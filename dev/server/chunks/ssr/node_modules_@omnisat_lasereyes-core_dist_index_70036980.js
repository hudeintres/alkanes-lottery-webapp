module.exports = [
"[project]/node_modules/@omnisat/lasereyes-core/dist/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ALKANES",
    ()=>Rk,
    "APPLICATION_ATOM_XML",
    ()=>Wve,
    "APPLICATION_FORM_URLENCODED",
    ()=>Vve,
    "APPLICATION_GZIP",
    ()=>Hve,
    "APPLICATION_JAVASCRIPT",
    ()=>Dve,
    "APPLICATION_JSON",
    ()=>Lve,
    "APPLICATION_OCTET_STREAM",
    ()=>Gve,
    "APPLICATION_PDF",
    ()=>zve,
    "APPLICATION_RSS_XML",
    ()=>Kve,
    "APPLICATION_XHTML_XML",
    ()=>qve,
    "APPLICATION_XML",
    ()=>Fve,
    "APPLICATION_ZIP",
    ()=>jve,
    "AUDIO_MP3",
    ()=>i2e,
    "AUDIO_OGG",
    ()=>s2e,
    "AUDIO_WAV",
    ()=>o2e,
    "BIP322",
    ()=>Xb,
    "BIP322_SIMPLE",
    ()=>l0,
    "BRC20",
    ()=>Nk,
    "BTC",
    ()=>Pk,
    "BaseNetwork",
    ()=>dt,
    "CmdruidNetwork",
    ()=>Qc,
    "DataSourceManager",
    ()=>nc,
    "ECDSA",
    ()=>f0,
    "FRACTAL_MAINNET",
    ()=>yc,
    "FRACTAL_TESTNET",
    ()=>co,
    "FractalNetwork",
    ()=>ME,
    "IMAGE_GIF",
    ()=>Xve,
    "IMAGE_ICON",
    ()=>e2e,
    "IMAGE_JPEG",
    ()=>Zve,
    "IMAGE_PNG",
    ()=>Yve,
    "IMAGE_SVG_XML",
    ()=>Jve,
    "IMAGE_WEBP",
    ()=>Qve,
    "KEPLR",
    ()=>Rl,
    "KeplrChain",
    ()=>cu,
    "LEATHER",
    ()=>Rh,
    "LOCAL_STORAGE_DEFAULT_WALLET",
    ()=>ev,
    "LaserEyesClient",
    ()=>u_e,
    "LeatherNetwork",
    ()=>Hl,
    "MAGIC_EDEN",
    ()=>ru,
    "MAINNET",
    ()=>ln,
    "MULTIPART_FORM_DATA",
    ()=>a2e,
    "MaestroDataSource",
    ()=>Yre,
    "MempoolSpaceDataSource",
    ()=>Xre,
    "OKX",
    ()=>Ch,
    "OP_NET",
    ()=>Nl,
    "ORANGE",
    ()=>Qu,
    "OYL",
    ()=>Il,
    "OYLNET",
    ()=>uP,
    "OkxNetwork",
    ()=>RE,
    "OpNetwork",
    ()=>EG,
    "OrangeNetwork",
    ()=>eu,
    "P2PKH",
    ()=>uG,
    "P2PSH",
    ()=>tve,
    "P2SH",
    ()=>Xp,
    "P2SH_P2WPKH",
    ()=>fG,
    "P2TR",
    ()=>df,
    "P2WPKH",
    ()=>Ay,
    "P2WSH",
    ()=>lG,
    "PHANTOM",
    ()=>Pl,
    "REGTEST",
    ()=>lve,
    "RUNES",
    ()=>Mk,
    "SIGNET",
    ()=>Ro,
    "SPARROW",
    ()=>Ml,
    "SUPPORTED_WALLETS",
    ()=>rve,
    "SandshrewDataSource",
    ()=>qae,
    "TESTNET",
    ()=>Ni,
    "TESTNET4",
    ()=>ao,
    "TEXT_CSS",
    ()=>Cve,
    "TEXT_HTML",
    ()=>Rve,
    "TEXT_JAVASCRIPT",
    ()=>Uve,
    "TEXT_MARKDOWN",
    ()=>$ve,
    "TEXT_PLAIN",
    ()=>Kre,
    "TOKEO",
    ()=>$h,
    "UNISAT",
    ()=>Bl,
    "UNSUPPORTED_PROVIDER_METHOD_ERROR",
    ()=>gB,
    "UnisatNetwork",
    ()=>ro,
    "VIDEO_MP4",
    ()=>t2e,
    "VIDEO_OGG",
    ()=>n2e,
    "VIDEO_WEBM",
    ()=>r2e,
    "WALLET_NOT_INSTALLED_ERROR",
    ()=>fme,
    "WIZZ",
    ()=>Uh,
    "WalletProvider",
    ()=>Do,
    "WizzNetwork",
    ()=>ko,
    "XVERSE",
    ()=>Ol,
    "XverseNetwork",
    ()=>Yu,
    "createConfig",
    ()=>c_e,
    "createStores",
    ()=>a_e,
    "getCmDruidNetwork",
    ()=>VQ,
    "getKeplrChainFromNetwork",
    ()=>WQ,
    "getLeatherNetwork",
    ()=>dve,
    "getNetworkForLeather",
    ()=>pve,
    "getNetworkForOkx",
    ()=>ZQ,
    "getNetworkForUnisat",
    ()=>om,
    "getNetworkForWizz",
    ()=>fk,
    "getNetworkForXverse",
    ()=>p_,
    "getNetworkFromKeplrChain",
    ()=>GQ,
    "getOrangeNetwork",
    ()=>h_,
    "getSatsConnectNetwork",
    ()=>d_,
    "getUnisatNetwork",
    ()=>fP,
    "getWizzNetwork",
    ()=>hve
]);
var RH = Object.defineProperty;
var CH = (e, t, r)=>t in e ? RH(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r;
var pt = (e, t, r)=>CH(e, typeof t != "symbol" ? t + "" : t, r);
function UH(e, t) {
    for(var r = 0; r < t.length; r++){
        const n = t[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for(const i in n)if (i !== "default" && !(i in e)) {
                const o = Object.getOwnPropertyDescriptor(n, i);
                o && Object.defineProperty(e, i, o.get ? o : {
                    enumerable: !0,
                    get: ()=>n[i]
                });
            }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }));
}
const zs = {
    /**
   * The message prefix used for signing Bitcoin messages.
   */ messagePrefix: `Bitcoin Signed Message:
`,
    /**
   * The Bech32 prefix used for Bitcoin addresses.
   */ bech32: "bc",
    /**
   * The BIP32 key prefixes for Bitcoin.
   */ bip32: {
        /**
     * The public key prefix for BIP32 extended public keys.
     */ public: 76067358,
        /**
     * The private key prefix for BIP32 extended private keys.
     */ private: 76066276
    },
    /**
   * The prefix for Bitcoin public key hashes.
   */ pubKeyHash: 0,
    /**
   * The prefix for Bitcoin script hashes.
   */ scriptHash: 5,
    /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */ wif: 128
}, $H = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
        public: 70617039,
        private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
};
function LH(e) {
    if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
    const t = e[3];
    if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
    const r = e[5 + t];
    return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function DH(e) {
    if (e.length < 8) throw new Error("DER sequence length is too short");
    if (e.length > 72) throw new Error("DER sequence length is too long");
    if (e[0] !== 48) throw new Error("Expected DER sequence");
    if (e[1] !== e.length - 2) throw new Error("DER sequence length is invalid");
    if (e[2] !== 2) throw new Error("Expected DER integer");
    const t = e[3];
    if (t === 0) throw new Error("R length is zero");
    if (5 + t >= e.length) throw new Error("R length is too long");
    if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
    const r = e[5 + t];
    if (r === 0) throw new Error("S length is zero");
    if (6 + t + r !== e.length) throw new Error("S length is invalid");
    if (e[4] & 128) throw new Error("R value is negative");
    if (t > 1 && e[4] === 0 && !(e[5] & 128)) throw new Error("R value excessively padded");
    if (e[t + 6] & 128) throw new Error("S value is negative");
    if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) throw new Error("S value excessively padded");
    return {
        r: e.slice(4, 4 + t),
        s: e.slice(6 + t)
    };
}
function FH(e, t) {
    const r = e.length, n = t.length;
    if (r === 0) throw new Error("R length is zero");
    if (n === 0) throw new Error("S length is zero");
    if (r > 33) throw new Error("R length is too long");
    if (n > 33) throw new Error("S length is too long");
    if (e[0] & 128) throw new Error("R value is negative");
    if (t[0] & 128) throw new Error("S value is negative");
    if (r > 1 && e[0] === 0 && !(e[1] & 128)) throw new Error("R value excessively padded");
    if (n > 1 && t[0] === 0 && !(t[1] & 128)) throw new Error("S value excessively padded");
    const i = new Uint8Array(6 + r + n);
    return i[0] = 48, i[1] = i.length - 2, i[2] = 2, i[3] = e.length, i.set(e, 4), i[4 + r] = 2, i[5 + r] = t.length, i.set(t, 6 + r), i;
}
const Kr = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
}, MB = {};
for (const e of Object.keys(Kr)){
    const t = Kr[e];
    MB[t] = e;
}
const Hy = "0123456789abcdefABCDEF", qy = Hy.split("").map((e)=>e.codePointAt(0)), Ky = Array(256).fill(!0).map((e, t)=>{
    const r = String.fromCodePoint(t), n = Hy.indexOf(r);
    return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), RB = new TextEncoder(), CB = new TextDecoder();
function zH(e) {
    return CB.decode(e);
}
function jH(e) {
    return RB.encode(e);
}
function kn(e) {
    const t = e.reduce((i, o)=>i + o.length, 0), r = new Uint8Array(t);
    let n = 0;
    for (const i of e)r.set(i, n), n += i.length;
    return r;
}
function rr(e) {
    const t = e || new Uint8Array();
    return t.length > 512 ? qH(t) : HH(t);
}
function HH(e) {
    let t = "";
    for(let r = 0; r < e.length; ++r)t += Hy[Ky[qy[e[r] >> 4]]], t += Hy[Ky[qy[e[r] & 15]]];
    return t;
}
function qH(e) {
    const t = new Uint8Array(e.length * 2);
    for(let r = 0; r < e.length; ++r)t[r * 2] = qy[e[r] >> 4], t[r * 2 + 1] = qy[e[r] & 15];
    return CB.decode(t);
}
function hc(e) {
    const t = RB.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
    let n;
    for(n = 0; n < r.length; n++){
        const i = Ky[t[n * 2]], o = Ky[t[n * 2 + 1]];
        if (i === void 0 || o === void 0) break;
        r[n] = i << 4 | o;
    }
    return n === r.length ? r : r.slice(0, n);
}
function KH(e) {
    return btoa(String.fromCharCode(...e));
}
function UB(e) {
    const t = atob(e), r = new Uint8Array(t.length);
    for(let n = 0; n < t.length; n++)r[n] = t.charCodeAt(n);
    return r;
}
function It(e, t) {
    const r = Math.min(e.length, t.length);
    for(let n = 0; n < r; ++n)if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
    return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function Po(e, t, r) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 255) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
    return e[t] = r, t + 1;
}
function WH(e, t, r, n) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 65535) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
    return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Wp(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 4294967295) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
    return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function VH(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 0xffffffffffffffffn) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
    return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function sc(e, t) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    return e[t];
}
function GH(e, t, r) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
    }
}
function wd(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
    }
}
function $B(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 2147483647 || r < -2147483648) throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
    return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function LB(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n) throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
    return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function ZH(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
        return e[t + 3] <= 127 ? n : n - 4294967296;
    } else {
        const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
        return e[t] <= 127 ? n : n - 4294967296;
    }
}
function DB(e, t, r) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    r = r.toUpperCase();
    let n = 0n;
    if (r === "LE") return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
    {
        let i = 0n;
        return i = (i << 8n) + BigInt(e[t]), i = (i << 8n) + BigInt(e[t + 1]), i = (i << 8n) + BigInt(e[t + 2]), i = (i << 8n) + BigInt(e[t + 3]), i = (i << 8n) + BigInt(e[t + 4]), i = (i << 8n) + BigInt(e[t + 5]), i = (i << 8n) + BigInt(e[t + 6]), i = (i << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i : i - 0x10000000000000000n;
    }
}
function FB(e) {
    return e < Kr.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function YH(e, t, r) {
    const n = FB(t);
    return n === 1 ? Po(e, r, t) : n === 2 ? (Po(e, r, Kr.OP_PUSHDATA1), Po(e, r + 1, t)) : n === 3 ? (Po(e, r, Kr.OP_PUSHDATA2), WH(e, r + 1, t, "LE")) : (Po(e, r, Kr.OP_PUSHDATA4), Wp(e, r + 1, t, "LE")), n;
}
function XH(e, t) {
    const r = sc(e, t);
    let n, i;
    if (r < Kr.OP_PUSHDATA1) n = r, i = 1;
    else if (r === Kr.OP_PUSHDATA1) {
        if (t + 2 > e.length) return null;
        n = sc(e, t + 1), i = 2;
    } else if (r === Kr.OP_PUSHDATA2) {
        if (t + 3 > e.length) return null;
        n = GH(e, t + 1, "LE"), i = 3;
    } else {
        if (t + 5 > e.length) return null;
        if (r !== Kr.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        n = wd(e, t + 1, "LE"), i = 5;
    }
    return {
        opcode: r,
        number: n,
        size: i
    };
}
function JH(e) {
    return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function QH(e) {
    let t = Math.abs(e);
    const r = JH(t), n = new Uint8Array(r), i = e < 0;
    for(let o = 0; o < r; ++o)Po(n, o, t & 255), t >>= 8;
    return n[r - 1] & 128 ? Po(n, r - 1, i ? 128 : 0) : i && (n[r - 1] |= 128), n;
}
var Da;
function eq(e) {
    return {
        lang: (e == null ? void 0 : e.lang) ?? (Da == null ? void 0 : Da.lang),
        message: e == null ? void 0 : e.message,
        abortEarly: (e == null ? void 0 : e.abortEarly) ?? (Da == null ? void 0 : Da.abortEarly),
        abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (Da == null ? void 0 : Da.abortPipeEarly)
    };
}
var Dw;
function tq(e) {
    return Dw == null ? void 0 : Dw.get(e);
}
var Fw;
function rq(e) {
    return Fw == null ? void 0 : Fw.get(e);
}
var zw;
function nq(e, t) {
    var r;
    return (r = zw == null ? void 0 : zw.get(e)) == null ? void 0 : r.get(t);
}
function Qh(e) {
    var r, n;
    const t = typeof e;
    return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function Ci(e, t, r, n, i) {
    const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? Qh(o), u = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: s,
        received: a,
        message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
        // @ts-expect-error
        requirement: e.requirement,
        path: i == null ? void 0 : i.path,
        issues: i == null ? void 0 : i.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, f = e.kind === "schema", c = (i == null ? void 0 : i.message) ?? // @ts-expect-error
    e.message ?? nq(e.reference, u.lang) ?? (f ? rq(u.lang) : null) ?? n.message ?? tq(u.lang);
    c && (u.message = typeof c == "function" ? c(u) : c), f && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [
        u
    ];
}
function iq(e, t) {
    const r = [
        ...new Set(e)
    ];
    return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var oq = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(r){
        super(r[0].message);
        /**
     * The error issues.
     */ pt(this, "issues");
        this.name = "ValiError", this.issues = r;
    }
};
function zB(e, t) {
    return {
        kind: "validation",
        type: "every_item",
        reference: zB,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !r.value.every(this.requirement) && Ci(this, "item", r, n), r;
        }
    };
}
function Zx(e) {
    return {
        kind: "validation",
        type: "integer",
        reference: Zx,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run (t, r) {
            return t.typed && !this.requirement(t.value) && Ci(this, "integer", t, r), t;
        }
    };
}
function jB(e, t) {
    return {
        kind: "validation",
        type: "length",
        reference: jB,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length !== this.requirement && Ci(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function nb(e, t) {
    return {
        kind: "validation",
        type: "max_value",
        reference: nb,
        async: !1,
        expects: `<=${e instanceof Date ? e.toJSON() : Qh(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value > this.requirement && Ci(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : Qh(r.value)
            }), r;
        }
    };
}
function ib(e, t) {
    return {
        kind: "validation",
        type: "min_value",
        reference: ib,
        async: !1,
        expects: `>=${e instanceof Date ? e.toJSON() : Qh(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value < this.requirement && Ci(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : Qh(r.value)
            }), r;
        }
    };
}
function HB(e, t) {
    return {
        kind: "validation",
        type: "regex",
        reference: HB,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement.test(r.value) && Ci(this, "format", r, n), r;
        }
    };
}
function Yx(e, t, r) {
    return typeof e.default == "function" ? // @ts-expect-error
    e.default(t, r) : // @ts-expect-error
    e.default;
}
function ob(e, t) {
    return !e._run({
        typed: !1,
        value: t
    }, {
        abortEarly: !0
    }).issues;
}
function qB() {
    return {
        kind: "schema",
        type: "any",
        reference: qB,
        expects: "any",
        async: !1,
        _run (e) {
            return e.typed = !0, e;
        }
    };
}
function lo(e, t) {
    return {
        kind: "schema",
        type: "array",
        reference: lo,
        expects: "Array",
        async: !1,
        item: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (Array.isArray(i)) {
                r.typed = !0, r.value = [];
                for(let s = 0; s < i.length; s++){
                    const a = i[s], u = this.item._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "array",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), r.value.push(u.value);
                }
            } else Ci(this, "type", r, n);
            return r;
        }
    };
}
function KB(e) {
    return {
        kind: "schema",
        type: "bigint",
        reference: KB,
        expects: "bigint",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "bigint" ? t.typed = !0 : Ci(this, "type", t, r), t;
        }
    };
}
function Ls(e, t) {
    return {
        kind: "schema",
        type: "custom",
        reference: Ls,
        expects: "unknown",
        async: !1,
        check: e,
        message: t,
        _run (r, n) {
            return this.check(r.value) ? r.typed = !0 : Ci(this, "type", r, n), r;
        }
    };
}
function sb(e, t) {
    return {
        kind: "schema",
        type: "instance",
        reference: sb,
        expects: e.name,
        async: !1,
        class: e,
        message: t,
        _run (r, n) {
            return r.value instanceof this.class ? r.typed = !0 : Ci(this, "type", r, n), r;
        }
    };
}
function vE(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullable",
        reference: vE,
        expects: `(${e.expects} | null)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return n.value === null && ("default" in this && (n.value = Yx(this, n, i)), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function WB(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullish",
        reference: WB,
        expects: `(${e.expects} | null | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return (n.value === null || n.value === void 0) && ("default" in this && (n.value = Yx(this, n, i)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function oo(e) {
    return {
        kind: "schema",
        type: "number",
        reference: oo,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Ci(this, "type", t, r), t;
        }
    };
}
function jn(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: jn,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
            } else Ci(this, "type", r, n);
            return r;
        }
    };
}
function Wy(e, ...t) {
    const r = {
        kind: "schema",
        type: "optional",
        reference: Wy,
        expects: `(${e.expects} | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return n.value === void 0 && ("default" in this && (n.value = Yx(this, n, i)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function Pf(e) {
    return {
        kind: "schema",
        type: "string",
        reference: Pf,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : Ci(this, "type", t, r), t;
        }
    };
}
function ca(e, t) {
    return {
        kind: "schema",
        type: "tuple",
        reference: ca,
        expects: "Array",
        async: !1,
        items: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (Array.isArray(i)) {
                r.typed = !0, r.value = [];
                for(let s = 0; s < this.items.length; s++){
                    const a = i[s], u = this.items[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "array",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), r.value.push(u.value);
                }
            } else Ci(this, "type", r, n);
            return r;
        }
    };
}
function I4(e) {
    let t;
    if (e) for (const r of e)t ? t.push(...r.issues) : t = r.issues;
    return t;
}
function Xx(e, t) {
    return {
        kind: "schema",
        type: "union",
        reference: Xx,
        expects: iq(e.map((r)=>r.expects), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            let i, o, s;
            for (const a of this.options){
                const u = a._run({
                    typed: !1,
                    value: r.value
                }, n);
                if (u.typed) if (u.issues) o ? o.push(u) : o = [
                    u
                ];
                else {
                    i = u;
                    break;
                }
                else s ? s.push(u) : s = [
                    u
                ];
            }
            if (i) return i;
            if (o) {
                if (o.length === 1) return o[0];
                Ci(this, "type", r, n, {
                    issues: I4(o)
                }), r.typed = !0;
            } else {
                if ((s == null ? void 0 : s.length) === 1) return s[0];
                Ci(this, "type", r, n, {
                    issues: I4(s)
                });
            }
            return r;
        }
    };
}
function En(e, t, r) {
    const n = e._run({
        typed: !1,
        value: t
    }, eq(r));
    if (n.issues) throw new oq(n.issues);
    return n.value;
}
function du(e, t) {
    const r = {};
    for(const n in e.entries)r[n] = Wy(e.entries[n]);
    return {
        ...e,
        entries: r
    };
}
function vd(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
const B4 = new Uint8Array(32), O4 = hc("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Yn = (e)=>vd(sb(Uint8Array), jB(e));
function ep(e, t) {
    return e.length !== t.length ? !1 : e.every((r, n)=>It(r, t[n]) === 0);
}
function Ms(e) {
    if (!(e instanceof Uint8Array) || e.length < 33) return !1;
    const t = e[0], r = e.slice(1, 33);
    if (It(B4, r) === 0 || It(r, O4) >= 0) return !1;
    if ((t === 2 || t === 3) && e.length === 33) return !0;
    const n = e.slice(33);
    return It(B4, n) === 0 || It(n, O4) >= 0 ? !1 : t === 4 && e.length === 65;
}
const xy = 254;
function Jx(e) {
    return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? !1 : e.version !== void 0 ? (e.version & xy) === e.version : !0;
}
function VB(e) {
    return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t)=>VB(t)) : Jx(e);
}
const sq = Yn(32), aq = Yn(20), P4 = Yn(32), tn = sb(Uint8Array);
vd(Pf(), HB(/^([0-9a-f]{2})+$/i));
const cq = vd(oo(), Zx(), ib(0), nb(255)), Za = vd(oo(), Zx(), ib(0), nb(4294967295)), jw = vd(KB(), ib(0n), nb(0x7fffffffffffffffn)), N4 = (e)=>jn(Object.entries(e).reduce((t, r)=>({
            ...t,
            [r[0]]: WB(r[1])
        }), {})), M4 = new Uint8Array(1);
function R4(e) {
    let t = 0;
    for(; e[t] === 0;)++t;
    return t === e.length ? M4 : (e = e.slice(t), e[0] & 128 ? kn([
        M4,
        e
    ]) : e);
}
function C4(e) {
    e[0] === 0 && (e = e.slice(1));
    const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
    return t.set(e, r), t;
}
function uq(e) {
    const t = sc(e, e.length - 1);
    if (!e3(t)) throw new Error("Invalid hashType " + t);
    const r = DH(e.subarray(0, -1)), n = C4(r.r), i = C4(r.s);
    return {
        signature: kn([
            n,
            i
        ]),
        hashType: t
    };
}
function fq(e, t) {
    if (En(jn({
        signature: Yn(64),
        hashType: cq
    }), {
        signature: e,
        hashType: t
    }), !e3(t)) throw new Error("Invalid hashType " + t);
    const r = new Uint8Array(1);
    Po(r, 0, t);
    const n = R4(e.slice(0, 32)), i = R4(e.slice(32, 64));
    return kn([
        FH(n, i),
        r
    ]);
}
const lq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    decode: uq,
    encode: fq
}, Symbol.toStringTag, {
    value: "Module"
})), GB = Kr.OP_RESERVED, ZB = lo(Xx([
    sb(Uint8Array),
    oo()
]));
function dq(e) {
    return ob(oo(), e) && (e === Kr.OP_0 || e >= Kr.OP_1 && e <= Kr.OP_16 || e === Kr.OP_1NEGATE);
}
function YB(e) {
    return ob(tn, e) || dq(e);
}
function Qx(e) {
    return ob(vd(qB(), zB(YB)), e);
}
function XB(e) {
    return e.length - e.filter(YB).length;
}
function Vy(e) {
    if (e.length === 0) return Kr.OP_0;
    if (e.length === 1) {
        if (e[0] >= 1 && e[0] <= 16) return GB + e[0];
        if (e[0] === 129) return Kr.OP_1NEGATE;
    }
}
function JB(e) {
    return e instanceof Uint8Array;
}
function hq(e) {
    return ob(ZB, e);
}
function Gy(e) {
    return e instanceof Uint8Array;
}
function Ri(e) {
    if (JB(e)) return e;
    En(ZB, e);
    const t = e.reduce((i, o)=>Gy(o) ? o.length === 1 && Vy(o) !== void 0 ? i + 1 : i + FB(o.length) + o.length : i + 1, 0), r = new Uint8Array(t);
    let n = 0;
    if (e.forEach((i)=>{
        if (Gy(i)) {
            const o = Vy(i);
            if (o !== void 0) {
                Po(r, n, o), n += 1;
                return;
            }
            n += YH(r, i.length, n), r.set(i, n), n += i.length;
        } else Po(r, n, i), n += 1;
    }), n !== r.length) throw new Error("Could not decode chunks");
    return r;
}
function Sn(e) {
    if (hq(e)) return e;
    En(tn, e);
    const t = [];
    let r = 0;
    for(; r < e.length;){
        const n = e[r];
        if (n > Kr.OP_0 && n <= Kr.OP_PUSHDATA4) {
            const i = XH(e, r);
            if (i === null || (r += i.size, r + i.number > e.length)) return null;
            const o = e.slice(r, r + i.number);
            r += i.number;
            const s = Vy(o);
            s !== void 0 ? t.push(s) : t.push(o);
        } else t.push(n), r += 1;
    }
    return t;
}
function pq(e) {
    if (JB(e) && (e = Sn(e)), !e) throw new Error("Could not convert invalid chunks to ASM");
    return e.map((t)=>{
        if (Gy(t)) {
            const r = Vy(t);
            if (r === void 0) return rr(t);
            t = r;
        }
        return MB[t];
    }).join(" ");
}
function gq(e) {
    return e = Sn(e), En(Ls(Qx), e), e.map((t)=>Gy(t) ? t : t === Kr.OP_0 ? new Uint8Array(0) : QH(t - GB));
}
function yq(e) {
    return Ms(e);
}
function e3(e) {
    const t = e & -129;
    return t > 0 && t < 4;
}
function ac(e) {
    return !(e instanceof Uint8Array) || !e3(e[e.length - 1]) ? !1 : LH(e.slice(0, -1));
}
const Nh = lq;
function Zt(e, t, r) {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !0,
        get () {
            const n = r.call(this);
            return this[t] = n, n;
        },
        set (n) {
            Object.defineProperty(this, t, {
                configurable: !0,
                enumerable: !0,
                value: n,
                writable: !0
            });
        }
    });
}
function fs(e) {
    let t;
    return ()=>(t !== void 0 || (t = e()), t);
}
const El = Kr, vg = El.OP_RESERVED;
function ab(e, t) {
    if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {});
    function r(u) {
        return ac(u) || (t.allowIncomplete && u === El.OP_0) !== void 0;
    }
    En(du(jn({
        network: jn({}),
        m: oo(),
        n: oo(),
        output: tn,
        pubkeys: lo(Ls(Ms), "Received invalid pubkey"),
        signatures: lo(Ls(r), "Expected signature to be of type isAcceptableSignature"),
        input: tn
    })), e);
    const i = {
        network: e.network || zs
    };
    let o = [], s = !1;
    function a(u) {
        s || (s = !0, o = Sn(u), i.m = o[0] - vg, i.n = o[o.length - 2] - vg, i.pubkeys = o.slice(1, -2));
    }
    if (Zt(i, "output", ()=>{
        if (e.m && i.n && e.pubkeys) return Ri([].concat(vg + e.m, e.pubkeys, vg + i.n, El.OP_CHECKMULTISIG));
    }), Zt(i, "m", ()=>{
        if (i.output) return a(i.output), i.m;
    }), Zt(i, "n", ()=>{
        if (i.pubkeys) return i.pubkeys.length;
    }), Zt(i, "pubkeys", ()=>{
        if (e.output) return a(e.output), i.pubkeys;
    }), Zt(i, "signatures", ()=>{
        if (e.input) return Sn(e.input).slice(1);
    }), Zt(i, "input", ()=>{
        if (e.signatures) return Ri([
            El.OP_0
        ].concat(e.signatures));
    }), Zt(i, "witness", ()=>{
        if (i.input) return [];
    }), Zt(i, "name", ()=>{
        if (!(!i.m || !i.n)) return `p2ms(${i.m} of ${i.n})`;
    }), t.validate) {
        if (e.output) {
            if (a(e.output), En(oo(), o[0], {
                message: "Output is invalid"
            }), En(oo(), o[o.length - 2], {
                message: "Output is invalid"
            }), o[o.length - 1] !== El.OP_CHECKMULTISIG) throw new TypeError("Output is invalid");
            if (i.m <= 0 || i.n > 16 || i.m > i.n || i.n !== o.length - 3) throw new TypeError("Output is invalid");
            if (!i.pubkeys.every((u)=>Ms(u))) throw new TypeError("Output is invalid");
            if (e.m !== void 0 && e.m !== i.m) throw new TypeError("m mismatch");
            if (e.n !== void 0 && e.n !== i.n) throw new TypeError("n mismatch");
            if (e.pubkeys && !ep(e.pubkeys, i.pubkeys)) throw new TypeError("Pubkeys mismatch");
        }
        if (e.pubkeys) {
            if (e.n !== void 0 && e.n !== e.pubkeys.length) throw new TypeError("Pubkey count mismatch");
            if (i.n = e.pubkeys.length, i.n < i.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (e.signatures) {
            if (e.signatures.length < i.m) throw new TypeError("Not enough signatures provided");
            if (e.signatures.length > i.m) throw new TypeError("Too many signatures provided");
        }
        if (e.input) {
            if (e.input[0] !== El.OP_0) throw new TypeError("Input is invalid");
            if (i.signatures.length === 0 || !i.signatures.every(r)) throw new TypeError("Input has invalid signature(s)");
            if (e.signatures && !ep(e.signatures, i.signatures)) throw new TypeError("Signature mismatch");
            if (e.m !== void 0 && e.m !== e.signatures.length) throw new TypeError("Signature count mismatch");
        }
    }
    return Object.assign(i, e);
}
const U4 = Kr;
function QB(e, t) {
    if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        network: jn({}),
        output: tn,
        pubkey: Ls(Ms, "invalid pubkey"),
        signature: Ls(ac, "Expected signature to be of type isCanonicalScriptSignature"),
        input: tn
    })), e);
    const r = fs(()=>Sn(e.input)), i = {
        name: "p2pk",
        network: e.network || zs
    };
    if (Zt(i, "output", ()=>{
        if (e.pubkey) return Ri([
            e.pubkey,
            U4.OP_CHECKSIG
        ]);
    }), Zt(i, "pubkey", ()=>{
        if (e.output) return e.output.slice(1, -1);
    }), Zt(i, "signature", ()=>{
        if (e.input) return r()[0];
    }), Zt(i, "input", ()=>{
        if (e.signature) return Ri([
            e.signature
        ]);
    }), Zt(i, "witness", ()=>{
        if (i.input) return [];
    }), t.validate) {
        if (e.output) {
            if (e.output[e.output.length - 1] !== U4.OP_CHECKSIG) throw new TypeError("Output is invalid");
            if (!Ms(i.pubkey)) throw new TypeError("Output pubkey is invalid");
            if (e.pubkey && It(e.pubkey, i.pubkey) !== 0) throw new TypeError("Pubkey mismatch");
        }
        if (e.signature && e.input && It(e.input, i.input) !== 0) throw new TypeError("Signature mismatch");
        if (e.input) {
            if (r().length !== 1) throw new TypeError("Input is invalid");
            if (!ac(i.signature)) throw new TypeError("Input has invalid signature");
        }
    }
    return Object.assign(i, e);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function mq(e) {
    return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function $4(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function cb(e, ...t) {
    if (!mq(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function bq(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    $4(e.outputLen), $4(e.blockLen);
}
function Zy(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function wq(e, t) {
    cb(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error("digestInto() expects output buffer of length at least " + r);
}
function hu(...e) {
    for(let t = 0; t < e.length; t++)e[t].fill(0);
}
function Hw(e) {
    return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function Vs(e, t) {
    return e << 32 - t | e >>> t;
}
function _g(e, t) {
    return e << t | e >>> 32 - t >>> 0;
}
function vq(e) {
    if (typeof e != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(e));
}
function t3(e) {
    return typeof e == "string" && (e = vq(e)), cb(e), e;
}
let e7 = class {
};
function r3(e) {
    const t = (n)=>e().update(t3(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function _q(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
function Eq(e, t, r) {
    return e & t ^ ~e & r;
}
function xq(e, t, r) {
    return e & t ^ e & r ^ t & r;
}
let n3 = class extends e7 {
    constructor(t, r, n, i){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Hw(this.buffer);
    }
    update(t) {
        Zy(this), t = t3(t), cb(t);
        const { view: r, buffer: n, blockLen: i } = this, o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = Hw(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        Zy(this), wq(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, hu(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        _q(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = Hw(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.destroyed = s, t.finished = o, t.length = i, t.pos = a, i % r && t.buffer.set(n), t;
    }
    clone() {
        return this._cloneInto();
    }
};
const Ic = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Ei = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]), Sq = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), t7 = Uint8Array.from(new Array(16).fill(0).map((e, t)=>t)), Aq = t7.map((e)=>(9 * e + 5) % 16), r7 = /* @__PURE__ */ (()=>{
    const r = [
        [
            t7
        ],
        [
            Aq
        ]
    ];
    for(let n = 0; n < 4; n++)for (let i of r)i.push(i[n].map((o)=>Sq[o]));
    return r;
})(), n7 = r7[0], i7 = r7[1], o7 = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>Uint8Array.from(e)), Tq = /* @__PURE__ */ n7.map((e, t)=>e.map((r)=>o7[t][r])), kq = /* @__PURE__ */ i7.map((e, t)=>e.map((r)=>o7[t][r])), Iq = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), Bq = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]);
function L4(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const Eg = /* @__PURE__ */ new Uint32Array(16);
let Oq = class extends n3 {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)Eg[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, u = a, f = this.h3 | 0, c = f, l = this.h4 | 0, p = l;
        for(let y = 0; y < 5; y++){
            const _ = 4 - y, A = Iq[y], O = Bq[y], N = n7[y], U = i7[y], D = Tq[y], H = kq[y];
            for(let K = 0; K < 16; K++){
                const re = _g(n + L4(y, o, a, f) + Eg[N[K]] + A, D[K]) + l | 0;
                n = l, l = f, f = _g(a, 10) | 0, a = o, o = re;
            }
            for(let K = 0; K < 16; K++){
                const re = _g(i + L4(_, s, u, c) + Eg[U[K]] + O, H[K]) + p | 0;
                i = p, p = c, c = _g(u, 10) | 0, u = s, s = re;
            }
        }
        this.set(this.h1 + a + c | 0, this.h2 + f + p | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + u | 0);
    }
    roundClean() {
        hu(Eg);
    }
    destroy() {
        this.destroyed = !0, hu(this.buffer), this.set(0, 0, 0, 0, 0);
    }
};
const Pq = /* @__PURE__ */ r3(()=>new Oq()), s7 = Pq, xg = /* @__PURE__ */ BigInt(2 ** 32 - 1), D4 = /* @__PURE__ */ BigInt(32);
function Nq(e, t = !1) {
    return t ? {
        h: Number(e & xg),
        l: Number(e >> D4 & xg)
    } : {
        h: Number(e >> D4 & xg) | 0,
        l: Number(e & xg) | 0
    };
}
function Mq(e, t = !1) {
    const r = e.length;
    let n = new Uint32Array(r), i = new Uint32Array(r);
    for(let o = 0; o < r; o++){
        const { h: s, l: a } = Nq(e[o], t);
        [n[o], i[o]] = [
            s,
            a
        ];
    }
    return [
        n,
        i
    ];
}
const F4 = (e, t, r)=>e >>> r, z4 = (e, t, r)=>e << 32 - r | t >>> r, al = (e, t, r)=>e >>> r | t << 32 - r, cl = (e, t, r)=>e << 32 - r | t >>> r, Sg = (e, t, r)=>e << 64 - r | t >>> r - 32, Ag = (e, t, r)=>e >>> r - 32 | t << 64 - r;
function Fa(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    };
}
const Rq = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0), Cq = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0, Uq = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), $q = (e, t, r, n, i)=>t + r + n + i + (e / 2 ** 32 | 0) | 0, Lq = (e, t, r, n, i)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Dq = (e, t, r, n, i, o)=>t + r + n + i + o + (e / 2 ** 32 | 0) | 0, Fq = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Bc = /* @__PURE__ */ new Uint32Array(64);
let zq = class extends n3 {
    constructor(t = 32){
        super(64, t, 8, !1), this.A = Ic[0] | 0, this.B = Ic[1] | 0, this.C = Ic[2] | 0, this.D = Ic[3] | 0, this.E = Ic[4] | 0, this.F = Ic[5] | 0, this.G = Ic[6] | 0, this.H = Ic[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Bc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Bc[l - 15], y = Bc[l - 2], _ = Vs(p, 7) ^ Vs(p, 18) ^ p >>> 3, A = Vs(y, 17) ^ Vs(y, 19) ^ y >>> 10;
            Bc[l] = A + Bc[l - 7] + _ + Bc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = Vs(a, 6) ^ Vs(a, 11) ^ Vs(a, 25), y = c + p + Eq(a, u, f) + Fq[l] + Bc[l] | 0, A = (Vs(n, 2) ^ Vs(n, 13) ^ Vs(n, 22)) + xq(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        hu(Bc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), hu(this.buffer);
    }
};
const a7 = Mq([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), jq = a7[0], Hq = a7[1], Oc = /* @__PURE__ */ new Uint32Array(80), Pc = /* @__PURE__ */ new Uint32Array(80);
let qq = class extends n3 {
    constructor(t = 64){
        super(128, t, 16, !1), this.Ah = Ei[0] | 0, this.Al = Ei[1] | 0, this.Bh = Ei[2] | 0, this.Bl = Ei[3] | 0, this.Ch = Ei[4] | 0, this.Cl = Ei[5] | 0, this.Dh = Ei[6] | 0, this.Dl = Ei[7] | 0, this.Eh = Ei[8] | 0, this.El = Ei[9] | 0, this.Fh = Ei[10] | 0, this.Fl = Ei[11] | 0, this.Gh = Ei[12] | 0, this.Gl = Ei[13] | 0, this.Hh = Ei[14] | 0, this.Hl = Ei[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: u, Eh: f, El: c, Fh: l, Fl: p, Gh: y, Gl: _, Hh: A, Hl: O } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u,
            f,
            c,
            l,
            p,
            y,
            _,
            A,
            O
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = f | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = A | 0, this.Hl = O | 0;
    }
    process(t, r) {
        for(let D = 0; D < 16; D++, r += 4)Oc[D] = t.getUint32(r), Pc[D] = t.getUint32(r += 4);
        for(let D = 16; D < 80; D++){
            const H = Oc[D - 15] | 0, K = Pc[D - 15] | 0, re = al(H, K, 1) ^ al(H, K, 8) ^ F4(H, K, 7), Q = cl(H, K, 1) ^ cl(H, K, 8) ^ z4(H, K, 7), G = Oc[D - 2] | 0, R = Pc[D - 2] | 0, X = al(G, R, 19) ^ Sg(G, R, 61) ^ F4(G, R, 6), $ = cl(G, R, 19) ^ Ag(G, R, 61) ^ z4(G, R, 6), S = Uq(Q, $, Pc[D - 7], Pc[D - 16]), w = $q(S, re, X, Oc[D - 7], Oc[D - 16]);
            Oc[D] = w | 0, Pc[D] = S | 0;
        }
        let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: u, Dh: f, Dl: c, Eh: l, El: p, Fh: y, Fl: _, Gh: A, Gl: O, Hh: N, Hl: U } = this;
        for(let D = 0; D < 80; D++){
            const H = al(l, p, 14) ^ al(l, p, 18) ^ Sg(l, p, 41), K = cl(l, p, 14) ^ cl(l, p, 18) ^ Ag(l, p, 41), re = l & y ^ ~l & A, Q = p & _ ^ ~p & O, G = Lq(U, K, Q, Hq[D], Pc[D]), R = Dq(G, N, H, re, jq[D], Oc[D]), X = G | 0, $ = al(n, i, 28) ^ Sg(n, i, 34) ^ Sg(n, i, 39), S = cl(n, i, 28) ^ Ag(n, i, 34) ^ Ag(n, i, 39), w = n & o ^ n & a ^ o & a, g = i & s ^ i & u ^ s & u;
            N = A | 0, U = O | 0, A = y | 0, O = _ | 0, y = l | 0, _ = p | 0, ({ h: l, l: p } = Fa(f | 0, c | 0, R | 0, X | 0)), f = a | 0, c = u | 0, a = o | 0, u = s | 0, o = n | 0, s = i | 0;
            const m = Rq(X, S, g);
            n = Cq(m, R, $, w), i = m | 0;
        }
        ({ h: n, l: i } = Fa(this.Ah | 0, this.Al | 0, n | 0, i | 0)), ({ h: o, l: s } = Fa(this.Bh | 0, this.Bl | 0, o | 0, s | 0)), ({ h: a, l: u } = Fa(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: f, l: c } = Fa(this.Dh | 0, this.Dl | 0, f | 0, c | 0)), ({ h: l, l: p } = Fa(this.Eh | 0, this.El | 0, l | 0, p | 0)), ({ h: y, l: _ } = Fa(this.Fh | 0, this.Fl | 0, y | 0, _ | 0)), ({ h: A, l: O } = Fa(this.Gh | 0, this.Gl | 0, A | 0, O | 0)), ({ h: N, l: U } = Fa(this.Hh | 0, this.Hl | 0, N | 0, U | 0)), this.set(n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U);
    }
    roundClean() {
        hu(Oc, Pc);
    }
    destroy() {
        hu(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
const Kq = /* @__PURE__ */ r3(()=>new zq()), Wq = /* @__PURE__ */ r3(()=>new qq()), pi = Kq;
function Rs(e) {
    return s7(pi(e));
}
function ju(e) {
    return pi(pi(e));
}
const Vq = {
    "BIP0340/challenge": Uint8Array.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
    ]),
    "BIP0340/aux": Uint8Array.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
    ]),
    "BIP0340/nonce": Uint8Array.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
    ]),
    TapLeaf: Uint8Array.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
    ]),
    TapBranch: Uint8Array.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
    ]),
    TapSighash: Uint8Array.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
    ]),
    TapTweak: Uint8Array.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
    ]),
    "KeyAgg list": Uint8Array.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
    ]),
    "KeyAgg coefficient": Uint8Array.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
    ])
};
function ub(e, t) {
    return pi(kn([
        Vq[e],
        t
    ]));
}
function Gq(e) {
    if (e.length >= 255) throw new TypeError("Alphabet too long");
    const t = new Uint8Array(256);
    for(let f = 0; f < t.length; f++)t[f] = 255;
    for(let f = 0; f < e.length; f++){
        const c = e.charAt(f), l = c.charCodeAt(0);
        if (t[l] !== 255) throw new TypeError(c + " is ambiguous");
        t[l] = f;
    }
    const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
    function s(f) {
        if (f instanceof Uint8Array || (ArrayBuffer.isView(f) ? f = new Uint8Array(f.buffer, f.byteOffset, f.byteLength) : Array.isArray(f) && (f = Uint8Array.from(f))), !(f instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (f.length === 0) return "";
        let c = 0, l = 0, p = 0;
        const y = f.length;
        for(; p !== y && f[p] === 0;)p++, c++;
        const _ = (y - p) * o + 1 >>> 0, A = new Uint8Array(_);
        for(; p !== y;){
            let U = f[p], D = 0;
            for(let H = _ - 1; (U !== 0 || D < l) && H !== -1; H--, D++)U += 256 * A[H] >>> 0, A[H] = U % r >>> 0, U = U / r >>> 0;
            if (U !== 0) throw new Error("Non-zero carry");
            l = D, p++;
        }
        let O = _ - l;
        for(; O !== _ && A[O] === 0;)O++;
        let N = n.repeat(c);
        for(; O < _; ++O)N += e.charAt(A[O]);
        return N;
    }
    function a(f) {
        if (typeof f != "string") throw new TypeError("Expected String");
        if (f.length === 0) return new Uint8Array();
        let c = 0, l = 0, p = 0;
        for(; f[c] === n;)l++, c++;
        const y = (f.length - c) * i + 1 >>> 0, _ = new Uint8Array(y);
        for(; c < f.length;){
            const U = f.charCodeAt(c);
            if (U > 255) return;
            let D = t[U];
            if (D === 255) return;
            let H = 0;
            for(let K = y - 1; (D !== 0 || H < p) && K !== -1; K--, H++)D += r * _[K] >>> 0, _[K] = D % 256 >>> 0, D = D / 256 >>> 0;
            if (D !== 0) throw new Error("Non-zero carry");
            p = H, c++;
        }
        let A = y - p;
        for(; A !== y && _[A] === 0;)A++;
        const O = new Uint8Array(l + (y - A));
        let N = l;
        for(; A !== y;)O[N++] = _[A++];
        return O;
    }
    function u(f) {
        const c = a(f);
        if (c) return c;
        throw new Error("Non-base" + r + " character");
    }
    return {
        encode: s,
        decodeUnsafe: a,
        decode: u
    };
}
var Zq = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const qw = Gq(Zq);
function Yq(e) {
    function t(o) {
        var s = Uint8Array.from(o), a = e(s), u = s.length + 4, f = new Uint8Array(u);
        return f.set(s, 0), f.set(a.subarray(0, 4), s.length), qw.encode(f);
    }
    function r(o) {
        var s = o.slice(0, -4), a = o.slice(-4), u = e(s);
        if (!(a[0] ^ u[0] | a[1] ^ u[1] | a[2] ^ u[2] | a[3] ^ u[3])) return s;
    }
    function n(o) {
        var s = qw.decodeUnsafe(o);
        if (s != null) return r(s);
    }
    function i(o) {
        var s = qw.decode(o), a = r(s);
        if (a == null) throw new Error("Invalid checksum");
        return a;
    }
    return {
        encode: t,
        decode: i,
        decodeUnsafe: n
    };
}
function Xq(e) {
    return pi(pi(e));
}
const Ql = Yq(Xq), Nc = Kr;
function Vp(e, t) {
    if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        network: jn({}),
        address: Pf(),
        hash: aq,
        output: Yn(25),
        pubkey: Ls(Ms),
        signature: Ls(ac),
        input: tn
    })), e);
    const r = fs(()=>{
        const s = Ql.decode(e.address), a = sc(s, 0), u = s.slice(1);
        return {
            version: a,
            hash: u
        };
    }), n = fs(()=>Sn(e.input)), i = e.network || zs, o = {
        name: "p2pkh",
        network: i
    };
    if (Zt(o, "address", ()=>{
        if (!o.hash) return;
        const s = new Uint8Array(21);
        return Po(s, 0, i.pubKeyHash), s.set(o.hash, 1), Ql.encode(s);
    }), Zt(o, "hash", ()=>{
        if (e.output) return e.output.slice(3, 23);
        if (e.address) return r().hash;
        if (e.pubkey || o.pubkey) return Rs(e.pubkey || o.pubkey);
    }), Zt(o, "output", ()=>{
        if (o.hash) return Ri([
            Nc.OP_DUP,
            Nc.OP_HASH160,
            o.hash,
            Nc.OP_EQUALVERIFY,
            Nc.OP_CHECKSIG
        ]);
    }), Zt(o, "pubkey", ()=>{
        if (e.input) return n()[1];
    }), Zt(o, "signature", ()=>{
        if (e.input) return n()[0];
    }), Zt(o, "input", ()=>{
        if (e.pubkey && e.signature) return Ri([
            e.signature,
            e.pubkey
        ]);
    }), Zt(o, "witness", ()=>{
        if (o.input) return [];
    }), t.validate) {
        let s = Uint8Array.from([]);
        if (e.address) {
            if (r().version !== i.pubKeyHash) throw new TypeError("Invalid version or Network mismatch");
            if (r().hash.length !== 20) throw new TypeError("Invalid address");
            s = r().hash;
        }
        if (e.hash) {
            if (s.length > 0 && It(s, e.hash) !== 0) throw new TypeError("Hash mismatch");
            s = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 25 || e.output[0] !== Nc.OP_DUP || e.output[1] !== Nc.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== Nc.OP_EQUALVERIFY || e.output[24] !== Nc.OP_CHECKSIG) throw new TypeError("Output is invalid");
            const a = e.output.slice(3, 23);
            if (s.length > 0 && It(s, a) !== 0) throw new TypeError("Hash mismatch");
            s = a;
        }
        if (e.pubkey) {
            const a = Rs(e.pubkey);
            if (s.length > 0 && It(s, a) !== 0) throw new TypeError("Hash mismatch");
            s = a;
        }
        if (e.input) {
            const a = n();
            if (a.length !== 2) throw new TypeError("Input is invalid");
            if (!ac(a[0])) throw new TypeError("Input has invalid signature");
            if (!Ms(a[1])) throw new TypeError("Input has invalid pubkey");
            if (e.signature && It(e.signature, a[0]) !== 0) throw new TypeError("Signature mismatch");
            if (e.pubkey && It(e.pubkey, a[1]) !== 0) throw new TypeError("Pubkey mismatch");
            const u = Rs(a[1]);
            if (s.length > 0 && It(s, u) !== 0) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(o, e);
}
const uh = Kr;
function _d(e, t) {
    if (!e.address && !e.hash && !e.output && !e.redeem && !e.input) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        network: jn({}),
        address: Pf(),
        hash: Yn(20),
        output: Yn(23),
        redeem: du(jn({
            network: jn({}),
            output: tn,
            input: tn,
            witness: lo(tn)
        })),
        input: tn,
        witness: lo(tn)
    })), e);
    let r = e.network;
    r || (r = e.redeem && e.redeem.network || zs);
    const n = {
        network: r
    }, i = fs(()=>{
        const a = Ql.decode(e.address), u = sc(a, 0), f = a.slice(1);
        return {
            version: u,
            hash: f
        };
    }), o = fs(()=>Sn(e.input)), s = fs(()=>{
        const a = o(), u = a[a.length - 1];
        return {
            network: r,
            output: u === uh.OP_FALSE ? Uint8Array.from([]) : u,
            input: Ri(a.slice(0, -1)),
            witness: e.witness || []
        };
    });
    if (Zt(n, "address", ()=>{
        if (!n.hash) return;
        const a = new Uint8Array(21);
        return Po(a, 0, n.network.scriptHash), a.set(n.hash, 1), Ql.encode(a);
    }), Zt(n, "hash", ()=>{
        if (e.output) return e.output.slice(2, 22);
        if (e.address) return i().hash;
        if (n.redeem && n.redeem.output) return Rs(n.redeem.output);
    }), Zt(n, "output", ()=>{
        if (n.hash) return Ri([
            uh.OP_HASH160,
            n.hash,
            uh.OP_EQUAL
        ]);
    }), Zt(n, "redeem", ()=>{
        if (e.input) return s();
    }), Zt(n, "input", ()=>{
        if (!(!e.redeem || !e.redeem.input || !e.redeem.output)) return Ri([].concat(Sn(e.redeem.input), e.redeem.output));
    }), Zt(n, "witness", ()=>{
        if (n.redeem && n.redeem.witness) return n.redeem.witness;
        if (n.input) return [];
    }), Zt(n, "name", ()=>{
        const a = [
            "p2sh"
        ];
        return n.redeem !== void 0 && n.redeem.name !== void 0 && a.push(n.redeem.name), a.join("-");
    }), t.validate) {
        let a = Uint8Array.from([]);
        if (e.address) {
            if (i().version !== r.scriptHash) throw new TypeError("Invalid version or Network mismatch");
            if (i().hash.length !== 20) throw new TypeError("Invalid address");
            a = i().hash;
        }
        if (e.hash) {
            if (a.length > 0 && It(a, e.hash) !== 0) throw new TypeError("Hash mismatch");
            a = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 23 || e.output[0] !== uh.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== uh.OP_EQUAL) throw new TypeError("Output is invalid");
            const f = e.output.slice(2, 22);
            if (a.length > 0 && It(a, f) !== 0) throw new TypeError("Hash mismatch");
            a = f;
        }
        const u = (f)=>{
            if (f.output) {
                const c = Sn(f.output);
                if (!c || c.length < 1) throw new TypeError("Redeem.output too short");
                if (f.output.byteLength > 520) throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
                if (XB(c) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
                const l = Rs(f.output);
                if (a.length > 0 && It(a, l) !== 0) throw new TypeError("Hash mismatch");
                a = l;
            }
            if (f.input) {
                const c = f.input.length > 0, l = f.witness && f.witness.length > 0;
                if (!c && !l) throw new TypeError("Empty input");
                if (c && l) throw new TypeError("Input and witness provided");
                if (c) {
                    const p = Sn(f.input);
                    if (!Qx(p)) throw new TypeError("Non push-only scriptSig");
                }
            }
        };
        if (e.input) {
            const f = o();
            if (!f || f.length < 1) throw new TypeError("Input too short");
            if (!(s().output instanceof Uint8Array)) throw new TypeError("Input is invalid");
            u(s());
        }
        if (e.redeem) {
            if (e.redeem.network && e.redeem.network !== r) throw new TypeError("Network mismatch");
            if (e.input) {
                const f = s();
                if (e.redeem.output && It(e.redeem.output, f.output) !== 0) throw new TypeError("Redeem.output mismatch");
                if (e.redeem.input && It(e.redeem.input, f.input) !== 0) throw new TypeError("Redeem.input mismatch");
            }
            u(e.redeem);
        }
        if (e.witness && e.redeem && e.redeem.witness && !ep(e.redeem.witness, e.witness)) throw new TypeError("Witness and redeem.witness mismatch");
    }
    return Object.assign(n, e);
}
var Ge = typeof globalThis < "u" ? globalThis : ("TURBOPACK compile-time value", "undefined") < "u" ? window : ("TURBOPACK compile-time value", "object") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g : typeof self < "u" ? self : {};
function c7(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Jq(e) {
    if (e.__esModule) return e;
    var t = e.default;
    if (typeof t == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
        };
        r.prototype = t.prototype;
    } else r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(n) {
        var i = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(r, n, i.get ? i : {
            enumerable: !0,
            get: function() {
                return e[n];
            }
        });
    }), r;
}
var tp = {};
Object.defineProperty(tp, "__esModule", {
    value: !0
});
var rp = tp.bech32m = No = tp.bech32 = void 0;
const Yy = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", u7 = {};
for(let e = 0; e < Yy.length; e++){
    const t = Yy.charAt(e);
    u7[t] = e;
}
function Fl(e) {
    const t = e >> 25;
    return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function j4(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = e.charCodeAt(r);
        if (n < 33 || n > 126) return "Invalid prefix (" + e + ")";
        t = Fl(t) ^ n >> 5;
    }
    t = Fl(t);
    for(let r = 0; r < e.length; ++r){
        const n = e.charCodeAt(r);
        t = Fl(t) ^ n & 31;
    }
    return t;
}
function i3(e, t, r, n) {
    let i = 0, o = 0;
    const s = (1 << r) - 1, a = [];
    for(let u = 0; u < e.length; ++u)for(i = i << t | e[u], o += t; o >= r;)o -= r, a.push(i >> o & s);
    if (n) o > 0 && a.push(i << r - o & s);
    else {
        if (o >= t) return "Excess padding";
        if (i << r - o & s) return "Non-zero padding";
    }
    return a;
}
function Qq(e) {
    return i3(e, 8, 5, !0);
}
function eK(e) {
    const t = i3(e, 5, 8, !1);
    if (Array.isArray(t)) return t;
}
function tK(e) {
    const t = i3(e, 5, 8, !1);
    if (Array.isArray(t)) return t;
    throw new Error(t);
}
function f7(e) {
    let t;
    e === "bech32" ? t = 1 : t = 734539939;
    function r(s, a, u) {
        if (u = u || 90, s.length + 7 + a.length > u) throw new TypeError("Exceeds length limit");
        s = s.toLowerCase();
        let f = j4(s);
        if (typeof f == "string") throw new Error(f);
        let c = s + "1";
        for(let l = 0; l < a.length; ++l){
            const p = a[l];
            if (p >> 5) throw new Error("Non 5-bit word");
            f = Fl(f) ^ p, c += Yy.charAt(p);
        }
        for(let l = 0; l < 6; ++l)f = Fl(f);
        f ^= t;
        for(let l = 0; l < 6; ++l){
            const p = f >> (5 - l) * 5 & 31;
            c += Yy.charAt(p);
        }
        return c;
    }
    function n(s, a) {
        if (a = a || 90, s.length < 8) return s + " too short";
        if (s.length > a) return "Exceeds length limit";
        const u = s.toLowerCase(), f = s.toUpperCase();
        if (s !== u && s !== f) return "Mixed-case string " + s;
        s = u;
        const c = s.lastIndexOf("1");
        if (c === -1) return "No separator character for " + s;
        if (c === 0) return "Missing prefix for " + s;
        const l = s.slice(0, c), p = s.slice(c + 1);
        if (p.length < 6) return "Data too short";
        let y = j4(l);
        if (typeof y == "string") return y;
        const _ = [];
        for(let A = 0; A < p.length; ++A){
            const O = p.charAt(A), N = u7[O];
            if (N === void 0) return "Unknown character " + O;
            y = Fl(y) ^ N, !(A + 6 >= p.length) && _.push(N);
        }
        return y !== t ? "Invalid checksum for " + s : {
            prefix: l,
            words: _
        };
    }
    function i(s, a) {
        const u = n(s, a);
        if (typeof u == "object") return u;
    }
    function o(s, a) {
        const u = n(s, a);
        if (typeof u == "object") return u;
        throw new Error(u);
    }
    return {
        decodeUnsafe: i,
        decode: o,
        encode: r,
        toWords: Qq,
        fromWordsUnsafe: eK,
        fromWords: tK
    };
}
var No = tp.bech32 = f7("bech32");
rp = tp.bech32m = f7("bech32m");
const H4 = Kr, rK = new Uint8Array(0);
function Gp(e, t) {
    if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        address: Pf(),
        hash: Yn(20),
        input: Yn(0),
        network: jn({}),
        output: Yn(22),
        pubkey: Ls(Ms, "Not a valid pubkey"),
        signature: Ls(ac),
        witness: lo(tn)
    })), e);
    const r = fs(()=>{
        const o = No.decode(e.address), s = o.words.shift(), a = No.fromWords(o.words);
        return {
            version: s,
            prefix: o.prefix,
            data: Uint8Array.from(a)
        };
    }), n = e.network || zs, i = {
        name: "p2wpkh",
        network: n
    };
    if (Zt(i, "address", ()=>{
        if (!i.hash) return;
        const o = No.toWords(i.hash);
        return o.unshift(0), No.encode(n.bech32, o);
    }), Zt(i, "hash", ()=>{
        if (e.output) return e.output.slice(2, 22);
        if (e.address) return r().data;
        if (e.pubkey || i.pubkey) return Rs(e.pubkey || i.pubkey);
    }), Zt(i, "output", ()=>{
        if (i.hash) return Ri([
            H4.OP_0,
            i.hash
        ]);
    }), Zt(i, "pubkey", ()=>{
        if (e.pubkey) return e.pubkey;
        if (e.witness) return e.witness[1];
    }), Zt(i, "signature", ()=>{
        if (e.witness) return e.witness[0];
    }), Zt(i, "input", ()=>{
        if (i.witness) return rK;
    }), Zt(i, "witness", ()=>{
        if (e.pubkey && e.signature) return [
            e.signature,
            e.pubkey
        ];
    }), t.validate) {
        let o = Uint8Array.from([]);
        if (e.address) {
            if (n && n.bech32 !== r().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== 0) throw new TypeError("Invalid address version");
            if (r().data.length !== 20) throw new TypeError("Invalid address data");
            o = r().data;
        }
        if (e.hash) {
            if (o.length > 0 && It(o, e.hash) !== 0) throw new TypeError("Hash mismatch");
            o = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 22 || e.output[0] !== H4.OP_0 || e.output[1] !== 20) throw new TypeError("Output is invalid");
            if (o.length > 0 && It(o, e.output.slice(2)) !== 0) throw new TypeError("Hash mismatch");
            o = e.output.slice(2);
        }
        if (e.pubkey) {
            const s = Rs(e.pubkey);
            if (o.length > 0 && It(o, s) !== 0) throw new TypeError("Hash mismatch");
            if (o = s, !Ms(e.pubkey) || e.pubkey.length !== 33) throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (e.witness) {
            if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
            if (!ac(e.witness[0])) throw new TypeError("Witness has invalid signature");
            if (!Ms(e.witness[1]) || e.witness[1].length !== 33) throw new TypeError("Witness has invalid pubkey");
            if (e.signature && It(e.signature, e.witness[0]) !== 0) throw new TypeError("Signature mismatch");
            if (e.pubkey && It(e.pubkey, e.witness[1]) !== 0) throw new TypeError("Pubkey mismatch");
            const s = Rs(e.witness[1]);
            if (o.length > 0 && It(o, s) !== 0) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(i, e);
}
const q4 = Kr, Kw = new Uint8Array(0);
function Tg(e) {
    return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && Ms(e));
}
function Zp(e, t) {
    if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(N4({
        network: jn({}),
        address: Pf(),
        hash: sq,
        output: Yn(34),
        redeem: N4({
            input: tn,
            network: jn({}),
            output: tn,
            witness: lo(tn)
        }),
        input: Yn(0),
        witness: lo(tn)
    }), e);
    const r = fs(()=>{
        const s = No.decode(e.address), a = s.words.shift(), u = No.fromWords(s.words);
        return {
            version: a,
            prefix: s.prefix,
            data: Uint8Array.from(u)
        };
    }), n = fs(()=>Sn(e.redeem.input));
    let i = e.network;
    i || (i = e.redeem && e.redeem.network || zs);
    const o = {
        network: i
    };
    if (Zt(o, "address", ()=>{
        if (!o.hash) return;
        const s = No.toWords(o.hash);
        return s.unshift(0), No.encode(i.bech32, s);
    }), Zt(o, "hash", ()=>{
        if (e.output) return e.output.slice(2);
        if (e.address) return r().data;
        if (o.redeem && o.redeem.output) return pi(o.redeem.output);
    }), Zt(o, "output", ()=>{
        if (o.hash) return Ri([
            q4.OP_0,
            o.hash
        ]);
    }), Zt(o, "redeem", ()=>{
        if (e.witness) return {
            output: e.witness[e.witness.length - 1],
            input: Kw,
            witness: e.witness.slice(0, -1)
        };
    }), Zt(o, "input", ()=>{
        if (o.witness) return Kw;
    }), Zt(o, "witness", ()=>{
        if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
            const s = gq(n());
            return o.redeem = Object.assign({
                witness: s
            }, e.redeem), o.redeem.input = Kw, [].concat(s, e.redeem.output);
        }
        if (e.redeem && e.redeem.output && e.redeem.witness) return [].concat(e.redeem.witness, e.redeem.output);
    }), Zt(o, "name", ()=>{
        const s = [
            "p2wsh"
        ];
        return o.redeem !== void 0 && o.redeem.name !== void 0 && s.push(o.redeem.name), s.join("-");
    }), t.validate) {
        let s = Uint8Array.from([]);
        if (e.address) {
            if (r().prefix !== i.bech32) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== 0) throw new TypeError("Invalid address version");
            if (r().data.length !== 32) throw new TypeError("Invalid address data");
            s = r().data;
        }
        if (e.hash) {
            if (s.length > 0 && It(s, e.hash) !== 0) throw new TypeError("Hash mismatch");
            s = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 34 || e.output[0] !== q4.OP_0 || e.output[1] !== 32) throw new TypeError("Output is invalid");
            const a = e.output.slice(2);
            if (s.length > 0 && It(s, a) !== 0) throw new TypeError("Hash mismatch");
            s = a;
        }
        if (e.redeem) {
            if (e.redeem.network && e.redeem.network !== i) throw new TypeError("Network mismatch");
            if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0) throw new TypeError("Ambiguous witness source");
            if (e.redeem.output) {
                const a = Sn(e.redeem.output);
                if (!a || a.length < 1) throw new TypeError("Redeem.output is invalid");
                if (e.redeem.output.byteLength > 3600) throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
                if (XB(a) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
                const u = pi(e.redeem.output);
                if (s.length > 0 && It(s, u) !== 0) throw new TypeError("Hash mismatch");
                s = u;
            }
            if (e.redeem.input && !Qx(n())) throw new TypeError("Non push-only scriptSig");
            if (e.witness && e.redeem.witness && !ep(e.witness, e.redeem.witness)) throw new TypeError("Witness and redeem.witness mismatch");
            if (e.redeem.input && n().some(Tg) || e.redeem.output && (Sn(e.redeem.output) || []).some(Tg)) throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
        }
        if (e.witness && e.witness.length > 0) {
            const a = e.witness[e.witness.length - 1];
            if (e.redeem && e.redeem.output && It(e.redeem.output, a) !== 0) throw new TypeError("Witness and redeem.output mismatch");
            if (e.witness.some(Tg) || (Sn(a) || []).some(Tg)) throw new TypeError("Witness contains uncompressed pubkey");
        }
    }
    return Object.assign(o, e);
}
const Mh = {};
function o3(e) {
    e ? e !== Mh.eccLib && (nK(e), Mh.eccLib = e) : Mh.eccLib = e;
}
function _E() {
    if (!Mh.eccLib) throw new Error("No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance");
    return Mh.eccLib;
}
const za = (e)=>hc(e);
function nK(e) {
    Go(typeof e.isXOnlyPoint == "function"), Go(e.isXOnlyPoint(za("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Go(e.isXOnlyPoint(za("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e"))), Go(e.isXOnlyPoint(za("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9"))), Go(e.isXOnlyPoint(za("0000000000000000000000000000000000000000000000000000000000000001"))), Go(!e.isXOnlyPoint(za("0000000000000000000000000000000000000000000000000000000000000000"))), Go(!e.isXOnlyPoint(za("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"))), Go(typeof e.xOnlyPointAddTweak == "function"), iK.forEach((t)=>{
        const r = e.xOnlyPointAddTweak(za(t.pubkey), za(t.tweak));
        t.result === null ? Go(r === null) : (Go(r !== null), Go(r.parity === t.parity), Go(It(r.xOnlyPubkey, za(t.result)) === 0));
    });
}
function Go(e) {
    if (!e) throw new Error("ecc library invalid");
}
const iK = [
    {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
    },
    {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
    },
    {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
    }
], l7 = "0123456789abcdefABCDEF";
l7.split("").map((e)=>e.codePointAt(0));
const K4 = Array(256).fill(!0).map((e, t)=>{
    const r = String.fromCodePoint(t), n = l7.indexOf(r);
    return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), d7 = new TextEncoder();
new TextDecoder();
function oK(e) {
    return d7.encode(e);
}
function sK(e) {
    const t = e.reduce((i, o)=>i + o.length, 0), r = new Uint8Array(t);
    let n = 0;
    for (const i of e)r.set(i, n), n += i.length;
    return r;
}
function aK(e) {
    const t = d7.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
    let n;
    for(n = 0; n < r.length; n++){
        const i = K4[t[n * 2]], o = K4[t[n * 2 + 1]];
        if (i === void 0 || o === void 0) break;
        r[n] = i << 4 | o;
    }
    return n === r.length ? r : r.slice(0, n);
}
function ja(e, t) {
    const r = Math.min(e.length, t.length);
    for(let n = 0; n < r; ++n)if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
    return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function W4(e, t, r) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 255) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
    e[t] = r;
}
function cK(e, t, r, n) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 65535) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
    n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Zu(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 4294967295) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
    n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function uK(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 0xffffffffffffffffn) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
    n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function fK(e, t, r) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
    }
}
function xl(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
    }
}
function lK(e, t, r) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0n;
        return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
    } else {
        let n = 0n;
        return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
    }
}
const dK = (e)=>{
    if (e < 0 || e > 0xffffffffffffffffn) throw new RangeError("value out of range");
};
function hK(e) {
    if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0) throw new RangeError("value out of range");
}
function h7(e) {
    typeof e == "number" ? hK(e) : dK(e);
}
function pu(e, t, r) {
    h7(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(ds(e)));
    let n = 0;
    return e < 253 ? (t.set([
        Number(e)
    ], r), n = 1) : e <= 65535 ? (t.set([
        253
    ], r), cK(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([
        254
    ], r), Zu(t, r + 1, Number(e), "LE"), n = 5) : (t.set([
        255
    ], r), uK(t, r + 1, BigInt(e), "LE"), n = 9), {
        buffer: t,
        bytes: n
    };
}
function Ed(e, t) {
    t === void 0 && (t = 0);
    const r = e.at(t);
    if (r === void 0) throw new Error("buffer too small");
    if (r < 253) return {
        numberValue: r,
        bigintValue: BigInt(r),
        bytes: 1
    };
    if (r === 253) {
        const n = fK(e, t + 1, "LE");
        return {
            numberValue: n,
            bigintValue: BigInt(n),
            bytes: 3
        };
    } else if (r === 254) {
        const n = xl(e, t + 1, "LE");
        return {
            numberValue: n,
            bigintValue: BigInt(n),
            bytes: 5
        };
    } else {
        const n = lK(e, t + 1, "LE");
        return {
            numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null,
            bigintValue: n,
            bytes: 9
        };
    }
}
function ds(e) {
    return h7(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const pK = 9007199254740991;
function gK(e, t) {
    if (typeof e != "number" && typeof e != "bigint") throw new Error("cannot write a non-number as a number");
    if (e < 0 && e < BigInt(0)) throw new Error("specified a negative value for writing an unsigned value");
    if (e > t && e > BigInt(t)) throw new Error("RangeError: value out of range");
    if (Math.floor(Number(e)) !== Number(e)) throw new Error("value has a fractional component");
}
function s3(e) {
    if (e.length < 1) return e;
    let t = e.length - 1, r = 0;
    for(let n = 0; n < e.length / 2; n++)r = e[n], e[n] = e[t], e[t] = r, t--;
    return e;
}
function V4(e) {
    const t = new Uint8Array(e.length);
    return t.set(e), t;
}
class Ii {
    constructor(t, r = 0){
        pt(this, "buffer");
        pt(this, "offset");
        this.buffer = t, this.offset = r, En(ca([
            tn,
            Za
        ]), [
            t,
            r
        ]);
    }
    static withCapacity(t) {
        return new Ii(new Uint8Array(t));
    }
    writeUInt8(t) {
        this.offset = Po(this.buffer, this.offset, t);
    }
    writeInt32(t) {
        this.offset = $B(this.buffer, this.offset, t, "LE");
    }
    writeInt64(t) {
        this.offset = LB(this.buffer, this.offset, BigInt(t), "LE");
    }
    writeUInt32(t) {
        this.offset = Wp(this.buffer, this.offset, t, "LE");
    }
    writeUInt64(t) {
        this.offset = VH(this.buffer, this.offset, BigInt(t), "LE");
    }
    writeVarInt(t) {
        const { bytes: r } = pu(t, this.buffer, this.offset);
        this.offset += r;
    }
    writeSlice(t) {
        if (this.buffer.length < this.offset + t.length) throw new Error("Cannot write slice out of bounds");
        this.buffer.set(t, this.offset), this.offset += t.length;
    }
    writeVarSlice(t) {
        this.writeVarInt(t.length), this.writeSlice(t);
    }
    writeVector(t) {
        this.writeVarInt(t.length), t.forEach((r)=>this.writeVarSlice(r));
    }
    end() {
        if (this.buffer.length === this.offset) return this.buffer;
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
    }
}
class yK {
    constructor(t, r = 0){
        pt(this, "buffer");
        pt(this, "offset");
        this.buffer = t, this.offset = r, En(ca([
            tn,
            Za
        ]), [
            t,
            r
        ]);
    }
    readUInt8() {
        const t = sc(this.buffer, this.offset);
        return this.offset++, t;
    }
    readInt32() {
        const t = ZH(this.buffer, this.offset, "LE");
        return this.offset += 4, t;
    }
    readUInt32() {
        const t = wd(this.buffer, this.offset, "LE");
        return this.offset += 4, t;
    }
    readInt64() {
        const t = DB(this.buffer, this.offset, "LE");
        return this.offset += 8, t;
    }
    readVarInt() {
        const { bigintValue: t, bytes: r } = Ed(this.buffer, this.offset);
        return this.offset += r, t;
    }
    readSlice(t) {
        gK(t, pK);
        const r = Number(t);
        if (this.buffer.length < this.offset + r) throw new Error("Cannot read slice out of bounds");
        const n = this.buffer.slice(this.offset, this.offset + r);
        return this.offset += r, n;
    }
    readVarSlice() {
        return this.readSlice(this.readVarInt());
    }
    readVector() {
        const t = this.readVarInt(), r = [];
        for(let n = 0; n < t; n++)r.push(this.readVarSlice());
        return r;
    }
}
const p7 = 192, mK = 128, bK = (e)=>"left" in e && "right" in e;
function EE(e, t) {
    if (e.length < 33) throw new TypeError(`The control-block length is too small. Got ${e.length}, expected min 33.`);
    const r = (e.length - 33) / 32;
    let n = t;
    for(let i = 0; i < r; i++){
        const o = e.slice(33 + 32 * i, 65 + 32 * i);
        It(n, o) < 0 ? n = SE(n, o) : n = SE(o, n);
    }
    return n;
}
function xE(e) {
    if (Jx(e)) return {
        hash: tc(e)
    };
    const t = [
        xE(e[0]),
        xE(e[1])
    ];
    t.sort((i, o)=>It(i.hash, o.hash));
    const [r, n] = t;
    return {
        hash: SE(r.hash, n.hash),
        left: r,
        right: n
    };
}
function Xy(e, t) {
    if (bK(e)) {
        const r = Xy(e.left, t);
        if (r !== void 0) return [
            ...r,
            e.right.hash
        ];
        const n = Xy(e.right, t);
        if (n !== void 0) return [
            ...n,
            e.left.hash
        ];
    } else if (It(e.hash, t) === 0) return [];
}
function tc(e) {
    const t = e.version || p7;
    return ub("TapLeaf", kn([
        Uint8Array.from([
            t
        ]),
        vK(e.output)
    ]));
}
function wK(e, t) {
    return ub("TapTweak", kn(t ? [
        e,
        t
    ] : [
        e
    ]));
}
function kg(e, t) {
    if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
    const r = wK(e, t), n = _E().xOnlyPointAddTweak(e, r);
    return !n || n.xOnlyPubkey === null ? null : {
        parity: n.parity,
        x: Uint8Array.from(n.xOnlyPubkey)
    };
}
function SE(e, t) {
    return ub("TapBranch", kn([
        e,
        t
    ]));
}
function vK(e) {
    const t = ds(e.length), r = new Uint8Array(t);
    return pu(e.length, r), kn([
        r,
        e
    ]);
}
const G4 = Kr, Z4 = 1, _K = 80;
function xd(e, t) {
    if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1)) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        address: Pf(),
        input: Yn(0),
        network: jn({}),
        output: Yn(34),
        internalPubkey: Yn(32),
        hash: Yn(32),
        // merkle root hash, the tweak
        pubkey: Yn(32),
        // tweaked with `hash` from `internalPubkey`
        signature: Xx([
            Yn(64),
            Yn(65)
        ]),
        witness: lo(tn),
        scriptTree: Ls(VB, "Taptree is not of type isTaptree"),
        redeem: du(jn({
            output: tn,
            // tapleaf script
            redeemVersion: oo(),
            // tapleaf version
            witness: lo(tn)
        })),
        redeemVersion: oo()
    })), e);
    const r = fs(()=>a3(e.address)), n = fs(()=>{
        if (!(!e.witness || !e.witness.length)) return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === _K ? e.witness.slice(0, -1) : e.witness.slice();
    }), i = fs(()=>{
        if (e.scriptTree) return xE(e.scriptTree);
        if (e.hash) return {
            hash: e.hash
        };
    }), o = e.network || zs, s = {
        name: "p2tr",
        network: o
    };
    if (Zt(s, "address", ()=>{
        if (!s.pubkey) return;
        const a = rp.toWords(s.pubkey);
        return a.unshift(Z4), rp.encode(o.bech32, a);
    }), Zt(s, "hash", ()=>{
        const a = i();
        if (a) return a.hash;
        const u = n();
        if (u && u.length > 1) {
            const f = u[u.length - 1], c = f[0] & xy, l = u[u.length - 2], p = tc({
                output: l,
                version: c
            });
            return EE(f, p);
        }
        return null;
    }), Zt(s, "output", ()=>{
        if (s.pubkey) return Ri([
            G4.OP_1,
            s.pubkey
        ]);
    }), Zt(s, "redeemVersion", ()=>e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : p7), Zt(s, "redeem", ()=>{
        const a = n();
        if (!(!a || a.length < 2)) return {
            output: a[a.length - 2],
            witness: a.slice(0, -2),
            redeemVersion: a[a.length - 1][0] & xy
        };
    }), Zt(s, "pubkey", ()=>{
        if (e.pubkey) return e.pubkey;
        if (e.output) return e.output.slice(2);
        if (e.address) return r().data;
        if (s.internalPubkey) {
            const a = kg(s.internalPubkey, s.hash);
            if (a) return a.x;
        }
    }), Zt(s, "internalPubkey", ()=>{
        if (e.internalPubkey) return e.internalPubkey;
        const a = n();
        if (a && a.length > 1) return a[a.length - 1].slice(1, 33);
    }), Zt(s, "signature", ()=>{
        if (e.signature) return e.signature;
        const a = n();
        if (!(!a || a.length !== 1)) return a[0];
    }), Zt(s, "witness", ()=>{
        if (e.witness) return e.witness;
        const a = i();
        if (a && e.redeem && e.redeem.output && e.internalPubkey) {
            const u = tc({
                output: e.redeem.output,
                version: s.redeemVersion
            }), f = Xy(a, u);
            if (!f) return;
            const c = kg(e.internalPubkey, a.hash);
            if (!c) return;
            const l = kn([
                Uint8Array.from([
                    s.redeemVersion | c.parity
                ]),
                e.internalPubkey
            ].concat(f));
            return [
                e.redeem.output,
                l
            ];
        }
        if (e.signature) return [
            e.signature
        ];
    }), t.validate) {
        let a = Uint8Array.from([]);
        if (e.address) {
            if (o && o.bech32 !== r().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== Z4) throw new TypeError("Invalid address version");
            if (r().data.length !== 32) throw new TypeError("Invalid address data");
            a = r().data;
        }
        if (e.pubkey) {
            if (a.length > 0 && It(a, e.pubkey) !== 0) throw new TypeError("Pubkey mismatch");
            a = e.pubkey;
        }
        if (e.output) {
            if (e.output.length !== 34 || e.output[0] !== G4.OP_1 || e.output[1] !== 32) throw new TypeError("Output is invalid");
            if (a.length > 0 && It(a, e.output.slice(2)) !== 0) throw new TypeError("Pubkey mismatch");
            a = e.output.slice(2);
        }
        if (e.internalPubkey) {
            const c = kg(e.internalPubkey, s.hash);
            if (a.length > 0 && It(a, c.x) !== 0) throw new TypeError("Pubkey mismatch");
            a = c.x;
        }
        if (a && a.length && !_E().isXOnlyPoint(a)) throw new TypeError("Invalid pubkey for p2tr");
        const u = i();
        if (e.hash && u && It(e.hash, u.hash) !== 0) throw new TypeError("Hash mismatch");
        if (e.redeem && e.redeem.output && u) {
            const c = tc({
                output: e.redeem.output,
                version: s.redeemVersion
            });
            if (!Xy(u, c)) throw new TypeError("Redeem script not in tree");
        }
        const f = n();
        if (e.redeem && s.redeem) {
            if (e.redeem.redeemVersion && e.redeem.redeemVersion !== s.redeem.redeemVersion) throw new TypeError("Redeem.redeemVersion and witness mismatch");
            if (e.redeem.output) {
                if (Sn(e.redeem.output).length === 0) throw new TypeError("Redeem.output is invalid");
                if (s.redeem.output && It(e.redeem.output, s.redeem.output) !== 0) throw new TypeError("Redeem.output and witness mismatch");
            }
            if (e.redeem.witness && s.redeem.witness && !ep(e.redeem.witness, s.redeem.witness)) throw new TypeError("Redeem.witness and witness mismatch");
        }
        if (f && f.length) if (f.length === 1) {
            if (e.signature && It(e.signature, f[0]) !== 0) throw new TypeError("Signature mismatch");
        } else {
            const c = f[f.length - 1];
            if (c.length < 33) throw new TypeError(`The control-block length is too small. Got ${c.length}, expected min 33.`);
            if ((c.length - 33) % 32 !== 0) throw new TypeError(`The control-block length of ${c.length} is incorrect!`);
            const l = (c.length - 33) / 32;
            if (l > 128) throw new TypeError(`The script path is too long. Got ${l}, expected max 128.`);
            const p = c.slice(1, 33);
            if (e.internalPubkey && It(e.internalPubkey, p) !== 0) throw new TypeError("Internal pubkey mismatch");
            if (!_E().isXOnlyPoint(p)) throw new TypeError("Invalid internalPubkey for p2tr witness");
            const y = c[0] & xy, _ = f[f.length - 2], A = tc({
                output: _,
                version: y
            }), O = EE(c, A), N = kg(p, O);
            if (!N) throw new TypeError("Invalid outputKey for p2tr witness");
            if (a.length && It(a, N.x) !== 0) throw new TypeError("Pubkey mismatch for p2tr witness");
            if (N.parity !== (c[0] & 1)) throw new Error("Incorrect parity");
        }
    }
    return Object.assign(s, e);
}
const g7 = 40, y7 = 2, m7 = 16, b7 = 2, w7 = 80, v7 = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function EK(e, t) {
    const r = e.slice(2);
    if (r.length < y7 || r.length > g7) throw new TypeError("Invalid program length for segwit address");
    const n = e[0] - w7;
    if (n < b7 || n > m7) throw new TypeError("Invalid version for segwit address");
    if (e[1] !== r.length) throw new TypeError("Invalid script for segwit address");
    return console.warn(v7), xK(r, n, t.bech32);
}
function _7(e) {
    const t = Ql.decode(e);
    if (t.length < 21) throw new TypeError(e + " is too short");
    if (t.length > 21) throw new TypeError(e + " is too long");
    const r = sc(t, 0), n = t.slice(1);
    return {
        version: r,
        hash: n
    };
}
function a3(e) {
    let t, r;
    try {
        t = No.decode(e);
    } catch  {}
    if (t) {
        if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
    } else if (t = rp.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
    const n = No.fromWords(t.words.slice(1));
    return {
        version: r,
        prefix: t.prefix,
        data: Uint8Array.from(n)
    };
}
function xK(e, t, r) {
    const n = No.toWords(e);
    return n.unshift(t), t === 0 ? No.encode(r, n) : rp.encode(r, n);
}
function Yp(e, t) {
    t = t || zs;
    try {
        return Vp({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return _d({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return Gp({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return Zp({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return xd({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return EK(e, t);
    } catch  {}
    throw new Error(pq(e) + " has no matching Address");
}
function hs(e, t) {
    t = t || zs;
    let r, n;
    try {
        r = _7(e);
    } catch  {}
    if (r) {
        if (r.version === t.pubKeyHash) return Vp({
            hash: r.hash
        }).output;
        if (r.version === t.scriptHash) return _d({
            hash: r.hash
        }).output;
    } else {
        try {
            n = a3(e);
        } catch  {}
        if (n) {
            if (n.prefix !== t.bech32) throw new Error(e + " has an invalid prefix");
            if (n.version === 0) {
                if (n.data.length === 20) return Gp({
                    hash: n.data
                }).output;
                if (n.data.length === 32) return Zp({
                    hash: n.data
                }).output;
            } else if (n.version === 1) {
                if (n.data.length === 32) return xd({
                    pubkey: n.data
                }).output;
            } else if (n.version >= b7 && n.version <= m7 && n.data.length >= y7 && n.data.length <= g7) return console.warn(v7), Ri([
                n.version + w7,
                n.data
            ]);
        }
    }
    throw new Error(e + " has no matching Script");
}
function aa(e) {
    const t = e.length;
    return ds(t) + t;
}
function SK(e) {
    const t = e.length;
    return ds(t) + e.reduce((r, n)=>r + aa(n), 0);
}
const Jc = new Uint8Array(0), Y4 = [], Ww = hc("0000000000000000000000000000000000000000000000000000000000000000"), X4 = hc("0000000000000000000000000000000000000000000000000000000000000001"), AK = hc("ffffffffffffffff"), TK = {
    script: Jc,
    valueBuffer: AK
};
function kK(e) {
    return e.value !== void 0;
}
const Br = class Br {
    constructor(){
        pt(this, "version", 1);
        pt(this, "locktime", 0);
        pt(this, "ins", []);
        pt(this, "outs", []);
    }
    static fromBuffer(t, r) {
        const n = new yK(t), i = new Br();
        i.version = n.readInt32();
        const o = n.readUInt8(), s = n.readUInt8();
        let a = !1;
        o === Br.ADVANCED_TRANSACTION_MARKER && s === Br.ADVANCED_TRANSACTION_FLAG ? a = !0 : n.offset -= 2;
        const u = n.readVarInt();
        for(let c = 0; c < u; ++c)i.ins.push({
            hash: n.readSlice(32),
            index: n.readUInt32(),
            script: n.readVarSlice(),
            sequence: n.readUInt32(),
            witness: Y4
        });
        const f = n.readVarInt();
        for(let c = 0; c < f; ++c)i.outs.push({
            value: n.readInt64(),
            script: n.readVarSlice()
        });
        if (a) {
            for(let c = 0; c < u; ++c)i.ins[c].witness = n.readVector();
            if (!i.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
        }
        if (i.locktime = n.readUInt32(), r) return i;
        if (n.offset !== t.length) throw new Error("Transaction has unexpected data");
        return i;
    }
    static fromHex(t) {
        return Br.fromBuffer(hc(t), !1);
    }
    static isCoinbaseHash(t) {
        En(P4, t);
        for(let r = 0; r < 32; ++r)if (t[r] !== 0) return !1;
        return !0;
    }
    isCoinbase() {
        return this.ins.length === 1 && Br.isCoinbaseHash(this.ins[0].hash);
    }
    addInput(t, r, n, i) {
        return En(ca([
            P4,
            Za,
            vE(Wy(Za)),
            vE(Wy(tn))
        ]), [
            t,
            r,
            n,
            i
        ]), n == null && (n = Br.DEFAULT_SEQUENCE), this.ins.push({
            hash: t,
            index: r,
            script: i || Jc,
            sequence: n,
            witness: Y4
        }) - 1;
    }
    addOutput(t, r) {
        return En(ca([
            tn,
            jw
        ]), [
            t,
            r
        ]), this.outs.push({
            script: t,
            value: r
        }) - 1;
    }
    hasWitnesses() {
        return this.ins.some((t)=>t.witness.length !== 0);
    }
    weight() {
        const t = this.byteLength(!1), r = this.byteLength(!0);
        return t * 3 + r;
    }
    virtualSize() {
        return Math.ceil(this.weight() / 4);
    }
    byteLength(t = !0) {
        const r = t && this.hasWitnesses();
        return (r ? 10 : 8) + ds(this.ins.length) + ds(this.outs.length) + this.ins.reduce((n, i)=>n + 40 + aa(i.script), 0) + this.outs.reduce((n, i)=>n + 8 + aa(i.script), 0) + (r ? this.ins.reduce((n, i)=>n + SK(i.witness), 0) : 0);
    }
    clone() {
        const t = new Br();
        return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r)=>({
                hash: r.hash,
                index: r.index,
                script: r.script,
                sequence: r.sequence,
                witness: r.witness
            })), t.outs = this.outs.map((r)=>({
                script: r.script,
                value: r.value
            })), t;
    }
    /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */ hashForSignature(t, r, n) {
        if (En(ca([
            Za,
            tn,
            oo()
        ]), [
            t,
            r,
            n
        ]), t >= this.ins.length) return X4;
        const i = Ri(Sn(r).filter((a)=>a !== Kr.OP_CODESEPARATOR)), o = this.clone();
        if ((n & 31) === Br.SIGHASH_NONE) o.outs = [], o.ins.forEach((a, u)=>{
            u !== t && (a.sequence = 0);
        });
        else if ((n & 31) === Br.SIGHASH_SINGLE) {
            if (t >= this.outs.length) return X4;
            o.outs.length = t + 1;
            for(let a = 0; a < t; a++)o.outs[a] = TK;
            o.ins.forEach((a, u)=>{
                u !== t && (a.sequence = 0);
            });
        }
        n & Br.SIGHASH_ANYONECANPAY ? (o.ins = [
            o.ins[t]
        ], o.ins[0].script = i) : (o.ins.forEach((a)=>{
            a.script = Jc;
        }), o.ins[t].script = i);
        const s = new Uint8Array(o.byteLength(!1) + 4);
        return $B(s, s.length - 4, n, "LE"), o.__toBuffer(s, 0, !1), ju(s);
    }
    hashForWitnessV1(t, r, n, i, o, s) {
        if (En(ca([
            Za,
            lo(tn),
            lo(jw),
            Za
        ]), [
            t,
            r,
            n,
            i
        ]), n.length !== this.ins.length || r.length !== this.ins.length) throw new Error("Must supply prevout script and value for all inputs");
        const a = i === Br.SIGHASH_DEFAULT ? Br.SIGHASH_ALL : i & Br.SIGHASH_OUTPUT_MASK, f = (i & Br.SIGHASH_INPUT_MASK) === Br.SIGHASH_ANYONECANPAY, c = a === Br.SIGHASH_NONE, l = a === Br.SIGHASH_SINGLE;
        let p = Jc, y = Jc, _ = Jc, A = Jc, O = Jc;
        if (!f) {
            let H = Ii.withCapacity(36 * this.ins.length);
            this.ins.forEach((K)=>{
                H.writeSlice(K.hash), H.writeUInt32(K.index);
            }), p = pi(H.end()), H = Ii.withCapacity(8 * this.ins.length), n.forEach((K)=>H.writeInt64(K)), y = pi(H.end()), H = Ii.withCapacity(r.map(aa).reduce((K, re)=>K + re)), r.forEach((K)=>H.writeVarSlice(K)), _ = pi(H.end()), H = Ii.withCapacity(4 * this.ins.length), this.ins.forEach((K)=>H.writeUInt32(K.sequence)), A = pi(H.end());
        }
        if (c || l) {
            if (l && t < this.outs.length) {
                const H = this.outs[t], K = Ii.withCapacity(8 + aa(H.script));
                K.writeInt64(H.value), K.writeVarSlice(H.script), O = pi(K.end());
            }
        } else {
            if (!this.outs.length) throw new Error("Add outputs to the transaction before signing.");
            const H = this.outs.map((re)=>8 + aa(re.script)).reduce((re, Q)=>re + Q), K = Ii.withCapacity(H);
            this.outs.forEach((re)=>{
                K.writeInt64(re.value), K.writeVarSlice(re.script);
            }), O = pi(K.end());
        }
        const N = (o ? 2 : 0) + (s ? 1 : 0), U = 174 - (f ? 49 : 0) - (c ? 32 : 0) + (s ? 32 : 0) + (o ? 37 : 0), D = Ii.withCapacity(U);
        if (D.writeUInt8(i), D.writeInt32(this.version), D.writeUInt32(this.locktime), D.writeSlice(p), D.writeSlice(y), D.writeSlice(_), D.writeSlice(A), c || l || D.writeSlice(O), D.writeUInt8(N), f) {
            const H = this.ins[t];
            D.writeSlice(H.hash), D.writeUInt32(H.index), D.writeInt64(n[t]), D.writeVarSlice(r[t]), D.writeUInt32(H.sequence);
        } else D.writeUInt32(t);
        if (s) {
            const H = Ii.withCapacity(aa(s));
            H.writeVarSlice(s), D.writeSlice(pi(H.end()));
        }
        return l && D.writeSlice(O), o && (D.writeSlice(o), D.writeUInt8(0), D.writeUInt32(4294967295)), ub("TapSighash", kn([
            Uint8Array.from([
                0
            ]),
            D.end()
        ]));
    }
    hashForWitnessV0(t, r, n, i) {
        En(ca([
            Za,
            tn,
            jw,
            Za
        ]), [
            t,
            r,
            n,
            i
        ]);
        let o = Uint8Array.from([]), s, a = Ww, u = Ww, f = Ww;
        if (i & Br.SIGHASH_ANYONECANPAY || (o = new Uint8Array(36 * this.ins.length), s = new Ii(o, 0), this.ins.forEach((l)=>{
            s.writeSlice(l.hash), s.writeUInt32(l.index);
        }), u = ju(o)), !(i & Br.SIGHASH_ANYONECANPAY) && (i & 31) !== Br.SIGHASH_SINGLE && (i & 31) !== Br.SIGHASH_NONE && (o = new Uint8Array(4 * this.ins.length), s = new Ii(o, 0), this.ins.forEach((l)=>{
            s.writeUInt32(l.sequence);
        }), f = ju(o)), (i & 31) !== Br.SIGHASH_SINGLE && (i & 31) !== Br.SIGHASH_NONE) {
            const l = this.outs.reduce((p, y)=>p + 8 + aa(y.script), 0);
            o = new Uint8Array(l), s = new Ii(o, 0), this.outs.forEach((p)=>{
                s.writeInt64(p.value), s.writeVarSlice(p.script);
            }), a = ju(o);
        } else if ((i & 31) === Br.SIGHASH_SINGLE && t < this.outs.length) {
            const l = this.outs[t];
            o = new Uint8Array(8 + aa(l.script)), s = new Ii(o, 0), s.writeInt64(l.value), s.writeVarSlice(l.script), a = ju(o);
        }
        o = new Uint8Array(156 + aa(r)), s = new Ii(o, 0);
        const c = this.ins[t];
        return s.writeInt32(this.version), s.writeSlice(u), s.writeSlice(f), s.writeSlice(c.hash), s.writeUInt32(c.index), s.writeVarSlice(r), s.writeInt64(n), s.writeUInt32(c.sequence), s.writeSlice(a), s.writeUInt32(this.locktime), s.writeUInt32(i), ju(o);
    }
    getHash(t) {
        return t && this.isCoinbase() ? new Uint8Array(32) : ju(this.__toBuffer(void 0, void 0, t));
    }
    getId() {
        return rr(s3(this.getHash(!1)));
    }
    toBuffer(t, r) {
        return this.__toBuffer(t, r, !0);
    }
    toHex() {
        return rr(this.toBuffer(void 0, void 0));
    }
    setInputScript(t, r) {
        En(ca([
            oo(),
            tn
        ]), [
            t,
            r
        ]), this.ins[t].script = r;
    }
    setWitness(t, r) {
        En(ca([
            oo(),
            lo(tn)
        ]), [
            t,
            r
        ]), this.ins[t].witness = r;
    }
    __toBuffer(t, r, n = !1) {
        t || (t = new Uint8Array(this.byteLength(n)));
        const i = new Ii(t, r || 0);
        i.writeInt32(this.version);
        const o = n && this.hasWitnesses();
        return o && (i.writeUInt8(Br.ADVANCED_TRANSACTION_MARKER), i.writeUInt8(Br.ADVANCED_TRANSACTION_FLAG)), i.writeVarInt(this.ins.length), this.ins.forEach((s)=>{
            i.writeSlice(s.hash), i.writeUInt32(s.index), i.writeVarSlice(s.script), i.writeUInt32(s.sequence);
        }), i.writeVarInt(this.outs.length), this.outs.forEach((s)=>{
            kK(s) ? i.writeInt64(s.value) : i.writeSlice(s.valueBuffer), i.writeVarSlice(s.script);
        }), o && this.ins.forEach((s)=>{
            i.writeVector(s.witness);
        }), i.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, i.offset) : t;
    }
};
pt(Br, "DEFAULT_SEQUENCE", 4294967295), pt(Br, "SIGHASH_DEFAULT", 0), pt(Br, "SIGHASH_ALL", 1), pt(Br, "SIGHASH_NONE", 2), pt(Br, "SIGHASH_SINGLE", 3), pt(Br, "SIGHASH_ANYONECANPAY", 128), pt(Br, "SIGHASH_OUTPUT_MASK", 3), pt(Br, "SIGHASH_INPUT_MASK", 128), pt(Br, "ADVANCED_TRANSACTION_MARKER", 0), pt(Br, "ADVANCED_TRANSACTION_FLAG", 1);
let xn = Br;
var ya;
(function(e) {
    e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(ya || (ya = {}));
var Dt;
(function(e) {
    e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(Dt || (Dt = {}));
var $n;
(function(e) {
    e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})($n || ($n = {}));
const IK = (e)=>[
        ...Array(e).keys()
    ];
function BK(e) {
    if (e.key[0] !== ya.GLOBAL_XPUB) throw new Error("Decode Error: could not decode globalXpub with key 0x" + rr(e.key));
    if (e.key.length !== 79 || ![
        2,
        3
    ].includes(e.key[46])) throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x" + rr(e.key));
    if (e.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");
    const t = e.key.slice(1), r = {
        masterFingerprint: e.value.slice(0, 4),
        extendedPubkey: t,
        path: "m"
    };
    for (const n of IK(e.value.length / 4 - 1)){
        const i = wd(e.value, n * 4 + 4, "LE"), o = !!(i & 2147483648), s = i & 2147483647;
        r.path += "/" + s.toString(10) + (o ? "'" : "");
    }
    return r;
}
function OK(e) {
    const t = new Uint8Array([
        ya.GLOBAL_XPUB
    ]), r = kn([
        t,
        e.extendedPubkey
    ]), n = e.path.split("/"), i = new Uint8Array(n.length * 4);
    i.set(e.masterFingerprint, 0);
    let o = 4;
    return n.slice(1).forEach((s)=>{
        const a = s.slice(-1) === "'";
        let u = 2147483647 & parseInt(a ? s.slice(0, -1) : s, 10);
        a && (u += 2147483648), Wp(i, o, u, "LE"), o += 4;
    }), {
        key: r,
        value: i
    };
}
const PK = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function NK(e) {
    const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
    return t instanceof Uint8Array && t.length === 78 && [
        2,
        3
    ].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function MK(e, t, r) {
    const n = rr(t.extendedPubkey);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.extendedPubkey, t.extendedPubkey)).length === 0);
}
const RK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: MK,
    check: NK,
    decode: BK,
    encode: OK,
    expected: PK
}, Symbol.toStringTag, {
    value: "Module"
}));
function CK(e) {
    return {
        key: new Uint8Array([
            ya.UNSIGNED_TX
        ]),
        value: e.toBuffer()
    };
}
const UK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    encode: CK
}, Symbol.toStringTag, {
    value: "Module"
}));
function $K(e) {
    if (e.key[0] !== Dt.FINAL_SCRIPTSIG) throw new Error("Decode Error: could not decode finalScriptSig with key 0x" + rr(e.key));
    return e.value;
}
function LK(e) {
    return {
        key: new Uint8Array([
            Dt.FINAL_SCRIPTSIG
        ]),
        value: e
    };
}
const DK = "Uint8Array";
function FK(e) {
    return e instanceof Uint8Array;
}
function zK(e, t) {
    return !!e && !!t && e.finalScriptSig === void 0;
}
const jK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: zK,
    check: FK,
    decode: $K,
    encode: LK,
    expected: DK
}, Symbol.toStringTag, {
    value: "Module"
}));
function HK(e) {
    if (e.key[0] !== Dt.FINAL_SCRIPTWITNESS) throw new Error("Decode Error: could not decode finalScriptWitness with key 0x" + rr(e.key));
    return e.value;
}
function qK(e) {
    return {
        key: new Uint8Array([
            Dt.FINAL_SCRIPTWITNESS
        ]),
        value: e
    };
}
const KK = "Uint8Array";
function WK(e) {
    return e instanceof Uint8Array;
}
function VK(e, t) {
    return !!e && !!t && e.finalScriptWitness === void 0;
}
const GK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: VK,
    check: WK,
    decode: HK,
    encode: qK,
    expected: KK
}, Symbol.toStringTag, {
    value: "Module"
}));
function ZK(e) {
    if (e.key[0] !== Dt.NON_WITNESS_UTXO) throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x" + rr(e.key));
    return e.value;
}
function YK(e) {
    return {
        key: new Uint8Array([
            Dt.NON_WITNESS_UTXO
        ]),
        value: e
    };
}
const XK = "Uint8Array";
function JK(e) {
    return e instanceof Uint8Array;
}
function QK(e, t) {
    return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const eW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: QK,
    check: JK,
    decode: ZK,
    encode: YK,
    expected: XK
}, Symbol.toStringTag, {
    value: "Module"
}));
function tW(e) {
    if (e.key[0] !== Dt.PARTIAL_SIG) throw new Error("Decode Error: could not decode partialSig with key 0x" + rr(e.key));
    if (!(e.key.length === 34 || e.key.length === 66) || ![
        2,
        3,
        4
    ].includes(e.key[1])) throw new Error("Decode Error: partialSig has invalid pubkey in key 0x" + rr(e.key));
    return {
        pubkey: e.key.slice(1),
        signature: e.value
    };
}
function rW(e) {
    const t = new Uint8Array([
        Dt.PARTIAL_SIG
    ]);
    return {
        key: kn([
            t,
            e.pubkey
        ]),
        value: e.signature
    };
}
const nW = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function iW(e) {
    return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [
        33,
        65
    ].includes(e.pubkey.length) && [
        2,
        3,
        4
    ].includes(e.pubkey[0]) && oW(e.signature);
}
function oW(e) {
    if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
    const t = e[3];
    if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
    const r = e[3 + t + 2];
    return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function sW(e, t, r) {
    const n = rr(t.pubkey);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.pubkey, t.pubkey) === 0).length === 0);
}
const aW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: sW,
    check: iW,
    decode: tW,
    encode: rW,
    expected: nW
}, Symbol.toStringTag, {
    value: "Module"
}));
function cW(e) {
    if (e.key[0] !== Dt.POR_COMMITMENT) throw new Error("Decode Error: could not decode porCommitment with key 0x" + rr(e.key));
    return zH(e.value);
}
function uW(e) {
    return {
        key: new Uint8Array([
            Dt.POR_COMMITMENT
        ]),
        value: jH(e)
    };
}
const fW = "string";
function lW(e) {
    return typeof e == "string";
}
function dW(e, t) {
    return !!e && !!t && e.porCommitment === void 0;
}
const hW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: dW,
    check: lW,
    decode: cW,
    encode: uW,
    expected: fW
}, Symbol.toStringTag, {
    value: "Module"
}));
function pW(e) {
    if (e.key[0] !== Dt.SIGHASH_TYPE) throw new Error("Decode Error: could not decode sighashType with key 0x" + rr(e.key));
    return Number(wd(e.value, 0, "LE"));
}
function gW(e) {
    const t = Uint8Array.from([
        Dt.SIGHASH_TYPE
    ]), r = new Uint8Array(4);
    return Wp(r, 0, e, "LE"), {
        key: t,
        value: r
    };
}
const yW = "number";
function mW(e) {
    return typeof e == "number";
}
function bW(e, t) {
    return !!e && !!t && e.sighashType === void 0;
}
const wW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: bW,
    check: mW,
    decode: pW,
    encode: gW,
    expected: yW
}, Symbol.toStringTag, {
    value: "Module"
}));
function vW(e) {
    if (e.key[0] !== Dt.TAP_KEY_SIG || e.key.length !== 1) throw new Error("Decode Error: could not decode tapKeySig with key 0x" + rr(e.key));
    if (!E7(e.value)) throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");
    return e.value;
}
function _W(e) {
    return {
        key: Uint8Array.from([
            Dt.TAP_KEY_SIG
        ]),
        value: e
    };
}
const EW = "Uint8Array";
function E7(e) {
    return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function xW(e, t) {
    return !!e && !!t && e.tapKeySig === void 0;
}
const SW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: xW,
    check: E7,
    decode: vW,
    encode: _W,
    expected: EW
}, Symbol.toStringTag, {
    value: "Module"
}));
function AW(e) {
    if (e.key[0] !== Dt.TAP_LEAF_SCRIPT) throw new Error("Decode Error: could not decode tapLeafScript with key 0x" + rr(e.key));
    if ((e.key.length - 2) % 32 !== 0) throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x" + rr(e.key));
    const t = e.value[e.value.length - 1];
    if ((e.key[1] & 254) !== t) throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x" + rr(e.key));
    const r = e.value.slice(0, -1);
    return {
        controlBlock: e.key.slice(1),
        script: r,
        leafVersion: t
    };
}
function TW(e) {
    const t = Uint8Array.from([
        Dt.TAP_LEAF_SCRIPT
    ]), r = Uint8Array.from([
        e.leafVersion
    ]);
    return {
        key: kn([
            t,
            e.controlBlock
        ]),
        value: kn([
            e.script,
            r
        ])
    };
}
const kW = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function IW(e) {
    return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function BW(e, t, r) {
    const n = rr(t.controlBlock);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.controlBlock, t.controlBlock) === 0).length === 0);
}
const OW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: BW,
    check: IW,
    decode: AW,
    encode: TW,
    expected: kW
}, Symbol.toStringTag, {
    value: "Module"
}));
function PW(e) {
    if (e.key[0] !== Dt.TAP_MERKLE_ROOT || e.key.length !== 1) throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x" + rr(e.key));
    if (!x7(e.value)) throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
    return e.value;
}
function NW(e) {
    return {
        key: Uint8Array.from([
            Dt.TAP_MERKLE_ROOT
        ]),
        value: e
    };
}
const MW = "Uint8Array";
function x7(e) {
    return e instanceof Uint8Array && e.length === 32;
}
function RW(e, t) {
    return !!e && !!t && e.tapMerkleRoot === void 0;
}
const CW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: RW,
    check: x7,
    decode: PW,
    encode: NW,
    expected: MW
}, Symbol.toStringTag, {
    value: "Module"
}));
function UW(e) {
    if (e.key[0] !== Dt.TAP_SCRIPT_SIG) throw new Error("Decode Error: could not decode tapScriptSig with key 0x" + rr(e.key));
    if (e.key.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid key 0x" + rr(e.key));
    if (e.value.length !== 64 && e.value.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x" + rr(e.key));
    const t = e.key.slice(1, 33), r = e.key.slice(33);
    return {
        pubkey: t,
        leafHash: r,
        signature: e.value
    };
}
function $W(e) {
    const t = Uint8Array.from([
        Dt.TAP_SCRIPT_SIG
    ]);
    return {
        key: kn([
            t,
            e.pubkey,
            e.leafHash
        ]),
        value: e.signature
    };
}
const LW = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function DW(e) {
    return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function FW(e, t, r) {
    const n = rr(t.pubkey) + rr(t.leafHash);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.pubkey, t.pubkey) === 0 && It(i.leafHash, t.leafHash) === 0).length === 0);
}
const zW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: FW,
    check: DW,
    decode: UW,
    encode: $W,
    expected: LW
}, Symbol.toStringTag, {
    value: "Module"
}));
function jW(e) {
    if (e.key[0] !== Dt.WITNESS_UTXO) throw new Error("Decode Error: could not decode witnessUtxo with key 0x" + rr(e.key));
    const t = DB(e.value, 0, "LE");
    let r = 8;
    const { numberValue: n, bytes: i } = Ed(e.value, r);
    r += i;
    const o = e.value.slice(r);
    if (o.length !== n) throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
    return {
        script: o,
        value: t
    };
}
function HW(e) {
    const { script: t, value: r } = e, n = ds(t.length), i = new Uint8Array(8 + n + t.length);
    return LB(i, 0, BigInt(r), "LE"), pu(t.length, i, 8), i.set(t, 8 + n), {
        key: Uint8Array.from([
            Dt.WITNESS_UTXO
        ]),
        value: i
    };
}
const qW = "{ script: Uint8Array; value: bigint; }";
function KW(e) {
    return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function WW(e, t) {
    return !!e && !!t && e.witnessUtxo === void 0;
}
const VW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: WW,
    check: KW,
    decode: jW,
    encode: HW,
    expected: qW
}, Symbol.toStringTag, {
    value: "Module"
}));
function GW(e) {
    if (e.key[0] !== $n.TAP_TREE || e.key.length !== 1) throw new Error("Decode Error: could not decode tapTree with key 0x" + rr(e.key));
    let t = 0;
    const r = [];
    for(; t < e.value.length;){
        const n = e.value[t++], i = e.value[t++], { numberValue: o, bytes: s } = Ed(e.value, t);
        t += s, r.push({
            depth: n,
            leafVersion: i,
            script: e.value.slice(t, t + o)
        }), t += o;
    }
    return {
        leaves: r
    };
}
function ZW(e) {
    const t = Uint8Array.from([
        $n.TAP_TREE
    ]), r = [].concat(...e.leaves.map((n)=>[
            Uint8Array.of(n.depth, n.leafVersion),
            pu(BigInt(n.script.length)).buffer,
            n.script
        ]));
    return {
        key: t,
        value: kn(r)
    };
}
const YW = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function XW(e) {
    return Array.isArray(e.leaves) && e.leaves.every((t)=>t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array);
}
function JW(e, t) {
    return !!e && !!t && e.tapTree === void 0;
}
const QW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: JW,
    check: XW,
    decode: GW,
    encode: ZW,
    expected: YW
}, Symbol.toStringTag, {
    value: "Module"
})), eV = (e)=>[
        ...Array(e).keys()
    ], tV = (e)=>e.length === 33 && [
        2,
        3
    ].includes(e[0]) || e.length === 65 && e[0] === 4;
function c3(e, t = tV) {
    function r(a) {
        if (a.key[0] !== e) throw new Error("Decode Error: could not decode bip32Derivation with key 0x" + rr(a.key));
        const u = a.key.slice(1);
        if (!t(u)) throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x" + rr(a.key));
        if (a.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");
        const f = {
            masterFingerprint: a.value.slice(0, 4),
            pubkey: u,
            path: "m"
        };
        for (const c of eV(a.value.length / 4 - 1)){
            const l = wd(a.value, c * 4 + 4, "LE"), p = !!(l & 2147483648), y = l & 2147483647;
            f.path += "/" + y.toString(10) + (p ? "'" : "");
        }
        return f;
    }
    function n(a) {
        const u = Uint8Array.from([
            e
        ]), f = kn([
            u,
            a.pubkey
        ]), c = a.path.split("/"), l = new Uint8Array(c.length * 4);
        l.set(a.masterFingerprint, 0);
        let p = 4;
        return c.slice(1).forEach((y)=>{
            const _ = y.slice(-1) === "'";
            let A = 2147483647 & parseInt(_ ? y.slice(0, -1) : y, 10);
            _ && (A += 2147483648), Wp(l, p, A, "LE"), p += 4;
        }), {
            key: f,
            value: l
        };
    }
    const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
    function o(a) {
        return a.pubkey instanceof Uint8Array && a.masterFingerprint instanceof Uint8Array && typeof a.path == "string" && t(a.pubkey) && a.masterFingerprint.length === 4;
    }
    function s(a, u, f) {
        const c = rr(u.pubkey);
        return f.has(c) ? !1 : (f.add(c), a.filter((l)=>It(l.pubkey, u.pubkey) === 0).length === 0);
    }
    return {
        decode: r,
        encode: n,
        check: o,
        expected: i,
        canAddToArray: s
    };
}
function u3(e) {
    return t;
    //TURBOPACK unreachable
    ;
    function t(r) {
        let n;
        if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![
            2,
            3,
            4
        ].includes(n[0]))) throw new Error("Format Error: invalid pubkey in key 0x" + rr(r.key));
        return n;
    }
}
function S7(e) {
    function t(s) {
        if (s.key[0] !== e) throw new Error("Decode Error: could not decode redeemScript with key 0x" + rr(s.key));
        return s.value;
    }
    function r(s) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: s
        };
    }
    const n = "Uint8Array";
    function i(s) {
        return s instanceof Uint8Array;
    }
    function o(s, a) {
        return !!s && !!a && s.redeemScript === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i,
        expected: n,
        canAdd: o
    };
}
const rV = (e)=>e.length === 32;
function A7(e) {
    const t = c3(e, rV);
    function r(s) {
        const { numberValue: a, bytes: u } = Ed(s.value), f = t.decode({
            key: s.key,
            value: s.value.slice(u + Number(a) * 32)
        }), c = new Array(Number(a));
        for(let l = 0, p = u; l < a; l++, p += 32)c[l] = s.value.slice(p, p + 32);
        return {
            ...f,
            leafHashes: c
        };
    }
    function n(s) {
        const a = t.encode(s), u = ds(s.leafHashes.length), f = new Uint8Array(u);
        pu(s.leafHashes.length, f);
        const c = kn([
            f,
            ...s.leafHashes,
            a.value
        ]);
        return {
            ...a,
            value: c
        };
    }
    const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
    function o(s) {
        return Array.isArray(s.leafHashes) && s.leafHashes.every((a)=>a instanceof Uint8Array && a.length === 32) && t.check(s);
    }
    return {
        decode: r,
        encode: n,
        check: o,
        expected: i,
        canAddToArray: t.canAddToArray
    };
}
function T7(e) {
    function t(s) {
        if (s.key[0] !== e || s.key.length !== 1) throw new Error("Decode Error: could not decode tapInternalKey with key 0x" + rr(s.key));
        if (s.value.length !== 32) throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");
        return s.value;
    }
    function r(s) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: s
        };
    }
    const n = "Uint8Array";
    function i(s) {
        return s instanceof Uint8Array && s.length === 32;
    }
    function o(s, a) {
        return !!s && !!a && s.tapInternalKey === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i,
        expected: n,
        canAdd: o
    };
}
function k7(e) {
    function t(s) {
        if (s.key[0] !== e) throw new Error("Decode Error: could not decode witnessScript with key 0x" + rr(s.key));
        return s.value;
    }
    function r(s) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: s
        };
    }
    const n = "Uint8Array";
    function i(s) {
        return s instanceof Uint8Array;
    }
    function o(s, a) {
        return !!s && !!a && s.witnessScript === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i,
        expected: n,
        canAdd: o
    };
}
const f3 = {
    unsignedTx: UK,
    globalXpub: RK,
    // pass an Array of key bytes that require pubkey beside the key
    checkPubkey: u3([])
}, Vn = {
    nonWitnessUtxo: eW,
    partialSig: aW,
    sighashType: wW,
    finalScriptSig: jK,
    finalScriptWitness: GK,
    porCommitment: hW,
    witnessUtxo: VW,
    bip32Derivation: c3(Dt.BIP32_DERIVATION),
    redeemScript: S7(Dt.REDEEM_SCRIPT),
    witnessScript: k7(Dt.WITNESS_SCRIPT),
    checkPubkey: u3([
        Dt.PARTIAL_SIG,
        Dt.BIP32_DERIVATION
    ]),
    tapKeySig: SW,
    tapScriptSig: zW,
    tapLeafScript: OW,
    tapBip32Derivation: A7(Dt.TAP_BIP32_DERIVATION),
    tapInternalKey: T7(Dt.TAP_INTERNAL_KEY),
    tapMerkleRoot: CW
}, Ya = {
    bip32Derivation: c3($n.BIP32_DERIVATION),
    redeemScript: S7($n.REDEEM_SCRIPT),
    witnessScript: k7($n.WITNESS_SCRIPT),
    checkPubkey: u3([
        $n.BIP32_DERIVATION
    ]),
    tapBip32Derivation: A7($n.TAP_BIP32_DERIVATION),
    tapTree: QW,
    tapInternalKey: T7($n.TAP_INTERNAL_KEY)
}, nV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    globals: f3,
    inputs: Vn,
    outputs: Ya
}, Symbol.toStringTag, {
    value: "Module"
})), Jy = (e)=>[
        ...Array(e).keys()
    ];
function J4(e) {
    const t = e.map(iV);
    return t.push(Uint8Array.from([
        0
    ])), kn(t);
}
function iV(e) {
    const t = e.key.length, r = e.value.length, n = ds(t), i = ds(r), o = new Uint8Array(n + t + i + r);
    return pu(t, o, 0), o.set(e.key, n), pu(r, o, n + t), o.set(e.value, n + t + i), o;
}
function oV(e, t) {
    let r = 0;
    function n() {
        const { numberValue: O, bytes: N } = Ed(e, r);
        r += N;
        const U = e.slice(r, r + Number(O));
        return r += Number(O), U;
    }
    function i() {
        const O = wd(e, r, "BE");
        return r += 4, O;
    }
    function o() {
        const O = sc(e, r);
        return r += 1, O;
    }
    function s() {
        const O = n(), N = n();
        return {
            key: O,
            value: N
        };
    }
    function a() {
        if (r >= e.length) throw new Error("Format Error: Unexpected End of PSBT");
        const O = sc(e, r) === 0;
        return O && r++, O;
    }
    if (i() !== 1886610036) throw new Error("Format Error: Invalid Magic Number");
    if (o() !== 255) throw new Error("Format Error: Magic Number must be followed by 0xff separator");
    const u = [], f = {};
    for(; !a();){
        const O = s(), N = rr(O.key);
        if (f[N]) throw new Error("Format Error: Keys must be unique for global keymap: key " + N);
        f[N] = 1, u.push(O);
    }
    const c = u.filter((O)=>O.key[0] === ya.UNSIGNED_TX);
    if (c.length !== 1) throw new Error("Format Error: Only one UNSIGNED_TX allowed");
    const l = t(c[0].value), { inputCount: p, outputCount: y } = l.getInputOutputCounts(), _ = [], A = [];
    for (const O of Jy(p)){
        const N = {}, U = [];
        for(; !a();){
            const D = s(), H = rr(D.key);
            if (N[H]) throw new Error("Format Error: Keys must be unique for each input: input index " + O + " key " + H);
            N[H] = 1, U.push(D);
        }
        _.push(U);
    }
    for (const O of Jy(y)){
        const N = {}, U = [];
        for(; !a();){
            const D = s(), H = rr(D.key);
            if (N[H]) throw new Error("Format Error: Keys must be unique for each output: output index " + O + " key " + H);
            N[H] = 1, U.push(D);
        }
        A.push(U);
    }
    return I7(l, {
        globalMapKeyVals: u,
        inputKeyVals: _,
        outputKeyVals: A
    });
}
function xi(e, t, r) {
    if (It(t, Uint8Array.from([
        r
    ]))) throw new Error(// `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    `Format Error: Invalid ${e} key: ${rr(t)}`);
}
function I7(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
    const i = {
        unsignedTx: e
    };
    let o = 0;
    for (const c of t)switch(c.key[0]){
        case ya.UNSIGNED_TX:
            if (xi("global", c.key, ya.UNSIGNED_TX), o > 0) throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            o++;
            break;
        case ya.GLOBAL_XPUB:
            i.globalXpub === void 0 && (i.globalXpub = []), i.globalXpub.push(f3.globalXpub.decode(c));
            break;
        default:
            i.unknownKeyVals || (i.unknownKeyVals = []), i.unknownKeyVals.push(c);
    }
    const s = r.length, a = n.length, u = [], f = [];
    for (const c of Jy(s)){
        const l = {};
        for (const p of r[c])switch(Vn.checkPubkey(p), p.key[0]){
            case Dt.NON_WITNESS_UTXO:
                if (xi("input", p.key, Dt.NON_WITNESS_UTXO), l.nonWitnessUtxo !== void 0) throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");
                l.nonWitnessUtxo = Vn.nonWitnessUtxo.decode(p);
                break;
            case Dt.WITNESS_UTXO:
                if (xi("input", p.key, Dt.WITNESS_UTXO), l.witnessUtxo !== void 0) throw new Error("Format Error: Input has multiple WITNESS_UTXO");
                l.witnessUtxo = Vn.witnessUtxo.decode(p);
                break;
            case Dt.PARTIAL_SIG:
                l.partialSig === void 0 && (l.partialSig = []), l.partialSig.push(Vn.partialSig.decode(p));
                break;
            case Dt.SIGHASH_TYPE:
                if (xi("input", p.key, Dt.SIGHASH_TYPE), l.sighashType !== void 0) throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
                l.sighashType = Vn.sighashType.decode(p);
                break;
            case Dt.REDEEM_SCRIPT:
                if (xi("input", p.key, Dt.REDEEM_SCRIPT), l.redeemScript !== void 0) throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
                l.redeemScript = Vn.redeemScript.decode(p);
                break;
            case Dt.WITNESS_SCRIPT:
                if (xi("input", p.key, Dt.WITNESS_SCRIPT), l.witnessScript !== void 0) throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
                l.witnessScript = Vn.witnessScript.decode(p);
                break;
            case Dt.BIP32_DERIVATION:
                l.bip32Derivation === void 0 && (l.bip32Derivation = []), l.bip32Derivation.push(Vn.bip32Derivation.decode(p));
                break;
            case Dt.FINAL_SCRIPTSIG:
                xi("input", p.key, Dt.FINAL_SCRIPTSIG), l.finalScriptSig = Vn.finalScriptSig.decode(p);
                break;
            case Dt.FINAL_SCRIPTWITNESS:
                xi("input", p.key, Dt.FINAL_SCRIPTWITNESS), l.finalScriptWitness = Vn.finalScriptWitness.decode(p);
                break;
            case Dt.POR_COMMITMENT:
                xi("input", p.key, Dt.POR_COMMITMENT), l.porCommitment = Vn.porCommitment.decode(p);
                break;
            case Dt.TAP_KEY_SIG:
                xi("input", p.key, Dt.TAP_KEY_SIG), l.tapKeySig = Vn.tapKeySig.decode(p);
                break;
            case Dt.TAP_SCRIPT_SIG:
                l.tapScriptSig === void 0 && (l.tapScriptSig = []), l.tapScriptSig.push(Vn.tapScriptSig.decode(p));
                break;
            case Dt.TAP_LEAF_SCRIPT:
                l.tapLeafScript === void 0 && (l.tapLeafScript = []), l.tapLeafScript.push(Vn.tapLeafScript.decode(p));
                break;
            case Dt.TAP_BIP32_DERIVATION:
                l.tapBip32Derivation === void 0 && (l.tapBip32Derivation = []), l.tapBip32Derivation.push(Vn.tapBip32Derivation.decode(p));
                break;
            case Dt.TAP_INTERNAL_KEY:
                xi("input", p.key, Dt.TAP_INTERNAL_KEY), l.tapInternalKey = Vn.tapInternalKey.decode(p);
                break;
            case Dt.TAP_MERKLE_ROOT:
                xi("input", p.key, Dt.TAP_MERKLE_ROOT), l.tapMerkleRoot = Vn.tapMerkleRoot.decode(p);
                break;
            default:
                l.unknownKeyVals || (l.unknownKeyVals = []), l.unknownKeyVals.push(p);
        }
        u.push(l);
    }
    for (const c of Jy(a)){
        const l = {};
        for (const p of n[c])switch(Ya.checkPubkey(p), p.key[0]){
            case $n.REDEEM_SCRIPT:
                if (xi("output", p.key, $n.REDEEM_SCRIPT), l.redeemScript !== void 0) throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
                l.redeemScript = Ya.redeemScript.decode(p);
                break;
            case $n.WITNESS_SCRIPT:
                if (xi("output", p.key, $n.WITNESS_SCRIPT), l.witnessScript !== void 0) throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
                l.witnessScript = Ya.witnessScript.decode(p);
                break;
            case $n.BIP32_DERIVATION:
                l.bip32Derivation === void 0 && (l.bip32Derivation = []), l.bip32Derivation.push(Ya.bip32Derivation.decode(p));
                break;
            case $n.TAP_INTERNAL_KEY:
                xi("output", p.key, $n.TAP_INTERNAL_KEY), l.tapInternalKey = Ya.tapInternalKey.decode(p);
                break;
            case $n.TAP_TREE:
                xi("output", p.key, $n.TAP_TREE), l.tapTree = Ya.tapTree.decode(p);
                break;
            case $n.TAP_BIP32_DERIVATION:
                l.tapBip32Derivation === void 0 && (l.tapBip32Derivation = []), l.tapBip32Derivation.push(Ya.tapBip32Derivation.decode(p));
                break;
            default:
                l.unknownKeyVals || (l.unknownKeyVals = []), l.unknownKeyVals.push(p);
        }
        f.push(l);
    }
    return {
        globalMap: i,
        inputs: u,
        outputs: f
    };
}
function sV({ globalMap: e, inputs: t, outputs: r }) {
    const { globalKeyVals: n, inputKeyVals: i, outputKeyVals: o } = AE({
        globalMap: e,
        inputs: t,
        outputs: r
    }), s = J4(n), a = (l)=>l.length === 0 ? [
            Uint8Array.from([
                0
            ])
        ] : l.map(J4), u = a(i), f = a(o), c = new Uint8Array(5);
    return c.set([
        112,
        115,
        98,
        116,
        255
    ], 0), kn([
        c,
        s
    ].concat(u, f));
}
const aV = (e, t)=>It(e.key, t.key);
function Vw(e, t) {
    const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((o, [s, a])=>{
        if (s === "unknownKeyVals") return o;
        const u = t[s];
        if (u === void 0) return o;
        const f = (Array.isArray(a) ? a : [
            a
        ]).map(u.encode);
        return f.map((l)=>rr(l.key)).forEach((l)=>{
            if (r.has(l)) throw new Error("Serialize Error: Duplicate key: " + l);
            r.add(l);
        }), o.concat(f);
    }, []), i = e.unknownKeyVals ? e.unknownKeyVals.filter((o)=>!r.has(rr(o.key))) : [];
    return n.concat(i).sort(aV);
}
function AE({ globalMap: e, inputs: t, outputs: r }) {
    return {
        globalKeyVals: Vw(e, f3),
        inputKeyVals: t.map((n)=>Vw(n, Vn)),
        outputKeyVals: r.map((n)=>Vw(n, Ya))
    };
}
function cV(e) {
    const t = e[0], r = AE(t), n = e.slice(1);
    if (n.length === 0) throw new Error("Combine: Nothing to combine");
    const i = Q4(t);
    if (i === void 0) throw new Error("Combine: Self missing transaction");
    const o = ul(r.globalKeyVals), s = r.inputKeyVals.map(ul), a = r.outputKeyVals.map(ul);
    for (const u of n){
        const f = Q4(u);
        if (f === void 0 || It(f.toBuffer(), i.toBuffer()) !== 0) throw new Error("Combine: One of the Psbts does not have the same transaction.");
        const c = AE(u);
        ul(c.globalKeyVals).forEach(Gw(o, r.globalKeyVals, c.globalKeyVals)), c.inputKeyVals.map(ul).forEach((_, A)=>_.forEach(Gw(s[A], r.inputKeyVals[A], c.inputKeyVals[A]))), c.outputKeyVals.map(ul).forEach((_, A)=>_.forEach(Gw(a[A], r.outputKeyVals[A], c.outputKeyVals[A])));
    }
    return I7(i, {
        globalMapKeyVals: r.globalKeyVals,
        inputKeyVals: r.inputKeyVals,
        outputKeyVals: r.outputKeyVals
    });
}
function Gw(e, t, r) {
    return (n)=>{
        if (e.has(n)) return;
        const i = r.filter((o)=>rr(o.key) === n)[0];
        t.push(i), e.add(n);
    };
}
function Q4(e) {
    return e.globalMap.unsignedTx;
}
function ul(e) {
    const t = /* @__PURE__ */ new Set();
    return e.forEach((r)=>{
        const n = rr(r.key);
        if (t.has(n)) throw new Error("Combine: KeyValue Map keys should be unique");
        t.add(n);
    }), t;
}
function li(e, t) {
    const r = e[t];
    if (r === void 0) throw new Error(`No input #${t}`);
    return r;
}
function np(e, t) {
    const r = e[t];
    if (r === void 0) throw new Error(`No output #${t}`);
    return r;
}
function Zw(e, t, r) {
    if (e.key[0] < r) throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");
    if (t && t.filter((n)=>It(n.key, e.key) === 0).length !== 0) throw new Error(`Duplicate Key: ${rr(e.key)}`);
}
function Yw(e) {
    let t = 0;
    return Object.keys(e).forEach((r)=>{
        Number(isNaN(Number(r))) && t++;
    }), t;
}
function uV(e, t) {
    let r = !1;
    if (t.nonWitnessUtxo || t.witnessUtxo) {
        const n = !!t.redeemScript, i = !!t.witnessScript, o = !n || !!t.finalScriptSig, s = !i || !!t.finalScriptWitness, a = !!t.finalScriptSig || !!t.finalScriptWitness;
        r = o && s && a;
    }
    if (r === !1) throw new Error(`Input #${e} has too much or too little data to clean`);
}
function eA(e, t, r, n) {
    throw new Error(`Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`);
}
function l3(e) {
    return (t, r)=>{
        for (const n of Object.keys(t)){
            const i = t[n], { canAdd: o, canAddToArray: s, check: a, expected: u } = // @ts-ignore
            nV[e + "s"][n] || {}, f = !!s;
            if (a) if (f) {
                if (!Array.isArray(i) || // @ts-ignore
                r[n] && !Array.isArray(r[n])) throw new Error(`Key type ${n} must be an array`);
                i.every(a) || eA(e, n, u, i);
                const c = r[n] || [], l = /* @__PURE__ */ new Set();
                if (!i.every((p)=>s(c, p, l))) throw new Error("Can not add duplicate data to array");
                r[n] = c.concat(i);
            } else {
                if (a(i) || eA(e, n, u, i), !o(r, i)) throw new Error(`Can not add duplicate data to ${e}`);
                r[n] = i;
            }
        }
    };
}
const fV = l3("global"), B7 = l3("input"), O7 = l3("output");
function lV(e, t) {
    const r = e.length - 1, n = li(e, r);
    B7(t, n);
}
function dV(e, t) {
    const r = e.length - 1, n = np(e, r);
    O7(t, n);
}
let tA = class {
    constructor(t){
        this.inputs = [], this.outputs = [], this.globalMap = {
            unsignedTx: t
        };
    }
    static fromBase64(t, r) {
        const n = UB(t);
        return this.fromBuffer(n, r);
    }
    static fromHex(t, r) {
        const n = hc(t);
        return this.fromBuffer(n, r);
    }
    static fromBuffer(t, r) {
        const n = oV(t, r), i = new this(n.globalMap.unsignedTx);
        return Object.assign(i, n), i;
    }
    toBase64() {
        const t = this.toBuffer();
        return KH(t);
    }
    toHex() {
        const t = this.toBuffer();
        return rr(t);
    }
    toBuffer() {
        return sV(this);
    }
    updateGlobal(t) {
        return fV(t, this.globalMap), this;
    }
    updateInput(t, r) {
        const n = li(this.inputs, t);
        return B7(r, n), this;
    }
    updateOutput(t, r) {
        const n = np(this.outputs, t);
        return O7(r, n), this;
    }
    addUnknownKeyValToGlobal(t) {
        return Zw(t, this.globalMap.unknownKeyVals, Yw(ya)), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
    }
    addUnknownKeyValToInput(t, r) {
        const n = li(this.inputs, t);
        return Zw(r, n.unknownKeyVals, Yw(Dt)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
    }
    addUnknownKeyValToOutput(t, r) {
        const n = np(this.outputs, t);
        return Zw(r, n.unknownKeyVals, Yw($n)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
    }
    addInput(t) {
        this.globalMap.unsignedTx.addInput(t), this.inputs.push({
            unknownKeyVals: []
        });
        const r = t.unknownKeyVals || [], n = this.inputs.length - 1;
        if (!Array.isArray(r)) throw new Error("unknownKeyVals must be an Array");
        return r.forEach((i)=>this.addUnknownKeyValToInput(n, i)), lV(this.inputs, t), this;
    }
    addOutput(t) {
        this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
            unknownKeyVals: []
        });
        const r = t.unknownKeyVals || [], n = this.outputs.length - 1;
        if (!Array.isArray(r)) throw new Error("unknownKeyVals must be an Array");
        return r.forEach((i)=>this.addUnknownKeyValToOutput(n, i)), dV(this.outputs, t), this;
    }
    clearFinalizedInput(t) {
        const r = li(this.inputs, t);
        uV(t, r);
        for (const n of Object.keys(r))[
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
        ].includes(n) || delete r[n];
        return this;
    }
    combine(...t) {
        const r = cV([
            this
        ].concat(t));
        return Object.assign(this, r), this;
    }
    getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
    }
};
function Nf(e) {
    return (t)=>{
        try {
            return e({
                output: t
            }), !0;
        } catch  {
            return !1;
        }
    };
}
const hV = Nf(ab), pV = Nf(QB), gV = Nf(Vp), fb = Nf(Gp), rA = Nf(Zp), P7 = Nf(_d), N7 = Nf(xd);
function Qy(e) {
    let t = new Uint8Array(0);
    function r(s) {
        t = kn([
            t,
            s
        ]);
    }
    function n(s) {
        const a = t.length, u = ds(s);
        t = kn([
            t,
            new Uint8Array(u)
        ]), pu(s, t, a);
    }
    function i(s) {
        n(s.length), r(s);
    }
    function o(s) {
        n(s.length), s.forEach(i);
    }
    return o(e), t;
}
function M7(e, t) {
    const r = Rs(e), n = e.slice(1, 33), i = Sn(t);
    if (i === null) throw new Error("Unknown script error");
    return i.findIndex((o)=>typeof o == "number" ? !1 : It(e, o) === 0 || It(r, o) === 0 || It(n, o) === 0);
}
function lb(e, t) {
    return M7(e, t) !== -1;
}
function yV(e, t) {
    return mV(e).some((n)=>R7(n, Nh.decode, t));
}
function R7(e, t, r) {
    const { hashType: n } = t(e), i = [];
    switch(n & xn.SIGHASH_ANYONECANPAY && i.push("addInput"), n & 31){
        case xn.SIGHASH_ALL:
            break;
        case xn.SIGHASH_SINGLE:
        case xn.SIGHASH_NONE:
            i.push("addOutput"), i.push("setInputSequence");
            break;
    }
    return i.indexOf(r) === -1;
}
function mV(e) {
    let t = [];
    if ((e.partialSig || []).length === 0) {
        if (!e.finalScriptSig && !e.finalScriptWitness) return [];
        t = bV(e);
    } else t = e.partialSig;
    return t.map((r)=>r.signature);
}
function bV(e) {
    const t = e.finalScriptSig ? Sn(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? Sn(e.finalScriptWitness) || [] : [];
    return t.concat(r).filter((n)=>n instanceof Uint8Array && ac(n)).map((n)=>({
            signature: n
        }));
}
const Mo = (e)=>e.length === 32 ? e : e.slice(1, 33);
function nA(e, t, r) {
    const n = NV(t, e, r);
    try {
        const o = OV(t, n).concat(n.script).concat(n.controlBlock);
        return {
            finalScriptWitness: Qy(o)
        };
    } catch (i) {
        throw new Error(`Can not finalize taproot input #${e}: ${i}`);
    }
}
function Ig(e, t) {
    const r = t ? Uint8Array.from([
        t
    ]) : Uint8Array.from([]);
    return kn([
        e,
        r
    ]);
}
function Is(e) {
    return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && N7(e.witnessUtxo.script));
}
function Xw(e, t) {
    return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function iA(e, t, r) {
    kV(e, t, r), BV(e, t, r);
}
function oA(e, t, r) {
    IV(e, t, r), wV(e, t);
}
function wV(e, t) {
    if (!t.tapTree && !t.tapInternalKey) return;
    const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
    if (r) {
        const { script: i } = e, o = vV(r, n);
        if (i && It(o, i) !== 0) throw new Error("Error adding output. Script or address mismatch.");
    }
}
function vV(e, t) {
    const r = t && _V(t.leaves), { output: n } = xd({
        internalPubkey: e,
        scriptTree: r
    });
    return n;
}
function _V(e = []) {
    return e.length === 1 && e[0].depth === 0 ? {
        output: e[0].script,
        version: e[0].leafVersion
    } : TV(e);
}
function EV(e, t) {
    return SV(e).some((n)=>R7(n, xV, t));
}
function xV(e) {
    return {
        signature: e.slice(0, 64),
        hashType: e.slice(64)[0] || xn.SIGHASH_DEFAULT
    };
}
function SV(e) {
    const t = [];
    if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r)=>r.signature)), !t.length) {
        const r = AV(e.finalScriptWitness);
        r && t.push(r);
    }
    return t;
}
function AV(e) {
    if (!e) return;
    const t = e.slice(2);
    if (t.length === 64 || t.length === 65) return t;
}
function TV(e) {
    let t;
    for (const r of e)if (t = TE(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
    return t;
}
function TE(e, t, r = 0) {
    if (r > mK) throw new Error("Max taptree depth exceeded.");
    if (e.depth === r) return t ? void 0 : {
        output: e.script,
        version: e.leafVersion
    };
    if (Jx(t)) return;
    const n = TE(e, t && t[0], r + 1);
    if (n) return [
        n,
        t && t[1]
    ];
    const i = TE(e, t && t[1], r + 1);
    if (i) return [
        t && t[0],
        i
    ];
}
function kV(e, t, r) {
    const n = Is(e) && zl(t), i = zl(e) && Is(t), o = e === t && Is(t) && zl(t);
    if (n || i || o) throw new Error(`Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`);
}
function IV(e, t, r) {
    const n = Xw(e) && zl(t), i = zl(e) && Xw(t), o = e === t && Xw(t) && zl(t);
    if (n || i || o) throw new Error(`Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`);
}
function BV(e, t, r) {
    if (t.tapMerkleRoot) {
        const n = (t.tapLeafScript || []).every((o)=>Jw(o, t.tapMerkleRoot)), i = (e.tapLeafScript || []).every((o)=>Jw(o, t.tapMerkleRoot));
        if (!n || !i) throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
    } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every((i)=>Jw(i, e.tapMerkleRoot))) throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
}
function Jw(e, t) {
    if (!t) return !0;
    const r = tc({
        output: e.script,
        version: e.leafVersion
    }), n = EE(e.controlBlock, r);
    return It(n, t) === 0;
}
function OV(e, t) {
    const r = tc({
        output: t.script,
        version: t.leafVersion
    });
    return (e.tapScriptSig || []).filter((n)=>It(n.leafHash, r) === 0).map((n)=>PV(t.script, n)).sort((n, i)=>i.positionInScript - n.positionInScript).map((n)=>n.signature);
}
function PV(e, t) {
    return Object.assign({
        positionInScript: M7(t.pubkey, e)
    }, t);
}
function NV(e, t, r) {
    if (!e.tapScriptSig || !e.tapScriptSig.length) throw new Error(`Can not finalize taproot input #${t}. No tapleaf script signature provided.`);
    const n = (e.tapLeafScript || []).sort((i, o)=>i.controlBlock.length - o.controlBlock.length).find((i)=>MV(i, e.tapScriptSig, r));
    if (!n) throw new Error(`Can not finalize taproot input #${t}. Signature for tapleaf script not found.`);
    return n;
}
function MV(e, t, r) {
    const n = tc({
        output: e.script,
        version: e.leafVersion
    });
    return (!r || It(n, r) === 0) && t.find((o)=>It(o.leafHash, n) === 0) !== void 0;
}
function zl(e) {
    return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const RV = {
    /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */ network: zs,
    /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */ maximumFeeRate: 5e3
};
class Cr {
    constructor(t = {}, r = new tA(new C7())){
        pt(this, "data");
        pt(this, "__CACHE");
        pt(this, "opts");
        this.data = r, this.opts = Object.assign({}, RV, t), this.__CACHE = {
            __NON_WITNESS_UTXO_TX_CACHE: [],
            __NON_WITNESS_UTXO_BUF_CACHE: [],
            __TX_IN_CACHE: {},
            __TX: this.data.globalMap.unsignedTx.tx,
            // Psbt's predecessor (TransactionBuilder - now removed) behavior
            // was to not confirm input values  before signing.
            // Even though we highly encourage people to get
            // the full parent transaction to verify values, the ability to
            // sign non-segwit inputs without the full transaction was often
            // requested. So the only way to activate is to use @ts-ignore.
            // We will disable exporting the Psbt when unsafe sign is active.
            // because it is not BIP174 compliant.
            __UNSAFE_SIGN_NONSEGWIT: !1
        }, this.data.inputs.length === 0 && this.setVersion(2);
        const n = (i, o, s, a)=>Object.defineProperty(i, o, {
                enumerable: s,
                writable: a
            });
        n(this, "__CACHE", !1, !0), n(this, "opts", !1, !0);
    }
    static fromBase64(t, r = {}) {
        const n = UB(t);
        return this.fromBuffer(n, r);
    }
    static fromHex(t, r = {}) {
        const n = hc(t);
        return this.fromBuffer(n, r);
    }
    static fromBuffer(t, r = {}) {
        const n = tA.fromBuffer(t, CV), i = new Cr(r, n);
        return FV(i.__CACHE.__TX, i.__CACHE), i;
    }
    get inputCount() {
        return this.data.inputs.length;
    }
    get version() {
        return this.__CACHE.__TX.version;
    }
    set version(t) {
        this.setVersion(t);
    }
    get locktime() {
        return this.__CACHE.__TX.locktime;
    }
    set locktime(t) {
        this.setLocktime(t);
    }
    get txInputs() {
        return this.__CACHE.__TX.ins.map((t)=>({
                hash: V4(t.hash),
                index: t.index,
                sequence: t.sequence
            }));
    }
    get txOutputs() {
        return this.__CACHE.__TX.outs.map((t)=>{
            let r;
            try {
                r = Yp(t.script, this.opts.network);
            } catch  {}
            return {
                script: V4(t.script),
                value: t.value,
                address: r
            };
        });
    }
    combine(...t) {
        return this.data.combine(...t.map((r)=>r.data)), this;
    }
    clone() {
        const t = Cr.fromBuffer(this.data.toBuffer());
        return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
    }
    setMaximumFeeRate(t) {
        Bg(t), this.opts.maximumFeeRate = t;
    }
    setVersion(t) {
        Bg(t), fh(this.data.inputs, "setVersion");
        const r = this.__CACHE;
        return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
    }
    setLocktime(t) {
        Bg(t), fh(this.data.inputs, "setLocktime");
        const r = this.__CACHE;
        return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
    }
    setInputSequence(t, r) {
        Bg(r), fh(this.data.inputs, "setInputSequence");
        const n = this.__CACHE;
        if (n.__TX.ins.length <= t) throw new Error("Input index too high");
        return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
    }
    addInputs(t) {
        return t.forEach((r)=>this.addInput(r)), this;
    }
    addInput(t) {
        if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0) throw new Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");
        iA(t, t, "addInput"), fh(this.data.inputs, "addInput"), t.witnessScript && em(t.witnessScript);
        const r = this.__CACHE;
        this.data.addInput(t);
        const n = r.__TX.ins[r.__TX.ins.length - 1];
        L7(r, n);
        const i = this.data.inputs.length - 1, o = this.data.inputs[i];
        return o.nonWitnessUtxo && IE(this.__CACHE, o, i), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
    }
    addOutputs(t) {
        return t.forEach((r)=>this.addOutput(r)), this;
    }
    addOutput(t) {
        if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0) throw new Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");
        fh(this.data.inputs, "addOutput");
        const { address: r } = t;
        if (typeof r == "string") {
            const { network: i } = this.opts, o = hs(r, i);
            t = Object.assign({}, t, {
                script: o
            });
        }
        oA(t, t, "addOutput");
        const n = this.__CACHE;
        return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
    }
    extractTransaction(t) {
        if (!this.data.inputs.every(U7)) throw new Error("Not finalized");
        const r = this.__CACHE;
        if (t || $V(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
        const n = r.__TX.clone();
        return q7(this.data.inputs, n, r, !0), n;
    }
    getFeeRate() {
        return fA("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
    }
    getFee() {
        return fA("__FEE", "fee", this.data.inputs, this.__CACHE);
    }
    finalizeAllInputs() {
        return li(this.data.inputs, 0), lh(this.data.inputs.length).forEach((t)=>this.finalizeInput(t)), this;
    }
    finalizeInput(t, r) {
        const n = li(this.data.inputs, t);
        return Is(n) ? this._finalizeTaprootInput(t, n, void 0, r) : this._finalizeInput(t, n, r);
    }
    finalizeTaprootInput(t, r, n = nA) {
        const i = li(this.data.inputs, t);
        if (Is(i)) return this._finalizeTaprootInput(t, i, r, n);
        throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
    }
    _finalizeInput(t, r, n = zV) {
        const { script: i, isP2SH: o, isP2WSH: s, isSegwit: a } = KV(t, r, this.__CACHE);
        if (!i) throw new Error(`No script found for input #${t}`);
        LV(r);
        const { finalScriptSig: u, finalScriptWitness: f } = n(t, r, i, a, o, s);
        if (u && this.data.updateInput(t, {
            finalScriptSig: u
        }), f && this.data.updateInput(t, {
            finalScriptWitness: f
        }), !u && !f) throw new Error(`Unknown error finalizing input #${t}`);
        return this.data.clearFinalizedInput(t), this;
    }
    _finalizeTaprootInput(t, r, n, i = nA) {
        if (!r.witnessUtxo) throw new Error(`Cannot finalize input #${t}. Missing withness utxo.`);
        if (r.tapKeySig) {
            const o = xd({
                output: r.witnessUtxo.script,
                signature: r.tapKeySig
            }), s = Qy(o.witness);
            this.data.updateInput(t, {
                finalScriptWitness: s
            });
        } else {
            const { finalScriptWitness: o } = i(t, r, n);
            this.data.updateInput(t, {
                finalScriptWitness: o
            });
        }
        return this.data.clearFinalizedInput(t), this;
    }
    getInputType(t) {
        const r = li(this.data.inputs, t), n = K7(t, r, this.__CACHE), i = hb(n, t, "input", r.redeemScript || YV(r.finalScriptSig), r.witnessScript || XV(r.finalScriptWitness)), o = i.type === "raw" ? "" : i.type + "-", s = V7(i.meaningfulScript);
        return o + s;
    }
    inputHasPubkey(t, r) {
        const n = li(this.data.inputs, t);
        return GV(r, n, t, this.__CACHE);
    }
    inputHasHDKey(t, r) {
        const n = li(this.data.inputs, t), i = aA(r);
        return !!n.bip32Derivation && n.bip32Derivation.some(i);
    }
    outputHasPubkey(t, r) {
        const n = np(this.data.outputs, t);
        return ZV(r, n, t, this.__CACHE);
    }
    outputHasHDKey(t, r) {
        const n = np(this.data.outputs, t), i = aA(r);
        return !!n.bip32Derivation && n.bip32Derivation.some(i);
    }
    validateSignaturesOfAllInputs(t) {
        return li(this.data.inputs, 0), lh(this.data.inputs.length).map((n)=>this.validateSignaturesOfInput(n, t)).reduce((n, i)=>i === !0 && n, !0);
    }
    validateSignaturesOfInput(t, r, n) {
        const i = this.data.inputs[t];
        return Is(i) ? this.validateSignaturesOfTaprootInput(t, r, n) : this._validateSignaturesOfInput(t, r, n);
    }
    _validateSignaturesOfInput(t, r, n) {
        const i = this.data.inputs[t], o = (i || {}).partialSig;
        if (!i || !o || o.length < 1) throw new Error("No signatures to validate");
        if (typeof r != "function") throw new Error("Need validator function to validate signatures");
        const s = n ? o.filter((l)=>It(l.pubkey, n) === 0) : o;
        if (s.length < 1) throw new Error("No signatures for this pubkey");
        const a = [];
        let u, f, c;
        for (const l of s){
            const p = Nh.decode(l.signature), { hash: y, script: _ } = c !== p.hashType ? F7(t, Object.assign({}, i, {
                sighashType: p.hashType
            }), this.__CACHE, !0) : {
                hash: u,
                script: f
            };
            c = p.hashType, u = y, f = _, $7(l.pubkey, _, "verify"), a.push(r(l.pubkey, y, p.signature));
        }
        return a.every((l)=>l === !0);
    }
    validateSignaturesOfTaprootInput(t, r, n) {
        const i = this.data.inputs[t], o = (i || {}).tapKeySig, s = (i || {}).tapScriptSig;
        if (!i && !o && !(s && !s.length)) throw new Error("No signatures to validate");
        if (typeof r != "function") throw new Error("Need validator function to validate signatures");
        n = n && Mo(n);
        const a = n ? kE(t, i, this.data.inputs, n, this.__CACHE) : HV(t, i, this.data.inputs, this.__CACHE);
        if (!a.length) throw new Error("No signatures for this pubkey");
        const u = a.find((c)=>!c.leafHash);
        let f = 0;
        if (o && u) {
            if (!r(u.pubkey, u.hash, dA(o))) return !1;
            f++;
        }
        if (s) for (const c of s){
            const l = a.find((p)=>It(p.pubkey, c.pubkey) === 0);
            if (l) {
                if (!r(c.pubkey, l.hash, dA(c.signature))) return !1;
                f++;
            }
        }
        return f > 0;
    }
    signAllInputsHD(t, r = [
        xn.SIGHASH_ALL
    ]) {
        if (!t || !t.publicKey || !t.fingerprint) throw new Error("Need HDSigner to sign input");
        const n = [];
        for (const i of lh(this.data.inputs.length))try {
            this.signInputHD(i, t, r), n.push(!0);
        } catch  {
            n.push(!1);
        }
        if (n.every((i)=>i === !1)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsHDAsync(t, r = [
        xn.SIGHASH_ALL
    ]) {
        return new Promise((n, i)=>{
            if (!t || !t.publicKey || !t.fingerprint) return i(new Error("Need HDSigner to sign input"));
            const o = [], s = [];
            for (const a of lh(this.data.inputs.length))s.push(this.signInputHDAsync(a, t, r).then(()=>{
                o.push(!0);
            }, ()=>{
                o.push(!1);
            }));
            return Promise.all(s).then(()=>{
                if (o.every((a)=>a === !1)) return i(new Error("No inputs were signed"));
                n();
            });
        });
    }
    signInputHD(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        if (!r || !r.publicKey || !r.fingerprint) throw new Error("Need HDSigner to sign input");
        return hA(t, this.data.inputs, r).forEach((o)=>this.signInput(t, o, n)), this;
    }
    signInputHDAsync(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        return new Promise((i, o)=>{
            if (!r || !r.publicKey || !r.fingerprint) return o(new Error("Need HDSigner to sign input"));
            const a = hA(t, this.data.inputs, r).map((u)=>this.signInputAsync(t, u, n));
            return Promise.all(a).then(()=>{
                i();
            }).catch(o);
        });
    }
    signAllInputs(t, r) {
        if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
        const n = [];
        for (const i of lh(this.data.inputs.length))try {
            this.signInput(i, t, r), n.push(!0);
        } catch  {
            n.push(!1);
        }
        if (n.every((i)=>i === !1)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsAsync(t, r) {
        return new Promise((n, i)=>{
            if (!t || !t.publicKey) return i(new Error("Need Signer to sign input"));
            const o = [], s = [];
            for (const [a] of this.data.inputs.entries())s.push(this.signInputAsync(a, t, r).then(()=>{
                o.push(!0);
            }, ()=>{
                o.push(!1);
            }));
            return Promise.all(s).then(()=>{
                if (o.every((a)=>a === !1)) return i(new Error("No inputs were signed"));
                n();
            });
        });
    }
    signInput(t, r, n) {
        if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
        const i = li(this.data.inputs, t);
        return Is(i) ? this._signTaprootInput(t, i, r, void 0, n) : this._signInput(t, r, n);
    }
    signTaprootInput(t, r, n, i) {
        if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
        const o = li(this.data.inputs, t);
        if (Is(o)) return this._signTaprootInput(t, o, r, n, i);
        throw new Error(`Input #${t} is not of type Taproot.`);
    }
    _signInput(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        const { hash: i, sighashType: o } = lA(this.data.inputs, t, r.publicKey, this.__CACHE, n), s = [
            {
                pubkey: r.publicKey,
                signature: Nh.encode(r.sign(i), o)
            }
        ];
        return this.data.updateInput(t, {
            partialSig: s
        }), this;
    }
    _signTaprootInput(t, r, n, i, o = [
        xn.SIGHASH_DEFAULT
    ]) {
        const s = this.checkTaprootHashesForSig(t, r, n, i, o), a = s.filter((f)=>!f.leafHash).map((f)=>Ig(n.signSchnorr(f.hash), r.sighashType))[0], u = s.filter((f)=>!!f.leafHash).map((f)=>({
                pubkey: Mo(n.publicKey),
                signature: Ig(n.signSchnorr(f.hash), r.sighashType),
                leafHash: f.leafHash
            }));
        return a && this.data.updateInput(t, {
            tapKeySig: a
        }), u.length && this.data.updateInput(t, {
            tapScriptSig: u
        }), this;
    }
    signInputAsync(t, r, n) {
        return Promise.resolve().then(()=>{
            if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
            const i = li(this.data.inputs, t);
            return Is(i) ? this._signTaprootInputAsync(t, i, r, void 0, n) : this._signInputAsync(t, r, n);
        });
    }
    signTaprootInputAsync(t, r, n, i) {
        return Promise.resolve().then(()=>{
            if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
            const o = li(this.data.inputs, t);
            if (Is(o)) return this._signTaprootInputAsync(t, o, r, n, i);
            throw new Error(`Input #${t} is not of type Taproot.`);
        });
    }
    _signInputAsync(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        const { hash: i, sighashType: o } = lA(this.data.inputs, t, r.publicKey, this.__CACHE, n);
        return Promise.resolve(r.sign(i)).then((s)=>{
            const a = [
                {
                    pubkey: r.publicKey,
                    signature: Nh.encode(s, o)
                }
            ];
            this.data.updateInput(t, {
                partialSig: a
            });
        });
    }
    async _signTaprootInputAsync(t, r, n, i, o = [
        xn.SIGHASH_DEFAULT
    ]) {
        const s = this.checkTaprootHashesForSig(t, r, n, i, o), a = [], u = s.filter((c)=>!c.leafHash)[0];
        if (u) {
            const c = Promise.resolve(n.signSchnorr(u.hash)).then((l)=>({
                    tapKeySig: Ig(l, r.sighashType)
                }));
            a.push(c);
        }
        const f = s.filter((c)=>!!c.leafHash);
        if (f.length) {
            const c = f.map((l)=>Promise.resolve(n.signSchnorr(l.hash)).then((p)=>({
                        tapScriptSig: [
                            {
                                pubkey: Mo(n.publicKey),
                                signature: Ig(p, r.sighashType),
                                leafHash: l.leafHash
                            }
                        ]
                    })));
            a.push(...c);
        }
        return Promise.all(a).then((c)=>{
            c.forEach((l)=>this.data.updateInput(t, l));
        });
    }
    checkTaprootHashesForSig(t, r, n, i, o) {
        if (typeof n.signSchnorr != "function") throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
        const s = kE(t, r, this.data.inputs, n.publicKey, this.__CACHE, i, o);
        if (!s || !s.length) throw new Error(`Can not sign for input #${t} with the key ${rr(n.publicKey)}`);
        return s;
    }
    toBuffer() {
        return Qw(this.__CACHE), this.data.toBuffer();
    }
    toHex() {
        return Qw(this.__CACHE), this.data.toHex();
    }
    toBase64() {
        return Qw(this.__CACHE), this.data.toBase64();
    }
    updateGlobal(t) {
        return this.data.updateGlobal(t), this;
    }
    updateInput(t, r) {
        return r.witnessScript && em(r.witnessScript), iA(this.data.inputs[t], r, "updateInput"), this.data.updateInput(t, r), r.nonWitnessUtxo && IE(this.__CACHE, this.data.inputs[t], t), this;
    }
    updateOutput(t, r) {
        const n = this.data.outputs[t];
        return oA(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
    }
    addUnknownKeyValToGlobal(t) {
        return this.data.addUnknownKeyValToGlobal(t), this;
    }
    addUnknownKeyValToInput(t, r) {
        return this.data.addUnknownKeyValToInput(t, r), this;
    }
    addUnknownKeyValToOutput(t, r) {
        return this.data.addUnknownKeyValToOutput(t, r), this;
    }
    clearFinalizedInput(t) {
        return this.data.clearFinalizedInput(t), this;
    }
}
const CV = (e)=>new C7(e);
class C7 {
    constructor(t = Uint8Array.from([
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ])){
        pt(this, "tx");
        this.tx = xn.fromBuffer(t), DV(this.tx), Object.defineProperty(this, "tx", {
            enumerable: !1,
            writable: !0
        });
    }
    getInputOutputCounts() {
        return {
            inputCount: this.tx.ins.length,
            outputCount: this.tx.outs.length
        };
    }
    addInput(t) {
        if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number") throw new Error("Error adding input.");
        const r = typeof t.hash == "string" ? s3(hc(t.hash)) : t.hash;
        this.tx.addInput(r, t.index, t.sequence);
    }
    addOutput(t) {
        if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint") throw new Error("Error adding output.");
        this.tx.addOutput(t.script, t.value);
    }
    toBuffer() {
        return this.tx.toBuffer();
    }
}
function UV(e, t, r) {
    switch(r){
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
            return sA(1, e.partialSig);
        case "multisig":
            const n = ab({
                output: t
            });
            return sA(n.m, e.partialSig, n.pubkeys);
        default:
            return !1;
    }
}
function Qw(e) {
    if (e.__UNSAFE_SIGN_NONSEGWIT !== !1) throw new Error("Not BIP174 compliant, can not export");
}
function sA(e, t, r) {
    if (!t) return !1;
    let n;
    if (r ? n = r.map((i)=>{
        const o = JV(i);
        return t.find((s)=>It(s.pubkey, o) === 0);
    }).filter((i)=>!!i) : n = t, n.length > e) throw new Error("Too many signatures");
    return n.length === e;
}
function U7(e) {
    return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function aA(e) {
    return (t)=>!(It(e.fingerprint, t.masterFingerprint) || It(e.derivePath(t.path).publicKey, t.pubkey));
}
function Bg(e) {
    if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0) throw new Error("Invalid 32 bit integer");
}
function $V(e, t, r) {
    const n = t.__FEE_RATE || e.getFeeRate(), i = t.__EXTRACTED_TX.virtualSize(), o = n * i;
    if (n >= r.maximumFeeRate) throw new Error(`Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`);
}
function fh(e, t) {
    e.forEach((r)=>{
        if (Is(r) ? EV(r, t) : yV(r, t)) throw new Error("Can not modify transaction, signatures exist.");
    });
}
function LV(e) {
    if (!e.sighashType || !e.partialSig) return;
    const { partialSig: t, sighashType: r } = e;
    t.forEach((n)=>{
        const { hashType: i } = Nh.decode(n.signature);
        if (r !== i) throw new Error("Signature sighash does not match input sighash type");
    });
}
function $7(e, t, r) {
    if (!lb(e, t)) throw new Error(`Can not ${r} for this input with the key ${rr(e)}`);
}
function DV(e) {
    if (!e.ins.every((r)=>r.script && r.script.length === 0 && r.witness && r.witness.length === 0)) throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function FV(e, t) {
    e.ins.forEach((r)=>{
        L7(t, r);
    });
}
function L7(e, t) {
    const r = rr(s3(Uint8Array.from(t.hash))) + ":" + t.index;
    if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
    e.__TX_IN_CACHE[r] = 1;
}
function D7(e, t) {
    return (r, n, i, o)=>{
        const s = e({
            redeem: {
                output: i
            }
        }).output;
        if (It(n, s)) throw new Error(`${t} for ${o} #${r} doesn't match the scriptPubKey in the prevout`);
    };
}
const cA = D7(_d, "Redeem script"), uA = D7(Zp, "Witness script");
function fA(e, t, r, n) {
    if (!r.every(U7)) throw new Error(`PSBT must be finalized to calculate ${t}`);
    if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
    if (e === "__FEE" && n.__FEE) return n.__FEE;
    let i, o = !0;
    if (n.__EXTRACTED_TX ? (i = n.__EXTRACTED_TX, o = !1) : i = n.__TX.clone(), q7(r, i, n, o), e === "__FEE_RATE") return n.__FEE_RATE;
    if (e === "__FEE") return n.__FEE;
}
function zV(e, t, r, n, i, o) {
    const s = V7(r);
    if (!UV(t, r, s)) throw new Error(`Can not finalize input #${e}`);
    return jV(r, s, t.partialSig, n, i, o);
}
function jV(e, t, r, n, i, o) {
    let s, a;
    const u = qV(e, t, r), f = o ? Zp({
        redeem: u
    }) : null, c = i ? _d({
        redeem: f || u
    }) : null;
    return n ? (f ? a = Qy(f.witness) : a = Qy(u.witness), c && (s = c.input)) : c ? s = c.input : s = u.input, {
        finalScriptSig: s,
        finalScriptWitness: a
    };
}
function lA(e, t, r, n, i) {
    const o = li(e, t), { hash: s, sighashType: a, script: u } = F7(t, o, n, !1, i);
    return $7(r, u, "sign"), {
        hash: s,
        sighashType: a
    };
}
function F7(e, t, r, n, i) {
    const o = r.__TX, s = t.sighashType || xn.SIGHASH_ALL;
    j7(s, i);
    let a, u;
    if (t.nonWitnessUtxo) {
        const l = db(r, t, e), p = o.ins[e].hash, y = l.getHash();
        if (It(p, y) !== 0) throw new Error(`Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`);
        const _ = o.ins[e].index;
        u = l.outs[_];
    } else if (t.witnessUtxo) u = t.witnessUtxo;
    else throw new Error("Need a Utxo input item for signing");
    const { meaningfulScript: f, type: c } = hb(u.script, e, "input", t.redeemScript, t.witnessScript);
    if ([
        "p2sh-p2wsh",
        "p2wsh"
    ].indexOf(c) >= 0) a = o.hashForWitnessV0(e, f, u.value, s);
    else if (fb(f)) {
        const l = Vp({
            hash: f.slice(2)
        }).output;
        a = o.hashForWitnessV0(e, l, u.value, s);
    } else {
        if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1) throw new Error(`Input #${e} has witnessUtxo but non-segwit script: ${rr(f)}`);
        !n && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(`Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`), a = o.hashForSignature(e, f, s);
    }
    return {
        script: f,
        sighashType: s,
        hash: a
    };
}
function HV(e, t, r, n) {
    const i = [];
    if (t.tapInternalKey) {
        const s = z7(e, t, n);
        s && i.push(s);
    }
    if (t.tapScriptSig) {
        const s = t.tapScriptSig.map((a)=>a.pubkey);
        i.push(...s);
    }
    return i.map((s)=>kE(e, t, r, s, n)).flat();
}
function z7(e, t, r) {
    const { script: n } = d3(e, t, r);
    return N7(n) ? n.subarray(2, 34) : null;
}
function dA(e) {
    return e.length === 64 ? e : e.subarray(0, 64);
}
function kE(e, t, r, n, i, o, s) {
    const a = i.__TX, u = t.sighashType || xn.SIGHASH_DEFAULT;
    j7(u, s);
    const f = r.map((_, A)=>d3(A, _, i)), c = f.map((_)=>_.script), l = f.map((_)=>_.value), p = [];
    if (t.tapInternalKey && !o) {
        const _ = z7(e, t, i) || Uint8Array.from([]);
        if (It(Mo(n), _) === 0) {
            const A = a.hashForWitnessV1(e, c, l, u);
            p.push({
                pubkey: n,
                hash: A
            });
        }
    }
    const y = (t.tapLeafScript || []).filter((_)=>lb(n, _.script)).map((_)=>{
        const A = tc({
            output: _.script,
            version: _.leafVersion
        });
        return Object.assign({
            hash: A
        }, _);
    }).filter((_)=>!o || It(o, _.hash) === 0).map((_)=>{
        const A = a.hashForWitnessV1(e, c, l, u, _.hash);
        return {
            pubkey: n,
            hash: A,
            leafHash: _.hash
        };
    });
    return p.concat(y);
}
function j7(e, t) {
    if (t && t.indexOf(e) < 0) {
        const r = VV(e);
        throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`);
    }
}
function qV(e, t, r) {
    let n;
    switch(t){
        case "multisig":
            const i = WV(e, r);
            n = ab({
                output: e,
                signatures: i
            });
            break;
        case "pubkey":
            n = QB({
                output: e,
                signature: r[0].signature
            });
            break;
        case "pubkeyhash":
            n = Vp({
                output: e,
                pubkey: r[0].pubkey,
                signature: r[0].signature
            });
            break;
        case "witnesspubkeyhash":
            n = Gp({
                output: e,
                pubkey: r[0].pubkey,
                signature: r[0].signature
            });
            break;
    }
    return n;
}
function KV(e, t, r) {
    const n = r.__TX, i = {
        script: null,
        isSegwit: !1,
        isP2SH: !1,
        isP2WSH: !1
    };
    if (i.isP2SH = !!t.redeemScript, i.isP2WSH = !!t.witnessScript, t.witnessScript) i.script = t.witnessScript;
    else if (t.redeemScript) i.script = t.redeemScript;
    else if (t.nonWitnessUtxo) {
        const o = db(r, t, e), s = n.ins[e].index;
        i.script = o.outs[s].script;
    } else t.witnessUtxo && (i.script = t.witnessUtxo.script);
    return (t.witnessScript || fb(i.script)) && (i.isSegwit = !0), i;
}
function hA(e, t, r) {
    const n = li(t, e);
    if (!n.bip32Derivation || n.bip32Derivation.length === 0) throw new Error("Need bip32Derivation to sign with HD");
    const i = n.bip32Derivation.map((s)=>{
        if (It(s.masterFingerprint, r.fingerprint) === 0) return s;
    }).filter((s)=>!!s);
    if (i.length === 0) throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
    return i.map((s)=>{
        const a = r.derivePath(s.path);
        if (It(s.pubkey, a.publicKey) !== 0) throw new Error("pubkey did not match bip32Derivation");
        return a;
    });
}
function WV(e, t) {
    return ab({
        output: e
    }).pubkeys.map((n)=>(t.filter((i)=>It(i.pubkey, n) === 0)[0] || {}).signature).filter((n)=>!!n);
}
function H7(e) {
    let t = 0;
    function r(s) {
        return t += s, e.slice(t - s, t);
    }
    function n() {
        const s = Ed(e, t);
        return t += ds(s.bigintValue), s.numberValue;
    }
    function i() {
        return r(n());
    }
    function o() {
        const s = n(), a = [];
        for(let u = 0; u < s; u++)a.push(i());
        return a;
    }
    return o();
}
function VV(e) {
    let t = e & xn.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
    switch(e & 31){
        case xn.SIGHASH_ALL:
            t += "SIGHASH_ALL";
            break;
        case xn.SIGHASH_SINGLE:
            t += "SIGHASH_SINGLE";
            break;
        case xn.SIGHASH_NONE:
            t += "SIGHASH_NONE";
            break;
    }
    return t;
}
function IE(e, t, r) {
    e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
    const n = xn.fromBuffer(t.nonWitnessUtxo);
    e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
    const i = e, o = r;
    delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
        enumerable: !0,
        get () {
            const s = i.__NON_WITNESS_UTXO_BUF_CACHE[o], a = i.__NON_WITNESS_UTXO_TX_CACHE[o];
            if (s !== void 0) return s;
            {
                const u = a.toBuffer();
                return i.__NON_WITNESS_UTXO_BUF_CACHE[o] = u, u;
            }
        },
        set (s) {
            i.__NON_WITNESS_UTXO_BUF_CACHE[o] = s;
        }
    });
}
function q7(e, t, r, n) {
    let i = 0n;
    e.forEach((u, f)=>{
        if (n && u.finalScriptSig && (t.ins[f].script = u.finalScriptSig), n && u.finalScriptWitness && (t.ins[f].witness = H7(u.finalScriptWitness)), u.witnessUtxo) i += u.witnessUtxo.value;
        else if (u.nonWitnessUtxo) {
            const c = db(r, u, f), l = t.ins[f].index, p = c.outs[l];
            i += p.value;
        }
    });
    const o = t.outs.reduce((u, f)=>u + f.value, 0n), s = i - o;
    if (s < 0) throw new Error("Outputs are spending more than Inputs");
    const a = t.virtualSize();
    r.__FEE = s, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(s / BigInt(a)));
}
function db(e, t, r) {
    const n = e.__NON_WITNESS_UTXO_TX_CACHE;
    return n[r] || IE(e, t, r), n[r];
}
function K7(e, t, r) {
    const { script: n } = d3(e, t, r);
    return n;
}
function d3(e, t, r) {
    if (t.witnessUtxo !== void 0) return {
        script: t.witnessUtxo.script,
        value: t.witnessUtxo.value
    };
    if (t.nonWitnessUtxo !== void 0) {
        const i = db(r, t, e).outs[r.__TX.ins[e].index];
        return {
            script: i.script,
            value: i.value
        };
    } else throw new Error("Can't find pubkey in input without Utxo data");
}
function GV(e, t, r, n) {
    const i = K7(r, t, n), { meaningfulScript: o } = hb(i, r, "input", t.redeemScript, t.witnessScript);
    return lb(e, o);
}
function ZV(e, t, r, n) {
    const i = n.__TX.outs[r].script, { meaningfulScript: o } = hb(i, r, "output", t.redeemScript, t.witnessScript);
    return lb(e, o);
}
function YV(e) {
    if (!e) return;
    const t = Sn(e);
    if (!t) return;
    const r = t[t.length - 1];
    if (!(!(r instanceof Uint8Array) || W7(r) || QV(r) || !Sn(r))) return r;
}
function XV(e) {
    if (!e) return;
    const t = H7(e), r = t[t.length - 1];
    if (!(W7(r) || !Sn(r))) return r;
}
function JV(e) {
    if (e.length === 65) {
        const t = e[64] & 1, r = e.slice(0, 33);
        return r[0] = 2 | t, r;
    }
    return e.slice();
}
function W7(e) {
    return e.length === 33 && yq(e);
}
function QV(e) {
    return ac(e);
}
function hb(e, t, r, n, i) {
    const o = P7(e), s = o && n && rA(n), a = rA(e);
    if (o && n === void 0) throw new Error("scriptPubkey is P2SH but redeemScript missing");
    if ((a || s) && i === void 0) throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    let u;
    return s ? (u = i, cA(t, e, n, r), uA(t, n, i, r), em(u)) : a ? (u = i, uA(t, e, i, r), em(u)) : o ? (u = n, cA(t, e, n, r)) : u = e, {
        meaningfulScript: u,
        type: s ? "p2sh-p2wsh" : o ? "p2sh" : a ? "p2wsh" : "raw"
    };
}
function em(e) {
    if (fb(e) || P7(e)) throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function V7(e) {
    return fb(e) ? "witnesspubkeyhash" : gV(e) ? "pubkeyhash" : hV(e) ? "multisig" : pV(e) ? "pubkey" : "nonstandard";
}
function lh(e) {
    return [
        ...Array(e).keys()
    ];
}
function eG(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var G7 = {
    exports: {}
}, Dn = G7.exports = {}, ua, fa;
function BE() {
    throw new Error("setTimeout has not been defined");
}
function OE() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        typeof setTimeout == "function" ? ua = setTimeout : ua = BE;
    } catch  {
        ua = BE;
    }
    try {
        typeof clearTimeout == "function" ? fa = clearTimeout : fa = OE;
    } catch  {
        fa = OE;
    }
})();
function Z7(e) {
    if (ua === setTimeout) return setTimeout(e, 0);
    if ((ua === BE || !ua) && setTimeout) return ua = setTimeout, setTimeout(e, 0);
    try {
        return ua(e, 0);
    } catch  {
        try {
            return ua.call(null, e, 0);
        } catch  {
            return ua.call(this, e, 0);
        }
    }
}
function tG(e) {
    if (fa === clearTimeout) return clearTimeout(e);
    if ((fa === OE || !fa) && clearTimeout) return fa = clearTimeout, clearTimeout(e);
    try {
        return fa(e);
    } catch  {
        try {
            return fa.call(null, e);
        } catch  {
            return fa.call(this, e);
        }
    }
}
var rc = [], jl = !1, rf, Sy = -1;
function rG() {
    !jl || !rf || (jl = !1, rf.length ? rc = rf.concat(rc) : Sy = -1, rc.length && Y7());
}
function Y7() {
    if (!jl) {
        var e = Z7(rG);
        jl = !0;
        for(var t = rc.length; t;){
            for(rf = rc, rc = []; ++Sy < t;)rf && rf[Sy].run();
            Sy = -1, t = rc.length;
        }
        rf = null, jl = !1, tG(e);
    }
}
Dn.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)t[r - 1] = arguments[r];
    rc.push(new X7(e, t)), rc.length === 1 && !jl && Z7(Y7);
};
function X7(e, t) {
    this.fun = e, this.array = t;
}
X7.prototype.run = function() {
    this.fun.apply(null, this.array);
};
Dn.title = "browser";
Dn.browser = !0;
Dn.env = {};
Dn.argv = [];
Dn.version = "";
Dn.versions = {};
function pc() {}
Dn.on = pc;
Dn.addListener = pc;
Dn.once = pc;
Dn.off = pc;
Dn.removeListener = pc;
Dn.removeAllListeners = pc;
Dn.emit = pc;
Dn.prependListener = pc;
Dn.prependOnceListener = pc;
Dn.listeners = function(e) {
    return [];
};
Dn.binding = function(e) {
    throw new Error("process.binding is not supported");
};
Dn.cwd = function() {
    return "/";
};
Dn.chdir = function(e) {
    throw new Error("process.chdir is not supported");
};
Dn.umask = function() {
    return 0;
};
var nG = G7.exports;
const bn = /* @__PURE__ */ eG(nG);
let PE = Symbol("clean"), xs = [], Mc = 0;
const Og = 4;
let NE = (e)=>{
    let t = [], r = {
        get () {
            return r.lc || r.listen(()=>{})(), r.value;
        },
        lc: 0,
        listen (n) {
            return r.lc = t.push(n), ()=>{
                for(let o = Mc + Og; o < xs.length;)xs[o] === n ? xs.splice(o, Og) : o += Og;
                let i = t.indexOf(n);
                ~i && (t.splice(i, 1), --r.lc || r.off());
            };
        },
        notify (n, i) {
            let o = !xs.length;
            for (let s of t)xs.push(s, r.value, n, i);
            if (o) {
                for(Mc = 0; Mc < xs.length; Mc += Og)xs[Mc](xs[Mc + 1], xs[Mc + 2], xs[Mc + 3]);
                xs.length = 0;
            }
        },
        /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */ off () {},
        set (n) {
            let i = r.value;
            i !== n && (r.value = n, r.notify(i));
        },
        subscribe (n) {
            let i = r.listen(n);
            return n(r.value), i;
        },
        value: e
    };
    return bn.env.NODE_ENV !== "production" && (r[PE] = ()=>{
        t = [], r.lc = 0, r.off();
    }), r;
};
const iG = 5, fl = 6, Pg = 10;
let oG = (e, t, r, n)=>(e.events = e.events || {}, e.events[r + Pg] || (e.events[r + Pg] = n((i)=>{
        e.events[r].reduceRight((o, s)=>(s(o), o), {
            shared: {},
            ...i
        });
    })), e.events[r] = e.events[r] || [], e.events[r].push(t), ()=>{
        let i = e.events[r], o = i.indexOf(t);
        i.splice(o, 1), i.length || (delete e.events[r], e.events[r + Pg](), delete e.events[r + Pg]);
    }), sG = 1e3, aG = (e, t)=>oG(e, (n)=>{
        let i = t(n);
        i && e.events[fl].push(i);
    }, iG, (n)=>{
        let i = e.listen;
        e.listen = (...s)=>(!e.lc && !e.active && (e.active = !0, n()), i(...s));
        let o = e.off;
        if (e.events[fl] = [], e.off = ()=>{
            o(), setTimeout(()=>{
                if (e.active && !e.lc) {
                    e.active = !1;
                    for (let s of e.events[fl])s();
                    e.events[fl] = [];
                }
            }, sG);
        }, bn.env.NODE_ENV !== "production") {
            let s = e[PE];
            e[PE] = ()=>{
                for (let a of e.events[fl])a();
                e.events[fl] = [], e.active = !1, s();
            };
        }
        return ()=>{
            e.listen = i, e.off = o;
        };
    }), cG = (e)=>{
    e.listen(()=>{});
};
function $o(e, t, r) {
    let n = new Set(t).add(void 0);
    return e.listen((i, o, s)=>{
        n.has(s) && r(i, o, s);
    });
}
let J7 = (e = {})=>{
    let t = NE(e);
    return t.setKey = function(r, n) {
        let i = t.value;
        typeof n > "u" && r in t.value ? (t.value = {
            ...t.value
        }, delete t.value[r], t.notify(i, r)) : t.value[r] !== n && (t.value = {
            ...t.value,
            [r]: n
        }, t.notify(i, r));
    }, t;
};
const ev = "defaultWallet", Il = "oyl", Bl = "unisat", Ol = "xverse", Pl = "phantom", Rh = "leather", ru = "magic-eden", Ch = "okx", Uh = "wizz", Qu = "orange", Nl = "op_net", Ml = "sparrow", $h = "tokeo", Rl = "keplr", df = "p2tr", uG = "p2pkh", fG = "p2sh-p2wpkh", Ay = "p2wpkh", tve = "p2psh", lG = "p2wsh", Xp = "p2sh", rve = {
    leather: {
        name: "leather",
        url: "https://leather.io/wallet"
    },
    "magic-eden": {
        name: "magic-eden",
        url: "https://wallet.magiceden.io/"
    },
    okx: {
        name: "okx",
        url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    op_net: {
        name: "op_net",
        url: "https://opnet.org/"
    },
    orange: {
        name: "orange",
        url: "https://www.orangewallet.com/"
    },
    oyl: {
        name: "oyl",
        url: "https://www.oyl.io/#get-wallet"
    },
    phantom: {
        name: "phantom",
        url: "https://phantom.app/download"
    },
    sparrow: {
        name: "sparrow",
        url: "https://sparrowwallet.com/"
    },
    tokeo: {
        name: "tokeo",
        url: "https://tokeo.io/"
    },
    unisat: {
        name: "unisat",
        url: "https://unisat.io/download"
    },
    wizz: {
        name: "wizz",
        url: "https://wizzwallet.io/#extension"
    },
    xverse: {
        name: "xverse",
        url: "https://www.xverse.app/download"
    },
    keplr: {
        name: "keplr",
        url: "https://keplr.app/download"
    }
};
var Q7 = {}, pb = {};
pb.byteLength = pG;
pb.toByteArray = yG;
pb.fromByteArray = wG;
var ha = [], is = [], dG = typeof Uint8Array < "u" ? Uint8Array : Array, tv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var ll = 0, hG = tv.length; ll < hG; ++ll)ha[ll] = tv[ll], is[tv.charCodeAt(ll)] = ll;
is[45] = 62;
is[95] = 63;
function e9(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [
        r,
        n
    ];
}
function pG(e) {
    var t = e9(e), r = t[0], n = t[1];
    return (r + n) * 3 / 4 - n;
}
function gG(e, t, r) {
    return (t + r) * 3 / 4 - r;
}
function yG(e) {
    var t, r = e9(e), n = r[0], i = r[1], o = new dG(gG(e, n, i)), s = 0, a = i > 0 ? n - 4 : n, u;
    for(u = 0; u < a; u += 4)t = is[e.charCodeAt(u)] << 18 | is[e.charCodeAt(u + 1)] << 12 | is[e.charCodeAt(u + 2)] << 6 | is[e.charCodeAt(u + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
    return i === 2 && (t = is[e.charCodeAt(u)] << 2 | is[e.charCodeAt(u + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = is[e.charCodeAt(u)] << 10 | is[e.charCodeAt(u + 1)] << 4 | is[e.charCodeAt(u + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function mG(e) {
    return ha[e >> 18 & 63] + ha[e >> 12 & 63] + ha[e >> 6 & 63] + ha[e & 63];
}
function bG(e, t, r) {
    for(var n, i = [], o = t; o < r; o += 3)n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(mG(n));
    return i.join("");
}
function wG(e) {
    for(var t, r = e.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)i.push(bG(e, s, s + o > a ? a : s + o));
    return n === 1 ? (t = e[r - 1], i.push(ha[t >> 2] + ha[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(ha[t >> 10] + ha[t >> 4 & 63] + ha[t << 2 & 63] + "=")), i.join("");
}
var h3 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ h3.read = function(e, t, r, n, i) {
    var o, s, a = i * 8 - n - 1, u = (1 << a) - 1, f = u >> 1, c = -7, l = r ? i - 1 : 0, p = r ? -1 : 1, y = e[t + l];
    for(l += p, o = y & (1 << -c) - 1, y >>= -c, c += a; c > 0; o = o * 256 + e[t + l], l += p, c -= 8);
    for(s = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; s = s * 256 + e[t + l], l += p, c -= 8);
    if (o === 0) o = 1 - f;
    else {
        if (o === u) return s ? NaN : (y ? -1 : 1) * (1 / 0);
        s = s + Math.pow(2, n), o = o - f;
    }
    return (y ? -1 : 1) * s * Math.pow(2, o - n);
};
h3.write = function(e, t, r, n, i, o) {
    var s, a, u, f = o * 8 - i - 1, c = (1 << f) - 1, l = c >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, _ = n ? 1 : -1, A = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + l >= 1 ? t += p / u : t += p * Math.pow(2, 1 - l), t * u >= 2 && (s++, u /= 2), s + l >= c ? (a = 0, s = c) : s + l >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s = s + l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + y] = a & 255, y += _, a /= 256, i -= 8);
    for(s = s << i | a, f += i; f > 0; e[r + y] = s & 255, y += _, s /= 256, f -= 8);
    e[r + y - _] |= A * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(e) {
    const t = pb, r = h3, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = c, e.SlowBuffer = K, e.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    e.kMaxLength = i;
    const { Uint8Array: o, ArrayBuffer: s, SharedArrayBuffer: a } = globalThis;
    c.TYPED_ARRAY_SUPPORT = u(), !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function u() {
        try {
            const V = new o(1), C = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(C, o.prototype), Object.setPrototypeOf(V, C), V.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(c.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (c.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(c.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (c.isBuffer(this)) return this.byteOffset;
        }
    });
    function f(V) {
        if (V > i) throw new RangeError('The value "' + V + '" is invalid for option "size"');
        const C = new o(V);
        return Object.setPrototypeOf(C, c.prototype), C;
    }
    function c(V, C, Z) {
        if (typeof V == "number") {
            if (typeof C == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return _(V);
        }
        return l(V, C, Z);
    }
    c.poolSize = 8192;
    function l(V, C, Z) {
        if (typeof V == "string") return A(V, C);
        if (s.isView(V)) return N(V);
        if (V == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof V);
        if (te(V, s) || V && te(V.buffer, s) || typeof a < "u" && (te(V, a) || V && te(V.buffer, a))) return U(V, C, Z);
        if (typeof V == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const le = V.valueOf && V.valueOf();
        if (le != null && le !== V) return c.from(le, C, Z);
        const se = D(V);
        if (se) return se;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof V[Symbol.toPrimitive] == "function") return c.from(V[Symbol.toPrimitive]("string"), C, Z);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof V);
    }
    c.from = function(V, C, Z) {
        return l(V, C, Z);
    }, Object.setPrototypeOf(c.prototype, o.prototype), Object.setPrototypeOf(c, o);
    function p(V) {
        if (typeof V != "number") throw new TypeError('"size" argument must be of type number');
        if (V < 0) throw new RangeError('The value "' + V + '" is invalid for option "size"');
    }
    function y(V, C, Z) {
        return p(V), V <= 0 ? f(V) : C !== void 0 ? typeof Z == "string" ? f(V).fill(C, Z) : f(V).fill(C) : f(V);
    }
    c.alloc = function(V, C, Z) {
        return y(V, C, Z);
    };
    function _(V) {
        return p(V), f(V < 0 ? 0 : H(V) | 0);
    }
    c.allocUnsafe = function(V) {
        return _(V);
    }, c.allocUnsafeSlow = function(V) {
        return _(V);
    };
    function A(V, C) {
        if ((typeof C != "string" || C === "") && (C = "utf8"), !c.isEncoding(C)) throw new TypeError("Unknown encoding: " + C);
        const Z = re(V, C) | 0;
        let le = f(Z);
        const se = le.write(V, C);
        return se !== Z && (le = le.slice(0, se)), le;
    }
    function O(V) {
        const C = V.length < 0 ? 0 : H(V.length) | 0, Z = f(C);
        for(let le = 0; le < C; le += 1)Z[le] = V[le] & 255;
        return Z;
    }
    function N(V) {
        if (te(V, o)) {
            const C = new o(V);
            return U(C.buffer, C.byteOffset, C.byteLength);
        }
        return O(V);
    }
    function U(V, C, Z) {
        if (C < 0 || V.byteLength < C) throw new RangeError('"offset" is outside of buffer bounds');
        if (V.byteLength < C + (Z || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let le;
        return C === void 0 && Z === void 0 ? le = new o(V) : Z === void 0 ? le = new o(V, C) : le = new o(V, C, Z), Object.setPrototypeOf(le, c.prototype), le;
    }
    function D(V) {
        if (c.isBuffer(V)) {
            const C = H(V.length) | 0, Z = f(C);
            return Z.length === 0 || V.copy(Z, 0, 0, C), Z;
        }
        if (V.length !== void 0) return typeof V.length != "number" || fe(V.length) ? f(0) : O(V);
        if (V.type === "Buffer" && Array.isArray(V.data)) return O(V.data);
    }
    function H(V) {
        if (V >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return V | 0;
    }
    function K(V) {
        return +V != V && (V = 0), c.alloc(+V);
    }
    c.isBuffer = function(C) {
        return C != null && C._isBuffer === !0 && C !== c.prototype;
    }, c.compare = function(C, Z) {
        if (te(C, o) && (C = c.from(C, C.offset, C.byteLength)), te(Z, o) && (Z = c.from(Z, Z.offset, Z.byteLength)), !c.isBuffer(C) || !c.isBuffer(Z)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (C === Z) return 0;
        let le = C.length, se = Z.length;
        for(let Ne = 0, Le = Math.min(le, se); Ne < Le; ++Ne)if (C[Ne] !== Z[Ne]) {
            le = C[Ne], se = Z[Ne];
            break;
        }
        return le < se ? -1 : se < le ? 1 : 0;
    }, c.isEncoding = function(C) {
        switch(String(C).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, c.concat = function(C, Z) {
        if (!Array.isArray(C)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (C.length === 0) return c.alloc(0);
        let le;
        if (Z === void 0) for(Z = 0, le = 0; le < C.length; ++le)Z += C[le].length;
        const se = c.allocUnsafe(Z);
        let Ne = 0;
        for(le = 0; le < C.length; ++le){
            let Le = C[le];
            if (te(Le, o)) Ne + Le.length > se.length ? (c.isBuffer(Le) || (Le = c.from(Le)), Le.copy(se, Ne)) : o.prototype.set.call(se, Le, Ne);
            else if (c.isBuffer(Le)) Le.copy(se, Ne);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            Ne += Le.length;
        }
        return se;
    };
    function re(V, C) {
        if (c.isBuffer(V)) return V.length;
        if (s.isView(V) || te(V, s)) return V.byteLength;
        if (typeof V != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof V);
        const Z = V.length, le = arguments.length > 2 && arguments[2] === !0;
        if (!le && Z === 0) return 0;
        let se = !1;
        for(;;)switch(C){
            case "ascii":
            case "latin1":
            case "binary":
                return Z;
            case "utf8":
            case "utf-8":
                return Ke(V).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Z * 2;
            case "hex":
                return Z >>> 1;
            case "base64":
                return x(V).length;
            default:
                if (se) return le ? -1 : Ke(V).length;
                C = ("" + C).toLowerCase(), se = !0;
        }
    }
    c.byteLength = re;
    function Q(V, C, Z) {
        let le = !1;
        if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((Z === void 0 || Z > this.length) && (Z = this.length), Z <= 0) || (Z >>>= 0, C >>>= 0, Z <= C)) return "";
        for(V || (V = "utf8");;)switch(V){
            case "hex":
                return j(this, C, Z);
            case "utf8":
            case "utf-8":
                return T(this, C, Z);
            case "ascii":
                return k(this, C, Z);
            case "latin1":
            case "binary":
                return L(this, C, Z);
            case "base64":
                return E(this, C, Z);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ie(this, C, Z);
            default:
                if (le) throw new TypeError("Unknown encoding: " + V);
                V = (V + "").toLowerCase(), le = !0;
        }
    }
    c.prototype._isBuffer = !0;
    function G(V, C, Z) {
        const le = V[C];
        V[C] = V[Z], V[Z] = le;
    }
    c.prototype.swap16 = function() {
        const C = this.length;
        if (C % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let Z = 0; Z < C; Z += 2)G(this, Z, Z + 1);
        return this;
    }, c.prototype.swap32 = function() {
        const C = this.length;
        if (C % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let Z = 0; Z < C; Z += 4)G(this, Z, Z + 3), G(this, Z + 1, Z + 2);
        return this;
    }, c.prototype.swap64 = function() {
        const C = this.length;
        if (C % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let Z = 0; Z < C; Z += 8)G(this, Z, Z + 7), G(this, Z + 1, Z + 6), G(this, Z + 2, Z + 5), G(this, Z + 3, Z + 4);
        return this;
    }, c.prototype.toString = function() {
        const C = this.length;
        return C === 0 ? "" : arguments.length === 0 ? T(this, 0, C) : Q.apply(this, arguments);
    }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(C) {
        if (!c.isBuffer(C)) throw new TypeError("Argument must be a Buffer");
        return this === C ? !0 : c.compare(this, C) === 0;
    }, c.prototype.inspect = function() {
        let C = "";
        const Z = e.INSPECT_MAX_BYTES;
        return C = this.toString("hex", 0, Z).replace(/(.{2})/g, "$1 ").trim(), this.length > Z && (C += " ... "), "<Buffer " + C + ">";
    }, n && (c.prototype[n] = c.prototype.inspect), c.prototype.compare = function(C, Z, le, se, Ne) {
        if (te(C, o) && (C = c.from(C, C.offset, C.byteLength)), !c.isBuffer(C)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C);
        if (Z === void 0 && (Z = 0), le === void 0 && (le = C ? C.length : 0), se === void 0 && (se = 0), Ne === void 0 && (Ne = this.length), Z < 0 || le > C.length || se < 0 || Ne > this.length) throw new RangeError("out of range index");
        if (se >= Ne && Z >= le) return 0;
        if (se >= Ne) return -1;
        if (Z >= le) return 1;
        if (Z >>>= 0, le >>>= 0, se >>>= 0, Ne >>>= 0, this === C) return 0;
        let Le = Ne - se, rt = le - Z;
        const yt = Math.min(Le, rt), _t = this.slice(se, Ne), Qe = C.slice(Z, le);
        for(let Rt = 0; Rt < yt; ++Rt)if (_t[Rt] !== Qe[Rt]) {
            Le = _t[Rt], rt = Qe[Rt];
            break;
        }
        return Le < rt ? -1 : rt < Le ? 1 : 0;
    };
    function R(V, C, Z, le, se) {
        if (V.length === 0) return -1;
        if (typeof Z == "string" ? (le = Z, Z = 0) : Z > 2147483647 ? Z = 2147483647 : Z < -2147483648 && (Z = -2147483648), Z = +Z, fe(Z) && (Z = se ? 0 : V.length - 1), Z < 0 && (Z = V.length + Z), Z >= V.length) {
            if (se) return -1;
            Z = V.length - 1;
        } else if (Z < 0) if (se) Z = 0;
        else return -1;
        if (typeof C == "string" && (C = c.from(C, le)), c.isBuffer(C)) return C.length === 0 ? -1 : X(V, C, Z, le, se);
        if (typeof C == "number") return C = C & 255, typeof o.prototype.indexOf == "function" ? se ? o.prototype.indexOf.call(V, C, Z) : o.prototype.lastIndexOf.call(V, C, Z) : X(V, [
            C
        ], Z, le, se);
        throw new TypeError("val must be string, number or Buffer");
    }
    function X(V, C, Z, le, se) {
        let Ne = 1, Le = V.length, rt = C.length;
        if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
            if (V.length < 2 || C.length < 2) return -1;
            Ne = 2, Le /= 2, rt /= 2, Z /= 2;
        }
        function yt(Qe, Rt) {
            return Ne === 1 ? Qe[Rt] : Qe.readUInt16BE(Rt * Ne);
        }
        let _t;
        if (se) {
            let Qe = -1;
            for(_t = Z; _t < Le; _t++)if (yt(V, _t) === yt(C, Qe === -1 ? 0 : _t - Qe)) {
                if (Qe === -1 && (Qe = _t), _t - Qe + 1 === rt) return Qe * Ne;
            } else Qe !== -1 && (_t -= _t - Qe), Qe = -1;
        } else for(Z + rt > Le && (Z = Le - rt), _t = Z; _t >= 0; _t--){
            let Qe = !0;
            for(let Rt = 0; Rt < rt; Rt++)if (yt(V, _t + Rt) !== yt(C, Rt)) {
                Qe = !1;
                break;
            }
            if (Qe) return _t;
        }
        return -1;
    }
    c.prototype.includes = function(C, Z, le) {
        return this.indexOf(C, Z, le) !== -1;
    }, c.prototype.indexOf = function(C, Z, le) {
        return R(this, C, Z, le, !0);
    }, c.prototype.lastIndexOf = function(C, Z, le) {
        return R(this, C, Z, le, !1);
    };
    function $(V, C, Z, le) {
        Z = Number(Z) || 0;
        const se = V.length - Z;
        le ? (le = Number(le), le > se && (le = se)) : le = se;
        const Ne = C.length;
        le > Ne / 2 && (le = Ne / 2);
        let Le;
        for(Le = 0; Le < le; ++Le){
            const rt = parseInt(C.substr(Le * 2, 2), 16);
            if (fe(rt)) return Le;
            V[Z + Le] = rt;
        }
        return Le;
    }
    function S(V, C, Z, le) {
        return q(Ke(C, V.length - Z), V, Z, le);
    }
    function w(V, C, Z, le) {
        return q(Ue(C), V, Z, le);
    }
    function g(V, C, Z, le) {
        return q(x(C), V, Z, le);
    }
    function m(V, C, Z, le) {
        return q(h(C, V.length - Z), V, Z, le);
    }
    c.prototype.write = function(C, Z, le, se) {
        if (Z === void 0) se = "utf8", le = this.length, Z = 0;
        else if (le === void 0 && typeof Z == "string") se = Z, le = this.length, Z = 0;
        else if (isFinite(Z)) Z = Z >>> 0, isFinite(le) ? (le = le >>> 0, se === void 0 && (se = "utf8")) : (se = le, le = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Ne = this.length - Z;
        if ((le === void 0 || le > Ne) && (le = Ne), C.length > 0 && (le < 0 || Z < 0) || Z > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        se || (se = "utf8");
        let Le = !1;
        for(;;)switch(se){
            case "hex":
                return $(this, C, Z, le);
            case "utf8":
            case "utf-8":
                return S(this, C, Z, le);
            case "ascii":
            case "latin1":
            case "binary":
                return w(this, C, Z, le);
            case "base64":
                return g(this, C, Z, le);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return m(this, C, Z, le);
            default:
                if (Le) throw new TypeError("Unknown encoding: " + se);
                se = ("" + se).toLowerCase(), Le = !0;
        }
    }, c.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function E(V, C, Z) {
        return C === 0 && Z === V.length ? t.fromByteArray(V) : t.fromByteArray(V.slice(C, Z));
    }
    function T(V, C, Z) {
        Z = Math.min(V.length, Z);
        const le = [];
        let se = C;
        for(; se < Z;){
            const Ne = V[se];
            let Le = null, rt = Ne > 239 ? 4 : Ne > 223 ? 3 : Ne > 191 ? 2 : 1;
            if (se + rt <= Z) {
                let yt, _t, Qe, Rt;
                switch(rt){
                    case 1:
                        Ne < 128 && (Le = Ne);
                        break;
                    case 2:
                        yt = V[se + 1], (yt & 192) === 128 && (Rt = (Ne & 31) << 6 | yt & 63, Rt > 127 && (Le = Rt));
                        break;
                    case 3:
                        yt = V[se + 1], _t = V[se + 2], (yt & 192) === 128 && (_t & 192) === 128 && (Rt = (Ne & 15) << 12 | (yt & 63) << 6 | _t & 63, Rt > 2047 && (Rt < 55296 || Rt > 57343) && (Le = Rt));
                        break;
                    case 4:
                        yt = V[se + 1], _t = V[se + 2], Qe = V[se + 3], (yt & 192) === 128 && (_t & 192) === 128 && (Qe & 192) === 128 && (Rt = (Ne & 15) << 18 | (yt & 63) << 12 | (_t & 63) << 6 | Qe & 63, Rt > 65535 && Rt < 1114112 && (Le = Rt));
                }
            }
            Le === null ? (Le = 65533, rt = 1) : Le > 65535 && (Le -= 65536, le.push(Le >>> 10 & 1023 | 55296), Le = 56320 | Le & 1023), le.push(Le), se += rt;
        }
        return P(le);
    }
    const I = 4096;
    function P(V) {
        const C = V.length;
        if (C <= I) return String.fromCharCode.apply(String, V);
        let Z = "", le = 0;
        for(; le < C;)Z += String.fromCharCode.apply(String, V.slice(le, le += I));
        return Z;
    }
    function k(V, C, Z) {
        let le = "";
        Z = Math.min(V.length, Z);
        for(let se = C; se < Z; ++se)le += String.fromCharCode(V[se] & 127);
        return le;
    }
    function L(V, C, Z) {
        let le = "";
        Z = Math.min(V.length, Z);
        for(let se = C; se < Z; ++se)le += String.fromCharCode(V[se]);
        return le;
    }
    function j(V, C, Z) {
        const le = V.length;
        (!C || C < 0) && (C = 0), (!Z || Z < 0 || Z > le) && (Z = le);
        let se = "";
        for(let Ne = C; Ne < Z; ++Ne)se += ne[V[Ne]];
        return se;
    }
    function ie(V, C, Z) {
        const le = V.slice(C, Z);
        let se = "";
        for(let Ne = 0; Ne < le.length - 1; Ne += 2)se += String.fromCharCode(le[Ne] + le[Ne + 1] * 256);
        return se;
    }
    c.prototype.slice = function(C, Z) {
        const le = this.length;
        C = ~~C, Z = Z === void 0 ? le : ~~Z, C < 0 ? (C += le, C < 0 && (C = 0)) : C > le && (C = le), Z < 0 ? (Z += le, Z < 0 && (Z = 0)) : Z > le && (Z = le), Z < C && (Z = C);
        const se = this.subarray(C, Z);
        return Object.setPrototypeOf(se, c.prototype), se;
    };
    function ue(V, C, Z) {
        if (V % 1 !== 0 || V < 0) throw new RangeError("offset is not uint");
        if (V + C > Z) throw new RangeError("Trying to access beyond buffer length");
    }
    c.prototype.readUintLE = c.prototype.readUIntLE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = this[C], Ne = 1, Le = 0;
        for(; ++Le < Z && (Ne *= 256);)se += this[C + Le] * Ne;
        return se;
    }, c.prototype.readUintBE = c.prototype.readUIntBE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = this[C + --Z], Ne = 1;
        for(; Z > 0 && (Ne *= 256);)se += this[C + --Z] * Ne;
        return se;
    }, c.prototype.readUint8 = c.prototype.readUInt8 = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 1, this.length), this[C];
    }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 2, this.length), this[C] | this[C + 1] << 8;
    }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 2, this.length), this[C] << 8 | this[C + 1];
    }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
    }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
    }, c.prototype.readBigUInt64LE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = Z + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24, Ne = this[++C] + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + le * 2 ** 24;
        return BigInt(se) + (BigInt(Ne) << BigInt(32));
    }), c.prototype.readBigUInt64BE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = Z * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C], Ne = this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + le;
        return (BigInt(se) << BigInt(32)) + BigInt(Ne);
    }), c.prototype.readIntLE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = this[C], Ne = 1, Le = 0;
        for(; ++Le < Z && (Ne *= 256);)se += this[C + Le] * Ne;
        return Ne *= 128, se >= Ne && (se -= Math.pow(2, 8 * Z)), se;
    }, c.prototype.readIntBE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = Z, Ne = 1, Le = this[C + --se];
        for(; se > 0 && (Ne *= 256);)Le += this[C + --se] * Ne;
        return Ne *= 128, Le >= Ne && (Le -= Math.pow(2, 8 * Z)), Le;
    }, c.prototype.readInt8 = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
    }, c.prototype.readInt16LE = function(C, Z) {
        C = C >>> 0, Z || ue(C, 2, this.length);
        const le = this[C] | this[C + 1] << 8;
        return le & 32768 ? le | 4294901760 : le;
    }, c.prototype.readInt16BE = function(C, Z) {
        C = C >>> 0, Z || ue(C, 2, this.length);
        const le = this[C + 1] | this[C] << 8;
        return le & 32768 ? le | 4294901760 : le;
    }, c.prototype.readInt32LE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
    }, c.prototype.readInt32BE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
    }, c.prototype.readBigInt64LE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = this[C + 4] + this[C + 5] * 2 ** 8 + this[C + 6] * 2 ** 16 + (le << 24);
        return (BigInt(se) << BigInt(32)) + BigInt(Z + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24);
    }), c.prototype.readBigInt64BE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = (Z << 24) + // Overflow
        this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C];
        return (BigInt(se) << BigInt(32)) + BigInt(this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + le);
    }), c.prototype.readFloatLE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), r.read(this, C, !0, 23, 4);
    }, c.prototype.readFloatBE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), r.read(this, C, !1, 23, 4);
    }, c.prototype.readDoubleLE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 8, this.length), r.read(this, C, !0, 52, 8);
    }, c.prototype.readDoubleBE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 8, this.length), r.read(this, C, !1, 52, 8);
    };
    function ce(V, C, Z, le, se, Ne) {
        if (!c.isBuffer(V)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (C > se || C < Ne) throw new RangeError('"value" argument is out of bounds');
        if (Z + le > V.length) throw new RangeError("Index out of range");
    }
    c.prototype.writeUintLE = c.prototype.writeUIntLE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, le = le >>> 0, !se) {
            const rt = Math.pow(2, 8 * le) - 1;
            ce(this, C, Z, le, rt, 0);
        }
        let Ne = 1, Le = 0;
        for(this[Z] = C & 255; ++Le < le && (Ne *= 256);)this[Z + Le] = C / Ne & 255;
        return Z + le;
    }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, le = le >>> 0, !se) {
            const rt = Math.pow(2, 8 * le) - 1;
            ce(this, C, Z, le, rt, 0);
        }
        let Ne = le - 1, Le = 1;
        for(this[Z + Ne] = C & 255; --Ne >= 0 && (Le *= 256);)this[Z + Ne] = C / Le & 255;
        return Z + le;
    }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 1, 255, 0), this[Z] = C & 255, Z + 1;
    }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 65535, 0), this[Z] = C & 255, this[Z + 1] = C >>> 8, Z + 2;
    }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 65535, 0), this[Z] = C >>> 8, this[Z + 1] = C & 255, Z + 2;
    }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 4294967295, 0), this[Z + 3] = C >>> 24, this[Z + 2] = C >>> 16, this[Z + 1] = C >>> 8, this[Z] = C & 255, Z + 4;
    }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 4294967295, 0), this[Z] = C >>> 24, this[Z + 1] = C >>> 16, this[Z + 2] = C >>> 8, this[Z + 3] = C & 255, Z + 4;
    };
    function he(V, C, Z, le, se) {
        z(C, le, se, V, Z, 7);
        let Ne = Number(C & BigInt(4294967295));
        V[Z++] = Ne, Ne = Ne >> 8, V[Z++] = Ne, Ne = Ne >> 8, V[Z++] = Ne, Ne = Ne >> 8, V[Z++] = Ne;
        let Le = Number(C >> BigInt(32) & BigInt(4294967295));
        return V[Z++] = Le, Le = Le >> 8, V[Z++] = Le, Le = Le >> 8, V[Z++] = Le, Le = Le >> 8, V[Z++] = Le, Z;
    }
    function ee(V, C, Z, le, se) {
        z(C, le, se, V, Z, 7);
        let Ne = Number(C & BigInt(4294967295));
        V[Z + 7] = Ne, Ne = Ne >> 8, V[Z + 6] = Ne, Ne = Ne >> 8, V[Z + 5] = Ne, Ne = Ne >> 8, V[Z + 4] = Ne;
        let Le = Number(C >> BigInt(32) & BigInt(4294967295));
        return V[Z + 3] = Le, Le = Le >> 8, V[Z + 2] = Le, Le = Le >> 8, V[Z + 1] = Le, Le = Le >> 8, V[Z] = Le, Z + 8;
    }
    c.prototype.writeBigUInt64LE = W(function(C, Z = 0) {
        return he(this, C, Z, BigInt(0), BigInt("0xffffffffffffffff"));
    }), c.prototype.writeBigUInt64BE = W(function(C, Z = 0) {
        return ee(this, C, Z, BigInt(0), BigInt("0xffffffffffffffff"));
    }), c.prototype.writeIntLE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, !se) {
            const yt = Math.pow(2, 8 * le - 1);
            ce(this, C, Z, le, yt - 1, -yt);
        }
        let Ne = 0, Le = 1, rt = 0;
        for(this[Z] = C & 255; ++Ne < le && (Le *= 256);)C < 0 && rt === 0 && this[Z + Ne - 1] !== 0 && (rt = 1), this[Z + Ne] = (C / Le >> 0) - rt & 255;
        return Z + le;
    }, c.prototype.writeIntBE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, !se) {
            const yt = Math.pow(2, 8 * le - 1);
            ce(this, C, Z, le, yt - 1, -yt);
        }
        let Ne = le - 1, Le = 1, rt = 0;
        for(this[Z + Ne] = C & 255; --Ne >= 0 && (Le *= 256);)C < 0 && rt === 0 && this[Z + Ne + 1] !== 0 && (rt = 1), this[Z + Ne] = (C / Le >> 0) - rt & 255;
        return Z + le;
    }, c.prototype.writeInt8 = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[Z] = C & 255, Z + 1;
    }, c.prototype.writeInt16LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 32767, -32768), this[Z] = C & 255, this[Z + 1] = C >>> 8, Z + 2;
    }, c.prototype.writeInt16BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 32767, -32768), this[Z] = C >>> 8, this[Z + 1] = C & 255, Z + 2;
    }, c.prototype.writeInt32LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 2147483647, -2147483648), this[Z] = C & 255, this[Z + 1] = C >>> 8, this[Z + 2] = C >>> 16, this[Z + 3] = C >>> 24, Z + 4;
    }, c.prototype.writeInt32BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[Z] = C >>> 24, this[Z + 1] = C >>> 16, this[Z + 2] = C >>> 8, this[Z + 3] = C & 255, Z + 4;
    }, c.prototype.writeBigInt64LE = W(function(C, Z = 0) {
        return he(this, C, Z, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), c.prototype.writeBigInt64BE = W(function(C, Z = 0) {
        return ee(this, C, Z, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ae(V, C, Z, le, se, Ne) {
        if (Z + le > V.length) throw new RangeError("Index out of range");
        if (Z < 0) throw new RangeError("Index out of range");
    }
    function ye(V, C, Z, le, se) {
        return C = +C, Z = Z >>> 0, se || ae(V, C, Z, 4), r.write(V, C, Z, le, 23, 4), Z + 4;
    }
    c.prototype.writeFloatLE = function(C, Z, le) {
        return ye(this, C, Z, !0, le);
    }, c.prototype.writeFloatBE = function(C, Z, le) {
        return ye(this, C, Z, !1, le);
    };
    function Se(V, C, Z, le, se) {
        return C = +C, Z = Z >>> 0, se || ae(V, C, Z, 8), r.write(V, C, Z, le, 52, 8), Z + 8;
    }
    c.prototype.writeDoubleLE = function(C, Z, le) {
        return Se(this, C, Z, !0, le);
    }, c.prototype.writeDoubleBE = function(C, Z, le) {
        return Se(this, C, Z, !1, le);
    }, c.prototype.copy = function(C, Z, le, se) {
        if (!c.isBuffer(C)) throw new TypeError("argument should be a Buffer");
        if (le || (le = 0), !se && se !== 0 && (se = this.length), Z >= C.length && (Z = C.length), Z || (Z = 0), se > 0 && se < le && (se = le), se === le || C.length === 0 || this.length === 0) return 0;
        if (Z < 0) throw new RangeError("targetStart out of bounds");
        if (le < 0 || le >= this.length) throw new RangeError("Index out of range");
        if (se < 0) throw new RangeError("sourceEnd out of bounds");
        se > this.length && (se = this.length), C.length - Z < se - le && (se = C.length - Z + le);
        const Ne = se - le;
        return this === C && typeof o.prototype.copyWithin == "function" ? this.copyWithin(Z, le, se) : o.prototype.set.call(C, this.subarray(le, se), Z), Ne;
    }, c.prototype.fill = function(C, Z, le, se) {
        if (typeof C == "string") {
            if (typeof Z == "string" ? (se = Z, Z = 0, le = this.length) : typeof le == "string" && (se = le, le = this.length), se !== void 0 && typeof se != "string") throw new TypeError("encoding must be a string");
            if (typeof se == "string" && !c.isEncoding(se)) throw new TypeError("Unknown encoding: " + se);
            if (C.length === 1) {
                const Le = C.charCodeAt(0);
                (se === "utf8" && Le < 128 || se === "latin1") && (C = Le);
            }
        } else typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
        if (Z < 0 || this.length < Z || this.length < le) throw new RangeError("Out of range index");
        if (le <= Z) return this;
        Z = Z >>> 0, le = le === void 0 ? this.length : le >>> 0, C || (C = 0);
        let Ne;
        if (typeof C == "number") for(Ne = Z; Ne < le; ++Ne)this[Ne] = C;
        else {
            const Le = c.isBuffer(C) ? C : c.from(C, se), rt = Le.length;
            if (rt === 0) throw new TypeError('The value "' + C + '" is invalid for argument "value"');
            for(Ne = 0; Ne < le - Z; ++Ne)this[Ne + Z] = Le[Ne % rt];
        }
        return this;
    };
    const De = {};
    function Re(V, C, Z) {
        De[V] = class extends Z {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: C.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${V}]`, this.stack, delete this.name;
            }
            get code() {
                return V;
            }
            set code(se) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: se,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${V}]: ${this.message}`;
            }
        };
    }
    Re("ERR_BUFFER_OUT_OF_BOUNDS", function(V) {
        return V ? `${V} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), Re("ERR_INVALID_ARG_TYPE", function(V, C) {
        return `The "${V}" argument must be of type number. Received type ${typeof C}`;
    }, TypeError), Re("ERR_OUT_OF_RANGE", function(V, C, Z) {
        let le = `The value of "${V}" is out of range.`, se = Z;
        return Number.isInteger(Z) && Math.abs(Z) > 2 ** 32 ? se = Ce(String(Z)) : typeof Z == "bigint" && (se = String(Z), (Z > BigInt(2) ** BigInt(32) || Z < -(BigInt(2) ** BigInt(32))) && (se = Ce(se)), se += "n"), le += ` It must be ${C}. Received ${se}`, le;
    }, RangeError);
    function Ce(V) {
        let C = "", Z = V.length;
        const le = V[0] === "-" ? 1 : 0;
        for(; Z >= le + 4; Z -= 3)C = `_${V.slice(Z - 3, Z)}${C}`;
        return `${V.slice(0, Z)}${C}`;
    }
    function M(V, C, Z) {
        de(C, "offset"), (V[C] === void 0 || V[C + Z] === void 0) && _e(C, V.length - (Z + 1));
    }
    function z(V, C, Z, le, se, Ne) {
        if (V > Z || V < C) {
            const Le = typeof C == "bigint" ? "n" : "";
            let rt;
            throw C === 0 || C === BigInt(0) ? rt = `>= 0${Le} and < 2${Le} ** ${(Ne + 1) * 8}${Le}` : rt = `>= -(2${Le} ** ${(Ne + 1) * 8 - 1}${Le}) and < 2 ** ${(Ne + 1) * 8 - 1}${Le}`, new De.ERR_OUT_OF_RANGE("value", rt, V);
        }
        M(le, se, Ne);
    }
    function de(V, C) {
        if (typeof V != "number") throw new De.ERR_INVALID_ARG_TYPE(C, "number", V);
    }
    function _e(V, C, Z) {
        throw Math.floor(V) !== V ? (de(V, Z), new De.ERR_OUT_OF_RANGE("offset", "an integer", V)) : C < 0 ? new De.ERR_BUFFER_OUT_OF_BOUNDS() : new De.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${C}`, V);
    }
    const Ie = /[^+/0-9A-Za-z-_]/g;
    function je(V) {
        if (V = V.split("=")[0], V = V.trim().replace(Ie, ""), V.length < 2) return "";
        for(; V.length % 4 !== 0;)V = V + "=";
        return V;
    }
    function Ke(V, C) {
        C = C || 1 / 0;
        let Z;
        const le = V.length;
        let se = null;
        const Ne = [];
        for(let Le = 0; Le < le; ++Le){
            if (Z = V.charCodeAt(Le), Z > 55295 && Z < 57344) {
                if (!se) {
                    if (Z > 56319) {
                        (C -= 3) > -1 && Ne.push(239, 191, 189);
                        continue;
                    } else if (Le + 1 === le) {
                        (C -= 3) > -1 && Ne.push(239, 191, 189);
                        continue;
                    }
                    se = Z;
                    continue;
                }
                if (Z < 56320) {
                    (C -= 3) > -1 && Ne.push(239, 191, 189), se = Z;
                    continue;
                }
                Z = (se - 55296 << 10 | Z - 56320) + 65536;
            } else se && (C -= 3) > -1 && Ne.push(239, 191, 189);
            if (se = null, Z < 128) {
                if ((C -= 1) < 0) break;
                Ne.push(Z);
            } else if (Z < 2048) {
                if ((C -= 2) < 0) break;
                Ne.push(Z >> 6 | 192, Z & 63 | 128);
            } else if (Z < 65536) {
                if ((C -= 3) < 0) break;
                Ne.push(Z >> 12 | 224, Z >> 6 & 63 | 128, Z & 63 | 128);
            } else if (Z < 1114112) {
                if ((C -= 4) < 0) break;
                Ne.push(Z >> 18 | 240, Z >> 12 & 63 | 128, Z >> 6 & 63 | 128, Z & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return Ne;
    }
    function Ue(V) {
        const C = [];
        for(let Z = 0; Z < V.length; ++Z)C.push(V.charCodeAt(Z) & 255);
        return C;
    }
    function h(V, C) {
        let Z, le, se;
        const Ne = [];
        for(let Le = 0; Le < V.length && !((C -= 2) < 0); ++Le)Z = V.charCodeAt(Le), le = Z >> 8, se = Z % 256, Ne.push(se), Ne.push(le);
        return Ne;
    }
    function x(V) {
        return t.toByteArray(je(V));
    }
    function q(V, C, Z, le) {
        let se;
        for(se = 0; se < le && !(se + Z >= C.length || se >= V.length); ++se)C[se + Z] = V[se];
        return se;
    }
    function te(V, C) {
        return V instanceof C || V != null && V.constructor != null && V.constructor.name != null && V.constructor.name === C.name;
    }
    function fe(V) {
        return V !== V;
    }
    const ne = function() {
        const V = "0123456789abcdef", C = new Array(256);
        for(let Z = 0; Z < 16; ++Z){
            const le = Z * 16;
            for(let se = 0; se < 16; ++se)C[le + se] = V[Z] + V[se];
        }
        return C;
    }();
    function W(V) {
        return typeof BigInt > "u" ? J : V;
    }
    function J() {
        throw new Error("BigInt not supported");
    }
})(Q7);
const We = Q7.Buffer, t9 = "maestro", vG = "mempool-space", _G = "sandshrew";
var ME = /* @__PURE__ */ ((e)=>(e.MAINNET = "fractal_mainnet", e.TESTNET = "fractal_testnet", e))(ME || {}), Qc = /* @__PURE__ */ ((e)=>(e.MAINNET = "main", e.TESTNET = "testnet", e.SIGNET = "signet", e))(Qc || {}), Hl = /* @__PURE__ */ ((e)=>(e.MAINNET = "mainnet", e.TESTNET = "testnet", e))(Hl || {}), ro = /* @__PURE__ */ ((e)=>(e.MAINNET = "BITCOIN_MAINNET", e.TESTNET = "BITCOIN_TESTNET", e.TESTNET4 = "BITCOIN_TESTNET4", e.SIGNET = "BITCOIN_SIGNET", e.FRACTAL_MAINNET = "FRACTAL_BITCOIN_MAINNET", e.FRACTAL_TESTNET = "FRACTAL_BITCOIN_TESTNET", e))(ro || {}), cu = /* @__PURE__ */ ((e)=>(e.BITCOIN_MAINNET = "BITCOIN_MAINNET", e.BITCOIN_TESTNET = "BITCOIN_TESTNET", e.BITCOIN_SIGNET = "BITCOIN_SIGNET", e))(cu || {}), EG = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e))(EG || {}), Yu = /* @__PURE__ */ ((e)=>(e.MAINNET = "Mainnet", e.TESTNET = "Testnet", e.SIGNET = "Signet", e.FRACTAL_MAINNET = "fractal mainnet", e.FRACTAL_TESTNET = "fractal testnet", e.TESTNET4 = "Testnet4", e))(Yu || {}), RE = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e))(RE || {}), ko = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e.TESTNET4 = "testnet4", e.SIGNET = "signet", e))(ko || {}), eu = /* @__PURE__ */ ((e)=>(e.MAINNET = "Mainnet", e.TESTNET = "Testnet", e))(eu || {}), dt = /* @__PURE__ */ ((e)=>(e.MAINNET = "mainnet", e.SIGNET = "signet", e.TESTNET = "testnet", e.TESTNET4 = "testnet4", e.REGTEST = "regtest", e.FRACTAL_MAINNET = "fractal_mainnet", e.FRACTAL_TESTNET = "fractal_testnet", e.OYLNET = "oylnet", e))(dt || {}), In = {}, p3 = {}, en = {}, Pi = {}, Hr = {}, gb = {};
Object.defineProperty(gb, "__esModule", {
    value: !0
});
gb.crypto = void 0;
gb.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.Hash = e.nextTick = e.swap32IfBE = e.byteSwapIfBE = e.swap8IfBE = e.isLE = void 0, e.isBytes = r, e.anumber = n, e.abytes = i, e.ahash = o, e.aexists = s, e.aoutput = a, e.u8 = u, e.u32 = f, e.clean = c, e.createView = l, e.rotr = p, e.rotl = y, e.byteSwap = _, e.byteSwap32 = A, e.bytesToHex = U, e.hexToBytes = K, e.asyncLoop = Q, e.utf8ToBytes = G, e.bytesToUtf8 = R, e.toBytes = X, e.kdfInputToBytes = $, e.concatBytes = S, e.checkOpts = w, e.createHasher = m, e.createOptHasher = E, e.createXOFer = T, e.randomBytes = I;
    const t = gb;
    function r(P) {
        return P instanceof Uint8Array || ArrayBuffer.isView(P) && P.constructor.name === "Uint8Array";
    }
    function n(P) {
        if (!Number.isSafeInteger(P) || P < 0) throw new Error("positive integer expected, got " + P);
    }
    function i(P, ...k) {
        if (!r(P)) throw new Error("Uint8Array expected");
        if (k.length > 0 && !k.includes(P.length)) throw new Error("Uint8Array expected of length " + k + ", got length=" + P.length);
    }
    function o(P) {
        if (typeof P != "function" || typeof P.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
        n(P.outputLen), n(P.blockLen);
    }
    function s(P, k = !0) {
        if (P.destroyed) throw new Error("Hash instance has been destroyed");
        if (k && P.finished) throw new Error("Hash#digest() has already been called");
    }
    function a(P, k) {
        i(P);
        const L = k.outputLen;
        if (P.length < L) throw new Error("digestInto() expects output buffer of length at least " + L);
    }
    function u(P) {
        return new Uint8Array(P.buffer, P.byteOffset, P.byteLength);
    }
    function f(P) {
        return new Uint32Array(P.buffer, P.byteOffset, Math.floor(P.byteLength / 4));
    }
    function c(...P) {
        for(let k = 0; k < P.length; k++)P[k].fill(0);
    }
    function l(P) {
        return new DataView(P.buffer, P.byteOffset, P.byteLength);
    }
    function p(P, k) {
        return P << 32 - k | P >>> k;
    }
    function y(P, k) {
        return P << k | P >>> 32 - k >>> 0;
    }
    e.isLE = new Uint8Array(new Uint32Array([
        287454020
    ]).buffer)[0] === 68;
    function _(P) {
        return P << 24 & 4278190080 | P << 8 & 16711680 | P >>> 8 & 65280 | P >>> 24 & 255;
    }
    e.swap8IfBE = e.isLE ? (P)=>P : (P)=>_(P), e.byteSwapIfBE = e.swap8IfBE;
    function A(P) {
        for(let k = 0; k < P.length; k++)P[k] = _(P[k]);
        return P;
    }
    e.swap32IfBE = e.isLE ? (P)=>P : A;
    const O = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", N = /* @__PURE__ */ Array.from({
        length: 256
    }, (P, k)=>k.toString(16).padStart(2, "0"));
    function U(P) {
        if (i(P), O) return P.toHex();
        let k = "";
        for(let L = 0; L < P.length; L++)k += N[P[L]];
        return k;
    }
    const D = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function H(P) {
        if (P >= D._0 && P <= D._9) return P - D._0;
        if (P >= D.A && P <= D.F) return P - (D.A - 10);
        if (P >= D.a && P <= D.f) return P - (D.a - 10);
    }
    function K(P) {
        if (typeof P != "string") throw new Error("hex string expected, got " + typeof P);
        if (O) return Uint8Array.fromHex(P);
        const k = P.length, L = k / 2;
        if (k % 2) throw new Error("hex string expected, got unpadded hex of length " + k);
        const j = new Uint8Array(L);
        for(let ie = 0, ue = 0; ie < L; ie++, ue += 2){
            const ce = H(P.charCodeAt(ue)), he = H(P.charCodeAt(ue + 1));
            if (ce === void 0 || he === void 0) {
                const ee = P[ue] + P[ue + 1];
                throw new Error('hex string expected, got non-hex character "' + ee + '" at index ' + ue);
            }
            j[ie] = ce * 16 + he;
        }
        return j;
    }
    const re = async ()=>{};
    e.nextTick = re;
    async function Q(P, k, L) {
        let j = Date.now();
        for(let ie = 0; ie < P; ie++){
            L(ie);
            const ue = Date.now() - j;
            ue >= 0 && ue < k || (await (0, e.nextTick)(), j += ue);
        }
    }
    function G(P) {
        if (typeof P != "string") throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(P));
    }
    function R(P) {
        return new TextDecoder().decode(P);
    }
    function X(P) {
        return typeof P == "string" && (P = G(P)), i(P), P;
    }
    function $(P) {
        return typeof P == "string" && (P = G(P)), i(P), P;
    }
    function S(...P) {
        let k = 0;
        for(let j = 0; j < P.length; j++){
            const ie = P[j];
            i(ie), k += ie.length;
        }
        const L = new Uint8Array(k);
        for(let j = 0, ie = 0; j < P.length; j++){
            const ue = P[j];
            L.set(ue, ie), ie += ue.length;
        }
        return L;
    }
    function w(P, k) {
        if (k !== void 0 && ({}).toString.call(k) !== "[object Object]") throw new Error("options should be object or undefined");
        return Object.assign(P, k);
    }
    class g {
    }
    e.Hash = g;
    function m(P) {
        const k = (j)=>P().update(X(j)).digest(), L = P();
        return k.outputLen = L.outputLen, k.blockLen = L.blockLen, k.create = ()=>P(), k;
    }
    function E(P) {
        const k = (j, ie)=>P(ie).update(X(j)).digest(), L = P({});
        return k.outputLen = L.outputLen, k.blockLen = L.blockLen, k.create = (j)=>P(j), k;
    }
    function T(P) {
        const k = (j, ie)=>P(ie).update(X(j)).digest(), L = P({});
        return k.outputLen = L.outputLen, k.blockLen = L.blockLen, k.create = (j)=>P(j), k;
    }
    e.wrapConstructor = m, e.wrapConstructorWithOpts = E, e.wrapXOFConstructorWithOpts = T;
    function I(P = 32) {
        if (t.crypto && typeof t.crypto.getRandomValues == "function") return t.crypto.getRandomValues(new Uint8Array(P));
        if (t.crypto && typeof t.crypto.randomBytes == "function") return Uint8Array.from(t.crypto.randomBytes(P));
        throw new Error("crypto.getRandomValues must be defined");
    }
})(Hr);
Object.defineProperty(Pi, "__esModule", {
    value: !0
});
Pi.SHA512_IV = Pi.SHA384_IV = Pi.SHA224_IV = Pi.SHA256_IV = Pi.HashMD = void 0;
Pi.setBigUint64 = r9;
Pi.Chi = xG;
Pi.Maj = SG;
const Gs = Hr;
function r9(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
function xG(e, t, r) {
    return e & t ^ ~e & r;
}
function SG(e, t, r) {
    return e & t ^ e & r ^ t & r;
}
class AG extends Gs.Hash {
    constructor(t, r, n, i){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = (0, Gs.createView)(this.buffer);
    }
    update(t) {
        (0, Gs.aexists)(this), t = (0, Gs.toBytes)(t), (0, Gs.abytes)(t);
        const { view: r, buffer: n, blockLen: i } = this, o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = (0, Gs.createView)(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        (0, Gs.aexists)(this), (0, Gs.aoutput)(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, (0, Gs.clean)(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        r9(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = (0, Gs.createView)(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.destroyed = s, t.finished = o, t.length = i, t.pos = a, i % r && t.buffer.set(n), t;
    }
    clone() {
        return this._cloneInto();
    }
}
Pi.HashMD = AG;
Pi.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]);
Pi.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
]);
Pi.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
]);
Pi.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]);
var ar = {};
Object.defineProperty(ar, "__esModule", {
    value: !0
});
ar.toBig = ar.shrSL = ar.shrSH = ar.rotrSL = ar.rotrSH = ar.rotrBL = ar.rotrBH = ar.rotr32L = ar.rotr32H = ar.rotlSL = ar.rotlSH = ar.rotlBL = ar.rotlBH = ar.add5L = ar.add5H = ar.add4L = ar.add4H = ar.add3L = ar.add3H = void 0;
ar.add = m9;
ar.fromBig = g3;
ar.split = n9;
const Ng = /* @__PURE__ */ BigInt(2 ** 32 - 1), CE = /* @__PURE__ */ BigInt(32);
function g3(e, t = !1) {
    return t ? {
        h: Number(e & Ng),
        l: Number(e >> CE & Ng)
    } : {
        h: Number(e >> CE & Ng) | 0,
        l: Number(e & Ng) | 0
    };
}
function n9(e, t = !1) {
    const r = e.length;
    let n = new Uint32Array(r), i = new Uint32Array(r);
    for(let o = 0; o < r; o++){
        const { h: s, l: a } = g3(e[o], t);
        [n[o], i[o]] = [
            s,
            a
        ];
    }
    return [
        n,
        i
    ];
}
const i9 = (e, t)=>BigInt(e >>> 0) << CE | BigInt(t >>> 0);
ar.toBig = i9;
const o9 = (e, t, r)=>e >>> r;
ar.shrSH = o9;
const s9 = (e, t, r)=>e << 32 - r | t >>> r;
ar.shrSL = s9;
const a9 = (e, t, r)=>e >>> r | t << 32 - r;
ar.rotrSH = a9;
const c9 = (e, t, r)=>e << 32 - r | t >>> r;
ar.rotrSL = c9;
const u9 = (e, t, r)=>e << 64 - r | t >>> r - 32;
ar.rotrBH = u9;
const f9 = (e, t, r)=>e >>> r - 32 | t << 64 - r;
ar.rotrBL = f9;
const l9 = (e, t)=>t;
ar.rotr32H = l9;
const d9 = (e, t)=>e;
ar.rotr32L = d9;
const h9 = (e, t, r)=>e << r | t >>> 32 - r;
ar.rotlSH = h9;
const p9 = (e, t, r)=>t << r | e >>> 32 - r;
ar.rotlSL = p9;
const g9 = (e, t, r)=>t << r - 32 | e >>> 64 - r;
ar.rotlBH = g9;
const y9 = (e, t, r)=>e << r - 32 | t >>> 64 - r;
ar.rotlBL = y9;
function m9(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    };
}
const b9 = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0);
ar.add3L = b9;
const w9 = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0;
ar.add3H = w9;
const v9 = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
ar.add4L = v9;
const _9 = (e, t, r, n, i)=>t + r + n + i + (e / 2 ** 32 | 0) | 0;
ar.add4H = _9;
const E9 = (e, t, r, n, i)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0);
ar.add5L = E9;
const x9 = (e, t, r, n, i, o)=>t + r + n + i + o + (e / 2 ** 32 | 0) | 0;
ar.add5H = x9;
const TG = {
    fromBig: g3,
    split: n9,
    toBig: i9,
    shrSH: o9,
    shrSL: s9,
    rotrSH: a9,
    rotrSL: c9,
    rotrBH: u9,
    rotrBL: f9,
    rotr32H: l9,
    rotr32L: d9,
    rotlSH: h9,
    rotlSL: p9,
    rotlBH: g9,
    rotlBL: y9,
    add: m9,
    add3L: b9,
    add3H: w9,
    add4L: v9,
    add4H: _9,
    add5H: x9,
    add5L: E9
};
ar.default = TG;
Object.defineProperty(en, "__esModule", {
    value: !0
});
en.sha512_224 = en.sha512_256 = en.sha384 = en.sha512 = en.sha224 = B9 = en.sha256 = en.SHA512_256 = en.SHA512_224 = en.SHA384 = en.SHA512 = en.SHA224 = en.SHA256 = void 0;
const Kt = Pi, _r = ar, Fn = Hr, kG = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Rc = /* @__PURE__ */ new Uint32Array(64);
let y3 = class extends Kt.HashMD {
    constructor(t = 32){
        super(64, t, 8, !1), this.A = Kt.SHA256_IV[0] | 0, this.B = Kt.SHA256_IV[1] | 0, this.C = Kt.SHA256_IV[2] | 0, this.D = Kt.SHA256_IV[3] | 0, this.E = Kt.SHA256_IV[4] | 0, this.F = Kt.SHA256_IV[5] | 0, this.G = Kt.SHA256_IV[6] | 0, this.H = Kt.SHA256_IV[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Rc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Rc[l - 15], y = Rc[l - 2], _ = (0, Fn.rotr)(p, 7) ^ (0, Fn.rotr)(p, 18) ^ p >>> 3, A = (0, Fn.rotr)(y, 17) ^ (0, Fn.rotr)(y, 19) ^ y >>> 10;
            Rc[l] = A + Rc[l - 7] + _ + Rc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = (0, Fn.rotr)(a, 6) ^ (0, Fn.rotr)(a, 11) ^ (0, Fn.rotr)(a, 25), y = c + p + (0, Kt.Chi)(a, u, f) + kG[l] + Rc[l] | 0, A = ((0, Fn.rotr)(n, 2) ^ (0, Fn.rotr)(n, 13) ^ (0, Fn.rotr)(n, 22)) + (0, Kt.Maj)(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        (0, Fn.clean)(Rc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, Fn.clean)(this.buffer);
    }
};
en.SHA256 = y3;
let S9 = class extends y3 {
    constructor(){
        super(28), this.A = Kt.SHA224_IV[0] | 0, this.B = Kt.SHA224_IV[1] | 0, this.C = Kt.SHA224_IV[2] | 0, this.D = Kt.SHA224_IV[3] | 0, this.E = Kt.SHA224_IV[4] | 0, this.F = Kt.SHA224_IV[5] | 0, this.G = Kt.SHA224_IV[6] | 0, this.H = Kt.SHA224_IV[7] | 0;
    }
};
en.SHA224 = S9;
const A9 = _r.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), IG = A9[0], BG = A9[1], Cc = /* @__PURE__ */ new Uint32Array(80), Uc = /* @__PURE__ */ new Uint32Array(80);
let Jp = class extends Kt.HashMD {
    constructor(t = 64){
        super(128, t, 16, !1), this.Ah = Kt.SHA512_IV[0] | 0, this.Al = Kt.SHA512_IV[1] | 0, this.Bh = Kt.SHA512_IV[2] | 0, this.Bl = Kt.SHA512_IV[3] | 0, this.Ch = Kt.SHA512_IV[4] | 0, this.Cl = Kt.SHA512_IV[5] | 0, this.Dh = Kt.SHA512_IV[6] | 0, this.Dl = Kt.SHA512_IV[7] | 0, this.Eh = Kt.SHA512_IV[8] | 0, this.El = Kt.SHA512_IV[9] | 0, this.Fh = Kt.SHA512_IV[10] | 0, this.Fl = Kt.SHA512_IV[11] | 0, this.Gh = Kt.SHA512_IV[12] | 0, this.Gl = Kt.SHA512_IV[13] | 0, this.Hh = Kt.SHA512_IV[14] | 0, this.Hl = Kt.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: u, Eh: f, El: c, Fh: l, Fl: p, Gh: y, Gl: _, Hh: A, Hl: O } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u,
            f,
            c,
            l,
            p,
            y,
            _,
            A,
            O
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = f | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = A | 0, this.Hl = O | 0;
    }
    process(t, r) {
        for(let D = 0; D < 16; D++, r += 4)Cc[D] = t.getUint32(r), Uc[D] = t.getUint32(r += 4);
        for(let D = 16; D < 80; D++){
            const H = Cc[D - 15] | 0, K = Uc[D - 15] | 0, re = _r.rotrSH(H, K, 1) ^ _r.rotrSH(H, K, 8) ^ _r.shrSH(H, K, 7), Q = _r.rotrSL(H, K, 1) ^ _r.rotrSL(H, K, 8) ^ _r.shrSL(H, K, 7), G = Cc[D - 2] | 0, R = Uc[D - 2] | 0, X = _r.rotrSH(G, R, 19) ^ _r.rotrBH(G, R, 61) ^ _r.shrSH(G, R, 6), $ = _r.rotrSL(G, R, 19) ^ _r.rotrBL(G, R, 61) ^ _r.shrSL(G, R, 6), S = _r.add4L(Q, $, Uc[D - 7], Uc[D - 16]), w = _r.add4H(S, re, X, Cc[D - 7], Cc[D - 16]);
            Cc[D] = w | 0, Uc[D] = S | 0;
        }
        let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: u, Dh: f, Dl: c, Eh: l, El: p, Fh: y, Fl: _, Gh: A, Gl: O, Hh: N, Hl: U } = this;
        for(let D = 0; D < 80; D++){
            const H = _r.rotrSH(l, p, 14) ^ _r.rotrSH(l, p, 18) ^ _r.rotrBH(l, p, 41), K = _r.rotrSL(l, p, 14) ^ _r.rotrSL(l, p, 18) ^ _r.rotrBL(l, p, 41), re = l & y ^ ~l & A, Q = p & _ ^ ~p & O, G = _r.add5L(U, K, Q, BG[D], Uc[D]), R = _r.add5H(G, N, H, re, IG[D], Cc[D]), X = G | 0, $ = _r.rotrSH(n, i, 28) ^ _r.rotrBH(n, i, 34) ^ _r.rotrBH(n, i, 39), S = _r.rotrSL(n, i, 28) ^ _r.rotrBL(n, i, 34) ^ _r.rotrBL(n, i, 39), w = n & o ^ n & a ^ o & a, g = i & s ^ i & u ^ s & u;
            N = A | 0, U = O | 0, A = y | 0, O = _ | 0, y = l | 0, _ = p | 0, ({ h: l, l: p } = _r.add(f | 0, c | 0, R | 0, X | 0)), f = a | 0, c = u | 0, a = o | 0, u = s | 0, o = n | 0, s = i | 0;
            const m = _r.add3L(X, S, g);
            n = _r.add3H(m, R, $, w), i = m | 0;
        }
        ({ h: n, l: i } = _r.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), ({ h: o, l: s } = _r.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0)), ({ h: a, l: u } = _r.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: f, l: c } = _r.add(this.Dh | 0, this.Dl | 0, f | 0, c | 0)), ({ h: l, l: p } = _r.add(this.Eh | 0, this.El | 0, l | 0, p | 0)), ({ h: y, l: _ } = _r.add(this.Fh | 0, this.Fl | 0, y | 0, _ | 0)), ({ h: A, l: O } = _r.add(this.Gh | 0, this.Gl | 0, A | 0, O | 0)), ({ h: N, l: U } = _r.add(this.Hh | 0, this.Hl | 0, N | 0, U | 0)), this.set(n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U);
    }
    roundClean() {
        (0, Fn.clean)(Cc, Uc);
    }
    destroy() {
        (0, Fn.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
en.SHA512 = Jp;
let T9 = class extends Jp {
    constructor(){
        super(48), this.Ah = Kt.SHA384_IV[0] | 0, this.Al = Kt.SHA384_IV[1] | 0, this.Bh = Kt.SHA384_IV[2] | 0, this.Bl = Kt.SHA384_IV[3] | 0, this.Ch = Kt.SHA384_IV[4] | 0, this.Cl = Kt.SHA384_IV[5] | 0, this.Dh = Kt.SHA384_IV[6] | 0, this.Dl = Kt.SHA384_IV[7] | 0, this.Eh = Kt.SHA384_IV[8] | 0, this.El = Kt.SHA384_IV[9] | 0, this.Fh = Kt.SHA384_IV[10] | 0, this.Fl = Kt.SHA384_IV[11] | 0, this.Gh = Kt.SHA384_IV[12] | 0, this.Gl = Kt.SHA384_IV[13] | 0, this.Hh = Kt.SHA384_IV[14] | 0, this.Hl = Kt.SHA384_IV[15] | 0;
    }
};
en.SHA384 = T9;
const Si = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
]), Ai = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
]);
let k9 = class extends Jp {
    constructor(){
        super(28), this.Ah = Si[0] | 0, this.Al = Si[1] | 0, this.Bh = Si[2] | 0, this.Bl = Si[3] | 0, this.Ch = Si[4] | 0, this.Cl = Si[5] | 0, this.Dh = Si[6] | 0, this.Dl = Si[7] | 0, this.Eh = Si[8] | 0, this.El = Si[9] | 0, this.Fh = Si[10] | 0, this.Fl = Si[11] | 0, this.Gh = Si[12] | 0, this.Gl = Si[13] | 0, this.Hh = Si[14] | 0, this.Hl = Si[15] | 0;
    }
};
en.SHA512_224 = k9;
let I9 = class extends Jp {
    constructor(){
        super(32), this.Ah = Ai[0] | 0, this.Al = Ai[1] | 0, this.Bh = Ai[2] | 0, this.Bl = Ai[3] | 0, this.Ch = Ai[4] | 0, this.Cl = Ai[5] | 0, this.Dh = Ai[6] | 0, this.Dl = Ai[7] | 0, this.Eh = Ai[8] | 0, this.El = Ai[9] | 0, this.Fh = Ai[10] | 0, this.Fl = Ai[11] | 0, this.Gh = Ai[12] | 0, this.Gl = Ai[13] | 0, this.Hh = Ai[14] | 0, this.Hl = Ai[15] | 0;
    }
};
en.SHA512_256 = I9;
var B9 = en.sha256 = (0, Fn.createHasher)(()=>new y3());
en.sha224 = (0, Fn.createHasher)(()=>new S9());
en.sha512 = (0, Fn.createHasher)(()=>new Jp());
en.sha384 = (0, Fn.createHasher)(()=>new T9());
en.sha512_256 = (0, Fn.createHasher)(()=>new I9());
en.sha512_224 = (0, Fn.createHasher)(()=>new k9());
var yb = {}, m3 = {}, Qp = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.hmac = e.HMAC = void 0;
    const t = Hr;
    class r extends t.Hash {
        constructor(o, s){
            super(), this.finished = !1, this.destroyed = !1, (0, t.ahash)(o);
            const a = (0, t.toBytes)(s);
            if (this.iHash = o.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
            const u = this.blockLen, f = new Uint8Array(u);
            f.set(a.length > u ? o.create().update(a).digest() : a);
            for(let c = 0; c < f.length; c++)f[c] ^= 54;
            this.iHash.update(f), this.oHash = o.create();
            for(let c = 0; c < f.length; c++)f[c] ^= 106;
            this.oHash.update(f), (0, t.clean)(f);
        }
        update(o) {
            return (0, t.aexists)(this), this.iHash.update(o), this;
        }
        digestInto(o) {
            (0, t.aexists)(this), (0, t.abytes)(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();
        }
        digest() {
            const o = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(o), o;
        }
        _cloneInto(o) {
            o || (o = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash: s, iHash: a, finished: u, destroyed: f, blockLen: c, outputLen: l } = this;
            return o = o, o.finished = u, o.destroyed = f, o.blockLen = c, o.outputLen = l, o.oHash = s._cloneInto(o.oHash), o.iHash = a._cloneInto(o.iHash), o;
        }
        clone() {
            return this._cloneInto();
        }
        destroy() {
            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
        }
    }
    e.HMAC = r;
    const n = (i, o, s)=>new r(i, o).update(s).digest();
    e.hmac = n, e.hmac.create = (i, o)=>new r(i, o);
})(Qp);
var Mf = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.notImplemented = e.bitMask = e.utf8ToBytes = e.randomBytes = e.isBytes = e.hexToBytes = e.concatBytes = e.bytesToUtf8 = e.bytesToHex = e.anumber = e.abytes = void 0, e.abool = o, e.numberToHexUnpadded = s, e.hexToNumber = a, e.bytesToNumberBE = u, e.bytesToNumberLE = f, e.numberToBytesBE = c, e.numberToBytesLE = l, e.numberToVarBytesBE = p, e.ensureBytes = y, e.equalBytes = _, e.inRange = O, e.aInRange = N, e.bitLen = U, e.bitGet = D, e.bitSet = H, e.createHmacDrbg = re, e.validateObject = G, e.isHash = R, e._validateObject = X, e.memoized = S;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = Hr;
    var r = Hr;
    Object.defineProperty(e, "abytes", {
        enumerable: !0,
        get: function() {
            return r.abytes;
        }
    }), Object.defineProperty(e, "anumber", {
        enumerable: !0,
        get: function() {
            return r.anumber;
        }
    }), Object.defineProperty(e, "bytesToHex", {
        enumerable: !0,
        get: function() {
            return r.bytesToHex;
        }
    }), Object.defineProperty(e, "bytesToUtf8", {
        enumerable: !0,
        get: function() {
            return r.bytesToUtf8;
        }
    }), Object.defineProperty(e, "concatBytes", {
        enumerable: !0,
        get: function() {
            return r.concatBytes;
        }
    }), Object.defineProperty(e, "hexToBytes", {
        enumerable: !0,
        get: function() {
            return r.hexToBytes;
        }
    }), Object.defineProperty(e, "isBytes", {
        enumerable: !0,
        get: function() {
            return r.isBytes;
        }
    }), Object.defineProperty(e, "randomBytes", {
        enumerable: !0,
        get: function() {
            return r.randomBytes;
        }
    }), Object.defineProperty(e, "utf8ToBytes", {
        enumerable: !0,
        get: function() {
            return r.utf8ToBytes;
        }
    });
    const n = /* @__PURE__ */ BigInt(0), i = /* @__PURE__ */ BigInt(1);
    function o(w, g) {
        if (typeof g != "boolean") throw new Error(w + " boolean expected, got " + g);
    }
    function s(w) {
        const g = w.toString(16);
        return g.length & 1 ? "0" + g : g;
    }
    function a(w) {
        if (typeof w != "string") throw new Error("hex string expected, got " + typeof w);
        return w === "" ? n : BigInt("0x" + w);
    }
    function u(w) {
        return a((0, t.bytesToHex)(w));
    }
    function f(w) {
        return (0, t.abytes)(w), a((0, t.bytesToHex)(Uint8Array.from(w).reverse()));
    }
    function c(w, g) {
        return (0, t.hexToBytes)(w.toString(16).padStart(g * 2, "0"));
    }
    function l(w, g) {
        return c(w, g).reverse();
    }
    function p(w) {
        return (0, t.hexToBytes)(s(w));
    }
    function y(w, g, m) {
        let E;
        if (typeof g == "string") try {
            E = (0, t.hexToBytes)(g);
        } catch (I) {
            throw new Error(w + " must be hex string or Uint8Array, cause: " + I);
        }
        else if ((0, t.isBytes)(g)) E = Uint8Array.from(g);
        else throw new Error(w + " must be hex string or Uint8Array");
        const T = E.length;
        if (typeof m == "number" && T !== m) throw new Error(w + " of length " + m + " expected, got " + T);
        return E;
    }
    function _(w, g) {
        if (w.length !== g.length) return !1;
        let m = 0;
        for(let E = 0; E < w.length; E++)m |= w[E] ^ g[E];
        return m === 0;
    }
    const A = (w)=>typeof w == "bigint" && n <= w;
    function O(w, g, m) {
        return A(w) && A(g) && A(m) && g <= w && w < m;
    }
    function N(w, g, m, E) {
        if (!O(g, m, E)) throw new Error("expected valid " + w + ": " + m + " <= n < " + E + ", got " + g);
    }
    function U(w) {
        let g;
        for(g = 0; w > n; w >>= i, g += 1);
        return g;
    }
    function D(w, g) {
        return w >> BigInt(g) & i;
    }
    function H(w, g, m) {
        return w | (m ? i : n) << BigInt(g);
    }
    const K = (w)=>(i << BigInt(w)) - i;
    e.bitMask = K;
    function re(w, g, m) {
        if (typeof w != "number" || w < 2) throw new Error("hashLen must be a number");
        if (typeof g != "number" || g < 2) throw new Error("qByteLen must be a number");
        if (typeof m != "function") throw new Error("hmacFn must be a function");
        const E = (he)=>new Uint8Array(he), T = (he)=>Uint8Array.of(he);
        let I = E(w), P = E(w), k = 0;
        const L = ()=>{
            I.fill(1), P.fill(0), k = 0;
        }, j = (...he)=>m(P, I, ...he), ie = (he = E(0))=>{
            P = j(T(0), he), I = j(), he.length !== 0 && (P = j(T(1), he), I = j());
        }, ue = ()=>{
            if (k++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let he = 0;
            const ee = [];
            for(; he < g;){
                I = j();
                const ae = I.slice();
                ee.push(ae), he += I.length;
            }
            return (0, t.concatBytes)(...ee);
        };
        return (he, ee)=>{
            L(), ie(he);
            let ae;
            for(; !(ae = ee(ue()));)ie();
            return L(), ae;
        };
    }
    const Q = {
        bigint: (w)=>typeof w == "bigint",
        function: (w)=>typeof w == "function",
        boolean: (w)=>typeof w == "boolean",
        string: (w)=>typeof w == "string",
        stringOrUint8Array: (w)=>typeof w == "string" || (0, t.isBytes)(w),
        isSafeInteger: (w)=>Number.isSafeInteger(w),
        array: (w)=>Array.isArray(w),
        field: (w, g)=>g.Fp.isValid(w),
        hash: (w)=>typeof w == "function" && Number.isSafeInteger(w.outputLen)
    };
    function G(w, g, m = {}) {
        const E = (T, I, P)=>{
            const k = Q[I];
            if (typeof k != "function") throw new Error("invalid validator function");
            const L = w[T];
            if (!(P && L === void 0) && !k(L, w)) throw new Error("param " + String(T) + " is invalid. Expected " + I + ", got " + L);
        };
        for (const [T, I] of Object.entries(g))E(T, I, !1);
        for (const [T, I] of Object.entries(m))E(T, I, !0);
        return w;
    }
    function R(w) {
        return typeof w == "function" && Number.isSafeInteger(w.outputLen);
    }
    function X(w, g, m = {}) {
        if (!w || typeof w != "object") throw new Error("expected valid options object");
        function E(T, I, P) {
            const k = w[T];
            if (P && k === void 0) return;
            const L = typeof k;
            if (L !== I || k === null) throw new Error(`param "${T}" is invalid: expected ${I}, got ${L}`);
        }
        Object.entries(g).forEach(([T, I])=>E(T, I, !1)), Object.entries(m).forEach(([T, I])=>E(T, I, !0));
    }
    const $ = ()=>{
        throw new Error("not implemented");
    };
    e.notImplemented = $;
    function S(w) {
        const g = /* @__PURE__ */ new WeakMap();
        return (m, ...E)=>{
            const T = g.get(m);
            if (T !== void 0) return T;
            const I = w(m, ...E);
            return g.set(m, I), I;
        };
    }
})(Mf);
var xa = {}, sn = {};
Object.defineProperty(sn, "__esModule", {
    value: !0
});
sn.isNegativeLE = void 0;
sn.mod = Io;
sn.pow = PG;
sn.pow2 = NG;
sn.invert = tm;
sn.tonelliShanks = R9;
sn.FpSqrt = C9;
sn.validateField = UG;
sn.FpPow = b3;
sn.FpInvertBatch = U9;
sn.FpDiv = $G;
sn.FpLegendre = rm;
sn.FpIsSquare = LG;
sn.nLength = w3;
sn.Field = v3;
sn.FpSqrtOdd = DG;
sn.FpSqrtEven = FG;
sn.hashToPrivateScalar = zG;
sn.getFieldBytesLength = _3;
sn.getMinHashLength = $9;
sn.mapHashToField = jG;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const io = Mf, so = BigInt(0), Xn = BigInt(1), nf = /* @__PURE__ */ BigInt(2), OG = /* @__PURE__ */ BigInt(3), O9 = /* @__PURE__ */ BigInt(4), P9 = /* @__PURE__ */ BigInt(5), N9 = /* @__PURE__ */ BigInt(8);
function Io(e, t) {
    const r = e % t;
    return r >= so ? r : t + r;
}
function PG(e, t, r) {
    return b3(v3(r), e, t);
}
function NG(e, t, r) {
    let n = e;
    for(; t-- > so;)n *= n, n %= r;
    return n;
}
function tm(e, t) {
    if (e === so) throw new Error("invert: expected non-zero number");
    if (t <= so) throw new Error("invert: expected positive modulus, got " + t);
    let r = Io(e, t), n = t, i = so, o = Xn;
    for(; r !== so;){
        const a = n / r, u = n % r, f = i - o * a;
        n = r, r = u, i = o, o = f;
    }
    if (n !== Xn) throw new Error("invert: does not exist");
    return Io(i, t);
}
function M9(e, t) {
    const r = (e.ORDER + Xn) / O9, n = e.pow(t, r);
    if (!e.eql(e.sqr(n), t)) throw new Error("Cannot find square root");
    return n;
}
function MG(e, t) {
    const r = (e.ORDER - P9) / N9, n = e.mul(t, nf), i = e.pow(n, r), o = e.mul(t, i), s = e.mul(e.mul(o, nf), i), a = e.mul(o, e.sub(s, e.ONE));
    if (!e.eql(e.sqr(a), t)) throw new Error("Cannot find square root");
    return a;
}
function R9(e) {
    if (e < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let t = e - Xn, r = 0;
    for(; t % nf === so;)t /= nf, r++;
    let n = nf;
    const i = v3(e);
    for(; rm(i, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return M9;
    let o = i.pow(n, t);
    const s = (t + Xn) / nf;
    return function(u, f) {
        if (u.is0(f)) return f;
        if (rm(u, f) !== 1) throw new Error("Cannot find square root");
        let c = r, l = u.mul(u.ONE, o), p = u.pow(f, t), y = u.pow(f, s);
        for(; !u.eql(p, u.ONE);){
            if (u.is0(p)) return u.ZERO;
            let _ = 1, A = u.sqr(p);
            for(; !u.eql(A, u.ONE);)if (_++, A = u.sqr(A), _ === c) throw new Error("Cannot find square root");
            const O = Xn << BigInt(c - _ - 1), N = u.pow(l, O);
            c = _, l = u.sqr(N), p = u.mul(p, l), y = u.mul(y, N);
        }
        return y;
    };
}
function C9(e) {
    return e % O9 === OG ? M9 : e % N9 === P9 ? MG : R9(e);
}
const RG = (e, t)=>(Io(e, t) & Xn) === Xn;
sn.isNegativeLE = RG;
const CG = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function UG(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, r = CG.reduce((n, i)=>(n[i] = "function", n), t);
    return (0, io._validateObject)(e, r), e;
}
function b3(e, t, r) {
    if (r < so) throw new Error("invalid exponent, negatives unsupported");
    if (r === so) return e.ONE;
    if (r === Xn) return t;
    let n = e.ONE, i = t;
    for(; r > so;)r & Xn && (n = e.mul(n, i)), i = e.sqr(i), r >>= Xn;
    return n;
}
function U9(e, t, r = !1) {
    const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, a, u)=>e.is0(a) ? s : (n[u] = s, e.mul(s, a)), e.ONE), o = e.inv(i);
    return t.reduceRight((s, a, u)=>e.is0(a) ? s : (n[u] = e.mul(s, n[u]), e.mul(s, a)), o), n;
}
function $G(e, t, r) {
    return e.mul(t, typeof r == "bigint" ? tm(r, e.ORDER) : e.inv(r));
}
function rm(e, t) {
    const r = (e.ORDER - Xn) / nf, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), s = e.eql(n, e.neg(e.ONE));
    if (!i && !o && !s) throw new Error("invalid Legendre symbol result");
    return i ? 1 : o ? 0 : -1;
}
function LG(e, t) {
    return rm(e, t) === 1;
}
function w3(e, t) {
    t !== void 0 && (0, io.anumber)(t);
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function v3(e, t, r = !1, n = {}) {
    if (e <= so) throw new Error("invalid field: expected ORDER > 0, got " + e);
    let i, o;
    if (typeof t == "object" && t != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const c = t;
        c.BITS && (i = c.BITS), c.sqrt && (o = c.sqrt), typeof c.isLE == "boolean" && (r = c.isLE);
    } else typeof t == "number" && (i = t), n.sqrt && (o = n.sqrt);
    const { nBitLength: s, nByteLength: a } = w3(e, i);
    if (a > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const f = Object.freeze({
        ORDER: e,
        isLE: r,
        BITS: s,
        BYTES: a,
        MASK: (0, io.bitMask)(s),
        ZERO: so,
        ONE: Xn,
        create: (c)=>Io(c, e),
        isValid: (c)=>{
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return so <= c && c < e;
        },
        is0: (c)=>c === so,
        // is valid and invertible
        isValidNot0: (c)=>!f.is0(c) && f.isValid(c),
        isOdd: (c)=>(c & Xn) === Xn,
        neg: (c)=>Io(-c, e),
        eql: (c, l)=>c === l,
        sqr: (c)=>Io(c * c, e),
        add: (c, l)=>Io(c + l, e),
        sub: (c, l)=>Io(c - l, e),
        mul: (c, l)=>Io(c * l, e),
        pow: (c, l)=>b3(f, c, l),
        div: (c, l)=>Io(c * tm(l, e), e),
        // Same as above, but doesn't normalize
        sqrN: (c)=>c * c,
        addN: (c, l)=>c + l,
        subN: (c, l)=>c - l,
        mulN: (c, l)=>c * l,
        inv: (c)=>tm(c, e),
        sqrt: o || ((c)=>(u || (u = C9(e)), u(f, c))),
        toBytes: (c)=>r ? (0, io.numberToBytesLE)(c, a) : (0, io.numberToBytesBE)(c, a),
        fromBytes: (c)=>{
            if (c.length !== a) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + c.length);
            return r ? (0, io.bytesToNumberLE)(c) : (0, io.bytesToNumberBE)(c);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (c)=>U9(f, c),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (c, l, p)=>p ? l : c
    });
    return Object.freeze(f);
}
function DG(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? r : e.neg(r);
}
function FG(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? e.neg(r) : r;
}
function zG(e, t, r = !1) {
    e = (0, io.ensureBytes)("privateHash", e);
    const n = e.length, i = w3(t).nByteLength + 8;
    if (i < 24 || n < i || n > 1024) throw new Error("hashToPrivateScalar: expected " + i + "-1024 bytes of input, got " + n);
    const o = r ? (0, io.bytesToNumberLE)(e) : (0, io.bytesToNumberBE)(e);
    return Io(o, t - Xn) + Xn;
}
function _3(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function $9(e) {
    const t = _3(e);
    return t + Math.ceil(t / 2);
}
function jG(e, t, r = !1) {
    const n = e.length, i = _3(t), o = $9(t);
    if (n < 16 || n < o || n > 1024) throw new Error("expected " + o + "-1024 bytes of input, got " + n);
    const s = r ? (0, io.bytesToNumberLE)(e) : (0, io.bytesToNumberBE)(e), a = Io(s, t - Xn) + Xn;
    return r ? (0, io.numberToBytesLE)(a, i) : (0, io.numberToBytesBE)(a, i);
}
Object.defineProperty(xa, "__esModule", {
    value: !0
});
xa.negateCt = Ty;
xa.normalizeZ = HG;
xa.wNAF = qG;
xa.mulEndoUnsafe = KG;
xa.pippenger = WG;
xa.precomputeMSMUnsafe = VG;
xa.validateBasic = GG;
xa._createCurveFields = ZG;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ip = Mf, op = sn, ed = BigInt(0), of = BigInt(1);
function Ty(e, t) {
    const r = t.negate();
    return e ? r : t;
}
function HG(e, t, r) {
    const n = t === "pz" ? (s)=>s.pz : (s)=>s.ez, i = (0, op.FpInvertBatch)(e.Fp, r.map(n));
    return r.map((s, a)=>s.toAffine(i[a])).map(e.fromAffine);
}
function E3(e, t) {
    if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function rv(e, t) {
    E3(e, t);
    const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = (0, ip.bitMask)(e), s = BigInt(e);
    return {
        windows: r,
        windowSize: n,
        mask: o,
        maxNumber: i,
        shiftBy: s
    };
}
function pA(e, t, r) {
    const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = r;
    let a = Number(e & i), u = e >> s;
    a > n && (a -= o, u += of);
    const f = t * n, c = f + Math.abs(a) - 1, l = a === 0, p = a < 0, y = t % 2 !== 0;
    return {
        nextN: u,
        offset: c,
        isZero: l,
        isNeg: p,
        isNegF: y,
        offsetF: f
    };
}
function L9(e, t) {
    if (!Array.isArray(e)) throw new Error("array expected");
    e.forEach((r, n)=>{
        if (!(r instanceof t)) throw new Error("invalid point at index " + n);
    });
}
function D9(e, t) {
    if (!Array.isArray(e)) throw new Error("array of scalars expected");
    e.forEach((r, n)=>{
        if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
    });
}
const nv = /* @__PURE__ */ new WeakMap(), F9 = /* @__PURE__ */ new WeakMap();
function iv(e) {
    return F9.get(e) || 1;
}
function gA(e) {
    if (e !== ed) throw new Error("invalid wNAF");
}
function qG(e, t) {
    return {
        constTimeNegate: Ty,
        hasPrecomputes (r) {
            return iv(r) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (r, n, i = e.ZERO) {
            let o = r;
            for(; n > ed;)n & of && (i = i.add(o)), o = o.double(), n >>= of;
            return i;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (r, n) {
            const { windows: i, windowSize: o } = rv(n, t), s = [];
            let a = r, u = a;
            for(let f = 0; f < i; f++){
                u = a, s.push(u);
                for(let c = 1; c < o; c++)u = u.add(a), s.push(u);
                a = u.double();
            }
            return s;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (r, n, i) {
            let o = e.ZERO, s = e.BASE;
            const a = rv(r, t);
            for(let u = 0; u < a.windows; u++){
                const { nextN: f, offset: c, isZero: l, isNeg: p, isNegF: y, offsetF: _ } = pA(i, u, a);
                i = f, l ? s = s.add(Ty(y, n[_])) : o = o.add(Ty(p, n[c]));
            }
            return gA(i), {
                p: o,
                f: s
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (r, n, i, o = e.ZERO) {
            const s = rv(r, t);
            for(let a = 0; a < s.windows && i !== ed; a++){
                const { nextN: u, offset: f, isZero: c, isNeg: l } = pA(i, a, s);
                if (i = u, !c) {
                    const p = n[f];
                    o = o.add(l ? p.negate() : p);
                }
            }
            return gA(i), o;
        },
        getPrecomputes (r, n, i) {
            let o = nv.get(n);
            return o || (o = this.precomputeWindow(n, r), r !== 1 && (typeof i == "function" && (o = i(o)), nv.set(n, o))), o;
        },
        wNAFCached (r, n, i) {
            const o = iv(r);
            return this.wNAF(o, this.getPrecomputes(o, r, i), n);
        },
        wNAFCachedUnsafe (r, n, i, o) {
            const s = iv(r);
            return s === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, r, i), n, o);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (r, n) {
            E3(n, t), F9.set(r, n), nv.delete(r);
        }
    };
}
function KG(e, t, r, n) {
    let i = t, o = e.ZERO, s = e.ZERO;
    for(; r > ed || n > ed;)r & of && (o = o.add(i)), n & of && (s = s.add(i)), i = i.double(), r >>= of, n >>= of;
    return {
        p1: o,
        p2: s
    };
}
function WG(e, t, r, n) {
    L9(r, e), D9(n, t);
    const i = r.length, o = n.length;
    if (i !== o) throw new Error("arrays of points and scalars must have equal length");
    const s = e.ZERO, a = (0, ip.bitLen)(BigInt(i));
    let u = 1;
    a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
    const f = (0, ip.bitMask)(u), c = new Array(Number(f) + 1).fill(s), l = Math.floor((t.BITS - 1) / u) * u;
    let p = s;
    for(let y = l; y >= 0; y -= u){
        c.fill(s);
        for(let A = 0; A < o; A++){
            const O = n[A], N = Number(O >> BigInt(y) & f);
            c[N] = c[N].add(r[A]);
        }
        let _ = s;
        for(let A = c.length - 1, O = s; A > 0; A--)O = O.add(c[A]), _ = _.add(O);
        if (p = p.add(_), y !== 0) for(let A = 0; A < u; A++)p = p.double();
    }
    return p;
}
function VG(e, t, r, n) {
    E3(n, t.BITS), L9(r, e);
    const i = e.ZERO, o = 2 ** n - 1, s = Math.ceil(t.BITS / n), a = (0, ip.bitMask)(n), u = r.map((f)=>{
        const c = [];
        for(let l = 0, p = f; l < o; l++)c.push(p), p = p.add(f);
        return c;
    });
    return (f)=>{
        if (D9(f, t), f.length > r.length) throw new Error("array of scalars must be smaller than array of points");
        let c = i;
        for(let l = 0; l < s; l++){
            if (c !== i) for(let y = 0; y < n; y++)c = c.double();
            const p = BigInt(s * n - (l + 1) * n);
            for(let y = 0; y < f.length; y++){
                const _ = f[y], A = Number(_ >> p & a);
                A && (c = c.add(u[y][A - 1]));
            }
        }
        return c;
    };
}
function GG(e) {
    return (0, op.validateField)(e.Fp), (0, ip.validateObject)(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...(0, op.nLength)(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
}
function yA(e, t) {
    if (t) {
        if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return (0, op.validateField)(t), t;
    } else return (0, op.Field)(e);
}
function ZG(e, t, r = {}) {
    if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const u = t[a];
        if (!(typeof u == "bigint" && u > ed)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const n = yA(t.p, r.Fp), i = yA(t.n, r.Fn), s = [
        "Gx",
        "Gy",
        "a",
        e === "weierstrass" ? "b" : "d"
    ];
    for (const a of s)if (!n.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i
    };
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.DER = e.DERErr = void 0, e._legacyHelperEquat = p, e._legacyHelperNormPriv = y, e.weierstrassN = _, e.weierstrassPoints = A, e.ecdsa = N, e.weierstrass = re, e.SWUFpSqrtRatio = Q, e.mapToCurveSimpleSWU = G;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = Qp, r = Mf, n = xa, i = sn;
    function o(R) {
        R.lowS !== void 0 && (0, r.abool)("lowS", R.lowS), R.prehash !== void 0 && (0, r.abool)("prehash", R.prehash);
    }
    class s extends Error {
        constructor(X = ""){
            super(X);
        }
    }
    e.DERErr = s, e.DER = {
        // asn.1 DER encoding utils
        Err: s,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
            encode: (R, X)=>{
                const { Err: $ } = e.DER;
                if (R < 0 || R > 256) throw new $("tlv.encode: wrong tag");
                if (X.length & 1) throw new $("tlv.encode: unpadded data");
                const S = X.length / 2, w = (0, r.numberToHexUnpadded)(S);
                if (w.length / 2 & 128) throw new $("tlv.encode: long form length too big");
                const g = S > 127 ? (0, r.numberToHexUnpadded)(w.length / 2 | 128) : "";
                return (0, r.numberToHexUnpadded)(R) + g + w + X;
            },
            // v - value, l - left bytes (unparsed)
            decode (R, X) {
                const { Err: $ } = e.DER;
                let S = 0;
                if (R < 0 || R > 256) throw new $("tlv.encode: wrong tag");
                if (X.length < 2 || X[S++] !== R) throw new $("tlv.decode: wrong tlv");
                const w = X[S++], g = !!(w & 128);
                let m = 0;
                if (!g) m = w;
                else {
                    const T = w & 127;
                    if (!T) throw new $("tlv.decode(long): indefinite length not supported");
                    if (T > 4) throw new $("tlv.decode(long): byte length is too big");
                    const I = X.subarray(S, S + T);
                    if (I.length !== T) throw new $("tlv.decode: length bytes not complete");
                    if (I[0] === 0) throw new $("tlv.decode(long): zero leftmost byte");
                    for (const P of I)m = m << 8 | P;
                    if (S += T, m < 128) throw new $("tlv.decode(long): not minimal encoding");
                }
                const E = X.subarray(S, S + m);
                if (E.length !== m) throw new $("tlv.decode: wrong value length");
                return {
                    v: E,
                    l: X.subarray(S + m)
                };
            }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
            encode (R) {
                const { Err: X } = e.DER;
                if (R < a) throw new X("integer: negative integers are not allowed");
                let $ = (0, r.numberToHexUnpadded)(R);
                if (Number.parseInt($[0], 16) & 8 && ($ = "00" + $), $.length & 1) throw new X("unexpected DER parsing assertion: unpadded hex");
                return $;
            },
            decode (R) {
                const { Err: X } = e.DER;
                if (R[0] & 128) throw new X("invalid signature integer: negative");
                if (R[0] === 0 && !(R[1] & 128)) throw new X("invalid signature integer: unnecessary leading zero");
                return (0, r.bytesToNumberBE)(R);
            }
        },
        toSig (R) {
            const { Err: X, _int: $, _tlv: S } = e.DER, w = (0, r.ensureBytes)("signature", R), { v: g, l: m } = S.decode(48, w);
            if (m.length) throw new X("invalid signature: left bytes after parsing");
            const { v: E, l: T } = S.decode(2, g), { v: I, l: P } = S.decode(2, T);
            if (P.length) throw new X("invalid signature: left bytes after parsing");
            return {
                r: $.decode(E),
                s: $.decode(I)
            };
        },
        hexFromSig (R) {
            const { _tlv: X, _int: $ } = e.DER, S = X.encode(2, $.encode(R.r)), w = X.encode(2, $.encode(R.s)), g = S + w;
            return X.encode(48, g);
        }
    };
    const a = BigInt(0), u = BigInt(1), f = BigInt(2), c = BigInt(3), l = BigInt(4);
    function p(R, X, $) {
        function S(w) {
            const g = R.sqr(w), m = R.mul(g, w);
            return R.add(R.add(m, R.mul(w, X)), $);
        }
        return S;
    }
    function y(R, X, $) {
        const { BYTES: S } = R;
        function w(g) {
            let m;
            if (typeof g == "bigint") m = g;
            else {
                let E = (0, r.ensureBytes)("private key", g);
                if (X) {
                    if (!X.includes(E.length * 2)) throw new Error("invalid private key");
                    const T = new Uint8Array(S);
                    T.set(E, T.length - E.length), E = T;
                }
                try {
                    m = R.fromBytes(E);
                } catch  {
                    throw new Error(`invalid private key: expected ui8a of size ${S}, got ${typeof g}`);
                }
            }
            if ($ && (m = R.create(m)), !R.isValidNot0(m)) throw new Error("invalid private key: out of range [1..N-1]");
            return m;
        }
        return w;
    }
    function _(R, X = {}) {
        const { Fp: $, Fn: S } = (0, n._createCurveFields)("weierstrass", R, X), { h: w, n: g } = R;
        (0, r._validateObject)(X, {}, {
            allowInfinityPoint: "boolean",
            clearCofactor: "function",
            isTorsionFree: "function",
            fromBytes: "function",
            toBytes: "function",
            endo: "object",
            wrapPrivateKey: "boolean"
        });
        const { endo: m } = X;
        if (m && (!$.is0(R.a) || typeof m.beta != "bigint" || typeof m.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
        function E() {
            if (!$.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
        }
        function T(Ce, M, z) {
            const { x: de, y: _e } = M.toAffine(), Ie = $.toBytes(de);
            if ((0, r.abool)("isCompressed", z), z) {
                E();
                const je = !$.isOdd(_e);
                return (0, r.concatBytes)(O(je), Ie);
            } else return (0, r.concatBytes)(Uint8Array.of(4), Ie, $.toBytes(_e));
        }
        function I(Ce) {
            (0, r.abytes)(Ce);
            const M = $.BYTES, z = M + 1, de = 2 * M + 1, _e = Ce.length, Ie = Ce[0], je = Ce.subarray(1);
            if (_e === z && (Ie === 2 || Ie === 3)) {
                const Ke = $.fromBytes(je);
                if (!$.isValid(Ke)) throw new Error("bad point: is not on curve, wrong x");
                const Ue = L(Ke);
                let h;
                try {
                    h = $.sqrt(Ue);
                } catch (te) {
                    const fe = te instanceof Error ? ": " + te.message : "";
                    throw new Error("bad point: is not on curve, sqrt error" + fe);
                }
                E();
                const x = $.isOdd(h);
                return (Ie & 1) === 1 !== x && (h = $.neg(h)), {
                    x: Ke,
                    y: h
                };
            } else if (_e === de && Ie === 4) {
                const Ke = $.fromBytes(je.subarray(M * 0, M * 1)), Ue = $.fromBytes(je.subarray(M * 1, M * 2));
                if (!j(Ke, Ue)) throw new Error("bad point: is not on curve");
                return {
                    x: Ke,
                    y: Ue
                };
            } else throw new Error(`bad point: got length ${_e}, expected compressed=${z} or uncompressed=${de}`);
        }
        const P = X.toBytes || T, k = X.fromBytes || I, L = p($, R.a, R.b);
        function j(Ce, M) {
            const z = $.sqr(M), de = L(Ce);
            return $.eql(z, de);
        }
        if (!j(R.Gx, R.Gy)) throw new Error("bad curve params: generator point");
        const ie = $.mul($.pow(R.a, c), l), ue = $.mul($.sqr(R.b), BigInt(27));
        if ($.is0($.add(ie, ue))) throw new Error("bad curve params: a or b");
        function ce(Ce, M, z = !1) {
            if (!$.isValid(M) || z && $.is0(M)) throw new Error(`bad point coordinate ${Ce}`);
            return M;
        }
        function he(Ce) {
            if (!(Ce instanceof Se)) throw new Error("ProjectivePoint expected");
        }
        const ee = (0, r.memoized)((Ce, M)=>{
            const { px: z, py: de, pz: _e } = Ce;
            if ($.eql(_e, $.ONE)) return {
                x: z,
                y: de
            };
            const Ie = Ce.is0();
            M == null && (M = Ie ? $.ONE : $.inv(_e));
            const je = $.mul(z, M), Ke = $.mul(de, M), Ue = $.mul(_e, M);
            if (Ie) return {
                x: $.ZERO,
                y: $.ZERO
            };
            if (!$.eql(Ue, $.ONE)) throw new Error("invZ was invalid");
            return {
                x: je,
                y: Ke
            };
        }), ae = (0, r.memoized)((Ce)=>{
            if (Ce.is0()) {
                if (X.allowInfinityPoint && !$.is0(Ce.py)) return;
                throw new Error("bad point: ZERO");
            }
            const { x: M, y: z } = Ce.toAffine();
            if (!$.isValid(M) || !$.isValid(z)) throw new Error("bad point: x or y not field elements");
            if (!j(M, z)) throw new Error("bad point: equation left != right");
            if (!Ce.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0;
        });
        function ye(Ce, M, z, de, _e) {
            return z = new Se($.mul(z.px, Ce), z.py, z.pz), M = (0, n.negateCt)(de, M), z = (0, n.negateCt)(_e, z), M.add(z);
        }
        class Se {
            /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(M, z, de){
                this.px = ce("x", M), this.py = ce("y", z, !0), this.pz = ce("z", de), Object.freeze(this);
            }
            /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(M) {
                const { x: z, y: de } = M || {};
                if (!M || !$.isValid(z) || !$.isValid(de)) throw new Error("invalid affine point");
                if (M instanceof Se) throw new Error("projective point not allowed");
                return $.is0(z) && $.is0(de) ? Se.ZERO : new Se(z, de, $.ONE);
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            static normalizeZ(M) {
                return (0, n.normalizeZ)(Se, "pz", M);
            }
            static fromBytes(M) {
                return (0, r.abytes)(M), Se.fromHex(M);
            }
            /** Converts hash string or Uint8Array to Point. */ static fromHex(M) {
                const z = Se.fromAffine(k((0, r.ensureBytes)("pointHex", M)));
                return z.assertValidity(), z;
            }
            /** Multiplies generator point by privateKey. */ static fromPrivateKey(M) {
                const z = y(S, X.allowedPrivateKeyLengths, X.wrapPrivateKey);
                return Se.BASE.multiply(z(M));
            }
            /** Multiscalar Multiplication */ static msm(M, z) {
                return (0, n.pippenger)(Se, S, M, z);
            }
            /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */ precompute(M = 8, z = !0) {
                return Re.setWindowSize(this, M), z || this.multiply(c), this;
            }
            /** "Private method", don't use it directly */ _setWindowSize(M) {
                this.precompute(M);
            }
            // TODO: return `this`
            /** A point on curve is valid if it conforms to equation. */ assertValidity() {
                ae(this);
            }
            hasEvenY() {
                const { y: M } = this.toAffine();
                if (!$.isOdd) throw new Error("Field doesn't support isOdd");
                return !$.isOdd(M);
            }
            /** Compare one point to another. */ equals(M) {
                he(M);
                const { px: z, py: de, pz: _e } = this, { px: Ie, py: je, pz: Ke } = M, Ue = $.eql($.mul(z, Ke), $.mul(Ie, _e)), h = $.eql($.mul(de, Ke), $.mul(je, _e));
                return Ue && h;
            }
            /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
                return new Se(this.px, $.neg(this.py), this.pz);
            }
            // Renes-Costello-Batina exception-free doubling formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 3
            // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
            double() {
                const { a: M, b: z } = R, de = $.mul(z, c), { px: _e, py: Ie, pz: je } = this;
                let Ke = $.ZERO, Ue = $.ZERO, h = $.ZERO, x = $.mul(_e, _e), q = $.mul(Ie, Ie), te = $.mul(je, je), fe = $.mul(_e, Ie);
                return fe = $.add(fe, fe), h = $.mul(_e, je), h = $.add(h, h), Ke = $.mul(M, h), Ue = $.mul(de, te), Ue = $.add(Ke, Ue), Ke = $.sub(q, Ue), Ue = $.add(q, Ue), Ue = $.mul(Ke, Ue), Ke = $.mul(fe, Ke), h = $.mul(de, h), te = $.mul(M, te), fe = $.sub(x, te), fe = $.mul(M, fe), fe = $.add(fe, h), h = $.add(x, x), x = $.add(h, x), x = $.add(x, te), x = $.mul(x, fe), Ue = $.add(Ue, x), te = $.mul(Ie, je), te = $.add(te, te), x = $.mul(te, fe), Ke = $.sub(Ke, x), h = $.mul(te, q), h = $.add(h, h), h = $.add(h, h), new Se(Ke, Ue, h);
            }
            // Renes-Costello-Batina exception-free addition formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 1
            // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
            add(M) {
                he(M);
                const { px: z, py: de, pz: _e } = this, { px: Ie, py: je, pz: Ke } = M;
                let Ue = $.ZERO, h = $.ZERO, x = $.ZERO;
                const q = R.a, te = $.mul(R.b, c);
                let fe = $.mul(z, Ie), ne = $.mul(de, je), W = $.mul(_e, Ke), J = $.add(z, de), V = $.add(Ie, je);
                J = $.mul(J, V), V = $.add(fe, ne), J = $.sub(J, V), V = $.add(z, _e);
                let C = $.add(Ie, Ke);
                return V = $.mul(V, C), C = $.add(fe, W), V = $.sub(V, C), C = $.add(de, _e), Ue = $.add(je, Ke), C = $.mul(C, Ue), Ue = $.add(ne, W), C = $.sub(C, Ue), x = $.mul(q, V), Ue = $.mul(te, W), x = $.add(Ue, x), Ue = $.sub(ne, x), x = $.add(ne, x), h = $.mul(Ue, x), ne = $.add(fe, fe), ne = $.add(ne, fe), W = $.mul(q, W), V = $.mul(te, V), ne = $.add(ne, W), W = $.sub(fe, W), W = $.mul(q, W), V = $.add(V, W), fe = $.mul(ne, V), h = $.add(h, fe), fe = $.mul(C, V), Ue = $.mul(J, Ue), Ue = $.sub(Ue, fe), fe = $.mul(J, ne), x = $.mul(C, x), x = $.add(x, fe), new Se(Ue, h, x);
            }
            subtract(M) {
                return this.add(M.negate());
            }
            is0() {
                return this.equals(Se.ZERO);
            }
            /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */ multiply(M) {
                const { endo: z } = X;
                if (!S.isValidNot0(M)) throw new Error("invalid scalar: out of range");
                let de, _e;
                const Ie = (je)=>Re.wNAFCached(this, je, Se.normalizeZ);
                if (z) {
                    const { k1neg: je, k1: Ke, k2neg: Ue, k2: h } = z.splitScalar(M), { p: x, f: q } = Ie(Ke), { p: te, f: fe } = Ie(h);
                    _e = q.add(fe), de = ye(z.beta, x, te, je, Ue);
                } else {
                    const { p: je, f: Ke } = Ie(M);
                    de = je, _e = Ke;
                }
                return Se.normalizeZ([
                    de,
                    _e
                ])[0];
            }
            /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */ multiplyUnsafe(M) {
                const { endo: z } = X, de = this;
                if (!S.isValid(M)) throw new Error("invalid scalar: out of range");
                if (M === a || de.is0()) return Se.ZERO;
                if (M === u) return de;
                if (Re.hasPrecomputes(this)) return this.multiply(M);
                if (z) {
                    const { k1neg: _e, k1: Ie, k2neg: je, k2: Ke } = z.splitScalar(M), { p1: Ue, p2: h } = (0, n.mulEndoUnsafe)(Se, de, Ie, Ke);
                    return ye(z.beta, Ue, h, _e, je);
                } else return Re.wNAFCachedUnsafe(de, M);
            }
            multiplyAndAddUnsafe(M, z, de) {
                const _e = this.multiplyUnsafe(z).add(M.multiplyUnsafe(de));
                return _e.is0() ? void 0 : _e;
            }
            /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */ toAffine(M) {
                return ee(this, M);
            }
            /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */ isTorsionFree() {
                const { isTorsionFree: M } = X;
                return w === u ? !0 : M ? M(Se, this) : Re.wNAFCachedUnsafe(this, g).is0();
            }
            clearCofactor() {
                const { clearCofactor: M } = X;
                return w === u ? this : M ? M(Se, this) : this.multiplyUnsafe(w);
            }
            toBytes(M = !0) {
                return (0, r.abool)("isCompressed", M), this.assertValidity(), P(Se, this, M);
            }
            /** @deprecated use `toBytes` */ toRawBytes(M = !0) {
                return this.toBytes(M);
            }
            toHex(M = !0) {
                return (0, r.bytesToHex)(this.toBytes(M));
            }
            toString() {
                return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
            }
        }
        Se.BASE = new Se(R.Gx, R.Gy, $.ONE), Se.ZERO = new Se($.ZERO, $.ONE, $.ZERO), Se.Fp = $, Se.Fn = S;
        const De = S.BITS, Re = (0, n.wNAF)(Se, X.endo ? Math.ceil(De / 2) : De);
        return Se;
    }
    function A(R) {
        const { CURVE: X, curveOpts: $ } = U(R), S = _(X, $);
        return H(R, S);
    }
    function O(R) {
        return Uint8Array.of(R ? 2 : 3);
    }
    function N(R, X, $ = {}) {
        (0, r._validateObject)(X, {
            hash: "function"
        }, {
            hmac: "function",
            lowS: "boolean",
            randomBytes: "function",
            bits2int: "function",
            bits2int_modN: "function"
        });
        const S = X.randomBytes || r.randomBytes, w = X.hmac || ((de, ..._e)=>(0, t.hmac)(X.hash, de, (0, r.concatBytes)(..._e))), { Fp: g, Fn: m } = R, { ORDER: E, BITS: T } = m;
        function I(de) {
            const _e = E >> u;
            return de > _e;
        }
        function P(de) {
            return I(de) ? m.neg(de) : de;
        }
        function k(de, _e) {
            if (!m.isValidNot0(_e)) throw new Error(`invalid signature ${de}: out of range 1..CURVE.n`);
        }
        class L {
            constructor(_e, Ie, je){
                k("r", _e), k("s", Ie), this.r = _e, this.s = Ie, je != null && (this.recovery = je), Object.freeze(this);
            }
            // pair (bytes of r, bytes of s)
            static fromCompact(_e) {
                const Ie = m.BYTES, je = (0, r.ensureBytes)("compactSignature", _e, Ie * 2);
                return new L(m.fromBytes(je.subarray(0, Ie)), m.fromBytes(je.subarray(Ie, Ie * 2)));
            }
            // DER encoded ECDSA signature
            // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
            static fromDER(_e) {
                const { r: Ie, s: je } = e.DER.toSig((0, r.ensureBytes)("DER", _e));
                return new L(Ie, je);
            }
            /**
       * @todo remove
       * @deprecated
       */ assertValidity() {}
            addRecoveryBit(_e) {
                return new L(this.r, this.s, _e);
            }
            // ProjPointType<bigint>
            recoverPublicKey(_e) {
                const Ie = g.ORDER, { r: je, s: Ke, recovery: Ue } = this;
                if (Ue == null || ![
                    0,
                    1,
                    2,
                    3
                ].includes(Ue)) throw new Error("recovery id invalid");
                if (E * f < Ie && Ue > 1) throw new Error("recovery id is ambiguous for h>1 curve");
                const x = Ue === 2 || Ue === 3 ? je + E : je;
                if (!g.isValid(x)) throw new Error("recovery id 2 or 3 invalid");
                const q = g.toBytes(x), te = R.fromHex((0, r.concatBytes)(O((Ue & 1) === 0), q)), fe = m.inv(x), ne = ae((0, r.ensureBytes)("msgHash", _e)), W = m.create(-ne * fe), J = m.create(Ke * fe), V = R.BASE.multiplyUnsafe(W).add(te.multiplyUnsafe(J));
                if (V.is0()) throw new Error("point at infinify");
                return V.assertValidity(), V;
            }
            // Signatures should be low-s, to prevent malleability.
            hasHighS() {
                return I(this.s);
            }
            normalizeS() {
                return this.hasHighS() ? new L(this.r, m.neg(this.s), this.recovery) : this;
            }
            toBytes(_e) {
                if (_e === "compact") return (0, r.concatBytes)(m.toBytes(this.r), m.toBytes(this.s));
                if (_e === "der") return (0, r.hexToBytes)(e.DER.hexFromSig(this));
                throw new Error("invalid format");
            }
            // DER-encoded
            toDERRawBytes() {
                return this.toBytes("der");
            }
            toDERHex() {
                return (0, r.bytesToHex)(this.toBytes("der"));
            }
            // padded bytes of r, then padded bytes of s
            toCompactRawBytes() {
                return this.toBytes("compact");
            }
            toCompactHex() {
                return (0, r.bytesToHex)(this.toBytes("compact"));
            }
        }
        const j = y(m, $.allowedPrivateKeyLengths, $.wrapPrivateKey), ie = {
            isValidPrivateKey (de) {
                try {
                    return j(de), !0;
                } catch  {
                    return !1;
                }
            },
            normPrivateKeyToScalar: j,
            /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */ randomPrivateKey: ()=>{
                const de = E;
                return (0, i.mapHashToField)(S((0, i.getMinHashLength)(de)), de);
            },
            precompute (de = 8, _e = R.BASE) {
                return _e.precompute(de, !1);
            }
        };
        function ue(de, _e = !0) {
            return R.fromPrivateKey(de).toBytes(_e);
        }
        function ce(de) {
            if (typeof de == "bigint") return !1;
            if (de instanceof R) return !0;
            const Ie = (0, r.ensureBytes)("key", de).length, je = g.BYTES, Ke = je + 1, Ue = 2 * je + 1;
            if (!($.allowedPrivateKeyLengths || m.BYTES === Ke)) return Ie === Ke || Ie === Ue;
        }
        function he(de, _e, Ie = !0) {
            if (ce(de) === !0) throw new Error("first arg must be private key");
            if (ce(_e) === !1) throw new Error("second arg must be public key");
            return R.fromHex(_e).multiply(j(de)).toBytes(Ie);
        }
        const ee = X.bits2int || function(de) {
            if (de.length > 8192) throw new Error("input is too large");
            const _e = (0, r.bytesToNumberBE)(de), Ie = de.length * 8 - T;
            return Ie > 0 ? _e >> BigInt(Ie) : _e;
        }, ae = X.bits2int_modN || function(de) {
            return m.create(ee(de));
        }, ye = (0, r.bitMask)(T);
        function Se(de) {
            return (0, r.aInRange)("num < 2^" + T, de, a, ye), m.toBytes(de);
        }
        function De(de, _e, Ie = Re) {
            if ([
                "recovered",
                "canonical"
            ].some((J)=>J in Ie)) throw new Error("sign() legacy options not supported");
            const { hash: je } = X;
            let { lowS: Ke, prehash: Ue, extraEntropy: h } = Ie;
            Ke == null && (Ke = !0), de = (0, r.ensureBytes)("msgHash", de), o(Ie), Ue && (de = (0, r.ensureBytes)("prehashed msgHash", je(de)));
            const x = ae(de), q = j(_e), te = [
                Se(q),
                Se(x)
            ];
            if (h != null && h !== !1) {
                const J = h === !0 ? S(g.BYTES) : h;
                te.push((0, r.ensureBytes)("extraEntropy", J));
            }
            const fe = (0, r.concatBytes)(...te), ne = x;
            function W(J) {
                const V = ee(J);
                if (!m.isValidNot0(V)) return;
                const C = m.inv(V), Z = R.BASE.multiply(V).toAffine(), le = m.create(Z.x);
                if (le === a) return;
                const se = m.create(C * m.create(ne + le * q));
                if (se === a) return;
                let Ne = (Z.x === le ? 0 : 2) | Number(Z.y & u), Le = se;
                return Ke && I(se) && (Le = P(se), Ne ^= 1), new L(le, Le, Ne);
            }
            return {
                seed: fe,
                k2sig: W
            };
        }
        const Re = {
            lowS: X.lowS,
            prehash: !1
        }, Ce = {
            lowS: X.lowS,
            prehash: !1
        };
        function M(de, _e, Ie = Re) {
            const { seed: je, k2sig: Ke } = De(de, _e, Ie);
            return (0, r.createHmacDrbg)(X.hash.outputLen, m.BYTES, w)(je, Ke);
        }
        R.BASE.precompute(8);
        function z(de, _e, Ie, je = Ce) {
            const Ke = de;
            _e = (0, r.ensureBytes)("msgHash", _e), Ie = (0, r.ensureBytes)("publicKey", Ie), o(je);
            const { lowS: Ue, prehash: h, format: x } = je;
            if ("strict" in je) throw new Error("options.strict was renamed to lowS");
            if (x !== void 0 && ![
                "compact",
                "der",
                "js"
            ].includes(x)) throw new Error('format must be "compact", "der" or "js"');
            const q = typeof Ke == "string" || (0, r.isBytes)(Ke), te = !q && !x && typeof Ke == "object" && Ke !== null && typeof Ke.r == "bigint" && typeof Ke.s == "bigint";
            if (!q && !te) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
            let fe, ne;
            try {
                if (te) if (x === void 0 || x === "js") fe = new L(Ke.r, Ke.s);
                else throw new Error("invalid format");
                if (q) {
                    try {
                        x !== "compact" && (fe = L.fromDER(Ke));
                    } catch (Le) {
                        if (!(Le instanceof e.DER.Err)) throw Le;
                    }
                    !fe && x !== "der" && (fe = L.fromCompact(Ke));
                }
                ne = R.fromHex(Ie);
            } catch  {
                return !1;
            }
            if (!fe || Ue && fe.hasHighS()) return !1;
            h && (_e = X.hash(_e));
            const { r: W, s: J } = fe, V = ae(_e), C = m.inv(J), Z = m.create(V * C), le = m.create(W * C), se = R.BASE.multiplyUnsafe(Z).add(ne.multiplyUnsafe(le));
            return se.is0() ? !1 : m.create(se.x) === W;
        }
        return Object.freeze({
            getPublicKey: ue,
            getSharedSecret: he,
            sign: M,
            verify: z,
            utils: ie,
            Point: R,
            Signature: L
        });
    }
    function U(R) {
        const X = {
            a: R.a,
            b: R.b,
            p: R.Fp.ORDER,
            n: R.n,
            h: R.h,
            Gx: R.Gx,
            Gy: R.Gy
        }, $ = R.Fp, S = (0, i.Field)(X.n, R.nBitLength), w = {
            Fp: $,
            Fn: S,
            allowedPrivateKeyLengths: R.allowedPrivateKeyLengths,
            allowInfinityPoint: R.allowInfinityPoint,
            endo: R.endo,
            wrapPrivateKey: R.wrapPrivateKey,
            isTorsionFree: R.isTorsionFree,
            clearCofactor: R.clearCofactor,
            fromBytes: R.fromBytes,
            toBytes: R.toBytes
        };
        return {
            CURVE: X,
            curveOpts: w
        };
    }
    function D(R) {
        const { CURVE: X, curveOpts: $ } = U(R), S = {
            hash: R.hash,
            hmac: R.hmac,
            randomBytes: R.randomBytes,
            lowS: R.lowS,
            bits2int: R.bits2int,
            bits2int_modN: R.bits2int_modN
        };
        return {
            CURVE: X,
            curveOpts: $,
            ecdsaOpts: S
        };
    }
    function H(R, X) {
        const { Fp: $, Fn: S } = X;
        function w(E) {
            return (0, r.inRange)(E, u, S.ORDER);
        }
        const g = p($, R.a, R.b), m = y(S, R.allowedPrivateKeyLengths, R.wrapPrivateKey);
        return Object.assign({}, {
            CURVE: R,
            Point: X,
            ProjectivePoint: X,
            normPrivateKeyToScalar: m,
            weierstrassEquation: g,
            isWithinCurveOrder: w
        });
    }
    function K(R, X) {
        return Object.assign({}, X, {
            ProjectivePoint: X.Point,
            CURVE: R
        });
    }
    function re(R) {
        const { CURVE: X, curveOpts: $, ecdsaOpts: S } = D(R), w = _(X, $), g = N(w, S, $);
        return K(R, g);
    }
    function Q(R, X) {
        const $ = R.ORDER;
        let S = a;
        for(let ie = $ - u; ie % f === a; ie /= f)S += u;
        const w = S, g = f << w - u - u, m = g * f, E = ($ - u) / m, T = (E - u) / f, I = m - u, P = g, k = R.pow(X, E), L = R.pow(X, (E + u) / f);
        let j = (ie, ue)=>{
            let ce = k, he = R.pow(ue, I), ee = R.sqr(he);
            ee = R.mul(ee, ue);
            let ae = R.mul(ie, ee);
            ae = R.pow(ae, T), ae = R.mul(ae, he), he = R.mul(ae, ue), ee = R.mul(ae, ie);
            let ye = R.mul(ee, he);
            ae = R.pow(ye, P);
            let Se = R.eql(ae, R.ONE);
            he = R.mul(ee, L), ae = R.mul(ye, ce), ee = R.cmov(he, ee, Se), ye = R.cmov(ae, ye, Se);
            for(let De = w; De > u; De--){
                let Re = De - f;
                Re = f << Re - u;
                let Ce = R.pow(ye, Re);
                const M = R.eql(Ce, R.ONE);
                he = R.mul(ee, ce), ce = R.mul(ce, ce), Ce = R.mul(ye, ce), ee = R.cmov(he, ee, M), ye = R.cmov(Ce, ye, M);
            }
            return {
                isValid: Se,
                value: ee
            };
        };
        if (R.ORDER % l === c) {
            const ie = (R.ORDER - c) / l, ue = R.sqrt(R.neg(X));
            j = (ce, he)=>{
                let ee = R.sqr(he);
                const ae = R.mul(ce, he);
                ee = R.mul(ee, ae);
                let ye = R.pow(ee, ie);
                ye = R.mul(ye, ae);
                const Se = R.mul(ye, ue), De = R.mul(R.sqr(ye), he), Re = R.eql(De, ce);
                let Ce = R.cmov(Se, ye, Re);
                return {
                    isValid: Re,
                    value: Ce
                };
            };
        }
        return j;
    }
    function G(R, X) {
        (0, i.validateField)(R);
        const { A: $, B: S, Z: w } = X;
        if (!R.isValid($) || !R.isValid(S) || !R.isValid(w)) throw new Error("mapToCurveSimpleSWU: invalid opts");
        const g = Q(R, w);
        if (!R.isOdd) throw new Error("Field does not have .isOdd()");
        return (m)=>{
            let E, T, I, P, k, L, j, ie;
            E = R.sqr(m), E = R.mul(E, w), T = R.sqr(E), T = R.add(T, E), I = R.add(T, R.ONE), I = R.mul(I, S), P = R.cmov(w, R.neg(T), !R.eql(T, R.ZERO)), P = R.mul(P, $), T = R.sqr(I), L = R.sqr(P), k = R.mul(L, $), T = R.add(T, k), T = R.mul(T, I), L = R.mul(L, P), k = R.mul(L, S), T = R.add(T, k), j = R.mul(E, I);
            const { isValid: ue, value: ce } = g(T, L);
            ie = R.mul(E, m), ie = R.mul(ie, ce), j = R.cmov(j, I, ue), ie = R.cmov(ie, ce, ue);
            const he = R.isOdd(m) === R.isOdd(ie);
            ie = R.cmov(R.neg(ie), ie, he);
            const ee = (0, i.FpInvertBatch)(R, [
                P
            ], !0)[0];
            return j = R.mul(j, ee), {
                x: j,
                y: ie
            };
        };
    }
})(m3);
Object.defineProperty(yb, "__esModule", {
    value: !0
});
yb.getHash = XG;
yb.createCurve = JG;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const YG = m3;
function XG(e) {
    return {
        hash: e
    };
}
function JG(e, t) {
    const r = (n)=>(0, YG.weierstrass)({
            ...e,
            hash: n
        });
    return {
        ...r(t),
        create: r
    };
}
var Rf = {};
Object.defineProperty(Rf, "__esModule", {
    value: !0
});
Rf.expand_message_xmd = j9;
Rf.expand_message_xof = H9;
Rf.hash_to_field = UE;
Rf.isogenyMap = tZ;
Rf.createHasher = rZ;
const ii = Mf, z9 = sn, QG = ii.bytesToNumberBE;
function nu(e, t) {
    if (sp(e), sp(t), e < 0 || e >= 1 << 8 * t) throw new Error("invalid I2OSP input: " + e);
    const r = Array.from({
        length: t
    }).fill(0);
    for(let n = t - 1; n >= 0; n--)r[n] = e & 255, e >>>= 8;
    return new Uint8Array(r);
}
function eZ(e, t) {
    const r = new Uint8Array(e.length);
    for(let n = 0; n < e.length; n++)r[n] = e[n] ^ t[n];
    return r;
}
function sp(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function j9(e, t, r, n) {
    (0, ii.abytes)(e), (0, ii.abytes)(t), sp(r), t.length > 255 && (t = n((0, ii.concatBytes)((0, ii.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i, blockLen: o } = n, s = Math.ceil(r / i);
    if (r > 65535 || s > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const a = (0, ii.concatBytes)(t, nu(t.length, 1)), u = nu(0, o), f = nu(r, 2), c = new Array(s), l = n((0, ii.concatBytes)(u, e, f, nu(0, 1), a));
    c[0] = n((0, ii.concatBytes)(l, nu(1, 1), a));
    for(let y = 1; y <= s; y++){
        const _ = [
            eZ(l, c[y - 1]),
            nu(y + 1, 1),
            a
        ];
        c[y] = n((0, ii.concatBytes)(..._));
    }
    return (0, ii.concatBytes)(...c).slice(0, r);
}
function H9(e, t, r, n, i) {
    if ((0, ii.abytes)(e), (0, ii.abytes)(t), sp(r), t.length > 255) {
        const o = Math.ceil(2 * n / 8);
        t = i.create({
            dkLen: o
        }).update((0, ii.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (r > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i.create({
        dkLen: r
    }).update(e).update(nu(r, 2)).update(t).update(nu(t.length, 1)).digest();
}
function UE(e, t, r) {
    (0, ii._validateObject)(r, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
    });
    const { p: n, k: i, m: o, hash: s, expand: a, DST: u } = r;
    if (!(0, ii.isBytes)(u) && typeof u != "string") throw new Error("DST must be string or uint8array");
    if (!(0, ii.isHash)(r.hash)) throw new Error("expected valid hash");
    (0, ii.abytes)(e), sp(t);
    const f = typeof u == "string" ? (0, ii.utf8ToBytes)(u) : u, c = n.toString(2).length, l = Math.ceil((c + i) / 8), p = t * o * l;
    let y;
    if (a === "xmd") y = j9(e, f, p, s);
    else if (a === "xof") y = H9(e, f, p, i, s);
    else if (a === "_internal_pass") y = e;
    else throw new Error('expand must be "xmd" or "xof"');
    const _ = new Array(t);
    for(let A = 0; A < t; A++){
        const O = new Array(o);
        for(let N = 0; N < o; N++){
            const U = l * (N + A * o), D = y.subarray(U, U + l);
            O[N] = (0, z9.mod)(QG(D), n);
        }
        _[A] = O;
    }
    return _;
}
function tZ(e, t) {
    const r = t.map((n)=>Array.from(n).reverse());
    return (n, i)=>{
        const [o, s, a, u] = r.map((l)=>l.reduce((p, y)=>e.add(e.mul(p, n), y))), [f, c] = (0, z9.FpInvertBatch)(e, [
            s,
            u
        ], !0);
        return n = e.mul(o, f), i = e.mul(i, e.mul(a, c)), {
            x: n,
            y: i
        };
    };
}
function rZ(e, t, r) {
    if (typeof t != "function") throw new Error("mapToCurve() must be defined");
    function n(o) {
        return e.fromAffine(t(o));
    }
    function i(o) {
        const s = o.clearCofactor();
        return s.equals(e.ZERO) ? e.ZERO : (s.assertValidity(), s);
    }
    return {
        defaults: r,
        hashToCurve (o, s) {
            const a = r.DST ? r.DST : {}, u = Object.assign({}, r, a, s), f = UE(o, 2, u), c = n(f[0]), l = n(f[1]);
            return i(c.add(l));
        },
        encodeToCurve (o, s) {
            const a = r.encodeDST ? r.encodeDST : {}, u = Object.assign({}, r, a, s), f = UE(o, 1, u);
            return i(n(f[0]));
        },
        /** See {@link H2CHasher} */ mapToCurve (o) {
            if (!Array.isArray(o)) throw new Error("expected array of bigints");
            for (const s of o)if (typeof s != "bigint") throw new Error("expected array of bigints");
            return i(n(o));
        }
    };
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.encodeToCurve = e.hashToCurve = e.secp256k1_hasher = e.schnorr = e.secp256k1 = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = en, r = Hr, n = yb, i = Rf, o = sn, s = m3, a = Mf, u = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    }, f = BigInt(0), c = BigInt(1), l = BigInt(2), p = (E, T)=>(E + T / l) / T;
    function y(E) {
        const T = u.p, I = BigInt(3), P = BigInt(6), k = BigInt(11), L = BigInt(22), j = BigInt(23), ie = BigInt(44), ue = BigInt(88), ce = E * E * E % T, he = ce * ce * E % T, ee = (0, o.pow2)(he, I, T) * he % T, ae = (0, o.pow2)(ee, I, T) * he % T, ye = (0, o.pow2)(ae, l, T) * ce % T, Se = (0, o.pow2)(ye, k, T) * ye % T, De = (0, o.pow2)(Se, L, T) * Se % T, Re = (0, o.pow2)(De, ie, T) * De % T, Ce = (0, o.pow2)(Re, ue, T) * Re % T, M = (0, o.pow2)(Ce, ie, T) * De % T, z = (0, o.pow2)(M, I, T) * he % T, de = (0, o.pow2)(z, j, T) * Se % T, _e = (0, o.pow2)(de, P, T) * ce % T, Ie = (0, o.pow2)(_e, l, T);
        if (!_.eql(_.sqr(Ie), E)) throw new Error("Cannot find square root");
        return Ie;
    }
    const _ = (0, o.Field)(u.p, void 0, void 0, {
        sqrt: y
    });
    e.secp256k1 = (0, n.createCurve)({
        ...u,
        Fp: _,
        lowS: !0,
        // Allow only low-S signatures by default in sign() and verify()
        endo: {
            // Endomorphism, see above
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: (E)=>{
                const T = u.n, I = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), P = -c * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), k = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), L = I, j = BigInt("0x100000000000000000000000000000000"), ie = p(L * E, T), ue = p(-P * E, T);
                let ce = (0, o.mod)(E - ie * I - ue * k, T), he = (0, o.mod)(-ie * P - ue * L, T);
                const ee = ce > j, ae = he > j;
                if (ee && (ce = T - ce), ae && (he = T - he), ce > j || he > j) throw new Error("splitScalar: Endomorphism failed, k=" + E);
                return {
                    k1neg: ee,
                    k1: ce,
                    k2neg: ae,
                    k2: he
                };
            }
        }
    }, t.sha256);
    const A = {};
    function O(E, ...T) {
        let I = A[E];
        if (I === void 0) {
            const P = (0, t.sha256)(Uint8Array.from(E, (k)=>k.charCodeAt(0)));
            I = (0, a.concatBytes)(P, P), A[E] = I;
        }
        return (0, t.sha256)((0, a.concatBytes)(I, ...T));
    }
    const N = (E)=>E.toBytes(!0).slice(1), U = (E)=>(0, a.numberToBytesBE)(E, 32), D = (E)=>(0, o.mod)(E, u.p), H = (E)=>(0, o.mod)(E, u.n), K = e.secp256k1.Point, re = (E)=>E % l === f;
    function Q(E) {
        let T = e.secp256k1.utils.normPrivateKeyToScalar(E), I = K.fromPrivateKey(T);
        return {
            scalar: re(I.y) ? T : H(-T),
            bytes: N(I)
        };
    }
    function G(E) {
        (0, a.aInRange)("x", E, c, u.p);
        const T = D(E * E), I = D(T * E + BigInt(7));
        let P = y(I);
        re(P) || (P = D(-P));
        const k = K.fromAffine({
            x: E,
            y: P
        });
        return k.assertValidity(), k;
    }
    const R = a.bytesToNumberBE;
    function X(...E) {
        return H(R(O("BIP0340/challenge", ...E)));
    }
    function $(E) {
        return Q(E).bytes;
    }
    function S(E, T, I = (0, r.randomBytes)(32)) {
        const P = (0, a.ensureBytes)("message", E), { bytes: k, scalar: L } = Q(T), j = (0, a.ensureBytes)("auxRand", I, 32), ie = U(L ^ R(O("BIP0340/aux", j))), ue = O("BIP0340/nonce", ie, k, P), ce = H(R(ue));
        if (ce === f) throw new Error("sign failed: k is zero");
        const { bytes: he, scalar: ee } = Q(ce), ae = X(he, k, P), ye = new Uint8Array(64);
        if (ye.set(he, 0), ye.set(U(H(ee + ae * L)), 32), !w(ye, P, k)) throw new Error("sign: Invalid signature produced");
        return ye;
    }
    function w(E, T, I) {
        const P = (0, a.ensureBytes)("signature", E, 64), k = (0, a.ensureBytes)("message", T), L = (0, a.ensureBytes)("publicKey", I, 32);
        try {
            const j = G(R(L)), ie = R(P.subarray(0, 32));
            if (!(0, a.inRange)(ie, c, u.p)) return !1;
            const ue = R(P.subarray(32, 64));
            if (!(0, a.inRange)(ue, c, u.n)) return !1;
            const ce = X(U(ie), N(j), k), he = K.BASE.multiplyUnsafe(ue).add(j.multiplyUnsafe(H(-ce))), { x: ee, y: ae } = he.toAffine();
            return !(he.is0() || !re(ae) || ee !== ie);
        } catch  {
            return !1;
        }
    }
    e.schnorr = {
        getPublicKey: $,
        sign: S,
        verify: w,
        utils: {
            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
            lift_x: G,
            pointToBytes: N,
            numberToBytesBE: a.numberToBytesBE,
            bytesToNumberBE: a.bytesToNumberBE,
            taggedHash: O,
            mod: o.mod
        }
    };
    const g = (0, i.isogenyMap)(_, [
        // xNum
        [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        // yNum
        [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
    ].map((E)=>E.map((T)=>BigInt(T)))), m = (0, s.mapToCurveSimpleSWU)(_, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: _.create(BigInt("-11"))
    });
    e.secp256k1_hasher = (0, i.createHasher)(e.secp256k1.Point, (E)=>{
        const { x: T, y: I } = m(_.create(E[0]));
        return g(T, I);
    }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: _.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: t.sha256
    }), e.hashToCurve = e.secp256k1_hasher.hashToCurve, e.encodeToCurve = e.secp256k1_hasher.encodeToCurve;
})(p3);
var q9 = {};
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Mf, e);
})(q9);
var mi = p3, nZ = sn, iZ = q9;
function K9(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
        if (r !== "default") {
            var n = Object.getOwnPropertyDescriptor(e, r);
            Object.defineProperty(t, r, n.get ? n : {
                enumerable: !0,
                get: function() {
                    return e[r];
                }
            });
        }
    }), t.default = e, Object.freeze(t);
}
var W9 = /* @__PURE__ */ K9(nZ), gu = /* @__PURE__ */ K9(iZ);
const x3 = mi.secp256k1.ProjectivePoint, Au = "Expected Private", Tu = "Expected Point", e0 = "Expected Tweak", oZ = "Expected Hash", Lh = "Expected Signature", S3 = "Expected Extra Data (32 bytes)", t0 = "Expected Scalar", sZ = "Bad Recovery Id", aZ = 32, cZ = 32, $E = new Uint8Array([
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    254,
    186,
    174,
    220,
    230,
    175,
    72,
    160,
    59,
    191,
    210,
    94,
    140,
    208,
    54,
    65,
    65
]), uZ = 32, fZ = new Uint8Array(32), lZ = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    69,
    81,
    35,
    25,
    80,
    183,
    95,
    196,
    64,
    45,
    161,
    114,
    47,
    201,
    186,
    238
]), dZ = BigInt(1);
function hZ(e) {
    return e instanceof Uint8Array;
}
function ap(e, t) {
    for(let r = 0; r < 32; ++r)if (e[r] !== t[r]) return e[r] < t[r] ? -1 : 1;
    return 0;
}
function mA(e) {
    return ap(e, fZ) === 0;
}
function r0(e) {
    return !(!(e instanceof Uint8Array) || e.length !== cZ || ap(e, $E) >= 0);
}
function A3(e) {
    return e instanceof Uint8Array && e.length === 64 && ap(e.subarray(0, 32), $E) < 0 && ap(e.subarray(32, 64), $E) < 0;
}
function pZ(e) {
    return hZ(e) && e.length === 64 && ap(e.subarray(0, 32), lZ) < 0;
}
function gZ(e) {
    return !(mA(e.subarray(0, 32)) || mA(e.subarray(32, 64)));
}
function Sd(e) {
    return e instanceof Uint8Array && e.length === aZ;
}
function T3(e) {
    return e === void 0 || e instanceof Uint8Array && e.length === uZ;
}
function k3(e) {
    let t;
    if (typeof e == "bigint") t = e;
    else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0) t = BigInt(e);
    else if (typeof e == "string") {
        if (e.length !== 64) throw new Error("Expected 32 bytes of private scalar");
        t = gu.hexToNumber(e);
    } else if (e instanceof Uint8Array) {
        if (e.length !== 32) throw new Error("Expected 32 bytes of private scalar");
        t = gu.bytesToNumberBE(e);
    } else throw new TypeError("Expected valid private scalar");
    if (t < 0) throw new Error("Expected private scalar >= 0");
    return t;
}
function I3(e) {
    return mi.secp256k1.utils.normPrivateKeyToScalar(e);
}
function yZ(e, t) {
    const r = I3(e), n = k3(t), i = gu.numberToBytesBE(W9.mod(r + n, mi.secp256k1.CURVE.n), 32);
    return mi.secp256k1.utils.isValidPrivateKey(i) ? i : null;
}
function mZ(e, t) {
    const r = I3(e), n = k3(t), i = gu.numberToBytesBE(W9.mod(r - n, mi.secp256k1.CURVE.n), 32);
    return mi.secp256k1.utils.isValidPrivateKey(i) ? i : null;
}
function bZ(e) {
    const t = I3(e), r = gu.numberToBytesBE(mi.secp256k1.CURVE.n - t, 32);
    return mi.secp256k1.utils.isValidPrivateKey(r) ? r : null;
}
function V9(e, t, r) {
    const n = cp(e), i = k3(t), o = x3.BASE.multiplyAndAddUnsafe(n, i, dZ);
    if (!o) throw new Error("Tweaked point at infinity");
    return o.toRawBytes(r);
}
function wZ(e, t, r) {
    const n = cp(e), i = typeof t == "string" ? t : gu.bytesToHex(t), o = gu.hexToNumber(i);
    return n.multiply(o).toRawBytes(r);
}
function Ad(e, t) {
    return e === void 0 ? t !== void 0 ? Z9(t) : !0 : !!e;
}
function Cf(e) {
    try {
        return e();
    } catch  {
        return null;
    }
}
function G9(e) {
    return mi.schnorr.utils.lift_x(gu.bytesToNumberBE(e));
}
function cp(e) {
    return e.length === 32 ? G9(e) : x3.fromHex(e);
}
function B3(e, t) {
    if (e.length === 32 !== t) return !1;
    try {
        return t ? !!G9(e) : !!x3.fromHex(e);
    } catch  {
        return !1;
    }
}
function yu(e) {
    return B3(e, !1);
}
function Z9(e) {
    return B3(e, !1) && e.length === 33;
}
function gc(e) {
    return mi.secp256k1.utils.isValidPrivateKey(e);
}
function mb(e) {
    return B3(e, !0);
}
function vZ(e, t) {
    if (!mb(e)) throw new Error(Tu);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>{
        const r = V9(e, t, !0);
        return {
            parity: r[0] % 2 === 1 ? 1 : 0,
            xOnlyPubkey: r.slice(1)
        };
    });
}
function Y9(e) {
    if (!yu(e)) throw new Error(Tu);
    return e.slice(1, 33);
}
function X9(e, t) {
    if (!gc(e)) throw new Error(Au);
    return Cf(()=>mi.secp256k1.getPublicKey(e, Ad(t)));
}
function _Z(e) {
    if (!gc(e)) throw new Error(Au);
    return Y9(X9(e));
}
function EZ(e, t) {
    if (!yu(e)) throw new Error(Tu);
    return cp(e).toRawBytes(Ad(t, e));
}
function xZ(e, t, r) {
    if (!yu(e)) throw new Error(Tu);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>wZ(e, t, Ad(r, e)));
}
function SZ(e, t, r) {
    if (!yu(e) || !yu(t)) throw new Error(Tu);
    return Cf(()=>{
        const n = cp(e), i = cp(t);
        return n.equals(i.negate()) ? null : n.add(i).toRawBytes(Ad(r, e));
    });
}
function AZ(e, t, r) {
    if (!yu(e)) throw new Error(Tu);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>V9(e, t, Ad(r, e)));
}
function TZ(e, t) {
    if (!gc(e)) throw new Error(Au);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>yZ(e, t));
}
function kZ(e, t) {
    if (!gc(e)) throw new Error(Au);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>mZ(e, t));
}
function IZ(e) {
    if (!gc(e)) throw new Error(Au);
    return bZ(e);
}
function BZ(e, t, r) {
    if (!gc(t)) throw new Error(Au);
    if (!Sd(e)) throw new Error(t0);
    if (!T3(r)) throw new Error(S3);
    return mi.secp256k1.sign(e, t, {
        extraEntropy: r
    }).toCompactRawBytes();
}
function OZ(e, t, r) {
    if (!gc(t)) throw new Error(Au);
    if (!Sd(e)) throw new Error(t0);
    if (!T3(r)) throw new Error(S3);
    const n = mi.secp256k1.sign(e, t, {
        extraEntropy: r
    });
    return {
        signature: n.toCompactRawBytes(),
        recoveryId: n.recovery
    };
}
function PZ(e, t, r) {
    if (!gc(t)) throw new Error(Au);
    if (!Sd(e)) throw new Error(t0);
    if (!T3(r)) throw new Error(S3);
    return mi.schnorr.sign(e, t, r);
}
function NZ(e, t, r, n) {
    if (!Sd(e)) throw new Error(oZ);
    if (!A3(t) || !gZ(t)) throw new Error(Lh);
    if (r & 2 && !pZ(t)) throw new Error(sZ);
    if (!mb(t.subarray(0, 32))) throw new Error(Lh);
    const o = mi.secp256k1.Signature.fromCompact(t).addRecoveryBit(r).recoverPublicKey(e);
    if (!o) throw new Error(Lh);
    return o.toRawBytes(Ad(n));
}
function MZ(e, t, r, n) {
    if (!yu(t)) throw new Error(Tu);
    if (!A3(r)) throw new Error(Lh);
    if (!Sd(e)) throw new Error(t0);
    return mi.secp256k1.verify(r, e, t, {
        lowS: n
    });
}
function RZ(e, t, r) {
    if (!mb(t)) throw new Error(Tu);
    if (!A3(r)) throw new Error(Lh);
    if (!Sd(e)) throw new Error(t0);
    return mi.schnorr.verify(r, e, t);
}
var CZ = In.isPoint = yu, UZ = In.isPointCompressed = Z9, $Z = In.isPrivate = gc, LZ = In.isXOnlyPoint = mb, DZ = In.pointAdd = SZ, FZ = In.pointAddScalar = AZ, zZ = In.pointCompress = EZ, jZ = In.pointFromScalar = X9, HZ = In.pointMultiply = xZ, qZ = In.privateAdd = TZ, KZ = In.privateNegate = IZ, WZ = In.privateSub = kZ, VZ = In.recover = NZ, GZ = In.sign = BZ, ZZ = In.signRecoverable = OZ, YZ = In.signSchnorr = PZ, XZ = In.verify = MZ, JZ = In.verifySchnorr = RZ, QZ = In.xOnlyPointAddTweak = vZ, eY = In.xOnlyPointFromPoint = Y9, tY = In.xOnlyPointFromScalar = _Z;
const bb = /* @__PURE__ */ UH({
    __proto__: null,
    default: In,
    isPoint: CZ,
    isPointCompressed: UZ,
    isPrivate: $Z,
    isXOnlyPoint: LZ,
    pointAdd: DZ,
    pointAddScalar: FZ,
    pointCompress: zZ,
    pointFromScalar: jZ,
    pointMultiply: HZ,
    privateAdd: qZ,
    privateNegate: KZ,
    privateSub: WZ,
    recover: VZ,
    sign: GZ,
    signRecoverable: ZZ,
    signSchnorr: YZ,
    verify: XZ,
    verifySchnorr: JZ,
    xOnlyPointAddTweak: QZ,
    xOnlyPointFromPoint: eY,
    xOnlyPointFromScalar: tY
}, [
    In
]);
var Lo = {}, td = {}, ji = {}, Td = {};
Td.byteLength = iY;
Td.toByteArray = sY;
Td.fromByteArray = uY;
var pa = [], os = [], rY = typeof Uint8Array < "u" ? Uint8Array : Array, ov = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var dl = 0, nY = ov.length; dl < nY; ++dl)pa[dl] = ov[dl], os[ov.charCodeAt(dl)] = dl;
os[45] = 62;
os[95] = 63;
function J9(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [
        r,
        n
    ];
}
function iY(e) {
    var t = J9(e), r = t[0], n = t[1];
    return (r + n) * 3 / 4 - n;
}
function oY(e, t, r) {
    return (t + r) * 3 / 4 - r;
}
function sY(e) {
    var t, r = J9(e), n = r[0], i = r[1], o = new rY(oY(e, n, i)), s = 0, a = i > 0 ? n - 4 : n, u;
    for(u = 0; u < a; u += 4)t = os[e.charCodeAt(u)] << 18 | os[e.charCodeAt(u + 1)] << 12 | os[e.charCodeAt(u + 2)] << 6 | os[e.charCodeAt(u + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
    return i === 2 && (t = os[e.charCodeAt(u)] << 2 | os[e.charCodeAt(u + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = os[e.charCodeAt(u)] << 10 | os[e.charCodeAt(u + 1)] << 4 | os[e.charCodeAt(u + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function aY(e) {
    return pa[e >> 18 & 63] + pa[e >> 12 & 63] + pa[e >> 6 & 63] + pa[e & 63];
}
function cY(e, t, r) {
    for(var n, i = [], o = t; o < r; o += 3)n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(aY(n));
    return i.join("");
}
function uY(e) {
    for(var t, r = e.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)i.push(cY(e, s, s + o > a ? a : s + o));
    return n === 1 ? (t = e[r - 1], i.push(pa[t >> 2] + pa[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(pa[t >> 10] + pa[t >> 4 & 63] + pa[t << 2 & 63] + "=")), i.join("");
}
Object.defineProperty(ji, "__esModule", {
    value: !0
});
ji.decode = ji.encode = ji.unescape = ji.escape = ji.pad = void 0;
const Q9 = Td;
function O3(e) {
    return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
ji.pad = O3;
function eO(e) {
    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
ji.escape = eO;
function tO(e) {
    return O3(e).replace(/-/g, "+").replace(/_/g, "/");
}
ji.unescape = tO;
function fY(e) {
    return eO((0, Q9.fromByteArray)(new TextEncoder().encode(e)));
}
ji.encode = fY;
function lY(e) {
    return new TextDecoder().decode((0, Q9.toByteArray)(O3(tO(e))));
}
ji.decode = lY;
var wb = {}, vb = {}, us = {};
Object.defineProperty(us, "__esModule", {
    value: !0
});
us.sha224 = us.SHA224 = us.sha256 = us.SHA256 = void 0;
const _b = en;
us.SHA256 = _b.SHA256;
us.sha256 = _b.sha256;
us.SHA224 = _b.SHA224;
us.sha224 = _b.sha224;
var rO = {}, gr = {}, Mg = {
    exports: {}
}, Rg = {
    exports: {}
}, ku = {}, P3 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ P3.read = function(e, t, r, n, i) {
    var o, s, a = i * 8 - n - 1, u = (1 << a) - 1, f = u >> 1, c = -7, l = r ? i - 1 : 0, p = r ? -1 : 1, y = e[t + l];
    for(l += p, o = y & (1 << -c) - 1, y >>= -c, c += a; c > 0; o = o * 256 + e[t + l], l += p, c -= 8);
    for(s = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; s = s * 256 + e[t + l], l += p, c -= 8);
    if (o === 0) o = 1 - f;
    else {
        if (o === u) return s ? NaN : (y ? -1 : 1) * (1 / 0);
        s = s + Math.pow(2, n), o = o - f;
    }
    return (y ? -1 : 1) * s * Math.pow(2, o - n);
};
P3.write = function(e, t, r, n, i, o) {
    var s, a, u, f = o * 8 - i - 1, c = (1 << f) - 1, l = c >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, _ = n ? 1 : -1, A = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + l >= 1 ? t += p / u : t += p * Math.pow(2, 1 - l), t * u >= 2 && (s++, u /= 2), s + l >= c ? (a = 0, s = c) : s + l >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s = s + l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + y] = a & 255, y += _, a /= 256, i -= 8);
    for(s = s << i | a, f += i; f > 0; e[r + y] = s & 255, y += _, s /= 256, f -= 8);
    e[r + y - _] |= A * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(e) {
    const t = Td, r = P3, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = a, e.SlowBuffer = U, e.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    e.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function o() {
        try {
            const ne = new Uint8Array(1), W = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(W, Uint8Array.prototype), Object.setPrototypeOf(ne, W), ne.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.byteOffset;
        }
    });
    function s(ne) {
        if (ne > i) throw new RangeError('The value "' + ne + '" is invalid for option "size"');
        const W = new Uint8Array(ne);
        return Object.setPrototypeOf(W, a.prototype), W;
    }
    function a(ne, W, J) {
        if (typeof ne == "number") {
            if (typeof W == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return l(ne);
        }
        return u(ne, W, J);
    }
    a.poolSize = 8192;
    function u(ne, W, J) {
        if (typeof ne == "string") return p(ne, W);
        if (ArrayBuffer.isView(ne)) return _(ne);
        if (ne == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne);
        if (h(ne, ArrayBuffer) || ne && h(ne.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (h(ne, SharedArrayBuffer) || ne && h(ne.buffer, SharedArrayBuffer))) return A(ne, W, J);
        if (typeof ne == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const V = ne.valueOf && ne.valueOf();
        if (V != null && V !== ne) return a.from(V, W, J);
        const C = O(ne);
        if (C) return C;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ne[Symbol.toPrimitive] == "function") return a.from(ne[Symbol.toPrimitive]("string"), W, J);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne);
    }
    a.from = function(ne, W, J) {
        return u(ne, W, J);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function f(ne) {
        if (typeof ne != "number") throw new TypeError('"size" argument must be of type number');
        if (ne < 0) throw new RangeError('The value "' + ne + '" is invalid for option "size"');
    }
    function c(ne, W, J) {
        return f(ne), ne <= 0 ? s(ne) : W !== void 0 ? typeof J == "string" ? s(ne).fill(W, J) : s(ne).fill(W) : s(ne);
    }
    a.alloc = function(ne, W, J) {
        return c(ne, W, J);
    };
    function l(ne) {
        return f(ne), s(ne < 0 ? 0 : N(ne) | 0);
    }
    a.allocUnsafe = function(ne) {
        return l(ne);
    }, a.allocUnsafeSlow = function(ne) {
        return l(ne);
    };
    function p(ne, W) {
        if ((typeof W != "string" || W === "") && (W = "utf8"), !a.isEncoding(W)) throw new TypeError("Unknown encoding: " + W);
        const J = D(ne, W) | 0;
        let V = s(J);
        const C = V.write(ne, W);
        return C !== J && (V = V.slice(0, C)), V;
    }
    function y(ne) {
        const W = ne.length < 0 ? 0 : N(ne.length) | 0, J = s(W);
        for(let V = 0; V < W; V += 1)J[V] = ne[V] & 255;
        return J;
    }
    function _(ne) {
        if (h(ne, Uint8Array)) {
            const W = new Uint8Array(ne);
            return A(W.buffer, W.byteOffset, W.byteLength);
        }
        return y(ne);
    }
    function A(ne, W, J) {
        if (W < 0 || ne.byteLength < W) throw new RangeError('"offset" is outside of buffer bounds');
        if (ne.byteLength < W + (J || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let V;
        return W === void 0 && J === void 0 ? V = new Uint8Array(ne) : J === void 0 ? V = new Uint8Array(ne, W) : V = new Uint8Array(ne, W, J), Object.setPrototypeOf(V, a.prototype), V;
    }
    function O(ne) {
        if (a.isBuffer(ne)) {
            const W = N(ne.length) | 0, J = s(W);
            return J.length === 0 || ne.copy(J, 0, 0, W), J;
        }
        if (ne.length !== void 0) return typeof ne.length != "number" || x(ne.length) ? s(0) : y(ne);
        if (ne.type === "Buffer" && Array.isArray(ne.data)) return y(ne.data);
    }
    function N(ne) {
        if (ne >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return ne | 0;
    }
    function U(ne) {
        return +ne != ne && (ne = 0), a.alloc(+ne);
    }
    a.isBuffer = function(W) {
        return W != null && W._isBuffer === !0 && W !== a.prototype;
    }, a.compare = function(W, J) {
        if (h(W, Uint8Array) && (W = a.from(W, W.offset, W.byteLength)), h(J, Uint8Array) && (J = a.from(J, J.offset, J.byteLength)), !a.isBuffer(W) || !a.isBuffer(J)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (W === J) return 0;
        let V = W.length, C = J.length;
        for(let Z = 0, le = Math.min(V, C); Z < le; ++Z)if (W[Z] !== J[Z]) {
            V = W[Z], C = J[Z];
            break;
        }
        return V < C ? -1 : C < V ? 1 : 0;
    }, a.isEncoding = function(W) {
        switch(String(W).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, a.concat = function(W, J) {
        if (!Array.isArray(W)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (W.length === 0) return a.alloc(0);
        let V;
        if (J === void 0) for(J = 0, V = 0; V < W.length; ++V)J += W[V].length;
        const C = a.allocUnsafe(J);
        let Z = 0;
        for(V = 0; V < W.length; ++V){
            let le = W[V];
            if (h(le, Uint8Array)) Z + le.length > C.length ? (a.isBuffer(le) || (le = a.from(le)), le.copy(C, Z)) : Uint8Array.prototype.set.call(C, le, Z);
            else if (a.isBuffer(le)) le.copy(C, Z);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            Z += le.length;
        }
        return C;
    };
    function D(ne, W) {
        if (a.isBuffer(ne)) return ne.length;
        if (ArrayBuffer.isView(ne) || h(ne, ArrayBuffer)) return ne.byteLength;
        if (typeof ne != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ne);
        const J = ne.length, V = arguments.length > 2 && arguments[2] === !0;
        if (!V && J === 0) return 0;
        let C = !1;
        for(;;)switch(W){
            case "ascii":
            case "latin1":
            case "binary":
                return J;
            case "utf8":
            case "utf-8":
                return _e(ne).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return J * 2;
            case "hex":
                return J >>> 1;
            case "base64":
                return Ke(ne).length;
            default:
                if (C) return V ? -1 : _e(ne).length;
                W = ("" + W).toLowerCase(), C = !0;
        }
    }
    a.byteLength = D;
    function H(ne, W, J) {
        let V = !1;
        if ((W === void 0 || W < 0) && (W = 0), W > this.length || ((J === void 0 || J > this.length) && (J = this.length), J <= 0) || (J >>>= 0, W >>>= 0, J <= W)) return "";
        for(ne || (ne = "utf8");;)switch(ne){
            case "hex":
                return P(this, W, J);
            case "utf8":
            case "utf-8":
                return g(this, W, J);
            case "ascii":
                return T(this, W, J);
            case "latin1":
            case "binary":
                return I(this, W, J);
            case "base64":
                return w(this, W, J);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return k(this, W, J);
            default:
                if (V) throw new TypeError("Unknown encoding: " + ne);
                ne = (ne + "").toLowerCase(), V = !0;
        }
    }
    a.prototype._isBuffer = !0;
    function K(ne, W, J) {
        const V = ne[W];
        ne[W] = ne[J], ne[J] = V;
    }
    a.prototype.swap16 = function() {
        const W = this.length;
        if (W % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let J = 0; J < W; J += 2)K(this, J, J + 1);
        return this;
    }, a.prototype.swap32 = function() {
        const W = this.length;
        if (W % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let J = 0; J < W; J += 4)K(this, J, J + 3), K(this, J + 1, J + 2);
        return this;
    }, a.prototype.swap64 = function() {
        const W = this.length;
        if (W % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let J = 0; J < W; J += 8)K(this, J, J + 7), K(this, J + 1, J + 6), K(this, J + 2, J + 5), K(this, J + 3, J + 4);
        return this;
    }, a.prototype.toString = function() {
        const W = this.length;
        return W === 0 ? "" : arguments.length === 0 ? g(this, 0, W) : H.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(W) {
        if (!a.isBuffer(W)) throw new TypeError("Argument must be a Buffer");
        return this === W ? !0 : a.compare(this, W) === 0;
    }, a.prototype.inspect = function() {
        let W = "";
        const J = e.INSPECT_MAX_BYTES;
        return W = this.toString("hex", 0, J).replace(/(.{2})/g, "$1 ").trim(), this.length > J && (W += " ... "), "<Buffer " + W + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(W, J, V, C, Z) {
        if (h(W, Uint8Array) && (W = a.from(W, W.offset, W.byteLength)), !a.isBuffer(W)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof W);
        if (J === void 0 && (J = 0), V === void 0 && (V = W ? W.length : 0), C === void 0 && (C = 0), Z === void 0 && (Z = this.length), J < 0 || V > W.length || C < 0 || Z > this.length) throw new RangeError("out of range index");
        if (C >= Z && J >= V) return 0;
        if (C >= Z) return -1;
        if (J >= V) return 1;
        if (J >>>= 0, V >>>= 0, C >>>= 0, Z >>>= 0, this === W) return 0;
        let le = Z - C, se = V - J;
        const Ne = Math.min(le, se), Le = this.slice(C, Z), rt = W.slice(J, V);
        for(let yt = 0; yt < Ne; ++yt)if (Le[yt] !== rt[yt]) {
            le = Le[yt], se = rt[yt];
            break;
        }
        return le < se ? -1 : se < le ? 1 : 0;
    };
    function re(ne, W, J, V, C) {
        if (ne.length === 0) return -1;
        if (typeof J == "string" ? (V = J, J = 0) : J > 2147483647 ? J = 2147483647 : J < -2147483648 && (J = -2147483648), J = +J, x(J) && (J = C ? 0 : ne.length - 1), J < 0 && (J = ne.length + J), J >= ne.length) {
            if (C) return -1;
            J = ne.length - 1;
        } else if (J < 0) if (C) J = 0;
        else return -1;
        if (typeof W == "string" && (W = a.from(W, V)), a.isBuffer(W)) return W.length === 0 ? -1 : Q(ne, W, J, V, C);
        if (typeof W == "number") return W = W & 255, typeof Uint8Array.prototype.indexOf == "function" ? C ? Uint8Array.prototype.indexOf.call(ne, W, J) : Uint8Array.prototype.lastIndexOf.call(ne, W, J) : Q(ne, [
            W
        ], J, V, C);
        throw new TypeError("val must be string, number or Buffer");
    }
    function Q(ne, W, J, V, C) {
        let Z = 1, le = ne.length, se = W.length;
        if (V !== void 0 && (V = String(V).toLowerCase(), V === "ucs2" || V === "ucs-2" || V === "utf16le" || V === "utf-16le")) {
            if (ne.length < 2 || W.length < 2) return -1;
            Z = 2, le /= 2, se /= 2, J /= 2;
        }
        function Ne(rt, yt) {
            return Z === 1 ? rt[yt] : rt.readUInt16BE(yt * Z);
        }
        let Le;
        if (C) {
            let rt = -1;
            for(Le = J; Le < le; Le++)if (Ne(ne, Le) === Ne(W, rt === -1 ? 0 : Le - rt)) {
                if (rt === -1 && (rt = Le), Le - rt + 1 === se) return rt * Z;
            } else rt !== -1 && (Le -= Le - rt), rt = -1;
        } else for(J + se > le && (J = le - se), Le = J; Le >= 0; Le--){
            let rt = !0;
            for(let yt = 0; yt < se; yt++)if (Ne(ne, Le + yt) !== Ne(W, yt)) {
                rt = !1;
                break;
            }
            if (rt) return Le;
        }
        return -1;
    }
    a.prototype.includes = function(W, J, V) {
        return this.indexOf(W, J, V) !== -1;
    }, a.prototype.indexOf = function(W, J, V) {
        return re(this, W, J, V, !0);
    }, a.prototype.lastIndexOf = function(W, J, V) {
        return re(this, W, J, V, !1);
    };
    function G(ne, W, J, V) {
        J = Number(J) || 0;
        const C = ne.length - J;
        V ? (V = Number(V), V > C && (V = C)) : V = C;
        const Z = W.length;
        V > Z / 2 && (V = Z / 2);
        let le;
        for(le = 0; le < V; ++le){
            const se = parseInt(W.substr(le * 2, 2), 16);
            if (x(se)) return le;
            ne[J + le] = se;
        }
        return le;
    }
    function R(ne, W, J, V) {
        return Ue(_e(W, ne.length - J), ne, J, V);
    }
    function X(ne, W, J, V) {
        return Ue(Ie(W), ne, J, V);
    }
    function $(ne, W, J, V) {
        return Ue(Ke(W), ne, J, V);
    }
    function S(ne, W, J, V) {
        return Ue(je(W, ne.length - J), ne, J, V);
    }
    a.prototype.write = function(W, J, V, C) {
        if (J === void 0) C = "utf8", V = this.length, J = 0;
        else if (V === void 0 && typeof J == "string") C = J, V = this.length, J = 0;
        else if (isFinite(J)) J = J >>> 0, isFinite(V) ? (V = V >>> 0, C === void 0 && (C = "utf8")) : (C = V, V = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Z = this.length - J;
        if ((V === void 0 || V > Z) && (V = Z), W.length > 0 && (V < 0 || J < 0) || J > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        C || (C = "utf8");
        let le = !1;
        for(;;)switch(C){
            case "hex":
                return G(this, W, J, V);
            case "utf8":
            case "utf-8":
                return R(this, W, J, V);
            case "ascii":
            case "latin1":
            case "binary":
                return X(this, W, J, V);
            case "base64":
                return $(this, W, J, V);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return S(this, W, J, V);
            default:
                if (le) throw new TypeError("Unknown encoding: " + C);
                C = ("" + C).toLowerCase(), le = !0;
        }
    }, a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function w(ne, W, J) {
        return W === 0 && J === ne.length ? t.fromByteArray(ne) : t.fromByteArray(ne.slice(W, J));
    }
    function g(ne, W, J) {
        J = Math.min(ne.length, J);
        const V = [];
        let C = W;
        for(; C < J;){
            const Z = ne[C];
            let le = null, se = Z > 239 ? 4 : Z > 223 ? 3 : Z > 191 ? 2 : 1;
            if (C + se <= J) {
                let Ne, Le, rt, yt;
                switch(se){
                    case 1:
                        Z < 128 && (le = Z);
                        break;
                    case 2:
                        Ne = ne[C + 1], (Ne & 192) === 128 && (yt = (Z & 31) << 6 | Ne & 63, yt > 127 && (le = yt));
                        break;
                    case 3:
                        Ne = ne[C + 1], Le = ne[C + 2], (Ne & 192) === 128 && (Le & 192) === 128 && (yt = (Z & 15) << 12 | (Ne & 63) << 6 | Le & 63, yt > 2047 && (yt < 55296 || yt > 57343) && (le = yt));
                        break;
                    case 4:
                        Ne = ne[C + 1], Le = ne[C + 2], rt = ne[C + 3], (Ne & 192) === 128 && (Le & 192) === 128 && (rt & 192) === 128 && (yt = (Z & 15) << 18 | (Ne & 63) << 12 | (Le & 63) << 6 | rt & 63, yt > 65535 && yt < 1114112 && (le = yt));
                }
            }
            le === null ? (le = 65533, se = 1) : le > 65535 && (le -= 65536, V.push(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), V.push(le), C += se;
        }
        return E(V);
    }
    const m = 4096;
    function E(ne) {
        const W = ne.length;
        if (W <= m) return String.fromCharCode.apply(String, ne);
        let J = "", V = 0;
        for(; V < W;)J += String.fromCharCode.apply(String, ne.slice(V, V += m));
        return J;
    }
    function T(ne, W, J) {
        let V = "";
        J = Math.min(ne.length, J);
        for(let C = W; C < J; ++C)V += String.fromCharCode(ne[C] & 127);
        return V;
    }
    function I(ne, W, J) {
        let V = "";
        J = Math.min(ne.length, J);
        for(let C = W; C < J; ++C)V += String.fromCharCode(ne[C]);
        return V;
    }
    function P(ne, W, J) {
        const V = ne.length;
        (!W || W < 0) && (W = 0), (!J || J < 0 || J > V) && (J = V);
        let C = "";
        for(let Z = W; Z < J; ++Z)C += q[ne[Z]];
        return C;
    }
    function k(ne, W, J) {
        const V = ne.slice(W, J);
        let C = "";
        for(let Z = 0; Z < V.length - 1; Z += 2)C += String.fromCharCode(V[Z] + V[Z + 1] * 256);
        return C;
    }
    a.prototype.slice = function(W, J) {
        const V = this.length;
        W = ~~W, J = J === void 0 ? V : ~~J, W < 0 ? (W += V, W < 0 && (W = 0)) : W > V && (W = V), J < 0 ? (J += V, J < 0 && (J = 0)) : J > V && (J = V), J < W && (J = W);
        const C = this.subarray(W, J);
        return Object.setPrototypeOf(C, a.prototype), C;
    };
    function L(ne, W, J) {
        if (ne % 1 !== 0 || ne < 0) throw new RangeError("offset is not uint");
        if (ne + W > J) throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = this[W], Z = 1, le = 0;
        for(; ++le < J && (Z *= 256);)C += this[W + le] * Z;
        return C;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = this[W + --J], Z = 1;
        for(; J > 0 && (Z *= 256);)C += this[W + --J] * Z;
        return C;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(W, J) {
        return W = W >>> 0, J || L(W, 1, this.length), this[W];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(W, J) {
        return W = W >>> 0, J || L(W, 2, this.length), this[W] | this[W + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(W, J) {
        return W = W >>> 0, J || L(W, 2, this.length), this[W] << 8 | this[W + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), (this[W] | this[W + 1] << 8 | this[W + 2] << 16) + this[W + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), this[W] * 16777216 + (this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3]);
    }, a.prototype.readBigUInt64LE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = J + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24, Z = this[++W] + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + V * 2 ** 24;
        return BigInt(C) + (BigInt(Z) << BigInt(32));
    }), a.prototype.readBigUInt64BE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = J * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W], Z = this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + V;
        return (BigInt(C) << BigInt(32)) + BigInt(Z);
    }), a.prototype.readIntLE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = this[W], Z = 1, le = 0;
        for(; ++le < J && (Z *= 256);)C += this[W + le] * Z;
        return Z *= 128, C >= Z && (C -= Math.pow(2, 8 * J)), C;
    }, a.prototype.readIntBE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = J, Z = 1, le = this[W + --C];
        for(; C > 0 && (Z *= 256);)le += this[W + --C] * Z;
        return Z *= 128, le >= Z && (le -= Math.pow(2, 8 * J)), le;
    }, a.prototype.readInt8 = function(W, J) {
        return W = W >>> 0, J || L(W, 1, this.length), this[W] & 128 ? (255 - this[W] + 1) * -1 : this[W];
    }, a.prototype.readInt16LE = function(W, J) {
        W = W >>> 0, J || L(W, 2, this.length);
        const V = this[W] | this[W + 1] << 8;
        return V & 32768 ? V | 4294901760 : V;
    }, a.prototype.readInt16BE = function(W, J) {
        W = W >>> 0, J || L(W, 2, this.length);
        const V = this[W + 1] | this[W] << 8;
        return V & 32768 ? V | 4294901760 : V;
    }, a.prototype.readInt32LE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), this[W] | this[W + 1] << 8 | this[W + 2] << 16 | this[W + 3] << 24;
    }, a.prototype.readInt32BE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), this[W] << 24 | this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3];
    }, a.prototype.readBigInt64LE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = this[W + 4] + this[W + 5] * 2 ** 8 + this[W + 6] * 2 ** 16 + (V << 24);
        return (BigInt(C) << BigInt(32)) + BigInt(J + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24);
    }), a.prototype.readBigInt64BE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = (J << 24) + // Overflow
        this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W];
        return (BigInt(C) << BigInt(32)) + BigInt(this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + V);
    }), a.prototype.readFloatLE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), r.read(this, W, !0, 23, 4);
    }, a.prototype.readFloatBE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), r.read(this, W, !1, 23, 4);
    }, a.prototype.readDoubleLE = function(W, J) {
        return W = W >>> 0, J || L(W, 8, this.length), r.read(this, W, !0, 52, 8);
    }, a.prototype.readDoubleBE = function(W, J) {
        return W = W >>> 0, J || L(W, 8, this.length), r.read(this, W, !1, 52, 8);
    };
    function j(ne, W, J, V, C, Z) {
        if (!a.isBuffer(ne)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (W > C || W < Z) throw new RangeError('"value" argument is out of bounds');
        if (J + V > ne.length) throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, V = V >>> 0, !C) {
            const se = Math.pow(2, 8 * V) - 1;
            j(this, W, J, V, se, 0);
        }
        let Z = 1, le = 0;
        for(this[J] = W & 255; ++le < V && (Z *= 256);)this[J + le] = W / Z & 255;
        return J + V;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, V = V >>> 0, !C) {
            const se = Math.pow(2, 8 * V) - 1;
            j(this, W, J, V, se, 0);
        }
        let Z = V - 1, le = 1;
        for(this[J + Z] = W & 255; --Z >= 0 && (le *= 256);)this[J + Z] = W / le & 255;
        return J + V;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 1, 255, 0), this[J] = W & 255, J + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 65535, 0), this[J] = W & 255, this[J + 1] = W >>> 8, J + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 65535, 0), this[J] = W >>> 8, this[J + 1] = W & 255, J + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 4294967295, 0), this[J + 3] = W >>> 24, this[J + 2] = W >>> 16, this[J + 1] = W >>> 8, this[J] = W & 255, J + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 4294967295, 0), this[J] = W >>> 24, this[J + 1] = W >>> 16, this[J + 2] = W >>> 8, this[J + 3] = W & 255, J + 4;
    };
    function ie(ne, W, J, V, C) {
        Re(W, V, C, ne, J, 7);
        let Z = Number(W & BigInt(4294967295));
        ne[J++] = Z, Z = Z >> 8, ne[J++] = Z, Z = Z >> 8, ne[J++] = Z, Z = Z >> 8, ne[J++] = Z;
        let le = Number(W >> BigInt(32) & BigInt(4294967295));
        return ne[J++] = le, le = le >> 8, ne[J++] = le, le = le >> 8, ne[J++] = le, le = le >> 8, ne[J++] = le, J;
    }
    function ue(ne, W, J, V, C) {
        Re(W, V, C, ne, J, 7);
        let Z = Number(W & BigInt(4294967295));
        ne[J + 7] = Z, Z = Z >> 8, ne[J + 6] = Z, Z = Z >> 8, ne[J + 5] = Z, Z = Z >> 8, ne[J + 4] = Z;
        let le = Number(W >> BigInt(32) & BigInt(4294967295));
        return ne[J + 3] = le, le = le >> 8, ne[J + 2] = le, le = le >> 8, ne[J + 1] = le, le = le >> 8, ne[J] = le, J + 8;
    }
    a.prototype.writeBigUInt64LE = te(function(W, J = 0) {
        return ie(this, W, J, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = te(function(W, J = 0) {
        return ue(this, W, J, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, !C) {
            const Ne = Math.pow(2, 8 * V - 1);
            j(this, W, J, V, Ne - 1, -Ne);
        }
        let Z = 0, le = 1, se = 0;
        for(this[J] = W & 255; ++Z < V && (le *= 256);)W < 0 && se === 0 && this[J + Z - 1] !== 0 && (se = 1), this[J + Z] = (W / le >> 0) - se & 255;
        return J + V;
    }, a.prototype.writeIntBE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, !C) {
            const Ne = Math.pow(2, 8 * V - 1);
            j(this, W, J, V, Ne - 1, -Ne);
        }
        let Z = V - 1, le = 1, se = 0;
        for(this[J + Z] = W & 255; --Z >= 0 && (le *= 256);)W < 0 && se === 0 && this[J + Z + 1] !== 0 && (se = 1), this[J + Z] = (W / le >> 0) - se & 255;
        return J + V;
    }, a.prototype.writeInt8 = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 1, 127, -128), W < 0 && (W = 255 + W + 1), this[J] = W & 255, J + 1;
    }, a.prototype.writeInt16LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 32767, -32768), this[J] = W & 255, this[J + 1] = W >>> 8, J + 2;
    }, a.prototype.writeInt16BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 32767, -32768), this[J] = W >>> 8, this[J + 1] = W & 255, J + 2;
    }, a.prototype.writeInt32LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 2147483647, -2147483648), this[J] = W & 255, this[J + 1] = W >>> 8, this[J + 2] = W >>> 16, this[J + 3] = W >>> 24, J + 4;
    }, a.prototype.writeInt32BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 2147483647, -2147483648), W < 0 && (W = 4294967295 + W + 1), this[J] = W >>> 24, this[J + 1] = W >>> 16, this[J + 2] = W >>> 8, this[J + 3] = W & 255, J + 4;
    }, a.prototype.writeBigInt64LE = te(function(W, J = 0) {
        return ie(this, W, J, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = te(function(W, J = 0) {
        return ue(this, W, J, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ce(ne, W, J, V, C, Z) {
        if (J + V > ne.length) throw new RangeError("Index out of range");
        if (J < 0) throw new RangeError("Index out of range");
    }
    function he(ne, W, J, V, C) {
        return W = +W, J = J >>> 0, C || ce(ne, W, J, 4), r.write(ne, W, J, V, 23, 4), J + 4;
    }
    a.prototype.writeFloatLE = function(W, J, V) {
        return he(this, W, J, !0, V);
    }, a.prototype.writeFloatBE = function(W, J, V) {
        return he(this, W, J, !1, V);
    };
    function ee(ne, W, J, V, C) {
        return W = +W, J = J >>> 0, C || ce(ne, W, J, 8), r.write(ne, W, J, V, 52, 8), J + 8;
    }
    a.prototype.writeDoubleLE = function(W, J, V) {
        return ee(this, W, J, !0, V);
    }, a.prototype.writeDoubleBE = function(W, J, V) {
        return ee(this, W, J, !1, V);
    }, a.prototype.copy = function(W, J, V, C) {
        if (!a.isBuffer(W)) throw new TypeError("argument should be a Buffer");
        if (V || (V = 0), !C && C !== 0 && (C = this.length), J >= W.length && (J = W.length), J || (J = 0), C > 0 && C < V && (C = V), C === V || W.length === 0 || this.length === 0) return 0;
        if (J < 0) throw new RangeError("targetStart out of bounds");
        if (V < 0 || V >= this.length) throw new RangeError("Index out of range");
        if (C < 0) throw new RangeError("sourceEnd out of bounds");
        C > this.length && (C = this.length), W.length - J < C - V && (C = W.length - J + V);
        const Z = C - V;
        return this === W && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(J, V, C) : Uint8Array.prototype.set.call(W, this.subarray(V, C), J), Z;
    }, a.prototype.fill = function(W, J, V, C) {
        if (typeof W == "string") {
            if (typeof J == "string" ? (C = J, J = 0, V = this.length) : typeof V == "string" && (C = V, V = this.length), C !== void 0 && typeof C != "string") throw new TypeError("encoding must be a string");
            if (typeof C == "string" && !a.isEncoding(C)) throw new TypeError("Unknown encoding: " + C);
            if (W.length === 1) {
                const le = W.charCodeAt(0);
                (C === "utf8" && le < 128 || C === "latin1") && (W = le);
            }
        } else typeof W == "number" ? W = W & 255 : typeof W == "boolean" && (W = Number(W));
        if (J < 0 || this.length < J || this.length < V) throw new RangeError("Out of range index");
        if (V <= J) return this;
        J = J >>> 0, V = V === void 0 ? this.length : V >>> 0, W || (W = 0);
        let Z;
        if (typeof W == "number") for(Z = J; Z < V; ++Z)this[Z] = W;
        else {
            const le = a.isBuffer(W) ? W : a.from(W, C), se = le.length;
            if (se === 0) throw new TypeError('The value "' + W + '" is invalid for argument "value"');
            for(Z = 0; Z < V - J; ++Z)this[Z + J] = le[Z % se];
        }
        return this;
    };
    const ae = {};
    function ye(ne, W, J) {
        ae[ne] = class extends J {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: W.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${ne}]`, this.stack, delete this.name;
            }
            get code() {
                return ne;
            }
            set code(C) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: C,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${ne}]: ${this.message}`;
            }
        };
    }
    ye("ERR_BUFFER_OUT_OF_BOUNDS", function(ne) {
        return ne ? `${ne} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), ye("ERR_INVALID_ARG_TYPE", function(ne, W) {
        return `The "${ne}" argument must be of type number. Received type ${typeof W}`;
    }, TypeError), ye("ERR_OUT_OF_RANGE", function(ne, W, J) {
        let V = `The value of "${ne}" is out of range.`, C = J;
        return Number.isInteger(J) && Math.abs(J) > 2 ** 32 ? C = Se(String(J)) : typeof J == "bigint" && (C = String(J), (J > BigInt(2) ** BigInt(32) || J < -(BigInt(2) ** BigInt(32))) && (C = Se(C)), C += "n"), V += ` It must be ${W}. Received ${C}`, V;
    }, RangeError);
    function Se(ne) {
        let W = "", J = ne.length;
        const V = ne[0] === "-" ? 1 : 0;
        for(; J >= V + 4; J -= 3)W = `_${ne.slice(J - 3, J)}${W}`;
        return `${ne.slice(0, J)}${W}`;
    }
    function De(ne, W, J) {
        Ce(W, "offset"), (ne[W] === void 0 || ne[W + J] === void 0) && M(W, ne.length - (J + 1));
    }
    function Re(ne, W, J, V, C, Z) {
        if (ne > J || ne < W) {
            const le = typeof W == "bigint" ? "n" : "";
            let se;
            throw W === 0 || W === BigInt(0) ? se = `>= 0${le} and < 2${le} ** ${(Z + 1) * 8}${le}` : se = `>= -(2${le} ** ${(Z + 1) * 8 - 1}${le}) and < 2 ** ${(Z + 1) * 8 - 1}${le}`, new ae.ERR_OUT_OF_RANGE("value", se, ne);
        }
        De(V, C, Z);
    }
    function Ce(ne, W) {
        if (typeof ne != "number") throw new ae.ERR_INVALID_ARG_TYPE(W, "number", ne);
    }
    function M(ne, W, J) {
        throw Math.floor(ne) !== ne ? (Ce(ne, J), new ae.ERR_OUT_OF_RANGE("offset", "an integer", ne)) : W < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS() : new ae.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${W}`, ne);
    }
    const z = /[^+/0-9A-Za-z-_]/g;
    function de(ne) {
        if (ne = ne.split("=")[0], ne = ne.trim().replace(z, ""), ne.length < 2) return "";
        for(; ne.length % 4 !== 0;)ne = ne + "=";
        return ne;
    }
    function _e(ne, W) {
        W = W || 1 / 0;
        let J;
        const V = ne.length;
        let C = null;
        const Z = [];
        for(let le = 0; le < V; ++le){
            if (J = ne.charCodeAt(le), J > 55295 && J < 57344) {
                if (!C) {
                    if (J > 56319) {
                        (W -= 3) > -1 && Z.push(239, 191, 189);
                        continue;
                    } else if (le + 1 === V) {
                        (W -= 3) > -1 && Z.push(239, 191, 189);
                        continue;
                    }
                    C = J;
                    continue;
                }
                if (J < 56320) {
                    (W -= 3) > -1 && Z.push(239, 191, 189), C = J;
                    continue;
                }
                J = (C - 55296 << 10 | J - 56320) + 65536;
            } else C && (W -= 3) > -1 && Z.push(239, 191, 189);
            if (C = null, J < 128) {
                if ((W -= 1) < 0) break;
                Z.push(J);
            } else if (J < 2048) {
                if ((W -= 2) < 0) break;
                Z.push(J >> 6 | 192, J & 63 | 128);
            } else if (J < 65536) {
                if ((W -= 3) < 0) break;
                Z.push(J >> 12 | 224, J >> 6 & 63 | 128, J & 63 | 128);
            } else if (J < 1114112) {
                if ((W -= 4) < 0) break;
                Z.push(J >> 18 | 240, J >> 12 & 63 | 128, J >> 6 & 63 | 128, J & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return Z;
    }
    function Ie(ne) {
        const W = [];
        for(let J = 0; J < ne.length; ++J)W.push(ne.charCodeAt(J) & 255);
        return W;
    }
    function je(ne, W) {
        let J, V, C;
        const Z = [];
        for(let le = 0; le < ne.length && !((W -= 2) < 0); ++le)J = ne.charCodeAt(le), V = J >> 8, C = J % 256, Z.push(C), Z.push(V);
        return Z;
    }
    function Ke(ne) {
        return t.toByteArray(de(ne));
    }
    function Ue(ne, W, J, V) {
        let C;
        for(C = 0; C < V && !(C + J >= W.length || C >= ne.length); ++C)W[C + J] = ne[C];
        return C;
    }
    function h(ne, W) {
        return ne instanceof W || ne != null && ne.constructor != null && ne.constructor.name != null && ne.constructor.name === W.name;
    }
    function x(ne) {
        return ne !== ne;
    }
    const q = function() {
        const ne = "0123456789abcdef", W = new Array(256);
        for(let J = 0; J < 16; ++J){
            const V = J * 16;
            for(let C = 0; C < 16; ++C)W[V + C] = ne[J] + ne[C];
        }
        return W;
    }();
    function te(ne) {
        return typeof BigInt > "u" ? fe : ne;
    }
    function fe() {
        throw new Error("BigInt not supported");
    }
})(ku);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var bA;
function Ar() {
    return bA || (bA = 1, function(e, t) {
        var r = ku, n = r.Buffer;
        function i(s, a) {
            for(var u in s)a[u] = s[u];
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = o);
        function o(s, a, u) {
            return n(s, a, u);
        }
        o.prototype = Object.create(n.prototype), i(n, o), o.from = function(s, a, u) {
            if (typeof s == "number") throw new TypeError("Argument must not be a number");
            return n(s, a, u);
        }, o.alloc = function(s, a, u) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            var f = n(s);
            return a !== void 0 ? typeof u == "string" ? f.fill(a, u) : f.fill(a) : f.fill(0), f;
        }, o.allocUnsafe = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return n(s);
        }, o.allocUnsafeSlow = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return r.SlowBuffer(s);
        };
    }(Rg, Rg.exports)), Rg.exports;
}
var wA;
function kd() {
    if (wA) return Mg.exports;
    wA = 1;
    var e = 65536, t = 4294967295;
    function r() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var n = Ar().Buffer, i = Ge.crypto || Ge.msCrypto;
    i && i.getRandomValues ? Mg.exports = o : Mg.exports = r;
    function o(s, a) {
        if (s > t) throw new RangeError("requested too many random bytes");
        var u = n.allocUnsafe(s);
        if (s > 0) if (s > e) for(var f = 0; f < s; f += e)i.getRandomValues(u.slice(f, f + e));
        else i.getRandomValues(u);
        return typeof a == "function" ? bn.nextTick(function() {
            a(null, u);
        }) : u;
    }
    return Mg.exports;
}
var Cg = {
    exports: {}
}, vA;
function Or() {
    return vA || (vA = 1, typeof Object.create == "function" ? Cg.exports = function(t, r) {
        r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    } : Cg.exports = function(t, r) {
        if (r) {
            t.super_ = r;
            var n = function() {};
            n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
        }
    }), Cg.exports;
}
const dY = {}, hY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: dY
}, Symbol.toStringTag, {
    value: "Module"
})), Iu = /* @__PURE__ */ Jq(hY);
var sv, _A;
function nO() {
    if (_A) return sv;
    _A = 1;
    var e = Ar().Buffer, t = Iu.Transform, r = Or();
    function n(a) {
        t.call(this), this._block = e.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [
            0,
            0,
            0,
            0
        ], this._finalized = !1;
    }
    r(n, t), n.prototype._transform = function(a, u, f) {
        var c = null;
        try {
            this.update(a, u);
        } catch (l) {
            c = l;
        }
        f(c);
    }, n.prototype._flush = function(a) {
        var u = null;
        try {
            this.push(this.digest());
        } catch (f) {
            u = f;
        }
        a(u);
    };
    var i = typeof Uint8Array < "u", o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
    function s(a, u) {
        if (a instanceof e) return a;
        if (typeof a == "string") return e.from(a, u);
        if (o && ArrayBuffer.isView(a)) {
            if (a.byteLength === 0) return e.alloc(0);
            var f = e.from(a.buffer, a.byteOffset, a.byteLength);
            if (f.byteLength === a.byteLength) return f;
        }
        if (i && a instanceof Uint8Array || e.isBuffer(a) && a.constructor && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a)) return e.from(a);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    return n.prototype.update = function(a, u) {
        if (this._finalized) throw new Error("Digest already called");
        a = s(a, u);
        for(var f = this._block, c = 0; this._blockOffset + a.length - c >= this._blockSize;){
            for(var l = this._blockOffset; l < this._blockSize;)f[l++] = a[c++];
            this._update(), this._blockOffset = 0;
        }
        for(; c < a.length;)f[this._blockOffset++] = a[c++];
        for(var p = 0, y = a.length * 8; y > 0; ++p)this._length[p] += y, y = this._length[p] / 4294967296 | 0, y > 0 && (this._length[p] -= 4294967296 * y);
        return this;
    }, n.prototype._update = function() {
        throw new Error("_update is not implemented");
    }, n.prototype.digest = function(a) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = !0;
        var u = this._digest();
        a !== void 0 && (u = u.toString(a)), this._block.fill(0), this._blockOffset = 0;
        for(var f = 0; f < 4; ++f)this._length[f] = 0;
        return u;
    }, n.prototype._digest = function() {
        throw new Error("_digest is not implemented");
    }, sv = n, sv;
}
var av, EA;
function N3() {
    if (EA) return av;
    EA = 1;
    var e = Or(), t = nO(), r = Ar().Buffer, n = new Array(16);
    function i() {
        t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    e(i, t), i.prototype._update = function() {
        for(var c = n, l = 0; l < 16; ++l)c[l] = this._block.readInt32LE(l * 4);
        var p = this._a, y = this._b, _ = this._c, A = this._d;
        p = s(p, y, _, A, c[0], 3614090360, 7), A = s(A, p, y, _, c[1], 3905402710, 12), _ = s(_, A, p, y, c[2], 606105819, 17), y = s(y, _, A, p, c[3], 3250441966, 22), p = s(p, y, _, A, c[4], 4118548399, 7), A = s(A, p, y, _, c[5], 1200080426, 12), _ = s(_, A, p, y, c[6], 2821735955, 17), y = s(y, _, A, p, c[7], 4249261313, 22), p = s(p, y, _, A, c[8], 1770035416, 7), A = s(A, p, y, _, c[9], 2336552879, 12), _ = s(_, A, p, y, c[10], 4294925233, 17), y = s(y, _, A, p, c[11], 2304563134, 22), p = s(p, y, _, A, c[12], 1804603682, 7), A = s(A, p, y, _, c[13], 4254626195, 12), _ = s(_, A, p, y, c[14], 2792965006, 17), y = s(y, _, A, p, c[15], 1236535329, 22), p = a(p, y, _, A, c[1], 4129170786, 5), A = a(A, p, y, _, c[6], 3225465664, 9), _ = a(_, A, p, y, c[11], 643717713, 14), y = a(y, _, A, p, c[0], 3921069994, 20), p = a(p, y, _, A, c[5], 3593408605, 5), A = a(A, p, y, _, c[10], 38016083, 9), _ = a(_, A, p, y, c[15], 3634488961, 14), y = a(y, _, A, p, c[4], 3889429448, 20), p = a(p, y, _, A, c[9], 568446438, 5), A = a(A, p, y, _, c[14], 3275163606, 9), _ = a(_, A, p, y, c[3], 4107603335, 14), y = a(y, _, A, p, c[8], 1163531501, 20), p = a(p, y, _, A, c[13], 2850285829, 5), A = a(A, p, y, _, c[2], 4243563512, 9), _ = a(_, A, p, y, c[7], 1735328473, 14), y = a(y, _, A, p, c[12], 2368359562, 20), p = u(p, y, _, A, c[5], 4294588738, 4), A = u(A, p, y, _, c[8], 2272392833, 11), _ = u(_, A, p, y, c[11], 1839030562, 16), y = u(y, _, A, p, c[14], 4259657740, 23), p = u(p, y, _, A, c[1], 2763975236, 4), A = u(A, p, y, _, c[4], 1272893353, 11), _ = u(_, A, p, y, c[7], 4139469664, 16), y = u(y, _, A, p, c[10], 3200236656, 23), p = u(p, y, _, A, c[13], 681279174, 4), A = u(A, p, y, _, c[0], 3936430074, 11), _ = u(_, A, p, y, c[3], 3572445317, 16), y = u(y, _, A, p, c[6], 76029189, 23), p = u(p, y, _, A, c[9], 3654602809, 4), A = u(A, p, y, _, c[12], 3873151461, 11), _ = u(_, A, p, y, c[15], 530742520, 16), y = u(y, _, A, p, c[2], 3299628645, 23), p = f(p, y, _, A, c[0], 4096336452, 6), A = f(A, p, y, _, c[7], 1126891415, 10), _ = f(_, A, p, y, c[14], 2878612391, 15), y = f(y, _, A, p, c[5], 4237533241, 21), p = f(p, y, _, A, c[12], 1700485571, 6), A = f(A, p, y, _, c[3], 2399980690, 10), _ = f(_, A, p, y, c[10], 4293915773, 15), y = f(y, _, A, p, c[1], 2240044497, 21), p = f(p, y, _, A, c[8], 1873313359, 6), A = f(A, p, y, _, c[15], 4264355552, 10), _ = f(_, A, p, y, c[6], 2734768916, 15), y = f(y, _, A, p, c[13], 1309151649, 21), p = f(p, y, _, A, c[4], 4149444226, 6), A = f(A, p, y, _, c[11], 3174756917, 10), _ = f(_, A, p, y, c[2], 718787259, 15), y = f(y, _, A, p, c[9], 3951481745, 21), this._a = this._a + p | 0, this._b = this._b + y | 0, this._c = this._c + _ | 0, this._d = this._d + A | 0;
    }, i.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var c = r.allocUnsafe(16);
        return c.writeInt32LE(this._a, 0), c.writeInt32LE(this._b, 4), c.writeInt32LE(this._c, 8), c.writeInt32LE(this._d, 12), c;
    };
    function o(c, l) {
        return c << l | c >>> 32 - l;
    }
    function s(c, l, p, y, _, A, O) {
        return o(c + (l & p | ~l & y) + _ + A | 0, O) + l | 0;
    }
    function a(c, l, p, y, _, A, O) {
        return o(c + (l & y | p & ~y) + _ + A | 0, O) + l | 0;
    }
    function u(c, l, p, y, _, A, O) {
        return o(c + (l ^ p ^ y) + _ + A | 0, O) + l | 0;
    }
    function f(c, l, p, y, _, A, O) {
        return o(c + (p ^ (l | ~y)) + _ + A | 0, O) + l | 0;
    }
    return av = i, av;
}
var cv, xA;
function M3() {
    if (xA) return cv;
    xA = 1;
    var e = ku.Buffer, t = Or(), r = nO(), n = new Array(16), i = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], o = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], a = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ], u = [
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
    ], f = [
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
    ];
    function c() {
        r.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    t(c, r), c.prototype._update = function() {
        for(var N = n, U = 0; U < 16; ++U)N[U] = this._block.readInt32LE(U * 4);
        for(var D = this._a | 0, H = this._b | 0, K = this._c | 0, re = this._d | 0, Q = this._e | 0, G = this._a | 0, R = this._b | 0, X = this._c | 0, $ = this._d | 0, S = this._e | 0, w = 0; w < 80; w += 1){
            var g, m;
            w < 16 ? (g = p(D, H, K, re, Q, N[i[w]], u[0], s[w]), m = O(G, R, X, $, S, N[o[w]], f[0], a[w])) : w < 32 ? (g = y(D, H, K, re, Q, N[i[w]], u[1], s[w]), m = A(G, R, X, $, S, N[o[w]], f[1], a[w])) : w < 48 ? (g = _(D, H, K, re, Q, N[i[w]], u[2], s[w]), m = _(G, R, X, $, S, N[o[w]], f[2], a[w])) : w < 64 ? (g = A(D, H, K, re, Q, N[i[w]], u[3], s[w]), m = y(G, R, X, $, S, N[o[w]], f[3], a[w])) : (g = O(D, H, K, re, Q, N[i[w]], u[4], s[w]), m = p(G, R, X, $, S, N[o[w]], f[4], a[w])), D = Q, Q = re, re = l(K, 10), K = H, H = g, G = S, S = $, $ = l(X, 10), X = R, R = m;
        }
        var E = this._b + K + $ | 0;
        this._b = this._c + re + S | 0, this._c = this._d + Q + G | 0, this._d = this._e + D + R | 0, this._e = this._a + H + X | 0, this._a = E;
    }, c.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var N = e.alloc ? e.alloc(20) : new e(20);
        return N.writeInt32LE(this._a, 0), N.writeInt32LE(this._b, 4), N.writeInt32LE(this._c, 8), N.writeInt32LE(this._d, 12), N.writeInt32LE(this._e, 16), N;
    };
    function l(N, U) {
        return N << U | N >>> 32 - U;
    }
    function p(N, U, D, H, K, re, Q, G) {
        return l(N + (U ^ D ^ H) + re + Q | 0, G) + K | 0;
    }
    function y(N, U, D, H, K, re, Q, G) {
        return l(N + (U & D | ~U & H) + re + Q | 0, G) + K | 0;
    }
    function _(N, U, D, H, K, re, Q, G) {
        return l(N + ((U | ~D) ^ H) + re + Q | 0, G) + K | 0;
    }
    function A(N, U, D, H, K, re, Q, G) {
        return l(N + (U & H | D & ~H) + re + Q | 0, G) + K | 0;
    }
    function O(N, U, D, H, K, re, Q, G) {
        return l(N + (U ^ (D | ~H)) + re + Q | 0, G) + K | 0;
    }
    return cv = c, cv;
}
var uv = {
    exports: {}
}, fv, SA;
function Id() {
    if (SA) return fv;
    SA = 1;
    var e = Ar().Buffer;
    function t(r, n) {
        this._block = e.alloc(r), this._finalSize = n, this._blockSize = r, this._len = 0;
    }
    return t.prototype.update = function(r, n) {
        typeof r == "string" && (n = n || "utf8", r = e.from(r, n));
        for(var i = this._block, o = this._blockSize, s = r.length, a = this._len, u = 0; u < s;){
            for(var f = a % o, c = Math.min(s - u, o - f), l = 0; l < c; l++)i[f + l] = r[u + l];
            a += c, u += c, a % o === 0 && this._update(i);
        }
        return this._len += s, this;
    }, t.prototype.digest = function(r) {
        var n = this._len % this._blockSize;
        this._block[n] = 128, this._block.fill(0, n + 1), n >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var i = this._len * 8;
        if (i <= 4294967295) this._block.writeUInt32BE(i, this._blockSize - 4);
        else {
            var o = (i & 4294967295) >>> 0, s = (i - o) / 4294967296;
            this._block.writeUInt32BE(s, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
        }
        this._update(this._block);
        var a = this._hash();
        return r ? a.toString(r) : a;
    }, t.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    }, fv = t, fv;
}
var lv, AA;
function pY() {
    if (AA) return lv;
    AA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], i = new Array(80);
    function o() {
        this.init(), this._w = i, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function s(f) {
        return f << 5 | f >>> 27;
    }
    function a(f) {
        return f << 30 | f >>> 2;
    }
    function u(f, c, l, p) {
        return f === 0 ? c & l | ~c & p : f === 2 ? c & l | c & p | l & p : c ^ l ^ p;
    }
    return o.prototype._update = function(f) {
        for(var c = this._w, l = this._a | 0, p = this._b | 0, y = this._c | 0, _ = this._d | 0, A = this._e | 0, O = 0; O < 16; ++O)c[O] = f.readInt32BE(O * 4);
        for(; O < 80; ++O)c[O] = c[O - 3] ^ c[O - 8] ^ c[O - 14] ^ c[O - 16];
        for(var N = 0; N < 80; ++N){
            var U = ~~(N / 20), D = s(l) + u(U, p, y, _) + A + c[N] + n[U] | 0;
            A = _, _ = y, y = a(p), p = l, l = D;
        }
        this._a = l + this._a | 0, this._b = p + this._b | 0, this._c = y + this._c | 0, this._d = _ + this._d | 0, this._e = A + this._e | 0;
    }, o.prototype._hash = function() {
        var f = r.allocUnsafe(20);
        return f.writeInt32BE(this._a | 0, 0), f.writeInt32BE(this._b | 0, 4), f.writeInt32BE(this._c | 0, 8), f.writeInt32BE(this._d | 0, 12), f.writeInt32BE(this._e | 0, 16), f;
    }, lv = o, lv;
}
var dv, TA;
function gY() {
    if (TA) return dv;
    TA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], i = new Array(80);
    function o() {
        this.init(), this._w = i, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function s(c) {
        return c << 1 | c >>> 31;
    }
    function a(c) {
        return c << 5 | c >>> 27;
    }
    function u(c) {
        return c << 30 | c >>> 2;
    }
    function f(c, l, p, y) {
        return c === 0 ? l & p | ~l & y : c === 2 ? l & p | l & y | p & y : l ^ p ^ y;
    }
    return o.prototype._update = function(c) {
        for(var l = this._w, p = this._a | 0, y = this._b | 0, _ = this._c | 0, A = this._d | 0, O = this._e | 0, N = 0; N < 16; ++N)l[N] = c.readInt32BE(N * 4);
        for(; N < 80; ++N)l[N] = s(l[N - 3] ^ l[N - 8] ^ l[N - 14] ^ l[N - 16]);
        for(var U = 0; U < 80; ++U){
            var D = ~~(U / 20), H = a(p) + f(D, y, _, A) + O + l[U] + n[D] | 0;
            O = A, A = _, _ = u(y), y = p, p = H;
        }
        this._a = p + this._a | 0, this._b = y + this._b | 0, this._c = _ + this._c | 0, this._d = A + this._d | 0, this._e = O + this._e | 0;
    }, o.prototype._hash = function() {
        var c = r.allocUnsafe(20);
        return c.writeInt32BE(this._a | 0, 0), c.writeInt32BE(this._b | 0, 4), c.writeInt32BE(this._c | 0, 8), c.writeInt32BE(this._d | 0, 12), c.writeInt32BE(this._e | 0, 16), c;
    }, dv = o, dv;
}
var hv, kA;
function iO() {
    if (kA) return hv;
    kA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ], i = new Array(64);
    function o() {
        this.init(), this._w = i, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function s(p, y, _) {
        return _ ^ p & (y ^ _);
    }
    function a(p, y, _) {
        return p & y | _ & (p | y);
    }
    function u(p) {
        return (p >>> 2 | p << 30) ^ (p >>> 13 | p << 19) ^ (p >>> 22 | p << 10);
    }
    function f(p) {
        return (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7);
    }
    function c(p) {
        return (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3;
    }
    function l(p) {
        return (p >>> 17 | p << 15) ^ (p >>> 19 | p << 13) ^ p >>> 10;
    }
    return o.prototype._update = function(p) {
        for(var y = this._w, _ = this._a | 0, A = this._b | 0, O = this._c | 0, N = this._d | 0, U = this._e | 0, D = this._f | 0, H = this._g | 0, K = this._h | 0, re = 0; re < 16; ++re)y[re] = p.readInt32BE(re * 4);
        for(; re < 64; ++re)y[re] = l(y[re - 2]) + y[re - 7] + c(y[re - 15]) + y[re - 16] | 0;
        for(var Q = 0; Q < 64; ++Q){
            var G = K + f(U) + s(U, D, H) + n[Q] + y[Q] | 0, R = u(_) + a(_, A, O) | 0;
            K = H, H = D, D = U, U = N + G | 0, N = O, O = A, A = _, _ = G + R | 0;
        }
        this._a = _ + this._a | 0, this._b = A + this._b | 0, this._c = O + this._c | 0, this._d = N + this._d | 0, this._e = U + this._e | 0, this._f = D + this._f | 0, this._g = H + this._g | 0, this._h = K + this._h | 0;
    }, o.prototype._hash = function() {
        var p = r.allocUnsafe(32);
        return p.writeInt32BE(this._a, 0), p.writeInt32BE(this._b, 4), p.writeInt32BE(this._c, 8), p.writeInt32BE(this._d, 12), p.writeInt32BE(this._e, 16), p.writeInt32BE(this._f, 20), p.writeInt32BE(this._g, 24), p.writeInt32BE(this._h, 28), p;
    }, hv = o, hv;
}
var pv, IA;
function yY() {
    if (IA) return pv;
    IA = 1;
    var e = Or(), t = iO(), r = Id(), n = Ar().Buffer, i = new Array(64);
    function o() {
        this.init(), this._w = i, r.call(this, 64, 56);
    }
    return e(o, t), o.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    }, o.prototype._hash = function() {
        var s = n.allocUnsafe(28);
        return s.writeInt32BE(this._a, 0), s.writeInt32BE(this._b, 4), s.writeInt32BE(this._c, 8), s.writeInt32BE(this._d, 12), s.writeInt32BE(this._e, 16), s.writeInt32BE(this._f, 20), s.writeInt32BE(this._g, 24), s;
    }, pv = o, pv;
}
var gv, BA;
function oO() {
    if (BA) return gv;
    BA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ], i = new Array(160);
    function o() {
        this.init(), this._w = i, t.call(this, 128, 112);
    }
    e(o, t), o.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function s(A, O, N) {
        return N ^ A & (O ^ N);
    }
    function a(A, O, N) {
        return A & O | N & (A | O);
    }
    function u(A, O) {
        return (A >>> 28 | O << 4) ^ (O >>> 2 | A << 30) ^ (O >>> 7 | A << 25);
    }
    function f(A, O) {
        return (A >>> 14 | O << 18) ^ (A >>> 18 | O << 14) ^ (O >>> 9 | A << 23);
    }
    function c(A, O) {
        return (A >>> 1 | O << 31) ^ (A >>> 8 | O << 24) ^ A >>> 7;
    }
    function l(A, O) {
        return (A >>> 1 | O << 31) ^ (A >>> 8 | O << 24) ^ (A >>> 7 | O << 25);
    }
    function p(A, O) {
        return (A >>> 19 | O << 13) ^ (O >>> 29 | A << 3) ^ A >>> 6;
    }
    function y(A, O) {
        return (A >>> 19 | O << 13) ^ (O >>> 29 | A << 3) ^ (A >>> 6 | O << 26);
    }
    function _(A, O) {
        return A >>> 0 < O >>> 0 ? 1 : 0;
    }
    return o.prototype._update = function(A) {
        for(var O = this._w, N = this._ah | 0, U = this._bh | 0, D = this._ch | 0, H = this._dh | 0, K = this._eh | 0, re = this._fh | 0, Q = this._gh | 0, G = this._hh | 0, R = this._al | 0, X = this._bl | 0, $ = this._cl | 0, S = this._dl | 0, w = this._el | 0, g = this._fl | 0, m = this._gl | 0, E = this._hl | 0, T = 0; T < 32; T += 2)O[T] = A.readInt32BE(T * 4), O[T + 1] = A.readInt32BE(T * 4 + 4);
        for(; T < 160; T += 2){
            var I = O[T - 30], P = O[T - 15 * 2 + 1], k = c(I, P), L = l(P, I);
            I = O[T - 2 * 2], P = O[T - 2 * 2 + 1];
            var j = p(I, P), ie = y(P, I), ue = O[T - 7 * 2], ce = O[T - 7 * 2 + 1], he = O[T - 16 * 2], ee = O[T - 16 * 2 + 1], ae = L + ce | 0, ye = k + ue + _(ae, L) | 0;
            ae = ae + ie | 0, ye = ye + j + _(ae, ie) | 0, ae = ae + ee | 0, ye = ye + he + _(ae, ee) | 0, O[T] = ye, O[T + 1] = ae;
        }
        for(var Se = 0; Se < 160; Se += 2){
            ye = O[Se], ae = O[Se + 1];
            var De = a(N, U, D), Re = a(R, X, $), Ce = u(N, R), M = u(R, N), z = f(K, w), de = f(w, K), _e = n[Se], Ie = n[Se + 1], je = s(K, re, Q), Ke = s(w, g, m), Ue = E + de | 0, h = G + z + _(Ue, E) | 0;
            Ue = Ue + Ke | 0, h = h + je + _(Ue, Ke) | 0, Ue = Ue + Ie | 0, h = h + _e + _(Ue, Ie) | 0, Ue = Ue + ae | 0, h = h + ye + _(Ue, ae) | 0;
            var x = M + Re | 0, q = Ce + De + _(x, M) | 0;
            G = Q, E = m, Q = re, m = g, re = K, g = w, w = S + Ue | 0, K = H + h + _(w, S) | 0, H = D, S = $, D = U, $ = X, U = N, X = R, R = Ue + x | 0, N = h + q + _(R, Ue) | 0;
        }
        this._al = this._al + R | 0, this._bl = this._bl + X | 0, this._cl = this._cl + $ | 0, this._dl = this._dl + S | 0, this._el = this._el + w | 0, this._fl = this._fl + g | 0, this._gl = this._gl + m | 0, this._hl = this._hl + E | 0, this._ah = this._ah + N + _(this._al, R) | 0, this._bh = this._bh + U + _(this._bl, X) | 0, this._ch = this._ch + D + _(this._cl, $) | 0, this._dh = this._dh + H + _(this._dl, S) | 0, this._eh = this._eh + K + _(this._el, w) | 0, this._fh = this._fh + re + _(this._fl, g) | 0, this._gh = this._gh + Q + _(this._gl, m) | 0, this._hh = this._hh + G + _(this._hl, E) | 0;
    }, o.prototype._hash = function() {
        var A = r.allocUnsafe(64);
        function O(N, U, D) {
            A.writeInt32BE(N, D), A.writeInt32BE(U, D + 4);
        }
        return O(this._ah, this._al, 0), O(this._bh, this._bl, 8), O(this._ch, this._cl, 16), O(this._dh, this._dl, 24), O(this._eh, this._el, 32), O(this._fh, this._fl, 40), O(this._gh, this._gl, 48), O(this._hh, this._hl, 56), A;
    }, gv = o, gv;
}
var yv, OA;
function mY() {
    if (OA) return yv;
    OA = 1;
    var e = Or(), t = oO(), r = Id(), n = Ar().Buffer, i = new Array(160);
    function o() {
        this.init(), this._w = i, r.call(this, 128, 112);
    }
    return e(o, t), o.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    }, o.prototype._hash = function() {
        var s = n.allocUnsafe(48);
        function a(u, f, c) {
            s.writeInt32BE(u, c), s.writeInt32BE(f, c + 4);
        }
        return a(this._ah, this._al, 0), a(this._bh, this._bl, 8), a(this._ch, this._cl, 16), a(this._dh, this._dl, 24), a(this._eh, this._el, 32), a(this._fh, this._fl, 40), s;
    }, yv = o, yv;
}
var PA;
function R3() {
    if (PA) return uv.exports;
    PA = 1;
    var e = uv.exports = function(r) {
        r = r.toLowerCase();
        var n = e[r];
        if (!n) throw new Error(r + " is not supported (we accept pull requests)");
        return new n();
    };
    return e.sha = pY(), e.sha1 = gY(), e.sha224 = yY(), e.sha256 = iO(), e.sha384 = mY(), e.sha512 = oO(), uv.exports;
}
var mv = {}, NA;
function bY() {
    if (NA) return mv;
    NA = 1;
    var e = Ar().Buffer, t = e.isEncoding || function(N) {
        switch(N = "" + N, N && N.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function r(N) {
        if (!N) return "utf8";
        for(var U;;)switch(N){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return N;
            default:
                if (U) return;
                N = ("" + N).toLowerCase(), U = !0;
        }
    }
    function n(N) {
        var U = r(N);
        if (typeof U != "string" && (e.isEncoding === t || !t(N))) throw new Error("Unknown encoding: " + N);
        return U || N;
    }
    mv.StringDecoder = i;
    function i(N) {
        this.encoding = n(N);
        var U;
        switch(this.encoding){
            case "utf16le":
                this.text = l, this.end = p, U = 4;
                break;
            case "utf8":
                this.fillLast = u, U = 4;
                break;
            case "base64":
                this.text = y, this.end = _, U = 3;
                break;
            default:
                this.write = A, this.end = O;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(U);
    }
    i.prototype.write = function(N) {
        if (N.length === 0) return "";
        var U, D;
        if (this.lastNeed) {
            if (U = this.fillLast(N), U === void 0) return "";
            D = this.lastNeed, this.lastNeed = 0;
        } else D = 0;
        return D < N.length ? U ? U + this.text(N, D) : this.text(N, D) : U || "";
    }, i.prototype.end = c, i.prototype.text = f, i.prototype.fillLast = function(N) {
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, N.length), this.lastNeed -= N.length;
    };
    function o(N) {
        return N <= 127 ? 0 : N >> 5 === 6 ? 2 : N >> 4 === 14 ? 3 : N >> 3 === 30 ? 4 : N >> 6 === 2 ? -1 : -2;
    }
    function s(N, U, D) {
        var H = U.length - 1;
        if (H < D) return 0;
        var K = o(U[H]);
        return K >= 0 ? (K > 0 && (N.lastNeed = K - 1), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (N.lastNeed = K - 2), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (K === 2 ? K = 0 : N.lastNeed = K - 3), K) : 0));
    }
    function a(N, U, D) {
        if ((U[0] & 192) !== 128) return N.lastNeed = 0, "�";
        if (N.lastNeed > 1 && U.length > 1) {
            if ((U[1] & 192) !== 128) return N.lastNeed = 1, "�";
            if (N.lastNeed > 2 && U.length > 2 && (U[2] & 192) !== 128) return N.lastNeed = 2, "�";
        }
    }
    function u(N) {
        var U = this.lastTotal - this.lastNeed, D = a(this, N);
        if (D !== void 0) return D;
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, U, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, U, 0, N.length), this.lastNeed -= N.length;
    }
    function f(N, U) {
        var D = s(this, N, U);
        if (!this.lastNeed) return N.toString("utf8", U);
        this.lastTotal = D;
        var H = N.length - (D - this.lastNeed);
        return N.copy(this.lastChar, 0, H), N.toString("utf8", U, H);
    }
    function c(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + "�" : U;
    }
    function l(N, U) {
        if ((N.length - U) % 2 === 0) {
            var D = N.toString("utf16le", U);
            if (D) {
                var H = D.charCodeAt(D.length - 1);
                if (H >= 55296 && H <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1], D.slice(0, -1);
            }
            return D;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = N[N.length - 1], N.toString("utf16le", U, N.length - 1);
    }
    function p(N) {
        var U = N && N.length ? this.write(N) : "";
        if (this.lastNeed) {
            var D = this.lastTotal - this.lastNeed;
            return U + this.lastChar.toString("utf16le", 0, D);
        }
        return U;
    }
    function y(N, U) {
        var D = (N.length - U) % 3;
        return D === 0 ? N.toString("base64", U) : (this.lastNeed = 3 - D, this.lastTotal = 3, D === 1 ? this.lastChar[0] = N[N.length - 1] : (this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1]), N.toString("base64", U, N.length - D));
    }
    function _(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : U;
    }
    function A(N) {
        return N.toString(this.encoding);
    }
    function O(N) {
        return N && N.length ? this.write(N) : "";
    }
    return mv;
}
var bv, MA;
function Bu() {
    if (MA) return bv;
    MA = 1;
    var e = Ar().Buffer, t = Iu.Transform, r = bY().StringDecoder, n = Or();
    function i(u) {
        t.call(this), this.hashMode = typeof u == "string", this.hashMode ? this[u] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    n(i, t);
    var o = typeof Uint8Array < "u", s = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
    function a(u, f) {
        if (u instanceof e) return u;
        if (typeof u == "string") return e.from(u, f);
        if (s && ArrayBuffer.isView(u)) {
            if (u.byteLength === 0) return e.alloc(0);
            var c = e.from(u.buffer, u.byteOffset, u.byteLength);
            if (c.byteLength === u.byteLength) return c;
        }
        if (o && u instanceof Uint8Array || e.isBuffer(u) && u.constructor && typeof u.constructor.isBuffer == "function" && u.constructor.isBuffer(u)) return e.from(u);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    return i.prototype.update = function(u, f, c) {
        var l = a(u, f), p = this._update(l);
        return this.hashMode ? this : (c && (p = this._toString(p, c)), p);
    }, i.prototype.setAutoPadding = function() {}, i.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
    }, i.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
    }, i.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
    }, i.prototype._transform = function(u, f, c) {
        var l;
        try {
            this.hashMode ? this._update(u) : this.push(this._update(u));
        } catch (p) {
            l = p;
        } finally{
            c(l);
        }
    }, i.prototype._flush = function(u) {
        var f;
        try {
            this.push(this.__final());
        } catch (c) {
            f = c;
        }
        u(f);
    }, i.prototype._finalOrDigest = function(u) {
        var f = this.__final() || e.alloc(0);
        return u && (f = this._toString(f, u, !0)), f;
    }, i.prototype._toString = function(u, f, c) {
        if (this._decoder || (this._decoder = new r(f), this._encoding = f), this._encoding !== f) throw new Error("can’t switch encodings");
        var l = this._decoder.write(u);
        return c && (l += this._decoder.end()), l;
    }, bv = i, bv;
}
var wv, RA;
function n0() {
    if (RA) return wv;
    RA = 1;
    var e = Or(), t = N3(), r = M3(), n = R3(), i = Bu();
    function o(s) {
        i.call(this, "digest"), this._hash = s;
    }
    return e(o, i), o.prototype._update = function(s) {
        this._hash.update(s);
    }, o.prototype._final = function() {
        return this._hash.digest();
    }, wv = function(a) {
        return a = a.toLowerCase(), a === "md5" ? new t() : a === "rmd160" || a === "ripemd160" ? new r() : new o(n(a));
    }, wv;
}
var vv, CA;
function wY() {
    if (CA) return vv;
    CA = 1;
    var e = Or(), t = Ar().Buffer, r = Bu(), n = t.alloc(128), i = 64;
    function o(s, a) {
        r.call(this, "digest"), typeof a == "string" && (a = t.from(a)), this._alg = s, this._key = a, a.length > i ? a = s(a) : a.length < i && (a = t.concat([
            a,
            n
        ], i));
        for(var u = this._ipad = t.allocUnsafe(i), f = this._opad = t.allocUnsafe(i), c = 0; c < i; c++)u[c] = a[c] ^ 54, f[c] = a[c] ^ 92;
        this._hash = [
            u
        ];
    }
    return e(o, r), o.prototype._update = function(s) {
        this._hash.push(s);
    }, o.prototype._final = function() {
        var s = this._alg(t.concat(this._hash));
        return this._alg(t.concat([
            this._opad,
            s
        ]));
    }, vv = o, vv;
}
var _v, UA;
function sO() {
    if (UA) return _v;
    UA = 1;
    var e = N3();
    return _v = function(t) {
        return new e().update(t).digest();
    }, _v;
}
var Ev, $A;
function aO() {
    if ($A) return Ev;
    $A = 1;
    var e = Or(), t = wY(), r = Bu(), n = Ar().Buffer, i = sO(), o = M3(), s = R3(), a = n.alloc(128);
    function u(f, c) {
        r.call(this, "digest"), typeof c == "string" && (c = n.from(c));
        var l = f === "sha512" || f === "sha384" ? 128 : 64;
        if (this._alg = f, this._key = c, c.length > l) {
            var p = f === "rmd160" ? new o() : s(f);
            c = p.update(c).digest();
        } else c.length < l && (c = n.concat([
            c,
            a
        ], l));
        for(var y = this._ipad = n.allocUnsafe(l), _ = this._opad = n.allocUnsafe(l), A = 0; A < l; A++)y[A] = c[A] ^ 54, _[A] = c[A] ^ 92;
        this._hash = f === "rmd160" ? new o() : s(f), this._hash.update(y);
    }
    return e(u, r), u.prototype._update = function(f) {
        this._hash.update(f);
    }, u.prototype._final = function() {
        var f = this._hash.digest(), c = this._alg === "rmd160" ? new o() : s(this._alg);
        return c.update(this._opad).update(f).digest();
    }, Ev = function(c, l) {
        return c = c.toLowerCase(), c === "rmd160" || c === "ripemd160" ? new u("rmd160", l) : c === "md5" ? new t(i, l) : new u(c, l);
    }, Ev;
}
const vY = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
}, _Y = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
}, EY = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
}, xY = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
}, SY = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
}, AY = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
}, TY = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
}, kY = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
}, IY = {
    sign: "dsa",
    hash: "sha1",
    id: ""
}, BY = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
}, OY = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
}, cO = {
    sha224WithRSAEncryption: vY,
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption: _Y,
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption: EY,
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption: xY,
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256: SY,
    sha224: AY,
    sha384: TY,
    sha512: kY,
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA: IY,
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA: BY,
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption: OY,
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var xv, LA;
function PY() {
    return LA || (LA = 1, xv = cO), xv;
}
var Ug = {}, Sv, DA;
function uO() {
    if (DA) return Sv;
    DA = 1;
    var e = Math.pow(2, 30) - 1;
    return Sv = function(t, r) {
        if (typeof t != "number") throw new TypeError("Iterations not a number");
        if (t < 0) throw new TypeError("Bad iterations");
        if (typeof r != "number") throw new TypeError("Key length not a number");
        if (r < 0 || r > e || r !== r) throw new TypeError("Bad key length");
    }, Sv;
}
var Av, FA;
function fO() {
    if (FA) return Av;
    FA = 1;
    var e;
    if (Ge.process && Ge.process.browser) e = "utf-8";
    else if (Ge.process && Ge.process.version) {
        var t = parseInt(bn.version.split(".")[0].slice(1), 10);
        e = t >= 6 ? "utf-8" : "binary";
    } else e = "utf-8";
    return Av = e, Av;
}
var Tv, zA;
function lO() {
    if (zA) return Tv;
    zA = 1;
    var e = Ar().Buffer;
    return Tv = function(t, r, n) {
        if (e.isBuffer(t)) return t;
        if (typeof t == "string") return e.from(t, r);
        if (ArrayBuffer.isView(t)) return e.from(t.buffer);
        throw new TypeError(n + " must be a string, a Buffer, a typed array or a DataView");
    }, Tv;
}
var kv, jA;
function dO() {
    if (jA) return kv;
    jA = 1;
    var e = sO(), t = M3(), r = R3(), n = Ar().Buffer, i = uO(), o = fO(), s = lO(), a = n.alloc(128), u = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function f(p, y, _) {
        var A = c(p), O = p === "sha512" || p === "sha384" ? 128 : 64;
        y.length > O ? y = A(y) : y.length < O && (y = n.concat([
            y,
            a
        ], O));
        for(var N = n.allocUnsafe(O + u[p]), U = n.allocUnsafe(O + u[p]), D = 0; D < O; D++)N[D] = y[D] ^ 54, U[D] = y[D] ^ 92;
        var H = n.allocUnsafe(O + _ + 4);
        N.copy(H, 0, 0, O), this.ipad1 = H, this.ipad2 = N, this.opad = U, this.alg = p, this.blocksize = O, this.hash = A, this.size = u[p];
    }
    f.prototype.run = function(p, y) {
        p.copy(y, this.blocksize);
        var _ = this.hash(y);
        return _.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function c(p) {
        function y(A) {
            return r(p).update(A).digest();
        }
        function _(A) {
            return new t().update(A).digest();
        }
        return p === "rmd160" || p === "ripemd160" ? _ : p === "md5" ? e : y;
    }
    function l(p, y, _, A, O) {
        i(_, A), p = s(p, o, "Password"), y = s(y, o, "Salt"), O = O || "sha1";
        var N = new f(O, p, y.length), U = n.allocUnsafe(A), D = n.allocUnsafe(y.length + 4);
        y.copy(D, 0, 0, y.length);
        for(var H = 0, K = u[O], re = Math.ceil(A / K), Q = 1; Q <= re; Q++){
            D.writeUInt32BE(Q, y.length);
            for(var G = N.run(D, N.ipad1), R = G, X = 1; X < _; X++){
                R = N.run(R, N.ipad2);
                for(var $ = 0; $ < K; $++)G[$] ^= R[$];
            }
            G.copy(U, H), H += K;
        }
        return U;
    }
    return kv = l, kv;
}
var Iv, HA;
function NY() {
    if (HA) return Iv;
    HA = 1;
    var e = Ar().Buffer, t = uO(), r = fO(), n = dO(), i = lO(), o, s = Ge.crypto && Ge.crypto.subtle, a = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, u = [];
    function f(_) {
        if (Ge.process && !Ge.process.browser || !s || !s.importKey || !s.deriveBits) return Promise.resolve(!1);
        if (u[_] !== void 0) return u[_];
        o = o || e.alloc(8);
        var A = p(o, o, 10, 128, _).then(function() {
            return !0;
        }).catch(function() {
            return !1;
        });
        return u[_] = A, A;
    }
    var c;
    function l() {
        return c || (Ge.process && Ge.process.nextTick ? c = Ge.process.nextTick : Ge.queueMicrotask ? c = Ge.queueMicrotask : Ge.setImmediate ? c = Ge.setImmediate : c = Ge.setTimeout, c);
    }
    function p(_, A, O, N, U) {
        return s.importKey("raw", _, {
            name: "PBKDF2"
        }, !1, [
            "deriveBits"
        ]).then(function(D) {
            return s.deriveBits({
                name: "PBKDF2",
                salt: A,
                iterations: O,
                hash: {
                    name: U
                }
            }, D, N << 3);
        }).then(function(D) {
            return e.from(D);
        });
    }
    function y(_, A) {
        _.then(function(O) {
            l()(function() {
                A(null, O);
            });
        }, function(O) {
            l()(function() {
                A(O);
            });
        });
    }
    return Iv = function(_, A, O, N, U, D) {
        typeof U == "function" && (D = U, U = void 0), U = U || "sha1";
        var H = a[U.toLowerCase()];
        if (!H || typeof Ge.Promise != "function") {
            l()(function() {
                var K;
                try {
                    K = n(_, A, O, N, U);
                } catch (re) {
                    return D(re);
                }
                D(null, K);
            });
            return;
        }
        if (t(O, N), _ = i(_, r, "Password"), A = i(A, r, "Salt"), typeof D != "function") throw new Error("No callback provided to pbkdf2");
        y(f(H).then(function(K) {
            return K ? p(_, A, O, N, H) : n(_, A, O, N, U);
        }), D);
    }, Iv;
}
var qA;
function hO() {
    return qA || (qA = 1, Ug.pbkdf2 = NY(), Ug.pbkdf2Sync = dO()), Ug;
}
var Zo = {}, Hu = {}, So = {}, KA;
function pO() {
    if (KA) return So;
    KA = 1, So.readUInt32BE = function(i, o) {
        var s = i[0 + o] << 24 | i[1 + o] << 16 | i[2 + o] << 8 | i[3 + o];
        return s >>> 0;
    }, So.writeUInt32BE = function(i, o, s) {
        i[0 + s] = o >>> 24, i[1 + s] = o >>> 16 & 255, i[2 + s] = o >>> 8 & 255, i[3 + s] = o & 255;
    }, So.ip = function(i, o, s, a) {
        for(var u = 0, f = 0, c = 6; c >= 0; c -= 2){
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= o >>> l + c & 1;
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= i >>> l + c & 1;
        }
        for(var c = 6; c >= 0; c -= 2){
            for(var l = 1; l <= 25; l += 8)f <<= 1, f |= o >>> l + c & 1;
            for(var l = 1; l <= 25; l += 8)f <<= 1, f |= i >>> l + c & 1;
        }
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.rip = function(i, o, s, a) {
        for(var u = 0, f = 0, c = 0; c < 4; c++)for(var l = 24; l >= 0; l -= 8)u <<= 1, u |= o >>> l + c & 1, u <<= 1, u |= i >>> l + c & 1;
        for(var c = 4; c < 8; c++)for(var l = 24; l >= 0; l -= 8)f <<= 1, f |= o >>> l + c & 1, f <<= 1, f |= i >>> l + c & 1;
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.pc1 = function(i, o, s, a) {
        for(var u = 0, f = 0, c = 7; c >= 5; c--){
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= o >> l + c & 1;
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= i >> l + c & 1;
        }
        for(var l = 0; l <= 24; l += 8)u <<= 1, u |= o >> l + c & 1;
        for(var c = 1; c <= 3; c++){
            for(var l = 0; l <= 24; l += 8)f <<= 1, f |= o >> l + c & 1;
            for(var l = 0; l <= 24; l += 8)f <<= 1, f |= i >> l + c & 1;
        }
        for(var l = 0; l <= 24; l += 8)f <<= 1, f |= i >> l + c & 1;
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.r28shl = function(i, o) {
        return i << o & 268435455 | i >>> 28 - o;
    };
    var e = [
        // inL => outL
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        // inR => outR
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
    ];
    So.pc2 = function(i, o, s, a) {
        for(var u = 0, f = 0, c = e.length >>> 1, l = 0; l < c; l++)u <<= 1, u |= i >>> e[l] & 1;
        for(var l = c; l < e.length; l++)f <<= 1, f |= o >>> e[l] & 1;
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.expand = function(i, o, s) {
        var a = 0, u = 0;
        a = (i & 1) << 5 | i >>> 27;
        for(var f = 23; f >= 15; f -= 4)a <<= 6, a |= i >>> f & 63;
        for(var f = 11; f >= 3; f -= 4)u |= i >>> f & 63, u <<= 6;
        u |= (i & 31) << 1 | i >>> 31, o[s + 0] = a >>> 0, o[s + 1] = u >>> 0;
    };
    var t = [
        14,
        0,
        4,
        15,
        13,
        7,
        1,
        4,
        2,
        14,
        15,
        2,
        11,
        13,
        8,
        1,
        3,
        10,
        10,
        6,
        6,
        12,
        12,
        11,
        5,
        9,
        9,
        5,
        0,
        3,
        7,
        8,
        4,
        15,
        1,
        12,
        14,
        8,
        8,
        2,
        13,
        4,
        6,
        9,
        2,
        1,
        11,
        7,
        15,
        5,
        12,
        11,
        9,
        3,
        7,
        14,
        3,
        10,
        10,
        0,
        5,
        6,
        0,
        13,
        15,
        3,
        1,
        13,
        8,
        4,
        14,
        7,
        6,
        15,
        11,
        2,
        3,
        8,
        4,
        14,
        9,
        12,
        7,
        0,
        2,
        1,
        13,
        10,
        12,
        6,
        0,
        9,
        5,
        11,
        10,
        5,
        0,
        13,
        14,
        8,
        7,
        10,
        11,
        1,
        10,
        3,
        4,
        15,
        13,
        4,
        1,
        2,
        5,
        11,
        8,
        6,
        12,
        7,
        6,
        12,
        9,
        0,
        3,
        5,
        2,
        14,
        15,
        9,
        10,
        13,
        0,
        7,
        9,
        0,
        14,
        9,
        6,
        3,
        3,
        4,
        15,
        6,
        5,
        10,
        1,
        2,
        13,
        8,
        12,
        5,
        7,
        14,
        11,
        12,
        4,
        11,
        2,
        15,
        8,
        1,
        13,
        1,
        6,
        10,
        4,
        13,
        9,
        0,
        8,
        6,
        15,
        9,
        3,
        8,
        0,
        7,
        11,
        4,
        1,
        15,
        2,
        14,
        12,
        3,
        5,
        11,
        10,
        5,
        14,
        2,
        7,
        12,
        7,
        13,
        13,
        8,
        14,
        11,
        3,
        5,
        0,
        6,
        6,
        15,
        9,
        0,
        10,
        3,
        1,
        4,
        2,
        7,
        8,
        2,
        5,
        12,
        11,
        1,
        12,
        10,
        4,
        14,
        15,
        9,
        10,
        3,
        6,
        15,
        9,
        0,
        0,
        6,
        12,
        10,
        11,
        1,
        7,
        13,
        13,
        8,
        15,
        9,
        1,
        4,
        3,
        5,
        14,
        11,
        5,
        12,
        2,
        7,
        8,
        2,
        4,
        14,
        2,
        14,
        12,
        11,
        4,
        2,
        1,
        12,
        7,
        4,
        10,
        7,
        11,
        13,
        6,
        1,
        8,
        5,
        5,
        0,
        3,
        15,
        15,
        10,
        13,
        3,
        0,
        9,
        14,
        8,
        9,
        6,
        4,
        11,
        2,
        8,
        1,
        12,
        11,
        7,
        10,
        1,
        13,
        14,
        7,
        2,
        8,
        13,
        15,
        6,
        9,
        15,
        12,
        0,
        5,
        9,
        6,
        10,
        3,
        4,
        0,
        5,
        14,
        3,
        12,
        10,
        1,
        15,
        10,
        4,
        15,
        2,
        9,
        7,
        2,
        12,
        6,
        9,
        8,
        5,
        0,
        6,
        13,
        1,
        3,
        13,
        4,
        14,
        14,
        0,
        7,
        11,
        5,
        3,
        11,
        8,
        9,
        4,
        14,
        3,
        15,
        2,
        5,
        12,
        2,
        9,
        8,
        5,
        12,
        15,
        3,
        10,
        7,
        11,
        0,
        14,
        4,
        1,
        10,
        7,
        1,
        6,
        13,
        0,
        11,
        8,
        6,
        13,
        4,
        13,
        11,
        0,
        2,
        11,
        14,
        7,
        15,
        4,
        0,
        9,
        8,
        1,
        13,
        10,
        3,
        14,
        12,
        3,
        9,
        5,
        7,
        12,
        5,
        2,
        10,
        15,
        6,
        8,
        1,
        6,
        1,
        6,
        4,
        11,
        11,
        13,
        13,
        8,
        12,
        1,
        3,
        4,
        7,
        10,
        14,
        7,
        10,
        9,
        15,
        5,
        6,
        0,
        8,
        15,
        0,
        14,
        5,
        2,
        9,
        3,
        2,
        12,
        13,
        1,
        2,
        15,
        8,
        13,
        4,
        8,
        6,
        10,
        15,
        3,
        11,
        7,
        1,
        4,
        10,
        12,
        9,
        5,
        3,
        6,
        14,
        11,
        5,
        0,
        0,
        14,
        12,
        9,
        7,
        2,
        7,
        2,
        11,
        1,
        4,
        14,
        1,
        7,
        9,
        4,
        12,
        10,
        14,
        8,
        2,
        13,
        0,
        15,
        6,
        12,
        10,
        9,
        13,
        0,
        15,
        3,
        3,
        5,
        5,
        6,
        8,
        11
    ];
    So.substitute = function(i, o) {
        for(var s = 0, a = 0; a < 4; a++){
            var u = i >>> 18 - a * 6 & 63, f = t[a * 64 + u];
            s <<= 4, s |= f;
        }
        for(var a = 0; a < 4; a++){
            var u = o >>> 18 - a * 6 & 63, f = t[4 * 64 + a * 64 + u];
            s <<= 4, s |= f;
        }
        return s >>> 0;
    };
    var r = [
        16,
        25,
        12,
        11,
        3,
        20,
        4,
        15,
        31,
        17,
        9,
        6,
        27,
        14,
        1,
        22,
        30,
        24,
        8,
        18,
        0,
        5,
        29,
        23,
        13,
        19,
        2,
        26,
        10,
        21,
        28,
        7
    ];
    return So.permute = function(i) {
        for(var o = 0, s = 0; s < r.length; s++)o <<= 1, o |= i >>> r[s] & 1;
        return o >>> 0;
    }, So.padSplit = function(i, o, s) {
        for(var a = i.toString(2); a.length < o;)a = "0" + a;
        for(var u = [], f = 0; f < o; f += s)u.push(a.slice(f, f + s));
        return u.join(" ");
    }, So;
}
var Bv, WA;
function ys() {
    if (WA) return Bv;
    WA = 1, Bv = e;
    function e(t, r) {
        if (!t) throw new Error(r || "Assertion failed");
    }
    return e.equal = function(r, n, i) {
        if (r != n) throw new Error(i || "Assertion failed: " + r + " != " + n);
    }, Bv;
}
var Ov, VA;
function C3() {
    if (VA) return Ov;
    VA = 1;
    var e = ys();
    function t(r) {
        this.options = r, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = r.padding !== !1;
    }
    return Ov = t, t.prototype._init = function() {}, t.prototype.update = function(n) {
        return n.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(n) : this._updateEncrypt(n);
    }, t.prototype._buffer = function(n, i) {
        for(var o = Math.min(this.buffer.length - this.bufferOff, n.length - i), s = 0; s < o; s++)this.buffer[this.bufferOff + s] = n[i + s];
        return this.bufferOff += o, o;
    }, t.prototype._flushBuffer = function(n, i) {
        return this._update(this.buffer, 0, n, i), this.bufferOff = 0, this.blockSize;
    }, t.prototype._updateEncrypt = function(n) {
        var i = 0, o = 0, s = (this.bufferOff + n.length) / this.blockSize | 0, a = new Array(s * this.blockSize);
        this.bufferOff !== 0 && (i += this._buffer(n, i), this.bufferOff === this.buffer.length && (o += this._flushBuffer(a, o)));
        for(var u = n.length - (n.length - i) % this.blockSize; i < u; i += this.blockSize)this._update(n, i, a, o), o += this.blockSize;
        for(; i < n.length; i++, this.bufferOff++)this.buffer[this.bufferOff] = n[i];
        return a;
    }, t.prototype._updateDecrypt = function(n) {
        for(var i = 0, o = 0, s = Math.ceil((this.bufferOff + n.length) / this.blockSize) - 1, a = new Array(s * this.blockSize); s > 0; s--)i += this._buffer(n, i), o += this._flushBuffer(a, o);
        return i += this._buffer(n, i), a;
    }, t.prototype.final = function(n) {
        var i;
        n && (i = this.update(n));
        var o;
        return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), i ? i.concat(o) : o;
    }, t.prototype._pad = function(n, i) {
        if (i === 0) return !1;
        for(; i < n.length;)n[i++] = 0;
        return !0;
    }, t.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff)) return [];
        var n = new Array(this.blockSize);
        return this._update(this.buffer, 0, n, 0), n;
    }, t.prototype._unpad = function(n) {
        return n;
    }, t.prototype._finalDecrypt = function() {
        e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var n = new Array(this.blockSize);
        return this._flushBuffer(n, 0), this._unpad(n);
    }, Ov;
}
var Pv, GA;
function gO() {
    if (GA) return Pv;
    GA = 1;
    var e = ys(), t = Or(), r = pO(), n = C3();
    function i() {
        this.tmp = new Array(2), this.keys = null;
    }
    function o(a) {
        n.call(this, a);
        var u = new i();
        this._desState = u, this.deriveKeys(u, a.key);
    }
    t(o, n), Pv = o, o.create = function(u) {
        return new o(u);
    };
    var s = [
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1
    ];
    return o.prototype.deriveKeys = function(u, f) {
        u.keys = new Array(16 * 2), e.equal(f.length, this.blockSize, "Invalid key length");
        var c = r.readUInt32BE(f, 0), l = r.readUInt32BE(f, 4);
        r.pc1(c, l, u.tmp, 0), c = u.tmp[0], l = u.tmp[1];
        for(var p = 0; p < u.keys.length; p += 2){
            var y = s[p >>> 1];
            c = r.r28shl(c, y), l = r.r28shl(l, y), r.pc2(c, l, u.keys, p);
        }
    }, o.prototype._update = function(u, f, c, l) {
        var p = this._desState, y = r.readUInt32BE(u, f), _ = r.readUInt32BE(u, f + 4);
        r.ip(y, _, p.tmp, 0), y = p.tmp[0], _ = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, y, _, p.tmp, 0) : this._decrypt(p, y, _, p.tmp, 0), y = p.tmp[0], _ = p.tmp[1], r.writeUInt32BE(c, y, l), r.writeUInt32BE(c, _, l + 4);
    }, o.prototype._pad = function(u, f) {
        if (this.padding === !1) return !1;
        for(var c = u.length - f, l = f; l < u.length; l++)u[l] = c;
        return !0;
    }, o.prototype._unpad = function(u) {
        if (this.padding === !1) return u;
        for(var f = u[u.length - 1], c = u.length - f; c < u.length; c++)e.equal(u[c], f);
        return u.slice(0, u.length - f);
    }, o.prototype._encrypt = function(u, f, c, l, p) {
        for(var y = f, _ = c, A = 0; A < u.keys.length; A += 2){
            var O = u.keys[A], N = u.keys[A + 1];
            r.expand(_, u.tmp, 0), O ^= u.tmp[0], N ^= u.tmp[1];
            var U = r.substitute(O, N), D = r.permute(U), H = _;
            _ = (y ^ D) >>> 0, y = H;
        }
        r.rip(_, y, l, p);
    }, o.prototype._decrypt = function(u, f, c, l, p) {
        for(var y = c, _ = f, A = u.keys.length - 2; A >= 0; A -= 2){
            var O = u.keys[A], N = u.keys[A + 1];
            r.expand(y, u.tmp, 0), O ^= u.tmp[0], N ^= u.tmp[1];
            var U = r.substitute(O, N), D = r.permute(U), H = y;
            y = (_ ^ D) >>> 0, _ = H;
        }
        r.rip(y, _, l, p);
    }, Pv;
}
var Nv = {}, ZA;
function MY() {
    if (ZA) return Nv;
    ZA = 1;
    var e = ys(), t = Or(), r = {};
    function n(o) {
        e.equal(o.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for(var s = 0; s < this.iv.length; s++)this.iv[s] = o[s];
    }
    function i(o) {
        function s(c) {
            o.call(this, c), this._cbcInit();
        }
        t(s, o);
        for(var a = Object.keys(r), u = 0; u < a.length; u++){
            var f = a[u];
            s.prototype[f] = r[f];
        }
        return s.create = function(l) {
            return new s(l);
        }, s;
    }
    return Nv.instantiate = i, r._cbcInit = function() {
        var s = new n(this.options.iv);
        this._cbcState = s;
    }, r._update = function(s, a, u, f) {
        var c = this._cbcState, l = this.constructor.super_.prototype, p = c.iv;
        if (this.type === "encrypt") {
            for(var y = 0; y < this.blockSize; y++)p[y] ^= s[a + y];
            l._update.call(this, p, 0, u, f);
            for(var y = 0; y < this.blockSize; y++)p[y] = u[f + y];
        } else {
            l._update.call(this, s, a, u, f);
            for(var y = 0; y < this.blockSize; y++)u[f + y] ^= p[y];
            for(var y = 0; y < this.blockSize; y++)p[y] = s[a + y];
        }
    }, Nv;
}
var Mv, YA;
function RY() {
    if (YA) return Mv;
    YA = 1;
    var e = ys(), t = Or(), r = C3(), n = gO();
    function i(s, a) {
        e.equal(a.length, 24, "Invalid key length");
        var u = a.slice(0, 8), f = a.slice(8, 16), c = a.slice(16, 24);
        s === "encrypt" ? this.ciphers = [
            n.create({
                type: "encrypt",
                key: u
            }),
            n.create({
                type: "decrypt",
                key: f
            }),
            n.create({
                type: "encrypt",
                key: c
            })
        ] : this.ciphers = [
            n.create({
                type: "decrypt",
                key: c
            }),
            n.create({
                type: "encrypt",
                key: f
            }),
            n.create({
                type: "decrypt",
                key: u
            })
        ];
    }
    function o(s) {
        r.call(this, s);
        var a = new i(this.type, this.options.key);
        this._edeState = a;
    }
    return t(o, r), Mv = o, o.create = function(a) {
        return new o(a);
    }, o.prototype._update = function(a, u, f, c) {
        var l = this._edeState;
        l.ciphers[0]._update(a, u, f, c), l.ciphers[1]._update(f, c, f, c), l.ciphers[2]._update(f, c, f, c);
    }, o.prototype._pad = n.prototype._pad, o.prototype._unpad = n.prototype._unpad, Mv;
}
var XA;
function CY() {
    return XA || (XA = 1, Hu.utils = pO(), Hu.Cipher = C3(), Hu.DES = gO(), Hu.CBC = MY(), Hu.EDE = RY()), Hu;
}
var Rv, JA;
function UY() {
    if (JA) return Rv;
    JA = 1;
    var e = Bu(), t = CY(), r = Or(), n = Ar().Buffer, i = {
        "des-ede3-cbc": t.CBC.instantiate(t.EDE),
        "des-ede3": t.EDE,
        "des-ede-cbc": t.CBC.instantiate(t.EDE),
        "des-ede": t.EDE,
        "des-cbc": t.CBC.instantiate(t.DES),
        "des-ecb": t.DES
    };
    i.des = i["des-cbc"], i.des3 = i["des-ede3-cbc"], Rv = o, r(o, e);
    function o(s) {
        e.call(this);
        var a = s.mode.toLowerCase(), u = i[a], f;
        s.decrypt ? f = "decrypt" : f = "encrypt";
        var c = s.key;
        n.isBuffer(c) || (c = n.from(c)), (a === "des-ede" || a === "des-ede-cbc") && (c = n.concat([
            c,
            c.slice(0, 8)
        ]));
        var l = s.iv;
        n.isBuffer(l) || (l = n.from(l)), this._des = u.create({
            key: c,
            iv: l,
            type: f
        });
    }
    return o.prototype._update = function(s) {
        return n.from(this._des.update(s));
    }, o.prototype._final = function() {
        return n.from(this._des.final());
    }, Rv;
}
var Yo = {}, $g = {}, Lg = {}, QA;
function $Y() {
    return QA || (QA = 1, Lg.encrypt = function(e, t) {
        return e._cipher.encryptBlock(t);
    }, Lg.decrypt = function(e, t) {
        return e._cipher.decryptBlock(t);
    }), Lg;
}
var Dg = {}, Cv, e5;
function i0() {
    return e5 || (e5 = 1, Cv = function(t, r) {
        for(var n = Math.min(t.length, r.length), i = new We(n), o = 0; o < n; ++o)i[o] = t[o] ^ r[o];
        return i;
    }), Cv;
}
var t5;
function LY() {
    if (t5) return Dg;
    t5 = 1;
    var e = i0();
    return Dg.encrypt = function(t, r) {
        var n = e(r, t._prev);
        return t._prev = t._cipher.encryptBlock(n), t._prev;
    }, Dg.decrypt = function(t, r) {
        var n = t._prev;
        t._prev = r;
        var i = t._cipher.decryptBlock(r);
        return e(i, n);
    }, Dg;
}
var Uv = {}, r5;
function DY() {
    if (r5) return Uv;
    r5 = 1;
    var e = Ar().Buffer, t = i0();
    function r(n, i, o) {
        var s = i.length, a = t(i, n._cache);
        return n._cache = n._cache.slice(s), n._prev = e.concat([
            n._prev,
            o ? i : a
        ]), a;
    }
    return Uv.encrypt = function(n, i, o) {
        for(var s = e.allocUnsafe(0), a; i.length;)if (n._cache.length === 0 && (n._cache = n._cipher.encryptBlock(n._prev), n._prev = e.allocUnsafe(0)), n._cache.length <= i.length) a = n._cache.length, s = e.concat([
            s,
            r(n, i.slice(0, a), o)
        ]), i = i.slice(a);
        else {
            s = e.concat([
                s,
                r(n, i, o)
            ]);
            break;
        }
        return s;
    }, Uv;
}
var $v = {}, n5;
function FY() {
    if (n5) return $v;
    n5 = 1;
    var e = Ar().Buffer;
    function t(r, n, i) {
        var o = r._cipher.encryptBlock(r._prev), s = o[0] ^ n;
        return r._prev = e.concat([
            r._prev.slice(1),
            e.from([
                i ? n : s
            ])
        ]), s;
    }
    return $v.encrypt = function(r, n, i) {
        for(var o = n.length, s = e.allocUnsafe(o), a = -1; ++a < o;)s[a] = t(r, n[a], i);
        return s;
    }, $v;
}
var Lv = {}, i5;
function zY() {
    if (i5) return Lv;
    i5 = 1;
    var e = Ar().Buffer;
    function t(n, i, o) {
        for(var s, a = -1, u = 8, f = 0, c, l; ++a < u;)s = n._cipher.encryptBlock(n._prev), c = i & 1 << 7 - a ? 128 : 0, l = s[0] ^ c, f += (l & 128) >> a % 8, n._prev = r(n._prev, o ? c : l);
        return f;
    }
    function r(n, i) {
        var o = n.length, s = -1, a = e.allocUnsafe(n.length);
        for(n = e.concat([
            n,
            e.from([
                i
            ])
        ]); ++s < o;)a[s] = n[s] << 1 | n[s + 1] >> 7;
        return a;
    }
    return Lv.encrypt = function(n, i, o) {
        for(var s = i.length, a = e.allocUnsafe(s), u = -1; ++u < s;)a[u] = t(n, i[u], o);
        return a;
    }, Lv;
}
var Dv = {}, o5;
function jY() {
    if (o5) return Dv;
    o5 = 1;
    var e = i0();
    function t(r) {
        return r._prev = r._cipher.encryptBlock(r._prev), r._prev;
    }
    return Dv.encrypt = function(r, n) {
        for(; r._cache.length < n.length;)r._cache = We.concat([
            r._cache,
            t(r)
        ]);
        var i = r._cache.slice(0, n.length);
        return r._cache = r._cache.slice(n.length), e(n, i);
    }, Dv;
}
var Fv = {}, zv, s5;
function yO() {
    if (s5) return zv;
    s5 = 1;
    function e(t) {
        for(var r = t.length, n; r--;)if (n = t.readUInt8(r), n === 255) t.writeUInt8(0, r);
        else {
            n++, t.writeUInt8(n, r);
            break;
        }
    }
    return zv = e, zv;
}
var a5;
function c5() {
    if (a5) return Fv;
    a5 = 1;
    var e = i0(), t = Ar().Buffer, r = yO();
    function n(o) {
        var s = o._cipher.encryptBlockRaw(o._prev);
        return r(o._prev), s;
    }
    var i = 16;
    return Fv.encrypt = function(o, s) {
        var a = Math.ceil(s.length / i), u = o._cache.length;
        o._cache = t.concat([
            o._cache,
            t.allocUnsafe(a * i)
        ]);
        for(var f = 0; f < a; f++){
            var c = n(o), l = u + f * i;
            o._cache.writeUInt32BE(c[0], l + 0), o._cache.writeUInt32BE(c[1], l + 4), o._cache.writeUInt32BE(c[2], l + 8), o._cache.writeUInt32BE(c[3], l + 12);
        }
        var p = o._cache.slice(0, s.length);
        return o._cache = o._cache.slice(s.length), e(s, p);
    }, Fv;
}
const HY = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
}, qY = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
}, KY = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
}, mO = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128: HY,
    aes192: qY,
    aes256: KY,
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
};
var jv, u5;
function U3() {
    if (u5) return jv;
    u5 = 1;
    var e = {
        ECB: $Y(),
        CBC: LY(),
        CFB: DY(),
        CFB8: FY(),
        CFB1: zY(),
        OFB: jY(),
        CTR: c5(),
        GCM: c5()
    }, t = mO;
    for(var r in t)t[r].module = e[t[r].mode];
    return jv = t, jv;
}
var Hv = {}, f5;
function Eb() {
    if (f5) return Hv;
    f5 = 1;
    var e = Ar().Buffer;
    function t(a) {
        e.isBuffer(a) || (a = e.from(a));
        for(var u = a.length / 4 | 0, f = new Array(u), c = 0; c < u; c++)f[c] = a.readUInt32BE(c * 4);
        return f;
    }
    function r(a) {
        for(var u = 0; u < a.length; a++)a[u] = 0;
    }
    function n(a, u, f, c, l) {
        for(var p = f[0], y = f[1], _ = f[2], A = f[3], O = a[0] ^ u[0], N = a[1] ^ u[1], U = a[2] ^ u[2], D = a[3] ^ u[3], H, K, re, Q, G = 4, R = 1; R < l; R++)H = p[O >>> 24] ^ y[N >>> 16 & 255] ^ _[U >>> 8 & 255] ^ A[D & 255] ^ u[G++], K = p[N >>> 24] ^ y[U >>> 16 & 255] ^ _[D >>> 8 & 255] ^ A[O & 255] ^ u[G++], re = p[U >>> 24] ^ y[D >>> 16 & 255] ^ _[O >>> 8 & 255] ^ A[N & 255] ^ u[G++], Q = p[D >>> 24] ^ y[O >>> 16 & 255] ^ _[N >>> 8 & 255] ^ A[U & 255] ^ u[G++], O = H, N = K, U = re, D = Q;
        return H = (c[O >>> 24] << 24 | c[N >>> 16 & 255] << 16 | c[U >>> 8 & 255] << 8 | c[D & 255]) ^ u[G++], K = (c[N >>> 24] << 24 | c[U >>> 16 & 255] << 16 | c[D >>> 8 & 255] << 8 | c[O & 255]) ^ u[G++], re = (c[U >>> 24] << 24 | c[D >>> 16 & 255] << 16 | c[O >>> 8 & 255] << 8 | c[N & 255]) ^ u[G++], Q = (c[D >>> 24] << 24 | c[O >>> 16 & 255] << 16 | c[N >>> 8 & 255] << 8 | c[U & 255]) ^ u[G++], H = H >>> 0, K = K >>> 0, re = re >>> 0, Q = Q >>> 0, [
            H,
            K,
            re,
            Q
        ];
    }
    var i = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], o = function() {
        for(var a = new Array(256), u = 0; u < 256; u++)u < 128 ? a[u] = u << 1 : a[u] = u << 1 ^ 283;
        for(var f = [], c = [], l = [
            [],
            [],
            [],
            []
        ], p = [
            [],
            [],
            [],
            []
        ], y = 0, _ = 0, A = 0; A < 256; ++A){
            var O = _ ^ _ << 1 ^ _ << 2 ^ _ << 3 ^ _ << 4;
            O = O >>> 8 ^ O & 255 ^ 99, f[y] = O, c[O] = y;
            var N = a[y], U = a[N], D = a[U], H = a[O] * 257 ^ O * 16843008;
            l[0][y] = H << 24 | H >>> 8, l[1][y] = H << 16 | H >>> 16, l[2][y] = H << 8 | H >>> 24, l[3][y] = H, H = D * 16843009 ^ U * 65537 ^ N * 257 ^ y * 16843008, p[0][O] = H << 24 | H >>> 8, p[1][O] = H << 16 | H >>> 16, p[2][O] = H << 8 | H >>> 24, p[3][O] = H, y === 0 ? y = _ = 1 : (y = N ^ a[a[a[D ^ N]]], _ ^= a[a[_]]);
        }
        return {
            SBOX: f,
            INV_SBOX: c,
            SUB_MIX: l,
            INV_SUB_MIX: p
        };
    }();
    function s(a) {
        this._key = t(a), this._reset();
    }
    return s.blockSize = 4 * 4, s.keySize = 256 / 8, s.prototype.blockSize = s.blockSize, s.prototype.keySize = s.keySize, s.prototype._reset = function() {
        for(var a = this._key, u = a.length, f = u + 6, c = (f + 1) * 4, l = [], p = 0; p < u; p++)l[p] = a[p];
        for(p = u; p < c; p++){
            var y = l[p - 1];
            p % u === 0 ? (y = y << 8 | y >>> 24, y = o.SBOX[y >>> 24] << 24 | o.SBOX[y >>> 16 & 255] << 16 | o.SBOX[y >>> 8 & 255] << 8 | o.SBOX[y & 255], y ^= i[p / u | 0] << 24) : u > 6 && p % u === 4 && (y = o.SBOX[y >>> 24] << 24 | o.SBOX[y >>> 16 & 255] << 16 | o.SBOX[y >>> 8 & 255] << 8 | o.SBOX[y & 255]), l[p] = l[p - u] ^ y;
        }
        for(var _ = [], A = 0; A < c; A++){
            var O = c - A, N = l[O - (A % 4 ? 0 : 4)];
            A < 4 || O <= 4 ? _[A] = N : _[A] = o.INV_SUB_MIX[0][o.SBOX[N >>> 24]] ^ o.INV_SUB_MIX[1][o.SBOX[N >>> 16 & 255]] ^ o.INV_SUB_MIX[2][o.SBOX[N >>> 8 & 255]] ^ o.INV_SUB_MIX[3][o.SBOX[N & 255]];
        }
        this._nRounds = f, this._keySchedule = l, this._invKeySchedule = _;
    }, s.prototype.encryptBlockRaw = function(a) {
        return a = t(a), n(a, this._keySchedule, o.SUB_MIX, o.SBOX, this._nRounds);
    }, s.prototype.encryptBlock = function(a) {
        var u = this.encryptBlockRaw(a), f = e.allocUnsafe(16);
        return f.writeUInt32BE(u[0], 0), f.writeUInt32BE(u[1], 4), f.writeUInt32BE(u[2], 8), f.writeUInt32BE(u[3], 12), f;
    }, s.prototype.decryptBlock = function(a) {
        a = t(a);
        var u = a[1];
        a[1] = a[3], a[3] = u;
        var f = n(a, this._invKeySchedule, o.INV_SUB_MIX, o.INV_SBOX, this._nRounds), c = e.allocUnsafe(16);
        return c.writeUInt32BE(f[0], 0), c.writeUInt32BE(f[3], 4), c.writeUInt32BE(f[2], 8), c.writeUInt32BE(f[1], 12), c;
    }, s.prototype.scrub = function() {
        r(this._keySchedule), r(this._invKeySchedule), r(this._key);
    }, Hv.AES = s, Hv;
}
var qv, l5;
function WY() {
    if (l5) return qv;
    l5 = 1;
    var e = Ar().Buffer, t = e.alloc(16, 0);
    function r(o) {
        return [
            o.readUInt32BE(0),
            o.readUInt32BE(4),
            o.readUInt32BE(8),
            o.readUInt32BE(12)
        ];
    }
    function n(o) {
        var s = e.allocUnsafe(16);
        return s.writeUInt32BE(o[0] >>> 0, 0), s.writeUInt32BE(o[1] >>> 0, 4), s.writeUInt32BE(o[2] >>> 0, 8), s.writeUInt32BE(o[3] >>> 0, 12), s;
    }
    function i(o) {
        this.h = o, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
    }
    return i.prototype.ghash = function(o) {
        for(var s = -1; ++s < o.length;)this.state[s] ^= o[s];
        this._multiply();
    }, i.prototype._multiply = function() {
        for(var o = r(this.h), s = [
            0,
            0,
            0,
            0
        ], a, u, f, c = -1; ++c < 128;){
            for(u = (this.state[~~(c / 8)] & 1 << 7 - c % 8) !== 0, u && (s[0] ^= o[0], s[1] ^= o[1], s[2] ^= o[2], s[3] ^= o[3]), f = (o[3] & 1) !== 0, a = 3; a > 0; a--)o[a] = o[a] >>> 1 | (o[a - 1] & 1) << 31;
            o[0] = o[0] >>> 1, f && (o[0] = o[0] ^ 225 << 24);
        }
        this.state = n(s);
    }, i.prototype.update = function(o) {
        this.cache = e.concat([
            this.cache,
            o
        ]);
        for(var s; this.cache.length >= 16;)s = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(s);
    }, i.prototype.final = function(o, s) {
        return this.cache.length && this.ghash(e.concat([
            this.cache,
            t
        ], 16)), this.ghash(n([
            0,
            o,
            0,
            s
        ])), this.state;
    }, qv = i, qv;
}
var Kv, d5;
function bO() {
    if (d5) return Kv;
    d5 = 1;
    var e = Eb(), t = Ar().Buffer, r = Bu(), n = Or(), i = WY(), o = i0(), s = yO();
    function a(c, l) {
        var p = 0;
        c.length !== l.length && p++;
        for(var y = Math.min(c.length, l.length), _ = 0; _ < y; ++_)p += c[_] ^ l[_];
        return p;
    }
    function u(c, l, p) {
        if (l.length === 12) return c._finID = t.concat([
            l,
            t.from([
                0,
                0,
                0,
                1
            ])
        ]), t.concat([
            l,
            t.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var y = new i(p), _ = l.length, A = _ % 16;
        y.update(l), A && (A = 16 - A, y.update(t.alloc(A, 0))), y.update(t.alloc(8, 0));
        var O = _ * 8, N = t.alloc(8);
        N.writeUIntBE(O, 0, 8), y.update(N), c._finID = y.state;
        var U = t.from(c._finID);
        return s(U), U;
    }
    function f(c, l, p, y) {
        r.call(this);
        var _ = t.alloc(4, 0);
        this._cipher = new e.AES(l);
        var A = this._cipher.encryptBlock(_);
        this._ghash = new i(A), p = u(this, p, A), this._prev = t.from(p), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = y, this._alen = 0, this._len = 0, this._mode = c, this._authTag = null, this._called = !1;
    }
    return n(f, r), f.prototype._update = function(c) {
        if (!this._called && this._alen) {
            var l = 16 - this._alen % 16;
            l < 16 && (l = t.alloc(l, 0), this._ghash.update(l));
        }
        this._called = !0;
        var p = this._mode.encrypt(this, c);
        return this._decrypt ? this._ghash.update(c) : this._ghash.update(p), this._len += c.length, p;
    }, f.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var c = o(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && a(c, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = c, this._cipher.scrub();
    }, f.prototype.getAuthTag = function() {
        if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    }, f.prototype.setAuthTag = function(l) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = l;
    }, f.prototype.setAAD = function(l) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(l), this._alen += l.length;
    }, Kv = f, Kv;
}
var Wv, h5;
function wO() {
    if (h5) return Wv;
    h5 = 1;
    var e = Eb(), t = Ar().Buffer, r = Bu(), n = Or();
    function i(o, s, a, u) {
        r.call(this), this._cipher = new e.AES(s), this._prev = t.from(a), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = u, this._mode = o;
    }
    return n(i, r), i.prototype._update = function(o) {
        return this._mode.encrypt(this, o, this._decrypt);
    }, i.prototype._final = function() {
        this._cipher.scrub();
    }, Wv = i, Wv;
}
var Vv, p5;
function xb() {
    if (p5) return Vv;
    p5 = 1;
    var e = Ar().Buffer, t = N3();
    function r(n, i, o, s) {
        if (e.isBuffer(n) || (n = e.from(n, "binary")), i && (e.isBuffer(i) || (i = e.from(i, "binary")), i.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
        for(var a = o / 8, u = e.alloc(a), f = e.alloc(s || 0), c = e.alloc(0); a > 0 || s > 0;){
            var l = new t();
            l.update(c), l.update(n), i && l.update(i), c = l.digest();
            var p = 0;
            if (a > 0) {
                var y = u.length - a;
                p = Math.min(a, c.length), c.copy(u, y, 0, p), a -= p;
            }
            if (p < c.length && s > 0) {
                var _ = f.length - s, A = Math.min(s, c.length - p);
                c.copy(f, _, p, p + A), s -= A;
            }
        }
        return c.fill(0), {
            key: u,
            iv: f
        };
    }
    return Vv = r, Vv;
}
var g5;
function VY() {
    if (g5) return $g;
    g5 = 1;
    var e = U3(), t = bO(), r = Ar().Buffer, n = wO(), i = Bu(), o = Eb(), s = xb(), a = Or();
    function u(y, _, A) {
        i.call(this), this._cache = new c(), this._cipher = new o.AES(_), this._prev = r.from(A), this._mode = y, this._autopadding = !0;
    }
    a(u, i), u.prototype._update = function(y) {
        this._cache.add(y);
        for(var _, A, O = []; _ = this._cache.get();)A = this._mode.encrypt(this, _), O.push(A);
        return r.concat(O);
    };
    var f = r.alloc(16, 16);
    u.prototype._final = function() {
        var y = this._cache.flush();
        if (this._autopadding) return y = this._mode.encrypt(this, y), this._cipher.scrub(), y;
        if (!y.equals(f)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    }, u.prototype.setAutoPadding = function(y) {
        return this._autopadding = !!y, this;
    };
    function c() {
        this.cache = r.allocUnsafe(0);
    }
    c.prototype.add = function(y) {
        this.cache = r.concat([
            this.cache,
            y
        ]);
    }, c.prototype.get = function() {
        if (this.cache.length > 15) {
            var y = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), y;
        }
        return null;
    }, c.prototype.flush = function() {
        for(var y = 16 - this.cache.length, _ = r.allocUnsafe(y), A = -1; ++A < y;)_.writeUInt8(y, A);
        return r.concat([
            this.cache,
            _
        ]);
    };
    function l(y, _, A) {
        var O = e[y.toLowerCase()];
        if (!O) throw new TypeError("invalid suite type");
        if (typeof _ == "string" && (_ = r.from(_)), _.length !== O.key / 8) throw new TypeError("invalid key length " + _.length);
        if (typeof A == "string" && (A = r.from(A)), O.mode !== "GCM" && A.length !== O.iv) throw new TypeError("invalid iv length " + A.length);
        return O.type === "stream" ? new n(O.module, _, A) : O.type === "auth" ? new t(O.module, _, A) : new u(O.module, _, A);
    }
    function p(y, _) {
        var A = e[y.toLowerCase()];
        if (!A) throw new TypeError("invalid suite type");
        var O = s(_, !1, A.key, A.iv);
        return l(y, O.key, O.iv);
    }
    return $g.createCipheriv = l, $g.createCipher = p, $g;
}
var Fg = {}, y5;
function GY() {
    if (y5) return Fg;
    y5 = 1;
    var e = bO(), t = Ar().Buffer, r = U3(), n = wO(), i = Bu(), o = Eb(), s = xb(), a = Or();
    function u(y, _, A) {
        i.call(this), this._cache = new f(), this._last = void 0, this._cipher = new o.AES(_), this._prev = t.from(A), this._mode = y, this._autopadding = !0;
    }
    a(u, i), u.prototype._update = function(y) {
        this._cache.add(y);
        for(var _, A, O = []; _ = this._cache.get(this._autopadding);)A = this._mode.decrypt(this, _), O.push(A);
        return t.concat(O);
    }, u.prototype._final = function() {
        var y = this._cache.flush();
        if (this._autopadding) return c(this._mode.decrypt(this, y));
        if (y) throw new Error("data not multiple of block length");
    }, u.prototype.setAutoPadding = function(y) {
        return this._autopadding = !!y, this;
    };
    function f() {
        this.cache = t.allocUnsafe(0);
    }
    f.prototype.add = function(y) {
        this.cache = t.concat([
            this.cache,
            y
        ]);
    }, f.prototype.get = function(y) {
        var _;
        if (y) {
            if (this.cache.length > 16) return _ = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _;
        } else if (this.cache.length >= 16) return _ = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _;
        return null;
    }, f.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function c(y) {
        var _ = y[15];
        if (_ < 1 || _ > 16) throw new Error("unable to decrypt data");
        for(var A = -1; ++A < _;)if (y[A + (16 - _)] !== _) throw new Error("unable to decrypt data");
        if (_ !== 16) return y.slice(0, 16 - _);
    }
    function l(y, _, A) {
        var O = r[y.toLowerCase()];
        if (!O) throw new TypeError("invalid suite type");
        if (typeof A == "string" && (A = t.from(A)), O.mode !== "GCM" && A.length !== O.iv) throw new TypeError("invalid iv length " + A.length);
        if (typeof _ == "string" && (_ = t.from(_)), _.length !== O.key / 8) throw new TypeError("invalid key length " + _.length);
        return O.type === "stream" ? new n(O.module, _, A, !0) : O.type === "auth" ? new e(O.module, _, A, !0) : new u(O.module, _, A);
    }
    function p(y, _) {
        var A = r[y.toLowerCase()];
        if (!A) throw new TypeError("invalid suite type");
        var O = s(_, !1, A.key, A.iv);
        return l(y, O.key, O.iv);
    }
    return Fg.createDecipher = p, Fg.createDecipheriv = l, Fg;
}
var m5;
function $3() {
    if (m5) return Yo;
    m5 = 1;
    var e = VY(), t = GY(), r = mO;
    function n() {
        return Object.keys(r);
    }
    return Yo.createCipher = Yo.Cipher = e.createCipher, Yo.createCipheriv = Yo.Cipheriv = e.createCipheriv, Yo.createDecipher = Yo.Decipher = t.createDecipher, Yo.createDecipheriv = Yo.Decipheriv = t.createDecipheriv, Yo.listCiphers = Yo.getCiphers = n, Yo;
}
var Gv = {}, b5;
function ZY() {
    return b5 || (b5 = 1, function(e) {
        e["des-ecb"] = {
            key: 8,
            iv: 0
        }, e["des-cbc"] = e.des = {
            key: 8,
            iv: 8
        }, e["des-ede3-cbc"] = e.des3 = {
            key: 24,
            iv: 8
        }, e["des-ede3"] = {
            key: 24,
            iv: 0
        }, e["des-ede-cbc"] = {
            key: 16,
            iv: 8
        }, e["des-ede"] = {
            key: 16,
            iv: 0
        };
    }(Gv)), Gv;
}
var w5;
function YY() {
    if (w5) return Zo;
    w5 = 1;
    var e = UY(), t = $3(), r = U3(), n = ZY(), i = xb();
    function o(c, l) {
        c = c.toLowerCase();
        var p, y;
        if (r[c]) p = r[c].key, y = r[c].iv;
        else if (n[c]) p = n[c].key * 8, y = n[c].iv;
        else throw new TypeError("invalid suite type");
        var _ = i(l, !1, p, y);
        return a(c, _.key, _.iv);
    }
    function s(c, l) {
        c = c.toLowerCase();
        var p, y;
        if (r[c]) p = r[c].key, y = r[c].iv;
        else if (n[c]) p = n[c].key * 8, y = n[c].iv;
        else throw new TypeError("invalid suite type");
        var _ = i(l, !1, p, y);
        return u(c, _.key, _.iv);
    }
    function a(c, l, p) {
        if (c = c.toLowerCase(), r[c]) return t.createCipheriv(c, l, p);
        if (n[c]) return new e({
            key: l,
            iv: p,
            mode: c
        });
        throw new TypeError("invalid suite type");
    }
    function u(c, l, p) {
        if (c = c.toLowerCase(), r[c]) return t.createDecipheriv(c, l, p);
        if (n[c]) return new e({
            key: l,
            iv: p,
            mode: c,
            decrypt: !0
        });
        throw new TypeError("invalid suite type");
    }
    function f() {
        return Object.keys(n).concat(t.getCiphers());
    }
    return Zo.createCipher = Zo.Cipher = o, Zo.createCipheriv = Zo.Cipheriv = a, Zo.createDecipher = Zo.Decipher = s, Zo.createDecipheriv = Zo.Decipheriv = u, Zo.listCiphers = Zo.getCiphers = f, Zo;
}
var qu = {}, ky = {
    exports: {}
};
ky.exports;
var v5;
function bi() {
    return v5 || (v5 = 1, function(e) {
        (function(t, r) {
            function n($, S) {
                if (!$) throw new Error(S || "Assertion failed");
            }
            function i($, S) {
                $.super_ = S;
                var w = function() {};
                w.prototype = S.prototype, $.prototype = new w(), $.prototype.constructor = $;
            }
            function o($, S, w) {
                if (o.isBN($)) return $;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, $ !== null && ((S === "le" || S === "be") && (w = S, S = 10), this._init($ || 0, S || 10, w || "be"));
            }
            typeof t == "object" ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
            var s;
            try {
                ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = Iu.Buffer;
            } catch  {}
            o.isBN = function(S) {
                return S instanceof o ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === o.wordSize && Array.isArray(S.words);
            }, o.max = function(S, w) {
                return S.cmp(w) > 0 ? S : w;
            }, o.min = function(S, w) {
                return S.cmp(w) < 0 ? S : w;
            }, o.prototype._init = function(S, w, g) {
                if (typeof S == "number") return this._initNumber(S, w, g);
                if (typeof S == "object") return this._initArray(S, w, g);
                w === "hex" && (w = 16), n(w === (w | 0) && w >= 2 && w <= 36), S = S.toString().replace(/\s+/g, "");
                var m = 0;
                S[0] === "-" && (m++, this.negative = 1), m < S.length && (w === 16 ? this._parseHex(S, m, g) : (this._parseBase(S, w, m), g === "le" && this._initArray(this.toArray(), w, g)));
            }, o.prototype._initNumber = function(S, w, g) {
                S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [
                    S & 67108863
                ], this.length = 1) : S < 4503599627370496 ? (this.words = [
                    S & 67108863,
                    S / 67108864 & 67108863
                ], this.length = 2) : (n(S < 9007199254740992), this.words = [
                    S & 67108863,
                    S / 67108864 & 67108863,
                    1
                ], this.length = 3), g === "le" && this._initArray(this.toArray(), w, g);
            }, o.prototype._initArray = function(S, w, g) {
                if (n(typeof S.length == "number"), S.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
                for(var m = 0; m < this.length; m++)this.words[m] = 0;
                var E, T, I = 0;
                if (g === "be") for(m = S.length - 1, E = 0; m >= 0; m -= 3)T = S[m] | S[m - 1] << 8 | S[m - 2] << 16, this.words[E] |= T << I & 67108863, this.words[E + 1] = T >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, E++);
                else if (g === "le") for(m = 0, E = 0; m < S.length; m += 3)T = S[m] | S[m + 1] << 8 | S[m + 2] << 16, this.words[E] |= T << I & 67108863, this.words[E + 1] = T >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, E++);
                return this.strip();
            };
            function a($, S) {
                var w = $.charCodeAt(S);
                return w >= 65 && w <= 70 ? w - 55 : w >= 97 && w <= 102 ? w - 87 : w - 48 & 15;
            }
            function u($, S, w) {
                var g = a($, w);
                return w - 1 >= S && (g |= a($, w - 1) << 4), g;
            }
            o.prototype._parseHex = function(S, w, g) {
                this.length = Math.ceil((S.length - w) / 6), this.words = new Array(this.length);
                for(var m = 0; m < this.length; m++)this.words[m] = 0;
                var E = 0, T = 0, I;
                if (g === "be") for(m = S.length - 1; m >= w; m -= 2)I = u(S, w, m) << E, this.words[T] |= I & 67108863, E >= 18 ? (E -= 18, T += 1, this.words[T] |= I >>> 26) : E += 8;
                else {
                    var P = S.length - w;
                    for(m = P % 2 === 0 ? w + 1 : w; m < S.length; m += 2)I = u(S, w, m) << E, this.words[T] |= I & 67108863, E >= 18 ? (E -= 18, T += 1, this.words[T] |= I >>> 26) : E += 8;
                }
                this.strip();
            };
            function f($, S, w, g) {
                for(var m = 0, E = Math.min($.length, w), T = S; T < E; T++){
                    var I = $.charCodeAt(T) - 48;
                    m *= g, I >= 49 ? m += I - 49 + 10 : I >= 17 ? m += I - 17 + 10 : m += I;
                }
                return m;
            }
            o.prototype._parseBase = function(S, w, g) {
                this.words = [
                    0
                ], this.length = 1;
                for(var m = 0, E = 1; E <= 67108863; E *= w)m++;
                m--, E = E / w | 0;
                for(var T = S.length - g, I = T % m, P = Math.min(T, T - I) + g, k = 0, L = g; L < P; L += m)k = f(S, L, L + m, w), this.imuln(E), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
                if (I !== 0) {
                    var j = 1;
                    for(k = f(S, L, S.length, w), L = 0; L < I; L++)j *= w;
                    this.imuln(j), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
                }
                this.strip();
            }, o.prototype.copy = function(S) {
                S.words = new Array(this.length);
                for(var w = 0; w < this.length; w++)S.words[w] = this.words[w];
                S.length = this.length, S.negative = this.negative, S.red = this.red;
            }, o.prototype.clone = function() {
                var S = new o(null);
                return this.copy(S), S;
            }, o.prototype._expand = function(S) {
                for(; this.length < S;)this.words[this.length++] = 0;
                return this;
            }, o.prototype.strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, o.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, o.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var c = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], l = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], p = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            o.prototype.toString = function(S, w) {
                S = S || 10, w = w | 0 || 1;
                var g;
                if (S === 16 || S === "hex") {
                    g = "";
                    for(var m = 0, E = 0, T = 0; T < this.length; T++){
                        var I = this.words[T], P = ((I << m | E) & 16777215).toString(16);
                        E = I >>> 24 - m & 16777215, m += 2, m >= 26 && (m -= 26, T--), E !== 0 || T !== this.length - 1 ? g = c[6 - P.length] + P + g : g = P + g;
                    }
                    for(E !== 0 && (g = E.toString(16) + g); g.length % w !== 0;)g = "0" + g;
                    return this.negative !== 0 && (g = "-" + g), g;
                }
                if (S === (S | 0) && S >= 2 && S <= 36) {
                    var k = l[S], L = p[S];
                    g = "";
                    var j = this.clone();
                    for(j.negative = 0; !j.isZero();){
                        var ie = j.modn(L).toString(S);
                        j = j.idivn(L), j.isZero() ? g = ie + g : g = c[k - ie.length] + ie + g;
                    }
                    for(this.isZero() && (g = "0" + g); g.length % w !== 0;)g = "0" + g;
                    return this.negative !== 0 && (g = "-" + g), g;
                }
                n(!1, "Base should be between 2 and 36");
            }, o.prototype.toNumber = function() {
                var S = this.words[0];
                return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
            }, o.prototype.toJSON = function() {
                return this.toString(16);
            }, o.prototype.toBuffer = function(S, w) {
                return n(typeof s < "u"), this.toArrayLike(s, S, w);
            }, o.prototype.toArray = function(S, w) {
                return this.toArrayLike(Array, S, w);
            }, o.prototype.toArrayLike = function(S, w, g) {
                var m = this.byteLength(), E = g || Math.max(1, m);
                n(m <= E, "byte array longer than desired length"), n(E > 0, "Requested array length <= 0"), this.strip();
                var T = w === "le", I = new S(E), P, k, L = this.clone();
                if (T) {
                    for(k = 0; !L.isZero(); k++)P = L.andln(255), L.iushrn(8), I[k] = P;
                    for(; k < E; k++)I[k] = 0;
                } else {
                    for(k = 0; k < E - m; k++)I[k] = 0;
                    for(k = 0; !L.isZero(); k++)P = L.andln(255), L.iushrn(8), I[E - k - 1] = P;
                }
                return I;
            }, Math.clz32 ? o.prototype._countBits = function(S) {
                return 32 - Math.clz32(S);
            } : o.prototype._countBits = function(S) {
                var w = S, g = 0;
                return w >= 4096 && (g += 13, w >>>= 13), w >= 64 && (g += 7, w >>>= 7), w >= 8 && (g += 4, w >>>= 4), w >= 2 && (g += 2, w >>>= 2), g + w;
            }, o.prototype._zeroBits = function(S) {
                if (S === 0) return 26;
                var w = S, g = 0;
                return w & 8191 || (g += 13, w >>>= 13), w & 127 || (g += 7, w >>>= 7), w & 15 || (g += 4, w >>>= 4), w & 3 || (g += 2, w >>>= 2), w & 1 || g++, g;
            }, o.prototype.bitLength = function() {
                var S = this.words[this.length - 1], w = this._countBits(S);
                return (this.length - 1) * 26 + w;
            };
            function y($) {
                for(var S = new Array($.bitLength()), w = 0; w < S.length; w++){
                    var g = w / 26 | 0, m = w % 26;
                    S[w] = ($.words[g] & 1 << m) >>> m;
                }
                return S;
            }
            o.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var S = 0, w = 0; w < this.length; w++){
                    var g = this._zeroBits(this.words[w]);
                    if (S += g, g !== 26) break;
                }
                return S;
            }, o.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, o.prototype.toTwos = function(S) {
                return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
            }, o.prototype.fromTwos = function(S) {
                return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
            }, o.prototype.isNeg = function() {
                return this.negative !== 0;
            }, o.prototype.neg = function() {
                return this.clone().ineg();
            }, o.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, o.prototype.iuor = function(S) {
                for(; this.length < S.length;)this.words[this.length++] = 0;
                for(var w = 0; w < S.length; w++)this.words[w] = this.words[w] | S.words[w];
                return this.strip();
            }, o.prototype.ior = function(S) {
                return n((this.negative | S.negative) === 0), this.iuor(S);
            }, o.prototype.or = function(S) {
                return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
            }, o.prototype.uor = function(S) {
                return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
            }, o.prototype.iuand = function(S) {
                var w;
                this.length > S.length ? w = S : w = this;
                for(var g = 0; g < w.length; g++)this.words[g] = this.words[g] & S.words[g];
                return this.length = w.length, this.strip();
            }, o.prototype.iand = function(S) {
                return n((this.negative | S.negative) === 0), this.iuand(S);
            }, o.prototype.and = function(S) {
                return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
            }, o.prototype.uand = function(S) {
                return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
            }, o.prototype.iuxor = function(S) {
                var w, g;
                this.length > S.length ? (w = this, g = S) : (w = S, g = this);
                for(var m = 0; m < g.length; m++)this.words[m] = w.words[m] ^ g.words[m];
                if (this !== w) for(; m < w.length; m++)this.words[m] = w.words[m];
                return this.length = w.length, this.strip();
            }, o.prototype.ixor = function(S) {
                return n((this.negative | S.negative) === 0), this.iuxor(S);
            }, o.prototype.xor = function(S) {
                return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
            }, o.prototype.uxor = function(S) {
                return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
            }, o.prototype.inotn = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = Math.ceil(S / 26) | 0, g = S % 26;
                this._expand(w), g > 0 && w--;
                for(var m = 0; m < w; m++)this.words[m] = ~this.words[m] & 67108863;
                return g > 0 && (this.words[m] = ~this.words[m] & 67108863 >> 26 - g), this.strip();
            }, o.prototype.notn = function(S) {
                return this.clone().inotn(S);
            }, o.prototype.setn = function(S, w) {
                n(typeof S == "number" && S >= 0);
                var g = S / 26 | 0, m = S % 26;
                return this._expand(g + 1), w ? this.words[g] = this.words[g] | 1 << m : this.words[g] = this.words[g] & ~(1 << m), this.strip();
            }, o.prototype.iadd = function(S) {
                var w;
                if (this.negative !== 0 && S.negative === 0) return this.negative = 0, w = this.isub(S), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && S.negative !== 0) return S.negative = 0, w = this.isub(S), S.negative = 1, w._normSign();
                var g, m;
                this.length > S.length ? (g = this, m = S) : (g = S, m = this);
                for(var E = 0, T = 0; T < m.length; T++)w = (g.words[T] | 0) + (m.words[T] | 0) + E, this.words[T] = w & 67108863, E = w >>> 26;
                for(; E !== 0 && T < g.length; T++)w = (g.words[T] | 0) + E, this.words[T] = w & 67108863, E = w >>> 26;
                if (this.length = g.length, E !== 0) this.words[this.length] = E, this.length++;
                else if (g !== this) for(; T < g.length; T++)this.words[T] = g.words[T];
                return this;
            }, o.prototype.add = function(S) {
                var w;
                return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, w = this.sub(S), S.negative ^= 1, w) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, w = S.sub(this), this.negative = 1, w) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
            }, o.prototype.isub = function(S) {
                if (S.negative !== 0) {
                    S.negative = 0;
                    var w = this.iadd(S);
                    return S.negative = 1, w._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
                var g = this.cmp(S);
                if (g === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var m, E;
                g > 0 ? (m = this, E = S) : (m = S, E = this);
                for(var T = 0, I = 0; I < E.length; I++)w = (m.words[I] | 0) - (E.words[I] | 0) + T, T = w >> 26, this.words[I] = w & 67108863;
                for(; T !== 0 && I < m.length; I++)w = (m.words[I] | 0) + T, T = w >> 26, this.words[I] = w & 67108863;
                if (T === 0 && I < m.length && m !== this) for(; I < m.length; I++)this.words[I] = m.words[I];
                return this.length = Math.max(this.length, I), m !== this && (this.negative = 1), this.strip();
            }, o.prototype.sub = function(S) {
                return this.clone().isub(S);
            };
            function _($, S, w) {
                w.negative = S.negative ^ $.negative;
                var g = $.length + S.length | 0;
                w.length = g, g = g - 1 | 0;
                var m = $.words[0] | 0, E = S.words[0] | 0, T = m * E, I = T & 67108863, P = T / 67108864 | 0;
                w.words[0] = I;
                for(var k = 1; k < g; k++){
                    for(var L = P >>> 26, j = P & 67108863, ie = Math.min(k, S.length - 1), ue = Math.max(0, k - $.length + 1); ue <= ie; ue++){
                        var ce = k - ue | 0;
                        m = $.words[ce] | 0, E = S.words[ue] | 0, T = m * E + j, L += T / 67108864 | 0, j = T & 67108863;
                    }
                    w.words[k] = j | 0, P = L | 0;
                }
                return P !== 0 ? w.words[k] = P | 0 : w.length--, w.strip();
            }
            var A = function(S, w, g) {
                var m = S.words, E = w.words, T = g.words, I = 0, P, k, L, j = m[0] | 0, ie = j & 8191, ue = j >>> 13, ce = m[1] | 0, he = ce & 8191, ee = ce >>> 13, ae = m[2] | 0, ye = ae & 8191, Se = ae >>> 13, De = m[3] | 0, Re = De & 8191, Ce = De >>> 13, M = m[4] | 0, z = M & 8191, de = M >>> 13, _e = m[5] | 0, Ie = _e & 8191, je = _e >>> 13, Ke = m[6] | 0, Ue = Ke & 8191, h = Ke >>> 13, x = m[7] | 0, q = x & 8191, te = x >>> 13, fe = m[8] | 0, ne = fe & 8191, W = fe >>> 13, J = m[9] | 0, V = J & 8191, C = J >>> 13, Z = E[0] | 0, le = Z & 8191, se = Z >>> 13, Ne = E[1] | 0, Le = Ne & 8191, rt = Ne >>> 13, yt = E[2] | 0, _t = yt & 8191, Qe = yt >>> 13, Rt = E[3] | 0, Lt = Rt & 8191, Ur = Rt >>> 13, jr = E[4] | 0, Et = jr & 8191, Xt = jr >>> 13, wr = E[5] | 0, zt = wr & 8191, Ae = wr >>> 13, we = E[6] | 0, xe = we & 8191, Me = we >>> 13, ze = E[7] | 0, Ve = ze & 8191, at = ze >>> 13, ct = E[8] | 0, lt = ct & 8191, mt = ct >>> 13, wt = E[9] | 0, bt = wt & 8191, Mt = wt >>> 13;
                g.negative = S.negative ^ w.negative, g.length = 19, P = Math.imul(ie, le), k = Math.imul(ie, se), k = k + Math.imul(ue, le) | 0, L = Math.imul(ue, se);
                var Ct = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(he, le), k = Math.imul(he, se), k = k + Math.imul(ee, le) | 0, L = Math.imul(ee, se), P = P + Math.imul(ie, Le) | 0, k = k + Math.imul(ie, rt) | 0, k = k + Math.imul(ue, Le) | 0, L = L + Math.imul(ue, rt) | 0;
                var Xe = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, P = Math.imul(ye, le), k = Math.imul(ye, se), k = k + Math.imul(Se, le) | 0, L = Math.imul(Se, se), P = P + Math.imul(he, Le) | 0, k = k + Math.imul(he, rt) | 0, k = k + Math.imul(ee, Le) | 0, L = L + Math.imul(ee, rt) | 0, P = P + Math.imul(ie, _t) | 0, k = k + Math.imul(ie, Qe) | 0, k = k + Math.imul(ue, _t) | 0, L = L + Math.imul(ue, Qe) | 0;
                var xt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(Re, le), k = Math.imul(Re, se), k = k + Math.imul(Ce, le) | 0, L = Math.imul(Ce, se), P = P + Math.imul(ye, Le) | 0, k = k + Math.imul(ye, rt) | 0, k = k + Math.imul(Se, Le) | 0, L = L + Math.imul(Se, rt) | 0, P = P + Math.imul(he, _t) | 0, k = k + Math.imul(he, Qe) | 0, k = k + Math.imul(ee, _t) | 0, L = L + Math.imul(ee, Qe) | 0, P = P + Math.imul(ie, Lt) | 0, k = k + Math.imul(ie, Ur) | 0, k = k + Math.imul(ue, Lt) | 0, L = L + Math.imul(ue, Ur) | 0;
                var St = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(z, le), k = Math.imul(z, se), k = k + Math.imul(de, le) | 0, L = Math.imul(de, se), P = P + Math.imul(Re, Le) | 0, k = k + Math.imul(Re, rt) | 0, k = k + Math.imul(Ce, Le) | 0, L = L + Math.imul(Ce, rt) | 0, P = P + Math.imul(ye, _t) | 0, k = k + Math.imul(ye, Qe) | 0, k = k + Math.imul(Se, _t) | 0, L = L + Math.imul(Se, Qe) | 0, P = P + Math.imul(he, Lt) | 0, k = k + Math.imul(he, Ur) | 0, k = k + Math.imul(ee, Lt) | 0, L = L + Math.imul(ee, Ur) | 0, P = P + Math.imul(ie, Et) | 0, k = k + Math.imul(ie, Xt) | 0, k = k + Math.imul(ue, Et) | 0, L = L + Math.imul(ue, Xt) | 0;
                var Pe = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, P = Math.imul(Ie, le), k = Math.imul(Ie, se), k = k + Math.imul(je, le) | 0, L = Math.imul(je, se), P = P + Math.imul(z, Le) | 0, k = k + Math.imul(z, rt) | 0, k = k + Math.imul(de, Le) | 0, L = L + Math.imul(de, rt) | 0, P = P + Math.imul(Re, _t) | 0, k = k + Math.imul(Re, Qe) | 0, k = k + Math.imul(Ce, _t) | 0, L = L + Math.imul(Ce, Qe) | 0, P = P + Math.imul(ye, Lt) | 0, k = k + Math.imul(ye, Ur) | 0, k = k + Math.imul(Se, Lt) | 0, L = L + Math.imul(Se, Ur) | 0, P = P + Math.imul(he, Et) | 0, k = k + Math.imul(he, Xt) | 0, k = k + Math.imul(ee, Et) | 0, L = L + Math.imul(ee, Xt) | 0, P = P + Math.imul(ie, zt) | 0, k = k + Math.imul(ie, Ae) | 0, k = k + Math.imul(ue, zt) | 0, L = L + Math.imul(ue, Ae) | 0;
                var et = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, P = Math.imul(Ue, le), k = Math.imul(Ue, se), k = k + Math.imul(h, le) | 0, L = Math.imul(h, se), P = P + Math.imul(Ie, Le) | 0, k = k + Math.imul(Ie, rt) | 0, k = k + Math.imul(je, Le) | 0, L = L + Math.imul(je, rt) | 0, P = P + Math.imul(z, _t) | 0, k = k + Math.imul(z, Qe) | 0, k = k + Math.imul(de, _t) | 0, L = L + Math.imul(de, Qe) | 0, P = P + Math.imul(Re, Lt) | 0, k = k + Math.imul(Re, Ur) | 0, k = k + Math.imul(Ce, Lt) | 0, L = L + Math.imul(Ce, Ur) | 0, P = P + Math.imul(ye, Et) | 0, k = k + Math.imul(ye, Xt) | 0, k = k + Math.imul(Se, Et) | 0, L = L + Math.imul(Se, Xt) | 0, P = P + Math.imul(he, zt) | 0, k = k + Math.imul(he, Ae) | 0, k = k + Math.imul(ee, zt) | 0, L = L + Math.imul(ee, Ae) | 0, P = P + Math.imul(ie, xe) | 0, k = k + Math.imul(ie, Me) | 0, k = k + Math.imul(ue, xe) | 0, L = L + Math.imul(ue, Me) | 0;
                var vt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(q, le), k = Math.imul(q, se), k = k + Math.imul(te, le) | 0, L = Math.imul(te, se), P = P + Math.imul(Ue, Le) | 0, k = k + Math.imul(Ue, rt) | 0, k = k + Math.imul(h, Le) | 0, L = L + Math.imul(h, rt) | 0, P = P + Math.imul(Ie, _t) | 0, k = k + Math.imul(Ie, Qe) | 0, k = k + Math.imul(je, _t) | 0, L = L + Math.imul(je, Qe) | 0, P = P + Math.imul(z, Lt) | 0, k = k + Math.imul(z, Ur) | 0, k = k + Math.imul(de, Lt) | 0, L = L + Math.imul(de, Ur) | 0, P = P + Math.imul(Re, Et) | 0, k = k + Math.imul(Re, Xt) | 0, k = k + Math.imul(Ce, Et) | 0, L = L + Math.imul(Ce, Xt) | 0, P = P + Math.imul(ye, zt) | 0, k = k + Math.imul(ye, Ae) | 0, k = k + Math.imul(Se, zt) | 0, L = L + Math.imul(Se, Ae) | 0, P = P + Math.imul(he, xe) | 0, k = k + Math.imul(he, Me) | 0, k = k + Math.imul(ee, xe) | 0, L = L + Math.imul(ee, Me) | 0, P = P + Math.imul(ie, Ve) | 0, k = k + Math.imul(ie, at) | 0, k = k + Math.imul(ue, Ve) | 0, L = L + Math.imul(ue, at) | 0;
                var be = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, P = Math.imul(ne, le), k = Math.imul(ne, se), k = k + Math.imul(W, le) | 0, L = Math.imul(W, se), P = P + Math.imul(q, Le) | 0, k = k + Math.imul(q, rt) | 0, k = k + Math.imul(te, Le) | 0, L = L + Math.imul(te, rt) | 0, P = P + Math.imul(Ue, _t) | 0, k = k + Math.imul(Ue, Qe) | 0, k = k + Math.imul(h, _t) | 0, L = L + Math.imul(h, Qe) | 0, P = P + Math.imul(Ie, Lt) | 0, k = k + Math.imul(Ie, Ur) | 0, k = k + Math.imul(je, Lt) | 0, L = L + Math.imul(je, Ur) | 0, P = P + Math.imul(z, Et) | 0, k = k + Math.imul(z, Xt) | 0, k = k + Math.imul(de, Et) | 0, L = L + Math.imul(de, Xt) | 0, P = P + Math.imul(Re, zt) | 0, k = k + Math.imul(Re, Ae) | 0, k = k + Math.imul(Ce, zt) | 0, L = L + Math.imul(Ce, Ae) | 0, P = P + Math.imul(ye, xe) | 0, k = k + Math.imul(ye, Me) | 0, k = k + Math.imul(Se, xe) | 0, L = L + Math.imul(Se, Me) | 0, P = P + Math.imul(he, Ve) | 0, k = k + Math.imul(he, at) | 0, k = k + Math.imul(ee, Ve) | 0, L = L + Math.imul(ee, at) | 0, P = P + Math.imul(ie, lt) | 0, k = k + Math.imul(ie, mt) | 0, k = k + Math.imul(ue, lt) | 0, L = L + Math.imul(ue, mt) | 0;
                var $r = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, P = Math.imul(V, le), k = Math.imul(V, se), k = k + Math.imul(C, le) | 0, L = Math.imul(C, se), P = P + Math.imul(ne, Le) | 0, k = k + Math.imul(ne, rt) | 0, k = k + Math.imul(W, Le) | 0, L = L + Math.imul(W, rt) | 0, P = P + Math.imul(q, _t) | 0, k = k + Math.imul(q, Qe) | 0, k = k + Math.imul(te, _t) | 0, L = L + Math.imul(te, Qe) | 0, P = P + Math.imul(Ue, Lt) | 0, k = k + Math.imul(Ue, Ur) | 0, k = k + Math.imul(h, Lt) | 0, L = L + Math.imul(h, Ur) | 0, P = P + Math.imul(Ie, Et) | 0, k = k + Math.imul(Ie, Xt) | 0, k = k + Math.imul(je, Et) | 0, L = L + Math.imul(je, Xt) | 0, P = P + Math.imul(z, zt) | 0, k = k + Math.imul(z, Ae) | 0, k = k + Math.imul(de, zt) | 0, L = L + Math.imul(de, Ae) | 0, P = P + Math.imul(Re, xe) | 0, k = k + Math.imul(Re, Me) | 0, k = k + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Me) | 0, P = P + Math.imul(ye, Ve) | 0, k = k + Math.imul(ye, at) | 0, k = k + Math.imul(Se, Ve) | 0, L = L + Math.imul(Se, at) | 0, P = P + Math.imul(he, lt) | 0, k = k + Math.imul(he, mt) | 0, k = k + Math.imul(ee, lt) | 0, L = L + Math.imul(ee, mt) | 0, P = P + Math.imul(ie, bt) | 0, k = k + Math.imul(ie, Mt) | 0, k = k + Math.imul(ue, bt) | 0, L = L + Math.imul(ue, Mt) | 0;
                var jt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, P = Math.imul(V, Le), k = Math.imul(V, rt), k = k + Math.imul(C, Le) | 0, L = Math.imul(C, rt), P = P + Math.imul(ne, _t) | 0, k = k + Math.imul(ne, Qe) | 0, k = k + Math.imul(W, _t) | 0, L = L + Math.imul(W, Qe) | 0, P = P + Math.imul(q, Lt) | 0, k = k + Math.imul(q, Ur) | 0, k = k + Math.imul(te, Lt) | 0, L = L + Math.imul(te, Ur) | 0, P = P + Math.imul(Ue, Et) | 0, k = k + Math.imul(Ue, Xt) | 0, k = k + Math.imul(h, Et) | 0, L = L + Math.imul(h, Xt) | 0, P = P + Math.imul(Ie, zt) | 0, k = k + Math.imul(Ie, Ae) | 0, k = k + Math.imul(je, zt) | 0, L = L + Math.imul(je, Ae) | 0, P = P + Math.imul(z, xe) | 0, k = k + Math.imul(z, Me) | 0, k = k + Math.imul(de, xe) | 0, L = L + Math.imul(de, Me) | 0, P = P + Math.imul(Re, Ve) | 0, k = k + Math.imul(Re, at) | 0, k = k + Math.imul(Ce, Ve) | 0, L = L + Math.imul(Ce, at) | 0, P = P + Math.imul(ye, lt) | 0, k = k + Math.imul(ye, mt) | 0, k = k + Math.imul(Se, lt) | 0, L = L + Math.imul(Se, mt) | 0, P = P + Math.imul(he, bt) | 0, k = k + Math.imul(he, Mt) | 0, k = k + Math.imul(ee, bt) | 0, L = L + Math.imul(ee, Mt) | 0;
                var nr = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, P = Math.imul(V, _t), k = Math.imul(V, Qe), k = k + Math.imul(C, _t) | 0, L = Math.imul(C, Qe), P = P + Math.imul(ne, Lt) | 0, k = k + Math.imul(ne, Ur) | 0, k = k + Math.imul(W, Lt) | 0, L = L + Math.imul(W, Ur) | 0, P = P + Math.imul(q, Et) | 0, k = k + Math.imul(q, Xt) | 0, k = k + Math.imul(te, Et) | 0, L = L + Math.imul(te, Xt) | 0, P = P + Math.imul(Ue, zt) | 0, k = k + Math.imul(Ue, Ae) | 0, k = k + Math.imul(h, zt) | 0, L = L + Math.imul(h, Ae) | 0, P = P + Math.imul(Ie, xe) | 0, k = k + Math.imul(Ie, Me) | 0, k = k + Math.imul(je, xe) | 0, L = L + Math.imul(je, Me) | 0, P = P + Math.imul(z, Ve) | 0, k = k + Math.imul(z, at) | 0, k = k + Math.imul(de, Ve) | 0, L = L + Math.imul(de, at) | 0, P = P + Math.imul(Re, lt) | 0, k = k + Math.imul(Re, mt) | 0, k = k + Math.imul(Ce, lt) | 0, L = L + Math.imul(Ce, mt) | 0, P = P + Math.imul(ye, bt) | 0, k = k + Math.imul(ye, Mt) | 0, k = k + Math.imul(Se, bt) | 0, L = L + Math.imul(Se, Mt) | 0;
                var kt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, P = Math.imul(V, Lt), k = Math.imul(V, Ur), k = k + Math.imul(C, Lt) | 0, L = Math.imul(C, Ur), P = P + Math.imul(ne, Et) | 0, k = k + Math.imul(ne, Xt) | 0, k = k + Math.imul(W, Et) | 0, L = L + Math.imul(W, Xt) | 0, P = P + Math.imul(q, zt) | 0, k = k + Math.imul(q, Ae) | 0, k = k + Math.imul(te, zt) | 0, L = L + Math.imul(te, Ae) | 0, P = P + Math.imul(Ue, xe) | 0, k = k + Math.imul(Ue, Me) | 0, k = k + Math.imul(h, xe) | 0, L = L + Math.imul(h, Me) | 0, P = P + Math.imul(Ie, Ve) | 0, k = k + Math.imul(Ie, at) | 0, k = k + Math.imul(je, Ve) | 0, L = L + Math.imul(je, at) | 0, P = P + Math.imul(z, lt) | 0, k = k + Math.imul(z, mt) | 0, k = k + Math.imul(de, lt) | 0, L = L + Math.imul(de, mt) | 0, P = P + Math.imul(Re, bt) | 0, k = k + Math.imul(Re, Mt) | 0, k = k + Math.imul(Ce, bt) | 0, L = L + Math.imul(Ce, Mt) | 0;
                var Hn = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Hn >>> 26) | 0, Hn &= 67108863, P = Math.imul(V, Et), k = Math.imul(V, Xt), k = k + Math.imul(C, Et) | 0, L = Math.imul(C, Xt), P = P + Math.imul(ne, zt) | 0, k = k + Math.imul(ne, Ae) | 0, k = k + Math.imul(W, zt) | 0, L = L + Math.imul(W, Ae) | 0, P = P + Math.imul(q, xe) | 0, k = k + Math.imul(q, Me) | 0, k = k + Math.imul(te, xe) | 0, L = L + Math.imul(te, Me) | 0, P = P + Math.imul(Ue, Ve) | 0, k = k + Math.imul(Ue, at) | 0, k = k + Math.imul(h, Ve) | 0, L = L + Math.imul(h, at) | 0, P = P + Math.imul(Ie, lt) | 0, k = k + Math.imul(Ie, mt) | 0, k = k + Math.imul(je, lt) | 0, L = L + Math.imul(je, mt) | 0, P = P + Math.imul(z, bt) | 0, k = k + Math.imul(z, Mt) | 0, k = k + Math.imul(de, bt) | 0, L = L + Math.imul(de, Mt) | 0;
                var Zr = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, P = Math.imul(V, zt), k = Math.imul(V, Ae), k = k + Math.imul(C, zt) | 0, L = Math.imul(C, Ae), P = P + Math.imul(ne, xe) | 0, k = k + Math.imul(ne, Me) | 0, k = k + Math.imul(W, xe) | 0, L = L + Math.imul(W, Me) | 0, P = P + Math.imul(q, Ve) | 0, k = k + Math.imul(q, at) | 0, k = k + Math.imul(te, Ve) | 0, L = L + Math.imul(te, at) | 0, P = P + Math.imul(Ue, lt) | 0, k = k + Math.imul(Ue, mt) | 0, k = k + Math.imul(h, lt) | 0, L = L + Math.imul(h, mt) | 0, P = P + Math.imul(Ie, bt) | 0, k = k + Math.imul(Ie, Mt) | 0, k = k + Math.imul(je, bt) | 0, L = L + Math.imul(je, Mt) | 0;
                var v = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (v >>> 26) | 0, v &= 67108863, P = Math.imul(V, xe), k = Math.imul(V, Me), k = k + Math.imul(C, xe) | 0, L = Math.imul(C, Me), P = P + Math.imul(ne, Ve) | 0, k = k + Math.imul(ne, at) | 0, k = k + Math.imul(W, Ve) | 0, L = L + Math.imul(W, at) | 0, P = P + Math.imul(q, lt) | 0, k = k + Math.imul(q, mt) | 0, k = k + Math.imul(te, lt) | 0, L = L + Math.imul(te, mt) | 0, P = P + Math.imul(Ue, bt) | 0, k = k + Math.imul(Ue, Mt) | 0, k = k + Math.imul(h, bt) | 0, L = L + Math.imul(h, Mt) | 0;
                var B = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (B >>> 26) | 0, B &= 67108863, P = Math.imul(V, Ve), k = Math.imul(V, at), k = k + Math.imul(C, Ve) | 0, L = Math.imul(C, at), P = P + Math.imul(ne, lt) | 0, k = k + Math.imul(ne, mt) | 0, k = k + Math.imul(W, lt) | 0, L = L + Math.imul(W, mt) | 0, P = P + Math.imul(q, bt) | 0, k = k + Math.imul(q, Mt) | 0, k = k + Math.imul(te, bt) | 0, L = L + Math.imul(te, Mt) | 0;
                var Y = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Y >>> 26) | 0, Y &= 67108863, P = Math.imul(V, lt), k = Math.imul(V, mt), k = k + Math.imul(C, lt) | 0, L = Math.imul(C, mt), P = P + Math.imul(ne, bt) | 0, k = k + Math.imul(ne, Mt) | 0, k = k + Math.imul(W, bt) | 0, L = L + Math.imul(W, Mt) | 0;
                var pe = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (pe >>> 26) | 0, pe &= 67108863, P = Math.imul(V, bt), k = Math.imul(V, Mt), k = k + Math.imul(C, bt) | 0, L = Math.imul(C, Mt);
                var ke = (I + P | 0) + ((k & 8191) << 13) | 0;
                return I = (L + (k >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, T[0] = Ct, T[1] = Xe, T[2] = xt, T[3] = St, T[4] = Pe, T[5] = et, T[6] = vt, T[7] = be, T[8] = $r, T[9] = jt, T[10] = nr, T[11] = kt, T[12] = Hn, T[13] = Zr, T[14] = v, T[15] = B, T[16] = Y, T[17] = pe, T[18] = ke, I !== 0 && (T[19] = I, g.length++), g;
            };
            Math.imul || (A = _);
            function O($, S, w) {
                w.negative = S.negative ^ $.negative, w.length = $.length + S.length;
                for(var g = 0, m = 0, E = 0; E < w.length - 1; E++){
                    var T = m;
                    m = 0;
                    for(var I = g & 67108863, P = Math.min(E, S.length - 1), k = Math.max(0, E - $.length + 1); k <= P; k++){
                        var L = E - k, j = $.words[L] | 0, ie = S.words[k] | 0, ue = j * ie, ce = ue & 67108863;
                        T = T + (ue / 67108864 | 0) | 0, ce = ce + I | 0, I = ce & 67108863, T = T + (ce >>> 26) | 0, m += T >>> 26, T &= 67108863;
                    }
                    w.words[E] = I, g = T, T = m;
                }
                return g !== 0 ? w.words[E] = g : w.length--, w.strip();
            }
            function N($, S, w) {
                var g = new U();
                return g.mulp($, S, w);
            }
            o.prototype.mulTo = function(S, w) {
                var g, m = this.length + S.length;
                return this.length === 10 && S.length === 10 ? g = A(this, S, w) : m < 63 ? g = _(this, S, w) : m < 1024 ? g = O(this, S, w) : g = N(this, S, w), g;
            };
            function U($, S) {
                this.x = $, this.y = S;
            }
            U.prototype.makeRBT = function(S) {
                for(var w = new Array(S), g = o.prototype._countBits(S) - 1, m = 0; m < S; m++)w[m] = this.revBin(m, g, S);
                return w;
            }, U.prototype.revBin = function(S, w, g) {
                if (S === 0 || S === g - 1) return S;
                for(var m = 0, E = 0; E < w; E++)m |= (S & 1) << w - E - 1, S >>= 1;
                return m;
            }, U.prototype.permute = function(S, w, g, m, E, T) {
                for(var I = 0; I < T; I++)m[I] = w[S[I]], E[I] = g[S[I]];
            }, U.prototype.transform = function(S, w, g, m, E, T) {
                this.permute(T, S, w, g, m, E);
                for(var I = 1; I < E; I <<= 1)for(var P = I << 1, k = Math.cos(2 * Math.PI / P), L = Math.sin(2 * Math.PI / P), j = 0; j < E; j += P)for(var ie = k, ue = L, ce = 0; ce < I; ce++){
                    var he = g[j + ce], ee = m[j + ce], ae = g[j + ce + I], ye = m[j + ce + I], Se = ie * ae - ue * ye;
                    ye = ie * ye + ue * ae, ae = Se, g[j + ce] = he + ae, m[j + ce] = ee + ye, g[j + ce + I] = he - ae, m[j + ce + I] = ee - ye, ce !== P && (Se = k * ie - L * ue, ue = k * ue + L * ie, ie = Se);
                }
            }, U.prototype.guessLen13b = function(S, w) {
                var g = Math.max(w, S) | 1, m = g & 1, E = 0;
                for(g = g / 2 | 0; g; g = g >>> 1)E++;
                return 1 << E + 1 + m;
            }, U.prototype.conjugate = function(S, w, g) {
                if (!(g <= 1)) for(var m = 0; m < g / 2; m++){
                    var E = S[m];
                    S[m] = S[g - m - 1], S[g - m - 1] = E, E = w[m], w[m] = -w[g - m - 1], w[g - m - 1] = -E;
                }
            }, U.prototype.normalize13b = function(S, w) {
                for(var g = 0, m = 0; m < w / 2; m++){
                    var E = Math.round(S[2 * m + 1] / w) * 8192 + Math.round(S[2 * m] / w) + g;
                    S[m] = E & 67108863, E < 67108864 ? g = 0 : g = E / 67108864 | 0;
                }
                return S;
            }, U.prototype.convert13b = function(S, w, g, m) {
                for(var E = 0, T = 0; T < w; T++)E = E + (S[T] | 0), g[2 * T] = E & 8191, E = E >>> 13, g[2 * T + 1] = E & 8191, E = E >>> 13;
                for(T = 2 * w; T < m; ++T)g[T] = 0;
                n(E === 0), n((E & -8192) === 0);
            }, U.prototype.stub = function(S) {
                for(var w = new Array(S), g = 0; g < S; g++)w[g] = 0;
                return w;
            }, U.prototype.mulp = function(S, w, g) {
                var m = 2 * this.guessLen13b(S.length, w.length), E = this.makeRBT(m), T = this.stub(m), I = new Array(m), P = new Array(m), k = new Array(m), L = new Array(m), j = new Array(m), ie = new Array(m), ue = g.words;
                ue.length = m, this.convert13b(S.words, S.length, I, m), this.convert13b(w.words, w.length, L, m), this.transform(I, T, P, k, m, E), this.transform(L, T, j, ie, m, E);
                for(var ce = 0; ce < m; ce++){
                    var he = P[ce] * j[ce] - k[ce] * ie[ce];
                    k[ce] = P[ce] * ie[ce] + k[ce] * j[ce], P[ce] = he;
                }
                return this.conjugate(P, k, m), this.transform(P, k, ue, T, m, E), this.conjugate(ue, T, m), this.normalize13b(ue, m), g.negative = S.negative ^ w.negative, g.length = S.length + w.length, g.strip();
            }, o.prototype.mul = function(S) {
                var w = new o(null);
                return w.words = new Array(this.length + S.length), this.mulTo(S, w);
            }, o.prototype.mulf = function(S) {
                var w = new o(null);
                return w.words = new Array(this.length + S.length), N(this, S, w);
            }, o.prototype.imul = function(S) {
                return this.clone().mulTo(S, this);
            }, o.prototype.imuln = function(S) {
                n(typeof S == "number"), n(S < 67108864);
                for(var w = 0, g = 0; g < this.length; g++){
                    var m = (this.words[g] | 0) * S, E = (m & 67108863) + (w & 67108863);
                    w >>= 26, w += m / 67108864 | 0, w += E >>> 26, this.words[g] = E & 67108863;
                }
                return w !== 0 && (this.words[g] = w, this.length++), this.length = S === 0 ? 1 : this.length, this;
            }, o.prototype.muln = function(S) {
                return this.clone().imuln(S);
            }, o.prototype.sqr = function() {
                return this.mul(this);
            }, o.prototype.isqr = function() {
                return this.imul(this.clone());
            }, o.prototype.pow = function(S) {
                var w = y(S);
                if (w.length === 0) return new o(1);
                for(var g = this, m = 0; m < w.length && w[m] === 0; m++, g = g.sqr());
                if (++m < w.length) for(var E = g.sqr(); m < w.length; m++, E = E.sqr())w[m] !== 0 && (g = g.mul(E));
                return g;
            }, o.prototype.iushln = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = S % 26, g = (S - w) / 26, m = 67108863 >>> 26 - w << 26 - w, E;
                if (w !== 0) {
                    var T = 0;
                    for(E = 0; E < this.length; E++){
                        var I = this.words[E] & m, P = (this.words[E] | 0) - I << w;
                        this.words[E] = P | T, T = I >>> 26 - w;
                    }
                    T && (this.words[E] = T, this.length++);
                }
                if (g !== 0) {
                    for(E = this.length - 1; E >= 0; E--)this.words[E + g] = this.words[E];
                    for(E = 0; E < g; E++)this.words[E] = 0;
                    this.length += g;
                }
                return this.strip();
            }, o.prototype.ishln = function(S) {
                return n(this.negative === 0), this.iushln(S);
            }, o.prototype.iushrn = function(S, w, g) {
                n(typeof S == "number" && S >= 0);
                var m;
                w ? m = (w - w % 26) / 26 : m = 0;
                var E = S % 26, T = Math.min((S - E) / 26, this.length), I = 67108863 ^ 67108863 >>> E << E, P = g;
                if (m -= T, m = Math.max(0, m), P) {
                    for(var k = 0; k < T; k++)P.words[k] = this.words[k];
                    P.length = T;
                }
                if (T !== 0) if (this.length > T) for(this.length -= T, k = 0; k < this.length; k++)this.words[k] = this.words[k + T];
                else this.words[0] = 0, this.length = 1;
                var L = 0;
                for(k = this.length - 1; k >= 0 && (L !== 0 || k >= m); k--){
                    var j = this.words[k] | 0;
                    this.words[k] = L << 26 - E | j >>> E, L = j & I;
                }
                return P && L !== 0 && (P.words[P.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
            }, o.prototype.ishrn = function(S, w, g) {
                return n(this.negative === 0), this.iushrn(S, w, g);
            }, o.prototype.shln = function(S) {
                return this.clone().ishln(S);
            }, o.prototype.ushln = function(S) {
                return this.clone().iushln(S);
            }, o.prototype.shrn = function(S) {
                return this.clone().ishrn(S);
            }, o.prototype.ushrn = function(S) {
                return this.clone().iushrn(S);
            }, o.prototype.testn = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = S % 26, g = (S - w) / 26, m = 1 << w;
                if (this.length <= g) return !1;
                var E = this.words[g];
                return !!(E & m);
            }, o.prototype.imaskn = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = S % 26, g = (S - w) / 26;
                if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g) return this;
                if (w !== 0 && g++, this.length = Math.min(g, this.length), w !== 0) {
                    var m = 67108863 ^ 67108863 >>> w << w;
                    this.words[this.length - 1] &= m;
                }
                return this.strip();
            }, o.prototype.maskn = function(S) {
                return this.clone().imaskn(S);
            }, o.prototype.iaddn = function(S) {
                return n(typeof S == "number"), n(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
            }, o.prototype._iaddn = function(S) {
                this.words[0] += S;
                for(var w = 0; w < this.length && this.words[w] >= 67108864; w++)this.words[w] -= 67108864, w === this.length - 1 ? this.words[w + 1] = 1 : this.words[w + 1]++;
                return this.length = Math.max(this.length, w + 1), this;
            }, o.prototype.isubn = function(S) {
                if (n(typeof S == "number"), n(S < 67108864), S < 0) return this.iaddn(-S);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(S), this.negative = 1, this;
                if (this.words[0] -= S, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var w = 0; w < this.length && this.words[w] < 0; w++)this.words[w] += 67108864, this.words[w + 1] -= 1;
                return this.strip();
            }, o.prototype.addn = function(S) {
                return this.clone().iaddn(S);
            }, o.prototype.subn = function(S) {
                return this.clone().isubn(S);
            }, o.prototype.iabs = function() {
                return this.negative = 0, this;
            }, o.prototype.abs = function() {
                return this.clone().iabs();
            }, o.prototype._ishlnsubmul = function(S, w, g) {
                var m = S.length + g, E;
                this._expand(m);
                var T, I = 0;
                for(E = 0; E < S.length; E++){
                    T = (this.words[E + g] | 0) + I;
                    var P = (S.words[E] | 0) * w;
                    T -= P & 67108863, I = (T >> 26) - (P / 67108864 | 0), this.words[E + g] = T & 67108863;
                }
                for(; E < this.length - g; E++)T = (this.words[E + g] | 0) + I, I = T >> 26, this.words[E + g] = T & 67108863;
                if (I === 0) return this.strip();
                for(n(I === -1), I = 0, E = 0; E < this.length; E++)T = -(this.words[E] | 0) + I, I = T >> 26, this.words[E] = T & 67108863;
                return this.negative = 1, this.strip();
            }, o.prototype._wordDiv = function(S, w) {
                var g = this.length - S.length, m = this.clone(), E = S, T = E.words[E.length - 1] | 0, I = this._countBits(T);
                g = 26 - I, g !== 0 && (E = E.ushln(g), m.iushln(g), T = E.words[E.length - 1] | 0);
                var P = m.length - E.length, k;
                if (w !== "mod") {
                    k = new o(null), k.length = P + 1, k.words = new Array(k.length);
                    for(var L = 0; L < k.length; L++)k.words[L] = 0;
                }
                var j = m.clone()._ishlnsubmul(E, 1, P);
                j.negative === 0 && (m = j, k && (k.words[P] = 1));
                for(var ie = P - 1; ie >= 0; ie--){
                    var ue = (m.words[E.length + ie] | 0) * 67108864 + (m.words[E.length + ie - 1] | 0);
                    for(ue = Math.min(ue / T | 0, 67108863), m._ishlnsubmul(E, ue, ie); m.negative !== 0;)ue--, m.negative = 0, m._ishlnsubmul(E, 1, ie), m.isZero() || (m.negative ^= 1);
                    k && (k.words[ie] = ue);
                }
                return k && k.strip(), m.strip(), w !== "div" && g !== 0 && m.iushrn(g), {
                    div: k || null,
                    mod: m
                };
            }, o.prototype.divmod = function(S, w, g) {
                if (n(!S.isZero()), this.isZero()) return {
                    div: new o(0),
                    mod: new o(0)
                };
                var m, E, T;
                return this.negative !== 0 && S.negative === 0 ? (T = this.neg().divmod(S, w), w !== "mod" && (m = T.div.neg()), w !== "div" && (E = T.mod.neg(), g && E.negative !== 0 && E.iadd(S)), {
                    div: m,
                    mod: E
                }) : this.negative === 0 && S.negative !== 0 ? (T = this.divmod(S.neg(), w), w !== "mod" && (m = T.div.neg()), {
                    div: m,
                    mod: T.mod
                }) : this.negative & S.negative ? (T = this.neg().divmod(S.neg(), w), w !== "div" && (E = T.mod.neg(), g && E.negative !== 0 && E.isub(S)), {
                    div: T.div,
                    mod: E
                }) : S.length > this.length || this.cmp(S) < 0 ? {
                    div: new o(0),
                    mod: this
                } : S.length === 1 ? w === "div" ? {
                    div: this.divn(S.words[0]),
                    mod: null
                } : w === "mod" ? {
                    div: null,
                    mod: new o(this.modn(S.words[0]))
                } : {
                    div: this.divn(S.words[0]),
                    mod: new o(this.modn(S.words[0]))
                } : this._wordDiv(S, w);
            }, o.prototype.div = function(S) {
                return this.divmod(S, "div", !1).div;
            }, o.prototype.mod = function(S) {
                return this.divmod(S, "mod", !1).mod;
            }, o.prototype.umod = function(S) {
                return this.divmod(S, "mod", !0).mod;
            }, o.prototype.divRound = function(S) {
                var w = this.divmod(S);
                if (w.mod.isZero()) return w.div;
                var g = w.div.negative !== 0 ? w.mod.isub(S) : w.mod, m = S.ushrn(1), E = S.andln(1), T = g.cmp(m);
                return T < 0 || E === 1 && T === 0 ? w.div : w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
            }, o.prototype.modn = function(S) {
                n(S <= 67108863);
                for(var w = (1 << 26) % S, g = 0, m = this.length - 1; m >= 0; m--)g = (w * g + (this.words[m] | 0)) % S;
                return g;
            }, o.prototype.idivn = function(S) {
                n(S <= 67108863);
                for(var w = 0, g = this.length - 1; g >= 0; g--){
                    var m = (this.words[g] | 0) + w * 67108864;
                    this.words[g] = m / S | 0, w = m % S;
                }
                return this.strip();
            }, o.prototype.divn = function(S) {
                return this.clone().idivn(S);
            }, o.prototype.egcd = function(S) {
                n(S.negative === 0), n(!S.isZero());
                var w = this, g = S.clone();
                w.negative !== 0 ? w = w.umod(S) : w = w.clone();
                for(var m = new o(1), E = new o(0), T = new o(0), I = new o(1), P = 0; w.isEven() && g.isEven();)w.iushrn(1), g.iushrn(1), ++P;
                for(var k = g.clone(), L = w.clone(); !w.isZero();){
                    for(var j = 0, ie = 1; !(w.words[0] & ie) && j < 26; ++j, ie <<= 1);
                    if (j > 0) for(w.iushrn(j); j-- > 0;)(m.isOdd() || E.isOdd()) && (m.iadd(k), E.isub(L)), m.iushrn(1), E.iushrn(1);
                    for(var ue = 0, ce = 1; !(g.words[0] & ce) && ue < 26; ++ue, ce <<= 1);
                    if (ue > 0) for(g.iushrn(ue); ue-- > 0;)(T.isOdd() || I.isOdd()) && (T.iadd(k), I.isub(L)), T.iushrn(1), I.iushrn(1);
                    w.cmp(g) >= 0 ? (w.isub(g), m.isub(T), E.isub(I)) : (g.isub(w), T.isub(m), I.isub(E));
                }
                return {
                    a: T,
                    b: I,
                    gcd: g.iushln(P)
                };
            }, o.prototype._invmp = function(S) {
                n(S.negative === 0), n(!S.isZero());
                var w = this, g = S.clone();
                w.negative !== 0 ? w = w.umod(S) : w = w.clone();
                for(var m = new o(1), E = new o(0), T = g.clone(); w.cmpn(1) > 0 && g.cmpn(1) > 0;){
                    for(var I = 0, P = 1; !(w.words[0] & P) && I < 26; ++I, P <<= 1);
                    if (I > 0) for(w.iushrn(I); I-- > 0;)m.isOdd() && m.iadd(T), m.iushrn(1);
                    for(var k = 0, L = 1; !(g.words[0] & L) && k < 26; ++k, L <<= 1);
                    if (k > 0) for(g.iushrn(k); k-- > 0;)E.isOdd() && E.iadd(T), E.iushrn(1);
                    w.cmp(g) >= 0 ? (w.isub(g), m.isub(E)) : (g.isub(w), E.isub(m));
                }
                var j;
                return w.cmpn(1) === 0 ? j = m : j = E, j.cmpn(0) < 0 && j.iadd(S), j;
            }, o.prototype.gcd = function(S) {
                if (this.isZero()) return S.abs();
                if (S.isZero()) return this.abs();
                var w = this.clone(), g = S.clone();
                w.negative = 0, g.negative = 0;
                for(var m = 0; w.isEven() && g.isEven(); m++)w.iushrn(1), g.iushrn(1);
                do {
                    for(; w.isEven();)w.iushrn(1);
                    for(; g.isEven();)g.iushrn(1);
                    var E = w.cmp(g);
                    if (E < 0) {
                        var T = w;
                        w = g, g = T;
                    } else if (E === 0 || g.cmpn(1) === 0) break;
                    w.isub(g);
                }while (!0)
                return g.iushln(m);
            }, o.prototype.invm = function(S) {
                return this.egcd(S).a.umod(S);
            }, o.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, o.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, o.prototype.andln = function(S) {
                return this.words[0] & S;
            }, o.prototype.bincn = function(S) {
                n(typeof S == "number");
                var w = S % 26, g = (S - w) / 26, m = 1 << w;
                if (this.length <= g) return this._expand(g + 1), this.words[g] |= m, this;
                for(var E = m, T = g; E !== 0 && T < this.length; T++){
                    var I = this.words[T] | 0;
                    I += E, E = I >>> 26, I &= 67108863, this.words[T] = I;
                }
                return E !== 0 && (this.words[T] = E, this.length++), this;
            }, o.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, o.prototype.cmpn = function(S) {
                var w = S < 0;
                if (this.negative !== 0 && !w) return -1;
                if (this.negative === 0 && w) return 1;
                this.strip();
                var g;
                if (this.length > 1) g = 1;
                else {
                    w && (S = -S), n(S <= 67108863, "Number is too big");
                    var m = this.words[0] | 0;
                    g = m === S ? 0 : m < S ? -1 : 1;
                }
                return this.negative !== 0 ? -g | 0 : g;
            }, o.prototype.cmp = function(S) {
                if (this.negative !== 0 && S.negative === 0) return -1;
                if (this.negative === 0 && S.negative !== 0) return 1;
                var w = this.ucmp(S);
                return this.negative !== 0 ? -w | 0 : w;
            }, o.prototype.ucmp = function(S) {
                if (this.length > S.length) return 1;
                if (this.length < S.length) return -1;
                for(var w = 0, g = this.length - 1; g >= 0; g--){
                    var m = this.words[g] | 0, E = S.words[g] | 0;
                    if (m !== E) {
                        m < E ? w = -1 : m > E && (w = 1);
                        break;
                    }
                }
                return w;
            }, o.prototype.gtn = function(S) {
                return this.cmpn(S) === 1;
            }, o.prototype.gt = function(S) {
                return this.cmp(S) === 1;
            }, o.prototype.gten = function(S) {
                return this.cmpn(S) >= 0;
            }, o.prototype.gte = function(S) {
                return this.cmp(S) >= 0;
            }, o.prototype.ltn = function(S) {
                return this.cmpn(S) === -1;
            }, o.prototype.lt = function(S) {
                return this.cmp(S) === -1;
            }, o.prototype.lten = function(S) {
                return this.cmpn(S) <= 0;
            }, o.prototype.lte = function(S) {
                return this.cmp(S) <= 0;
            }, o.prototype.eqn = function(S) {
                return this.cmpn(S) === 0;
            }, o.prototype.eq = function(S) {
                return this.cmp(S) === 0;
            }, o.red = function(S) {
                return new R(S);
            }, o.prototype.toRed = function(S) {
                return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
            }, o.prototype.fromRed = function() {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, o.prototype._forceRed = function(S) {
                return this.red = S, this;
            }, o.prototype.forceRed = function(S) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(S);
            }, o.prototype.redAdd = function(S) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
            }, o.prototype.redIAdd = function(S) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
            }, o.prototype.redSub = function(S) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
            }, o.prototype.redISub = function(S) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
            }, o.prototype.redShl = function(S) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
            }, o.prototype.redMul = function(S) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
            }, o.prototype.redIMul = function(S) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
            }, o.prototype.redSqr = function() {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, o.prototype.redISqr = function() {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, o.prototype.redSqrt = function() {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, o.prototype.redInvm = function() {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, o.prototype.redNeg = function() {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, o.prototype.redPow = function(S) {
                return n(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
            };
            var D = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function H($, S) {
                this.name = $, this.p = new o(S, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            H.prototype._tmp = function() {
                var S = new o(null);
                return S.words = new Array(Math.ceil(this.n / 13)), S;
            }, H.prototype.ireduce = function(S) {
                var w = S, g;
                do this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), g = w.bitLength();
                while (g > this.n)
                var m = g < this.n ? -1 : w.ucmp(this.p);
                return m === 0 ? (w.words[0] = 0, w.length = 1) : m > 0 ? w.isub(this.p) : w.strip !== void 0 ? w.strip() : w._strip(), w;
            }, H.prototype.split = function(S, w) {
                S.iushrn(this.n, 0, w);
            }, H.prototype.imulK = function(S) {
                return S.imul(this.k);
            };
            function K() {
                H.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            i(K, H), K.prototype.split = function(S, w) {
                for(var g = 4194303, m = Math.min(S.length, 9), E = 0; E < m; E++)w.words[E] = S.words[E];
                if (w.length = m, S.length <= 9) {
                    S.words[0] = 0, S.length = 1;
                    return;
                }
                var T = S.words[9];
                for(w.words[w.length++] = T & g, E = 10; E < S.length; E++){
                    var I = S.words[E] | 0;
                    S.words[E - 10] = (I & g) << 4 | T >>> 22, T = I;
                }
                T >>>= 22, S.words[E - 10] = T, T === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
            }, K.prototype.imulK = function(S) {
                S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
                for(var w = 0, g = 0; g < S.length; g++){
                    var m = S.words[g] | 0;
                    w += m * 977, S.words[g] = w & 67108863, w = m * 64 + (w / 67108864 | 0);
                }
                return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
            };
            function re() {
                H.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            i(re, H);
            function Q() {
                H.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            i(Q, H);
            function G() {
                H.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            i(G, H), G.prototype.imulK = function(S) {
                for(var w = 0, g = 0; g < S.length; g++){
                    var m = (S.words[g] | 0) * 19 + w, E = m & 67108863;
                    m >>>= 26, S.words[g] = E, w = m;
                }
                return w !== 0 && (S.words[S.length++] = w), S;
            }, o._prime = function(S) {
                if (D[S]) return D[S];
                var w;
                if (S === "k256") w = new K();
                else if (S === "p224") w = new re();
                else if (S === "p192") w = new Q();
                else if (S === "p25519") w = new G();
                else throw new Error("Unknown prime " + S);
                return D[S] = w, w;
            };
            function R($) {
                if (typeof $ == "string") {
                    var S = o._prime($);
                    this.m = S.p, this.prime = S;
                } else n($.gtn(1), "modulus must be greater than 1"), this.m = $, this.prime = null;
            }
            R.prototype._verify1 = function(S) {
                n(S.negative === 0, "red works only with positives"), n(S.red, "red works only with red numbers");
            }, R.prototype._verify2 = function(S, w) {
                n((S.negative | w.negative) === 0, "red works only with positives"), n(S.red && S.red === w.red, "red works only with red numbers");
            }, R.prototype.imod = function(S) {
                return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
            }, R.prototype.neg = function(S) {
                return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
            }, R.prototype.add = function(S, w) {
                this._verify2(S, w);
                var g = S.add(w);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
            }, R.prototype.iadd = function(S, w) {
                this._verify2(S, w);
                var g = S.iadd(w);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g;
            }, R.prototype.sub = function(S, w) {
                this._verify2(S, w);
                var g = S.sub(w);
                return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
            }, R.prototype.isub = function(S, w) {
                this._verify2(S, w);
                var g = S.isub(w);
                return g.cmpn(0) < 0 && g.iadd(this.m), g;
            }, R.prototype.shl = function(S, w) {
                return this._verify1(S), this.imod(S.ushln(w));
            }, R.prototype.imul = function(S, w) {
                return this._verify2(S, w), this.imod(S.imul(w));
            }, R.prototype.mul = function(S, w) {
                return this._verify2(S, w), this.imod(S.mul(w));
            }, R.prototype.isqr = function(S) {
                return this.imul(S, S.clone());
            }, R.prototype.sqr = function(S) {
                return this.mul(S, S);
            }, R.prototype.sqrt = function(S) {
                if (S.isZero()) return S.clone();
                var w = this.m.andln(3);
                if (n(w % 2 === 1), w === 3) {
                    var g = this.m.add(new o(1)).iushrn(2);
                    return this.pow(S, g);
                }
                for(var m = this.m.subn(1), E = 0; !m.isZero() && m.andln(1) === 0;)E++, m.iushrn(1);
                n(!m.isZero());
                var T = new o(1).toRed(this), I = T.redNeg(), P = this.m.subn(1).iushrn(1), k = this.m.bitLength();
                for(k = new o(2 * k * k).toRed(this); this.pow(k, P).cmp(I) !== 0;)k.redIAdd(I);
                for(var L = this.pow(k, m), j = this.pow(S, m.addn(1).iushrn(1)), ie = this.pow(S, m), ue = E; ie.cmp(T) !== 0;){
                    for(var ce = ie, he = 0; ce.cmp(T) !== 0; he++)ce = ce.redSqr();
                    n(he < ue);
                    var ee = this.pow(L, new o(1).iushln(ue - he - 1));
                    j = j.redMul(ee), L = ee.redSqr(), ie = ie.redMul(L), ue = he;
                }
                return j;
            }, R.prototype.invm = function(S) {
                var w = S._invmp(this.m);
                return w.negative !== 0 ? (w.negative = 0, this.imod(w).redNeg()) : this.imod(w);
            }, R.prototype.pow = function(S, w) {
                if (w.isZero()) return new o(1).toRed(this);
                if (w.cmpn(1) === 0) return S.clone();
                var g = 4, m = new Array(1 << g);
                m[0] = new o(1).toRed(this), m[1] = S;
                for(var E = 2; E < m.length; E++)m[E] = this.mul(m[E - 1], S);
                var T = m[0], I = 0, P = 0, k = w.bitLength() % 26;
                for(k === 0 && (k = 26), E = w.length - 1; E >= 0; E--){
                    for(var L = w.words[E], j = k - 1; j >= 0; j--){
                        var ie = L >> j & 1;
                        if (T !== m[0] && (T = this.sqr(T)), ie === 0 && I === 0) {
                            P = 0;
                            continue;
                        }
                        I <<= 1, I |= ie, P++, !(P !== g && (E !== 0 || j !== 0)) && (T = this.mul(T, m[I]), P = 0, I = 0);
                    }
                    k = 26;
                }
                return T;
            }, R.prototype.convertTo = function(S) {
                var w = S.umod(this.m);
                return w === S ? w.clone() : w;
            }, R.prototype.convertFrom = function(S) {
                var w = S.clone();
                return w.red = null, w;
            }, o.mont = function(S) {
                return new X(S);
            };
            function X($) {
                R.call(this, $), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            i(X, R), X.prototype.convertTo = function(S) {
                return this.imod(S.ushln(this.shift));
            }, X.prototype.convertFrom = function(S) {
                var w = this.imod(S.mul(this.rinv));
                return w.red = null, w;
            }, X.prototype.imul = function(S, w) {
                if (S.isZero() || w.isZero()) return S.words[0] = 0, S.length = 1, S;
                var g = S.imul(w), m = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = g.isub(m).iushrn(this.shift), T = E;
                return E.cmp(this.m) >= 0 ? T = E.isub(this.m) : E.cmpn(0) < 0 && (T = E.iadd(this.m)), T._forceRed(this);
            }, X.prototype.mul = function(S, w) {
                if (S.isZero() || w.isZero()) return new o(0)._forceRed(this);
                var g = S.mul(w), m = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = g.isub(m).iushrn(this.shift), T = E;
                return E.cmp(this.m) >= 0 ? T = E.isub(this.m) : E.cmpn(0) < 0 && (T = E.iadd(this.m)), T._forceRed(this);
            }, X.prototype.invm = function(S) {
                var w = this.imod(S._invmp(this.m).mul(this.r2));
                return w._forceRed(this);
            };
        })(e, Ge);
    }(ky)), ky.exports;
}
var zg = {
    exports: {}
}, _5;
function L3() {
    if (_5) return zg.exports;
    _5 = 1;
    var e;
    zg.exports = function(i) {
        return e || (e = new t(null)), e.generate(i);
    };
    function t(n) {
        this.rand = n;
    }
    if (zg.exports.Rand = t, t.prototype.generate = function(i) {
        return this._rand(i);
    }, t.prototype._rand = function(i) {
        if (this.rand.getBytes) return this.rand.getBytes(i);
        for(var o = new Uint8Array(i), s = 0; s < o.length; s++)o[s] = this.rand.getByte();
        return o;
    }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(i) {
        var o = new Uint8Array(i);
        return self.crypto.getRandomValues(o), o;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(i) {
        var o = new Uint8Array(i);
        return self.msCrypto.getRandomValues(o), o;
    } : ("TURBOPACK compile-time value", "undefined") == "object" && (t.prototype._rand = function() {
        throw new Error("Not implemented yet");
    });
    else try {
        var r = q3();
        if (typeof r.randomBytes != "function") throw new Error("Not supported");
        t.prototype._rand = function(i) {
            return r.randomBytes(i);
        };
    } catch  {}
    return zg.exports;
}
var Zv, E5;
function vO() {
    if (E5) return Zv;
    E5 = 1;
    var e = bi(), t = L3();
    function r(n) {
        this.rand = n || new t.Rand();
    }
    return Zv = r, r.create = function(i) {
        return new r(i);
    }, r.prototype._randbelow = function(i) {
        var o = i.bitLength(), s = Math.ceil(o / 8);
        do var a = new e(this.rand.generate(s));
        while (a.cmp(i) >= 0)
        return a;
    }, r.prototype._randrange = function(i, o) {
        var s = o.sub(i);
        return i.add(this._randbelow(s));
    }, r.prototype.test = function(i, o, s) {
        var a = i.bitLength(), u = e.mont(i), f = new e(1).toRed(u);
        o || (o = Math.max(1, a / 48 | 0));
        for(var c = i.subn(1), l = 0; !c.testn(l); l++);
        for(var p = i.shrn(l), y = c.toRed(u), _ = !0; o > 0; o--){
            var A = this._randrange(new e(2), c);
            s && s(A);
            var O = A.toRed(u).redPow(p);
            if (!(O.cmp(f) === 0 || O.cmp(y) === 0)) {
                for(var N = 1; N < l; N++){
                    if (O = O.redSqr(), O.cmp(f) === 0) return !1;
                    if (O.cmp(y) === 0) break;
                }
                if (N === l) return !1;
            }
        }
        return _;
    }, r.prototype.getDivisor = function(i, o) {
        var s = i.bitLength(), a = e.mont(i), u = new e(1).toRed(a);
        o || (o = Math.max(1, s / 48 | 0));
        for(var f = i.subn(1), c = 0; !f.testn(c); c++);
        for(var l = i.shrn(c), p = f.toRed(a); o > 0; o--){
            var y = this._randrange(new e(2), f), _ = i.gcd(y);
            if (_.cmpn(1) !== 0) return _;
            var A = y.toRed(a).redPow(l);
            if (!(A.cmp(u) === 0 || A.cmp(p) === 0)) {
                for(var O = 1; O < c; O++){
                    if (A = A.redSqr(), A.cmp(u) === 0) return A.fromRed().subn(1).gcd(i);
                    if (A.cmp(p) === 0) break;
                }
                if (O === c) return A = A.redSqr(), A.fromRed().subn(1).gcd(i);
            }
        }
        return !1;
    }, Zv;
}
var Yv, x5;
function _O() {
    if (x5) return Yv;
    x5 = 1;
    var e = kd();
    Yv = O, O.simpleSieve = _, O.fermatTest = A;
    var t = bi(), r = new t(24), n = vO(), i = new n(), o = new t(1), s = new t(2), a = new t(5);
    new t(16), new t(8);
    var u = new t(10), f = new t(3);
    new t(7);
    var c = new t(11), l = new t(4);
    new t(12);
    var p = null;
    function y() {
        if (p !== null) return p;
        var N = 1048576, U = [];
        U[0] = 2;
        for(var D = 1, H = 3; H < N; H += 2){
            for(var K = Math.ceil(Math.sqrt(H)), re = 0; re < D && U[re] <= K && H % U[re] !== 0; re++);
            D !== re && U[re] <= K || (U[D++] = H);
        }
        return p = U, U;
    }
    function _(N) {
        for(var U = y(), D = 0; D < U.length; D++)if (N.modn(U[D]) === 0) return N.cmpn(U[D]) === 0;
        return !0;
    }
    function A(N) {
        var U = t.mont(N);
        return s.toRed(U).redPow(N.subn(1)).fromRed().cmpn(1) === 0;
    }
    function O(N, U) {
        if (N < 16) return U === 2 || U === 5 ? new t([
            140,
            123
        ]) : new t([
            140,
            39
        ]);
        U = new t(U);
        for(var D, H;;){
            for(D = new t(e(Math.ceil(N / 8))); D.bitLength() > N;)D.ishrn(1);
            if (D.isEven() && D.iadd(o), D.testn(1) || D.iadd(s), U.cmp(s)) {
                if (!U.cmp(a)) for(; D.mod(u).cmp(f);)D.iadd(l);
            } else for(; D.mod(r).cmp(c);)D.iadd(l);
            if (H = D.shrn(1), _(H) && _(D) && A(H) && A(D) && i.test(H) && i.test(D)) return D;
        }
    }
    return Yv;
}
const XY = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, JY = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, QY = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, eX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, tX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, rX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, nX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, iX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, oX = {
    modp1: XY,
    modp2: JY,
    modp5: QY,
    modp14: eX,
    modp15: tX,
    modp16: rX,
    modp17: nX,
    modp18: iX
};
var Xv, S5;
function sX() {
    if (S5) return Xv;
    S5 = 1;
    var e = bi(), t = vO(), r = new t(), n = new e(24), i = new e(11), o = new e(10), s = new e(3), a = new e(7), u = _O(), f = kd();
    Xv = _;
    function c(O, N) {
        return N = N || "utf8", We.isBuffer(O) || (O = new We(O, N)), this._pub = new e(O), this;
    }
    function l(O, N) {
        return N = N || "utf8", We.isBuffer(O) || (O = new We(O, N)), this._priv = new e(O), this;
    }
    var p = {};
    function y(O, N) {
        var U = N.toString("hex"), D = [
            U,
            O.toString(16)
        ].join("_");
        if (D in p) return p[D];
        var H = 0;
        if (O.isEven() || !u.simpleSieve || !u.fermatTest(O) || !r.test(O)) return H += 1, U === "02" || U === "05" ? H += 8 : H += 4, p[D] = H, H;
        r.test(O.shrn(1)) || (H += 2);
        var K;
        switch(U){
            case "02":
                O.mod(n).cmp(i) && (H += 8);
                break;
            case "05":
                K = O.mod(o), K.cmp(s) && K.cmp(a) && (H += 8);
                break;
            default:
                H += 4;
        }
        return p[D] = H, H;
    }
    function _(O, N, U) {
        this.setGenerator(N), this.__prime = new e(O), this._prime = e.mont(this.__prime), this._primeLen = O.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, U ? (this.setPublicKey = c, this.setPrivateKey = l) : this._primeCode = 8;
    }
    Object.defineProperty(_.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = y(this.__prime, this.__gen)), this._primeCode;
        }
    }), _.prototype.generateKeys = function() {
        return this._priv || (this._priv = new e(f(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    }, _.prototype.computeSecret = function(O) {
        O = new e(O), O = O.toRed(this._prime);
        var N = O.redPow(this._priv).fromRed(), U = new We(N.toArray()), D = this.getPrime();
        if (U.length < D.length) {
            var H = new We(D.length - U.length);
            H.fill(0), U = We.concat([
                H,
                U
            ]);
        }
        return U;
    }, _.prototype.getPublicKey = function(N) {
        return A(this._pub, N);
    }, _.prototype.getPrivateKey = function(N) {
        return A(this._priv, N);
    }, _.prototype.getPrime = function(O) {
        return A(this.__prime, O);
    }, _.prototype.getGenerator = function(O) {
        return A(this._gen, O);
    }, _.prototype.setGenerator = function(O, N) {
        return N = N || "utf8", We.isBuffer(O) || (O = new We(O, N)), this.__gen = O, this._gen = new e(O), this;
    };
    function A(O, N) {
        var U = new We(O.toArray());
        return N ? U.toString(N) : U;
    }
    return Xv;
}
var A5;
function aX() {
    if (A5) return qu;
    A5 = 1;
    var e = _O(), t = oX, r = sX();
    function n(s) {
        var a = new We(t[s].prime, "hex"), u = new We(t[s].gen, "hex");
        return new r(a, u);
    }
    var i = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function o(s, a, u, f) {
        return We.isBuffer(a) || i[a] === void 0 ? o(s, "binary", a, u) : (a = a || "binary", f = f || "binary", u = u || new We([
            2
        ]), We.isBuffer(u) || (u = new We(u, f)), typeof s == "number" ? new r(e(s, u), u, !0) : (We.isBuffer(s) || (s = new We(s, a)), new r(s, u, !0)));
    }
    return qu.DiffieHellmanGroup = qu.createDiffieHellmanGroup = qu.getDiffieHellman = n, qu.createDiffieHellman = qu.DiffieHellman = o, qu;
}
var jg = {
    exports: {}
}, Hg = {
    exports: {}
}, T5;
function Sb() {
    if (T5) return Hg.exports;
    T5 = 1, typeof bn > "u" || !bn.version || bn.version.indexOf("v0.") === 0 || bn.version.indexOf("v1.") === 0 && bn.version.indexOf("v1.8.") !== 0 ? Hg.exports = {
        nextTick: e
    } : Hg.exports = bn;
    function e(t, r, n, i) {
        if (typeof t != "function") throw new TypeError('"callback" argument must be a function');
        var o = arguments.length, s, a;
        switch(o){
            case 0:
            case 1:
                return bn.nextTick(t);
            case 2:
                return bn.nextTick(function() {
                    t.call(null, r);
                });
            case 3:
                return bn.nextTick(function() {
                    t.call(null, r, n);
                });
            case 4:
                return bn.nextTick(function() {
                    t.call(null, r, n, i);
                });
            default:
                for(s = new Array(o - 1), a = 0; a < s.length;)s[a++] = arguments[a];
                return bn.nextTick(function() {
                    t.apply(null, s);
                });
        }
    }
    return Hg.exports;
}
var Jv, k5;
function cX() {
    if (k5) return Jv;
    k5 = 1;
    var e = {}.toString;
    return Jv = Array.isArray || function(t) {
        return e.call(t) == "[object Array]";
    }, Jv;
}
var qg = {
    exports: {}
}, I5;
function EO() {
    if (I5) return qg.exports;
    I5 = 1;
    var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(K, re, Q) {
        return Function.prototype.apply.call(K, re, Q);
    }, r;
    e && typeof e.ownKeys == "function" ? r = e.ownKeys : Object.getOwnPropertySymbols ? r = function(K) {
        return Object.getOwnPropertyNames(K).concat(Object.getOwnPropertySymbols(K));
    } : r = function(K) {
        return Object.getOwnPropertyNames(K);
    };
    function n(H) {
        console && console.warn && console.warn(H);
    }
    var i = Number.isNaN || function(K) {
        return K !== K;
    };
    function o() {
        o.init.call(this);
    }
    qg.exports = o, qg.exports.once = N, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    var s = 10;
    function a(H) {
        if (typeof H != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof H);
    }
    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return s;
        },
        set: function(H) {
            if (typeof H != "number" || H < 0 || i(H)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + H + ".");
            s = H;
        }
    }), o.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o.prototype.setMaxListeners = function(K) {
        if (typeof K != "number" || K < 0 || i(K)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + K + ".");
        return this._maxListeners = K, this;
    };
    function u(H) {
        return H._maxListeners === void 0 ? o.defaultMaxListeners : H._maxListeners;
    }
    o.prototype.getMaxListeners = function() {
        return u(this);
    }, o.prototype.emit = function(K) {
        for(var re = [], Q = 1; Q < arguments.length; Q++)re.push(arguments[Q]);
        var G = K === "error", R = this._events;
        if (R !== void 0) G = G && R.error === void 0;
        else if (!G) return !1;
        if (G) {
            var X;
            if (re.length > 0 && (X = re[0]), X instanceof Error) throw X;
            var $ = new Error("Unhandled error." + (X ? " (" + X.message + ")" : ""));
            throw $.context = X, $;
        }
        var S = R[K];
        if (S === void 0) return !1;
        if (typeof S == "function") t(S, this, re);
        else for(var w = S.length, g = _(S, w), Q = 0; Q < w; ++Q)t(g[Q], this, re);
        return !0;
    };
    function f(H, K, re, Q) {
        var G, R, X;
        if (a(re), R = H._events, R === void 0 ? (R = H._events = /* @__PURE__ */ Object.create(null), H._eventsCount = 0) : (R.newListener !== void 0 && (H.emit("newListener", K, re.listener ? re.listener : re), R = H._events), X = R[K]), X === void 0) X = R[K] = re, ++H._eventsCount;
        else if (typeof X == "function" ? X = R[K] = Q ? [
            re,
            X
        ] : [
            X,
            re
        ] : Q ? X.unshift(re) : X.push(re), G = u(H), G > 0 && X.length > G && !X.warned) {
            X.warned = !0;
            var $ = new Error("Possible EventEmitter memory leak detected. " + X.length + " " + String(K) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            $.name = "MaxListenersExceededWarning", $.emitter = H, $.type = K, $.count = X.length, n($);
        }
        return H;
    }
    o.prototype.addListener = function(K, re) {
        return f(this, K, re, !1);
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(K, re) {
        return f(this, K, re, !0);
    };
    function c() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function l(H, K, re) {
        var Q = {
            fired: !1,
            wrapFn: void 0,
            target: H,
            type: K,
            listener: re
        }, G = c.bind(Q);
        return G.listener = re, Q.wrapFn = G, G;
    }
    o.prototype.once = function(K, re) {
        return a(re), this.on(K, l(this, K, re)), this;
    }, o.prototype.prependOnceListener = function(K, re) {
        return a(re), this.prependListener(K, l(this, K, re)), this;
    }, o.prototype.removeListener = function(K, re) {
        var Q, G, R, X, $;
        if (a(re), G = this._events, G === void 0) return this;
        if (Q = G[K], Q === void 0) return this;
        if (Q === re || Q.listener === re) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete G[K], G.removeListener && this.emit("removeListener", K, Q.listener || re));
        else if (typeof Q != "function") {
            for(R = -1, X = Q.length - 1; X >= 0; X--)if (Q[X] === re || Q[X].listener === re) {
                $ = Q[X].listener, R = X;
                break;
            }
            if (R < 0) return this;
            R === 0 ? Q.shift() : A(Q, R), Q.length === 1 && (G[K] = Q[0]), G.removeListener !== void 0 && this.emit("removeListener", K, $ || re);
        }
        return this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(K) {
        var re, Q, G;
        if (Q = this._events, Q === void 0) return this;
        if (Q.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Q[K] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Q[K]), this;
        if (arguments.length === 0) {
            var R = Object.keys(Q), X;
            for(G = 0; G < R.length; ++G)X = R[G], X !== "removeListener" && this.removeAllListeners(X);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if (re = Q[K], typeof re == "function") this.removeListener(K, re);
        else if (re !== void 0) for(G = re.length - 1; G >= 0; G--)this.removeListener(K, re[G]);
        return this;
    };
    function p(H, K, re) {
        var Q = H._events;
        if (Q === void 0) return [];
        var G = Q[K];
        return G === void 0 ? [] : typeof G == "function" ? re ? [
            G.listener || G
        ] : [
            G
        ] : re ? O(G) : _(G, G.length);
    }
    o.prototype.listeners = function(K) {
        return p(this, K, !0);
    }, o.prototype.rawListeners = function(K) {
        return p(this, K, !1);
    }, o.listenerCount = function(H, K) {
        return typeof H.listenerCount == "function" ? H.listenerCount(K) : y.call(H, K);
    }, o.prototype.listenerCount = y;
    function y(H) {
        var K = this._events;
        if (K !== void 0) {
            var re = K[H];
            if (typeof re == "function") return 1;
            if (re !== void 0) return re.length;
        }
        return 0;
    }
    o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r(this._events) : [];
    };
    function _(H, K) {
        for(var re = new Array(K), Q = 0; Q < K; ++Q)re[Q] = H[Q];
        return re;
    }
    function A(H, K) {
        for(; K + 1 < H.length; K++)H[K] = H[K + 1];
        H.pop();
    }
    function O(H) {
        for(var K = new Array(H.length), re = 0; re < K.length; ++re)K[re] = H[re].listener || H[re];
        return K;
    }
    function N(H, K) {
        return new Promise(function(re, Q) {
            function G(X) {
                H.removeListener(K, R), Q(X);
            }
            function R() {
                typeof H.removeListener == "function" && H.removeListener("error", G), re([].slice.call(arguments));
            }
            D(H, K, R, {
                once: !0
            }), K !== "error" && U(H, G, {
                once: !0
            });
        });
    }
    function U(H, K, re) {
        typeof H.on == "function" && D(H, "error", K, re);
    }
    function D(H, K, re, Q) {
        if (typeof H.on == "function") Q.once ? H.once(K, re) : H.on(K, re);
        else if (typeof H.addEventListener == "function") H.addEventListener(K, function G(R) {
            Q.once && H.removeEventListener(K, G), re(R);
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof H);
    }
    return qg.exports;
}
var Qv, B5;
function xO() {
    return B5 || (B5 = 1, Qv = EO().EventEmitter), Qv;
}
var Kg = {
    exports: {}
}, O5;
function Ab() {
    return O5 || (O5 = 1, function(e, t) {
        var r = ku, n = r.Buffer;
        function i(s, a) {
            for(var u in s)a[u] = s[u];
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = o);
        function o(s, a, u) {
            return n(s, a, u);
        }
        i(n, o), o.from = function(s, a, u) {
            if (typeof s == "number") throw new TypeError("Argument must not be a number");
            return n(s, a, u);
        }, o.alloc = function(s, a, u) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            var f = n(s);
            return a !== void 0 ? typeof u == "string" ? f.fill(a, u) : f.fill(a) : f.fill(0), f;
        }, o.allocUnsafe = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return n(s);
        }, o.allocUnsafeSlow = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return r.SlowBuffer(s);
        };
    }(Kg, Kg.exports)), Kg.exports;
}
var fi = {}, P5;
function o0() {
    if (P5) return fi;
    P5 = 1;
    function e(A) {
        return Array.isArray ? Array.isArray(A) : _(A) === "[object Array]";
    }
    fi.isArray = e;
    function t(A) {
        return typeof A == "boolean";
    }
    fi.isBoolean = t;
    function r(A) {
        return A === null;
    }
    fi.isNull = r;
    function n(A) {
        return A == null;
    }
    fi.isNullOrUndefined = n;
    function i(A) {
        return typeof A == "number";
    }
    fi.isNumber = i;
    function o(A) {
        return typeof A == "string";
    }
    fi.isString = o;
    function s(A) {
        return typeof A == "symbol";
    }
    fi.isSymbol = s;
    function a(A) {
        return A === void 0;
    }
    fi.isUndefined = a;
    function u(A) {
        return _(A) === "[object RegExp]";
    }
    fi.isRegExp = u;
    function f(A) {
        return typeof A == "object" && A !== null;
    }
    fi.isObject = f;
    function c(A) {
        return _(A) === "[object Date]";
    }
    fi.isDate = c;
    function l(A) {
        return _(A) === "[object Error]" || A instanceof Error;
    }
    fi.isError = l;
    function p(A) {
        return typeof A == "function";
    }
    fi.isFunction = p;
    function y(A) {
        return A === null || typeof A == "boolean" || typeof A == "number" || typeof A == "string" || typeof A == "symbol" || // ES6 symbol
        typeof A > "u";
    }
    fi.isPrimitive = y, fi.isBuffer = ku.Buffer.isBuffer;
    function _(A) {
        return Object.prototype.toString.call(A);
    }
    return fi;
}
var e2 = {
    exports: {}
}, N5;
function uX() {
    return N5 || (N5 = 1, function(e) {
        function t(o, s) {
            if (!(o instanceof s)) throw new TypeError("Cannot call a class as a function");
        }
        var r = Ab().Buffer, n = Iu;
        function i(o, s, a) {
            o.copy(s, a);
        }
        e.exports = function() {
            function o() {
                t(this, o), this.head = null, this.tail = null, this.length = 0;
            }
            return o.prototype.push = function(a) {
                var u = {
                    data: a,
                    next: null
                };
                this.length > 0 ? this.tail.next = u : this.head = u, this.tail = u, ++this.length;
            }, o.prototype.unshift = function(a) {
                var u = {
                    data: a,
                    next: this.head
                };
                this.length === 0 && (this.tail = u), this.head = u, ++this.length;
            }, o.prototype.shift = function() {
                if (this.length !== 0) {
                    var a = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, a;
                }
            }, o.prototype.clear = function() {
                this.head = this.tail = null, this.length = 0;
            }, o.prototype.join = function(a) {
                if (this.length === 0) return "";
                for(var u = this.head, f = "" + u.data; u = u.next;)f += a + u.data;
                return f;
            }, o.prototype.concat = function(a) {
                if (this.length === 0) return r.alloc(0);
                for(var u = r.allocUnsafe(a >>> 0), f = this.head, c = 0; f;)i(f.data, u, c), c += f.data.length, f = f.next;
                return u;
            }, o;
        }(), n && n.inspect && n.inspect.custom && (e.exports.prototype[n.inspect.custom] = function() {
            var o = n.inspect({
                length: this.length
            });
            return this.constructor.name + " " + o;
        });
    }(e2)), e2.exports;
}
var t2, M5;
function SO() {
    if (M5) return t2;
    M5 = 1;
    var e = Sb();
    function t(i, o) {
        var s = this, a = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
        return a || u ? (o ? o(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(n, this, i)) : e.nextTick(n, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(f) {
            !o && f ? s._writableState ? s._writableState.errorEmitted || (s._writableState.errorEmitted = !0, e.nextTick(n, s, f)) : e.nextTick(n, s, f) : o && o(f);
        }), this);
    }
    function r() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function n(i, o) {
        i.emit("error", o);
    }
    return t2 = {
        destroy: t,
        undestroy: r
    }, t2;
}
var r2, R5;
function fX() {
    if (R5) return r2;
    R5 = 1, r2 = e;
    function e(r, n) {
        if (t("noDeprecation")) return r;
        var i = !1;
        function o() {
            if (!i) {
                if (t("throwDeprecation")) throw new Error(n);
                t("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
            }
            return r.apply(this, arguments);
        }
        return o;
    }
    function t(r) {
        try {
            if (!Ge.localStorage) return !1;
        } catch  {
            return !1;
        }
        var n = Ge.localStorage[r];
        return n == null ? !1 : String(n).toLowerCase() === "true";
    }
    return r2;
}
var n2, C5;
function AO() {
    if (C5) return n2;
    C5 = 1;
    var e = Sb();
    n2 = A;
    function t(T) {
        var I = this;
        this.next = null, this.entry = null, this.finish = function() {
            E(I, T);
        };
    }
    var r = !bn.browser && [
        "v0.10",
        "v0.9."
    ].indexOf(bn.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, n;
    A.WritableState = y;
    var i = Object.create(o0());
    i.inherits = Or();
    var o = {
        deprecate: fX()
    }, s = xO(), a = Ab().Buffer, u = (typeof Ge < "u" ? Ge : ("TURBOPACK compile-time value", "undefined") < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function f(T) {
        return a.from(T);
    }
    function c(T) {
        return a.isBuffer(T) || T instanceof u;
    }
    var l = SO();
    i.inherits(A, s);
    function p() {}
    function y(T, I) {
        n = n || rd(), T = T || {};
        var P = I instanceof n;
        this.objectMode = !!T.objectMode, P && (this.objectMode = this.objectMode || !!T.writableObjectMode);
        var k = T.highWaterMark, L = T.writableHighWaterMark, j = this.objectMode ? 16 : 16 * 1024;
        k || k === 0 ? this.highWaterMark = k : P && (L || L === 0) ? this.highWaterMark = L : this.highWaterMark = j, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var ie = T.decodeStrings === !1;
        this.decodeStrings = !ie, this.defaultEncoding = T.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ue) {
            Q(I, ue);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
    }
    y.prototype.getBuffer = function() {
        for(var I = this.bufferedRequest, P = []; I;)P.push(I), I = I.next;
        return P;
    }, function() {
        try {
            Object.defineProperty(y.prototype, "buffer", {
                get: o.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch  {}
    }();
    var _;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (_ = Function.prototype[Symbol.hasInstance], Object.defineProperty(A, Symbol.hasInstance, {
        value: function(T) {
            return _.call(this, T) ? !0 : this !== A ? !1 : T && T._writableState instanceof y;
        }
    })) : _ = function(T) {
        return T instanceof this;
    };
    function A(T) {
        if (n = n || rd(), !_.call(A, this) && !(this instanceof n)) return new A(T);
        this._writableState = new y(T, this), this.writable = !0, T && (typeof T.write == "function" && (this._write = T.write), typeof T.writev == "function" && (this._writev = T.writev), typeof T.destroy == "function" && (this._destroy = T.destroy), typeof T.final == "function" && (this._final = T.final)), s.call(this);
    }
    A.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function O(T, I) {
        var P = new Error("write after end");
        T.emit("error", P), e.nextTick(I, P);
    }
    function N(T, I, P, k) {
        var L = !0, j = !1;
        return P === null ? j = new TypeError("May not write null values to stream") : typeof P != "string" && P !== void 0 && !I.objectMode && (j = new TypeError("Invalid non-string/buffer chunk")), j && (T.emit("error", j), e.nextTick(k, j), L = !1), L;
    }
    A.prototype.write = function(T, I, P) {
        var k = this._writableState, L = !1, j = !k.objectMode && c(T);
        return j && !a.isBuffer(T) && (T = f(T)), typeof I == "function" && (P = I, I = null), j ? I = "buffer" : I || (I = k.defaultEncoding), typeof P != "function" && (P = p), k.ended ? O(this, P) : (j || N(this, k, T, P)) && (k.pendingcb++, L = D(this, k, j, T, I, P)), L;
    }, A.prototype.cork = function() {
        var T = this._writableState;
        T.corked++;
    }, A.prototype.uncork = function() {
        var T = this._writableState;
        T.corked && (T.corked--, !T.writing && !T.corked && !T.bufferProcessing && T.bufferedRequest && X(this, T));
    }, A.prototype.setDefaultEncoding = function(I) {
        if (typeof I == "string" && (I = I.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((I + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + I);
        return this._writableState.defaultEncoding = I, this;
    };
    function U(T, I, P) {
        return !T.objectMode && T.decodeStrings !== !1 && typeof I == "string" && (I = a.from(I, P)), I;
    }
    Object.defineProperty(A.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function D(T, I, P, k, L, j) {
        if (!P) {
            var ie = U(I, k, L);
            k !== ie && (P = !0, L = "buffer", k = ie);
        }
        var ue = I.objectMode ? 1 : k.length;
        I.length += ue;
        var ce = I.length < I.highWaterMark;
        if (ce || (I.needDrain = !0), I.writing || I.corked) {
            var he = I.lastBufferedRequest;
            I.lastBufferedRequest = {
                chunk: k,
                encoding: L,
                isBuf: P,
                callback: j,
                next: null
            }, he ? he.next = I.lastBufferedRequest : I.bufferedRequest = I.lastBufferedRequest, I.bufferedRequestCount += 1;
        } else H(T, I, !1, ue, k, L, j);
        return ce;
    }
    function H(T, I, P, k, L, j, ie) {
        I.writelen = k, I.writecb = ie, I.writing = !0, I.sync = !0, P ? T._writev(L, I.onwrite) : T._write(L, j, I.onwrite), I.sync = !1;
    }
    function K(T, I, P, k, L) {
        --I.pendingcb, P ? (e.nextTick(L, k), e.nextTick(g, T, I), T._writableState.errorEmitted = !0, T.emit("error", k)) : (L(k), T._writableState.errorEmitted = !0, T.emit("error", k), g(T, I));
    }
    function re(T) {
        T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0;
    }
    function Q(T, I) {
        var P = T._writableState, k = P.sync, L = P.writecb;
        if (re(P), I) K(T, P, k, I, L);
        else {
            var j = $(P);
            !j && !P.corked && !P.bufferProcessing && P.bufferedRequest && X(T, P), k ? r(G, T, P, j, L) : G(T, P, j, L);
        }
    }
    function G(T, I, P, k) {
        P || R(T, I), I.pendingcb--, k(), g(T, I);
    }
    function R(T, I) {
        I.length === 0 && I.needDrain && (I.needDrain = !1, T.emit("drain"));
    }
    function X(T, I) {
        I.bufferProcessing = !0;
        var P = I.bufferedRequest;
        if (T._writev && P && P.next) {
            var k = I.bufferedRequestCount, L = new Array(k), j = I.corkedRequestsFree;
            j.entry = P;
            for(var ie = 0, ue = !0; P;)L[ie] = P, P.isBuf || (ue = !1), P = P.next, ie += 1;
            L.allBuffers = ue, H(T, I, !0, I.length, L, "", j.finish), I.pendingcb++, I.lastBufferedRequest = null, j.next ? (I.corkedRequestsFree = j.next, j.next = null) : I.corkedRequestsFree = new t(I), I.bufferedRequestCount = 0;
        } else {
            for(; P;){
                var ce = P.chunk, he = P.encoding, ee = P.callback, ae = I.objectMode ? 1 : ce.length;
                if (H(T, I, !1, ae, ce, he, ee), P = P.next, I.bufferedRequestCount--, I.writing) break;
            }
            P === null && (I.lastBufferedRequest = null);
        }
        I.bufferedRequest = P, I.bufferProcessing = !1;
    }
    A.prototype._write = function(T, I, P) {
        P(new Error("_write() is not implemented"));
    }, A.prototype._writev = null, A.prototype.end = function(T, I, P) {
        var k = this._writableState;
        typeof T == "function" ? (P = T, T = null, I = null) : typeof I == "function" && (P = I, I = null), T != null && this.write(T, I), k.corked && (k.corked = 1, this.uncork()), k.ending || m(this, k, P);
    };
    function $(T) {
        return T.ending && T.length === 0 && T.bufferedRequest === null && !T.finished && !T.writing;
    }
    function S(T, I) {
        T._final(function(P) {
            I.pendingcb--, P && T.emit("error", P), I.prefinished = !0, T.emit("prefinish"), g(T, I);
        });
    }
    function w(T, I) {
        !I.prefinished && !I.finalCalled && (typeof T._final == "function" ? (I.pendingcb++, I.finalCalled = !0, e.nextTick(S, T, I)) : (I.prefinished = !0, T.emit("prefinish")));
    }
    function g(T, I) {
        var P = $(I);
        return P && (w(T, I), I.pendingcb === 0 && (I.finished = !0, T.emit("finish"))), P;
    }
    function m(T, I, P) {
        I.ending = !0, g(T, I), P && (I.finished ? e.nextTick(P) : T.once("finish", P)), I.ended = !0, T.writable = !1;
    }
    function E(T, I, P) {
        var k = T.entry;
        for(T.entry = null; k;){
            var L = k.callback;
            I.pendingcb--, L(P), k = k.next;
        }
        I.corkedRequestsFree.next = T;
    }
    return Object.defineProperty(A.prototype, "destroyed", {
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(T) {
            this._writableState && (this._writableState.destroyed = T);
        }
    }), A.prototype.destroy = l.destroy, A.prototype._undestroy = l.undestroy, A.prototype._destroy = function(T, I) {
        this.end(), I(T);
    }, n2;
}
var i2, U5;
function rd() {
    if (U5) return i2;
    U5 = 1;
    var e = Sb(), t = Object.keys || function(l) {
        var p = [];
        for(var y in l)p.push(y);
        return p;
    };
    i2 = u;
    var r = Object.create(o0());
    r.inherits = Or();
    var n = TO(), i = AO();
    r.inherits(u, n);
    for(var o = t(i.prototype), s = 0; s < o.length; s++){
        var a = o[s];
        u.prototype[a] || (u.prototype[a] = i.prototype[a]);
    }
    function u(l) {
        if (!(this instanceof u)) return new u(l);
        n.call(this, l), i.call(this, l), l && l.readable === !1 && (this.readable = !1), l && l.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, l && l.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", f);
    }
    Object.defineProperty(u.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function f() {
        this.allowHalfOpen || this._writableState.ended || e.nextTick(c, this);
    }
    function c(l) {
        l.end();
    }
    return Object.defineProperty(u.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(l) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
        }
    }), u.prototype._destroy = function(l, p) {
        this.push(null), this.end(), e.nextTick(p, l);
    }, i2;
}
var o2 = {}, $5;
function L5() {
    if ($5) return o2;
    $5 = 1;
    var e = Ab().Buffer, t = e.isEncoding || function(N) {
        switch(N = "" + N, N && N.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function r(N) {
        if (!N) return "utf8";
        for(var U;;)switch(N){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return N;
            default:
                if (U) return;
                N = ("" + N).toLowerCase(), U = !0;
        }
    }
    function n(N) {
        var U = r(N);
        if (typeof U != "string" && (e.isEncoding === t || !t(N))) throw new Error("Unknown encoding: " + N);
        return U || N;
    }
    o2.StringDecoder = i;
    function i(N) {
        this.encoding = n(N);
        var U;
        switch(this.encoding){
            case "utf16le":
                this.text = l, this.end = p, U = 4;
                break;
            case "utf8":
                this.fillLast = u, U = 4;
                break;
            case "base64":
                this.text = y, this.end = _, U = 3;
                break;
            default:
                this.write = A, this.end = O;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(U);
    }
    i.prototype.write = function(N) {
        if (N.length === 0) return "";
        var U, D;
        if (this.lastNeed) {
            if (U = this.fillLast(N), U === void 0) return "";
            D = this.lastNeed, this.lastNeed = 0;
        } else D = 0;
        return D < N.length ? U ? U + this.text(N, D) : this.text(N, D) : U || "";
    }, i.prototype.end = c, i.prototype.text = f, i.prototype.fillLast = function(N) {
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, N.length), this.lastNeed -= N.length;
    };
    function o(N) {
        return N <= 127 ? 0 : N >> 5 === 6 ? 2 : N >> 4 === 14 ? 3 : N >> 3 === 30 ? 4 : N >> 6 === 2 ? -1 : -2;
    }
    function s(N, U, D) {
        var H = U.length - 1;
        if (H < D) return 0;
        var K = o(U[H]);
        return K >= 0 ? (K > 0 && (N.lastNeed = K - 1), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (N.lastNeed = K - 2), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (K === 2 ? K = 0 : N.lastNeed = K - 3), K) : 0));
    }
    function a(N, U, D) {
        if ((U[0] & 192) !== 128) return N.lastNeed = 0, "�";
        if (N.lastNeed > 1 && U.length > 1) {
            if ((U[1] & 192) !== 128) return N.lastNeed = 1, "�";
            if (N.lastNeed > 2 && U.length > 2 && (U[2] & 192) !== 128) return N.lastNeed = 2, "�";
        }
    }
    function u(N) {
        var U = this.lastTotal - this.lastNeed, D = a(this, N);
        if (D !== void 0) return D;
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, U, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, U, 0, N.length), this.lastNeed -= N.length;
    }
    function f(N, U) {
        var D = s(this, N, U);
        if (!this.lastNeed) return N.toString("utf8", U);
        this.lastTotal = D;
        var H = N.length - (D - this.lastNeed);
        return N.copy(this.lastChar, 0, H), N.toString("utf8", U, H);
    }
    function c(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + "�" : U;
    }
    function l(N, U) {
        if ((N.length - U) % 2 === 0) {
            var D = N.toString("utf16le", U);
            if (D) {
                var H = D.charCodeAt(D.length - 1);
                if (H >= 55296 && H <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1], D.slice(0, -1);
            }
            return D;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = N[N.length - 1], N.toString("utf16le", U, N.length - 1);
    }
    function p(N) {
        var U = N && N.length ? this.write(N) : "";
        if (this.lastNeed) {
            var D = this.lastTotal - this.lastNeed;
            return U + this.lastChar.toString("utf16le", 0, D);
        }
        return U;
    }
    function y(N, U) {
        var D = (N.length - U) % 3;
        return D === 0 ? N.toString("base64", U) : (this.lastNeed = 3 - D, this.lastTotal = 3, D === 1 ? this.lastChar[0] = N[N.length - 1] : (this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1]), N.toString("base64", U, N.length - D));
    }
    function _(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : U;
    }
    function A(N) {
        return N.toString(this.encoding);
    }
    function O(N) {
        return N && N.length ? this.write(N) : "";
    }
    return o2;
}
var s2, D5;
function TO() {
    if (D5) return s2;
    D5 = 1;
    var e = Sb();
    s2 = U;
    var t = cX(), r;
    U.ReadableState = N, EO().EventEmitter;
    var n = function(ee, ae) {
        return ee.listeners(ae).length;
    }, i = xO(), o = Ab().Buffer, s = (typeof Ge < "u" ? Ge : ("TURBOPACK compile-time value", "undefined") < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function a(ee) {
        return o.from(ee);
    }
    function u(ee) {
        return o.isBuffer(ee) || ee instanceof s;
    }
    var f = Object.create(o0());
    f.inherits = Or();
    var c = Iu, l = void 0;
    c && c.debuglog ? l = c.debuglog("stream") : l = function() {};
    var p = uX(), y = SO(), _;
    f.inherits(U, i);
    var A = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function O(ee, ae, ye) {
        if (typeof ee.prependListener == "function") return ee.prependListener(ae, ye);
        !ee._events || !ee._events[ae] ? ee.on(ae, ye) : t(ee._events[ae]) ? ee._events[ae].unshift(ye) : ee._events[ae] = [
            ye,
            ee._events[ae]
        ];
    }
    function N(ee, ae) {
        r = r || rd(), ee = ee || {};
        var ye = ae instanceof r;
        this.objectMode = !!ee.objectMode, ye && (this.objectMode = this.objectMode || !!ee.readableObjectMode);
        var Se = ee.highWaterMark, De = ee.readableHighWaterMark, Re = this.objectMode ? 16 : 16 * 1024;
        Se || Se === 0 ? this.highWaterMark = Se : ye && (De || De === 0) ? this.highWaterMark = De : this.highWaterMark = Re, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = ee.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ee.encoding && (_ || (_ = L5().StringDecoder), this.decoder = new _(ee.encoding), this.encoding = ee.encoding);
    }
    function U(ee) {
        if (r = r || rd(), !(this instanceof U)) return new U(ee);
        this._readableState = new N(ee, this), this.readable = !0, ee && (typeof ee.read == "function" && (this._read = ee.read), typeof ee.destroy == "function" && (this._destroy = ee.destroy)), i.call(this);
    }
    Object.defineProperty(U.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(ee) {
            this._readableState && (this._readableState.destroyed = ee);
        }
    }), U.prototype.destroy = y.destroy, U.prototype._undestroy = y.undestroy, U.prototype._destroy = function(ee, ae) {
        this.push(null), ae(ee);
    }, U.prototype.push = function(ee, ae) {
        var ye = this._readableState, Se;
        return ye.objectMode ? Se = !0 : typeof ee == "string" && (ae = ae || ye.defaultEncoding, ae !== ye.encoding && (ee = o.from(ee, ae), ae = ""), Se = !0), D(this, ee, ae, !1, Se);
    }, U.prototype.unshift = function(ee) {
        return D(this, ee, null, !0, !1);
    };
    function D(ee, ae, ye, Se, De) {
        var Re = ee._readableState;
        if (ae === null) Re.reading = !1, X(ee, Re);
        else {
            var Ce;
            De || (Ce = K(Re, ae)), Ce ? ee.emit("error", Ce) : Re.objectMode || ae && ae.length > 0 ? (typeof ae != "string" && !Re.objectMode && Object.getPrototypeOf(ae) !== o.prototype && (ae = a(ae)), Se ? Re.endEmitted ? ee.emit("error", new Error("stream.unshift() after end event")) : H(ee, Re, ae, !0) : Re.ended ? ee.emit("error", new Error("stream.push() after EOF")) : (Re.reading = !1, Re.decoder && !ye ? (ae = Re.decoder.write(ae), Re.objectMode || ae.length !== 0 ? H(ee, Re, ae, !1) : w(ee, Re)) : H(ee, Re, ae, !1))) : Se || (Re.reading = !1);
        }
        return re(Re);
    }
    function H(ee, ae, ye, Se) {
        ae.flowing && ae.length === 0 && !ae.sync ? (ee.emit("data", ye), ee.read(0)) : (ae.length += ae.objectMode ? 1 : ye.length, Se ? ae.buffer.unshift(ye) : ae.buffer.push(ye), ae.needReadable && $(ee)), w(ee, ae);
    }
    function K(ee, ae) {
        var ye;
        return !u(ae) && typeof ae != "string" && ae !== void 0 && !ee.objectMode && (ye = new TypeError("Invalid non-string/buffer chunk")), ye;
    }
    function re(ee) {
        return !ee.ended && (ee.needReadable || ee.length < ee.highWaterMark || ee.length === 0);
    }
    U.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    }, U.prototype.setEncoding = function(ee) {
        return _ || (_ = L5().StringDecoder), this._readableState.decoder = new _(ee), this._readableState.encoding = ee, this;
    };
    var Q = 8388608;
    function G(ee) {
        return ee >= Q ? ee = Q : (ee--, ee |= ee >>> 1, ee |= ee >>> 2, ee |= ee >>> 4, ee |= ee >>> 8, ee |= ee >>> 16, ee++), ee;
    }
    function R(ee, ae) {
        return ee <= 0 || ae.length === 0 && ae.ended ? 0 : ae.objectMode ? 1 : ee !== ee ? ae.flowing && ae.length ? ae.buffer.head.data.length : ae.length : (ee > ae.highWaterMark && (ae.highWaterMark = G(ee)), ee <= ae.length ? ee : ae.ended ? ae.length : (ae.needReadable = !0, 0));
    }
    U.prototype.read = function(ee) {
        l("read", ee), ee = parseInt(ee, 10);
        var ae = this._readableState, ye = ee;
        if (ee !== 0 && (ae.emittedReadable = !1), ee === 0 && ae.needReadable && (ae.length >= ae.highWaterMark || ae.ended)) return l("read: emitReadable", ae.length, ae.ended), ae.length === 0 && ae.ended ? ue(this) : $(this), null;
        if (ee = R(ee, ae), ee === 0 && ae.ended) return ae.length === 0 && ue(this), null;
        var Se = ae.needReadable;
        l("need readable", Se), (ae.length === 0 || ae.length - ee < ae.highWaterMark) && (Se = !0, l("length less than watermark", Se)), ae.ended || ae.reading ? (Se = !1, l("reading or ended", Se)) : Se && (l("do read"), ae.reading = !0, ae.sync = !0, ae.length === 0 && (ae.needReadable = !0), this._read(ae.highWaterMark), ae.sync = !1, ae.reading || (ee = R(ye, ae)));
        var De;
        return ee > 0 ? De = k(ee, ae) : De = null, De === null ? (ae.needReadable = !0, ee = 0) : ae.length -= ee, ae.length === 0 && (ae.ended || (ae.needReadable = !0), ye !== ee && ae.ended && ue(this)), De !== null && this.emit("data", De), De;
    };
    function X(ee, ae) {
        if (!ae.ended) {
            if (ae.decoder) {
                var ye = ae.decoder.end();
                ye && ye.length && (ae.buffer.push(ye), ae.length += ae.objectMode ? 1 : ye.length);
            }
            ae.ended = !0, $(ee);
        }
    }
    function $(ee) {
        var ae = ee._readableState;
        ae.needReadable = !1, ae.emittedReadable || (l("emitReadable", ae.flowing), ae.emittedReadable = !0, ae.sync ? e.nextTick(S, ee) : S(ee));
    }
    function S(ee) {
        l("emit readable"), ee.emit("readable"), P(ee);
    }
    function w(ee, ae) {
        ae.readingMore || (ae.readingMore = !0, e.nextTick(g, ee, ae));
    }
    function g(ee, ae) {
        for(var ye = ae.length; !ae.reading && !ae.flowing && !ae.ended && ae.length < ae.highWaterMark && (l("maybeReadMore read 0"), ee.read(0), ye !== ae.length);)ye = ae.length;
        ae.readingMore = !1;
    }
    U.prototype._read = function(ee) {
        this.emit("error", new Error("_read() is not implemented"));
    }, U.prototype.pipe = function(ee, ae) {
        var ye = this, Se = this._readableState;
        switch(Se.pipesCount){
            case 0:
                Se.pipes = ee;
                break;
            case 1:
                Se.pipes = [
                    Se.pipes,
                    ee
                ];
                break;
            default:
                Se.pipes.push(ee);
                break;
        }
        Se.pipesCount += 1, l("pipe count=%d opts=%j", Se.pipesCount, ae);
        var De = (!ae || ae.end !== !1) && ee !== bn.stdout && ee !== bn.stderr, Re = De ? M : x;
        Se.endEmitted ? e.nextTick(Re) : ye.once("end", Re), ee.on("unpipe", Ce);
        function Ce(q, te) {
            l("onunpipe"), q === ye && te && te.hasUnpiped === !1 && (te.hasUnpiped = !0, _e());
        }
        function M() {
            l("onend"), ee.end();
        }
        var z = m(ye);
        ee.on("drain", z);
        var de = !1;
        function _e() {
            l("cleanup"), ee.removeListener("close", Ue), ee.removeListener("finish", h), ee.removeListener("drain", z), ee.removeListener("error", Ke), ee.removeListener("unpipe", Ce), ye.removeListener("end", M), ye.removeListener("end", x), ye.removeListener("data", je), de = !0, Se.awaitDrain && (!ee._writableState || ee._writableState.needDrain) && z();
        }
        var Ie = !1;
        ye.on("data", je);
        function je(q) {
            l("ondata"), Ie = !1;
            var te = ee.write(q);
            te === !1 && !Ie && ((Se.pipesCount === 1 && Se.pipes === ee || Se.pipesCount > 1 && he(Se.pipes, ee) !== -1) && !de && (l("false write response, pause", Se.awaitDrain), Se.awaitDrain++, Ie = !0), ye.pause());
        }
        function Ke(q) {
            l("onerror", q), x(), ee.removeListener("error", Ke), n(ee, "error") === 0 && ee.emit("error", q);
        }
        O(ee, "error", Ke);
        function Ue() {
            ee.removeListener("finish", h), x();
        }
        ee.once("close", Ue);
        function h() {
            l("onfinish"), ee.removeListener("close", Ue), x();
        }
        ee.once("finish", h);
        function x() {
            l("unpipe"), ye.unpipe(ee);
        }
        return ee.emit("pipe", ye), Se.flowing || (l("pipe resume"), ye.resume()), ee;
    };
    function m(ee) {
        return function() {
            var ae = ee._readableState;
            l("pipeOnDrain", ae.awaitDrain), ae.awaitDrain && ae.awaitDrain--, ae.awaitDrain === 0 && n(ee, "data") && (ae.flowing = !0, P(ee));
        };
    }
    U.prototype.unpipe = function(ee) {
        var ae = this._readableState, ye = {
            hasUnpiped: !1
        };
        if (ae.pipesCount === 0) return this;
        if (ae.pipesCount === 1) return ee && ee !== ae.pipes ? this : (ee || (ee = ae.pipes), ae.pipes = null, ae.pipesCount = 0, ae.flowing = !1, ee && ee.emit("unpipe", this, ye), this);
        if (!ee) {
            var Se = ae.pipes, De = ae.pipesCount;
            ae.pipes = null, ae.pipesCount = 0, ae.flowing = !1;
            for(var Re = 0; Re < De; Re++)Se[Re].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var Ce = he(ae.pipes, ee);
        return Ce === -1 ? this : (ae.pipes.splice(Ce, 1), ae.pipesCount -= 1, ae.pipesCount === 1 && (ae.pipes = ae.pipes[0]), ee.emit("unpipe", this, ye), this);
    }, U.prototype.on = function(ee, ae) {
        var ye = i.prototype.on.call(this, ee, ae);
        if (ee === "data") this._readableState.flowing !== !1 && this.resume();
        else if (ee === "readable") {
            var Se = this._readableState;
            !Se.endEmitted && !Se.readableListening && (Se.readableListening = Se.needReadable = !0, Se.emittedReadable = !1, Se.reading ? Se.length && $(this) : e.nextTick(E, this));
        }
        return ye;
    }, U.prototype.addListener = U.prototype.on;
    function E(ee) {
        l("readable nexttick read 0"), ee.read(0);
    }
    U.prototype.resume = function() {
        var ee = this._readableState;
        return ee.flowing || (l("resume"), ee.flowing = !0, T(this, ee)), this;
    };
    function T(ee, ae) {
        ae.resumeScheduled || (ae.resumeScheduled = !0, e.nextTick(I, ee, ae));
    }
    function I(ee, ae) {
        ae.reading || (l("resume read 0"), ee.read(0)), ae.resumeScheduled = !1, ae.awaitDrain = 0, ee.emit("resume"), P(ee), ae.flowing && !ae.reading && ee.read(0);
    }
    U.prototype.pause = function() {
        return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    };
    function P(ee) {
        var ae = ee._readableState;
        for(l("flow", ae.flowing); ae.flowing && ee.read() !== null;);
    }
    U.prototype.wrap = function(ee) {
        var ae = this, ye = this._readableState, Se = !1;
        ee.on("end", function() {
            if (l("wrapped end"), ye.decoder && !ye.ended) {
                var Ce = ye.decoder.end();
                Ce && Ce.length && ae.push(Ce);
            }
            ae.push(null);
        }), ee.on("data", function(Ce) {
            if (l("wrapped data"), ye.decoder && (Ce = ye.decoder.write(Ce)), !(ye.objectMode && Ce == null) && !(!ye.objectMode && (!Ce || !Ce.length))) {
                var M = ae.push(Ce);
                M || (Se = !0, ee.pause());
            }
        });
        for(var De in ee)this[De] === void 0 && typeof ee[De] == "function" && (this[De] = /* @__PURE__ */ function(Ce) {
            return function() {
                return ee[Ce].apply(ee, arguments);
            };
        }(De));
        for(var Re = 0; Re < A.length; Re++)ee.on(A[Re], this.emit.bind(this, A[Re]));
        return this._read = function(Ce) {
            l("wrapped _read", Ce), Se && (Se = !1, ee.resume());
        }, this;
    }, Object.defineProperty(U.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    }), U._fromList = k;
    function k(ee, ae) {
        if (ae.length === 0) return null;
        var ye;
        return ae.objectMode ? ye = ae.buffer.shift() : !ee || ee >= ae.length ? (ae.decoder ? ye = ae.buffer.join("") : ae.buffer.length === 1 ? ye = ae.buffer.head.data : ye = ae.buffer.concat(ae.length), ae.buffer.clear()) : ye = L(ee, ae.buffer, ae.decoder), ye;
    }
    function L(ee, ae, ye) {
        var Se;
        return ee < ae.head.data.length ? (Se = ae.head.data.slice(0, ee), ae.head.data = ae.head.data.slice(ee)) : ee === ae.head.data.length ? Se = ae.shift() : Se = ye ? j(ee, ae) : ie(ee, ae), Se;
    }
    function j(ee, ae) {
        var ye = ae.head, Se = 1, De = ye.data;
        for(ee -= De.length; ye = ye.next;){
            var Re = ye.data, Ce = ee > Re.length ? Re.length : ee;
            if (Ce === Re.length ? De += Re : De += Re.slice(0, ee), ee -= Ce, ee === 0) {
                Ce === Re.length ? (++Se, ye.next ? ae.head = ye.next : ae.head = ae.tail = null) : (ae.head = ye, ye.data = Re.slice(Ce));
                break;
            }
            ++Se;
        }
        return ae.length -= Se, De;
    }
    function ie(ee, ae) {
        var ye = o.allocUnsafe(ee), Se = ae.head, De = 1;
        for(Se.data.copy(ye), ee -= Se.data.length; Se = Se.next;){
            var Re = Se.data, Ce = ee > Re.length ? Re.length : ee;
            if (Re.copy(ye, ye.length - ee, 0, Ce), ee -= Ce, ee === 0) {
                Ce === Re.length ? (++De, Se.next ? ae.head = Se.next : ae.head = ae.tail = null) : (ae.head = Se, Se.data = Re.slice(Ce));
                break;
            }
            ++De;
        }
        return ae.length -= De, ye;
    }
    function ue(ee) {
        var ae = ee._readableState;
        if (ae.length > 0) throw new Error('"endReadable()" called on non-empty stream');
        ae.endEmitted || (ae.ended = !0, e.nextTick(ce, ae, ee));
    }
    function ce(ee, ae) {
        !ee.endEmitted && ee.length === 0 && (ee.endEmitted = !0, ae.readable = !1, ae.emit("end"));
    }
    function he(ee, ae) {
        for(var ye = 0, Se = ee.length; ye < Se; ye++)if (ee[ye] === ae) return ye;
        return -1;
    }
    return s2;
}
var a2, F5;
function kO() {
    if (F5) return a2;
    F5 = 1, a2 = n;
    var e = rd(), t = Object.create(o0());
    t.inherits = Or(), t.inherits(n, e);
    function r(s, a) {
        var u = this._transformState;
        u.transforming = !1;
        var f = u.writecb;
        if (!f) return this.emit("error", new Error("write callback called multiple times"));
        u.writechunk = null, u.writecb = null, a != null && this.push(a), f(s);
        var c = this._readableState;
        c.reading = !1, (c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
    }
    function n(s) {
        if (!(this instanceof n)) return new n(s);
        e.call(this, s), this._transformState = {
            afterTransform: r.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", i);
    }
    function i() {
        var s = this;
        typeof this._flush == "function" ? this._flush(function(a, u) {
            o(s, a, u);
        }) : o(this, null, null);
    }
    n.prototype.push = function(s, a) {
        return this._transformState.needTransform = !1, e.prototype.push.call(this, s, a);
    }, n.prototype._transform = function(s, a, u) {
        throw new Error("_transform() is not implemented");
    }, n.prototype._write = function(s, a, u) {
        var f = this._transformState;
        if (f.writecb = u, f.writechunk = s, f.writeencoding = a, !f.transforming) {
            var c = this._readableState;
            (f.needTransform || c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
        }
    }, n.prototype._read = function(s) {
        var a = this._transformState;
        a.writechunk !== null && a.writecb && !a.transforming ? (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)) : a.needTransform = !0;
    }, n.prototype._destroy = function(s, a) {
        var u = this;
        e.prototype._destroy.call(this, s, function(f) {
            a(f), u.emit("close");
        });
    };
    function o(s, a, u) {
        if (a) return s.emit("error", a);
        if (u != null && s.push(u), s._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (s._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return s.push(null);
    }
    return a2;
}
var c2, z5;
function lX() {
    if (z5) return c2;
    z5 = 1, c2 = r;
    var e = kO(), t = Object.create(o0());
    t.inherits = Or(), t.inherits(r, e);
    function r(n) {
        if (!(this instanceof r)) return new r(n);
        e.call(this, n);
    }
    return r.prototype._transform = function(n, i, o) {
        o(null, n);
    }, c2;
}
var j5;
function dX() {
    return j5 || (j5 = 1, function(e, t) {
        t = e.exports = TO(), t.Stream = t, t.Readable = t, t.Writable = AO(), t.Duplex = rd(), t.Transform = kO(), t.PassThrough = lX();
    }(jg, jg.exports)), jg.exports;
}
var dh = {
    exports: {}
}, Iy = {
    exports: {}
};
Iy.exports;
var H5;
function D3() {
    return H5 || (H5 = 1, function(e) {
        (function(t, r) {
            function n(w, g) {
                if (!w) throw new Error(g || "Assertion failed");
            }
            function i(w, g) {
                w.super_ = g;
                var m = function() {};
                m.prototype = g.prototype, w.prototype = new m(), w.prototype.constructor = w;
            }
            function o(w, g, m) {
                if (o.isBN(w)) return w;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, w !== null && ((g === "le" || g === "be") && (m = g, g = 10), this._init(w || 0, g || 10, m || "be"));
            }
            typeof t == "object" ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
            var s;
            try {
                ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = Iu.Buffer;
            } catch  {}
            o.isBN = function(g) {
                return g instanceof o ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === o.wordSize && Array.isArray(g.words);
            }, o.max = function(g, m) {
                return g.cmp(m) > 0 ? g : m;
            }, o.min = function(g, m) {
                return g.cmp(m) < 0 ? g : m;
            }, o.prototype._init = function(g, m, E) {
                if (typeof g == "number") return this._initNumber(g, m, E);
                if (typeof g == "object") return this._initArray(g, m, E);
                m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), g = g.toString().replace(/\s+/g, "");
                var T = 0;
                g[0] === "-" && (T++, this.negative = 1), T < g.length && (m === 16 ? this._parseHex(g, T, E) : (this._parseBase(g, m, T), E === "le" && this._initArray(this.toArray(), m, E)));
            }, o.prototype._initNumber = function(g, m, E) {
                g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [
                    g & 67108863
                ], this.length = 1) : g < 4503599627370496 ? (this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863
                ], this.length = 2) : (n(g < 9007199254740992), this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863,
                    1
                ], this.length = 3), E === "le" && this._initArray(this.toArray(), m, E);
            }, o.prototype._initArray = function(g, m, E) {
                if (n(typeof g.length == "number"), g.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
                for(var T = 0; T < this.length; T++)this.words[T] = 0;
                var I, P, k = 0;
                if (E === "be") for(T = g.length - 1, I = 0; T >= 0; T -= 3)P = g[T] | g[T - 1] << 8 | g[T - 2] << 16, this.words[I] |= P << k & 67108863, this.words[I + 1] = P >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, I++);
                else if (E === "le") for(T = 0, I = 0; T < g.length; T += 3)P = g[T] | g[T + 1] << 8 | g[T + 2] << 16, this.words[I] |= P << k & 67108863, this.words[I + 1] = P >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, I++);
                return this._strip();
            };
            function a(w, g) {
                var m = w.charCodeAt(g);
                if (m >= 48 && m <= 57) return m - 48;
                if (m >= 65 && m <= 70) return m - 55;
                if (m >= 97 && m <= 102) return m - 87;
                n(!1, "Invalid character in " + w);
            }
            function u(w, g, m) {
                var E = a(w, m);
                return m - 1 >= g && (E |= a(w, m - 1) << 4), E;
            }
            o.prototype._parseHex = function(g, m, E) {
                this.length = Math.ceil((g.length - m) / 6), this.words = new Array(this.length);
                for(var T = 0; T < this.length; T++)this.words[T] = 0;
                var I = 0, P = 0, k;
                if (E === "be") for(T = g.length - 1; T >= m; T -= 2)k = u(g, m, T) << I, this.words[P] |= k & 67108863, I >= 18 ? (I -= 18, P += 1, this.words[P] |= k >>> 26) : I += 8;
                else {
                    var L = g.length - m;
                    for(T = L % 2 === 0 ? m + 1 : m; T < g.length; T += 2)k = u(g, m, T) << I, this.words[P] |= k & 67108863, I >= 18 ? (I -= 18, P += 1, this.words[P] |= k >>> 26) : I += 8;
                }
                this._strip();
            };
            function f(w, g, m, E) {
                for(var T = 0, I = 0, P = Math.min(w.length, m), k = g; k < P; k++){
                    var L = w.charCodeAt(k) - 48;
                    T *= E, L >= 49 ? I = L - 49 + 10 : L >= 17 ? I = L - 17 + 10 : I = L, n(L >= 0 && I < E, "Invalid character"), T += I;
                }
                return T;
            }
            o.prototype._parseBase = function(g, m, E) {
                this.words = [
                    0
                ], this.length = 1;
                for(var T = 0, I = 1; I <= 67108863; I *= m)T++;
                T--, I = I / m | 0;
                for(var P = g.length - E, k = P % T, L = Math.min(P, P - k) + E, j = 0, ie = E; ie < L; ie += T)j = f(g, ie, ie + T, m), this.imuln(I), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
                if (k !== 0) {
                    var ue = 1;
                    for(j = f(g, ie, g.length, m), ie = 0; ie < k; ie++)ue *= m;
                    this.imuln(ue), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
                }
                this._strip();
            }, o.prototype.copy = function(g) {
                g.words = new Array(this.length);
                for(var m = 0; m < this.length; m++)g.words[m] = this.words[m];
                g.length = this.length, g.negative = this.negative, g.red = this.red;
            };
            function c(w, g) {
                w.words = g.words, w.length = g.length, w.negative = g.negative, w.red = g.red;
            }
            if (o.prototype._move = function(g) {
                c(g, this);
            }, o.prototype.clone = function() {
                var g = new o(null);
                return this.copy(g), g;
            }, o.prototype._expand = function(g) {
                for(; this.length < g;)this.words[this.length++] = 0;
                return this;
            }, o.prototype._strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, o.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
                o.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
            } catch  {
                o.prototype.inspect = l;
            }
            else o.prototype.inspect = l;
            function l() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            }
            var p = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], y = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], _ = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            o.prototype.toString = function(g, m) {
                g = g || 10, m = m | 0 || 1;
                var E;
                if (g === 16 || g === "hex") {
                    E = "";
                    for(var T = 0, I = 0, P = 0; P < this.length; P++){
                        var k = this.words[P], L = ((k << T | I) & 16777215).toString(16);
                        I = k >>> 24 - T & 16777215, T += 2, T >= 26 && (T -= 26, P--), I !== 0 || P !== this.length - 1 ? E = p[6 - L.length] + L + E : E = L + E;
                    }
                    for(I !== 0 && (E = I.toString(16) + E); E.length % m !== 0;)E = "0" + E;
                    return this.negative !== 0 && (E = "-" + E), E;
                }
                if (g === (g | 0) && g >= 2 && g <= 36) {
                    var j = y[g], ie = _[g];
                    E = "";
                    var ue = this.clone();
                    for(ue.negative = 0; !ue.isZero();){
                        var ce = ue.modrn(ie).toString(g);
                        ue = ue.idivn(ie), ue.isZero() ? E = ce + E : E = p[j - ce.length] + ce + E;
                    }
                    for(this.isZero() && (E = "0" + E); E.length % m !== 0;)E = "0" + E;
                    return this.negative !== 0 && (E = "-" + E), E;
                }
                n(!1, "Base should be between 2 and 36");
            }, o.prototype.toNumber = function() {
                var g = this.words[0];
                return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
            }, o.prototype.toJSON = function() {
                return this.toString(16, 2);
            }, s && (o.prototype.toBuffer = function(g, m) {
                return this.toArrayLike(s, g, m);
            }), o.prototype.toArray = function(g, m) {
                return this.toArrayLike(Array, g, m);
            };
            var A = function(g, m) {
                return g.allocUnsafe ? g.allocUnsafe(m) : new g(m);
            };
            o.prototype.toArrayLike = function(g, m, E) {
                this._strip();
                var T = this.byteLength(), I = E || Math.max(1, T);
                n(T <= I, "byte array longer than desired length"), n(I > 0, "Requested array length <= 0");
                var P = A(g, I), k = m === "le" ? "LE" : "BE";
                return this["_toArrayLike" + k](P, T), P;
            }, o.prototype._toArrayLikeLE = function(g, m) {
                for(var E = 0, T = 0, I = 0, P = 0; I < this.length; I++){
                    var k = this.words[I] << P | T;
                    g[E++] = k & 255, E < g.length && (g[E++] = k >> 8 & 255), E < g.length && (g[E++] = k >> 16 & 255), P === 6 ? (E < g.length && (g[E++] = k >> 24 & 255), T = 0, P = 0) : (T = k >>> 24, P += 2);
                }
                if (E < g.length) for(g[E++] = T; E < g.length;)g[E++] = 0;
            }, o.prototype._toArrayLikeBE = function(g, m) {
                for(var E = g.length - 1, T = 0, I = 0, P = 0; I < this.length; I++){
                    var k = this.words[I] << P | T;
                    g[E--] = k & 255, E >= 0 && (g[E--] = k >> 8 & 255), E >= 0 && (g[E--] = k >> 16 & 255), P === 6 ? (E >= 0 && (g[E--] = k >> 24 & 255), T = 0, P = 0) : (T = k >>> 24, P += 2);
                }
                if (E >= 0) for(g[E--] = T; E >= 0;)g[E--] = 0;
            }, Math.clz32 ? o.prototype._countBits = function(g) {
                return 32 - Math.clz32(g);
            } : o.prototype._countBits = function(g) {
                var m = g, E = 0;
                return m >= 4096 && (E += 13, m >>>= 13), m >= 64 && (E += 7, m >>>= 7), m >= 8 && (E += 4, m >>>= 4), m >= 2 && (E += 2, m >>>= 2), E + m;
            }, o.prototype._zeroBits = function(g) {
                if (g === 0) return 26;
                var m = g, E = 0;
                return m & 8191 || (E += 13, m >>>= 13), m & 127 || (E += 7, m >>>= 7), m & 15 || (E += 4, m >>>= 4), m & 3 || (E += 2, m >>>= 2), m & 1 || E++, E;
            }, o.prototype.bitLength = function() {
                var g = this.words[this.length - 1], m = this._countBits(g);
                return (this.length - 1) * 26 + m;
            };
            function O(w) {
                for(var g = new Array(w.bitLength()), m = 0; m < g.length; m++){
                    var E = m / 26 | 0, T = m % 26;
                    g[m] = w.words[E] >>> T & 1;
                }
                return g;
            }
            o.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var g = 0, m = 0; m < this.length; m++){
                    var E = this._zeroBits(this.words[m]);
                    if (g += E, E !== 26) break;
                }
                return g;
            }, o.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, o.prototype.toTwos = function(g) {
                return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
            }, o.prototype.fromTwos = function(g) {
                return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
            }, o.prototype.isNeg = function() {
                return this.negative !== 0;
            }, o.prototype.neg = function() {
                return this.clone().ineg();
            }, o.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, o.prototype.iuor = function(g) {
                for(; this.length < g.length;)this.words[this.length++] = 0;
                for(var m = 0; m < g.length; m++)this.words[m] = this.words[m] | g.words[m];
                return this._strip();
            }, o.prototype.ior = function(g) {
                return n((this.negative | g.negative) === 0), this.iuor(g);
            }, o.prototype.or = function(g) {
                return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
            }, o.prototype.uor = function(g) {
                return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
            }, o.prototype.iuand = function(g) {
                var m;
                this.length > g.length ? m = g : m = this;
                for(var E = 0; E < m.length; E++)this.words[E] = this.words[E] & g.words[E];
                return this.length = m.length, this._strip();
            }, o.prototype.iand = function(g) {
                return n((this.negative | g.negative) === 0), this.iuand(g);
            }, o.prototype.and = function(g) {
                return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
            }, o.prototype.uand = function(g) {
                return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
            }, o.prototype.iuxor = function(g) {
                var m, E;
                this.length > g.length ? (m = this, E = g) : (m = g, E = this);
                for(var T = 0; T < E.length; T++)this.words[T] = m.words[T] ^ E.words[T];
                if (this !== m) for(; T < m.length; T++)this.words[T] = m.words[T];
                return this.length = m.length, this._strip();
            }, o.prototype.ixor = function(g) {
                return n((this.negative | g.negative) === 0), this.iuxor(g);
            }, o.prototype.xor = function(g) {
                return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
            }, o.prototype.uxor = function(g) {
                return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
            }, o.prototype.inotn = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = Math.ceil(g / 26) | 0, E = g % 26;
                this._expand(m), E > 0 && m--;
                for(var T = 0; T < m; T++)this.words[T] = ~this.words[T] & 67108863;
                return E > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - E), this._strip();
            }, o.prototype.notn = function(g) {
                return this.clone().inotn(g);
            }, o.prototype.setn = function(g, m) {
                n(typeof g == "number" && g >= 0);
                var E = g / 26 | 0, T = g % 26;
                return this._expand(E + 1), m ? this.words[E] = this.words[E] | 1 << T : this.words[E] = this.words[E] & ~(1 << T), this._strip();
            }, o.prototype.iadd = function(g) {
                var m;
                if (this.negative !== 0 && g.negative === 0) return this.negative = 0, m = this.isub(g), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && g.negative !== 0) return g.negative = 0, m = this.isub(g), g.negative = 1, m._normSign();
                var E, T;
                this.length > g.length ? (E = this, T = g) : (E = g, T = this);
                for(var I = 0, P = 0; P < T.length; P++)m = (E.words[P] | 0) + (T.words[P] | 0) + I, this.words[P] = m & 67108863, I = m >>> 26;
                for(; I !== 0 && P < E.length; P++)m = (E.words[P] | 0) + I, this.words[P] = m & 67108863, I = m >>> 26;
                if (this.length = E.length, I !== 0) this.words[this.length] = I, this.length++;
                else if (E !== this) for(; P < E.length; P++)this.words[P] = E.words[P];
                return this;
            }, o.prototype.add = function(g) {
                var m;
                return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, m = this.sub(g), g.negative ^= 1, m) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = g.sub(this), this.negative = 1, m) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
            }, o.prototype.isub = function(g) {
                if (g.negative !== 0) {
                    g.negative = 0;
                    var m = this.iadd(g);
                    return g.negative = 1, m._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
                var E = this.cmp(g);
                if (E === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var T, I;
                E > 0 ? (T = this, I = g) : (T = g, I = this);
                for(var P = 0, k = 0; k < I.length; k++)m = (T.words[k] | 0) - (I.words[k] | 0) + P, P = m >> 26, this.words[k] = m & 67108863;
                for(; P !== 0 && k < T.length; k++)m = (T.words[k] | 0) + P, P = m >> 26, this.words[k] = m & 67108863;
                if (P === 0 && k < T.length && T !== this) for(; k < T.length; k++)this.words[k] = T.words[k];
                return this.length = Math.max(this.length, k), T !== this && (this.negative = 1), this._strip();
            }, o.prototype.sub = function(g) {
                return this.clone().isub(g);
            };
            function N(w, g, m) {
                m.negative = g.negative ^ w.negative;
                var E = w.length + g.length | 0;
                m.length = E, E = E - 1 | 0;
                var T = w.words[0] | 0, I = g.words[0] | 0, P = T * I, k = P & 67108863, L = P / 67108864 | 0;
                m.words[0] = k;
                for(var j = 1; j < E; j++){
                    for(var ie = L >>> 26, ue = L & 67108863, ce = Math.min(j, g.length - 1), he = Math.max(0, j - w.length + 1); he <= ce; he++){
                        var ee = j - he | 0;
                        T = w.words[ee] | 0, I = g.words[he] | 0, P = T * I + ue, ie += P / 67108864 | 0, ue = P & 67108863;
                    }
                    m.words[j] = ue | 0, L = ie | 0;
                }
                return L !== 0 ? m.words[j] = L | 0 : m.length--, m._strip();
            }
            var U = function(g, m, E) {
                var T = g.words, I = m.words, P = E.words, k = 0, L, j, ie, ue = T[0] | 0, ce = ue & 8191, he = ue >>> 13, ee = T[1] | 0, ae = ee & 8191, ye = ee >>> 13, Se = T[2] | 0, De = Se & 8191, Re = Se >>> 13, Ce = T[3] | 0, M = Ce & 8191, z = Ce >>> 13, de = T[4] | 0, _e = de & 8191, Ie = de >>> 13, je = T[5] | 0, Ke = je & 8191, Ue = je >>> 13, h = T[6] | 0, x = h & 8191, q = h >>> 13, te = T[7] | 0, fe = te & 8191, ne = te >>> 13, W = T[8] | 0, J = W & 8191, V = W >>> 13, C = T[9] | 0, Z = C & 8191, le = C >>> 13, se = I[0] | 0, Ne = se & 8191, Le = se >>> 13, rt = I[1] | 0, yt = rt & 8191, _t = rt >>> 13, Qe = I[2] | 0, Rt = Qe & 8191, Lt = Qe >>> 13, Ur = I[3] | 0, jr = Ur & 8191, Et = Ur >>> 13, Xt = I[4] | 0, wr = Xt & 8191, zt = Xt >>> 13, Ae = I[5] | 0, we = Ae & 8191, xe = Ae >>> 13, Me = I[6] | 0, ze = Me & 8191, Ve = Me >>> 13, at = I[7] | 0, ct = at & 8191, lt = at >>> 13, mt = I[8] | 0, wt = mt & 8191, bt = mt >>> 13, Mt = I[9] | 0, Ct = Mt & 8191, Xe = Mt >>> 13;
                E.negative = g.negative ^ m.negative, E.length = 19, L = Math.imul(ce, Ne), j = Math.imul(ce, Le), j = j + Math.imul(he, Ne) | 0, ie = Math.imul(he, Le);
                var xt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, L = Math.imul(ae, Ne), j = Math.imul(ae, Le), j = j + Math.imul(ye, Ne) | 0, ie = Math.imul(ye, Le), L = L + Math.imul(ce, yt) | 0, j = j + Math.imul(ce, _t) | 0, j = j + Math.imul(he, yt) | 0, ie = ie + Math.imul(he, _t) | 0;
                var St = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, L = Math.imul(De, Ne), j = Math.imul(De, Le), j = j + Math.imul(Re, Ne) | 0, ie = Math.imul(Re, Le), L = L + Math.imul(ae, yt) | 0, j = j + Math.imul(ae, _t) | 0, j = j + Math.imul(ye, yt) | 0, ie = ie + Math.imul(ye, _t) | 0, L = L + Math.imul(ce, Rt) | 0, j = j + Math.imul(ce, Lt) | 0, j = j + Math.imul(he, Rt) | 0, ie = ie + Math.imul(he, Lt) | 0;
                var Pe = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, L = Math.imul(M, Ne), j = Math.imul(M, Le), j = j + Math.imul(z, Ne) | 0, ie = Math.imul(z, Le), L = L + Math.imul(De, yt) | 0, j = j + Math.imul(De, _t) | 0, j = j + Math.imul(Re, yt) | 0, ie = ie + Math.imul(Re, _t) | 0, L = L + Math.imul(ae, Rt) | 0, j = j + Math.imul(ae, Lt) | 0, j = j + Math.imul(ye, Rt) | 0, ie = ie + Math.imul(ye, Lt) | 0, L = L + Math.imul(ce, jr) | 0, j = j + Math.imul(ce, Et) | 0, j = j + Math.imul(he, jr) | 0, ie = ie + Math.imul(he, Et) | 0;
                var et = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, L = Math.imul(_e, Ne), j = Math.imul(_e, Le), j = j + Math.imul(Ie, Ne) | 0, ie = Math.imul(Ie, Le), L = L + Math.imul(M, yt) | 0, j = j + Math.imul(M, _t) | 0, j = j + Math.imul(z, yt) | 0, ie = ie + Math.imul(z, _t) | 0, L = L + Math.imul(De, Rt) | 0, j = j + Math.imul(De, Lt) | 0, j = j + Math.imul(Re, Rt) | 0, ie = ie + Math.imul(Re, Lt) | 0, L = L + Math.imul(ae, jr) | 0, j = j + Math.imul(ae, Et) | 0, j = j + Math.imul(ye, jr) | 0, ie = ie + Math.imul(ye, Et) | 0, L = L + Math.imul(ce, wr) | 0, j = j + Math.imul(ce, zt) | 0, j = j + Math.imul(he, wr) | 0, ie = ie + Math.imul(he, zt) | 0;
                var vt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(Ke, Ne), j = Math.imul(Ke, Le), j = j + Math.imul(Ue, Ne) | 0, ie = Math.imul(Ue, Le), L = L + Math.imul(_e, yt) | 0, j = j + Math.imul(_e, _t) | 0, j = j + Math.imul(Ie, yt) | 0, ie = ie + Math.imul(Ie, _t) | 0, L = L + Math.imul(M, Rt) | 0, j = j + Math.imul(M, Lt) | 0, j = j + Math.imul(z, Rt) | 0, ie = ie + Math.imul(z, Lt) | 0, L = L + Math.imul(De, jr) | 0, j = j + Math.imul(De, Et) | 0, j = j + Math.imul(Re, jr) | 0, ie = ie + Math.imul(Re, Et) | 0, L = L + Math.imul(ae, wr) | 0, j = j + Math.imul(ae, zt) | 0, j = j + Math.imul(ye, wr) | 0, ie = ie + Math.imul(ye, zt) | 0, L = L + Math.imul(ce, we) | 0, j = j + Math.imul(ce, xe) | 0, j = j + Math.imul(he, we) | 0, ie = ie + Math.imul(he, xe) | 0;
                var be = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, L = Math.imul(x, Ne), j = Math.imul(x, Le), j = j + Math.imul(q, Ne) | 0, ie = Math.imul(q, Le), L = L + Math.imul(Ke, yt) | 0, j = j + Math.imul(Ke, _t) | 0, j = j + Math.imul(Ue, yt) | 0, ie = ie + Math.imul(Ue, _t) | 0, L = L + Math.imul(_e, Rt) | 0, j = j + Math.imul(_e, Lt) | 0, j = j + Math.imul(Ie, Rt) | 0, ie = ie + Math.imul(Ie, Lt) | 0, L = L + Math.imul(M, jr) | 0, j = j + Math.imul(M, Et) | 0, j = j + Math.imul(z, jr) | 0, ie = ie + Math.imul(z, Et) | 0, L = L + Math.imul(De, wr) | 0, j = j + Math.imul(De, zt) | 0, j = j + Math.imul(Re, wr) | 0, ie = ie + Math.imul(Re, zt) | 0, L = L + Math.imul(ae, we) | 0, j = j + Math.imul(ae, xe) | 0, j = j + Math.imul(ye, we) | 0, ie = ie + Math.imul(ye, xe) | 0, L = L + Math.imul(ce, ze) | 0, j = j + Math.imul(ce, Ve) | 0, j = j + Math.imul(he, ze) | 0, ie = ie + Math.imul(he, Ve) | 0;
                var $r = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, L = Math.imul(fe, Ne), j = Math.imul(fe, Le), j = j + Math.imul(ne, Ne) | 0, ie = Math.imul(ne, Le), L = L + Math.imul(x, yt) | 0, j = j + Math.imul(x, _t) | 0, j = j + Math.imul(q, yt) | 0, ie = ie + Math.imul(q, _t) | 0, L = L + Math.imul(Ke, Rt) | 0, j = j + Math.imul(Ke, Lt) | 0, j = j + Math.imul(Ue, Rt) | 0, ie = ie + Math.imul(Ue, Lt) | 0, L = L + Math.imul(_e, jr) | 0, j = j + Math.imul(_e, Et) | 0, j = j + Math.imul(Ie, jr) | 0, ie = ie + Math.imul(Ie, Et) | 0, L = L + Math.imul(M, wr) | 0, j = j + Math.imul(M, zt) | 0, j = j + Math.imul(z, wr) | 0, ie = ie + Math.imul(z, zt) | 0, L = L + Math.imul(De, we) | 0, j = j + Math.imul(De, xe) | 0, j = j + Math.imul(Re, we) | 0, ie = ie + Math.imul(Re, xe) | 0, L = L + Math.imul(ae, ze) | 0, j = j + Math.imul(ae, Ve) | 0, j = j + Math.imul(ye, ze) | 0, ie = ie + Math.imul(ye, Ve) | 0, L = L + Math.imul(ce, ct) | 0, j = j + Math.imul(ce, lt) | 0, j = j + Math.imul(he, ct) | 0, ie = ie + Math.imul(he, lt) | 0;
                var jt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, L = Math.imul(J, Ne), j = Math.imul(J, Le), j = j + Math.imul(V, Ne) | 0, ie = Math.imul(V, Le), L = L + Math.imul(fe, yt) | 0, j = j + Math.imul(fe, _t) | 0, j = j + Math.imul(ne, yt) | 0, ie = ie + Math.imul(ne, _t) | 0, L = L + Math.imul(x, Rt) | 0, j = j + Math.imul(x, Lt) | 0, j = j + Math.imul(q, Rt) | 0, ie = ie + Math.imul(q, Lt) | 0, L = L + Math.imul(Ke, jr) | 0, j = j + Math.imul(Ke, Et) | 0, j = j + Math.imul(Ue, jr) | 0, ie = ie + Math.imul(Ue, Et) | 0, L = L + Math.imul(_e, wr) | 0, j = j + Math.imul(_e, zt) | 0, j = j + Math.imul(Ie, wr) | 0, ie = ie + Math.imul(Ie, zt) | 0, L = L + Math.imul(M, we) | 0, j = j + Math.imul(M, xe) | 0, j = j + Math.imul(z, we) | 0, ie = ie + Math.imul(z, xe) | 0, L = L + Math.imul(De, ze) | 0, j = j + Math.imul(De, Ve) | 0, j = j + Math.imul(Re, ze) | 0, ie = ie + Math.imul(Re, Ve) | 0, L = L + Math.imul(ae, ct) | 0, j = j + Math.imul(ae, lt) | 0, j = j + Math.imul(ye, ct) | 0, ie = ie + Math.imul(ye, lt) | 0, L = L + Math.imul(ce, wt) | 0, j = j + Math.imul(ce, bt) | 0, j = j + Math.imul(he, wt) | 0, ie = ie + Math.imul(he, bt) | 0;
                var nr = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, L = Math.imul(Z, Ne), j = Math.imul(Z, Le), j = j + Math.imul(le, Ne) | 0, ie = Math.imul(le, Le), L = L + Math.imul(J, yt) | 0, j = j + Math.imul(J, _t) | 0, j = j + Math.imul(V, yt) | 0, ie = ie + Math.imul(V, _t) | 0, L = L + Math.imul(fe, Rt) | 0, j = j + Math.imul(fe, Lt) | 0, j = j + Math.imul(ne, Rt) | 0, ie = ie + Math.imul(ne, Lt) | 0, L = L + Math.imul(x, jr) | 0, j = j + Math.imul(x, Et) | 0, j = j + Math.imul(q, jr) | 0, ie = ie + Math.imul(q, Et) | 0, L = L + Math.imul(Ke, wr) | 0, j = j + Math.imul(Ke, zt) | 0, j = j + Math.imul(Ue, wr) | 0, ie = ie + Math.imul(Ue, zt) | 0, L = L + Math.imul(_e, we) | 0, j = j + Math.imul(_e, xe) | 0, j = j + Math.imul(Ie, we) | 0, ie = ie + Math.imul(Ie, xe) | 0, L = L + Math.imul(M, ze) | 0, j = j + Math.imul(M, Ve) | 0, j = j + Math.imul(z, ze) | 0, ie = ie + Math.imul(z, Ve) | 0, L = L + Math.imul(De, ct) | 0, j = j + Math.imul(De, lt) | 0, j = j + Math.imul(Re, ct) | 0, ie = ie + Math.imul(Re, lt) | 0, L = L + Math.imul(ae, wt) | 0, j = j + Math.imul(ae, bt) | 0, j = j + Math.imul(ye, wt) | 0, ie = ie + Math.imul(ye, bt) | 0, L = L + Math.imul(ce, Ct) | 0, j = j + Math.imul(ce, Xe) | 0, j = j + Math.imul(he, Ct) | 0, ie = ie + Math.imul(he, Xe) | 0;
                var kt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, L = Math.imul(Z, yt), j = Math.imul(Z, _t), j = j + Math.imul(le, yt) | 0, ie = Math.imul(le, _t), L = L + Math.imul(J, Rt) | 0, j = j + Math.imul(J, Lt) | 0, j = j + Math.imul(V, Rt) | 0, ie = ie + Math.imul(V, Lt) | 0, L = L + Math.imul(fe, jr) | 0, j = j + Math.imul(fe, Et) | 0, j = j + Math.imul(ne, jr) | 0, ie = ie + Math.imul(ne, Et) | 0, L = L + Math.imul(x, wr) | 0, j = j + Math.imul(x, zt) | 0, j = j + Math.imul(q, wr) | 0, ie = ie + Math.imul(q, zt) | 0, L = L + Math.imul(Ke, we) | 0, j = j + Math.imul(Ke, xe) | 0, j = j + Math.imul(Ue, we) | 0, ie = ie + Math.imul(Ue, xe) | 0, L = L + Math.imul(_e, ze) | 0, j = j + Math.imul(_e, Ve) | 0, j = j + Math.imul(Ie, ze) | 0, ie = ie + Math.imul(Ie, Ve) | 0, L = L + Math.imul(M, ct) | 0, j = j + Math.imul(M, lt) | 0, j = j + Math.imul(z, ct) | 0, ie = ie + Math.imul(z, lt) | 0, L = L + Math.imul(De, wt) | 0, j = j + Math.imul(De, bt) | 0, j = j + Math.imul(Re, wt) | 0, ie = ie + Math.imul(Re, bt) | 0, L = L + Math.imul(ae, Ct) | 0, j = j + Math.imul(ae, Xe) | 0, j = j + Math.imul(ye, Ct) | 0, ie = ie + Math.imul(ye, Xe) | 0;
                var Hn = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Hn >>> 26) | 0, Hn &= 67108863, L = Math.imul(Z, Rt), j = Math.imul(Z, Lt), j = j + Math.imul(le, Rt) | 0, ie = Math.imul(le, Lt), L = L + Math.imul(J, jr) | 0, j = j + Math.imul(J, Et) | 0, j = j + Math.imul(V, jr) | 0, ie = ie + Math.imul(V, Et) | 0, L = L + Math.imul(fe, wr) | 0, j = j + Math.imul(fe, zt) | 0, j = j + Math.imul(ne, wr) | 0, ie = ie + Math.imul(ne, zt) | 0, L = L + Math.imul(x, we) | 0, j = j + Math.imul(x, xe) | 0, j = j + Math.imul(q, we) | 0, ie = ie + Math.imul(q, xe) | 0, L = L + Math.imul(Ke, ze) | 0, j = j + Math.imul(Ke, Ve) | 0, j = j + Math.imul(Ue, ze) | 0, ie = ie + Math.imul(Ue, Ve) | 0, L = L + Math.imul(_e, ct) | 0, j = j + Math.imul(_e, lt) | 0, j = j + Math.imul(Ie, ct) | 0, ie = ie + Math.imul(Ie, lt) | 0, L = L + Math.imul(M, wt) | 0, j = j + Math.imul(M, bt) | 0, j = j + Math.imul(z, wt) | 0, ie = ie + Math.imul(z, bt) | 0, L = L + Math.imul(De, Ct) | 0, j = j + Math.imul(De, Xe) | 0, j = j + Math.imul(Re, Ct) | 0, ie = ie + Math.imul(Re, Xe) | 0;
                var Zr = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, L = Math.imul(Z, jr), j = Math.imul(Z, Et), j = j + Math.imul(le, jr) | 0, ie = Math.imul(le, Et), L = L + Math.imul(J, wr) | 0, j = j + Math.imul(J, zt) | 0, j = j + Math.imul(V, wr) | 0, ie = ie + Math.imul(V, zt) | 0, L = L + Math.imul(fe, we) | 0, j = j + Math.imul(fe, xe) | 0, j = j + Math.imul(ne, we) | 0, ie = ie + Math.imul(ne, xe) | 0, L = L + Math.imul(x, ze) | 0, j = j + Math.imul(x, Ve) | 0, j = j + Math.imul(q, ze) | 0, ie = ie + Math.imul(q, Ve) | 0, L = L + Math.imul(Ke, ct) | 0, j = j + Math.imul(Ke, lt) | 0, j = j + Math.imul(Ue, ct) | 0, ie = ie + Math.imul(Ue, lt) | 0, L = L + Math.imul(_e, wt) | 0, j = j + Math.imul(_e, bt) | 0, j = j + Math.imul(Ie, wt) | 0, ie = ie + Math.imul(Ie, bt) | 0, L = L + Math.imul(M, Ct) | 0, j = j + Math.imul(M, Xe) | 0, j = j + Math.imul(z, Ct) | 0, ie = ie + Math.imul(z, Xe) | 0;
                var v = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (v >>> 26) | 0, v &= 67108863, L = Math.imul(Z, wr), j = Math.imul(Z, zt), j = j + Math.imul(le, wr) | 0, ie = Math.imul(le, zt), L = L + Math.imul(J, we) | 0, j = j + Math.imul(J, xe) | 0, j = j + Math.imul(V, we) | 0, ie = ie + Math.imul(V, xe) | 0, L = L + Math.imul(fe, ze) | 0, j = j + Math.imul(fe, Ve) | 0, j = j + Math.imul(ne, ze) | 0, ie = ie + Math.imul(ne, Ve) | 0, L = L + Math.imul(x, ct) | 0, j = j + Math.imul(x, lt) | 0, j = j + Math.imul(q, ct) | 0, ie = ie + Math.imul(q, lt) | 0, L = L + Math.imul(Ke, wt) | 0, j = j + Math.imul(Ke, bt) | 0, j = j + Math.imul(Ue, wt) | 0, ie = ie + Math.imul(Ue, bt) | 0, L = L + Math.imul(_e, Ct) | 0, j = j + Math.imul(_e, Xe) | 0, j = j + Math.imul(Ie, Ct) | 0, ie = ie + Math.imul(Ie, Xe) | 0;
                var B = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (B >>> 26) | 0, B &= 67108863, L = Math.imul(Z, we), j = Math.imul(Z, xe), j = j + Math.imul(le, we) | 0, ie = Math.imul(le, xe), L = L + Math.imul(J, ze) | 0, j = j + Math.imul(J, Ve) | 0, j = j + Math.imul(V, ze) | 0, ie = ie + Math.imul(V, Ve) | 0, L = L + Math.imul(fe, ct) | 0, j = j + Math.imul(fe, lt) | 0, j = j + Math.imul(ne, ct) | 0, ie = ie + Math.imul(ne, lt) | 0, L = L + Math.imul(x, wt) | 0, j = j + Math.imul(x, bt) | 0, j = j + Math.imul(q, wt) | 0, ie = ie + Math.imul(q, bt) | 0, L = L + Math.imul(Ke, Ct) | 0, j = j + Math.imul(Ke, Xe) | 0, j = j + Math.imul(Ue, Ct) | 0, ie = ie + Math.imul(Ue, Xe) | 0;
                var Y = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Y >>> 26) | 0, Y &= 67108863, L = Math.imul(Z, ze), j = Math.imul(Z, Ve), j = j + Math.imul(le, ze) | 0, ie = Math.imul(le, Ve), L = L + Math.imul(J, ct) | 0, j = j + Math.imul(J, lt) | 0, j = j + Math.imul(V, ct) | 0, ie = ie + Math.imul(V, lt) | 0, L = L + Math.imul(fe, wt) | 0, j = j + Math.imul(fe, bt) | 0, j = j + Math.imul(ne, wt) | 0, ie = ie + Math.imul(ne, bt) | 0, L = L + Math.imul(x, Ct) | 0, j = j + Math.imul(x, Xe) | 0, j = j + Math.imul(q, Ct) | 0, ie = ie + Math.imul(q, Xe) | 0;
                var pe = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (pe >>> 26) | 0, pe &= 67108863, L = Math.imul(Z, ct), j = Math.imul(Z, lt), j = j + Math.imul(le, ct) | 0, ie = Math.imul(le, lt), L = L + Math.imul(J, wt) | 0, j = j + Math.imul(J, bt) | 0, j = j + Math.imul(V, wt) | 0, ie = ie + Math.imul(V, bt) | 0, L = L + Math.imul(fe, Ct) | 0, j = j + Math.imul(fe, Xe) | 0, j = j + Math.imul(ne, Ct) | 0, ie = ie + Math.imul(ne, Xe) | 0;
                var ke = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, L = Math.imul(Z, wt), j = Math.imul(Z, bt), j = j + Math.imul(le, wt) | 0, ie = Math.imul(le, bt), L = L + Math.imul(J, Ct) | 0, j = j + Math.imul(J, Xe) | 0, j = j + Math.imul(V, Ct) | 0, ie = ie + Math.imul(V, Xe) | 0;
                var qe = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, L = Math.imul(Z, Ct), j = Math.imul(Z, Xe), j = j + Math.imul(le, Ct) | 0, ie = Math.imul(le, Xe);
                var ut = (k + L | 0) + ((j & 8191) << 13) | 0;
                return k = (ie + (j >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, P[0] = xt, P[1] = St, P[2] = Pe, P[3] = et, P[4] = vt, P[5] = be, P[6] = $r, P[7] = jt, P[8] = nr, P[9] = kt, P[10] = Hn, P[11] = Zr, P[12] = v, P[13] = B, P[14] = Y, P[15] = pe, P[16] = ke, P[17] = qe, P[18] = ut, k !== 0 && (P[19] = k, E.length++), E;
            };
            Math.imul || (U = N);
            function D(w, g, m) {
                m.negative = g.negative ^ w.negative, m.length = w.length + g.length;
                for(var E = 0, T = 0, I = 0; I < m.length - 1; I++){
                    var P = T;
                    T = 0;
                    for(var k = E & 67108863, L = Math.min(I, g.length - 1), j = Math.max(0, I - w.length + 1); j <= L; j++){
                        var ie = I - j, ue = w.words[ie] | 0, ce = g.words[j] | 0, he = ue * ce, ee = he & 67108863;
                        P = P + (he / 67108864 | 0) | 0, ee = ee + k | 0, k = ee & 67108863, P = P + (ee >>> 26) | 0, T += P >>> 26, P &= 67108863;
                    }
                    m.words[I] = k, E = P, P = T;
                }
                return E !== 0 ? m.words[I] = E : m.length--, m._strip();
            }
            function H(w, g, m) {
                return D(w, g, m);
            }
            o.prototype.mulTo = function(g, m) {
                var E, T = this.length + g.length;
                return this.length === 10 && g.length === 10 ? E = U(this, g, m) : T < 63 ? E = N(this, g, m) : T < 1024 ? E = D(this, g, m) : E = H(this, g, m), E;
            }, o.prototype.mul = function(g) {
                var m = new o(null);
                return m.words = new Array(this.length + g.length), this.mulTo(g, m);
            }, o.prototype.mulf = function(g) {
                var m = new o(null);
                return m.words = new Array(this.length + g.length), H(this, g, m);
            }, o.prototype.imul = function(g) {
                return this.clone().mulTo(g, this);
            }, o.prototype.imuln = function(g) {
                var m = g < 0;
                m && (g = -g), n(typeof g == "number"), n(g < 67108864);
                for(var E = 0, T = 0; T < this.length; T++){
                    var I = (this.words[T] | 0) * g, P = (I & 67108863) + (E & 67108863);
                    E >>= 26, E += I / 67108864 | 0, E += P >>> 26, this.words[T] = P & 67108863;
                }
                return E !== 0 && (this.words[T] = E, this.length++), this.length = g === 0 ? 1 : this.length, m ? this.ineg() : this;
            }, o.prototype.muln = function(g) {
                return this.clone().imuln(g);
            }, o.prototype.sqr = function() {
                return this.mul(this);
            }, o.prototype.isqr = function() {
                return this.imul(this.clone());
            }, o.prototype.pow = function(g) {
                var m = O(g);
                if (m.length === 0) return new o(1);
                for(var E = this, T = 0; T < m.length && m[T] === 0; T++, E = E.sqr());
                if (++T < m.length) for(var I = E.sqr(); T < m.length; T++, I = I.sqr())m[T] !== 0 && (E = E.mul(I));
                return E;
            }, o.prototype.iushln = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = g % 26, E = (g - m) / 26, T = 67108863 >>> 26 - m << 26 - m, I;
                if (m !== 0) {
                    var P = 0;
                    for(I = 0; I < this.length; I++){
                        var k = this.words[I] & T, L = (this.words[I] | 0) - k << m;
                        this.words[I] = L | P, P = k >>> 26 - m;
                    }
                    P && (this.words[I] = P, this.length++);
                }
                if (E !== 0) {
                    for(I = this.length - 1; I >= 0; I--)this.words[I + E] = this.words[I];
                    for(I = 0; I < E; I++)this.words[I] = 0;
                    this.length += E;
                }
                return this._strip();
            }, o.prototype.ishln = function(g) {
                return n(this.negative === 0), this.iushln(g);
            }, o.prototype.iushrn = function(g, m, E) {
                n(typeof g == "number" && g >= 0);
                var T;
                m ? T = (m - m % 26) / 26 : T = 0;
                var I = g % 26, P = Math.min((g - I) / 26, this.length), k = 67108863 ^ 67108863 >>> I << I, L = E;
                if (T -= P, T = Math.max(0, T), L) {
                    for(var j = 0; j < P; j++)L.words[j] = this.words[j];
                    L.length = P;
                }
                if (P !== 0) if (this.length > P) for(this.length -= P, j = 0; j < this.length; j++)this.words[j] = this.words[j + P];
                else this.words[0] = 0, this.length = 1;
                var ie = 0;
                for(j = this.length - 1; j >= 0 && (ie !== 0 || j >= T); j--){
                    var ue = this.words[j] | 0;
                    this.words[j] = ie << 26 - I | ue >>> I, ie = ue & k;
                }
                return L && ie !== 0 && (L.words[L.length++] = ie), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
            }, o.prototype.ishrn = function(g, m, E) {
                return n(this.negative === 0), this.iushrn(g, m, E);
            }, o.prototype.shln = function(g) {
                return this.clone().ishln(g);
            }, o.prototype.ushln = function(g) {
                return this.clone().iushln(g);
            }, o.prototype.shrn = function(g) {
                return this.clone().ishrn(g);
            }, o.prototype.ushrn = function(g) {
                return this.clone().iushrn(g);
            }, o.prototype.testn = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = g % 26, E = (g - m) / 26, T = 1 << m;
                if (this.length <= E) return !1;
                var I = this.words[E];
                return !!(I & T);
            }, o.prototype.imaskn = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = g % 26, E = (g - m) / 26;
                if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= E) return this;
                if (m !== 0 && E++, this.length = Math.min(E, this.length), m !== 0) {
                    var T = 67108863 ^ 67108863 >>> m << m;
                    this.words[this.length - 1] &= T;
                }
                return this._strip();
            }, o.prototype.maskn = function(g) {
                return this.clone().imaskn(g);
            }, o.prototype.iaddn = function(g) {
                return n(typeof g == "number"), n(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
            }, o.prototype._iaddn = function(g) {
                this.words[0] += g;
                for(var m = 0; m < this.length && this.words[m] >= 67108864; m++)this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
                return this.length = Math.max(this.length, m + 1), this;
            }, o.prototype.isubn = function(g) {
                if (n(typeof g == "number"), n(g < 67108864), g < 0) return this.iaddn(-g);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this;
                if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var m = 0; m < this.length && this.words[m] < 0; m++)this.words[m] += 67108864, this.words[m + 1] -= 1;
                return this._strip();
            }, o.prototype.addn = function(g) {
                return this.clone().iaddn(g);
            }, o.prototype.subn = function(g) {
                return this.clone().isubn(g);
            }, o.prototype.iabs = function() {
                return this.negative = 0, this;
            }, o.prototype.abs = function() {
                return this.clone().iabs();
            }, o.prototype._ishlnsubmul = function(g, m, E) {
                var T = g.length + E, I;
                this._expand(T);
                var P, k = 0;
                for(I = 0; I < g.length; I++){
                    P = (this.words[I + E] | 0) + k;
                    var L = (g.words[I] | 0) * m;
                    P -= L & 67108863, k = (P >> 26) - (L / 67108864 | 0), this.words[I + E] = P & 67108863;
                }
                for(; I < this.length - E; I++)P = (this.words[I + E] | 0) + k, k = P >> 26, this.words[I + E] = P & 67108863;
                if (k === 0) return this._strip();
                for(n(k === -1), k = 0, I = 0; I < this.length; I++)P = -(this.words[I] | 0) + k, k = P >> 26, this.words[I] = P & 67108863;
                return this.negative = 1, this._strip();
            }, o.prototype._wordDiv = function(g, m) {
                var E = this.length - g.length, T = this.clone(), I = g, P = I.words[I.length - 1] | 0, k = this._countBits(P);
                E = 26 - k, E !== 0 && (I = I.ushln(E), T.iushln(E), P = I.words[I.length - 1] | 0);
                var L = T.length - I.length, j;
                if (m !== "mod") {
                    j = new o(null), j.length = L + 1, j.words = new Array(j.length);
                    for(var ie = 0; ie < j.length; ie++)j.words[ie] = 0;
                }
                var ue = T.clone()._ishlnsubmul(I, 1, L);
                ue.negative === 0 && (T = ue, j && (j.words[L] = 1));
                for(var ce = L - 1; ce >= 0; ce--){
                    var he = (T.words[I.length + ce] | 0) * 67108864 + (T.words[I.length + ce - 1] | 0);
                    for(he = Math.min(he / P | 0, 67108863), T._ishlnsubmul(I, he, ce); T.negative !== 0;)he--, T.negative = 0, T._ishlnsubmul(I, 1, ce), T.isZero() || (T.negative ^= 1);
                    j && (j.words[ce] = he);
                }
                return j && j._strip(), T._strip(), m !== "div" && E !== 0 && T.iushrn(E), {
                    div: j || null,
                    mod: T
                };
            }, o.prototype.divmod = function(g, m, E) {
                if (n(!g.isZero()), this.isZero()) return {
                    div: new o(0),
                    mod: new o(0)
                };
                var T, I, P;
                return this.negative !== 0 && g.negative === 0 ? (P = this.neg().divmod(g, m), m !== "mod" && (T = P.div.neg()), m !== "div" && (I = P.mod.neg(), E && I.negative !== 0 && I.iadd(g)), {
                    div: T,
                    mod: I
                }) : this.negative === 0 && g.negative !== 0 ? (P = this.divmod(g.neg(), m), m !== "mod" && (T = P.div.neg()), {
                    div: T,
                    mod: P.mod
                }) : this.negative & g.negative ? (P = this.neg().divmod(g.neg(), m), m !== "div" && (I = P.mod.neg(), E && I.negative !== 0 && I.isub(g)), {
                    div: P.div,
                    mod: I
                }) : g.length > this.length || this.cmp(g) < 0 ? {
                    div: new o(0),
                    mod: this
                } : g.length === 1 ? m === "div" ? {
                    div: this.divn(g.words[0]),
                    mod: null
                } : m === "mod" ? {
                    div: null,
                    mod: new o(this.modrn(g.words[0]))
                } : {
                    div: this.divn(g.words[0]),
                    mod: new o(this.modrn(g.words[0]))
                } : this._wordDiv(g, m);
            }, o.prototype.div = function(g) {
                return this.divmod(g, "div", !1).div;
            }, o.prototype.mod = function(g) {
                return this.divmod(g, "mod", !1).mod;
            }, o.prototype.umod = function(g) {
                return this.divmod(g, "mod", !0).mod;
            }, o.prototype.divRound = function(g) {
                var m = this.divmod(g);
                if (m.mod.isZero()) return m.div;
                var E = m.div.negative !== 0 ? m.mod.isub(g) : m.mod, T = g.ushrn(1), I = g.andln(1), P = E.cmp(T);
                return P < 0 || I === 1 && P === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
            }, o.prototype.modrn = function(g) {
                var m = g < 0;
                m && (g = -g), n(g <= 67108863);
                for(var E = (1 << 26) % g, T = 0, I = this.length - 1; I >= 0; I--)T = (E * T + (this.words[I] | 0)) % g;
                return m ? -T : T;
            }, o.prototype.modn = function(g) {
                return this.modrn(g);
            }, o.prototype.idivn = function(g) {
                var m = g < 0;
                m && (g = -g), n(g <= 67108863);
                for(var E = 0, T = this.length - 1; T >= 0; T--){
                    var I = (this.words[T] | 0) + E * 67108864;
                    this.words[T] = I / g | 0, E = I % g;
                }
                return this._strip(), m ? this.ineg() : this;
            }, o.prototype.divn = function(g) {
                return this.clone().idivn(g);
            }, o.prototype.egcd = function(g) {
                n(g.negative === 0), n(!g.isZero());
                var m = this, E = g.clone();
                m.negative !== 0 ? m = m.umod(g) : m = m.clone();
                for(var T = new o(1), I = new o(0), P = new o(0), k = new o(1), L = 0; m.isEven() && E.isEven();)m.iushrn(1), E.iushrn(1), ++L;
                for(var j = E.clone(), ie = m.clone(); !m.isZero();){
                    for(var ue = 0, ce = 1; !(m.words[0] & ce) && ue < 26; ++ue, ce <<= 1);
                    if (ue > 0) for(m.iushrn(ue); ue-- > 0;)(T.isOdd() || I.isOdd()) && (T.iadd(j), I.isub(ie)), T.iushrn(1), I.iushrn(1);
                    for(var he = 0, ee = 1; !(E.words[0] & ee) && he < 26; ++he, ee <<= 1);
                    if (he > 0) for(E.iushrn(he); he-- > 0;)(P.isOdd() || k.isOdd()) && (P.iadd(j), k.isub(ie)), P.iushrn(1), k.iushrn(1);
                    m.cmp(E) >= 0 ? (m.isub(E), T.isub(P), I.isub(k)) : (E.isub(m), P.isub(T), k.isub(I));
                }
                return {
                    a: P,
                    b: k,
                    gcd: E.iushln(L)
                };
            }, o.prototype._invmp = function(g) {
                n(g.negative === 0), n(!g.isZero());
                var m = this, E = g.clone();
                m.negative !== 0 ? m = m.umod(g) : m = m.clone();
                for(var T = new o(1), I = new o(0), P = E.clone(); m.cmpn(1) > 0 && E.cmpn(1) > 0;){
                    for(var k = 0, L = 1; !(m.words[0] & L) && k < 26; ++k, L <<= 1);
                    if (k > 0) for(m.iushrn(k); k-- > 0;)T.isOdd() && T.iadd(P), T.iushrn(1);
                    for(var j = 0, ie = 1; !(E.words[0] & ie) && j < 26; ++j, ie <<= 1);
                    if (j > 0) for(E.iushrn(j); j-- > 0;)I.isOdd() && I.iadd(P), I.iushrn(1);
                    m.cmp(E) >= 0 ? (m.isub(E), T.isub(I)) : (E.isub(m), I.isub(T));
                }
                var ue;
                return m.cmpn(1) === 0 ? ue = T : ue = I, ue.cmpn(0) < 0 && ue.iadd(g), ue;
            }, o.prototype.gcd = function(g) {
                if (this.isZero()) return g.abs();
                if (g.isZero()) return this.abs();
                var m = this.clone(), E = g.clone();
                m.negative = 0, E.negative = 0;
                for(var T = 0; m.isEven() && E.isEven(); T++)m.iushrn(1), E.iushrn(1);
                do {
                    for(; m.isEven();)m.iushrn(1);
                    for(; E.isEven();)E.iushrn(1);
                    var I = m.cmp(E);
                    if (I < 0) {
                        var P = m;
                        m = E, E = P;
                    } else if (I === 0 || E.cmpn(1) === 0) break;
                    m.isub(E);
                }while (!0)
                return E.iushln(T);
            }, o.prototype.invm = function(g) {
                return this.egcd(g).a.umod(g);
            }, o.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, o.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, o.prototype.andln = function(g) {
                return this.words[0] & g;
            }, o.prototype.bincn = function(g) {
                n(typeof g == "number");
                var m = g % 26, E = (g - m) / 26, T = 1 << m;
                if (this.length <= E) return this._expand(E + 1), this.words[E] |= T, this;
                for(var I = T, P = E; I !== 0 && P < this.length; P++){
                    var k = this.words[P] | 0;
                    k += I, I = k >>> 26, k &= 67108863, this.words[P] = k;
                }
                return I !== 0 && (this.words[P] = I, this.length++), this;
            }, o.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, o.prototype.cmpn = function(g) {
                var m = g < 0;
                if (this.negative !== 0 && !m) return -1;
                if (this.negative === 0 && m) return 1;
                this._strip();
                var E;
                if (this.length > 1) E = 1;
                else {
                    m && (g = -g), n(g <= 67108863, "Number is too big");
                    var T = this.words[0] | 0;
                    E = T === g ? 0 : T < g ? -1 : 1;
                }
                return this.negative !== 0 ? -E | 0 : E;
            }, o.prototype.cmp = function(g) {
                if (this.negative !== 0 && g.negative === 0) return -1;
                if (this.negative === 0 && g.negative !== 0) return 1;
                var m = this.ucmp(g);
                return this.negative !== 0 ? -m | 0 : m;
            }, o.prototype.ucmp = function(g) {
                if (this.length > g.length) return 1;
                if (this.length < g.length) return -1;
                for(var m = 0, E = this.length - 1; E >= 0; E--){
                    var T = this.words[E] | 0, I = g.words[E] | 0;
                    if (T !== I) {
                        T < I ? m = -1 : T > I && (m = 1);
                        break;
                    }
                }
                return m;
            }, o.prototype.gtn = function(g) {
                return this.cmpn(g) === 1;
            }, o.prototype.gt = function(g) {
                return this.cmp(g) === 1;
            }, o.prototype.gten = function(g) {
                return this.cmpn(g) >= 0;
            }, o.prototype.gte = function(g) {
                return this.cmp(g) >= 0;
            }, o.prototype.ltn = function(g) {
                return this.cmpn(g) === -1;
            }, o.prototype.lt = function(g) {
                return this.cmp(g) === -1;
            }, o.prototype.lten = function(g) {
                return this.cmpn(g) <= 0;
            }, o.prototype.lte = function(g) {
                return this.cmp(g) <= 0;
            }, o.prototype.eqn = function(g) {
                return this.cmpn(g) === 0;
            }, o.prototype.eq = function(g) {
                return this.cmp(g) === 0;
            }, o.red = function(g) {
                return new $(g);
            }, o.prototype.toRed = function(g) {
                return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
            }, o.prototype.fromRed = function() {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, o.prototype._forceRed = function(g) {
                return this.red = g, this;
            }, o.prototype.forceRed = function(g) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(g);
            }, o.prototype.redAdd = function(g) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
            }, o.prototype.redIAdd = function(g) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
            }, o.prototype.redSub = function(g) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
            }, o.prototype.redISub = function(g) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
            }, o.prototype.redShl = function(g) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
            }, o.prototype.redMul = function(g) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
            }, o.prototype.redIMul = function(g) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
            }, o.prototype.redSqr = function() {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, o.prototype.redISqr = function() {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, o.prototype.redSqrt = function() {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, o.prototype.redInvm = function() {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, o.prototype.redNeg = function() {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, o.prototype.redPow = function(g) {
                return n(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
            };
            var K = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function re(w, g) {
                this.name = w, this.p = new o(g, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            re.prototype._tmp = function() {
                var g = new o(null);
                return g.words = new Array(Math.ceil(this.n / 13)), g;
            }, re.prototype.ireduce = function(g) {
                var m = g, E;
                do this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), E = m.bitLength();
                while (E > this.n)
                var T = E < this.n ? -1 : m.ucmp(this.p);
                return T === 0 ? (m.words[0] = 0, m.length = 1) : T > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
            }, re.prototype.split = function(g, m) {
                g.iushrn(this.n, 0, m);
            }, re.prototype.imulK = function(g) {
                return g.imul(this.k);
            };
            function Q() {
                re.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            i(Q, re), Q.prototype.split = function(g, m) {
                for(var E = 4194303, T = Math.min(g.length, 9), I = 0; I < T; I++)m.words[I] = g.words[I];
                if (m.length = T, g.length <= 9) {
                    g.words[0] = 0, g.length = 1;
                    return;
                }
                var P = g.words[9];
                for(m.words[m.length++] = P & E, I = 10; I < g.length; I++){
                    var k = g.words[I] | 0;
                    g.words[I - 10] = (k & E) << 4 | P >>> 22, P = k;
                }
                P >>>= 22, g.words[I - 10] = P, P === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
            }, Q.prototype.imulK = function(g) {
                g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
                for(var m = 0, E = 0; E < g.length; E++){
                    var T = g.words[E] | 0;
                    m += T * 977, g.words[E] = m & 67108863, m = T * 64 + (m / 67108864 | 0);
                }
                return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
            };
            function G() {
                re.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            i(G, re);
            function R() {
                re.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            i(R, re);
            function X() {
                re.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            i(X, re), X.prototype.imulK = function(g) {
                for(var m = 0, E = 0; E < g.length; E++){
                    var T = (g.words[E] | 0) * 19 + m, I = T & 67108863;
                    T >>>= 26, g.words[E] = I, m = T;
                }
                return m !== 0 && (g.words[g.length++] = m), g;
            }, o._prime = function(g) {
                if (K[g]) return K[g];
                var m;
                if (g === "k256") m = new Q();
                else if (g === "p224") m = new G();
                else if (g === "p192") m = new R();
                else if (g === "p25519") m = new X();
                else throw new Error("Unknown prime " + g);
                return K[g] = m, m;
            };
            function $(w) {
                if (typeof w == "string") {
                    var g = o._prime(w);
                    this.m = g.p, this.prime = g;
                } else n(w.gtn(1), "modulus must be greater than 1"), this.m = w, this.prime = null;
            }
            $.prototype._verify1 = function(g) {
                n(g.negative === 0, "red works only with positives"), n(g.red, "red works only with red numbers");
            }, $.prototype._verify2 = function(g, m) {
                n((g.negative | m.negative) === 0, "red works only with positives"), n(g.red && g.red === m.red, "red works only with red numbers");
            }, $.prototype.imod = function(g) {
                return this.prime ? this.prime.ireduce(g)._forceRed(this) : (c(g, g.umod(this.m)._forceRed(this)), g);
            }, $.prototype.neg = function(g) {
                return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
            }, $.prototype.add = function(g, m) {
                this._verify2(g, m);
                var E = g.add(m);
                return E.cmp(this.m) >= 0 && E.isub(this.m), E._forceRed(this);
            }, $.prototype.iadd = function(g, m) {
                this._verify2(g, m);
                var E = g.iadd(m);
                return E.cmp(this.m) >= 0 && E.isub(this.m), E;
            }, $.prototype.sub = function(g, m) {
                this._verify2(g, m);
                var E = g.sub(m);
                return E.cmpn(0) < 0 && E.iadd(this.m), E._forceRed(this);
            }, $.prototype.isub = function(g, m) {
                this._verify2(g, m);
                var E = g.isub(m);
                return E.cmpn(0) < 0 && E.iadd(this.m), E;
            }, $.prototype.shl = function(g, m) {
                return this._verify1(g), this.imod(g.ushln(m));
            }, $.prototype.imul = function(g, m) {
                return this._verify2(g, m), this.imod(g.imul(m));
            }, $.prototype.mul = function(g, m) {
                return this._verify2(g, m), this.imod(g.mul(m));
            }, $.prototype.isqr = function(g) {
                return this.imul(g, g.clone());
            }, $.prototype.sqr = function(g) {
                return this.mul(g, g);
            }, $.prototype.sqrt = function(g) {
                if (g.isZero()) return g.clone();
                var m = this.m.andln(3);
                if (n(m % 2 === 1), m === 3) {
                    var E = this.m.add(new o(1)).iushrn(2);
                    return this.pow(g, E);
                }
                for(var T = this.m.subn(1), I = 0; !T.isZero() && T.andln(1) === 0;)I++, T.iushrn(1);
                n(!T.isZero());
                var P = new o(1).toRed(this), k = P.redNeg(), L = this.m.subn(1).iushrn(1), j = this.m.bitLength();
                for(j = new o(2 * j * j).toRed(this); this.pow(j, L).cmp(k) !== 0;)j.redIAdd(k);
                for(var ie = this.pow(j, T), ue = this.pow(g, T.addn(1).iushrn(1)), ce = this.pow(g, T), he = I; ce.cmp(P) !== 0;){
                    for(var ee = ce, ae = 0; ee.cmp(P) !== 0; ae++)ee = ee.redSqr();
                    n(ae < he);
                    var ye = this.pow(ie, new o(1).iushln(he - ae - 1));
                    ue = ue.redMul(ye), ie = ye.redSqr(), ce = ce.redMul(ie), he = ae;
                }
                return ue;
            }, $.prototype.invm = function(g) {
                var m = g._invmp(this.m);
                return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
            }, $.prototype.pow = function(g, m) {
                if (m.isZero()) return new o(1).toRed(this);
                if (m.cmpn(1) === 0) return g.clone();
                var E = 4, T = new Array(1 << E);
                T[0] = new o(1).toRed(this), T[1] = g;
                for(var I = 2; I < T.length; I++)T[I] = this.mul(T[I - 1], g);
                var P = T[0], k = 0, L = 0, j = m.bitLength() % 26;
                for(j === 0 && (j = 26), I = m.length - 1; I >= 0; I--){
                    for(var ie = m.words[I], ue = j - 1; ue >= 0; ue--){
                        var ce = ie >> ue & 1;
                        if (P !== T[0] && (P = this.sqr(P)), ce === 0 && k === 0) {
                            L = 0;
                            continue;
                        }
                        k <<= 1, k |= ce, L++, !(L !== E && (I !== 0 || ue !== 0)) && (P = this.mul(P, T[k]), L = 0, k = 0);
                    }
                    j = 26;
                }
                return P;
            }, $.prototype.convertTo = function(g) {
                var m = g.umod(this.m);
                return m === g ? m.clone() : m;
            }, $.prototype.convertFrom = function(g) {
                var m = g.clone();
                return m.red = null, m;
            }, o.mont = function(g) {
                return new S(g);
            };
            function S(w) {
                $.call(this, w), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            i(S, $), S.prototype.convertTo = function(g) {
                return this.imod(g.ushln(this.shift));
            }, S.prototype.convertFrom = function(g) {
                var m = this.imod(g.mul(this.rinv));
                return m.red = null, m;
            }, S.prototype.imul = function(g, m) {
                if (g.isZero() || m.isZero()) return g.words[0] = 0, g.length = 1, g;
                var E = g.imul(m), T = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = E.isub(T).iushrn(this.shift), P = I;
                return I.cmp(this.m) >= 0 ? P = I.isub(this.m) : I.cmpn(0) < 0 && (P = I.iadd(this.m)), P._forceRed(this);
            }, S.prototype.mul = function(g, m) {
                if (g.isZero() || m.isZero()) return new o(0)._forceRed(this);
                var E = g.mul(m), T = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = E.isub(T).iushrn(this.shift), P = I;
                return I.cmp(this.m) >= 0 ? P = I.isub(this.m) : I.cmpn(0) < 0 && (P = I.iadd(this.m)), P._forceRed(this);
            }, S.prototype.invm = function(g) {
                var m = this.imod(g._invmp(this.m).mul(this.r2));
                return m._forceRed(this);
            };
        })(e, Ge);
    }(Iy)), Iy.exports;
}
var u2, q5;
function F3() {
    if (q5) return u2;
    q5 = 1;
    var e = D3(), t = kd(), r = Ar().Buffer;
    function n(s) {
        var a = s.modulus.byteLength(), u;
        do u = new e(t(a));
        while (u.cmp(s.modulus) >= 0 || !u.umod(s.prime1) || !u.umod(s.prime2))
        return u;
    }
    function i(s) {
        var a = n(s), u = a.toRed(e.mont(s.modulus)).redPow(new e(s.publicExponent)).fromRed();
        return {
            blinder: u,
            unblinder: a.invm(s.modulus)
        };
    }
    function o(s, a) {
        var u = i(a), f = a.modulus.byteLength(), c = new e(s).mul(u.blinder).umod(a.modulus), l = c.toRed(e.mont(a.prime1)), p = c.toRed(e.mont(a.prime2)), y = a.coefficient, _ = a.prime1, A = a.prime2, O = l.redPow(a.exponent1).fromRed(), N = p.redPow(a.exponent2).fromRed(), U = O.isub(N).imul(y).umod(_).imul(A);
        return N.iadd(U).imul(u.unblinder).umod(a.modulus).toArrayLike(r, "be", f);
    }
    return o.getr = n, u2 = o, u2;
}
var f2 = {};
const hX = "6.6.1", pX = {
    version: hX
};
var l2 = {}, d2 = {}, K5;
function IO() {
    return K5 || (K5 = 1, function(e) {
        var t = e;
        function r(o, s) {
            if (Array.isArray(o)) return o.slice();
            if (!o) return [];
            var a = [];
            if (typeof o != "string") {
                for(var u = 0; u < o.length; u++)a[u] = o[u] | 0;
                return a;
            }
            if (s === "hex") {
                o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
                for(var u = 0; u < o.length; u += 2)a.push(parseInt(o[u] + o[u + 1], 16));
            } else for(var u = 0; u < o.length; u++){
                var f = o.charCodeAt(u), c = f >> 8, l = f & 255;
                c ? a.push(c, l) : a.push(l);
            }
            return a;
        }
        t.toArray = r;
        function n(o) {
            return o.length === 1 ? "0" + o : o;
        }
        t.zero2 = n;
        function i(o) {
            for(var s = "", a = 0; a < o.length; a++)s += n(o[a].toString(16));
            return s;
        }
        t.toHex = i, t.encode = function(s, a) {
            return a === "hex" ? i(s) : s;
        };
    }(d2)), d2;
}
var W5;
function ms() {
    return W5 || (W5 = 1, function(e) {
        var t = e, r = bi(), n = ys(), i = IO();
        t.assert = n, t.toArray = i.toArray, t.zero2 = i.zero2, t.toHex = i.toHex, t.encode = i.encode;
        function o(c, l, p) {
            var y = new Array(Math.max(c.bitLength(), p) + 1), _;
            for(_ = 0; _ < y.length; _ += 1)y[_] = 0;
            var A = 1 << l + 1, O = c.clone();
            for(_ = 0; _ < y.length; _++){
                var N, U = O.andln(A - 1);
                O.isOdd() ? (U > (A >> 1) - 1 ? N = (A >> 1) - U : N = U, O.isubn(N)) : N = 0, y[_] = N, O.iushrn(1);
            }
            return y;
        }
        t.getNAF = o;
        function s(c, l) {
            var p = [
                [],
                []
            ];
            c = c.clone(), l = l.clone();
            for(var y = 0, _ = 0, A; c.cmpn(-y) > 0 || l.cmpn(-_) > 0;){
                var O = c.andln(3) + y & 3, N = l.andln(3) + _ & 3;
                O === 3 && (O = -1), N === 3 && (N = -1);
                var U;
                O & 1 ? (A = c.andln(7) + y & 7, (A === 3 || A === 5) && N === 2 ? U = -O : U = O) : U = 0, p[0].push(U);
                var D;
                N & 1 ? (A = l.andln(7) + _ & 7, (A === 3 || A === 5) && O === 2 ? D = -N : D = N) : D = 0, p[1].push(D), 2 * y === U + 1 && (y = 1 - y), 2 * _ === D + 1 && (_ = 1 - _), c.iushrn(1), l.iushrn(1);
            }
            return p;
        }
        t.getJSF = s;
        function a(c, l, p) {
            var y = "_" + l;
            c.prototype[l] = function() {
                return this[y] !== void 0 ? this[y] : this[y] = p.call(this);
            };
        }
        t.cachedProperty = a;
        function u(c) {
            return typeof c == "string" ? t.toArray(c, "hex") : c;
        }
        t.parseBytes = u;
        function f(c) {
            return new r(c, "hex", "le");
        }
        t.intFromLE = f;
    }(l2)), l2;
}
var h2 = {}, p2, V5;
function Tb() {
    if (V5) return p2;
    V5 = 1;
    var e = bi(), t = ms(), r = t.getNAF, n = t.getJSF, i = t.assert;
    function o(a, u) {
        this.type = a, this.p = new e(u.p, 16), this.red = u.prime ? e.red(u.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = u.n && new e(u.n, 16), this.g = u.g && this.pointFromJSON(u.g, u.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var f = this.n && this.p.div(this.n);
        !f || f.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
    }
    p2 = o, o.prototype.point = function() {
        throw new Error("Not implemented");
    }, o.prototype.validate = function() {
        throw new Error("Not implemented");
    }, o.prototype._fixedNafMul = function(u, f) {
        i(u.precomputed);
        var c = u._getDoubles(), l = r(f, 1, this._bitLength), p = (1 << c.step + 1) - (c.step % 2 === 0 ? 2 : 1);
        p /= 3;
        var y = [], _, A;
        for(_ = 0; _ < l.length; _ += c.step){
            A = 0;
            for(var O = _ + c.step - 1; O >= _; O--)A = (A << 1) + l[O];
            y.push(A);
        }
        for(var N = this.jpoint(null, null, null), U = this.jpoint(null, null, null), D = p; D > 0; D--){
            for(_ = 0; _ < y.length; _++)A = y[_], A === D ? U = U.mixedAdd(c.points[_]) : A === -D && (U = U.mixedAdd(c.points[_].neg()));
            N = N.add(U);
        }
        return N.toP();
    }, o.prototype._wnafMul = function(u, f) {
        var c = 4, l = u._getNAFPoints(c);
        c = l.wnd;
        for(var p = l.points, y = r(f, c, this._bitLength), _ = this.jpoint(null, null, null), A = y.length - 1; A >= 0; A--){
            for(var O = 0; A >= 0 && y[A] === 0; A--)O++;
            if (A >= 0 && O++, _ = _.dblp(O), A < 0) break;
            var N = y[A];
            i(N !== 0), u.type === "affine" ? N > 0 ? _ = _.mixedAdd(p[N - 1 >> 1]) : _ = _.mixedAdd(p[-N - 1 >> 1].neg()) : N > 0 ? _ = _.add(p[N - 1 >> 1]) : _ = _.add(p[-N - 1 >> 1].neg());
        }
        return u.type === "affine" ? _.toP() : _;
    }, o.prototype._wnafMulAdd = function(u, f, c, l, p) {
        var y = this._wnafT1, _ = this._wnafT2, A = this._wnafT3, O = 0, N, U, D;
        for(N = 0; N < l; N++){
            D = f[N];
            var H = D._getNAFPoints(u);
            y[N] = H.wnd, _[N] = H.points;
        }
        for(N = l - 1; N >= 1; N -= 2){
            var K = N - 1, re = N;
            if (y[K] !== 1 || y[re] !== 1) {
                A[K] = r(c[K], y[K], this._bitLength), A[re] = r(c[re], y[re], this._bitLength), O = Math.max(A[K].length, O), O = Math.max(A[re].length, O);
                continue;
            }
            var Q = [
                f[K],
                /* 1 */ null,
                /* 3 */ null,
                /* 5 */ f[re]
            ];
            f[K].y.cmp(f[re].y) === 0 ? (Q[1] = f[K].add(f[re]), Q[2] = f[K].toJ().mixedAdd(f[re].neg())) : f[K].y.cmp(f[re].y.redNeg()) === 0 ? (Q[1] = f[K].toJ().mixedAdd(f[re]), Q[2] = f[K].add(f[re].neg())) : (Q[1] = f[K].toJ().mixedAdd(f[re]), Q[2] = f[K].toJ().mixedAdd(f[re].neg()));
            var G = [
                -3,
                /* -1 -1 */ -1,
                /* -1 0 */ -5,
                /* -1 1 */ -7,
                /* 0 -1 */ 0,
                /* 0 0 */ 7,
                /* 0 1 */ 5,
                /* 1 -1 */ 1,
                /* 1 0 */ 3
            ], R = n(c[K], c[re]);
            for(O = Math.max(R[0].length, O), A[K] = new Array(O), A[re] = new Array(O), U = 0; U < O; U++){
                var X = R[0][U] | 0, $ = R[1][U] | 0;
                A[K][U] = G[(X + 1) * 3 + ($ + 1)], A[re][U] = 0, _[K] = Q;
            }
        }
        var S = this.jpoint(null, null, null), w = this._wnafT4;
        for(N = O; N >= 0; N--){
            for(var g = 0; N >= 0;){
                var m = !0;
                for(U = 0; U < l; U++)w[U] = A[U][N] | 0, w[U] !== 0 && (m = !1);
                if (!m) break;
                g++, N--;
            }
            if (N >= 0 && g++, S = S.dblp(g), N < 0) break;
            for(U = 0; U < l; U++){
                var E = w[U];
                E !== 0 && (E > 0 ? D = _[U][E - 1 >> 1] : E < 0 && (D = _[U][-E - 1 >> 1].neg()), D.type === "affine" ? S = S.mixedAdd(D) : S = S.add(D));
            }
        }
        for(N = 0; N < l; N++)_[N] = null;
        return p ? S : S.toP();
    };
    function s(a, u) {
        this.curve = a, this.type = u, this.precomputed = null;
    }
    return o.BasePoint = s, s.prototype.eq = function() {
        throw new Error("Not implemented");
    }, s.prototype.validate = function() {
        return this.curve.validate(this);
    }, o.prototype.decodePoint = function(u, f) {
        u = t.toArray(u, f);
        var c = this.p.byteLength();
        if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 === 2 * c) {
            u[0] === 6 ? i(u[u.length - 1] % 2 === 0) : u[0] === 7 && i(u[u.length - 1] % 2 === 1);
            var l = this.point(u.slice(1, 1 + c), u.slice(1 + c, 1 + 2 * c));
            return l;
        } else if ((u[0] === 2 || u[0] === 3) && u.length - 1 === c) return this.pointFromX(u.slice(1, 1 + c), u[0] === 3);
        throw new Error("Unknown point format");
    }, s.prototype.encodeCompressed = function(u) {
        return this.encode(u, !0);
    }, s.prototype._encode = function(u) {
        var f = this.curve.p.byteLength(), c = this.getX().toArray("be", f);
        return u ? [
            this.getY().isEven() ? 2 : 3
        ].concat(c) : [
            4
        ].concat(c, this.getY().toArray("be", f));
    }, s.prototype.encode = function(u, f) {
        return t.encode(this._encode(f), u);
    }, s.prototype.precompute = function(u) {
        if (this.precomputed) return this;
        var f = {
            doubles: null,
            naf: null,
            beta: null
        };
        return f.naf = this._getNAFPoints(8), f.doubles = this._getDoubles(4, u), f.beta = this._getBeta(), this.precomputed = f, this;
    }, s.prototype._hasDoubles = function(u) {
        if (!this.precomputed) return !1;
        var f = this.precomputed.doubles;
        return f ? f.points.length >= Math.ceil((u.bitLength() + 1) / f.step) : !1;
    }, s.prototype._getDoubles = function(u, f) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        for(var c = [
            this
        ], l = this, p = 0; p < f; p += u){
            for(var y = 0; y < u; y++)l = l.dbl();
            c.push(l);
        }
        return {
            step: u,
            points: c
        };
    }, s.prototype._getNAFPoints = function(u) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        for(var f = [
            this
        ], c = (1 << u) - 1, l = c === 1 ? null : this.dbl(), p = 1; p < c; p++)f[p] = f[p - 1].add(l);
        return {
            wnd: u,
            points: f
        };
    }, s.prototype._getBeta = function() {
        return null;
    }, s.prototype.dblp = function(u) {
        for(var f = this, c = 0; c < u; c++)f = f.dbl();
        return f;
    }, p2;
}
var g2, G5;
function gX() {
    if (G5) return g2;
    G5 = 1;
    var e = ms(), t = bi(), r = Or(), n = Tb(), i = e.assert;
    function o(u) {
        n.call(this, "short", u), this.a = new t(u.a, 16).toRed(this.red), this.b = new t(u.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(u), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    r(o, n), g2 = o, o.prototype._getEndomorphism = function(f) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var c, l;
            if (f.beta) c = new t(f.beta, 16).toRed(this.red);
            else {
                var p = this._getEndoRoots(this.p);
                c = p[0].cmp(p[1]) < 0 ? p[0] : p[1], c = c.toRed(this.red);
            }
            if (f.lambda) l = new t(f.lambda, 16);
            else {
                var y = this._getEndoRoots(this.n);
                this.g.mul(y[0]).x.cmp(this.g.x.redMul(c)) === 0 ? l = y[0] : (l = y[1], i(this.g.mul(l).x.cmp(this.g.x.redMul(c)) === 0));
            }
            var _;
            return f.basis ? _ = f.basis.map(function(A) {
                return {
                    a: new t(A.a, 16),
                    b: new t(A.b, 16)
                };
            }) : _ = this._getEndoBasis(l), {
                beta: c,
                lambda: l,
                basis: _
            };
        }
    }, o.prototype._getEndoRoots = function(f) {
        var c = f === this.p ? this.red : t.mont(f), l = new t(2).toRed(c).redInvm(), p = l.redNeg(), y = new t(3).toRed(c).redNeg().redSqrt().redMul(l), _ = p.redAdd(y).fromRed(), A = p.redSub(y).fromRed();
        return [
            _,
            A
        ];
    }, o.prototype._getEndoBasis = function(f) {
        for(var c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), l = f, p = this.n.clone(), y = new t(1), _ = new t(0), A = new t(0), O = new t(1), N, U, D, H, K, re, Q, G = 0, R, X; l.cmpn(0) !== 0;){
            var $ = p.div(l);
            R = p.sub($.mul(l)), X = A.sub($.mul(y));
            var S = O.sub($.mul(_));
            if (!D && R.cmp(c) < 0) N = Q.neg(), U = y, D = R.neg(), H = X;
            else if (D && ++G === 2) break;
            Q = R, p = l, l = R, A = y, y = X, O = _, _ = S;
        }
        K = R.neg(), re = X;
        var w = D.sqr().add(H.sqr()), g = K.sqr().add(re.sqr());
        return g.cmp(w) >= 0 && (K = N, re = U), D.negative && (D = D.neg(), H = H.neg()), K.negative && (K = K.neg(), re = re.neg()), [
            {
                a: D,
                b: H
            },
            {
                a: K,
                b: re
            }
        ];
    }, o.prototype._endoSplit = function(f) {
        var c = this.endo.basis, l = c[0], p = c[1], y = p.b.mul(f).divRound(this.n), _ = l.b.neg().mul(f).divRound(this.n), A = y.mul(l.a), O = _.mul(p.a), N = y.mul(l.b), U = _.mul(p.b), D = f.sub(A).sub(O), H = N.add(U).neg();
        return {
            k1: D,
            k2: H
        };
    }, o.prototype.pointFromX = function(f, c) {
        f = new t(f, 16), f.red || (f = f.toRed(this.red));
        var l = f.redSqr().redMul(f).redIAdd(f.redMul(this.a)).redIAdd(this.b), p = l.redSqrt();
        if (p.redSqr().redSub(l).cmp(this.zero) !== 0) throw new Error("invalid point");
        var y = p.fromRed().isOdd();
        return (c && !y || !c && y) && (p = p.redNeg()), this.point(f, p);
    }, o.prototype.validate = function(f) {
        if (f.inf) return !0;
        var c = f.x, l = f.y, p = this.a.redMul(c), y = c.redSqr().redMul(c).redIAdd(p).redIAdd(this.b);
        return l.redSqr().redISub(y).cmpn(0) === 0;
    }, o.prototype._endoWnafMulAdd = function(f, c, l) {
        for(var p = this._endoWnafT1, y = this._endoWnafT2, _ = 0; _ < f.length; _++){
            var A = this._endoSplit(c[_]), O = f[_], N = O._getBeta();
            A.k1.negative && (A.k1.ineg(), O = O.neg(!0)), A.k2.negative && (A.k2.ineg(), N = N.neg(!0)), p[_ * 2] = O, p[_ * 2 + 1] = N, y[_ * 2] = A.k1, y[_ * 2 + 1] = A.k2;
        }
        for(var U = this._wnafMulAdd(1, p, y, _ * 2, l), D = 0; D < _ * 2; D++)p[D] = null, y[D] = null;
        return U;
    };
    function s(u, f, c, l) {
        n.BasePoint.call(this, u, "affine"), f === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(f, 16), this.y = new t(c, 16), l && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
    }
    r(s, n.BasePoint), o.prototype.point = function(f, c, l) {
        return new s(this, f, c, l);
    }, o.prototype.pointFromJSON = function(f, c) {
        return s.fromJSON(this, f, c);
    }, s.prototype._getBeta = function() {
        if (this.curve.endo) {
            var f = this.precomputed;
            if (f && f.beta) return f.beta;
            var c = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (f) {
                var l = this.curve, p = function(y) {
                    return l.point(y.x.redMul(l.endo.beta), y.y);
                };
                f.beta = c, c.precomputed = {
                    beta: null,
                    naf: f.naf && {
                        wnd: f.naf.wnd,
                        points: f.naf.points.map(p)
                    },
                    doubles: f.doubles && {
                        step: f.doubles.step,
                        points: f.doubles.points.map(p)
                    }
                };
            }
            return c;
        }
    }, s.prototype.toJSON = function() {
        return this.precomputed ? [
            this.x,
            this.y,
            this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }
        ] : [
            this.x,
            this.y
        ];
    }, s.fromJSON = function(f, c, l) {
        typeof c == "string" && (c = JSON.parse(c));
        var p = f.point(c[0], c[1], l);
        if (!c[2]) return p;
        function y(A) {
            return f.point(A[0], A[1], l);
        }
        var _ = c[2];
        return p.precomputed = {
            beta: null,
            doubles: _.doubles && {
                step: _.doubles.step,
                points: [
                    p
                ].concat(_.doubles.points.map(y))
            },
            naf: _.naf && {
                wnd: _.naf.wnd,
                points: [
                    p
                ].concat(_.naf.points.map(y))
            }
        }, p;
    }, s.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, s.prototype.isInfinity = function() {
        return this.inf;
    }, s.prototype.add = function(f) {
        if (this.inf) return f;
        if (f.inf) return this;
        if (this.eq(f)) return this.dbl();
        if (this.neg().eq(f)) return this.curve.point(null, null);
        if (this.x.cmp(f.x) === 0) return this.curve.point(null, null);
        var c = this.y.redSub(f.y);
        c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(f.x).redInvm()));
        var l = c.redSqr().redISub(this.x).redISub(f.x), p = c.redMul(this.x.redSub(l)).redISub(this.y);
        return this.curve.point(l, p);
    }, s.prototype.dbl = function() {
        if (this.inf) return this;
        var f = this.y.redAdd(this.y);
        if (f.cmpn(0) === 0) return this.curve.point(null, null);
        var c = this.curve.a, l = this.x.redSqr(), p = f.redInvm(), y = l.redAdd(l).redIAdd(l).redIAdd(c).redMul(p), _ = y.redSqr().redISub(this.x.redAdd(this.x)), A = y.redMul(this.x.redSub(_)).redISub(this.y);
        return this.curve.point(_, A);
    }, s.prototype.getX = function() {
        return this.x.fromRed();
    }, s.prototype.getY = function() {
        return this.y.fromRed();
    }, s.prototype.mul = function(f) {
        return f = new t(f, 16), this.isInfinity() ? this : this._hasDoubles(f) ? this.curve._fixedNafMul(this, f) : this.curve.endo ? this.curve._endoWnafMulAdd([
            this
        ], [
            f
        ]) : this.curve._wnafMul(this, f);
    }, s.prototype.mulAdd = function(f, c, l) {
        var p = [
            this,
            c
        ], y = [
            f,
            l
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(p, y) : this.curve._wnafMulAdd(1, p, y, 2);
    }, s.prototype.jmulAdd = function(f, c, l) {
        var p = [
            this,
            c
        ], y = [
            f,
            l
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(p, y, !0) : this.curve._wnafMulAdd(1, p, y, 2, !0);
    }, s.prototype.eq = function(f) {
        return this === f || this.inf === f.inf && (this.inf || this.x.cmp(f.x) === 0 && this.y.cmp(f.y) === 0);
    }, s.prototype.neg = function(f) {
        if (this.inf) return this;
        var c = this.curve.point(this.x, this.y.redNeg());
        if (f && this.precomputed) {
            var l = this.precomputed, p = function(y) {
                return y.neg();
            };
            c.precomputed = {
                naf: l.naf && {
                    wnd: l.naf.wnd,
                    points: l.naf.points.map(p)
                },
                doubles: l.doubles && {
                    step: l.doubles.step,
                    points: l.doubles.points.map(p)
                }
            };
        }
        return c;
    }, s.prototype.toJ = function() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var f = this.curve.jpoint(this.x, this.y, this.curve.one);
        return f;
    };
    function a(u, f, c, l) {
        n.BasePoint.call(this, u, "jacobian"), f === null && c === null && l === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(f, 16), this.y = new t(c, 16), this.z = new t(l, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    return r(a, n.BasePoint), o.prototype.jpoint = function(f, c, l) {
        return new a(this, f, c, l);
    }, a.prototype.toP = function() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var f = this.z.redInvm(), c = f.redSqr(), l = this.x.redMul(c), p = this.y.redMul(c).redMul(f);
        return this.curve.point(l, p);
    }, a.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, a.prototype.add = function(f) {
        if (this.isInfinity()) return f;
        if (f.isInfinity()) return this;
        var c = f.z.redSqr(), l = this.z.redSqr(), p = this.x.redMul(c), y = f.x.redMul(l), _ = this.y.redMul(c.redMul(f.z)), A = f.y.redMul(l.redMul(this.z)), O = p.redSub(y), N = _.redSub(A);
        if (O.cmpn(0) === 0) return N.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var U = O.redSqr(), D = U.redMul(O), H = p.redMul(U), K = N.redSqr().redIAdd(D).redISub(H).redISub(H), re = N.redMul(H.redISub(K)).redISub(_.redMul(D)), Q = this.z.redMul(f.z).redMul(O);
        return this.curve.jpoint(K, re, Q);
    }, a.prototype.mixedAdd = function(f) {
        if (this.isInfinity()) return f.toJ();
        if (f.isInfinity()) return this;
        var c = this.z.redSqr(), l = this.x, p = f.x.redMul(c), y = this.y, _ = f.y.redMul(c).redMul(this.z), A = l.redSub(p), O = y.redSub(_);
        if (A.cmpn(0) === 0) return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var N = A.redSqr(), U = N.redMul(A), D = l.redMul(N), H = O.redSqr().redIAdd(U).redISub(D).redISub(D), K = O.redMul(D.redISub(H)).redISub(y.redMul(U)), re = this.z.redMul(A);
        return this.curve.jpoint(H, K, re);
    }, a.prototype.dblp = function(f) {
        if (f === 0) return this;
        if (this.isInfinity()) return this;
        if (!f) return this.dbl();
        var c;
        if (this.curve.zeroA || this.curve.threeA) {
            var l = this;
            for(c = 0; c < f; c++)l = l.dbl();
            return l;
        }
        var p = this.curve.a, y = this.curve.tinv, _ = this.x, A = this.y, O = this.z, N = O.redSqr().redSqr(), U = A.redAdd(A);
        for(c = 0; c < f; c++){
            var D = _.redSqr(), H = U.redSqr(), K = H.redSqr(), re = D.redAdd(D).redIAdd(D).redIAdd(p.redMul(N)), Q = _.redMul(H), G = re.redSqr().redISub(Q.redAdd(Q)), R = Q.redISub(G), X = re.redMul(R);
            X = X.redIAdd(X).redISub(K);
            var $ = U.redMul(O);
            c + 1 < f && (N = N.redMul(K)), _ = G, O = $, U = X;
        }
        return this.curve.jpoint(_, U.redMul(y), O);
    }, a.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, a.prototype._zeroDbl = function() {
        var f, c, l;
        if (this.zOne) {
            var p = this.x.redSqr(), y = this.y.redSqr(), _ = y.redSqr(), A = this.x.redAdd(y).redSqr().redISub(p).redISub(_);
            A = A.redIAdd(A);
            var O = p.redAdd(p).redIAdd(p), N = O.redSqr().redISub(A).redISub(A), U = _.redIAdd(_);
            U = U.redIAdd(U), U = U.redIAdd(U), f = N, c = O.redMul(A.redISub(N)).redISub(U), l = this.y.redAdd(this.y);
        } else {
            var D = this.x.redSqr(), H = this.y.redSqr(), K = H.redSqr(), re = this.x.redAdd(H).redSqr().redISub(D).redISub(K);
            re = re.redIAdd(re);
            var Q = D.redAdd(D).redIAdd(D), G = Q.redSqr(), R = K.redIAdd(K);
            R = R.redIAdd(R), R = R.redIAdd(R), f = G.redISub(re).redISub(re), c = Q.redMul(re.redISub(f)).redISub(R), l = this.y.redMul(this.z), l = l.redIAdd(l);
        }
        return this.curve.jpoint(f, c, l);
    }, a.prototype._threeDbl = function() {
        var f, c, l;
        if (this.zOne) {
            var p = this.x.redSqr(), y = this.y.redSqr(), _ = y.redSqr(), A = this.x.redAdd(y).redSqr().redISub(p).redISub(_);
            A = A.redIAdd(A);
            var O = p.redAdd(p).redIAdd(p).redIAdd(this.curve.a), N = O.redSqr().redISub(A).redISub(A);
            f = N;
            var U = _.redIAdd(_);
            U = U.redIAdd(U), U = U.redIAdd(U), c = O.redMul(A.redISub(N)).redISub(U), l = this.y.redAdd(this.y);
        } else {
            var D = this.z.redSqr(), H = this.y.redSqr(), K = this.x.redMul(H), re = this.x.redSub(D).redMul(this.x.redAdd(D));
            re = re.redAdd(re).redIAdd(re);
            var Q = K.redIAdd(K);
            Q = Q.redIAdd(Q);
            var G = Q.redAdd(Q);
            f = re.redSqr().redISub(G), l = this.y.redAdd(this.z).redSqr().redISub(H).redISub(D);
            var R = H.redSqr();
            R = R.redIAdd(R), R = R.redIAdd(R), R = R.redIAdd(R), c = re.redMul(Q.redISub(f)).redISub(R);
        }
        return this.curve.jpoint(f, c, l);
    }, a.prototype._dbl = function() {
        var f = this.curve.a, c = this.x, l = this.y, p = this.z, y = p.redSqr().redSqr(), _ = c.redSqr(), A = l.redSqr(), O = _.redAdd(_).redIAdd(_).redIAdd(f.redMul(y)), N = c.redAdd(c);
        N = N.redIAdd(N);
        var U = N.redMul(A), D = O.redSqr().redISub(U.redAdd(U)), H = U.redISub(D), K = A.redSqr();
        K = K.redIAdd(K), K = K.redIAdd(K), K = K.redIAdd(K);
        var re = O.redMul(H).redISub(K), Q = l.redAdd(l).redMul(p);
        return this.curve.jpoint(D, re, Q);
    }, a.prototype.trpl = function() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var f = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr(), p = c.redSqr(), y = f.redAdd(f).redIAdd(f), _ = y.redSqr(), A = this.x.redAdd(c).redSqr().redISub(f).redISub(p);
        A = A.redIAdd(A), A = A.redAdd(A).redIAdd(A), A = A.redISub(_);
        var O = A.redSqr(), N = p.redIAdd(p);
        N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
        var U = y.redIAdd(A).redSqr().redISub(_).redISub(O).redISub(N), D = c.redMul(U);
        D = D.redIAdd(D), D = D.redIAdd(D);
        var H = this.x.redMul(O).redISub(D);
        H = H.redIAdd(H), H = H.redIAdd(H);
        var K = this.y.redMul(U.redMul(N.redISub(U)).redISub(A.redMul(O)));
        K = K.redIAdd(K), K = K.redIAdd(K), K = K.redIAdd(K);
        var re = this.z.redAdd(A).redSqr().redISub(l).redISub(O);
        return this.curve.jpoint(H, K, re);
    }, a.prototype.mul = function(f, c) {
        return f = new t(f, c), this.curve._wnafMul(this, f);
    }, a.prototype.eq = function(f) {
        if (f.type === "affine") return this.eq(f.toJ());
        if (this === f) return !0;
        var c = this.z.redSqr(), l = f.z.redSqr();
        if (this.x.redMul(l).redISub(f.x.redMul(c)).cmpn(0) !== 0) return !1;
        var p = c.redMul(this.z), y = l.redMul(f.z);
        return this.y.redMul(y).redISub(f.y.redMul(p)).cmpn(0) === 0;
    }, a.prototype.eqXToP = function(f) {
        var c = this.z.redSqr(), l = f.toRed(this.curve.red).redMul(c);
        if (this.x.cmp(l) === 0) return !0;
        for(var p = f.clone(), y = this.curve.redN.redMul(c);;){
            if (p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0) return !1;
            if (l.redIAdd(y), this.x.cmp(l) === 0) return !0;
        }
    }, a.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, a.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    }, g2;
}
var y2, Z5;
function yX() {
    if (Z5) return y2;
    Z5 = 1;
    var e = bi(), t = Or(), r = Tb(), n = ms();
    function i(s) {
        r.call(this, "mont", s), this.a = new e(s.a, 16).toRed(this.red), this.b = new e(s.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    t(i, r), y2 = i, i.prototype.validate = function(a) {
        var u = a.normalize().x, f = u.redSqr(), c = f.redMul(u).redAdd(f.redMul(this.a)).redAdd(u), l = c.redSqrt();
        return l.redSqr().cmp(c) === 0;
    };
    function o(s, a, u) {
        r.BasePoint.call(this, s, "projective"), a === null && u === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(a, 16), this.z = new e(u, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    return t(o, r.BasePoint), i.prototype.decodePoint = function(a, u) {
        return this.point(n.toArray(a, u), 1);
    }, i.prototype.point = function(a, u) {
        return new o(this, a, u);
    }, i.prototype.pointFromJSON = function(a) {
        return o.fromJSON(this, a);
    }, o.prototype.precompute = function() {}, o.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    }, o.fromJSON = function(a, u) {
        return new o(a, u[0], u[1] || a.one);
    }, o.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, o.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    }, o.prototype.dbl = function() {
        var a = this.x.redAdd(this.z), u = a.redSqr(), f = this.x.redSub(this.z), c = f.redSqr(), l = u.redSub(c), p = u.redMul(c), y = l.redMul(c.redAdd(this.curve.a24.redMul(l)));
        return this.curve.point(p, y);
    }, o.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.diffAdd = function(a, u) {
        var f = this.x.redAdd(this.z), c = this.x.redSub(this.z), l = a.x.redAdd(a.z), p = a.x.redSub(a.z), y = p.redMul(f), _ = l.redMul(c), A = u.z.redMul(y.redAdd(_).redSqr()), O = u.x.redMul(y.redISub(_).redSqr());
        return this.curve.point(A, O);
    }, o.prototype.mul = function(a) {
        for(var u = a.clone(), f = this, c = this.curve.point(null, null), l = this, p = []; u.cmpn(0) !== 0; u.iushrn(1))p.push(u.andln(1));
        for(var y = p.length - 1; y >= 0; y--)p[y] === 0 ? (f = f.diffAdd(c, l), c = c.dbl()) : (c = f.diffAdd(c, l), f = f.dbl());
        return c;
    }, o.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.eq = function(a) {
        return this.getX().cmp(a.getX()) === 0;
    }, o.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, o.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    }, y2;
}
var m2, Y5;
function mX() {
    if (Y5) return m2;
    Y5 = 1;
    var e = ms(), t = bi(), r = Or(), n = Tb(), i = e.assert;
    function o(a) {
        this.twisted = (a.a | 0) !== 1, this.mOneA = this.twisted && (a.a | 0) === -1, this.extended = this.mOneA, n.call(this, "edwards", a), this.a = new t(a.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(a.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(a.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), i(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (a.c | 0) === 1;
    }
    r(o, n), m2 = o, o.prototype._mulA = function(u) {
        return this.mOneA ? u.redNeg() : this.a.redMul(u);
    }, o.prototype._mulC = function(u) {
        return this.oneC ? u : this.c.redMul(u);
    }, o.prototype.jpoint = function(u, f, c, l) {
        return this.point(u, f, c, l);
    }, o.prototype.pointFromX = function(u, f) {
        u = new t(u, 16), u.red || (u = u.toRed(this.red));
        var c = u.redSqr(), l = this.c2.redSub(this.a.redMul(c)), p = this.one.redSub(this.c2.redMul(this.d).redMul(c)), y = l.redMul(p.redInvm()), _ = y.redSqrt();
        if (_.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error("invalid point");
        var A = _.fromRed().isOdd();
        return (f && !A || !f && A) && (_ = _.redNeg()), this.point(u, _);
    }, o.prototype.pointFromY = function(u, f) {
        u = new t(u, 16), u.red || (u = u.toRed(this.red));
        var c = u.redSqr(), l = c.redSub(this.c2), p = c.redMul(this.d).redMul(this.c2).redSub(this.a), y = l.redMul(p.redInvm());
        if (y.cmp(this.zero) === 0) {
            if (f) throw new Error("invalid point");
            return this.point(this.zero, u);
        }
        var _ = y.redSqrt();
        if (_.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error("invalid point");
        return _.fromRed().isOdd() !== f && (_ = _.redNeg()), this.point(_, u);
    }, o.prototype.validate = function(u) {
        if (u.isInfinity()) return !0;
        u.normalize();
        var f = u.x.redSqr(), c = u.y.redSqr(), l = f.redMul(this.a).redAdd(c), p = this.c2.redMul(this.one.redAdd(this.d.redMul(f).redMul(c)));
        return l.cmp(p) === 0;
    };
    function s(a, u, f, c, l) {
        n.BasePoint.call(this, a, "projective"), u === null && f === null && c === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(u, 16), this.y = new t(f, 16), this.z = c ? new t(c, 16) : this.curve.one, this.t = l && new t(l, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    return r(s, n.BasePoint), o.prototype.pointFromJSON = function(u) {
        return s.fromJSON(this, u);
    }, o.prototype.point = function(u, f, c, l) {
        return new s(this, u, f, c, l);
    }, s.fromJSON = function(u, f) {
        return new s(u, f[0], f[1], f[2]);
    }, s.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, s.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, s.prototype._extDbl = function() {
        var u = this.x.redSqr(), f = this.y.redSqr(), c = this.z.redSqr();
        c = c.redIAdd(c);
        var l = this.curve._mulA(u), p = this.x.redAdd(this.y).redSqr().redISub(u).redISub(f), y = l.redAdd(f), _ = y.redSub(c), A = l.redSub(f), O = p.redMul(_), N = y.redMul(A), U = p.redMul(A), D = _.redMul(y);
        return this.curve.point(O, N, D, U);
    }, s.prototype._projDbl = function() {
        var u = this.x.redAdd(this.y).redSqr(), f = this.x.redSqr(), c = this.y.redSqr(), l, p, y, _, A, O;
        if (this.curve.twisted) {
            _ = this.curve._mulA(f);
            var N = _.redAdd(c);
            this.zOne ? (l = u.redSub(f).redSub(c).redMul(N.redSub(this.curve.two)), p = N.redMul(_.redSub(c)), y = N.redSqr().redSub(N).redSub(N)) : (A = this.z.redSqr(), O = N.redSub(A).redISub(A), l = u.redSub(f).redISub(c).redMul(O), p = N.redMul(_.redSub(c)), y = N.redMul(O));
        } else _ = f.redAdd(c), A = this.curve._mulC(this.z).redSqr(), O = _.redSub(A).redSub(A), l = this.curve._mulC(u.redISub(_)).redMul(O), p = this.curve._mulC(_).redMul(f.redISub(c)), y = _.redMul(O);
        return this.curve.point(l, p, y);
    }, s.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }, s.prototype._extAdd = function(u) {
        var f = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), c = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), l = this.t.redMul(this.curve.dd).redMul(u.t), p = this.z.redMul(u.z.redAdd(u.z)), y = c.redSub(f), _ = p.redSub(l), A = p.redAdd(l), O = c.redAdd(f), N = y.redMul(_), U = A.redMul(O), D = y.redMul(O), H = _.redMul(A);
        return this.curve.point(N, U, H, D);
    }, s.prototype._projAdd = function(u) {
        var f = this.z.redMul(u.z), c = f.redSqr(), l = this.x.redMul(u.x), p = this.y.redMul(u.y), y = this.curve.d.redMul(l).redMul(p), _ = c.redSub(y), A = c.redAdd(y), O = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(l).redISub(p), N = f.redMul(_).redMul(O), U, D;
        return this.curve.twisted ? (U = f.redMul(A).redMul(p.redSub(this.curve._mulA(l))), D = _.redMul(A)) : (U = f.redMul(A).redMul(p.redSub(l)), D = this.curve._mulC(_).redMul(A)), this.curve.point(N, U, D);
    }, s.prototype.add = function(u) {
        return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u);
    }, s.prototype.mul = function(u) {
        return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u);
    }, s.prototype.mulAdd = function(u, f, c) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            u,
            c
        ], 2, !1);
    }, s.prototype.jmulAdd = function(u, f, c) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            u,
            c
        ], 2, !0);
    }, s.prototype.normalize = function() {
        if (this.zOne) return this;
        var u = this.z.redInvm();
        return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this;
    }, s.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, s.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    }, s.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
    }, s.prototype.eq = function(u) {
        return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0;
    }, s.prototype.eqXToP = function(u) {
        var f = u.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(f) === 0) return !0;
        for(var c = u.clone(), l = this.curve.redN.redMul(this.z);;){
            if (c.iadd(this.curve.n), c.cmp(this.curve.p) >= 0) return !1;
            if (f.redIAdd(l), this.x.cmp(f) === 0) return !0;
        }
    }, s.prototype.toP = s.prototype.normalize, s.prototype.mixedAdd = s.prototype.add, m2;
}
var X5;
function BO() {
    return X5 || (X5 = 1, function(e) {
        var t = e;
        t.base = Tb(), t.short = gX(), t.mont = yX(), t.edwards = mX();
    }(h2)), h2;
}
var b2 = {}, w2 = {}, nn = {}, J5;
function Sa() {
    if (J5) return nn;
    J5 = 1;
    var e = ys(), t = Or();
    nn.inherits = t;
    function r(S, w) {
        return (S.charCodeAt(w) & 64512) !== 55296 || w < 0 || w + 1 >= S.length ? !1 : (S.charCodeAt(w + 1) & 64512) === 56320;
    }
    function n(S, w) {
        if (Array.isArray(S)) return S.slice();
        if (!S) return [];
        var g = [];
        if (typeof S == "string") if (w) {
            if (w === "hex") for(S = S.replace(/[^a-z0-9]+/ig, ""), S.length % 2 !== 0 && (S = "0" + S), E = 0; E < S.length; E += 2)g.push(parseInt(S[E] + S[E + 1], 16));
        } else for(var m = 0, E = 0; E < S.length; E++){
            var T = S.charCodeAt(E);
            T < 128 ? g[m++] = T : T < 2048 ? (g[m++] = T >> 6 | 192, g[m++] = T & 63 | 128) : r(S, E) ? (T = 65536 + ((T & 1023) << 10) + (S.charCodeAt(++E) & 1023), g[m++] = T >> 18 | 240, g[m++] = T >> 12 & 63 | 128, g[m++] = T >> 6 & 63 | 128, g[m++] = T & 63 | 128) : (g[m++] = T >> 12 | 224, g[m++] = T >> 6 & 63 | 128, g[m++] = T & 63 | 128);
        }
        else for(E = 0; E < S.length; E++)g[E] = S[E] | 0;
        return g;
    }
    nn.toArray = n;
    function i(S) {
        for(var w = "", g = 0; g < S.length; g++)w += a(S[g].toString(16));
        return w;
    }
    nn.toHex = i;
    function o(S) {
        var w = S >>> 24 | S >>> 8 & 65280 | S << 8 & 16711680 | (S & 255) << 24;
        return w >>> 0;
    }
    nn.htonl = o;
    function s(S, w) {
        for(var g = "", m = 0; m < S.length; m++){
            var E = S[m];
            w === "little" && (E = o(E)), g += u(E.toString(16));
        }
        return g;
    }
    nn.toHex32 = s;
    function a(S) {
        return S.length === 1 ? "0" + S : S;
    }
    nn.zero2 = a;
    function u(S) {
        return S.length === 7 ? "0" + S : S.length === 6 ? "00" + S : S.length === 5 ? "000" + S : S.length === 4 ? "0000" + S : S.length === 3 ? "00000" + S : S.length === 2 ? "000000" + S : S.length === 1 ? "0000000" + S : S;
    }
    nn.zero8 = u;
    function f(S, w, g, m) {
        var E = g - w;
        e(E % 4 === 0);
        for(var T = new Array(E / 4), I = 0, P = w; I < T.length; I++, P += 4){
            var k;
            m === "big" ? k = S[P] << 24 | S[P + 1] << 16 | S[P + 2] << 8 | S[P + 3] : k = S[P + 3] << 24 | S[P + 2] << 16 | S[P + 1] << 8 | S[P], T[I] = k >>> 0;
        }
        return T;
    }
    nn.join32 = f;
    function c(S, w) {
        for(var g = new Array(S.length * 4), m = 0, E = 0; m < S.length; m++, E += 4){
            var T = S[m];
            w === "big" ? (g[E] = T >>> 24, g[E + 1] = T >>> 16 & 255, g[E + 2] = T >>> 8 & 255, g[E + 3] = T & 255) : (g[E + 3] = T >>> 24, g[E + 2] = T >>> 16 & 255, g[E + 1] = T >>> 8 & 255, g[E] = T & 255);
        }
        return g;
    }
    nn.split32 = c;
    function l(S, w) {
        return S >>> w | S << 32 - w;
    }
    nn.rotr32 = l;
    function p(S, w) {
        return S << w | S >>> 32 - w;
    }
    nn.rotl32 = p;
    function y(S, w) {
        return S + w >>> 0;
    }
    nn.sum32 = y;
    function _(S, w, g) {
        return S + w + g >>> 0;
    }
    nn.sum32_3 = _;
    function A(S, w, g, m) {
        return S + w + g + m >>> 0;
    }
    nn.sum32_4 = A;
    function O(S, w, g, m, E) {
        return S + w + g + m + E >>> 0;
    }
    nn.sum32_5 = O;
    function N(S, w, g, m) {
        var E = S[w], T = S[w + 1], I = m + T >>> 0, P = (I < m ? 1 : 0) + g + E;
        S[w] = P >>> 0, S[w + 1] = I;
    }
    nn.sum64 = N;
    function U(S, w, g, m) {
        var E = w + m >>> 0, T = (E < w ? 1 : 0) + S + g;
        return T >>> 0;
    }
    nn.sum64_hi = U;
    function D(S, w, g, m) {
        var E = w + m;
        return E >>> 0;
    }
    nn.sum64_lo = D;
    function H(S, w, g, m, E, T, I, P) {
        var k = 0, L = w;
        L = L + m >>> 0, k += L < w ? 1 : 0, L = L + T >>> 0, k += L < T ? 1 : 0, L = L + P >>> 0, k += L < P ? 1 : 0;
        var j = S + g + E + I + k;
        return j >>> 0;
    }
    nn.sum64_4_hi = H;
    function K(S, w, g, m, E, T, I, P) {
        var k = w + m + T + P;
        return k >>> 0;
    }
    nn.sum64_4_lo = K;
    function re(S, w, g, m, E, T, I, P, k, L) {
        var j = 0, ie = w;
        ie = ie + m >>> 0, j += ie < w ? 1 : 0, ie = ie + T >>> 0, j += ie < T ? 1 : 0, ie = ie + P >>> 0, j += ie < P ? 1 : 0, ie = ie + L >>> 0, j += ie < L ? 1 : 0;
        var ue = S + g + E + I + k + j;
        return ue >>> 0;
    }
    nn.sum64_5_hi = re;
    function Q(S, w, g, m, E, T, I, P, k, L) {
        var j = w + m + T + P + L;
        return j >>> 0;
    }
    nn.sum64_5_lo = Q;
    function G(S, w, g) {
        var m = w << 32 - g | S >>> g;
        return m >>> 0;
    }
    nn.rotr64_hi = G;
    function R(S, w, g) {
        var m = S << 32 - g | w >>> g;
        return m >>> 0;
    }
    nn.rotr64_lo = R;
    function X(S, w, g) {
        return S >>> g;
    }
    nn.shr64_hi = X;
    function $(S, w, g) {
        var m = S << 32 - g | w >>> g;
        return m >>> 0;
    }
    return nn.shr64_lo = $, nn;
}
var v2 = {}, Q5;
function s0() {
    if (Q5) return v2;
    Q5 = 1;
    var e = Sa(), t = ys();
    function r() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    return v2.BlockHash = r, r.prototype.update = function(i, o) {
        if (i = e.toArray(i, o), this.pending ? this.pending = this.pending.concat(i) : this.pending = i, this.pendingTotal += i.length, this.pending.length >= this._delta8) {
            i = this.pending;
            var s = i.length % this._delta8;
            this.pending = i.slice(i.length - s, i.length), this.pending.length === 0 && (this.pending = null), i = e.join32(i, 0, i.length - s, this.endian);
            for(var a = 0; a < i.length; a += this._delta32)this._update(i, a, a + this._delta32);
        }
        return this;
    }, r.prototype.digest = function(i) {
        return this.update(this._pad()), t(this.pending === null), this._digest(i);
    }, r.prototype._pad = function() {
        var i = this.pendingTotal, o = this._delta8, s = o - (i + this.padLength) % o, a = new Array(s + this.padLength);
        a[0] = 128;
        for(var u = 1; u < s; u++)a[u] = 0;
        if (i <<= 3, this.endian === "big") {
            for(var f = 8; f < this.padLength; f++)a[u++] = 0;
            a[u++] = 0, a[u++] = 0, a[u++] = 0, a[u++] = 0, a[u++] = i >>> 24 & 255, a[u++] = i >>> 16 & 255, a[u++] = i >>> 8 & 255, a[u++] = i & 255;
        } else for(a[u++] = i & 255, a[u++] = i >>> 8 & 255, a[u++] = i >>> 16 & 255, a[u++] = i >>> 24 & 255, a[u++] = 0, a[u++] = 0, a[u++] = 0, a[u++] = 0, f = 8; f < this.padLength; f++)a[u++] = 0;
        return a;
    }, v2;
}
var Ku = {}, Zs = {}, eT;
function OO() {
    if (eT) return Zs;
    eT = 1;
    var e = Sa(), t = e.rotr32;
    function r(c, l, p, y) {
        if (c === 0) return n(l, p, y);
        if (c === 1 || c === 3) return o(l, p, y);
        if (c === 2) return i(l, p, y);
    }
    Zs.ft_1 = r;
    function n(c, l, p) {
        return c & l ^ ~c & p;
    }
    Zs.ch32 = n;
    function i(c, l, p) {
        return c & l ^ c & p ^ l & p;
    }
    Zs.maj32 = i;
    function o(c, l, p) {
        return c ^ l ^ p;
    }
    Zs.p32 = o;
    function s(c) {
        return t(c, 2) ^ t(c, 13) ^ t(c, 22);
    }
    Zs.s0_256 = s;
    function a(c) {
        return t(c, 6) ^ t(c, 11) ^ t(c, 25);
    }
    Zs.s1_256 = a;
    function u(c) {
        return t(c, 7) ^ t(c, 18) ^ c >>> 3;
    }
    Zs.g0_256 = u;
    function f(c) {
        return t(c, 17) ^ t(c, 19) ^ c >>> 10;
    }
    return Zs.g1_256 = f, Zs;
}
var _2, tT;
function bX() {
    if (tT) return _2;
    tT = 1;
    var e = Sa(), t = s0(), r = OO(), n = e.rotl32, i = e.sum32, o = e.sum32_5, s = r.ft_1, a = t.BlockHash, u = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    function f() {
        if (!(this instanceof f)) return new f();
        a.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.W = new Array(80);
    }
    return e.inherits(f, a), _2 = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 80, f.padLength = 64, f.prototype._update = function(l, p) {
        for(var y = this.W, _ = 0; _ < 16; _++)y[_] = l[p + _];
        for(; _ < y.length; _++)y[_] = n(y[_ - 3] ^ y[_ - 8] ^ y[_ - 14] ^ y[_ - 16], 1);
        var A = this.h[0], O = this.h[1], N = this.h[2], U = this.h[3], D = this.h[4];
        for(_ = 0; _ < y.length; _++){
            var H = ~~(_ / 20), K = o(n(A, 5), s(H, O, N, U), D, y[_], u[H]);
            D = U, U = N, N = n(O, 30), O = A, A = K;
        }
        this.h[0] = i(this.h[0], A), this.h[1] = i(this.h[1], O), this.h[2] = i(this.h[2], N), this.h[3] = i(this.h[3], U), this.h[4] = i(this.h[4], D);
    }, f.prototype._digest = function(l) {
        return l === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    }, _2;
}
var E2, rT;
function PO() {
    if (rT) return E2;
    rT = 1;
    var e = Sa(), t = s0(), r = OO(), n = ys(), i = e.sum32, o = e.sum32_4, s = e.sum32_5, a = r.ch32, u = r.maj32, f = r.s0_256, c = r.s1_256, l = r.g0_256, p = r.g1_256, y = t.BlockHash, _ = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ];
    function A() {
        if (!(this instanceof A)) return new A();
        y.call(this), this.h = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
        ], this.k = _, this.W = new Array(64);
    }
    return e.inherits(A, y), E2 = A, A.blockSize = 512, A.outSize = 256, A.hmacStrength = 192, A.padLength = 64, A.prototype._update = function(N, U) {
        for(var D = this.W, H = 0; H < 16; H++)D[H] = N[U + H];
        for(; H < D.length; H++)D[H] = o(p(D[H - 2]), D[H - 7], l(D[H - 15]), D[H - 16]);
        var K = this.h[0], re = this.h[1], Q = this.h[2], G = this.h[3], R = this.h[4], X = this.h[5], $ = this.h[6], S = this.h[7];
        for(n(this.k.length === D.length), H = 0; H < D.length; H++){
            var w = s(S, c(R), a(R, X, $), this.k[H], D[H]), g = i(f(K), u(K, re, Q));
            S = $, $ = X, X = R, R = i(G, w), G = Q, Q = re, re = K, K = i(w, g);
        }
        this.h[0] = i(this.h[0], K), this.h[1] = i(this.h[1], re), this.h[2] = i(this.h[2], Q), this.h[3] = i(this.h[3], G), this.h[4] = i(this.h[4], R), this.h[5] = i(this.h[5], X), this.h[6] = i(this.h[6], $), this.h[7] = i(this.h[7], S);
    }, A.prototype._digest = function(N) {
        return N === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    }, E2;
}
var x2, nT;
function wX() {
    if (nT) return x2;
    nT = 1;
    var e = Sa(), t = PO();
    function r() {
        if (!(this instanceof r)) return new r();
        t.call(this), this.h = [
            3238371032,
            914150663,
            812702999,
            4144912697,
            4290775857,
            1750603025,
            1694076839,
            3204075428
        ];
    }
    return e.inherits(r, t), x2 = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(i) {
        return i === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
    }, x2;
}
var S2, iT;
function NO() {
    if (iT) return S2;
    iT = 1;
    var e = Sa(), t = s0(), r = ys(), n = e.rotr64_hi, i = e.rotr64_lo, o = e.shr64_hi, s = e.shr64_lo, a = e.sum64, u = e.sum64_hi, f = e.sum64_lo, c = e.sum64_4_hi, l = e.sum64_4_lo, p = e.sum64_5_hi, y = e.sum64_5_lo, _ = t.BlockHash, A = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ];
    function O() {
        if (!(this instanceof O)) return new O();
        _.call(this), this.h = [
            1779033703,
            4089235720,
            3144134277,
            2227873595,
            1013904242,
            4271175723,
            2773480762,
            1595750129,
            1359893119,
            2917565137,
            2600822924,
            725511199,
            528734635,
            4215389547,
            1541459225,
            327033209
        ], this.k = A, this.W = new Array(160);
    }
    e.inherits(O, _), S2 = O, O.blockSize = 1024, O.outSize = 512, O.hmacStrength = 192, O.padLength = 128, O.prototype._prepareBlock = function(g, m) {
        for(var E = this.W, T = 0; T < 32; T++)E[T] = g[m + T];
        for(; T < E.length; T += 2){
            var I = $(E[T - 4], E[T - 3]), P = S(E[T - 4], E[T - 3]), k = E[T - 14], L = E[T - 13], j = R(E[T - 30], E[T - 29]), ie = X(E[T - 30], E[T - 29]), ue = E[T - 32], ce = E[T - 31];
            E[T] = c(I, P, k, L, j, ie, ue, ce), E[T + 1] = l(I, P, k, L, j, ie, ue, ce);
        }
    }, O.prototype._update = function(g, m) {
        this._prepareBlock(g, m);
        var E = this.W, T = this.h[0], I = this.h[1], P = this.h[2], k = this.h[3], L = this.h[4], j = this.h[5], ie = this.h[6], ue = this.h[7], ce = this.h[8], he = this.h[9], ee = this.h[10], ae = this.h[11], ye = this.h[12], Se = this.h[13], De = this.h[14], Re = this.h[15];
        r(this.k.length === E.length);
        for(var Ce = 0; Ce < E.length; Ce += 2){
            var M = De, z = Re, de = Q(ce, he), _e = G(ce, he), Ie = N(ce, he, ee, ae, ye), je = U(ce, he, ee, ae, ye, Se), Ke = this.k[Ce], Ue = this.k[Ce + 1], h = E[Ce], x = E[Ce + 1], q = p(M, z, de, _e, Ie, je, Ke, Ue, h, x), te = y(M, z, de, _e, Ie, je, Ke, Ue, h, x);
            M = K(T, I), z = re(T, I), de = D(T, I, P, k, L), _e = H(T, I, P, k, L, j);
            var fe = u(M, z, de, _e), ne = f(M, z, de, _e);
            De = ye, Re = Se, ye = ee, Se = ae, ee = ce, ae = he, ce = u(ie, ue, q, te), he = f(ue, ue, q, te), ie = L, ue = j, L = P, j = k, P = T, k = I, T = u(q, te, fe, ne), I = f(q, te, fe, ne);
        }
        a(this.h, 0, T, I), a(this.h, 2, P, k), a(this.h, 4, L, j), a(this.h, 6, ie, ue), a(this.h, 8, ce, he), a(this.h, 10, ee, ae), a(this.h, 12, ye, Se), a(this.h, 14, De, Re);
    }, O.prototype._digest = function(g) {
        return g === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    };
    function N(w, g, m, E, T) {
        var I = w & m ^ ~w & T;
        return I < 0 && (I += 4294967296), I;
    }
    function U(w, g, m, E, T, I) {
        var P = g & E ^ ~g & I;
        return P < 0 && (P += 4294967296), P;
    }
    function D(w, g, m, E, T) {
        var I = w & m ^ w & T ^ m & T;
        return I < 0 && (I += 4294967296), I;
    }
    function H(w, g, m, E, T, I) {
        var P = g & E ^ g & I ^ E & I;
        return P < 0 && (P += 4294967296), P;
    }
    function K(w, g) {
        var m = n(w, g, 28), E = n(g, w, 2), T = n(g, w, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function re(w, g) {
        var m = i(w, g, 28), E = i(g, w, 2), T = i(g, w, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function Q(w, g) {
        var m = n(w, g, 14), E = n(w, g, 18), T = n(g, w, 9), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function G(w, g) {
        var m = i(w, g, 14), E = i(w, g, 18), T = i(g, w, 9), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function R(w, g) {
        var m = n(w, g, 1), E = n(w, g, 8), T = o(w, g, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function X(w, g) {
        var m = i(w, g, 1), E = i(w, g, 8), T = s(w, g, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function $(w, g) {
        var m = n(w, g, 19), E = n(g, w, 29), T = o(w, g, 6), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function S(w, g) {
        var m = i(w, g, 19), E = i(g, w, 29), T = s(w, g, 6), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    return S2;
}
var A2, oT;
function vX() {
    if (oT) return A2;
    oT = 1;
    var e = Sa(), t = NO();
    function r() {
        if (!(this instanceof r)) return new r();
        t.call(this), this.h = [
            3418070365,
            3238371032,
            1654270250,
            914150663,
            2438529370,
            812702999,
            355462360,
            4144912697,
            1731405415,
            4290775857,
            2394180231,
            1750603025,
            3675008525,
            1694076839,
            1203062813,
            3204075428
        ];
    }
    return e.inherits(r, t), A2 = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(i) {
        return i === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
    }, A2;
}
var sT;
function _X() {
    return sT || (sT = 1, Ku.sha1 = bX(), Ku.sha224 = wX(), Ku.sha256 = PO(), Ku.sha384 = vX(), Ku.sha512 = NO()), Ku;
}
var T2 = {}, aT;
function EX() {
    if (aT) return T2;
    aT = 1;
    var e = Sa(), t = s0(), r = e.rotl32, n = e.sum32, i = e.sum32_3, o = e.sum32_4, s = t.BlockHash;
    function a() {
        if (!(this instanceof a)) return new a();
        s.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.endian = "little";
    }
    e.inherits(a, s), T2.ripemd160 = a, a.blockSize = 512, a.outSize = 160, a.hmacStrength = 192, a.padLength = 64, a.prototype._update = function(O, N) {
        for(var U = this.h[0], D = this.h[1], H = this.h[2], K = this.h[3], re = this.h[4], Q = U, G = D, R = H, X = K, $ = re, S = 0; S < 80; S++){
            var w = n(r(o(U, u(S, D, H, K), O[l[S] + N], f(S)), y[S]), re);
            U = re, re = K, K = r(H, 10), H = D, D = w, w = n(r(o(Q, u(79 - S, G, R, X), O[p[S] + N], c(S)), _[S]), $), Q = $, $ = X, X = r(R, 10), R = G, G = w;
        }
        w = i(this.h[1], H, X), this.h[1] = i(this.h[2], K, $), this.h[2] = i(this.h[3], re, Q), this.h[3] = i(this.h[4], U, G), this.h[4] = i(this.h[0], D, R), this.h[0] = w;
    }, a.prototype._digest = function(O) {
        return O === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
    };
    function u(A, O, N, U) {
        return A <= 15 ? O ^ N ^ U : A <= 31 ? O & N | ~O & U : A <= 47 ? (O | ~N) ^ U : A <= 63 ? O & U | N & ~U : O ^ (N | ~U);
    }
    function f(A) {
        return A <= 15 ? 0 : A <= 31 ? 1518500249 : A <= 47 ? 1859775393 : A <= 63 ? 2400959708 : 2840853838;
    }
    function c(A) {
        return A <= 15 ? 1352829926 : A <= 31 ? 1548603684 : A <= 47 ? 1836072691 : A <= 63 ? 2053994217 : 0;
    }
    var l = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], p = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], y = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], _ = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ];
    return T2;
}
var k2, cT;
function xX() {
    if (cT) return k2;
    cT = 1;
    var e = Sa(), t = ys();
    function r(n, i, o) {
        if (!(this instanceof r)) return new r(n, i, o);
        this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(i, o));
    }
    return k2 = r, r.prototype._init = function(i) {
        i.length > this.blockSize && (i = new this.Hash().update(i).digest()), t(i.length <= this.blockSize);
        for(var o = i.length; o < this.blockSize; o++)i.push(0);
        for(o = 0; o < i.length; o++)i[o] ^= 54;
        for(this.inner = new this.Hash().update(i), o = 0; o < i.length; o++)i[o] ^= 106;
        this.outer = new this.Hash().update(i);
    }, r.prototype.update = function(i, o) {
        return this.inner.update(i, o), this;
    }, r.prototype.digest = function(i) {
        return this.outer.update(this.inner.digest()), this.outer.digest(i);
    }, k2;
}
var uT;
function z3() {
    return uT || (uT = 1, function(e) {
        var t = e;
        t.utils = Sa(), t.common = s0(), t.sha = _X(), t.ripemd = EX(), t.hmac = xX(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
    }(w2)), w2;
}
var I2, fT;
function SX() {
    return fT || (fT = 1, I2 = {
        doubles: {
            step: 4,
            points: [
                [
                    "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                    "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
                ],
                [
                    "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                    "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
                ],
                [
                    "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                    "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
                ],
                [
                    "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                    "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
                ],
                [
                    "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                    "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
                ],
                [
                    "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                    "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
                ],
                [
                    "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                    "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
                ],
                [
                    "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                    "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
                ],
                [
                    "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                    "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
                ],
                [
                    "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                    "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
                ],
                [
                    "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                    "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
                ],
                [
                    "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                    "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
                ],
                [
                    "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                    "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
                ],
                [
                    "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                    "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
                ],
                [
                    "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                    "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
                ],
                [
                    "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                    "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
                ],
                [
                    "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                    "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
                ],
                [
                    "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                    "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
                ],
                [
                    "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                    "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
                ],
                [
                    "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                    "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
                ],
                [
                    "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                    "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
                ],
                [
                    "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                    "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
                ],
                [
                    "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                    "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
                ],
                [
                    "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                    "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
                ],
                [
                    "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                    "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
                ],
                [
                    "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                    "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
                ],
                [
                    "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                    "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
                ],
                [
                    "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                    "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
                ],
                [
                    "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                    "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
                ],
                [
                    "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                    "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
                ],
                [
                    "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                    "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
                ],
                [
                    "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                    "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
                ],
                [
                    "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                    "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
                ],
                [
                    "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                    "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
                ],
                [
                    "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                    "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
                ],
                [
                    "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                    "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
                ],
                [
                    "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                    "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
                ],
                [
                    "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                    "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
                ],
                [
                    "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                    "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
                ],
                [
                    "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                    "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
                ],
                [
                    "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                    "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
                ],
                [
                    "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                    "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
                ],
                [
                    "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                    "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
                ],
                [
                    "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                    "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
                ],
                [
                    "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                    "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
                ],
                [
                    "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                    "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
                ],
                [
                    "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                    "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
                ],
                [
                    "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                    "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
                ],
                [
                    "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                    "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
                ],
                [
                    "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                    "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
                ],
                [
                    "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                    "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
                ],
                [
                    "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                    "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
                ],
                [
                    "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                    "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
                ],
                [
                    "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                    "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
                ],
                [
                    "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                    "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
                ],
                [
                    "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                    "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
                ],
                [
                    "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                    "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
                ],
                [
                    "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                    "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
                ],
                [
                    "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                    "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
                ],
                [
                    "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                    "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
                ],
                [
                    "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                    "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
                ],
                [
                    "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                    "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
                ],
                [
                    "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                    "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
                ],
                [
                    "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                    "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
                ],
                [
                    "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                    "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
                ]
            ]
        },
        naf: {
            wnd: 7,
            points: [
                [
                    "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                    "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
                ],
                [
                    "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                    "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
                ],
                [
                    "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                    "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
                ],
                [
                    "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                    "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
                ],
                [
                    "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                    "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
                ],
                [
                    "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                    "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
                ],
                [
                    "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                    "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
                ],
                [
                    "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                    "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
                ],
                [
                    "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                    "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
                ],
                [
                    "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                    "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
                ],
                [
                    "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                    "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
                ],
                [
                    "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                    "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
                ],
                [
                    "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                    "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
                ],
                [
                    "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                    "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
                ],
                [
                    "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                    "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
                ],
                [
                    "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                    "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
                ],
                [
                    "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                    "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
                ],
                [
                    "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                    "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
                ],
                [
                    "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                    "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
                ],
                [
                    "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                    "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
                ],
                [
                    "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                    "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
                ],
                [
                    "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                    "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
                ],
                [
                    "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                    "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
                ],
                [
                    "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                    "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
                ],
                [
                    "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                    "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
                ],
                [
                    "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                    "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
                ],
                [
                    "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                    "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
                ],
                [
                    "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                    "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
                ],
                [
                    "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                    "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
                ],
                [
                    "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                    "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
                ],
                [
                    "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                    "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
                ],
                [
                    "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                    "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
                ],
                [
                    "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                    "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
                ],
                [
                    "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                    "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
                ],
                [
                    "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                    "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
                ],
                [
                    "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                    "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
                ],
                [
                    "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                    "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
                ],
                [
                    "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                    "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
                ],
                [
                    "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                    "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
                ],
                [
                    "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                    "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
                ],
                [
                    "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                    "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
                ],
                [
                    "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                    "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
                ],
                [
                    "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                    "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
                ],
                [
                    "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                    "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
                ],
                [
                    "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                    "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
                ],
                [
                    "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                    "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
                ],
                [
                    "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                    "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
                ],
                [
                    "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                    "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
                ],
                [
                    "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                    "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
                ],
                [
                    "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                    "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
                ],
                [
                    "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                    "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
                ],
                [
                    "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                    "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
                ],
                [
                    "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                    "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
                ],
                [
                    "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                    "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
                ],
                [
                    "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                    "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
                ],
                [
                    "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                    "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
                ],
                [
                    "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                    "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
                ],
                [
                    "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                    "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
                ],
                [
                    "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                    "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
                ],
                [
                    "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                    "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
                ],
                [
                    "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                    "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
                ],
                [
                    "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                    "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
                ],
                [
                    "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                    "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
                ],
                [
                    "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                    "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
                ],
                [
                    "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                    "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
                ],
                [
                    "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                    "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
                ],
                [
                    "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                    "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
                ],
                [
                    "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                    "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
                ],
                [
                    "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                    "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
                ],
                [
                    "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                    "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
                ],
                [
                    "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                    "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
                ],
                [
                    "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                    "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
                ],
                [
                    "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                    "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
                ],
                [
                    "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                    "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
                ],
                [
                    "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                    "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
                ],
                [
                    "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                    "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
                ],
                [
                    "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                    "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
                ],
                [
                    "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                    "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
                ],
                [
                    "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                    "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
                ],
                [
                    "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                    "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
                ],
                [
                    "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                    "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
                ],
                [
                    "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                    "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
                ],
                [
                    "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                    "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
                ],
                [
                    "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                    "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
                ],
                [
                    "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                    "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
                ],
                [
                    "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                    "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
                ],
                [
                    "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                    "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
                ],
                [
                    "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                    "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
                ],
                [
                    "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                    "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
                ],
                [
                    "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                    "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
                ],
                [
                    "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                    "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
                ],
                [
                    "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                    "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
                ],
                [
                    "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                    "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
                ],
                [
                    "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                    "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
                ],
                [
                    "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                    "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
                ],
                [
                    "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                    "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
                ],
                [
                    "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                    "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
                ],
                [
                    "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                    "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
                ],
                [
                    "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                    "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
                ],
                [
                    "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                    "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
                ],
                [
                    "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                    "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
                ],
                [
                    "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                    "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
                ],
                [
                    "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                    "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
                ],
                [
                    "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                    "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
                ],
                [
                    "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                    "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
                ],
                [
                    "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                    "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
                ],
                [
                    "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                    "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
                ],
                [
                    "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                    "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
                ],
                [
                    "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                    "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
                ],
                [
                    "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                    "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
                ],
                [
                    "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                    "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
                ],
                [
                    "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                    "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
                ],
                [
                    "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                    "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
                ],
                [
                    "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                    "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
                ],
                [
                    "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                    "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
                ],
                [
                    "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                    "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
                ],
                [
                    "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                    "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
                ],
                [
                    "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                    "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
                ],
                [
                    "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                    "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
                ],
                [
                    "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                    "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
                ],
                [
                    "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                    "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
                ],
                [
                    "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                    "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
                ],
                [
                    "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                    "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
                ],
                [
                    "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                    "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
                ],
                [
                    "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                    "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
                ],
                [
                    "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                    "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
                ],
                [
                    "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                    "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
                ]
            ]
        }
    }), I2;
}
var lT;
function j3() {
    return lT || (lT = 1, function(e) {
        var t = e, r = z3(), n = BO(), i = ms(), o = i.assert;
        function s(f) {
            f.type === "short" ? this.curve = new n.short(f) : f.type === "edwards" ? this.curve = new n.edwards(f) : this.curve = new n.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, o(this.g.validate(), "Invalid curve"), o(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        t.PresetCurve = s;
        function a(f, c) {
            Object.defineProperty(t, f, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var l = new s(c);
                    return Object.defineProperty(t, f, {
                        configurable: !0,
                        enumerable: !0,
                        value: l
                    }), l;
                }
            });
        }
        a("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: r.sha256,
            gRed: !1,
            g: [
                "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
                "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
            ]
        }), a("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: r.sha256,
            gRed: !1,
            g: [
                "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
                "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
            ]
        }), a("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: r.sha256,
            gRed: !1,
            g: [
                "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
                "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
            ]
        }), a("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: r.sha384,
            gRed: !1,
            g: [
                "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
            ]
        }), a("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: r.sha512,
            gRed: !1,
            g: [
                "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
            ]
        }), a("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: r.sha256,
            gRed: !1,
            g: [
                "9"
            ]
        }), a("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            // -121665 * (121666^(-1)) (mod P)
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: r.sha256,
            gRed: !1,
            g: [
                "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
                // 4/5
                "6666666666666666666666666666666666666666666666666666666666666658"
            ]
        });
        var u;
        try {
            u = SX();
        } catch  {
            u = void 0;
        }
        a("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: r.sha256,
            // Precomputed endomorphism
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                {
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                },
                {
                    a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                    b: "3086d221a7d46bcde86c90e49284eb15"
                }
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                u
            ]
        });
    }(b2)), b2;
}
var B2, dT;
function AX() {
    if (dT) return B2;
    dT = 1;
    var e = z3(), t = IO(), r = ys();
    function n(i) {
        if (!(this instanceof n)) return new n(i);
        this.hash = i.hash, this.predResist = !!i.predResist, this.outLen = this.hash.outSize, this.minEntropy = i.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var o = t.toArray(i.entropy, i.entropyEnc || "hex"), s = t.toArray(i.nonce, i.nonceEnc || "hex"), a = t.toArray(i.pers, i.persEnc || "hex");
        r(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(o, s, a);
    }
    return B2 = n, n.prototype._init = function(o, s, a) {
        var u = o.concat(s).concat(a);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for(var f = 0; f < this.V.length; f++)this.K[f] = 0, this.V[f] = 1;
        this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, n.prototype._hmac = function() {
        return new e.hmac(this.hash, this.K);
    }, n.prototype._update = function(o) {
        var s = this._hmac().update(this.V).update([
            0
        ]);
        o && (s = s.update(o)), this.K = s.digest(), this.V = this._hmac().update(this.V).digest(), o && (this.K = this._hmac().update(this.V).update([
            1
        ]).update(o).digest(), this.V = this._hmac().update(this.V).digest());
    }, n.prototype.reseed = function(o, s, a, u) {
        typeof s != "string" && (u = a, a = s, s = null), o = t.toArray(o, s), a = t.toArray(a, u), r(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(o.concat(a || [])), this._reseed = 1;
    }, n.prototype.generate = function(o, s, a, u) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        typeof s != "string" && (u = a, a = s, s = null), a && (a = t.toArray(a, u || "hex"), this._update(a));
        for(var f = []; f.length < o;)this.V = this._hmac().update(this.V).digest(), f = f.concat(this.V);
        var c = f.slice(0, o);
        return this._update(a), this._reseed++, t.encode(c, s);
    }, B2;
}
var O2, hT;
function TX() {
    if (hT) return O2;
    hT = 1;
    var e = bi(), t = ms(), r = t.assert;
    function n(i, o) {
        this.ec = i, this.priv = null, this.pub = null, o.priv && this._importPrivate(o.priv, o.privEnc), o.pub && this._importPublic(o.pub, o.pubEnc);
    }
    return O2 = n, n.fromPublic = function(o, s, a) {
        return s instanceof n ? s : new n(o, {
            pub: s,
            pubEnc: a
        });
    }, n.fromPrivate = function(o, s, a) {
        return s instanceof n ? s : new n(o, {
            priv: s,
            privEnc: a
        });
    }, n.prototype.validate = function() {
        var o = this.getPublic();
        return o.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : o.validate() ? o.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        };
    }, n.prototype.getPublic = function(o, s) {
        return typeof o == "string" && (s = o, o = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), s ? this.pub.encode(s, o) : this.pub;
    }, n.prototype.getPrivate = function(o) {
        return o === "hex" ? this.priv.toString(16, 2) : this.priv;
    }, n.prototype._importPrivate = function(o, s) {
        this.priv = new e(o, s || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, n.prototype._importPublic = function(o, s) {
        if (o.x || o.y) {
            this.ec.curve.type === "mont" ? r(o.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && r(o.x && o.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(o.x, o.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(o, s);
    }, n.prototype.derive = function(o) {
        return o.validate() || r(o.validate(), "public point not validated"), o.mul(this.priv).getX();
    }, n.prototype.sign = function(o, s, a) {
        return this.ec.sign(o, this, s, a);
    }, n.prototype.verify = function(o, s, a) {
        return this.ec.verify(o, s, this, void 0, a);
    }, n.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    }, O2;
}
var P2, pT;
function kX() {
    if (pT) return P2;
    pT = 1;
    var e = bi(), t = ms(), r = t.assert;
    function n(u, f) {
        if (u instanceof n) return u;
        this._importDER(u, f) || (r(u.r && u.s, "Signature without r or s"), this.r = new e(u.r, 16), this.s = new e(u.s, 16), u.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = u.recoveryParam);
    }
    P2 = n;
    function i() {
        this.place = 0;
    }
    function o(u, f) {
        var c = u[f.place++];
        if (!(c & 128)) return c;
        var l = c & 15;
        if (l === 0 || l > 4 || u[f.place] === 0) return !1;
        for(var p = 0, y = 0, _ = f.place; y < l; y++, _++)p <<= 8, p |= u[_], p >>>= 0;
        return p <= 127 ? !1 : (f.place = _, p);
    }
    function s(u) {
        for(var f = 0, c = u.length - 1; !u[f] && !(u[f + 1] & 128) && f < c;)f++;
        return f === 0 ? u : u.slice(f);
    }
    n.prototype._importDER = function(f, c) {
        f = t.toArray(f, c);
        var l = new i();
        if (f[l.place++] !== 48) return !1;
        var p = o(f, l);
        if (p === !1 || p + l.place !== f.length || f[l.place++] !== 2) return !1;
        var y = o(f, l);
        if (y === !1 || f[l.place] & 128) return !1;
        var _ = f.slice(l.place, y + l.place);
        if (l.place += y, f[l.place++] !== 2) return !1;
        var A = o(f, l);
        if (A === !1 || f.length !== A + l.place || f[l.place] & 128) return !1;
        var O = f.slice(l.place, A + l.place);
        if (_[0] === 0) if (_[1] & 128) _ = _.slice(1);
        else return !1;
        if (O[0] === 0) if (O[1] & 128) O = O.slice(1);
        else return !1;
        return this.r = new e(_), this.s = new e(O), this.recoveryParam = null, !0;
    };
    function a(u, f) {
        if (f < 128) {
            u.push(f);
            return;
        }
        var c = 1 + (Math.log(f) / Math.LN2 >>> 3);
        for(u.push(c | 128); --c;)u.push(f >>> (c << 3) & 255);
        u.push(f);
    }
    return n.prototype.toDER = function(f) {
        var c = this.r.toArray(), l = this.s.toArray();
        for(c[0] & 128 && (c = [
            0
        ].concat(c)), l[0] & 128 && (l = [
            0
        ].concat(l)), c = s(c), l = s(l); !l[0] && !(l[1] & 128);)l = l.slice(1);
        var p = [
            2
        ];
        a(p, c.length), p = p.concat(c), p.push(2), a(p, l.length);
        var y = p.concat(l), _ = [
            48
        ];
        return a(_, y.length), _ = _.concat(y), t.encode(_, f);
    }, P2;
}
var N2, gT;
function IX() {
    if (gT) return N2;
    gT = 1;
    var e = bi(), t = AX(), r = ms(), n = j3(), i = L3(), o = r.assert, s = TX(), a = kX();
    function u(f) {
        if (!(this instanceof u)) return new u(f);
        typeof f == "string" && (o(Object.prototype.hasOwnProperty.call(n, f), "Unknown curve " + f), f = n[f]), f instanceof n.PresetCurve && (f = {
            curve: f
        }), this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash;
    }
    return N2 = u, u.prototype.keyPair = function(c) {
        return new s(this, c);
    }, u.prototype.keyFromPrivate = function(c, l) {
        return s.fromPrivate(this, c, l);
    }, u.prototype.keyFromPublic = function(c, l) {
        return s.fromPublic(this, c, l);
    }, u.prototype.genKeyPair = function(c) {
        c || (c = {});
        for(var l = new t({
            hash: this.hash,
            pers: c.pers,
            persEnc: c.persEnc || "utf8",
            entropy: c.entropy || i(this.hash.hmacStrength),
            entropyEnc: c.entropy && c.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), p = this.n.byteLength(), y = this.n.sub(new e(2));;){
            var _ = new e(l.generate(p));
            if (!(_.cmp(y) > 0)) return _.iaddn(1), this.keyFromPrivate(_);
        }
    }, u.prototype._truncateToN = function(c, l, p) {
        var y;
        if (e.isBN(c) || typeof c == "number") c = new e(c, 16), y = c.byteLength();
        else if (typeof c == "object") y = c.length, c = new e(c, 16);
        else {
            var _ = c.toString();
            y = _.length + 1 >>> 1, c = new e(_, 16);
        }
        typeof p != "number" && (p = y * 8);
        var A = p - this.n.bitLength();
        return A > 0 && (c = c.ushrn(A)), !l && c.cmp(this.n) >= 0 ? c.sub(this.n) : c;
    }, u.prototype.sign = function(c, l, p, y) {
        if (typeof p == "object" && (y = p, p = null), y || (y = {}), typeof c != "string" && typeof c != "number" && !e.isBN(c)) {
            o(typeof c == "object" && c && typeof c.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), o(c.length >>> 0 === c.length);
            for(var _ = 0; _ < c.length; _++)o((c[_] & 255) === c[_]);
        }
        l = this.keyFromPrivate(l, p), c = this._truncateToN(c, !1, y.msgBitLength), o(!c.isNeg(), "Can not sign a negative message");
        var A = this.n.byteLength(), O = l.getPrivate().toArray("be", A), N = c.toArray("be", A);
        o(new e(N).eq(c), "Can not sign message");
        for(var U = new t({
            hash: this.hash,
            entropy: O,
            nonce: N,
            pers: y.pers,
            persEnc: y.persEnc || "utf8"
        }), D = this.n.sub(new e(1)), H = 0;; H++){
            var K = y.k ? y.k(H) : new e(U.generate(this.n.byteLength()));
            if (K = this._truncateToN(K, !0), !(K.cmpn(1) <= 0 || K.cmp(D) >= 0)) {
                var re = this.g.mul(K);
                if (!re.isInfinity()) {
                    var Q = re.getX(), G = Q.umod(this.n);
                    if (G.cmpn(0) !== 0) {
                        var R = K.invm(this.n).mul(G.mul(l.getPrivate()).iadd(c));
                        if (R = R.umod(this.n), R.cmpn(0) !== 0) {
                            var X = (re.getY().isOdd() ? 1 : 0) | (Q.cmp(G) !== 0 ? 2 : 0);
                            return y.canonical && R.cmp(this.nh) > 0 && (R = this.n.sub(R), X ^= 1), new a({
                                r: G,
                                s: R,
                                recoveryParam: X
                            });
                        }
                    }
                }
            }
        }
    }, u.prototype.verify = function(c, l, p, y, _) {
        _ || (_ = {}), c = this._truncateToN(c, !1, _.msgBitLength), p = this.keyFromPublic(p, y), l = new a(l, "hex");
        var A = l.r, O = l.s;
        if (A.cmpn(1) < 0 || A.cmp(this.n) >= 0 || O.cmpn(1) < 0 || O.cmp(this.n) >= 0) return !1;
        var N = O.invm(this.n), U = N.mul(c).umod(this.n), D = N.mul(A).umod(this.n), H;
        return this.curve._maxwellTrick ? (H = this.g.jmulAdd(U, p.getPublic(), D), H.isInfinity() ? !1 : H.eqXToP(A)) : (H = this.g.mulAdd(U, p.getPublic(), D), H.isInfinity() ? !1 : H.getX().umod(this.n).cmp(A) === 0);
    }, u.prototype.recoverPubKey = function(f, c, l, p) {
        o((3 & l) === l, "The recovery param is more than two bits"), c = new a(c, p);
        var y = this.n, _ = new e(f), A = c.r, O = c.s, N = l & 1, U = l >> 1;
        if (A.cmp(this.curve.p.umod(this.curve.n)) >= 0 && U) throw new Error("Unable to find sencond key candinate");
        U ? A = this.curve.pointFromX(A.add(this.curve.n), N) : A = this.curve.pointFromX(A, N);
        var D = c.r.invm(y), H = y.sub(_).mul(D).umod(y), K = O.mul(D).umod(y);
        return this.g.mulAdd(H, A, K);
    }, u.prototype.getKeyRecoveryParam = function(f, c, l, p) {
        if (c = new a(c, p), c.recoveryParam !== null) return c.recoveryParam;
        for(var y = 0; y < 4; y++){
            var _;
            try {
                _ = this.recoverPubKey(f, c, y);
            } catch  {
                continue;
            }
            if (_.eq(l)) return y;
        }
        throw new Error("Unable to find valid recovery factor");
    }, N2;
}
var M2, yT;
function BX() {
    if (yT) return M2;
    yT = 1;
    var e = ms(), t = e.assert, r = e.parseBytes, n = e.cachedProperty;
    function i(o, s) {
        this.eddsa = o, this._secret = r(s.secret), o.isPoint(s.pub) ? this._pub = s.pub : this._pubBytes = r(s.pub);
    }
    return i.fromPublic = function(s, a) {
        return a instanceof i ? a : new i(s, {
            pub: a
        });
    }, i.fromSecret = function(s, a) {
        return a instanceof i ? a : new i(s, {
            secret: a
        });
    }, i.prototype.secret = function() {
        return this._secret;
    }, n(i, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
    }), n(i, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    }), n(i, "privBytes", function() {
        var s = this.eddsa, a = this.hash(), u = s.encodingLength - 1, f = a.slice(0, s.encodingLength);
        return f[0] &= 248, f[u] &= 127, f[u] |= 64, f;
    }), n(i, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
    }), n(i, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
    }), n(i, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
    }), i.prototype.sign = function(s) {
        return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(s, this);
    }, i.prototype.verify = function(s, a) {
        return this.eddsa.verify(s, a, this);
    }, i.prototype.getSecret = function(s) {
        return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), s);
    }, i.prototype.getPublic = function(s) {
        return e.encode(this.pubBytes(), s);
    }, M2 = i, M2;
}
var R2, mT;
function OX() {
    if (mT) return R2;
    mT = 1;
    var e = bi(), t = ms(), r = t.assert, n = t.cachedProperty, i = t.parseBytes;
    function o(s, a) {
        this.eddsa = s, typeof a != "object" && (a = i(a)), Array.isArray(a) && (r(a.length === s.encodingLength * 2, "Signature has invalid size"), a = {
            R: a.slice(0, s.encodingLength),
            S: a.slice(s.encodingLength)
        }), r(a.R && a.S, "Signature without R or S"), s.isPoint(a.R) && (this._R = a.R), a.S instanceof e && (this._S = a.S), this._Rencoded = Array.isArray(a.R) ? a.R : a.Rencoded, this._Sencoded = Array.isArray(a.S) ? a.S : a.Sencoded;
    }
    return n(o, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
    }), n(o, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
    }), n(o, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
    }), n(o, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
    }), o.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
    }, o.prototype.toHex = function() {
        return t.encode(this.toBytes(), "hex").toUpperCase();
    }, R2 = o, R2;
}
var C2, bT;
function PX() {
    if (bT) return C2;
    bT = 1;
    var e = z3(), t = j3(), r = ms(), n = r.assert, i = r.parseBytes, o = BX(), s = OX();
    function a(u) {
        if (n(u === "ed25519", "only tested with ed25519 so far"), !(this instanceof a)) return new a(u);
        u = t[u].curve, this.curve = u, this.g = u.g, this.g.precompute(u.n.bitLength() + 1), this.pointClass = u.point().constructor, this.encodingLength = Math.ceil(u.n.bitLength() / 8), this.hash = e.sha512;
    }
    return C2 = a, a.prototype.sign = function(f, c) {
        f = i(f);
        var l = this.keyFromSecret(c), p = this.hashInt(l.messagePrefix(), f), y = this.g.mul(p), _ = this.encodePoint(y), A = this.hashInt(_, l.pubBytes(), f).mul(l.priv()), O = p.add(A).umod(this.curve.n);
        return this.makeSignature({
            R: y,
            S: O,
            Rencoded: _
        });
    }, a.prototype.verify = function(f, c, l) {
        if (f = i(f), c = this.makeSignature(c), c.S().gte(c.eddsa.curve.n) || c.S().isNeg()) return !1;
        var p = this.keyFromPublic(l), y = this.hashInt(c.Rencoded(), p.pubBytes(), f), _ = this.g.mul(c.S()), A = c.R().add(p.pub().mul(y));
        return A.eq(_);
    }, a.prototype.hashInt = function() {
        for(var f = this.hash(), c = 0; c < arguments.length; c++)f.update(arguments[c]);
        return r.intFromLE(f.digest()).umod(this.curve.n);
    }, a.prototype.keyFromPublic = function(f) {
        return o.fromPublic(this, f);
    }, a.prototype.keyFromSecret = function(f) {
        return o.fromSecret(this, f);
    }, a.prototype.makeSignature = function(f) {
        return f instanceof s ? f : new s(this, f);
    }, a.prototype.encodePoint = function(f) {
        var c = f.getY().toArray("le", this.encodingLength);
        return c[this.encodingLength - 1] |= f.getX().isOdd() ? 128 : 0, c;
    }, a.prototype.decodePoint = function(f) {
        f = r.parseBytes(f);
        var c = f.length - 1, l = f.slice(0, c).concat(f[c] & -129), p = (f[c] & 128) !== 0, y = r.intFromLE(l);
        return this.curve.pointFromY(y, p);
    }, a.prototype.encodeInt = function(f) {
        return f.toArray("le", this.encodingLength);
    }, a.prototype.decodeInt = function(f) {
        return r.intFromLE(f);
    }, a.prototype.isPoint = function(f) {
        return f instanceof this.pointClass;
    }, C2;
}
var wT;
function H3() {
    return wT || (wT = 1, function(e) {
        var t = e;
        t.version = pX.version, t.utils = ms(), t.rand = L3(), t.curve = BO(), t.curves = j3(), t.ec = IX(), t.eddsa = PX();
    }(f2)), f2;
}
var Xo = {}, U2 = {}, $2 = {}, vT;
function NX() {
    return vT || (vT = 1, function(e) {
        var t = a0(), r = Or(), n = e;
        n.define = function(s, a) {
            return new i(s, a);
        };
        function i(o, s) {
            this.name = o, this.body = s, this.decoders = {}, this.encoders = {};
        }
        i.prototype._createNamed = function(s) {
            var a;
            try {
                a = Iu.runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
            } catch  {
                a = function(f) {
                    this._initNamed(f);
                };
            }
            return r(a, s), a.prototype._initNamed = function(f) {
                s.call(this, f);
            }, new a(this);
        }, i.prototype._getDecoder = function(s) {
            return s = s || "der", this.decoders.hasOwnProperty(s) || (this.decoders[s] = this._createNamed(t.decoders[s])), this.decoders[s];
        }, i.prototype.decode = function(s, a, u) {
            return this._getDecoder(a).decode(s, u);
        }, i.prototype._getEncoder = function(s) {
            return s = s || "der", this.encoders.hasOwnProperty(s) || (this.encoders[s] = this._createNamed(t.encoders[s])), this.encoders[s];
        }, i.prototype.encode = function(s, a, u) {
            return this._getEncoder(a).encode(s, u);
        };
    }($2)), $2;
}
var L2 = {}, D2 = {}, _T;
function MX() {
    if (_T) return D2;
    _T = 1;
    var e = Or();
    function t(n) {
        this._reporterState = {
            obj: null,
            path: [],
            options: n || {},
            errors: []
        };
    }
    D2.Reporter = t, t.prototype.isError = function(i) {
        return i instanceof r;
    }, t.prototype.save = function() {
        var i = this._reporterState;
        return {
            obj: i.obj,
            pathLen: i.path.length
        };
    }, t.prototype.restore = function(i) {
        var o = this._reporterState;
        o.obj = i.obj, o.path = o.path.slice(0, i.pathLen);
    }, t.prototype.enterKey = function(i) {
        return this._reporterState.path.push(i);
    }, t.prototype.exitKey = function(i) {
        var o = this._reporterState;
        o.path = o.path.slice(0, i - 1);
    }, t.prototype.leaveKey = function(i, o, s) {
        var a = this._reporterState;
        this.exitKey(i), a.obj !== null && (a.obj[o] = s);
    }, t.prototype.path = function() {
        return this._reporterState.path.join("/");
    }, t.prototype.enterObject = function() {
        var i = this._reporterState, o = i.obj;
        return i.obj = {}, o;
    }, t.prototype.leaveObject = function(i) {
        var o = this._reporterState, s = o.obj;
        return o.obj = i, s;
    }, t.prototype.error = function(i) {
        var o, s = this._reporterState, a = i instanceof r;
        if (a ? o = i : o = new r(s.path.map(function(u) {
            return "[" + JSON.stringify(u) + "]";
        }).join(""), i.message || i, i.stack), !s.options.partial) throw o;
        return a || s.errors.push(o), o;
    }, t.prototype.wrapResult = function(i) {
        var o = this._reporterState;
        return o.options.partial ? {
            result: this.isError(i) ? null : i,
            errors: o.errors
        } : i;
    };
    function r(n, i) {
        this.path = n, this.rethrow(i);
    }
    return e(r, Error), r.prototype.rethrow = function(i) {
        if (this.message = i + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, r), !this.stack) try {
            throw new Error(this.message);
        } catch (o) {
            this.stack = o.stack;
        }
        return this;
    }, D2;
}
var Wg = {}, ET;
function xT() {
    if (ET) return Wg;
    ET = 1;
    var e = Or(), t = Dh().Reporter, r = ku.Buffer;
    function n(o, s) {
        if (t.call(this, s), !r.isBuffer(o)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = o, this.offset = 0, this.length = o.length;
    }
    e(n, t), Wg.DecoderBuffer = n, n.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: t.prototype.save.call(this)
        };
    }, n.prototype.restore = function(s) {
        var a = new n(this.base);
        return a.offset = s.offset, a.length = this.offset, this.offset = s.offset, t.prototype.restore.call(this, s.reporter), a;
    }, n.prototype.isEmpty = function() {
        return this.offset === this.length;
    }, n.prototype.readUInt8 = function(s) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(s || "DecoderBuffer overrun");
    }, n.prototype.skip = function(s, a) {
        if (!(this.offset + s <= this.length)) return this.error(a || "DecoderBuffer overrun");
        var u = new n(this.base);
        return u._reporterState = this._reporterState, u.offset = this.offset, u.length = this.offset + s, this.offset += s, u;
    }, n.prototype.raw = function(s) {
        return this.base.slice(s ? s.offset : this.offset, this.length);
    };
    function i(o, s) {
        if (Array.isArray(o)) this.length = 0, this.value = o.map(function(a) {
            return a instanceof i || (a = new i(a, s)), this.length += a.length, a;
        }, this);
        else if (typeof o == "number") {
            if (!(0 <= o && o <= 255)) return s.error("non-byte EncoderBuffer value");
            this.value = o, this.length = 1;
        } else if (typeof o == "string") this.value = o, this.length = r.byteLength(o);
        else if (r.isBuffer(o)) this.value = o, this.length = o.length;
        else return s.error("Unsupported type: " + typeof o);
    }
    return Wg.EncoderBuffer = i, i.prototype.join = function(s, a) {
        return s || (s = new r(this.length)), a || (a = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(u) {
            u.join(s, a), a += u.length;
        }) : (typeof this.value == "number" ? s[a] = this.value : typeof this.value == "string" ? s.write(this.value, a) : r.isBuffer(this.value) && this.value.copy(s, a), a += this.length)), s;
    }, Wg;
}
var F2, ST;
function RX() {
    if (ST) return F2;
    ST = 1;
    var e = Dh().Reporter, t = Dh().EncoderBuffer, r = Dh().DecoderBuffer, n = ys(), i = [
        "seq",
        "seqof",
        "set",
        "setof",
        "objid",
        "bool",
        "gentime",
        "utctime",
        "null_",
        "enum",
        "int",
        "objDesc",
        "bitstr",
        "bmpstr",
        "charstr",
        "genstr",
        "graphstr",
        "ia5str",
        "iso646str",
        "numstr",
        "octstr",
        "printstr",
        "t61str",
        "unistr",
        "utf8str",
        "videostr"
    ], o = [
        "key",
        "obj",
        "use",
        "optional",
        "explicit",
        "implicit",
        "def",
        "choice",
        "any",
        "contains"
    ].concat(i), s = [
        "_peekTag",
        "_decodeTag",
        "_use",
        "_decodeStr",
        "_decodeObjid",
        "_decodeTime",
        "_decodeNull",
        "_decodeInt",
        "_decodeBool",
        "_decodeList",
        "_encodeComposite",
        "_encodeStr",
        "_encodeObjid",
        "_encodeTime",
        "_encodeNull",
        "_encodeInt",
        "_encodeBool"
    ];
    function a(f, c) {
        var l = {};
        this._baseState = l, l.enc = f, l.parent = c || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
    }
    F2 = a;
    var u = [
        "enc",
        "parent",
        "children",
        "tag",
        "args",
        "reverseArgs",
        "choice",
        "optional",
        "any",
        "obj",
        "use",
        "alteredUse",
        "key",
        "default",
        "explicit",
        "implicit",
        "contains"
    ];
    return a.prototype.clone = function() {
        var c = this._baseState, l = {};
        u.forEach(function(y) {
            l[y] = c[y];
        });
        var p = new this.constructor(l.parent);
        return p._baseState = l, p;
    }, a.prototype._wrap = function() {
        var c = this._baseState;
        o.forEach(function(l) {
            this[l] = function() {
                var y = new this.constructor(this);
                return c.children.push(y), y[l].apply(y, arguments);
            };
        }, this);
    }, a.prototype._init = function(c) {
        var l = this._baseState;
        n(l.parent === null), c.call(this), l.children = l.children.filter(function(p) {
            return p._baseState.parent === this;
        }, this), n.equal(l.children.length, 1, "Root node can have only one child");
    }, a.prototype._useArgs = function(c) {
        var l = this._baseState, p = c.filter(function(y) {
            return y instanceof this.constructor;
        }, this);
        c = c.filter(function(y) {
            return !(y instanceof this.constructor);
        }, this), p.length !== 0 && (n(l.children === null), l.children = p, p.forEach(function(y) {
            y._baseState.parent = this;
        }, this)), c.length !== 0 && (n(l.args === null), l.args = c, l.reverseArgs = c.map(function(y) {
            if (typeof y != "object" || y.constructor !== Object) return y;
            var _ = {};
            return Object.keys(y).forEach(function(A) {
                A == (A | 0) && (A |= 0);
                var O = y[A];
                _[O] = A;
            }), _;
        }));
    }, s.forEach(function(f) {
        a.prototype[f] = function() {
            var l = this._baseState;
            throw new Error(f + " not implemented for encoding: " + l.enc);
        };
    }), i.forEach(function(f) {
        a.prototype[f] = function() {
            var l = this._baseState, p = Array.prototype.slice.call(arguments);
            return n(l.tag === null), l.tag = f, this._useArgs(p), this;
        };
    }), a.prototype.use = function(c) {
        n(c);
        var l = this._baseState;
        return n(l.use === null), l.use = c, this;
    }, a.prototype.optional = function() {
        var c = this._baseState;
        return c.optional = !0, this;
    }, a.prototype.def = function(c) {
        var l = this._baseState;
        return n(l.default === null), l.default = c, l.optional = !0, this;
    }, a.prototype.explicit = function(c) {
        var l = this._baseState;
        return n(l.explicit === null && l.implicit === null), l.explicit = c, this;
    }, a.prototype.implicit = function(c) {
        var l = this._baseState;
        return n(l.explicit === null && l.implicit === null), l.implicit = c, this;
    }, a.prototype.obj = function() {
        var c = this._baseState, l = Array.prototype.slice.call(arguments);
        return c.obj = !0, l.length !== 0 && this._useArgs(l), this;
    }, a.prototype.key = function(c) {
        var l = this._baseState;
        return n(l.key === null), l.key = c, this;
    }, a.prototype.any = function() {
        var c = this._baseState;
        return c.any = !0, this;
    }, a.prototype.choice = function(c) {
        var l = this._baseState;
        return n(l.choice === null), l.choice = c, this._useArgs(Object.keys(c).map(function(p) {
            return c[p];
        })), this;
    }, a.prototype.contains = function(c) {
        var l = this._baseState;
        return n(l.use === null), l.contains = c, this;
    }, a.prototype._decode = function(c, l) {
        var p = this._baseState;
        if (p.parent === null) return c.wrapResult(p.children[0]._decode(c, l));
        var y = p.default, _ = !0, A = null;
        if (p.key !== null && (A = c.enterKey(p.key)), p.optional) {
            var O = null;
            if (p.explicit !== null ? O = p.explicit : p.implicit !== null ? O = p.implicit : p.tag !== null && (O = p.tag), O === null && !p.any) {
                var N = c.save();
                try {
                    p.choice === null ? this._decodeGeneric(p.tag, c, l) : this._decodeChoice(c, l), _ = !0;
                } catch  {
                    _ = !1;
                }
                c.restore(N);
            } else if (_ = this._peekTag(c, O, p.any), c.isError(_)) return _;
        }
        var U;
        if (p.obj && _ && (U = c.enterObject()), _) {
            if (p.explicit !== null) {
                var D = this._decodeTag(c, p.explicit);
                if (c.isError(D)) return D;
                c = D;
            }
            var H = c.offset;
            if (p.use === null && p.choice === null) {
                if (p.any) var N = c.save();
                var K = this._decodeTag(c, p.implicit !== null ? p.implicit : p.tag, p.any);
                if (c.isError(K)) return K;
                p.any ? y = c.raw(N) : c = K;
            }
            if (l && l.track && p.tag !== null && l.track(c.path(), H, c.length, "tagged"), l && l.track && p.tag !== null && l.track(c.path(), c.offset, c.length, "content"), p.any ? y = y : p.choice === null ? y = this._decodeGeneric(p.tag, c, l) : y = this._decodeChoice(c, l), c.isError(y)) return y;
            if (!p.any && p.choice === null && p.children !== null && p.children.forEach(function(G) {
                G._decode(c, l);
            }), p.contains && (p.tag === "octstr" || p.tag === "bitstr")) {
                var re = new r(y);
                y = this._getUse(p.contains, c._reporterState.obj)._decode(re, l);
            }
        }
        return p.obj && _ && (y = c.leaveObject(U)), p.key !== null && (y !== null || _ === !0) ? c.leaveKey(A, p.key, y) : A !== null && c.exitKey(A), y;
    }, a.prototype._decodeGeneric = function(c, l, p) {
        var y = this._baseState;
        return c === "seq" || c === "set" ? null : c === "seqof" || c === "setof" ? this._decodeList(l, c, y.args[0], p) : /str$/.test(c) ? this._decodeStr(l, c, p) : c === "objid" && y.args ? this._decodeObjid(l, y.args[0], y.args[1], p) : c === "objid" ? this._decodeObjid(l, null, null, p) : c === "gentime" || c === "utctime" ? this._decodeTime(l, c, p) : c === "null_" ? this._decodeNull(l, p) : c === "bool" ? this._decodeBool(l, p) : c === "objDesc" ? this._decodeStr(l, c, p) : c === "int" || c === "enum" ? this._decodeInt(l, y.args && y.args[0], p) : y.use !== null ? this._getUse(y.use, l._reporterState.obj)._decode(l, p) : l.error("unknown tag: " + c);
    }, a.prototype._getUse = function(c, l) {
        var p = this._baseState;
        return p.useDecoder = this._use(c, l), n(p.useDecoder._baseState.parent === null), p.useDecoder = p.useDecoder._baseState.children[0], p.implicit !== p.useDecoder._baseState.implicit && (p.useDecoder = p.useDecoder.clone(), p.useDecoder._baseState.implicit = p.implicit), p.useDecoder;
    }, a.prototype._decodeChoice = function(c, l) {
        var p = this._baseState, y = null, _ = !1;
        return Object.keys(p.choice).some(function(A) {
            var O = c.save(), N = p.choice[A];
            try {
                var U = N._decode(c, l);
                if (c.isError(U)) return !1;
                y = {
                    type: A,
                    value: U
                }, _ = !0;
            } catch  {
                return c.restore(O), !1;
            }
            return !0;
        }, this), _ ? y : c.error("Choice not matched");
    }, a.prototype._createEncoderBuffer = function(c) {
        return new t(c, this.reporter);
    }, a.prototype._encode = function(c, l, p) {
        var y = this._baseState;
        if (!(y.default !== null && y.default === c)) {
            var _ = this._encodeValue(c, l, p);
            if (_ !== void 0 && !this._skipDefault(_, l, p)) return _;
        }
    }, a.prototype._encodeValue = function(c, l, p) {
        var y = this._baseState;
        if (y.parent === null) return y.children[0]._encode(c, l || new e());
        var N = null;
        if (this.reporter = l, y.optional && c === void 0) if (y.default !== null) c = y.default;
        else return;
        var _ = null, A = !1;
        if (y.any) N = this._createEncoderBuffer(c);
        else if (y.choice) N = this._encodeChoice(c, l);
        else if (y.contains) _ = this._getUse(y.contains, p)._encode(c, l), A = !0;
        else if (y.children) _ = y.children.map(function(H) {
            if (H._baseState.tag === "null_") return H._encode(null, l, c);
            if (H._baseState.key === null) return l.error("Child should have a key");
            var K = l.enterKey(H._baseState.key);
            if (typeof c != "object") return l.error("Child expected, but input is not object");
            var re = H._encode(c[H._baseState.key], l, c);
            return l.leaveKey(K), re;
        }, this).filter(function(H) {
            return H;
        }), _ = this._createEncoderBuffer(_);
        else if (y.tag === "seqof" || y.tag === "setof") {
            if (!(y.args && y.args.length === 1)) return l.error("Too many args for : " + y.tag);
            if (!Array.isArray(c)) return l.error("seqof/setof, but data is not Array");
            var O = this.clone();
            O._baseState.implicit = null, _ = this._createEncoderBuffer(c.map(function(H) {
                var K = this._baseState;
                return this._getUse(K.args[0], c)._encode(H, l);
            }, O));
        } else y.use !== null ? N = this._getUse(y.use, p)._encode(c, l) : (_ = this._encodePrimitive(y.tag, c), A = !0);
        var N;
        if (!y.any && y.choice === null) {
            var U = y.implicit !== null ? y.implicit : y.tag, D = y.implicit === null ? "universal" : "context";
            U === null ? y.use === null && l.error("Tag could be omitted only for .use()") : y.use === null && (N = this._encodeComposite(U, A, D, _));
        }
        return y.explicit !== null && (N = this._encodeComposite(y.explicit, !1, "context", N)), N;
    }, a.prototype._encodeChoice = function(c, l) {
        var p = this._baseState, y = p.choice[c.type];
        return y || n(!1, c.type + " not found in " + JSON.stringify(Object.keys(p.choice))), y._encode(c.value, l);
    }, a.prototype._encodePrimitive = function(c, l) {
        var p = this._baseState;
        if (/str$/.test(c)) return this._encodeStr(l, c);
        if (c === "objid" && p.args) return this._encodeObjid(l, p.reverseArgs[0], p.args[1]);
        if (c === "objid") return this._encodeObjid(l, null, null);
        if (c === "gentime" || c === "utctime") return this._encodeTime(l, c);
        if (c === "null_") return this._encodeNull();
        if (c === "int" || c === "enum") return this._encodeInt(l, p.args && p.reverseArgs[0]);
        if (c === "bool") return this._encodeBool(l);
        if (c === "objDesc") return this._encodeStr(l, c);
        throw new Error("Unsupported tag: " + c);
    }, a.prototype._isNumstr = function(c) {
        return /^[0-9 ]*$/.test(c);
    }, a.prototype._isPrintstr = function(c) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(c);
    }, F2;
}
var AT;
function Dh() {
    return AT || (AT = 1, function(e) {
        var t = e;
        t.Reporter = MX().Reporter, t.DecoderBuffer = xT().DecoderBuffer, t.EncoderBuffer = xT().EncoderBuffer, t.Node = RX();
    }(L2)), L2;
}
var z2 = {}, j2 = {}, TT;
function CX() {
    return TT || (TT = 1, function(e) {
        var t = MO();
        e.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        }, e.tagByName = t._reverse(e.tag);
    }(j2)), j2;
}
var kT;
function MO() {
    return kT || (kT = 1, function(e) {
        var t = e;
        t._reverse = function(n) {
            var i = {};
            return Object.keys(n).forEach(function(o) {
                (o | 0) == o && (o = o | 0);
                var s = n[o];
                i[s] = o;
            }), i;
        }, t.der = CX();
    }(z2)), z2;
}
var H2 = {}, q2, IT;
function RO() {
    if (IT) return q2;
    IT = 1;
    var e = Or(), t = a0(), r = t.base, n = t.bignum, i = t.constants.der;
    function o(f) {
        this.enc = "der", this.name = f.name, this.entity = f, this.tree = new s(), this.tree._init(f.body);
    }
    q2 = o, o.prototype.decode = function(c, l) {
        return c instanceof r.DecoderBuffer || (c = new r.DecoderBuffer(c, l)), this.tree._decode(c, l);
    };
    function s(f) {
        r.Node.call(this, "der", f);
    }
    e(s, r.Node), s.prototype._peekTag = function(c, l, p) {
        if (c.isEmpty()) return !1;
        var y = c.save(), _ = a(c, 'Failed to peek tag: "' + l + '"');
        return c.isError(_) ? _ : (c.restore(y), _.tag === l || _.tagStr === l || _.tagStr + "of" === l || p);
    }, s.prototype._decodeTag = function(c, l, p) {
        var y = a(c, 'Failed to decode tag of "' + l + '"');
        if (c.isError(y)) return y;
        var _ = u(c, y.primitive, 'Failed to get length of "' + l + '"');
        if (c.isError(_)) return _;
        if (!p && y.tag !== l && y.tagStr !== l && y.tagStr + "of" !== l) return c.error('Failed to match tag: "' + l + '"');
        if (y.primitive || _ !== null) return c.skip(_, 'Failed to match body of: "' + l + '"');
        var A = c.save(), O = this._skipUntilEnd(c, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return c.isError(O) ? O : (_ = c.offset - A.offset, c.restore(A), c.skip(_, 'Failed to match body of: "' + l + '"'));
    }, s.prototype._skipUntilEnd = function(c, l) {
        for(;;){
            var p = a(c, l);
            if (c.isError(p)) return p;
            var y = u(c, p.primitive, l);
            if (c.isError(y)) return y;
            var _;
            if (p.primitive || y !== null ? _ = c.skip(y) : _ = this._skipUntilEnd(c, l), c.isError(_)) return _;
            if (p.tagStr === "end") break;
        }
    }, s.prototype._decodeList = function(c, l, p, y) {
        for(var _ = []; !c.isEmpty();){
            var A = this._peekTag(c, "end");
            if (c.isError(A)) return A;
            var O = p.decode(c, "der", y);
            if (c.isError(O) && A) break;
            _.push(O);
        }
        return _;
    }, s.prototype._decodeStr = function(c, l) {
        if (l === "bitstr") {
            var p = c.readUInt8();
            return c.isError(p) ? p : {
                unused: p,
                data: c.raw()
            };
        } else if (l === "bmpstr") {
            var y = c.raw();
            if (y.length % 2 === 1) return c.error("Decoding of string type: bmpstr length mismatch");
            for(var _ = "", A = 0; A < y.length / 2; A++)_ += String.fromCharCode(y.readUInt16BE(A * 2));
            return _;
        } else if (l === "numstr") {
            var O = c.raw().toString("ascii");
            return this._isNumstr(O) ? O : c.error("Decoding of string type: numstr unsupported characters");
        } else {
            if (l === "octstr") return c.raw();
            if (l === "objDesc") return c.raw();
            if (l === "printstr") {
                var N = c.raw().toString("ascii");
                return this._isPrintstr(N) ? N : c.error("Decoding of string type: printstr unsupported characters");
            } else return /str$/.test(l) ? c.raw().toString() : c.error("Decoding of string type: " + l + " unsupported");
        }
    }, s.prototype._decodeObjid = function(c, l, p) {
        for(var y, _ = [], A = 0; !c.isEmpty();){
            var O = c.readUInt8();
            A <<= 7, A |= O & 127, O & 128 || (_.push(A), A = 0);
        }
        O & 128 && _.push(A);
        var N = _[0] / 40 | 0, U = _[0] % 40;
        if (p ? y = _ : y = [
            N,
            U
        ].concat(_.slice(1)), l) {
            var D = l[y.join(" ")];
            D === void 0 && (D = l[y.join(".")]), D !== void 0 && (y = D);
        }
        return y;
    }, s.prototype._decodeTime = function(c, l) {
        var p = c.raw().toString();
        if (l === "gentime") var y = p.slice(0, 4) | 0, _ = p.slice(4, 6) | 0, A = p.slice(6, 8) | 0, O = p.slice(8, 10) | 0, N = p.slice(10, 12) | 0, U = p.slice(12, 14) | 0;
        else if (l === "utctime") {
            var y = p.slice(0, 2) | 0, _ = p.slice(2, 4) | 0, A = p.slice(4, 6) | 0, O = p.slice(6, 8) | 0, N = p.slice(8, 10) | 0, U = p.slice(10, 12) | 0;
            y < 70 ? y = 2e3 + y : y = 1900 + y;
        } else return c.error("Decoding " + l + " time is not supported yet");
        return Date.UTC(y, _ - 1, A, O, N, U, 0);
    }, s.prototype._decodeNull = function(c) {
        return null;
    }, s.prototype._decodeBool = function(c) {
        var l = c.readUInt8();
        return c.isError(l) ? l : l !== 0;
    }, s.prototype._decodeInt = function(c, l) {
        var p = c.raw(), y = new n(p);
        return l && (y = l[y.toString(10)] || y), y;
    }, s.prototype._use = function(c, l) {
        return typeof c == "function" && (c = c(l)), c._getDecoder("der").tree;
    };
    function a(f, c) {
        var l = f.readUInt8(c);
        if (f.isError(l)) return l;
        var p = i.tagClass[l >> 6], y = (l & 32) === 0;
        if ((l & 31) === 31) {
            var _ = l;
            for(l = 0; (_ & 128) === 128;){
                if (_ = f.readUInt8(c), f.isError(_)) return _;
                l <<= 7, l |= _ & 127;
            }
        } else l &= 31;
        var A = i.tag[l];
        return {
            cls: p,
            primitive: y,
            tag: l,
            tagStr: A
        };
    }
    function u(f, c, l) {
        var p = f.readUInt8(l);
        if (f.isError(p)) return p;
        if (!c && p === 128) return null;
        if (!(p & 128)) return p;
        var y = p & 127;
        if (y > 4) return f.error("length octect is too long");
        p = 0;
        for(var _ = 0; _ < y; _++){
            p <<= 8;
            var A = f.readUInt8(l);
            if (f.isError(A)) return A;
            p |= A;
        }
        return p;
    }
    return q2;
}
var K2, BT;
function UX() {
    if (BT) return K2;
    BT = 1;
    var e = Or(), t = ku.Buffer, r = RO();
    function n(i) {
        r.call(this, i), this.enc = "pem";
    }
    return e(n, r), K2 = n, n.prototype.decode = function(o, s) {
        for(var a = o.toString().split(/[\r\n]+/g), u = s.label.toUpperCase(), f = /^-----(BEGIN|END) ([^-]+)-----$/, c = -1, l = -1, p = 0; p < a.length; p++){
            var y = a[p].match(f);
            if (y !== null && y[2] === u) if (c === -1) {
                if (y[1] !== "BEGIN") break;
                c = p;
            } else {
                if (y[1] !== "END") break;
                l = p;
                break;
            }
        }
        if (c === -1 || l === -1) throw new Error("PEM section not found for: " + u);
        var _ = a.slice(c + 1, l).join("");
        _.replace(/[^a-z0-9\+\/=]+/gi, "");
        var A = new t(_, "base64");
        return r.prototype.decode.call(this, A, s);
    }, K2;
}
var OT;
function $X() {
    return OT || (OT = 1, function(e) {
        var t = e;
        t.der = RO(), t.pem = UX();
    }(H2)), H2;
}
var W2 = {}, V2, PT;
function CO() {
    if (PT) return V2;
    PT = 1;
    var e = Or(), t = ku.Buffer, r = a0(), n = r.base, i = r.constants.der;
    function o(f) {
        this.enc = "der", this.name = f.name, this.entity = f, this.tree = new s(), this.tree._init(f.body);
    }
    V2 = o, o.prototype.encode = function(c, l) {
        return this.tree._encode(c, l).join();
    };
    function s(f) {
        n.Node.call(this, "der", f);
    }
    e(s, n.Node), s.prototype._encodeComposite = function(c, l, p, y) {
        var _ = u(c, l, p, this.reporter);
        if (y.length < 128) {
            var N = new t(2);
            return N[0] = _, N[1] = y.length, this._createEncoderBuffer([
                N,
                y
            ]);
        }
        for(var A = 1, O = y.length; O >= 256; O >>= 8)A++;
        var N = new t(2 + A);
        N[0] = _, N[1] = 128 | A;
        for(var O = 1 + A, U = y.length; U > 0; O--, U >>= 8)N[O] = U & 255;
        return this._createEncoderBuffer([
            N,
            y
        ]);
    }, s.prototype._encodeStr = function(c, l) {
        if (l === "bitstr") return this._createEncoderBuffer([
            c.unused | 0,
            c.data
        ]);
        if (l === "bmpstr") {
            for(var p = new t(c.length * 2), y = 0; y < c.length; y++)p.writeUInt16BE(c.charCodeAt(y), y * 2);
            return this._createEncoderBuffer(p);
        } else return l === "numstr" ? this._isNumstr(c) ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : l === "printstr" ? this._isPrintstr(c) ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(l) ? this._createEncoderBuffer(c) : l === "objDesc" ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: " + l + " unsupported");
    }, s.prototype._encodeObjid = function(c, l, p) {
        if (typeof c == "string") {
            if (!l) return this.reporter.error("string objid given, but no values map found");
            if (!l.hasOwnProperty(c)) return this.reporter.error("objid not found in values map");
            c = l[c].split(/[\s\.]+/g);
            for(var y = 0; y < c.length; y++)c[y] |= 0;
        } else if (Array.isArray(c)) {
            c = c.slice();
            for(var y = 0; y < c.length; y++)c[y] |= 0;
        }
        if (!Array.isArray(c)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(c));
        if (!p) {
            if (c[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            c.splice(0, 2, c[0] * 40 + c[1]);
        }
        for(var _ = 0, y = 0; y < c.length; y++){
            var A = c[y];
            for(_++; A >= 128; A >>= 7)_++;
        }
        for(var O = new t(_), N = O.length - 1, y = c.length - 1; y >= 0; y--){
            var A = c[y];
            for(O[N--] = A & 127; (A >>= 7) > 0;)O[N--] = 128 | A & 127;
        }
        return this._createEncoderBuffer(O);
    };
    function a(f) {
        return f < 10 ? "0" + f : f;
    }
    s.prototype._encodeTime = function(c, l) {
        var p, y = new Date(c);
        return l === "gentime" ? p = [
            a(y.getFullYear()),
            a(y.getUTCMonth() + 1),
            a(y.getUTCDate()),
            a(y.getUTCHours()),
            a(y.getUTCMinutes()),
            a(y.getUTCSeconds()),
            "Z"
        ].join("") : l === "utctime" ? p = [
            a(y.getFullYear() % 100),
            a(y.getUTCMonth() + 1),
            a(y.getUTCDate()),
            a(y.getUTCHours()),
            a(y.getUTCMinutes()),
            a(y.getUTCSeconds()),
            "Z"
        ].join("") : this.reporter.error("Encoding " + l + " time is not supported yet"), this._encodeStr(p, "octstr");
    }, s.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
    }, s.prototype._encodeInt = function(c, l) {
        if (typeof c == "string") {
            if (!l) return this.reporter.error("String int or enum given, but no values map");
            if (!l.hasOwnProperty(c)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(c));
            c = l[c];
        }
        if (typeof c != "number" && !t.isBuffer(c)) {
            var p = c.toArray();
            !c.sign && p[0] & 128 && p.unshift(0), c = new t(p);
        }
        if (t.isBuffer(c)) {
            var y = c.length;
            c.length === 0 && y++;
            var A = new t(y);
            return c.copy(A), c.length === 0 && (A[0] = 0), this._createEncoderBuffer(A);
        }
        if (c < 128) return this._createEncoderBuffer(c);
        if (c < 256) return this._createEncoderBuffer([
            0,
            c
        ]);
        for(var y = 1, _ = c; _ >= 256; _ >>= 8)y++;
        for(var A = new Array(y), _ = A.length - 1; _ >= 0; _--)A[_] = c & 255, c >>= 8;
        return A[0] & 128 && A.unshift(0), this._createEncoderBuffer(new t(A));
    }, s.prototype._encodeBool = function(c) {
        return this._createEncoderBuffer(c ? 255 : 0);
    }, s.prototype._use = function(c, l) {
        return typeof c == "function" && (c = c(l)), c._getEncoder("der").tree;
    }, s.prototype._skipDefault = function(c, l, p) {
        var y = this._baseState, _;
        if (y.default === null) return !1;
        var A = c.join();
        if (y.defaultBuffer === void 0 && (y.defaultBuffer = this._encodeValue(y.default, l, p).join()), A.length !== y.defaultBuffer.length) return !1;
        for(_ = 0; _ < A.length; _++)if (A[_] !== y.defaultBuffer[_]) return !1;
        return !0;
    };
    function u(f, c, l, p) {
        var y;
        if (f === "seqof" ? f = "seq" : f === "setof" && (f = "set"), i.tagByName.hasOwnProperty(f)) y = i.tagByName[f];
        else if (typeof f == "number" && (f | 0) === f) y = f;
        else return p.error("Unknown tag: " + f);
        return y >= 31 ? p.error("Multi-octet tag encoding unsupported") : (c || (y |= 32), y |= i.tagClassByName[l || "universal"] << 6, y);
    }
    return V2;
}
var G2, NT;
function LX() {
    if (NT) return G2;
    NT = 1;
    var e = Or(), t = CO();
    function r(n) {
        t.call(this, n), this.enc = "pem";
    }
    return e(r, t), G2 = r, r.prototype.encode = function(i, o) {
        for(var s = t.prototype.encode.call(this, i), a = s.toString("base64"), u = [
            "-----BEGIN " + o.label + "-----"
        ], f = 0; f < a.length; f += 64)u.push(a.slice(f, f + 64));
        return u.push("-----END " + o.label + "-----"), u.join(`
`);
    }, G2;
}
var MT;
function DX() {
    return MT || (MT = 1, function(e) {
        var t = e;
        t.der = CO(), t.pem = LX();
    }(W2)), W2;
}
var RT;
function a0() {
    return RT || (RT = 1, function(e) {
        var t = e;
        t.bignum = bi(), t.define = NX().define, t.base = Dh(), t.constants = MO(), t.decoders = $X(), t.encoders = DX();
    }(U2)), U2;
}
var Z2, CT;
function FX() {
    if (CT) return Z2;
    CT = 1;
    var e = a0(), t = e.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        });
    }), r = e.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), i = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr());
    }), o = e.define("RelativeDistinguishedName", function() {
        this.setof(r);
    }), s = e.define("RDNSequence", function() {
        this.seqof(o);
    }), a = e.define("Name", function() {
        this.choice({
            rdnSequence: this.use(s)
        });
    }), u = e.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(t), this.key("notAfter").use(t));
    }), f = e.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
    }), c = e.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(n), this.key("issuer").use(a), this.key("validity").use(u), this.key("subject").use(a), this.key("subjectPublicKeyInfo").use(i), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(f).optional());
    }), l = e.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(c), this.key("signatureAlgorithm").use(n), this.key("signatureValue").bitstr());
    });
    return Z2 = l, Z2;
}
var UT;
function zX() {
    if (UT) return Xo;
    UT = 1;
    var e = a0();
    Xo.certificate = FX();
    var t = e.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Xo.RSAPrivateKey = t;
    var r = e.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Xo.RSAPublicKey = r;
    var n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), i = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr());
    });
    Xo.PublicKey = i;
    var o = e.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(n), this.key("subjectPrivateKey").octstr());
    });
    Xo.PrivateKey = o;
    var s = e.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Xo.EncryptedPrivateKey = s;
    var a = e.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Xo.DSAPrivateKey = a, Xo.DSAparam = e.define("DSAparam", function() {
        this.int();
    });
    var u = e.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        });
    }), f = e.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(u), this.key("publicKey").optional().explicit(1).bitstr());
    });
    return Xo.ECPrivateKey = f, Xo.signature = e.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
    }), Xo;
}
const jX = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var Y2, $T;
function HX() {
    if ($T) return Y2;
    $T = 1;
    var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, n = xb(), i = $3(), o = Ar().Buffer;
    return Y2 = function(s, a) {
        var u = s.toString(), f = u.match(e), c;
        if (f) {
            var p = "aes" + f[1], y = o.from(f[2], "hex"), _ = o.from(f[3].replace(/[\r\n]/g, ""), "base64"), A = n(a, y.slice(0, 8), parseInt(f[1], 10)).key, O = [], N = i.createDecipheriv(p, A, y);
            O.push(N.update(_)), O.push(N.final()), c = o.concat(O);
        } else {
            var l = u.match(r);
            c = o.from(l[2].replace(/[\r\n]/g, ""), "base64");
        }
        var U = u.match(t)[1];
        return {
            tag: U,
            data: c
        };
    }, Y2;
}
var X2, LT;
function kb() {
    if (LT) return X2;
    LT = 1;
    var e = zX(), t = jX, r = HX(), n = $3(), i = hO(), o = Ar().Buffer;
    function s(u, f) {
        var c = u.algorithm.decrypt.kde.kdeparams.salt, l = parseInt(u.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), p = t[u.algorithm.decrypt.cipher.algo.join(".")], y = u.algorithm.decrypt.cipher.iv, _ = u.subjectPrivateKey, A = parseInt(p.split("-")[1], 10) / 8, O = i.pbkdf2Sync(f, c, l, A, "sha1"), N = n.createDecipheriv(p, O, y), U = [];
        return U.push(N.update(_)), U.push(N.final()), o.concat(U);
    }
    function a(u) {
        var f;
        typeof u == "object" && !o.isBuffer(u) && (f = u.passphrase, u = u.key), typeof u == "string" && (u = o.from(u));
        var c = r(u, f), l = c.tag, p = c.data, y, _;
        switch(l){
            case "CERTIFICATE":
                _ = e.certificate.decode(p, "der").tbsCertificate.subjectPublicKeyInfo;
            case "PUBLIC KEY":
                switch(_ || (_ = e.PublicKey.decode(p, "der")), y = _.algorithm.algorithm.join("."), y){
                    case "1.2.840.113549.1.1.1":
                        return e.RSAPublicKey.decode(_.subjectPublicKey.data, "der");
                    case "1.2.840.10045.2.1":
                        return _.subjectPrivateKey = _.subjectPublicKey, {
                            type: "ec",
                            data: _
                        };
                    case "1.2.840.10040.4.1":
                        return _.algorithm.params.pub_key = e.DSAparam.decode(_.subjectPublicKey.data, "der"), {
                            type: "dsa",
                            data: _.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + y);
                }
            case "ENCRYPTED PRIVATE KEY":
                p = e.EncryptedPrivateKey.decode(p, "der"), p = s(p, f);
            case "PRIVATE KEY":
                switch(_ = e.PrivateKey.decode(p, "der"), y = _.algorithm.algorithm.join("."), y){
                    case "1.2.840.113549.1.1.1":
                        return e.RSAPrivateKey.decode(_.subjectPrivateKey, "der");
                    case "1.2.840.10045.2.1":
                        return {
                            curve: _.algorithm.curve,
                            privateKey: e.ECPrivateKey.decode(_.subjectPrivateKey, "der").privateKey
                        };
                    case "1.2.840.10040.4.1":
                        return _.algorithm.params.priv_key = e.DSAparam.decode(_.subjectPrivateKey, "der"), {
                            type: "dsa",
                            params: _.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + y);
                }
            case "RSA PUBLIC KEY":
                return e.RSAPublicKey.decode(p, "der");
            case "RSA PRIVATE KEY":
                return e.RSAPrivateKey.decode(p, "der");
            case "DSA PRIVATE KEY":
                return {
                    type: "dsa",
                    params: e.DSAPrivateKey.decode(p, "der")
                };
            case "EC PRIVATE KEY":
                return p = e.ECPrivateKey.decode(p, "der"), {
                    curve: p.parameters.value,
                    privateKey: p.privateKey
                };
            default:
                throw new Error("unknown key type " + l);
        }
    }
    return a.signature = e.signature, X2 = a, X2;
}
const UO = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var DT;
function qX() {
    if (DT) return dh.exports;
    DT = 1;
    var e = Ar().Buffer, t = aO(), r = F3(), n = H3().ec, i = D3(), o = kb(), s = UO, a = 1;
    function u(N, U, D, H, K) {
        var re = o(U);
        if (re.curve) {
            if (H !== "ecdsa" && H !== "ecdsa/rsa") throw new Error("wrong private key type");
            return f(N, re);
        } else if (re.type === "dsa") {
            if (H !== "dsa") throw new Error("wrong private key type");
            return c(N, re, D);
        }
        if (H !== "rsa" && H !== "ecdsa/rsa") throw new Error("wrong private key type");
        if (U.padding !== void 0 && U.padding !== a) throw new Error("illegal or unsupported padding mode");
        N = e.concat([
            K,
            N
        ]);
        for(var Q = re.modulus.byteLength(), G = [
            0,
            1
        ]; N.length + G.length + 1 < Q;)G.push(255);
        G.push(0);
        for(var R = -1; ++R < N.length;)G.push(N[R]);
        var X = r(G, re);
        return X;
    }
    function f(N, U) {
        var D = s[U.curve.join(".")];
        if (!D) throw new Error("unknown curve " + U.curve.join("."));
        var H = new n(D), K = H.keyFromPrivate(U.privateKey), re = K.sign(N);
        return e.from(re.toDER());
    }
    function c(N, U, D) {
        for(var H = U.params.priv_key, K = U.params.p, re = U.params.q, Q = U.params.g, G = new i(0), R, X = y(N, re).mod(re), $ = !1, S = p(H, re, N, D); $ === !1;)R = A(re, S, D), G = O(Q, R, K, re), $ = R.invm(re).imul(X.add(H.mul(G))).mod(re), $.cmpn(0) === 0 && ($ = !1, G = new i(0));
        return l(G, $);
    }
    function l(N, U) {
        N = N.toArray(), U = U.toArray(), N[0] & 128 && (N = [
            0
        ].concat(N)), U[0] & 128 && (U = [
            0
        ].concat(U));
        var D = N.length + U.length + 4, H = [
            48,
            D,
            2,
            N.length
        ];
        return H = H.concat(N, [
            2,
            U.length
        ], U), e.from(H);
    }
    function p(N, U, D, H) {
        if (N = e.from(N.toArray()), N.length < U.byteLength()) {
            var K = e.alloc(U.byteLength() - N.length);
            N = e.concat([
                K,
                N
            ]);
        }
        var re = D.length, Q = _(D, U), G = e.alloc(re);
        G.fill(1);
        var R = e.alloc(re);
        return R = t(H, R).update(G).update(e.from([
            0
        ])).update(N).update(Q).digest(), G = t(H, R).update(G).digest(), R = t(H, R).update(G).update(e.from([
            1
        ])).update(N).update(Q).digest(), G = t(H, R).update(G).digest(), {
            k: R,
            v: G
        };
    }
    function y(N, U) {
        var D = new i(N), H = (N.length << 3) - U.bitLength();
        return H > 0 && D.ishrn(H), D;
    }
    function _(N, U) {
        N = y(N, U), N = N.mod(U);
        var D = e.from(N.toArray());
        if (D.length < U.byteLength()) {
            var H = e.alloc(U.byteLength() - D.length);
            D = e.concat([
                H,
                D
            ]);
        }
        return D;
    }
    function A(N, U, D) {
        var H, K;
        do {
            for(H = e.alloc(0); H.length * 8 < N.bitLength();)U.v = t(D, U.k).update(U.v).digest(), H = e.concat([
                H,
                U.v
            ]);
            K = y(H, N), U.k = t(D, U.k).update(U.v).update(e.from([
                0
            ])).digest(), U.v = t(D, U.k).update(U.v).digest();
        }while (K.cmp(N) !== -1)
        return K;
    }
    function O(N, U, D, H) {
        return N.toRed(i.mont(D)).redPow(U).fromRed().mod(H);
    }
    return dh.exports = u, dh.exports.getKey = p, dh.exports.makeKey = A, dh.exports;
}
var J2, FT;
function KX() {
    if (FT) return J2;
    FT = 1;
    var e = Ar().Buffer, t = D3(), r = H3().ec, n = kb(), i = UO;
    function o(f, c, l, p, y) {
        var _ = n(l);
        if (_.type === "ec") {
            if (p !== "ecdsa" && p !== "ecdsa/rsa") throw new Error("wrong public key type");
            return s(f, c, _);
        } else if (_.type === "dsa") {
            if (p !== "dsa") throw new Error("wrong public key type");
            return a(f, c, _);
        }
        if (p !== "rsa" && p !== "ecdsa/rsa") throw new Error("wrong public key type");
        c = e.concat([
            y,
            c
        ]);
        for(var A = _.modulus.byteLength(), O = [
            1
        ], N = 0; c.length + O.length + 2 < A;)O.push(255), N += 1;
        O.push(0);
        for(var U = -1; ++U < c.length;)O.push(c[U]);
        O = e.from(O);
        var D = t.mont(_.modulus);
        f = new t(f).toRed(D), f = f.redPow(new t(_.publicExponent)), f = e.from(f.fromRed().toArray());
        var H = N < 8 ? 1 : 0;
        for(A = Math.min(f.length, O.length), f.length !== O.length && (H = 1), U = -1; ++U < A;)H |= f[U] ^ O[U];
        return H === 0;
    }
    function s(f, c, l) {
        var p = i[l.data.algorithm.curve.join(".")];
        if (!p) throw new Error("unknown curve " + l.data.algorithm.curve.join("."));
        var y = new r(p), _ = l.data.subjectPrivateKey.data;
        return y.verify(c, f, _);
    }
    function a(f, c, l) {
        var p = l.data.p, y = l.data.q, _ = l.data.g, A = l.data.pub_key, O = n.signature.decode(f, "der"), N = O.s, U = O.r;
        u(N, y), u(U, y);
        var D = t.mont(p), H = N.invm(y), K = _.toRed(D).redPow(new t(c).mul(H).mod(y)).fromRed().mul(A.toRed(D).redPow(U.mul(H).mod(y)).fromRed()).mod(p).mod(y);
        return K.cmp(U) === 0;
    }
    function u(f, c) {
        if (f.cmpn(0) <= 0) throw new Error("invalid sig");
        if (f.cmp(c) >= 0) throw new Error("invalid sig");
    }
    return J2 = o, J2;
}
var Q2, zT;
function WX() {
    if (zT) return Q2;
    zT = 1;
    var e = Ar().Buffer, t = n0(), r = dX(), n = Or(), i = qX(), o = KX(), s = cO;
    Object.keys(s).forEach(function(l) {
        s[l].id = e.from(s[l].id, "hex"), s[l.toLowerCase()] = s[l];
    });
    function a(l) {
        r.Writable.call(this);
        var p = s[l];
        if (!p) throw new Error("Unknown message digest");
        this._hashType = p.hash, this._hash = t(p.hash), this._tag = p.id, this._signType = p.sign;
    }
    n(a, r.Writable), a.prototype._write = function(p, y, _) {
        this._hash.update(p), _();
    }, a.prototype.update = function(p, y) {
        return this._hash.update(typeof p == "string" ? e.from(p, y) : p), this;
    }, a.prototype.sign = function(p, y) {
        this.end();
        var _ = this._hash.digest(), A = i(_, p, this._hashType, this._signType, this._tag);
        return y ? A.toString(y) : A;
    };
    function u(l) {
        r.Writable.call(this);
        var p = s[l];
        if (!p) throw new Error("Unknown message digest");
        this._hash = t(p.hash), this._tag = p.id, this._signType = p.sign;
    }
    n(u, r.Writable), u.prototype._write = function(p, y, _) {
        this._hash.update(p), _();
    }, u.prototype.update = function(p, y) {
        return this._hash.update(typeof p == "string" ? e.from(p, y) : p), this;
    }, u.prototype.verify = function(p, y, _) {
        var A = typeof y == "string" ? e.from(y, _) : y;
        this.end();
        var O = this._hash.digest();
        return o(A, O, p, this._signType, this._tag);
    };
    function f(l) {
        return new a(l);
    }
    function c(l) {
        return new u(l);
    }
    return Q2 = {
        Sign: f,
        Verify: c,
        createSign: f,
        createVerify: c
    }, Q2;
}
var e_, jT;
function VX() {
    if (jT) return e_;
    jT = 1;
    var e = H3(), t = bi();
    e_ = function(s) {
        return new n(s);
    };
    var r = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
    function n(o) {
        this.curveType = r[o], this.curveType || (this.curveType = {
            name: o
        }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
    }
    n.prototype.generateKeys = function(o, s) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(o, s);
    }, n.prototype.computeSecret = function(o, s, a) {
        s = s || "utf8", We.isBuffer(o) || (o = new We(o, s));
        var u = this.curve.keyFromPublic(o).getPublic(), f = u.mul(this.keys.getPrivate()).getX();
        return i(f, a, this.curveType.byteLength);
    }, n.prototype.getPublicKey = function(o, s) {
        var a = this.keys.getPublic(s === "compressed", !0);
        return s === "hybrid" && (a[a.length - 1] % 2 ? a[0] = 7 : a[0] = 6), i(a, o);
    }, n.prototype.getPrivateKey = function(o) {
        return i(this.keys.getPrivate(), o);
    }, n.prototype.setPublicKey = function(o, s) {
        return s = s || "utf8", We.isBuffer(o) || (o = new We(o, s)), this.keys._importPublic(o), this;
    }, n.prototype.setPrivateKey = function(o, s) {
        s = s || "utf8", We.isBuffer(o) || (o = new We(o, s));
        var a = new t(o);
        return a = a.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(a), this;
    };
    function i(o, s, a) {
        Array.isArray(o) || (o = o.toArray());
        var u = new We(o);
        if (a && u.length < a) {
            var f = new We(a - u.length);
            f.fill(0), u = We.concat([
                f,
                u
            ]);
        }
        return s ? u.toString(s) : u;
    }
    return e_;
}
var t_ = {}, r_, HT;
function $O() {
    if (HT) return r_;
    HT = 1;
    var e = n0(), t = Ar().Buffer;
    r_ = function(n, i) {
        for(var o = t.alloc(0), s = 0, a; o.length < i;)a = r(s++), o = t.concat([
            o,
            e("sha1").update(n).update(a).digest()
        ]);
        return o.slice(0, i);
    };
    function r(n) {
        var i = t.allocUnsafe(4);
        return i.writeUInt32BE(n, 0), i;
    }
    return r_;
}
var n_, qT;
function LO() {
    return qT || (qT = 1, n_ = function(t, r) {
        for(var n = t.length, i = -1; ++i < n;)t[i] ^= r[i];
        return t;
    }), n_;
}
var i_, KT;
function DO() {
    if (KT) return i_;
    KT = 1;
    var e = bi(), t = Ar().Buffer;
    function r(n, i) {
        return t.from(n.toRed(e.mont(i.modulus)).redPow(new e(i.publicExponent)).fromRed().toArray());
    }
    return i_ = r, i_;
}
var o_, WT;
function GX() {
    if (WT) return o_;
    WT = 1;
    var e = kb(), t = kd(), r = n0(), n = $O(), i = LO(), o = bi(), s = DO(), a = F3(), u = Ar().Buffer;
    o_ = function(y, _, A) {
        var O;
        y.padding ? O = y.padding : A ? O = 1 : O = 4;
        var N = e(y), U;
        if (O === 4) U = f(N, _);
        else if (O === 1) U = c(N, _, A);
        else if (O === 3) {
            if (U = new o(_), U.cmp(N.modulus) >= 0) throw new Error("data too long for modulus");
        } else throw new Error("unknown padding");
        return A ? a(U, N) : s(U, N);
    };
    function f(p, y) {
        var _ = p.modulus.byteLength(), A = y.length, O = r("sha1").update(u.alloc(0)).digest(), N = O.length, U = 2 * N;
        if (A > _ - U - 2) throw new Error("message too long");
        var D = u.alloc(_ - A - U - 2), H = _ - N - 1, K = t(N), re = i(u.concat([
            O,
            D,
            u.alloc(1, 1),
            y
        ], H), n(K, H)), Q = i(K, n(re, N));
        return new o(u.concat([
            u.alloc(1),
            Q,
            re
        ], _));
    }
    function c(p, y, _) {
        var A = y.length, O = p.modulus.byteLength();
        if (A > O - 11) throw new Error("message too long");
        var N;
        return _ ? N = u.alloc(O - A - 3, 255) : N = l(O - A - 3), new o(u.concat([
            u.from([
                0,
                _ ? 1 : 2
            ]),
            N,
            u.alloc(1),
            y
        ], O));
    }
    function l(p) {
        for(var y = u.allocUnsafe(p), _ = 0, A = t(p * 2), O = 0, N; _ < p;)O === A.length && (A = t(p * 2), O = 0), N = A[O++], N && (y[_++] = N);
        return y;
    }
    return o_;
}
var s_, VT;
function ZX() {
    if (VT) return s_;
    VT = 1;
    var e = kb(), t = $O(), r = LO(), n = bi(), i = F3(), o = n0(), s = DO(), a = Ar().Buffer;
    s_ = function(p, y, _) {
        var A;
        p.padding ? A = p.padding : _ ? A = 1 : A = 4;
        var O = e(p), N = O.modulus.byteLength();
        if (y.length > N || new n(y).cmp(O.modulus) >= 0) throw new Error("decryption error");
        var U;
        _ ? U = s(new n(y), O) : U = i(y, O);
        var D = a.alloc(N - U.length);
        if (U = a.concat([
            D,
            U
        ], N), A === 4) return u(O, U);
        if (A === 1) return f(O, U, _);
        if (A === 3) return U;
        throw new Error("unknown padding");
    };
    function u(l, p) {
        var y = l.modulus.byteLength(), _ = o("sha1").update(a.alloc(0)).digest(), A = _.length;
        if (p[0] !== 0) throw new Error("decryption error");
        var O = p.slice(1, A + 1), N = p.slice(A + 1), U = r(O, t(N, A)), D = r(N, t(U, y - A - 1));
        if (c(_, D.slice(0, A))) throw new Error("decryption error");
        for(var H = A; D[H] === 0;)H++;
        if (D[H++] !== 1) throw new Error("decryption error");
        return D.slice(H);
    }
    function f(l, p, y) {
        for(var _ = p.slice(0, 2), A = 2, O = 0; p[A++] !== 0;)if (A >= p.length) {
            O++;
            break;
        }
        var N = p.slice(2, A - 1);
        if ((_.toString("hex") !== "0002" && !y || _.toString("hex") !== "0001" && y) && O++, N.length < 8 && O++, O) throw new Error("decryption error");
        return p.slice(A);
    }
    function c(l, p) {
        l = a.from(l), p = a.from(p);
        var y = 0, _ = l.length;
        l.length !== p.length && (y++, _ = Math.min(l.length, p.length));
        for(var A = -1; ++A < _;)y += l[A] ^ p[A];
        return y;
    }
    return s_;
}
var GT;
function YX() {
    return GT || (GT = 1, function(e) {
        e.publicEncrypt = GX(), e.privateDecrypt = ZX(), e.privateEncrypt = function(r, n) {
            return e.publicEncrypt(r, n, !0);
        }, e.publicDecrypt = function(r, n) {
            return e.privateDecrypt(r, n, !0);
        };
    }(t_)), t_;
}
var hl = {}, ZT;
function XX() {
    if (ZT) return hl;
    ZT = 1;
    function e() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var t = Ar(), r = kd(), n = t.Buffer, i = t.kMaxLength, o = Ge.crypto || Ge.msCrypto, s = Math.pow(2, 32) - 1;
    function a(p, y) {
        if (typeof p != "number" || p !== p) throw new TypeError("offset must be a number");
        if (p > s || p < 0) throw new TypeError("offset must be a uint32");
        if (p > i || p > y) throw new RangeError("offset out of range");
    }
    function u(p, y, _) {
        if (typeof p != "number" || p !== p) throw new TypeError("size must be a number");
        if (p > s || p < 0) throw new TypeError("size must be a uint32");
        if (p + y > _ || p > i) throw new RangeError("buffer too small");
    }
    o && o.getRandomValues || !bn.browser ? (hl.randomFill = f, hl.randomFillSync = l) : (hl.randomFill = e, hl.randomFillSync = e);
    function f(p, y, _, A) {
        if (!n.isBuffer(p) && !(p instanceof Ge.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof y == "function") A = y, y = 0, _ = p.length;
        else if (typeof _ == "function") A = _, _ = p.length - y;
        else if (typeof A != "function") throw new TypeError('"cb" argument must be a function');
        return a(y, p.length), u(_, y, p.length), c(p, y, _, A);
    }
    function c(p, y, _, A) {
        if (bn.browser) {
            var O = p.buffer, N = new Uint8Array(O, y, _);
            if (o.getRandomValues(N), A) {
                bn.nextTick(function() {
                    A(null, p);
                });
                return;
            }
            return p;
        }
        if (A) {
            r(_, function(D, H) {
                if (D) return A(D);
                H.copy(p, y), A(null, p);
            });
            return;
        }
        var U = r(_);
        return U.copy(p, y), p;
    }
    function l(p, y, _) {
        if (typeof y > "u" && (y = 0), !n.isBuffer(p) && !(p instanceof Ge.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return a(y, p.length), _ === void 0 && (_ = p.length - y), u(_, y, p.length), c(p, y, _);
    }
    return hl;
}
var YT;
function q3() {
    if (YT) return gr;
    YT = 1, gr.randomBytes = gr.rng = gr.pseudoRandomBytes = gr.prng = kd(), gr.createHash = gr.Hash = n0(), gr.createHmac = gr.Hmac = aO();
    var e = PY(), t = Object.keys(e), r = [
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "md5",
        "rmd160"
    ].concat(t);
    gr.getHashes = function() {
        return r;
    };
    var n = hO();
    gr.pbkdf2 = n.pbkdf2, gr.pbkdf2Sync = n.pbkdf2Sync;
    var i = YY();
    gr.Cipher = i.Cipher, gr.createCipher = i.createCipher, gr.Cipheriv = i.Cipheriv, gr.createCipheriv = i.createCipheriv, gr.Decipher = i.Decipher, gr.createDecipher = i.createDecipher, gr.Decipheriv = i.Decipheriv, gr.createDecipheriv = i.createDecipheriv, gr.getCiphers = i.getCiphers, gr.listCiphers = i.listCiphers;
    var o = aX();
    gr.DiffieHellmanGroup = o.DiffieHellmanGroup, gr.createDiffieHellmanGroup = o.createDiffieHellmanGroup, gr.getDiffieHellman = o.getDiffieHellman, gr.createDiffieHellman = o.createDiffieHellman, gr.DiffieHellman = o.DiffieHellman;
    var s = WX();
    gr.createSign = s.createSign, gr.Sign = s.Sign, gr.createVerify = s.createVerify, gr.Verify = s.Verify, gr.createECDH = VX();
    var a = YX();
    gr.publicEncrypt = a.publicEncrypt, gr.privateEncrypt = a.privateEncrypt, gr.publicDecrypt = a.publicDecrypt, gr.privateDecrypt = a.privateDecrypt;
    var u = XX();
    return gr.randomFill = u.randomFill, gr.randomFillSync = u.randomFillSync, gr.createCredentials = function() {
        throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    }, gr.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    }, gr;
}
(function(e) {
    /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.hexToBytes = e.bytesToHex = e.Signature = e.Point = e.CURVE = void 0;
    const t = q3(), r = BigInt(0), n = BigInt(1), i = BigInt(2), o = BigInt(3), s = BigInt(8), a = Object.freeze({
        a: r,
        b: BigInt(7),
        P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: n,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    e.CURVE = a;
    const u = (Ae, we)=>(Ae + we / i) / we, f = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar (Ae) {
            const { n: we } = a, xe = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Me = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ze = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Ve = xe, at = BigInt("0x100000000000000000000000000000000"), ct = u(Ve * Ae, we), lt = u(-Me * Ae, we);
            let mt = ee(Ae - ct * xe - lt * ze, we), wt = ee(-ct * Me - lt * Ve, we);
            const bt = mt > at, Mt = wt > at;
            if (bt && (mt = we - mt), Mt && (wt = we - wt), mt > at || wt > at) throw new Error("splitScalarEndo: Endomorphism failed, k=" + Ae);
            return {
                k1neg: bt,
                k1: mt,
                k2neg: Mt,
                k2: wt
            };
        }
    }, c = 32, l = 32, p = 32, y = c + 1, _ = 2 * c + 1;
    function A(Ae) {
        const { a: we, b: xe } = a, Me = ee(Ae * Ae), ze = ee(Me * Ae);
        return ee(ze + we * Ae + xe);
    }
    const O = a.a === r;
    class N extends Error {
        constructor(we){
            super(we);
        }
    }
    function U(Ae) {
        if (!(Ae instanceof D)) throw new TypeError("JacobianPoint expected");
    }
    class D {
        constructor(we, xe, Me){
            this.x = we, this.y = xe, this.z = Me;
        }
        static fromAffine(we) {
            if (!(we instanceof re)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return we.equals(re.ZERO) ? D.ZERO : new D(we.x, we.y, n);
        }
        static toAffineBatch(we) {
            const xe = De(we.map((Me)=>Me.z));
            return we.map((Me, ze)=>Me.toAffine(xe[ze]));
        }
        static normalizeZ(we) {
            return D.toAffineBatch(we).map(D.fromAffine);
        }
        equals(we) {
            U(we);
            const { x: xe, y: Me, z: ze } = this, { x: Ve, y: at, z: ct } = we, lt = ee(ze * ze), mt = ee(ct * ct), wt = ee(xe * mt), bt = ee(Ve * lt), Mt = ee(ee(Me * ct) * mt), Ct = ee(ee(at * ze) * lt);
            return wt === bt && Mt === Ct;
        }
        negate() {
            return new D(this.x, ee(-this.y), this.z);
        }
        double() {
            const { x: we, y: xe, z: Me } = this, ze = ee(we * we), Ve = ee(xe * xe), at = ee(Ve * Ve), ct = we + Ve, lt = ee(i * (ee(ct * ct) - ze - at)), mt = ee(o * ze), wt = ee(mt * mt), bt = ee(wt - i * lt), Mt = ee(mt * (lt - bt) - s * at), Ct = ee(i * xe * Me);
            return new D(bt, Mt, Ct);
        }
        add(we) {
            U(we);
            const { x: xe, y: Me, z: ze } = this, { x: Ve, y: at, z: ct } = we;
            if (Ve === r || at === r) return this;
            if (xe === r || Me === r) return we;
            const lt = ee(ze * ze), mt = ee(ct * ct), wt = ee(xe * mt), bt = ee(Ve * lt), Mt = ee(ee(Me * ct) * mt), Ct = ee(ee(at * ze) * lt), Xe = ee(bt - wt), xt = ee(Ct - Mt);
            if (Xe === r) return xt === r ? this.double() : D.ZERO;
            const St = ee(Xe * Xe), Pe = ee(Xe * St), et = ee(wt * St), vt = ee(xt * xt - Pe - i * et), be = ee(xt * (et - vt) - Mt * Pe), $r = ee(ze * ct * Xe);
            return new D(vt, be, $r);
        }
        subtract(we) {
            return this.add(we.negate());
        }
        multiplyUnsafe(we) {
            const xe = D.ZERO;
            if (typeof we == "bigint" && we === r) return xe;
            let Me = he(we);
            if (Me === n) return this;
            if (!O) {
                let bt = xe, Mt = this;
                for(; Me > r;)Me & n && (bt = bt.add(Mt)), Mt = Mt.double(), Me >>= n;
                return bt;
            }
            let { k1neg: ze, k1: Ve, k2neg: at, k2: ct } = f.splitScalar(Me), lt = xe, mt = xe, wt = this;
            for(; Ve > r || ct > r;)Ve & n && (lt = lt.add(wt)), ct & n && (mt = mt.add(wt)), wt = wt.double(), Ve >>= n, ct >>= n;
            return ze && (lt = lt.negate()), at && (mt = mt.negate()), mt = new D(ee(mt.x * f.beta), mt.y, mt.z), lt.add(mt);
        }
        precomputeWindow(we) {
            const xe = O ? 128 / we + 1 : 256 / we + 1, Me = [];
            let ze = this, Ve = ze;
            for(let at = 0; at < xe; at++){
                Ve = ze, Me.push(Ve);
                for(let ct = 1; ct < 2 ** (we - 1); ct++)Ve = Ve.add(ze), Me.push(Ve);
                ze = Ve.double();
            }
            return Me;
        }
        wNAF(we, xe) {
            !xe && this.equals(D.BASE) && (xe = re.BASE);
            const Me = xe && xe._WINDOW_SIZE || 1;
            if (256 % Me) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let ze = xe && K.get(xe);
            ze || (ze = this.precomputeWindow(Me), xe && Me !== 1 && (ze = D.normalizeZ(ze), K.set(xe, ze)));
            let Ve = D.ZERO, at = D.BASE;
            const ct = 1 + (O ? 128 / Me : 256 / Me), lt = 2 ** (Me - 1), mt = BigInt(2 ** Me - 1), wt = 2 ** Me, bt = BigInt(Me);
            for(let Mt = 0; Mt < ct; Mt++){
                const Ct = Mt * lt;
                let Xe = Number(we & mt);
                we >>= bt, Xe > lt && (Xe -= wt, we += n);
                const xt = Ct, St = Ct + Math.abs(Xe) - 1, Pe = Mt % 2 !== 0, et = Xe < 0;
                Xe === 0 ? at = at.add(H(Pe, ze[xt])) : Ve = Ve.add(H(et, ze[St]));
            }
            return {
                p: Ve,
                f: at
            };
        }
        multiply(we, xe) {
            let Me = he(we), ze, Ve;
            if (O) {
                const { k1neg: at, k1: ct, k2neg: lt, k2: mt } = f.splitScalar(Me);
                let { p: wt, f: bt } = this.wNAF(ct, xe), { p: Mt, f: Ct } = this.wNAF(mt, xe);
                wt = H(at, wt), Mt = H(lt, Mt), Mt = new D(ee(Mt.x * f.beta), Mt.y, Mt.z), ze = wt.add(Mt), Ve = bt.add(Ct);
            } else {
                const { p: at, f: ct } = this.wNAF(Me, xe);
                ze = at, Ve = ct;
            }
            return D.normalizeZ([
                ze,
                Ve
            ])[0];
        }
        toAffine(we) {
            const { x: xe, y: Me, z: ze } = this, Ve = this.equals(D.ZERO);
            we == null && (we = Ve ? s : Se(ze));
            const at = we, ct = ee(at * at), lt = ee(ct * at), mt = ee(xe * ct), wt = ee(Me * lt), bt = ee(ze * at);
            if (Ve) return re.ZERO;
            if (bt !== n) throw new Error("invZ was invalid");
            return new re(mt, wt);
        }
    }
    D.BASE = new D(a.Gx, a.Gy, n), D.ZERO = new D(r, n, r);
    function H(Ae, we) {
        const xe = we.negate();
        return Ae ? xe : we;
    }
    const K = /* @__PURE__ */ new WeakMap();
    class re {
        constructor(we, xe){
            this.x = we, this.y = xe;
        }
        _setWindowSize(we) {
            this._WINDOW_SIZE = we, K.delete(this);
        }
        hasEvenY() {
            return this.y % i === r;
        }
        static fromCompressedHex(we) {
            const xe = we.length === 32, Me = ue(xe ? we : we.subarray(1));
            if (!Ie(Me)) throw new Error("Point is not on curve");
            const ze = A(Me);
            let Ve = ye(ze);
            const at = (Ve & n) === n;
            xe ? at && (Ve = ee(-Ve)) : (we[0] & 1) === 1 !== at && (Ve = ee(-Ve));
            const ct = new re(Me, Ve);
            return ct.assertValidity(), ct;
        }
        static fromUncompressedHex(we) {
            const xe = ue(we.subarray(1, c + 1)), Me = ue(we.subarray(c + 1, c * 2 + 1)), ze = new re(xe, Me);
            return ze.assertValidity(), ze;
        }
        static fromHex(we) {
            const xe = ce(we), Me = xe.length, ze = xe[0];
            if (Me === c) return this.fromCompressedHex(xe);
            if (Me === y && (ze === 2 || ze === 3)) return this.fromCompressedHex(xe);
            if (Me === _ && ze === 4) return this.fromUncompressedHex(xe);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${_} uncompressed bytes, not ${Me}`);
        }
        static fromPrivateKey(we) {
            return re.BASE.multiply(Ke(we));
        }
        static fromSignature(we, xe, Me) {
            const { r: ze, s: Ve } = h(xe);
            if (![
                0,
                1,
                2,
                3
            ].includes(Me)) throw new Error("Cannot recover: invalid recovery bit");
            const at = Ce(ce(we)), { n: ct } = a, lt = Me === 2 || Me === 3 ? ze + ct : ze, mt = Se(lt, ct), wt = ee(-at * mt, ct), bt = ee(Ve * mt, ct), Mt = Me & 1 ? "03" : "02", Ct = re.fromHex(Mt + k(lt)), Xe = re.BASE.multiplyAndAddUnsafe(Ct, wt, bt);
            if (!Xe) throw new Error("Cannot recover signature: point at infinify");
            return Xe.assertValidity(), Xe;
        }
        toRawBytes(we = !1) {
            return I(this.toHex(we));
        }
        toHex(we = !1) {
            const xe = k(this.x);
            return we ? `${this.hasEvenY() ? "02" : "03"}${xe}` : `04${xe}${k(this.y)}`;
        }
        toHexX() {
            return this.toHex(!0).slice(2);
        }
        toRawX() {
            return this.toRawBytes(!0).slice(1);
        }
        assertValidity() {
            const we = "Point is not on elliptic curve", { x: xe, y: Me } = this;
            if (!Ie(xe) || !Ie(Me)) throw new Error(we);
            const ze = ee(Me * Me), Ve = A(xe);
            if (ee(ze - Ve) !== r) throw new Error(we);
        }
        equals(we) {
            return this.x === we.x && this.y === we.y;
        }
        negate() {
            return new re(this.x, ee(-this.y));
        }
        double() {
            return D.fromAffine(this).double().toAffine();
        }
        add(we) {
            return D.fromAffine(this).add(D.fromAffine(we)).toAffine();
        }
        subtract(we) {
            return this.add(we.negate());
        }
        multiply(we) {
            return D.fromAffine(this).multiply(we, this).toAffine();
        }
        multiplyAndAddUnsafe(we, xe, Me) {
            const ze = D.fromAffine(this), Ve = xe === r || xe === n || this !== re.BASE ? ze.multiplyUnsafe(xe) : ze.multiply(xe), at = D.fromAffine(we).multiplyUnsafe(Me), ct = Ve.add(at);
            return ct.equals(D.ZERO) ? void 0 : ct.toAffine();
        }
    }
    e.Point = re, re.BASE = new re(a.Gx, a.Gy), re.ZERO = new re(r, r);
    function Q(Ae) {
        return Number.parseInt(Ae[0], 16) >= 8 ? "00" + Ae : Ae;
    }
    function G(Ae) {
        if (Ae.length < 2 || Ae[0] !== 2) throw new Error(`Invalid signature integer tag: ${m(Ae)}`);
        const we = Ae[1], xe = Ae.subarray(2, we + 2);
        if (!we || xe.length !== we) throw new Error("Invalid signature integer: wrong length");
        if (xe[0] === 0 && xe[1] <= 127) throw new Error("Invalid signature integer: trailing length");
        return {
            data: ue(xe),
            left: Ae.subarray(we + 2)
        };
    }
    function R(Ae) {
        if (Ae.length < 2 || Ae[0] != 48) throw new Error(`Invalid signature tag: ${m(Ae)}`);
        if (Ae[1] !== Ae.length - 2) throw new Error("Invalid signature: incorrect length");
        const { data: we, left: xe } = G(Ae.subarray(2)), { data: Me, left: ze } = G(xe);
        if (ze.length) throw new Error(`Invalid signature: left bytes after parsing: ${m(ze)}`);
        return {
            r: we,
            s: Me
        };
    }
    class X {
        constructor(we, xe){
            this.r = we, this.s = xe, this.assertValidity();
        }
        static fromCompact(we) {
            const xe = $(we), Me = "Signature.fromCompact";
            if (typeof we != "string" && !xe) throw new TypeError(`${Me}: Expected string or Uint8Array`);
            const ze = xe ? m(we) : we;
            if (ze.length !== 128) throw new Error(`${Me}: Expected 64-byte hex`);
            return new X(ie(ze.slice(0, 64)), ie(ze.slice(64, 128)));
        }
        static fromDER(we) {
            const xe = $(we);
            if (typeof we != "string" && !xe) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
            const { r: Me, s: ze } = R(xe ? we : I(we));
            return new X(Me, ze);
        }
        static fromHex(we) {
            return this.fromDER(we);
        }
        assertValidity() {
            const { r: we, s: xe } = this;
            if (!_e(we)) throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!_e(xe)) throw new Error("Invalid Signature: s must be 0 < s < n");
        }
        hasHighS() {
            const we = a.n >> n;
            return this.s > we;
        }
        normalizeS() {
            return this.hasHighS() ? new X(this.r, ee(-this.s, a.n)) : this;
        }
        toDERRawBytes() {
            return I(this.toDERHex());
        }
        toDERHex() {
            const we = Q(j(this.s)), xe = Q(j(this.r)), Me = we.length / 2, ze = xe.length / 2, Ve = j(Me), at = j(ze);
            return `30${j(ze + Me + 4)}02${at}${xe}02${Ve}${we}`;
        }
        toRawBytes() {
            return this.toDERRawBytes();
        }
        toHex() {
            return this.toDERHex();
        }
        toCompactRawBytes() {
            return I(this.toCompactHex());
        }
        toCompactHex() {
            return k(this.r) + k(this.s);
        }
    }
    e.Signature = X;
    function $(Ae) {
        return Ae instanceof Uint8Array || ArrayBuffer.isView(Ae) && Ae.constructor.name === "Uint8Array";
    }
    function S(Ae) {
        if (!$(Ae)) throw new Error("Uint8Array expected");
    }
    function w(...Ae) {
        if (Ae.every(S), Ae.length === 1) return Ae[0];
        const we = Ae.reduce((Me, ze)=>Me + ze.length, 0), xe = new Uint8Array(we);
        for(let Me = 0, ze = 0; Me < Ae.length; Me++){
            const Ve = Ae[Me];
            xe.set(Ve, ze), ze += Ve.length;
        }
        return xe;
    }
    const g = Array.from({
        length: 256
    }, (Ae, we)=>we.toString(16).padStart(2, "0"));
    function m(Ae) {
        S(Ae);
        let we = "";
        for(let xe = 0; xe < Ae.length; xe++)we += g[Ae[xe]];
        return we;
    }
    e.bytesToHex = m;
    const E = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function T(Ae) {
        if (Ae >= E._0 && Ae <= E._9) return Ae - E._0;
        if (Ae >= E.A && Ae <= E.F) return Ae - (E.A - 10);
        if (Ae >= E.a && Ae <= E.f) return Ae - (E.a - 10);
    }
    function I(Ae) {
        if (typeof Ae != "string") throw new Error("hex string expected, got " + typeof Ae);
        const we = Ae.length, xe = we / 2;
        if (we % 2) throw new Error("hex string expected, got unpadded hex of length " + we);
        const Me = new Uint8Array(xe);
        for(let ze = 0, Ve = 0; ze < xe; ze++, Ve += 2){
            const at = T(Ae.charCodeAt(Ve)), ct = T(Ae.charCodeAt(Ve + 1));
            if (at === void 0 || ct === void 0) {
                const lt = Ae[Ve] + Ae[Ve + 1];
                throw new Error('hex string expected, got non-hex character "' + lt + '" at index ' + Ve);
            }
            Me[ze] = at * 16 + ct;
        }
        return Me;
    }
    e.hexToBytes = I;
    const P = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function k(Ae) {
        if (typeof Ae != "bigint") throw new Error("Expected bigint");
        if (!(r <= Ae && Ae < P)) throw new Error("Expected number 0 <= n < 2^256");
        return Ae.toString(16).padStart(64, "0");
    }
    function L(Ae) {
        const we = I(k(Ae));
        if (we.length !== 32) throw new Error("Error: expected 32 bytes");
        return we;
    }
    function j(Ae) {
        const we = Ae.toString(16);
        return we.length & 1 ? `0${we}` : we;
    }
    function ie(Ae) {
        if (typeof Ae != "string") throw new TypeError("hexToNumber: expected string, got " + typeof Ae);
        return BigInt(`0x${Ae}`);
    }
    function ue(Ae) {
        return ie(m(Ae));
    }
    function ce(Ae) {
        return $(Ae) ? Uint8Array.from(Ae) : I(Ae);
    }
    function he(Ae) {
        if (typeof Ae == "number" && Number.isSafeInteger(Ae) && Ae > 0) return BigInt(Ae);
        if (typeof Ae == "bigint" && _e(Ae)) return Ae;
        throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function ee(Ae, we = a.P) {
        const xe = Ae % we;
        return xe >= r ? xe : we + xe;
    }
    function ae(Ae, we) {
        const { P: xe } = a;
        let Me = Ae;
        for(; we-- > r;)Me *= Me, Me %= xe;
        return Me;
    }
    function ye(Ae) {
        const { P: we } = a, xe = BigInt(6), Me = BigInt(11), ze = BigInt(22), Ve = BigInt(23), at = BigInt(44), ct = BigInt(88), lt = Ae * Ae * Ae % we, mt = lt * lt * Ae % we, wt = ae(mt, o) * mt % we, bt = ae(wt, o) * mt % we, Mt = ae(bt, i) * lt % we, Ct = ae(Mt, Me) * Mt % we, Xe = ae(Ct, ze) * Ct % we, xt = ae(Xe, at) * Xe % we, St = ae(xt, ct) * xt % we, Pe = ae(St, at) * Xe % we, et = ae(Pe, o) * mt % we, vt = ae(et, Ve) * Ct % we, be = ae(vt, xe) * lt % we, $r = ae(be, i);
        if ($r * $r % we !== Ae) throw new Error("Cannot find square root");
        return $r;
    }
    function Se(Ae, we = a.P) {
        if (Ae === r || we <= r) throw new Error(`invert: expected positive integers, got n=${Ae} mod=${we}`);
        let xe = ee(Ae, we), Me = we, ze = r, Ve = n;
        for(; xe !== r;){
            const ct = Me / xe, lt = Me % xe, mt = ze - Ve * ct;
            Me = xe, xe = lt, ze = Ve, Ve = mt;
        }
        if (Me !== n) throw new Error("invert: does not exist");
        return ee(ze, we);
    }
    function De(Ae, we = a.P) {
        const xe = new Array(Ae.length), Me = Ae.reduce((Ve, at, ct)=>at === r ? Ve : (xe[ct] = Ve, ee(Ve * at, we)), n), ze = Se(Me, we);
        return Ae.reduceRight((Ve, at, ct)=>at === r ? Ve : (xe[ct] = ee(Ve * xe[ct], we), ee(Ve * at, we)), ze), xe;
    }
    function Re(Ae) {
        const we = Ae.length * 8 - l * 8, xe = ue(Ae);
        return we > 0 ? xe >> BigInt(we) : xe;
    }
    function Ce(Ae, we = !1) {
        const xe = Re(Ae);
        if (we) return xe;
        const { n: Me } = a;
        return xe >= Me ? xe - Me : xe;
    }
    let M, z;
    class de {
        constructor(we, xe){
            if (this.hashLen = we, this.qByteLen = xe, typeof we != "number" || we < 2) throw new Error("hashLen must be a number");
            if (typeof xe != "number" || xe < 2) throw new Error("qByteLen must be a number");
            this.v = new Uint8Array(we).fill(1), this.k = new Uint8Array(we).fill(0), this.counter = 0;
        }
        hmac(...we) {
            return e.utils.hmacSha256(this.k, ...we);
        }
        hmacSync(...we) {
            return z(this.k, ...we);
        }
        checkSync() {
            if (typeof z != "function") throw new N("hmacSha256Sync needs to be set");
        }
        incr() {
            if (this.counter >= 1e3) throw new Error("Tried 1,000 k values for sign(), all were invalid");
            this.counter += 1;
        }
        async reseed(we = new Uint8Array()) {
            this.k = await this.hmac(this.v, Uint8Array.from([
                0
            ]), we), this.v = await this.hmac(this.v), we.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([
                1
            ]), we), this.v = await this.hmac(this.v));
        }
        reseedSync(we = new Uint8Array()) {
            this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([
                0
            ]), we), this.v = this.hmacSync(this.v), we.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([
                1
            ]), we), this.v = this.hmacSync(this.v));
        }
        async generate() {
            this.incr();
            let we = 0;
            const xe = [];
            for(; we < this.qByteLen;){
                this.v = await this.hmac(this.v);
                const Me = this.v.slice();
                xe.push(Me), we += this.v.length;
            }
            return w(...xe);
        }
        generateSync() {
            this.checkSync(), this.incr();
            let we = 0;
            const xe = [];
            for(; we < this.qByteLen;){
                this.v = this.hmacSync(this.v);
                const Me = this.v.slice();
                xe.push(Me), we += this.v.length;
            }
            return w(...xe);
        }
    }
    function _e(Ae) {
        return r < Ae && Ae < a.n;
    }
    function Ie(Ae) {
        return r < Ae && Ae < a.P;
    }
    function je(Ae, we, xe, Me = !0) {
        const { n: ze } = a, Ve = Ce(Ae, !0);
        if (!_e(Ve)) return;
        const at = Se(Ve, ze), ct = re.BASE.multiply(Ve), lt = ee(ct.x, ze);
        if (lt === r) return;
        const mt = ee(at * ee(we + xe * lt, ze), ze);
        if (mt === r) return;
        let wt = new X(lt, mt), bt = (ct.x === wt.r ? 0 : 2) | Number(ct.y & n);
        return Me && wt.hasHighS() && (wt = wt.normalizeS(), bt ^= 1), {
            sig: wt,
            recovery: bt
        };
    }
    function Ke(Ae) {
        let we;
        if (typeof Ae == "bigint") we = Ae;
        else if (typeof Ae == "number" && Number.isSafeInteger(Ae) && Ae > 0) we = BigInt(Ae);
        else if (typeof Ae == "string") {
            if (Ae.length !== 2 * l) throw new Error("Expected 32 bytes of private key");
            we = ie(Ae);
        } else if ($(Ae)) {
            if (Ae.length !== l) throw new Error("Expected 32 bytes of private key");
            we = ue(Ae);
        } else throw new TypeError("Expected valid private key");
        if (!_e(we)) throw new Error("Expected private key: 0 < key < n");
        return we;
    }
    function Ue(Ae) {
        return Ae instanceof re ? (Ae.assertValidity(), Ae) : re.fromHex(Ae);
    }
    function h(Ae) {
        if (Ae instanceof X) return Ae.assertValidity(), Ae;
        try {
            return X.fromDER(Ae);
        } catch  {
            return X.fromCompact(Ae);
        }
    }
    function x(Ae, we = !1) {
        return re.fromPrivateKey(Ae).toRawBytes(we);
    }
    e.getPublicKey = x;
    function q(Ae, we, xe, Me = !1) {
        return re.fromSignature(Ae, we, xe).toRawBytes(Me);
    }
    e.recoverPublicKey = q;
    function te(Ae) {
        const we = $(Ae), xe = typeof Ae == "string", Me = (we || xe) && Ae.length;
        return we ? Me === y || Me === _ : xe ? Me === y * 2 || Me === _ * 2 : Ae instanceof re;
    }
    function fe(Ae, we, xe = !1) {
        if (te(Ae)) throw new TypeError("getSharedSecret: first arg must be private key");
        if (!te(we)) throw new TypeError("getSharedSecret: second arg must be public key");
        const Me = Ue(we);
        return Me.assertValidity(), Me.multiply(Ke(Ae)).toRawBytes(xe);
    }
    e.getSharedSecret = fe;
    function ne(Ae) {
        const we = Ae.length > c ? Ae.slice(0, c) : Ae;
        return ue(we);
    }
    function W(Ae) {
        const we = ne(Ae), xe = ee(we, a.n);
        return J(xe < r ? we : xe);
    }
    function J(Ae) {
        return L(Ae);
    }
    function V(Ae, we, xe) {
        if (Ae == null) throw new Error(`sign: expected valid message hash, not "${Ae}"`);
        const Me = ce(Ae), ze = Ke(we), Ve = [
            J(ze),
            W(Me)
        ];
        if (xe != null) {
            xe === !0 && (xe = e.utils.randomBytes(c));
            const lt = ce(xe);
            if (lt.length !== c) throw new Error(`sign: Expected ${c} bytes of extra data`);
            Ve.push(lt);
        }
        const at = w(...Ve), ct = ne(Me);
        return {
            seed: at,
            m: ct,
            d: ze
        };
    }
    function C(Ae, we) {
        const { sig: xe, recovery: Me } = Ae, { der: ze, recovered: Ve } = Object.assign({
            canonical: !0,
            der: !0
        }, we), at = ze ? xe.toDERRawBytes() : xe.toCompactRawBytes();
        return Ve ? [
            at,
            Me
        ] : at;
    }
    async function Z(Ae, we, xe = {}) {
        const { seed: Me, m: ze, d: Ve } = V(Ae, we, xe.extraEntropy), at = new de(p, l);
        await at.reseed(Me);
        let ct;
        for(; !(ct = je(await at.generate(), ze, Ve, xe.canonical));)await at.reseed();
        return C(ct, xe);
    }
    e.sign = Z;
    function le(Ae, we, xe = {}) {
        const { seed: Me, m: ze, d: Ve } = V(Ae, we, xe.extraEntropy), at = new de(p, l);
        at.reseedSync(Me);
        let ct;
        for(; !(ct = je(at.generateSync(), ze, Ve, xe.canonical));)at.reseedSync();
        return C(ct, xe);
    }
    e.signSync = le;
    const se = {
        strict: !0
    };
    function Ne(Ae, we, xe, Me = se) {
        let ze;
        try {
            ze = h(Ae), we = ce(we);
        } catch  {
            return !1;
        }
        const { r: Ve, s: at } = ze;
        if (Me.strict && ze.hasHighS()) return !1;
        const ct = Ce(we);
        let lt;
        try {
            lt = Ue(xe);
        } catch  {
            return !1;
        }
        const { n: mt } = a, wt = Se(at, mt), bt = ee(ct * wt, mt), Mt = ee(Ve * wt, mt), Ct = re.BASE.multiplyAndAddUnsafe(lt, bt, Mt);
        return Ct ? ee(Ct.x, mt) === Ve : !1;
    }
    e.verify = Ne;
    function Le(Ae) {
        return ee(ue(Ae), a.n);
    }
    class rt {
        constructor(we, xe){
            this.r = we, this.s = xe, this.assertValidity();
        }
        static fromHex(we) {
            const xe = ce(we);
            if (xe.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${xe.length}`);
            const Me = ue(xe.subarray(0, 32)), ze = ue(xe.subarray(32, 64));
            return new rt(Me, ze);
        }
        assertValidity() {
            const { r: we, s: xe } = this;
            if (!Ie(we) || !_e(xe)) throw new Error("Invalid signature");
        }
        toHex() {
            return k(this.r) + k(this.s);
        }
        toRawBytes() {
            return I(this.toHex());
        }
    }
    function yt(Ae) {
        return re.fromPrivateKey(Ae).toRawX();
    }
    class _t {
        constructor(we, xe, Me = e.utils.randomBytes()){
            if (we == null) throw new TypeError(`sign: Expected valid message, not "${we}"`);
            this.m = ce(we);
            const { x: ze, scalar: Ve } = this.getScalar(Ke(xe));
            if (this.px = ze, this.d = Ve, this.rand = ce(Me), this.rand.length !== 32) throw new TypeError("sign: Expected 32 bytes of aux randomness");
        }
        getScalar(we) {
            const xe = re.fromPrivateKey(we), Me = xe.hasEvenY() ? we : a.n - we;
            return {
                point: xe,
                scalar: Me,
                x: xe.toRawX()
            };
        }
        initNonce(we, xe) {
            return L(we ^ ue(xe));
        }
        finalizeNonce(we) {
            const xe = ee(ue(we), a.n);
            if (xe === r) throw new Error("sign: Creation of signature failed. k is zero");
            const { point: Me, x: ze, scalar: Ve } = this.getScalar(xe);
            return {
                R: Me,
                rx: ze,
                k: Ve
            };
        }
        finalizeSig(we, xe, Me, ze) {
            return new rt(we.x, ee(xe + Me * ze, a.n)).toRawBytes();
        }
        error() {
            throw new Error("sign: Invalid signature produced");
        }
        async calc() {
            const { m: we, d: xe, px: Me, rand: ze } = this, Ve = e.utils.taggedHash, at = this.initNonce(xe, await Ve(wr.aux, ze)), { R: ct, rx: lt, k: mt } = this.finalizeNonce(await Ve(wr.nonce, at, Me, we)), wt = Le(await Ve(wr.challenge, lt, Me, we)), bt = this.finalizeSig(ct, mt, wt, xe);
            return await jr(bt, we, Me) || this.error(), bt;
        }
        calcSync() {
            const { m: we, d: xe, px: Me, rand: ze } = this, Ve = e.utils.taggedHashSync, at = this.initNonce(xe, Ve(wr.aux, ze)), { R: ct, rx: lt, k: mt } = this.finalizeNonce(Ve(wr.nonce, at, Me, we)), wt = Le(Ve(wr.challenge, lt, Me, we)), bt = this.finalizeSig(ct, mt, wt, xe);
            return Et(bt, we, Me) || this.error(), bt;
        }
    }
    async function Qe(Ae, we, xe) {
        return new _t(Ae, we, xe).calc();
    }
    function Rt(Ae, we, xe) {
        return new _t(Ae, we, xe).calcSync();
    }
    function Lt(Ae, we, xe) {
        const Me = Ae instanceof rt, ze = Me ? Ae : rt.fromHex(Ae);
        return Me && ze.assertValidity(), {
            ...ze,
            m: ce(we),
            P: Ue(xe)
        };
    }
    function Ur(Ae, we, xe, Me) {
        const ze = re.BASE.multiplyAndAddUnsafe(we, Ke(xe), ee(-Me, a.n));
        return !(!ze || !ze.hasEvenY() || ze.x !== Ae);
    }
    async function jr(Ae, we, xe) {
        try {
            const { r: Me, s: ze, m: Ve, P: at } = Lt(Ae, we, xe), ct = Le(await e.utils.taggedHash(wr.challenge, L(Me), at.toRawX(), Ve));
            return Ur(Me, at, ze, ct);
        } catch  {
            return !1;
        }
    }
    function Et(Ae, we, xe) {
        try {
            const { r: Me, s: ze, m: Ve, P: at } = Lt(Ae, we, xe), ct = Le(e.utils.taggedHashSync(wr.challenge, L(Me), at.toRawX(), Ve));
            return Ur(Me, at, ze, ct);
        } catch (Me) {
            if (Me instanceof N) throw Me;
            return !1;
        }
    }
    e.schnorr = {
        Signature: rt,
        getPublicKey: yt,
        sign: Qe,
        verify: jr,
        signSync: Rt,
        verifySync: Et
    }, re.BASE._setWindowSize(8);
    const Xt = {
        node: t,
        web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
    }, wr = {
        challenge: "BIP0340/challenge",
        aux: "BIP0340/aux",
        nonce: "BIP0340/nonce"
    }, zt = {};
    e.utils = {
        bytesToHex: m,
        hexToBytes: I,
        concatBytes: w,
        mod: ee,
        invert: Se,
        isValidPrivateKey (Ae) {
            try {
                return Ke(Ae), !0;
            } catch  {
                return !1;
            }
        },
        _bigintTo32Bytes: L,
        _normalizePrivateKey: Ke,
        hashToPrivateKey: (Ae)=>{
            Ae = ce(Ae);
            const we = l + 8;
            if (Ae.length < we || Ae.length > 1024) throw new Error("Expected valid bytes of private key as per FIPS 186");
            const xe = ee(ue(Ae), a.n - n) + n;
            return L(xe);
        },
        randomBytes: (Ae = 32)=>{
            if (Xt.web) return Xt.web.getRandomValues(new Uint8Array(Ae));
            if (Xt.node) {
                const { randomBytes: we } = Xt.node;
                return Uint8Array.from(we(Ae));
            } else throw new Error("The environment doesn't have randomBytes function");
        },
        randomPrivateKey: ()=>e.utils.hashToPrivateKey(e.utils.randomBytes(l + 8)),
        precompute (Ae = 8, we = re.BASE) {
            const xe = we === re.BASE ? we : new re(we.x, we.y);
            return xe._setWindowSize(Ae), xe.multiply(o), xe;
        },
        sha256: async (...Ae)=>{
            if (Xt.web) {
                const we = await Xt.web.subtle.digest("SHA-256", w(...Ae));
                return new Uint8Array(we);
            } else if (Xt.node) {
                const { createHash: we } = Xt.node, xe = we("sha256");
                return Ae.forEach((Me)=>xe.update(Me)), Uint8Array.from(xe.digest());
            } else throw new Error("The environment doesn't have sha256 function");
        },
        hmacSha256: async (Ae, ...we)=>{
            if (Xt.web) {
                const xe = await Xt.web.subtle.importKey("raw", Ae, {
                    name: "HMAC",
                    hash: {
                        name: "SHA-256"
                    }
                }, !1, [
                    "sign"
                ]), Me = w(...we), ze = await Xt.web.subtle.sign("HMAC", xe, Me);
                return new Uint8Array(ze);
            } else if (Xt.node) {
                const { createHmac: xe } = Xt.node, Me = xe("sha256", Ae);
                return we.forEach((ze)=>Me.update(ze)), Uint8Array.from(Me.digest());
            } else throw new Error("The environment doesn't have hmac-sha256 function");
        },
        sha256Sync: void 0,
        hmacSha256Sync: void 0,
        taggedHash: async (Ae, ...we)=>{
            let xe = zt[Ae];
            if (xe === void 0) {
                const Me = await e.utils.sha256(Uint8Array.from(Ae, (ze)=>ze.charCodeAt(0)));
                xe = w(Me, Me), zt[Ae] = xe;
            }
            return e.utils.sha256(xe, ...we);
        },
        taggedHashSync: (Ae, ...we)=>{
            if (typeof M != "function") throw new N("sha256Sync is undefined, you need to set it");
            let xe = zt[Ae];
            if (xe === void 0) {
                const Me = M(Uint8Array.from(Ae, (ze)=>ze.charCodeAt(0)));
                xe = w(Me, Me), zt[Ae] = xe;
            }
            return M(xe, ...we);
        },
        _JacobianPoint: D
    }, Object.defineProperties(e.utils, {
        sha256Sync: {
            configurable: !1,
            get () {
                return M;
            },
            set (Ae) {
                M || (M = Ae);
            }
        },
        hmacSha256Sync: {
            configurable: !1,
            get () {
                return z;
            },
            set (Ae) {
                z || (z = Ae);
            }
        }
    });
})(rO);
var nd = {};
Object.defineProperty(nd, "__esModule", {
    value: !0
});
nd.joseToDer = nd.derToJose = void 0;
const FO = Td, zO = ji;
function a_(e) {
    return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
const JX = {
    ES256: a_(256),
    ES384: a_(384),
    ES512: a_(521)
};
function jO(e) {
    const t = JX[e];
    if (t) return t;
    throw new Error(`Unknown algorithm "${e}"`);
}
const nm = 128, HO = 0, QX = 32, eJ = 16, tJ = 2, qO = eJ | QX | HO << 6, im = tJ | HO << 6;
function KO(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return (0, FO.toByteArray)((0, zO.pad)(e));
    throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function rJ(e, t) {
    const r = KO(e), n = jO(t), i = n + 1, o = r.length;
    let s = 0;
    if (r[s++] !== qO) throw new Error('Could not find expected "seq"');
    let a = r[s++];
    if (a === (nm | 1) && (a = r[s++]), o - s < a) throw new Error(`"seq" specified length of "${a}", only "${o - s}" remaining`);
    if (r[s++] !== im) throw new Error('Could not find expected "int" for "r"');
    const u = r[s++];
    if (o - s - 2 < u) throw new Error(`"r" specified length of "${u}", only "${o - s - 2}" available`);
    if (i < u) throw new Error(`"r" specified length of "${u}", max of "${i}" is acceptable`);
    const f = s;
    if (s += u, r[s++] !== im) throw new Error('Could not find expected "int" for "s"');
    const c = r[s++];
    if (o - s !== c) throw new Error(`"s" specified length of "${c}", expected "${o - s}"`);
    if (i < c) throw new Error(`"s" specified length of "${c}", max of "${i}" is acceptable`);
    const l = s;
    if (s += c, s !== o) throw new Error(`Expected to consume entire array, but "${o - s}" bytes remain`);
    const p = n - u, y = n - c, _ = new Uint8Array(p + u + y + c);
    for(s = 0; s < p; ++s)_[s] = 0;
    _.set(r.subarray(f + Math.max(-p, 0), f + u), s), s = n;
    for(const A = s; s < A + y; ++s)_[s] = 0;
    return _.set(r.subarray(l + Math.max(-y, 0), l + c), s), (0, zO.escape)((0, FO.fromByteArray)(_));
}
nd.derToJose = rJ;
function XT(e, t, r) {
    let n = 0;
    for(; t + n < r && e[t + n] === 0;)++n;
    return e[t + n] >= nm && --n, n;
}
function nJ(e, t) {
    e = KO(e);
    const r = jO(t), n = e.length;
    if (n !== r * 2) throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
    const i = XT(e, 0, r), o = XT(e, r, e.length), s = r - i, a = r - o, u = 2 + s + 1 + 1 + a, f = u < nm, c = new Uint8Array((f ? 2 : 3) + u);
    let l = 0;
    return c[l++] = qO, f ? c[l++] = u : (c[l++] = nm | 1, c[l++] = u & 255), c[l++] = im, c[l++] = s, i < 0 ? (c[l++] = 0, c.set(e.subarray(0, r), l), l += r) : (c.set(e.subarray(i, r), l), l += r - i), c[l++] = im, c[l++] = a, o < 0 ? (c[l++] = 0, c.set(e.subarray(r), l)) : c.set(e.subarray(r + o), l), c;
}
nd.joseToDer = nJ;
var cc = {};
Object.defineProperty(cc, "__esModule", {
    value: !0
});
cc.InvalidTokenError = cc.MissingParametersError = void 0;
class iJ extends Error {
    constructor(t){
        super(), this.name = "MissingParametersError", this.message = t || "";
    }
}
cc.MissingParametersError = iJ;
class oJ extends Error {
    constructor(t){
        super(), this.name = "InvalidTokenError", this.message = t || "";
    }
}
cc.InvalidTokenError = oJ;
Object.defineProperty(vb, "__esModule", {
    value: !0
});
vb.SECP256K1Client = void 0;
const sJ = Qp, aJ = us, By = rO, JT = nd, QT = cc, ek = Hr;
By.utils.hmacSha256Sync = (e, ...t)=>{
    const r = sJ.hmac.create(aJ.sha256, e);
    return t.forEach((n)=>r.update(n)), r.digest();
};
class WO {
    static derivePublicKey(t, r = !0) {
        return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, ek.bytesToHex)(By.getPublicKey(t, r));
    }
    static signHash(t, r, n = "jose") {
        if (!t || !r) throw new QT.MissingParametersError("a signing input hash and private key are all required");
        const i = By.signSync(t, r.slice(0, 64), {
            der: !0,
            canonical: !1
        });
        if (n === "der") return (0, ek.bytesToHex)(i);
        if (n === "jose") return (0, JT.derToJose)(i, "ES256");
        throw Error("Invalid signature format");
    }
    static loadSignature(t) {
        return (0, JT.joseToDer)(t, "ES256");
    }
    static verifyHash(t, r, n) {
        if (!t || !r || !n) throw new QT.MissingParametersError("a signing input hash, der signature, and public key are all required");
        return By.verify(r, t, n, {
            strict: !1
        });
    }
}
vb.SECP256K1Client = WO;
WO.algorithmName = "ES256K";
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.cryptoClients = e.SECP256K1Client = void 0;
    const t = vb;
    Object.defineProperty(e, "SECP256K1Client", {
        enumerable: !0,
        get: function() {
            return t.SECP256K1Client;
        }
    });
    const r = {
        ES256K: t.SECP256K1Client
    };
    e.cryptoClients = r;
})(wb);
var wf = {}, cJ = Ge && Ge.__awaiter || function(e, t, r, n) {
    function i(o) {
        return o instanceof r ? o : new r(function(s) {
            s(o);
        });
    }
    return new (r || (r = Promise))(function(o, s) {
        function a(c) {
            try {
                f(n.next(c));
            } catch (l) {
                s(l);
            }
        }
        function u(c) {
            try {
                f(n.throw(c));
            } catch (l) {
                s(l);
            }
        }
        function f(c) {
            c.done ? o(c.value) : i(c.value).then(a, u);
        }
        f((n = n.apply(e, t || [])).next());
    });
};
Object.defineProperty(wf, "__esModule", {
    value: !0
});
wf.hashSha256Async = wf.hashSha256 = void 0;
const uJ = us;
function VO(e) {
    return (0, uJ.sha256)(e);
}
wf.hashSha256 = VO;
function fJ(e) {
    return cJ(this, void 0, void 0, function*() {
        try {
            if (typeof crypto < "u" && typeof crypto.subtle < "u") {
                const r = typeof e == "string" ? new TextEncoder().encode(e) : e, n = yield crypto.subtle.digest("SHA-256", r);
                return new Uint8Array(n);
            } else {
                const r = q3();
                if (!r.createHash) throw new Error("`crypto` module does not contain `createHash`");
                return Promise.resolve(r.createHash("sha256").update(e).digest());
            }
        } catch (t) {
            return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(VO(e));
        }
    });
}
wf.hashSha256Async = fJ;
var lJ = Ge && Ge.__awaiter || function(e, t, r, n) {
    function i(o) {
        return o instanceof r ? o : new r(function(s) {
            s(o);
        });
    }
    return new (r || (r = Promise))(function(o, s) {
        function a(c) {
            try {
                f(n.next(c));
            } catch (l) {
                s(l);
            }
        }
        function u(c) {
            try {
                f(n.throw(c));
            } catch (l) {
                s(l);
            }
        }
        function f(c) {
            c.done ? o(c.value) : i(c.value).then(a, u);
        }
        f((n = n.apply(e, t || [])).next());
    });
};
Object.defineProperty(td, "__esModule", {
    value: !0
});
td.TokenSigner = td.createUnsecuredToken = void 0;
const LE = ji, tk = wb, dJ = cc, rk = wf;
function DE(e, t) {
    const r = [], n = LE.encode(JSON.stringify(t));
    r.push(n);
    const i = LE.encode(JSON.stringify(e));
    return r.push(i), r.join(".");
}
function hJ(e) {
    return DE(e, {
        typ: "JWT",
        alg: "none"
    }) + ".";
}
td.createUnsecuredToken = hJ;
class pJ {
    constructor(t, r){
        if (!(t && r)) throw new dJ.MissingParametersError("a signing algorithm and private key are required");
        if (typeof t != "string") throw new Error("signing algorithm parameter must be a string");
        if (t = t.toUpperCase(), !tk.cryptoClients.hasOwnProperty(t)) throw new Error("invalid signing algorithm");
        this.tokenType = "JWT", this.cryptoClient = tk.cryptoClients[t], this.rawPrivateKey = r;
    }
    header(t = {}) {
        const r = {
            typ: this.tokenType,
            alg: this.cryptoClient.algorithmName
        };
        return Object.assign({}, r, t);
    }
    sign(t, r = !1, n = {}) {
        const i = this.header(n), o = DE(t, i), s = (0, rk.hashSha256)(o);
        return this.createWithSignedHash(t, r, i, o, s);
    }
    signAsync(t, r = !1, n = {}) {
        return lJ(this, void 0, void 0, function*() {
            const i = this.header(n), o = DE(t, i), s = yield (0, rk.hashSha256Async)(o);
            return this.createWithSignedHash(t, r, i, o, s);
        });
    }
    createWithSignedHash(t, r, n, i, o) {
        const s = this.cryptoClient.signHash(o, this.rawPrivateKey);
        return r ? {
            header: [
                LE.encode(JSON.stringify(n))
            ],
            payload: JSON.stringify(t),
            signature: [
                s
            ]
        } : [
            i,
            s
        ].join(".");
    }
}
td.TokenSigner = pJ;
var Ib = {};
Object.defineProperty(Ib, "__esModule", {
    value: !0
});
Ib.TokenVerifier = void 0;
const gJ = ji, nk = wb, yJ = cc, Vg = wf;
class mJ {
    constructor(t, r){
        if (!(t && r)) throw new yJ.MissingParametersError("a signing algorithm and public key are required");
        if (typeof t != "string") throw "signing algorithm parameter must be a string";
        if (t = t.toUpperCase(), !nk.cryptoClients.hasOwnProperty(t)) throw "invalid signing algorithm";
        this.tokenType = "JWT", this.cryptoClient = nk.cryptoClients[t], this.rawPublicKey = r;
    }
    verify(t) {
        return typeof t == "string" ? this.verifyCompact(t, !1) : typeof t == "object" ? this.verifyExpanded(t, !1) : !1;
    }
    verifyAsync(t) {
        return typeof t == "string" ? this.verifyCompact(t, !0) : typeof t == "object" ? this.verifyExpanded(t, !0) : Promise.resolve(!1);
    }
    verifyCompact(t, r) {
        const n = t.split("."), i = n[0] + "." + n[1], o = (s)=>{
            const a = this.cryptoClient.loadSignature(n[2]);
            return this.cryptoClient.verifyHash(s, a, this.rawPublicKey);
        };
        if (r) return (0, Vg.hashSha256Async)(i).then((s)=>o(s));
        {
            const s = (0, Vg.hashSha256)(i);
            return o(s);
        }
    }
    verifyExpanded(t, r) {
        const n = [
            t.header.join("."),
            gJ.encode(t.payload)
        ].join(".");
        let i = !0;
        const o = (s)=>(t.signature.map((a)=>{
                const u = this.cryptoClient.loadSignature(a);
                this.cryptoClient.verifyHash(s, u, this.rawPublicKey) || (i = !1);
            }), i);
        if (r) return (0, Vg.hashSha256Async)(n).then((s)=>o(s));
        {
            const s = (0, Vg.hashSha256)(n);
            return o(s);
        }
    }
}
Ib.TokenVerifier = mJ;
var Bb = {};
Object.defineProperty(Bb, "__esModule", {
    value: !0
});
Bb.decodeToken = void 0;
const Gg = ji;
function bJ(e) {
    if (typeof e == "string") {
        const t = e.split("."), r = JSON.parse(Gg.decode(t[0])), n = JSON.parse(Gg.decode(t[1])), i = t[2];
        return {
            header: r,
            payload: n,
            signature: i
        };
    } else if (typeof e == "object") {
        if (typeof e.payload != "string") throw new Error("Expected token payload to be a base64 or json string");
        let t = e.payload;
        e.payload[0] !== "{" && (t = Gg.decode(t));
        const r = [];
        return e.header.map((n)=>{
            const i = JSON.parse(Gg.decode(n));
            r.push(i);
        }), {
            header: r,
            payload: JSON.parse(t),
            signature: e.signature
        };
    }
}
Bb.decodeToken = bJ;
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(td, e), r(Ib, e), r(Bb, e), r(cc, e), r(wb, e);
})(Lo);
var c_;
function wJ(e) {
    return c_ == null ? void 0 : c_.get(e);
}
var u_;
function vJ(e) {
    return u_ == null ? void 0 : u_.get(e);
}
var f_;
function _J(e, t) {
    var r;
    return (r = f_ == null ? void 0 : f_.get(e)) == null ? void 0 : r.get(t);
}
function Ob(e) {
    var r, n;
    const t = typeof e;
    return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function Jn(e, t, r, n, i) {
    const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? Ob(o), u = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: s,
        received: a,
        message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
        requirement: e.requirement,
        path: i == null ? void 0 : i.path,
        issues: i == null ? void 0 : i.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, f = e.kind === "schema", c = (i == null ? void 0 : i.message) ?? e.message ?? _J(e.reference, u.lang) ?? (f ? vJ(u.lang) : null) ?? n.message ?? wJ(u.lang);
    c && (u.message = typeof c == "function" ? // @ts-expect-error
    c(u) : c), f && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [
        u
    ];
}
function GO(e, t) {
    return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function Pb(e, t) {
    const r = [
        ...new Set(e)
    ];
    return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
function ZO(e, t) {
    return {
        kind: "validation",
        type: "check",
        reference: ZO,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement(r.value) && Jn(this, "input", r, n), r;
        }
    };
}
function YO(e, t) {
    return {
        kind: "validation",
        type: "max_length",
        reference: YO,
        async: !1,
        expects: `<=${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length > this.requirement && Jn(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function XO(e, t) {
    return {
        kind: "validation",
        type: "min_length",
        reference: XO,
        async: !1,
        expects: `>=${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length < this.requirement && Jn(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function JO(e, t, r) {
    return typeof e.default == "function" ? // @ts-expect-error
    e.default(t, r) : // @ts-expect-error
    e.default;
}
function ik(e, t) {
    return !e._run({
        typed: !1,
        value: t
    }, {
        abortEarly: !0
    }).issues;
}
function An(e, t) {
    return {
        kind: "schema",
        type: "array",
        reference: An,
        expects: "Array",
        async: !1,
        item: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (Array.isArray(i)) {
                r.typed = !0, r.value = [];
                for(let s = 0; s < i.length; s++){
                    const a = i[s], u = this.item._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "array",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), r.value.push(u.value);
                }
            } else Jn(this, "type", r, n);
            return r;
        }
    };
}
function Uf(e) {
    return {
        kind: "schema",
        type: "boolean",
        reference: Uf,
        expects: "boolean",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "boolean" ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function go(e, t) {
    const r = Object.entries(e).filter(([n])=>isNaN(+n)).map(([, n])=>n);
    return {
        kind: "schema",
        type: "enum",
        reference: go,
        expects: Pb(r.map(Ob), "|"),
        async: !1,
        enum: e,
        options: r,
        message: t,
        _run (n, i) {
            return this.options.includes(n.value) ? n.typed = !0 : Jn(this, "type", n, i), n;
        }
    };
}
function or(e, t) {
    return {
        kind: "schema",
        type: "literal",
        reference: or,
        expects: Ob(e),
        async: !1,
        literal: e,
        message: t,
        _run (r, n) {
            return r.value === this.literal ? r.typed = !0 : Jn(this, "type", r, n), r;
        }
    };
}
function QO(e, t) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: QO,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
                if (!r.issues || !n.abortEarly) for(const s in i)GO(i, s) && !(s in this.entries) && (r.value[s] = i[s]);
            } else Jn(this, "type", r, n);
            return r;
        }
    };
}
function K3(e, t) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: K3,
        expects: "!undefined",
        async: !1,
        wrapped: e,
        message: t,
        _run (r, n) {
            return r.value === void 0 ? (Jn(this, "type", r, n), r) : this.wrapped._run(r, n);
        }
    };
}
function $i(e) {
    return {
        kind: "schema",
        type: "null",
        reference: $i,
        expects: "null",
        async: !1,
        message: e,
        _run (t, r) {
            return t.value === null ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function ai(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullish",
        reference: ai,
        expects: `(${e.expects} | null | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return (n.value === null || n.value === void 0) && ("default" in this && (n.value = JO(this, n, i)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function zn(e) {
    return {
        kind: "schema",
        type: "number",
        reference: zn,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function ot(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: ot,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
            } else Jn(this, "type", r, n);
            return r;
        }
    };
}
function Yt(e, ...t) {
    const r = {
        kind: "schema",
        type: "optional",
        reference: Yt,
        expects: `(${e.expects} | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return n.value === void 0 && ("default" in this && (n.value = JO(this, n, i)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function eP(e, t) {
    return {
        kind: "schema",
        type: "picklist",
        reference: eP,
        expects: Pb(e.map(Ob), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            return this.options.includes(r.value) ? r.typed = !0 : Jn(this, "type", r, n), r;
        }
    };
}
function tP(e, t, r) {
    return {
        kind: "schema",
        type: "record",
        reference: tP,
        expects: "Object",
        async: !1,
        key: e,
        value: t,
        message: r,
        _run (n, i) {
            var s, a;
            const o = n.value;
            if (o && typeof o == "object") {
                n.typed = !0, n.value = {};
                for(const u in o)if (GO(o, u)) {
                    const f = o[u], c = this.key._run({
                        typed: !1,
                        value: u
                    }, i);
                    if (c.issues) {
                        const p = {
                            type: "object",
                            origin: "key",
                            input: o,
                            key: u,
                            value: f
                        };
                        for (const y of c.issues)y.path = [
                            p
                        ], (s = n.issues) == null || s.push(y);
                        if (n.issues || (n.issues = c.issues), i.abortEarly) {
                            n.typed = !1;
                            break;
                        }
                    }
                    const l = this.value._run({
                        typed: !1,
                        value: f
                    }, i);
                    if (l.issues) {
                        const p = {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: u,
                            value: f
                        };
                        for (const y of l.issues)y.path ? y.path.unshift(p) : y.path = [
                            p
                        ], (a = n.issues) == null || a.push(y);
                        if (n.issues || (n.issues = l.issues), i.abortEarly) {
                            n.typed = !1;
                            break;
                        }
                    }
                    (!c.typed || !l.typed) && (n.typed = !1), c.typed && (n.value[c.value] = l.value);
                }
            } else Jn(this, "type", n, i);
            return n;
        }
    };
}
function nt(e) {
    return {
        kind: "schema",
        type: "string",
        reference: nt,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function ok(e) {
    let t;
    if (e) for (const r of e)t ? t.push(...r.issues) : t = r.issues;
    return t;
}
function $f(e, t) {
    return {
        kind: "schema",
        type: "union",
        reference: $f,
        expects: Pb(e.map((r)=>r.expects), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            let i, o, s;
            for (const a of this.options){
                const u = a._run({
                    typed: !1,
                    value: r.value
                }, n);
                if (u.typed) if (u.issues) o ? o.push(u) : o = [
                    u
                ];
                else {
                    i = u;
                    break;
                }
                else s ? s.push(u) : s = [
                    u
                ];
            }
            if (i) return i;
            if (o) {
                if (o.length === 1) return o[0];
                Jn(this, "type", r, n, {
                    issues: ok(o)
                }), r.typed = !0;
            } else {
                if ((s == null ? void 0 : s.length) === 1) return s[0];
                Jn(this, "type", r, n, {
                    issues: ok(s)
                });
            }
            return r;
        }
    };
}
function Nb() {
    return {
        kind: "schema",
        type: "unknown",
        reference: Nb,
        expects: "unknown",
        async: !1,
        _run (e) {
            return e.typed = !0, e;
        }
    };
}
function rP(e, t, r) {
    return {
        kind: "schema",
        type: "variant",
        reference: rP,
        expects: "Object",
        async: !1,
        key: e,
        options: t,
        message: r,
        _run (n, i) {
            const o = n.value;
            if (o && typeof o == "object") {
                let s, a = 0, u = this.key, f = [];
                const c = (l, p)=>{
                    for (const y of l.options){
                        if (y.type === "variant") c(y, new Set(p).add(y.key));
                        else {
                            let _ = !0, A = 0;
                            for (const O of p){
                                if (y.entries[O]._run(// @ts-expect-error
                                {
                                    typed: !1,
                                    value: o[O]
                                }, i).issues) {
                                    _ = !1, u !== O && (a < A || a === A && O in o && !(u in o)) && (a = A, u = O, f = []), u === O && f.push(y.entries[O].expects);
                                    break;
                                }
                                A++;
                            }
                            if (_) {
                                const O = y._run({
                                    typed: !1,
                                    value: o
                                }, i);
                                (!s || !s.typed && O.typed) && (s = O);
                            }
                        }
                        if (s && !s.issues) break;
                    }
                };
                if (c(this, /* @__PURE__ */ new Set([
                    this.key
                ])), s) return s;
                Jn(this, "type", n, i, {
                    // @ts-expect-error
                    input: o[u],
                    expected: Pb(f, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: u,
                            // @ts-expect-error
                            value: o[u]
                        }
                    ]
                });
            } else Jn(this, "type", n, i);
            return n;
        }
    };
}
function sk(e, t) {
    const r = {
        ...e.entries
    };
    for (const n of t)delete r[n];
    return {
        ...e,
        entries: r
    };
}
function FE(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
function EJ(e) {
    return e.wrapped;
}
const xJ = globalThis || void 0 || self;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var ak = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(()=>{
    const e = Array(256).fill(-1);
    for(let t = 0; t < ak.length; ++t)e[ak.charCodeAt(t)] = t;
})();
var ck, l_, Zg, W3 = (ck = function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.bech32m = t.bech32 = void 0;
    const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
    for(let l = 0; l < 32; l++){
        const p = r.charAt(l);
        n[p] = l;
    }
    function i(l) {
        const p = l >> 25;
        return (33554431 & l) << 5 ^ 996825010 & -(p >> 0 & 1) ^ 642813549 & -(p >> 1 & 1) ^ 513874426 & -(p >> 2 & 1) ^ 1027748829 & -(p >> 3 & 1) ^ 705979059 & -(p >> 4 & 1);
    }
    function o(l) {
        let p = 1;
        for(let y = 0; y < l.length; ++y){
            const _ = l.charCodeAt(y);
            if (_ < 33 || _ > 126) return "Invalid prefix (" + l + ")";
            p = i(p) ^ _ >> 5;
        }
        p = i(p);
        for(let y = 0; y < l.length; ++y){
            const _ = l.charCodeAt(y);
            p = i(p) ^ 31 & _;
        }
        return p;
    }
    function s(l, p, y, _) {
        let A = 0, O = 0;
        const N = (1 << y) - 1, U = [];
        for(let D = 0; D < l.length; ++D)for(A = A << p | l[D], O += p; O >= y;)O -= y, U.push(A >> O & N);
        if (_) O > 0 && U.push(A << y - O & N);
        else {
            if (O >= p) return "Excess padding";
            if (A << y - O & N) return "Non-zero padding";
        }
        return U;
    }
    function a(l) {
        return s(l, 8, 5, !0);
    }
    function u(l) {
        const p = s(l, 5, 8, !1);
        if (Array.isArray(p)) return p;
    }
    function f(l) {
        const p = s(l, 5, 8, !1);
        if (Array.isArray(p)) return p;
        throw new Error(p);
    }
    function c(l) {
        let p;
        function y(_, A) {
            if (A = A || 90, _.length < 8) return _ + " too short";
            if (_.length > A) return "Exceeds length limit";
            const O = _.toLowerCase(), N = _.toUpperCase();
            if (_ !== O && _ !== N) return "Mixed-case string " + _;
            const U = (_ = O).lastIndexOf("1");
            if (U === -1) return "No separator character for " + _;
            if (U === 0) return "Missing prefix for " + _;
            const D = _.slice(0, U), H = _.slice(U + 1);
            if (H.length < 6) return "Data too short";
            let K = o(D);
            if (typeof K == "string") return K;
            const re = [];
            for(let Q = 0; Q < H.length; ++Q){
                const G = H.charAt(Q), R = n[G];
                if (R === void 0) return "Unknown character " + G;
                K = i(K) ^ R, Q + 6 >= H.length || re.push(R);
            }
            return K !== p ? "Invalid checksum for " + _ : {
                prefix: D,
                words: re
            };
        }
        return p = l === "bech32" ? 1 : 734539939, {
            decodeUnsafe: function(_, A) {
                const O = y(_, A);
                if (typeof O == "object") return O;
            },
            decode: function(_, A) {
                const O = y(_, A);
                if (typeof O == "object") return O;
                throw new Error(O);
            },
            encode: function(_, A, O) {
                if (O = O || 90, _.length + 7 + A.length > O) throw new TypeError("Exceeds length limit");
                let N = o(_ = _.toLowerCase());
                if (typeof N == "string") throw new Error(N);
                let U = _ + "1";
                for(let D = 0; D < A.length; ++D){
                    const H = A[D];
                    if (H >> 5) throw new Error("Non 5-bit word");
                    N = i(N) ^ H, U += r.charAt(H);
                }
                for(let D = 0; D < 6; ++D)N = i(N);
                N ^= p;
                for(let D = 0; D < 6; ++D)U += r.charAt(N >> 5 * (5 - D) & 31);
                return U;
            },
            toWords: a,
            fromWordsUnsafe: u,
            fromWords: f
        };
    }
    t.bech32 = c("bech32"), t.bech32m = c("bech32m");
}, ck(l_ = {
    exports: {}
}, l_.exports), l_.exports);
(Zg = W3) && Zg.__esModule && Object.prototype.hasOwnProperty.call(Zg, "default") && Zg.default;
W3.bech32m;
W3.bech32;
new Uint8Array(new Uint16Array([
    65279
]).buffer)[0];
var Cl, Ul;
(function(e) {
    e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Cl || (Cl = {})), function(e) {
    e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Ul || (Ul = {}));
Ul.p2pkh, Cl.mainnet, Ul.p2pkh, Cl.testnet, Ul.p2sh, Cl.mainnet, Ul.p2sh, Cl.testnet;
var SJ = [
    "software",
    "ledger",
    "keystone"
], nP = eP(SJ), vf = /* @__PURE__ */ ((e)=>(e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(vf || {}), iP = /* @__PURE__ */ ((e)=>(e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(iP || {}), oP = ot({
    address: nt(),
    publicKey: nt(),
    purpose: go(vf),
    addressType: go(iP),
    walletType: nP
}), AJ = async (e)=>{
    var n, i;
    const t = await Mb(e.getProvider), { purposes: r } = e.payload;
    if (!r) throw new Error("Address purposes are required");
    try {
        const o = Lo.createUnsecuredToken(e.payload), s = await t.connect(o);
        (n = e.onFinish) == null || n.call(e, s);
    } catch (o) {
        console.error("[Connect] Error during address request", o), (i = e.onCancel) == null || i.call(e);
    }
}, Mn = /* @__PURE__ */ ((e)=>(e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Testnet4 = "Testnet4", e.Signet = "Signet", e.Regtest = "Regtest", e))(Mn || {}), V3 = Yt($f([
    nt(),
    zn(),
    $i()
])), Gr = ot({
    jsonrpc: or("2.0"),
    method: nt(),
    params: Yt($f([
        An(Nb()),
        QO({}),
        // Note: This is to support current incorrect usage of RPC 2.0. Params need
        // to be either an array or an object when provided. Changing this now would
        // be a breaking change, so accepting null values for now. Tracking in
        // https://linear.app/xverseapp/issue/ENG-4538.
        $i()
    ])),
    id: EJ(V3)
}), kh = /* @__PURE__ */ ((e)=>(e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(kh || {}), sP = ot({
    jsonrpc: or("2.0"),
    result: K3(Nb()),
    id: V3
}), aP = ot({
    jsonrpc: or("2.0"),
    error: K3(Nb()),
    id: V3
});
$f([
    sP,
    aP
]);
var TJ = "accountChange";
ot({
    type: or(TJ),
    addresses: Yt(An(oP))
});
var kJ = "networkChange";
ot({
    type: or(kJ),
    bitcoin: ot({
        name: go(Mn)
    }),
    stacks: ot({
        name: nt()
    })
});
var IJ = "disconnect";
ot({
    type: or(IJ)
});
async function Mb(e) {
    var r;
    const t = await (e == null ? void 0 : e()) || ((r = window.XverseProviders) == null ? void 0 : r.BitcoinProvider) || window.BitcoinProvider;
    if (!t) throw new Error("No Bitcoin wallet installed");
    return t;
}
var BJ = "stx_callContract", OJ = ot({
    /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */ contract: nt(),
    /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */ functionName: nt(),
    /**
   * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
   */ arguments: Yt(An(nt())),
    /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */ functionArgs: Yt(An(nt())),
    /**
   * The post conditions to apply to the contract call.
   */ postConditions: Yt(An(nt())),
    /**
   * The mode to apply to the post conditions.
   */ postConditionMode: Yt($f([
        or("allow"),
        or("deny")
    ]))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(BJ),
        params: OJ,
        id: nt()
    }).entries
});
var PJ = "stx_deployContract", NJ = ot({
    /**
   * Name of the contract.
   */ name: nt(),
    /**
   * The source code of the Clarity contract.
   */ clarityCode: nt(),
    /**
   * The version of the Clarity contract.
   */ clarityVersion: Yt(nt()),
    /**
   * The post conditions to apply to the contract call.
   */ postConditions: Yt(An(nt())),
    /**
   * The mode to apply to the post conditions.
   */ postConditionMode: Yt($f([
        or("allow"),
        or("deny")
    ]))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(PJ),
        params: NJ,
        id: nt()
    }).entries
});
var MJ = ot({
    read: Yt(Uf())
}), RJ = ot({
    readNetwork: Yt(Uf())
}), CJ = ot({
    type: or("account"),
    resourceId: nt(),
    clientId: nt(),
    actions: MJ
}), UJ = ot({
    type: or("wallet"),
    resourceId: nt(),
    clientId: nt(),
    actions: RJ
}), cP = rP("type", [
    ot({
        ...sk(CJ, [
            "clientId"
        ]).entries
    }),
    ot({
        ...sk(UJ, [
            "clientId"
        ]).entries
    })
]), $J = "wallet_requestPermissions", LJ = ai(An(cP));
or(!0);
ot({
    ...Gr.entries,
    ...ot({
        method: or($J),
        params: LJ,
        id: nt()
    }).entries
});
var DJ = "wallet_renouncePermissions", FJ = ai($i());
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(DJ),
        params: FJ,
        id: nt()
    }).entries
});
var zJ = "wallet_disconnect", jJ = ai($i());
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(zJ),
        params: jJ,
        id: nt()
    }).entries
});
var HJ = "wallet_getWalletType", qJ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(HJ),
        params: qJ,
        id: nt()
    }).entries
});
var KJ = "wallet_getCurrentPermissions", WJ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(KJ),
        params: WJ,
        id: nt()
    }).entries
});
var VJ = "wallet_getNetwork", GJ = ai($i());
ot({
    bitcoin: ot({
        name: go(Mn)
    }),
    stacks: ot({
        name: nt()
    })
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(VJ),
        params: GJ,
        id: nt()
    }).entries
});
var ZJ = "wallet_changeNetwork", YJ = ot({
    name: go(Mn)
});
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(ZJ),
        params: YJ,
        id: nt()
    }).entries
});
var XJ = "wallet_getAccount", JJ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(XJ),
        params: JJ,
        id: nt()
    }).entries
});
var QJ = "wallet_connect", eQ = ai(ot({
    permissions: Yt(An(cP)),
    addresses: Yt(An(go(vf))),
    message: Yt(FE(nt(), YO(80, "The message must not exceed 80 characters."))),
    network: Yt(go(Mn))
}));
ot({
    ...Gr.entries,
    ...ot({
        method: or(QJ),
        params: eQ,
        id: nt()
    }).entries
});
var tQ = "stx_getAccounts", rQ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(tQ),
        params: rQ,
        id: nt()
    }).entries
});
var nQ = "stx_getAddresses", iQ = ai(ot({
    /**
     * A message to be displayed to the user in the request prompt.
     */ message: Yt(nt())
}));
ot({
    ...Gr.entries,
    ...ot({
        method: or(nQ),
        params: iQ,
        id: nt()
    }).entries
});
var oQ = "stx_signMessage", sQ = ot({
    /**
   * The message to sign.
   */ message: nt()
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(oQ),
        params: sQ,
        id: nt()
    }).entries
});
var aQ = "stx_signStructuredMessage", cQ = ot({
    /**
   * The domain to be signed.
   */ domain: nt(),
    /**
   * Message payload to be signed.
   */ message: nt(),
    /**
   * The public key to sign the message with.
   */ publicKey: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(aQ),
        params: cQ,
        id: nt()
    }).entries
});
var uQ = "stx_signTransaction", fQ = ot({
    /**
   * The transaction to sign as a hex-encoded string.
   */ transaction: nt(),
    /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */ pubkey: Yt(nt()),
    /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */ broadcast: Yt(Uf())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(uQ),
        params: fQ,
        id: nt()
    }).entries
});
var lQ = "stx_signTransactions", dQ = ot({
    /**
   * The transactions to sign as hex-encoded strings.
   */ transactions: FE(An(FE(nt(), ZO((e)=>!0, "Invalid hex-encoded Stacks transaction."))), XO(1)),
    /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */ broadcast: Yt(Uf())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(lQ),
        params: dQ,
        id: nt()
    }).entries
});
var hQ = "stx_transferStx", pQ = ot({
    /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */ amount: $f([
        zn(),
        nt()
    ]),
    /**
   * The recipeint's principal.
   */ recipient: nt(),
    /**
   * A string representing the memo.
   */ memo: Yt(nt()),
    /**
   * Version of parameter format.
   */ version: Yt(nt()),
    /**
   * The mode of the post conditions.
   */ postConditionMode: Yt(zn()),
    /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */ postConditions: Yt(An(nt())),
    /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */ pubkey: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(hQ),
        params: pQ,
        id: nt()
    }).entries
});
var gQ = "getInfo", yQ = ai($i());
ot({
    /**
   * Version of the wallet.
   */ version: nt(),
    /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */ methods: Yt(An(nt())),
    /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */ supports: An(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(gQ),
        params: yQ,
        id: nt()
    }).entries
});
var mQ = "getAddresses", bQ = ot({
    /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */ purposes: An(go(vf)),
    /**
   * A message to be displayed to the user in the request prompt.
   */ message: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(mQ),
        params: bQ,
        id: nt()
    }).entries
});
var wQ = "signMessage", _f = /* @__PURE__ */ ((e)=>(e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(_f || {}), vQ = ot({
    /**
   * The address used for signing.
   **/ address: nt(),
    /**
   * The message to sign.
   **/ message: nt(),
    /**
   * The protocol to use for signing the message.
   */ protocol: Yt(go(_f))
});
ot({
    /**
   * The signature of the message.
   */ signature: nt(),
    /**
   * hash of the message.
   */ messageHash: nt(),
    /**
   * The address used for signing.
   */ address: nt(),
    /**
   * The protocol to use for signing the message.
   */ protocol: go(_f)
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(wQ),
        params: vQ,
        id: nt()
    }).entries
});
var _Q = "sendTransfer", EQ = ot({
    /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */ recipients: An(ot({
        address: nt(),
        amount: zn()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(_Q),
        params: EQ,
        id: nt()
    }).entries
});
var xQ = "signPsbt", SQ = ot({
    /**
   * The base64 encoded PSBT to sign.
   */ psbt: nt(),
    /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */ signInputs: tP(nt(), An(zn())),
    /**
   * Whether to broadcast the transaction after signing.
   **/ broadcast: Yt(Uf())
});
ot({
    /**
   * The base64 encoded PSBT after signing.
   */ psbt: nt(),
    /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/ txid: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(xQ),
        params: SQ,
        id: nt()
    }).entries
});
var AQ = "getAccounts", TQ = ot({
    /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */ purposes: An(go(vf)),
    /**
   * A message to be displayed to the user in the request prompt.
   */ message: Yt(nt())
});
An(ot({
    ...oP.entries,
    ...ot({
        walletType: nP
    }).entries
}));
ot({
    ...Gr.entries,
    ...ot({
        method: or(AQ),
        params: TQ,
        id: nt()
    }).entries
});
var kQ = "getBalance";
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(kQ),
        id: nt()
    }).entries
});
var IQ = "runes_etch", BQ = ot({
    amount: nt(),
    cap: nt(),
    heightStart: Yt(nt()),
    heightEnd: Yt(nt()),
    offsetStart: Yt(nt()),
    offsetEnd: Yt(nt())
}), OQ = ot({
    contentType: nt(),
    contentBase64: nt()
}), PQ = ot({
    runeName: nt(),
    divisibility: Yt(zn()),
    symbol: Yt(nt()),
    premine: Yt(nt()),
    isMintable: Uf(),
    delegateInscriptionId: Yt(nt()),
    destinationAddress: nt(),
    refundAddress: nt(),
    feeRate: zn(),
    appServiceFee: Yt(zn()),
    appServiceFeeAddress: Yt(nt()),
    terms: Yt(BQ),
    inscriptionDetails: Yt(OQ),
    network: Yt(go(Mn))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(IQ),
        params: PQ,
        id: nt()
    }).entries
});
var NQ = "runes_getBalance", MQ = ai($i());
ot({
    balances: An(ot({
        runeName: nt(),
        amount: nt(),
        divisibility: zn(),
        symbol: nt(),
        inscriptionId: ai(nt()),
        spendableBalance: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(NQ),
        params: MQ,
        id: nt()
    }).entries
});
var RQ = "runes_mint", CQ = ot({
    appServiceFee: Yt(zn()),
    appServiceFeeAddress: Yt(nt()),
    destinationAddress: nt(),
    feeRate: zn(),
    refundAddress: nt(),
    repeats: zn(),
    runeName: nt(),
    network: Yt(go(Mn))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(RQ),
        params: CQ,
        id: nt()
    }).entries
});
var UQ = "runes_transfer", $Q = ot({
    recipients: An(ot({
        runeName: nt(),
        amount: nt(),
        address: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(UQ),
        params: $Q,
        id: nt()
    }).entries
});
var LQ = "ord_getInscriptions", DQ = ot({
    offset: zn(),
    limit: zn()
});
ot({
    total: zn(),
    limit: zn(),
    offset: zn(),
    inscriptions: An(ot({
        inscriptionId: nt(),
        inscriptionNumber: nt(),
        address: nt(),
        collectionName: Yt(nt()),
        postage: nt(),
        contentLength: nt(),
        contentType: nt(),
        timestamp: zn(),
        offset: zn(),
        genesisTransaction: nt(),
        output: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(LQ),
        params: DQ,
        id: nt()
    }).entries
});
var FQ = "ord_sendInscriptions", zQ = ot({
    transfers: An(ot({
        address: nt(),
        inscriptionId: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(FQ),
        params: zQ,
        id: nt()
    }).entries
});
var Wu = async (e, t, r)=>{
    var o;
    let n = ((o = window.XverseProviders) == null ? void 0 : o.BitcoinProvider) || window.BitcoinProvider;
    if (!n) throw new Error("no wallet provider was found");
    if (!e) throw new Error("A wallet method is required");
    const i = await n.request(e, t);
    return ik(aP, i) ? {
        status: "error",
        error: i.error
    } : ik(sP, i) ? {
        status: "success",
        result: i.result
    } : {
        status: "error",
        error: {
            code: -32603,
            message: "Received unknown response from provider.",
            data: i
        }
    };
}, uk = (e, t, r)=>{
    var i;
    let n = ((i = window.XverseProviders) == null ? void 0 : i.BitcoinProvider) || window.BitcoinProvider;
    if (!n) throw new Error("no wallet provider was found");
    return n.addListener ? n.addListener(e, t) : (console.error("The wallet provider you are using does not support the addListener method. Please update your wallet provider."), ()=>{});
}, jQ = async (e)=>{
    var i, o;
    const t = await Mb(e.getProvider), { address: r, message: n } = e.payload;
    if (!r) throw new Error("An address is required to sign a message");
    if (!n) throw new Error("A message to be signed is required");
    try {
        const s = Lo.createUnsecuredToken(e.payload), a = await t.signMessage(s);
        (i = e.onFinish) == null || i.call(e, a);
    } catch (s) {
        console.error("[Connect] Error during sign message request", s), (o = e.onCancel) == null || o.call(e);
    }
}, HQ = (e)=>e.map((t)=>{
        const { address: r, amountSats: n } = t;
        return {
            address: r,
            amountSats: n.toString()
        };
    }), qQ = async (e)=>{
    var s, a;
    const t = await Mb(e.getProvider), { recipients: r, senderAddress: n, network: i, message: o } = e.payload;
    if (!r || r.length === 0) throw new Error("At least one recipient is required");
    if (r.some((u)=>typeof u.address != "string" || typeof u.amountSats != "bigint")) throw new Error("Incorrect recipient format");
    if (!n) throw new Error("The sender address is required");
    try {
        const u = HQ(r), f = {
            network: i,
            senderAddress: n,
            message: o,
            recipients: u
        }, c = Lo.createUnsecuredToken(f), l = await t.sendBtcTransaction(c);
        (s = e.onFinish) == null || s.call(e, l);
    } catch (u) {
        console.error("[Connect] Error during send BTC transaction request", u), (a = e.onCancel) == null || a.call(e);
    }
}, KQ = async (e)=>{
    var i, o;
    const t = await Mb(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
    if (!r) throw new Error("A value for psbtBase64 representing the tx hash is required");
    if (!n) throw new Error("An array specifying the inputs to be signed by the wallet is required");
    try {
        const s = Lo.createUnsecuredToken(e.payload), a = await t.signTransaction(s);
        (i = e.onFinish) == null || i.call(e, a);
    } catch (s) {
        console.error("[Connect] Error during sign transaction request", s), (o = e.onCancel) == null || o.call(e);
    }
};
const ln = dt.MAINNET, Ro = dt.SIGNET, Ni = dt.TESTNET, ao = dt.TESTNET4, yc = dt.FRACTAL_MAINNET, co = dt.FRACTAL_TESTNET, lve = dt.REGTEST, uP = dt.OYLNET, d_ = (e)=>e === dt.MAINNET ? Mn.Mainnet : e === dt.TESTNET ? Mn.Testnet : e === dt.TESTNET4 ? Mn.Testnet4 : e === dt.SIGNET ? Mn.Signet : (e === dt.FRACTAL_MAINNET || e === dt.FRACTAL_TESTNET, Mn.Mainnet), dve = (e)=>e === dt.MAINNET ? Hl.MAINNET : e === dt.TESTNET ? Hl.TESTNET : Hl.MAINNET, fP = (e)=>e === dt.MAINNET ? ro.MAINNET : e === dt.TESTNET ? ro.TESTNET : e === dt.TESTNET4 ? ro.TESTNET4 : e === dt.SIGNET ? ro.SIGNET : e === dt.FRACTAL_MAINNET ? ro.FRACTAL_MAINNET : e === dt.FRACTAL_TESTNET ? ro.FRACTAL_TESTNET : ro.MAINNET, WQ = (e)=>e === dt.MAINNET ? cu.BITCOIN_MAINNET : e === dt.TESTNET ? cu.BITCOIN_TESTNET : e === dt.SIGNET ? cu.BITCOIN_SIGNET : cu.BITCOIN_MAINNET, hve = (e)=>e === dt.MAINNET ? ko.MAINNET : e === dt.TESTNET ? ko.TESTNET : e === dt.TESTNET4 ? ko.TESTNET4 : e === dt.SIGNET ? ko.SIGNET : e === dt.FRACTAL_TESTNET ? ko.TESTNET : (e === dt.FRACTAL_MAINNET, ko.MAINNET), h_ = (e)=>e === dt.MAINNET ? eu.MAINNET : e === dt.TESTNET || e === dt.TESTNET4 || e === dt.SIGNET ? eu.TESTNET : (e === dt.FRACTAL_MAINNET || e === dt.FRACTAL_TESTNET, eu.MAINNET), VQ = (e)=>e === dt.MAINNET ? Qc.MAINNET : e === dt.TESTNET4 || e === dt.TESTNET ? Qc.TESTNET : e === dt.SIGNET ? Qc.SIGNET : (e === dt.MAINNET || e === dt.TESTNET, Qc.MAINNET), om = (e)=>e === ro.MAINNET ? dt.MAINNET : e === ro.TESTNET ? dt.TESTNET : e === ro.TESTNET4 ? dt.TESTNET4 : e === ro.SIGNET ? dt.SIGNET : e === ro.FRACTAL_MAINNET ? dt.FRACTAL_MAINNET : e === ro.FRACTAL_TESTNET ? dt.TESTNET : dt.MAINNET, GQ = (e)=>e === cu.BITCOIN_MAINNET ? dt.MAINNET : e === cu.BITCOIN_TESTNET ? dt.TESTNET : e === cu.BITCOIN_SIGNET ? dt.SIGNET : dt.MAINNET, p_ = (e)=>e === Yu.MAINNET ? dt.MAINNET : e === Yu.TESTNET ? dt.TESTNET : e === Yu.TESTNET4 ? dt.TESTNET4 : e === Yu.SIGNET ? dt.SIGNET : e === Yu.FRACTAL_MAINNET ? dt.FRACTAL_MAINNET : e === Yu.FRACTAL_TESTNET ? dt.FRACTAL_TESTNET : dt.MAINNET, pve = (e)=>e === Hl.MAINNET ? dt.MAINNET : e === Hl.TESTNET ? dt.TESTNET : dt.MAINNET, ZQ = (e)=>e === RE.MAINNET ? dt.MAINNET : e === RE.TESTNET ? dt.TESTNET : dt.MAINNET, fk = (e)=>e === ko.MAINNET ? dt.MAINNET : e === ko.TESTNET ? dt.TESTNET : e === ko.TESTNET4 ? dt.TESTNET4 : e === ko.SIGNET ? dt.SIGNET : e === ME.TESTNET ? dt.TESTNET : (e === ME.MAINNET, dt.MAINNET);
function lP(e, t) {
    return function() {
        return e.apply(t, arguments);
    };
}
const { toString: YQ } = Object.prototype, { getPrototypeOf: G3 } = Object, { iterator: Rb, toStringTag: dP } = Symbol, Cb = /* @__PURE__ */ ((e)=>(t)=>{
        const r = YQ.call(t);
        return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null)), js = (e)=>(e = e.toLowerCase(), (t)=>Cb(t) === e), Ub = (e)=>(t)=>typeof t === e, { isArray: Bd } = Array, up = Ub("undefined");
function XQ(e) {
    return e !== null && !up(e) && e.constructor !== null && !up(e.constructor) && ho(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const hP = js("ArrayBuffer");
function JQ(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && hP(e.buffer), t;
}
const QQ = Ub("string"), ho = Ub("function"), pP = Ub("number"), $b = (e)=>e !== null && typeof e == "object", eee = (e)=>e === !0 || e === !1, Oy = (e)=>{
    if (Cb(e) !== "object") return !1;
    const t = G3(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(dP in e) && !(Rb in e);
}, tee = js("Date"), ree = js("File"), nee = js("Blob"), iee = js("FileList"), oee = (e)=>$b(e) && ho(e.pipe), see = (e)=>{
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || ho(e.append) && ((t = Cb(e)) === "formdata" || // detect form-data instance
    t === "object" && ho(e.toString) && e.toString() === "[object FormData]"));
}, aee = js("URLSearchParams"), [cee, uee, fee, lee] = [
    "ReadableStream",
    "Request",
    "Response",
    "Headers"
].map(js), dee = (e)=>e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function c0(e, t, { allOwnKeys: r = !1 } = {}) {
    if (e === null || typeof e > "u") return;
    let n, i;
    if (typeof e != "object" && (e = [
        e
    ]), Bd(e)) for(n = 0, i = e.length; n < i; n++)t.call(null, e[n], n, e);
    else {
        const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length;
        let a;
        for(n = 0; n < s; n++)a = o[n], t.call(null, e[a], a, e);
    }
}
function gP(e, t) {
    t = t.toLowerCase();
    const r = Object.keys(e);
    let n = r.length, i;
    for(; n-- > 0;)if (i = r[n], t === i.toLowerCase()) return i;
    return null;
}
const sf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : ("TURBOPACK compile-time value", "undefined") < "u" ? window : xJ, yP = (e)=>!up(e) && e !== sf;
function zE() {
    const { caseless: e } = yP(this) && this || {}, t = {}, r = (n, i)=>{
        const o = e && gP(t, i) || i;
        Oy(t[o]) && Oy(n) ? t[o] = zE(t[o], n) : Oy(n) ? t[o] = zE({}, n) : Bd(n) ? t[o] = n.slice() : t[o] = n;
    };
    for(let n = 0, i = arguments.length; n < i; n++)arguments[n] && c0(arguments[n], r);
    return t;
}
const hee = (e, t, r, { allOwnKeys: n } = {})=>(c0(t, (i, o)=>{
        r && ho(i) ? e[o] = lP(i, r) : e[o] = i;
    }, {
        allOwnKeys: n
    }), e), pee = (e)=>(e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), gee = (e, t, r, n)=>{
    e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
        value: t.prototype
    }), r && Object.assign(e.prototype, r);
}, yee = (e, t, r, n)=>{
    let i, o, s;
    const a = {};
    if (t = t || {}, e == null) return t;
    do {
        for(i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0;)s = i[o], (!n || n(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0);
        e = r !== !1 && G3(e);
    }while (e && (!r || r(e, t)) && e !== Object.prototype)
    return t;
}, mee = (e, t, r)=>{
    e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
    const n = e.indexOf(t, r);
    return n !== -1 && n === r;
}, bee = (e)=>{
    if (!e) return null;
    if (Bd(e)) return e;
    let t = e.length;
    if (!pP(t)) return null;
    const r = new Array(t);
    for(; t-- > 0;)r[t] = e[t];
    return r;
}, wee = /* @__PURE__ */ ((e)=>(t)=>e && t instanceof e)(typeof Uint8Array < "u" && G3(Uint8Array)), vee = (e, t)=>{
    const n = (e && e[Rb]).call(e);
    let i;
    for(; (i = n.next()) && !i.done;){
        const o = i.value;
        t.call(e, o[0], o[1]);
    }
}, _ee = (e, t)=>{
    let r;
    const n = [];
    for(; (r = e.exec(t)) !== null;)n.push(r);
    return n;
}, Eee = js("HTMLFormElement"), xee = (e)=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(r, n, i) {
        return n.toUpperCase() + i;
    }), lk = (({ hasOwnProperty: e })=>(t, r)=>e.call(t, r))(Object.prototype), See = js("RegExp"), mP = (e, t)=>{
    const r = Object.getOwnPropertyDescriptors(e), n = {};
    c0(r, (i, o)=>{
        let s;
        (s = t(i, o, e)) !== !1 && (n[o] = s || i);
    }), Object.defineProperties(e, n);
}, Aee = (e)=>{
    mP(e, (t, r)=>{
        if (ho(e) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(r) !== -1) return !1;
        const n = e[r];
        if (ho(n)) {
            if (t.enumerable = !1, "writable" in t) {
                t.writable = !1;
                return;
            }
            t.set || (t.set = ()=>{
                throw Error("Can not rewrite read-only method '" + r + "'");
            });
        }
    });
}, Tee = (e, t)=>{
    const r = {}, n = (i)=>{
        i.forEach((o)=>{
            r[o] = !0;
        });
    };
    return Bd(e) ? n(e) : n(String(e).split(t)), r;
}, kee = ()=>{}, Iee = (e, t)=>e != null && Number.isFinite(e = +e) ? e : t;
function Bee(e) {
    return !!(e && ho(e.append) && e[dP] === "FormData" && e[Rb]);
}
const Oee = (e)=>{
    const t = new Array(10), r = (n, i)=>{
        if ($b(n)) {
            if (t.indexOf(n) >= 0) return;
            if (!("toJSON" in n)) {
                t[i] = n;
                const o = Bd(n) ? [] : {};
                return c0(n, (s, a)=>{
                    const u = r(s, i + 1);
                    !up(u) && (o[a] = u);
                }), t[i] = void 0, o;
            }
        }
        return n;
    };
    return r(e, 0);
}, Pee = js("AsyncFunction"), Nee = (e)=>e && ($b(e) || ho(e)) && ho(e.then) && ho(e.catch), bP = ((e, t)=>e ? setImmediate : t ? ((r, n)=>(sf.addEventListener("message", ({ source: i, data: o })=>{
            i === sf && o === r && n.length && n.shift()();
        }, !1), (i)=>{
            n.push(i), sf.postMessage(r, "*");
        }))(`axios@${Math.random()}`, []) : (r)=>setTimeout(r))(typeof setImmediate == "function", ho(sf.postMessage)), Mee = typeof queueMicrotask < "u" ? queueMicrotask.bind(sf) : typeof bn < "u" && bn.nextTick || bP, Ree = (e)=>e != null && ho(e[Rb]), Je = {
    isArray: Bd,
    isArrayBuffer: hP,
    isBuffer: XQ,
    isFormData: see,
    isArrayBufferView: JQ,
    isString: QQ,
    isNumber: pP,
    isBoolean: eee,
    isObject: $b,
    isPlainObject: Oy,
    isReadableStream: cee,
    isRequest: uee,
    isResponse: fee,
    isHeaders: lee,
    isUndefined: up,
    isDate: tee,
    isFile: ree,
    isBlob: nee,
    isRegExp: See,
    isFunction: ho,
    isStream: oee,
    isURLSearchParams: aee,
    isTypedArray: wee,
    isFileList: iee,
    forEach: c0,
    merge: zE,
    extend: hee,
    trim: dee,
    stripBOM: pee,
    inherits: gee,
    toFlatObject: yee,
    kindOf: Cb,
    kindOfTest: js,
    endsWith: mee,
    toArray: bee,
    forEachEntry: vee,
    matchAll: _ee,
    isHTMLForm: Eee,
    hasOwnProperty: lk,
    hasOwnProp: lk,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: mP,
    freezeMethods: Aee,
    toObjectSet: Tee,
    toCamelCase: xee,
    noop: kee,
    toFiniteNumber: Iee,
    findKey: gP,
    global: sf,
    isContextDefined: yP,
    isSpecCompliantForm: Bee,
    toJSONObject: Oee,
    isAsyncFn: Pee,
    isThenable: Nee,
    setImmediate: bP,
    asap: Mee,
    isIterable: Ree
};
function dr(e, t, r, n, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Je.inherits(dr, Error, {
    toJSON: function() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: Je.toJSONObject(this.config),
            code: this.code,
            status: this.status
        };
    }
});
const wP = dr.prototype, vP = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((e)=>{
    vP[e] = {
        value: e
    };
});
Object.defineProperties(dr, vP);
Object.defineProperty(wP, "isAxiosError", {
    value: !0
});
dr.from = (e, t, r, n, i, o)=>{
    const s = Object.create(wP);
    return Je.toFlatObject(e, s, function(u) {
        return u !== Error.prototype;
    }, (a)=>a !== "isAxiosError"), dr.call(s, e.message, t, r, n, i), s.cause = e, s.name = e.name, o && Object.assign(s, o), s;
};
const Cee = null;
function jE(e) {
    return Je.isPlainObject(e) || Je.isArray(e);
}
function _P(e) {
    return Je.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function dk(e, t, r) {
    return e ? e.concat(t).map(function(i, o) {
        return i = _P(i), !r && o ? "[" + i + "]" : i;
    }).join(r ? "." : "") : t;
}
function Uee(e) {
    return Je.isArray(e) && !e.some(jE);
}
const $ee = Je.toFlatObject(Je, {}, null, function(t) {
    return /^is[A-Z]/.test(t);
});
function Lb(e, t, r) {
    if (!Je.isObject(e)) throw new TypeError("target must be an object");
    t = t || new FormData(), r = Je.toFlatObject(r, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(A, O) {
        return !Je.isUndefined(O[A]);
    });
    const n = r.metaTokens, i = r.visitor || c, o = r.dots, s = r.indexes, u = (r.Blob || typeof Blob < "u" && Blob) && Je.isSpecCompliantForm(t);
    if (!Je.isFunction(i)) throw new TypeError("visitor must be a function");
    function f(_) {
        if (_ === null) return "";
        if (Je.isDate(_)) return _.toISOString();
        if (Je.isBoolean(_)) return _.toString();
        if (!u && Je.isBlob(_)) throw new dr("Blob is not supported. Use a Buffer instead.");
        return Je.isArrayBuffer(_) || Je.isTypedArray(_) ? u && typeof Blob == "function" ? new Blob([
            _
        ]) : We.from(_) : _;
    }
    function c(_, A, O) {
        let N = _;
        if (_ && !O && typeof _ == "object") {
            if (Je.endsWith(A, "{}")) A = n ? A : A.slice(0, -2), _ = JSON.stringify(_);
            else if (Je.isArray(_) && Uee(_) || (Je.isFileList(_) || Je.endsWith(A, "[]")) && (N = Je.toArray(_))) return A = _P(A), N.forEach(function(D, H) {
                !(Je.isUndefined(D) || D === null) && t.append(// eslint-disable-next-line no-nested-ternary
                s === !0 ? dk([
                    A
                ], H, o) : s === null ? A : A + "[]", f(D));
            }), !1;
        }
        return jE(_) ? !0 : (t.append(dk(O, A, o), f(_)), !1);
    }
    const l = [], p = Object.assign($ee, {
        defaultVisitor: c,
        convertValue: f,
        isVisitable: jE
    });
    function y(_, A) {
        if (!Je.isUndefined(_)) {
            if (l.indexOf(_) !== -1) throw Error("Circular reference detected in " + A.join("."));
            l.push(_), Je.forEach(_, function(N, U) {
                (!(Je.isUndefined(N) || N === null) && i.call(t, N, Je.isString(U) ? U.trim() : U, A, p)) === !0 && y(N, A ? A.concat(U) : [
                    U
                ]);
            }), l.pop();
        }
    }
    if (!Je.isObject(e)) throw new TypeError("data must be an object");
    return y(e), t;
}
function hk(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
        return t[n];
    });
}
function Z3(e, t) {
    this._pairs = [], e && Lb(e, this, t);
}
const EP = Z3.prototype;
EP.append = function(t, r) {
    this._pairs.push([
        t,
        r
    ]);
};
EP.toString = function(t) {
    const r = t ? function(n) {
        return t.call(this, n, hk);
    } : hk;
    return this._pairs.map(function(i) {
        return r(i[0]) + "=" + r(i[1]);
    }, "").join("&");
};
function Lee(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function xP(e, t, r) {
    if (!t) return e;
    const n = r && r.encode || Lee;
    Je.isFunction(r) && (r = {
        serialize: r
    });
    const i = r && r.serialize;
    let o;
    if (i ? o = i(t, r) : o = Je.isURLSearchParams(t) ? t.toString() : new Z3(t, r).toString(n), o) {
        const s = e.indexOf("#");
        s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
    }
    return e;
}
class pk {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(t, r, n) {
        return this.handlers.push({
            fulfilled: t,
            rejected: r,
            synchronous: n ? n.synchronous : !1,
            runWhen: n ? n.runWhen : null
        }), this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(t) {
        this.handlers[t] && (this.handlers[t] = null);
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        this.handlers && (this.handlers = []);
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(t) {
        Je.forEach(this.handlers, function(n) {
            n !== null && t(n);
        });
    }
}
const SP = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}, Dee = typeof URLSearchParams < "u" ? URLSearchParams : Z3, Fee = typeof FormData < "u" ? FormData : null, zee = typeof Blob < "u" ? Blob : null, jee = {
    isBrowser: !0,
    classes: {
        URLSearchParams: Dee,
        FormData: Fee,
        Blob: zee
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
}, Y3 = ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u", HE = typeof navigator == "object" && navigator || void 0, Hee = Y3 && (!HE || [
    "ReactNative",
    "NativeScript",
    "NS"
].indexOf(HE.product) < 0), qee = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Kee = Y3 && window.location.href || "http://localhost", Wee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: Y3,
    hasStandardBrowserEnv: Hee,
    hasStandardBrowserWebWorkerEnv: qee,
    navigator: HE,
    origin: Kee
}, Symbol.toStringTag, {
    value: "Module"
})), Mi = {
    ...Wee,
    ...jee
};
function Vee(e, t) {
    return Lb(e, new Mi.classes.URLSearchParams(), Object.assign({
        visitor: function(r, n, i, o) {
            return Mi.isNode && Je.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
        }
    }, t));
}
function Gee(e) {
    return Je.matchAll(/\w+|\[(\w*)]/g, e).map((t)=>t[0] === "[]" ? "" : t[1] || t[0]);
}
function Zee(e) {
    const t = {}, r = Object.keys(e);
    let n;
    const i = r.length;
    let o;
    for(n = 0; n < i; n++)o = r[n], t[o] = e[o];
    return t;
}
function AP(e) {
    function t(r, n, i, o) {
        let s = r[o++];
        if (s === "__proto__") return !0;
        const a = Number.isFinite(+s), u = o >= r.length;
        return s = !s && Je.isArray(i) ? i.length : s, u ? (Je.hasOwnProp(i, s) ? i[s] = [
            i[s],
            n
        ] : i[s] = n, !a) : ((!i[s] || !Je.isObject(i[s])) && (i[s] = []), t(r, n, i[s], o) && Je.isArray(i[s]) && (i[s] = Zee(i[s])), !a);
    }
    if (Je.isFormData(e) && Je.isFunction(e.entries)) {
        const r = {};
        return Je.forEachEntry(e, (n, i)=>{
            t(Gee(n), i, r, 0);
        }), r;
    }
    return null;
}
function Yee(e, t, r) {
    if (Je.isString(e)) try {
        return (t || JSON.parse)(e), Je.trim(e);
    } catch (n) {
        if (n.name !== "SyntaxError") throw n;
    }
    return (r || JSON.stringify)(e);
}
const u0 = {
    transitional: SP,
    adapter: [
        "xhr",
        "http",
        "fetch"
    ],
    transformRequest: [
        function(t, r) {
            const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, o = Je.isObject(t);
            if (o && Je.isHTMLForm(t) && (t = new FormData(t)), Je.isFormData(t)) return i ? JSON.stringify(AP(t)) : t;
            if (Je.isArrayBuffer(t) || Je.isBuffer(t) || Je.isStream(t) || Je.isFile(t) || Je.isBlob(t) || Je.isReadableStream(t)) return t;
            if (Je.isArrayBufferView(t)) return t.buffer;
            if (Je.isURLSearchParams(t)) return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
            let a;
            if (o) {
                if (n.indexOf("application/x-www-form-urlencoded") > -1) return Vee(t, this.formSerializer).toString();
                if ((a = Je.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
                    const u = this.env && this.env.FormData;
                    return Lb(a ? {
                        "files[]": t
                    } : t, u && new u(), this.formSerializer);
                }
            }
            return o || i ? (r.setContentType("application/json", !1), Yee(t)) : t;
        }
    ],
    transformResponse: [
        function(t) {
            const r = this.transitional || u0.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
            if (Je.isResponse(t) || Je.isReadableStream(t)) return t;
            if (t && Je.isString(t) && (n && !this.responseType || i)) {
                const s = !(r && r.silentJSONParsing) && i;
                try {
                    return JSON.parse(t);
                } catch (a) {
                    if (s) throw a.name === "SyntaxError" ? dr.from(a, dr.ERR_BAD_RESPONSE, this, null, this.response) : a;
                }
            }
            return t;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: Mi.classes.FormData,
        Blob: Mi.classes.Blob
    },
    validateStatus: function(t) {
        return t >= 200 && t < 300;
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Je.forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (e)=>{
    u0.headers[e] = {};
});
const Xee = Je.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]), Jee = (e)=>{
    const t = {};
    let r, n, i;
    return e && e.split(`
`).forEach(function(s) {
        i = s.indexOf(":"), r = s.substring(0, i).trim().toLowerCase(), n = s.substring(i + 1).trim(), !(!r || t[r] && Xee[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [
            n
        ] : t[r] = t[r] ? t[r] + ", " + n : n);
    }), t;
}, gk = Symbol("internals");
function hh(e) {
    return e && String(e).trim().toLowerCase();
}
function Py(e) {
    return e === !1 || e == null ? e : Je.isArray(e) ? e.map(Py) : String(e);
}
function Qee(e) {
    const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let n;
    for(; n = r.exec(e);)t[n[1]] = n[2];
    return t;
}
const ete = (e)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function g_(e, t, r, n, i) {
    if (Je.isFunction(n)) return n.call(this, t, r);
    if (i && (t = r), !!Je.isString(t)) {
        if (Je.isString(n)) return t.indexOf(n) !== -1;
        if (Je.isRegExp(n)) return n.test(t);
    }
}
function tte(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n)=>r.toUpperCase() + n);
}
function rte(e, t) {
    const r = Je.toCamelCase(" " + t);
    [
        "get",
        "set",
        "has"
    ].forEach((n)=>{
        Object.defineProperty(e, n + r, {
            value: function(i, o, s) {
                return this[n].call(this, t, i, o, s);
            },
            configurable: !0
        });
    });
}
let po = class {
    constructor(t){
        t && this.set(t);
    }
    set(t, r, n) {
        const i = this;
        function o(a, u, f) {
            const c = hh(u);
            if (!c) throw new Error("header name must be a non-empty string");
            const l = Je.findKey(i, c);
            (!l || i[l] === void 0 || f === !0 || f === void 0 && i[l] !== !1) && (i[l || u] = Py(a));
        }
        const s = (a, u)=>Je.forEach(a, (f, c)=>o(f, c, u));
        if (Je.isPlainObject(t) || t instanceof this.constructor) s(t, r);
        else if (Je.isString(t) && (t = t.trim()) && !ete(t)) s(Jee(t), r);
        else if (Je.isObject(t) && Je.isIterable(t)) {
            let a = {}, u, f;
            for (const c of t){
                if (!Je.isArray(c)) throw TypeError("Object iterator must return a key-value pair");
                a[f = c[0]] = (u = a[f]) ? Je.isArray(u) ? [
                    ...u,
                    c[1]
                ] : [
                    u,
                    c[1]
                ] : c[1];
            }
            s(a, r);
        } else t != null && o(r, t, n);
        return this;
    }
    get(t, r) {
        if (t = hh(t), t) {
            const n = Je.findKey(this, t);
            if (n) {
                const i = this[n];
                if (!r) return i;
                if (r === !0) return Qee(i);
                if (Je.isFunction(r)) return r.call(this, i, n);
                if (Je.isRegExp(r)) return r.exec(i);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(t, r) {
        if (t = hh(t), t) {
            const n = Je.findKey(this, t);
            return !!(n && this[n] !== void 0 && (!r || g_(this, this[n], n, r)));
        }
        return !1;
    }
    delete(t, r) {
        const n = this;
        let i = !1;
        function o(s) {
            if (s = hh(s), s) {
                const a = Je.findKey(n, s);
                a && (!r || g_(n, n[a], a, r)) && (delete n[a], i = !0);
            }
        }
        return Je.isArray(t) ? t.forEach(o) : o(t), i;
    }
    clear(t) {
        const r = Object.keys(this);
        let n = r.length, i = !1;
        for(; n--;){
            const o = r[n];
            (!t || g_(this, this[o], o, t, !0)) && (delete this[o], i = !0);
        }
        return i;
    }
    normalize(t) {
        const r = this, n = {};
        return Je.forEach(this, (i, o)=>{
            const s = Je.findKey(n, o);
            if (s) {
                r[s] = Py(i), delete r[o];
                return;
            }
            const a = t ? tte(o) : String(o).trim();
            a !== o && delete r[o], r[a] = Py(i), n[a] = !0;
        }), this;
    }
    concat(...t) {
        return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
        const r = /* @__PURE__ */ Object.create(null);
        return Je.forEach(this, (n, i)=>{
            n != null && n !== !1 && (r[i] = t && Je.isArray(n) ? n.join(", ") : n);
        }), r;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([t, r])=>t + ": " + r).join(`
`);
    }
    getSetCookie() {
        return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(t) {
        return t instanceof this ? t : new this(t);
    }
    static concat(t, ...r) {
        const n = new this(t);
        return r.forEach((i)=>n.set(i)), n;
    }
    static accessor(t) {
        const n = (this[gk] = this[gk] = {
            accessors: {}
        }).accessors, i = this.prototype;
        function o(s) {
            const a = hh(s);
            n[a] || (rte(i, s), n[a] = !0);
        }
        return Je.isArray(t) ? t.forEach(o) : o(t), this;
    }
};
po.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
Je.reduceDescriptors(po.prototype, ({ value: e }, t)=>{
    let r = t[0].toUpperCase() + t.slice(1);
    return {
        get: ()=>e,
        set (n) {
            this[r] = n;
        }
    };
});
Je.freezeMethods(po);
function y_(e, t) {
    const r = this || u0, n = t || r, i = po.from(n.headers);
    let o = n.data;
    return Je.forEach(e, function(a) {
        o = a.call(r, o, i.normalize(), t ? t.status : void 0);
    }), i.normalize(), o;
}
function TP(e) {
    return !!(e && e.__CANCEL__);
}
function Od(e, t, r) {
    dr.call(this, e ?? "canceled", dr.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Je.inherits(Od, dr, {
    __CANCEL__: !0
});
function kP(e, t, r) {
    const n = r.config.validateStatus;
    !r.status || !n || n(r.status) ? e(r) : t(new dr("Request failed with status code " + r.status, [
        dr.ERR_BAD_REQUEST,
        dr.ERR_BAD_RESPONSE
    ][Math.floor(r.status / 100) - 4], r.config, r.request, r));
}
function nte(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
}
function ite(e, t) {
    e = e || 10;
    const r = new Array(e), n = new Array(e);
    let i = 0, o = 0, s;
    return t = t !== void 0 ? t : 1e3, function(u) {
        const f = Date.now(), c = n[o];
        s || (s = f), r[i] = u, n[i] = f;
        let l = o, p = 0;
        for(; l !== i;)p += r[l++], l = l % e;
        if (i = (i + 1) % e, i === o && (o = (o + 1) % e), f - s < t) return;
        const y = c && f - c;
        return y ? Math.round(p * 1e3 / y) : void 0;
    };
}
function ote(e, t) {
    let r = 0, n = 1e3 / t, i, o;
    const s = (f, c = Date.now())=>{
        r = c, i = null, o && (clearTimeout(o), o = null), e.apply(null, f);
    };
    return [
        (...f)=>{
            const c = Date.now(), l = c - r;
            l >= n ? s(f, c) : (i = f, o || (o = setTimeout(()=>{
                o = null, s(i);
            }, n - l)));
        },
        ()=>i && s(i)
    ];
}
const sm = (e, t, r = 3)=>{
    let n = 0;
    const i = ite(50, 250);
    return ote((o)=>{
        const s = o.loaded, a = o.lengthComputable ? o.total : void 0, u = s - n, f = i(u), c = s <= a;
        n = s;
        const l = {
            loaded: s,
            total: a,
            progress: a ? s / a : void 0,
            bytes: u,
            rate: f || void 0,
            estimated: f && a && c ? (a - s) / f : void 0,
            event: o,
            lengthComputable: a != null,
            [t ? "download" : "upload"]: !0
        };
        e(l);
    }, r);
}, yk = (e, t)=>{
    const r = e != null;
    return [
        (n)=>t[0]({
                lengthComputable: r,
                total: e,
                loaded: n
            }),
        t[1]
    ];
}, mk = (e)=>(...t)=>Je.asap(()=>e(...t)), ste = Mi.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t)=>(r)=>(r = new URL(r, Mi.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(new URL(Mi.origin), Mi.navigator && /(msie|trident)/i.test(Mi.navigator.userAgent)) : ()=>!0, ate = Mi.hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (e, t, r, n, i, o) {
        const s = [
            e + "=" + encodeURIComponent(t)
        ];
        Je.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), Je.isString(n) && s.push("path=" + n), Je.isString(i) && s.push("domain=" + i), o === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read (e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null;
    },
    remove (e) {
        this.write(e, "", Date.now() - 864e5);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};
function cte(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function ute(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function IP(e, t, r) {
    let n = !cte(t);
    return e && (n || r == !1) ? ute(e, t) : t;
}
const bk = (e)=>e instanceof po ? {
        ...e
    } : e;
function Ef(e, t) {
    t = t || {};
    const r = {};
    function n(f, c, l, p) {
        return Je.isPlainObject(f) && Je.isPlainObject(c) ? Je.merge.call({
            caseless: p
        }, f, c) : Je.isPlainObject(c) ? Je.merge({}, c) : Je.isArray(c) ? c.slice() : c;
    }
    function i(f, c, l, p) {
        if (Je.isUndefined(c)) {
            if (!Je.isUndefined(f)) return n(void 0, f, l, p);
        } else return n(f, c, l, p);
    }
    function o(f, c) {
        if (!Je.isUndefined(c)) return n(void 0, c);
    }
    function s(f, c) {
        if (Je.isUndefined(c)) {
            if (!Je.isUndefined(f)) return n(void 0, f);
        } else return n(void 0, c);
    }
    function a(f, c, l) {
        if (l in t) return n(f, c);
        if (l in e) return n(void 0, f);
    }
    const u = {
        url: o,
        method: o,
        data: o,
        baseURL: s,
        transformRequest: s,
        transformResponse: s,
        paramsSerializer: s,
        timeout: s,
        timeoutMessage: s,
        withCredentials: s,
        withXSRFToken: s,
        adapter: s,
        responseType: s,
        xsrfCookieName: s,
        xsrfHeaderName: s,
        onUploadProgress: s,
        onDownloadProgress: s,
        decompress: s,
        maxContentLength: s,
        maxBodyLength: s,
        beforeRedirect: s,
        transport: s,
        httpAgent: s,
        httpsAgent: s,
        cancelToken: s,
        socketPath: s,
        responseEncoding: s,
        validateStatus: a,
        headers: (f, c, l)=>i(bk(f), bk(c), l, !0)
    };
    return Je.forEach(Object.keys(Object.assign({}, e, t)), function(c) {
        const l = u[c] || i, p = l(e[c], t[c], c);
        Je.isUndefined(p) && l !== a || (r[c] = p);
    }), r;
}
const BP = (e)=>{
    const t = Ef({}, e);
    let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: a } = t;
    t.headers = s = po.from(s), t.url = xP(IP(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && s.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
    let u;
    if (Je.isFormData(r)) {
        if (Mi.hasStandardBrowserEnv || Mi.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0);
        else if ((u = s.getContentType()) !== !1) {
            const [f, ...c] = u ? u.split(";").map((l)=>l.trim()).filter(Boolean) : [];
            s.setContentType([
                f || "multipart/form-data",
                ...c
            ].join("; "));
        }
    }
    if (Mi.hasStandardBrowserEnv && (n && Je.isFunction(n) && (n = n(t)), n || n !== !1 && ste(t.url))) {
        const f = i && o && ate.read(o);
        f && s.set(i, f);
    }
    return t;
}, fte = typeof XMLHttpRequest < "u", lte = fte && function(e) {
    return new Promise(function(r, n) {
        const i = BP(e);
        let o = i.data;
        const s = po.from(i.headers).normalize();
        let { responseType: a, onUploadProgress: u, onDownloadProgress: f } = i, c, l, p, y, _;
        function A() {
            y && y(), _ && _(), i.cancelToken && i.cancelToken.unsubscribe(c), i.signal && i.signal.removeEventListener("abort", c);
        }
        let O = new XMLHttpRequest();
        O.open(i.method.toUpperCase(), i.url, !0), O.timeout = i.timeout;
        function N() {
            if (!O) return;
            const D = po.from("getAllResponseHeaders" in O && O.getAllResponseHeaders()), K = {
                data: !a || a === "text" || a === "json" ? O.responseText : O.response,
                status: O.status,
                statusText: O.statusText,
                headers: D,
                config: e,
                request: O
            };
            kP(function(Q) {
                r(Q), A();
            }, function(Q) {
                n(Q), A();
            }, K), O = null;
        }
        "onloadend" in O ? O.onloadend = N : O.onreadystatechange = function() {
            !O || O.readyState !== 4 || O.status === 0 && !(O.responseURL && O.responseURL.indexOf("file:") === 0) || setTimeout(N);
        }, O.onabort = function() {
            O && (n(new dr("Request aborted", dr.ECONNABORTED, e, O)), O = null);
        }, O.onerror = function() {
            n(new dr("Network Error", dr.ERR_NETWORK, e, O)), O = null;
        }, O.ontimeout = function() {
            let H = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
            const K = i.transitional || SP;
            i.timeoutErrorMessage && (H = i.timeoutErrorMessage), n(new dr(H, K.clarifyTimeoutError ? dr.ETIMEDOUT : dr.ECONNABORTED, e, O)), O = null;
        }, o === void 0 && s.setContentType(null), "setRequestHeader" in O && Je.forEach(s.toJSON(), function(H, K) {
            O.setRequestHeader(K, H);
        }), Je.isUndefined(i.withCredentials) || (O.withCredentials = !!i.withCredentials), a && a !== "json" && (O.responseType = i.responseType), f && ([p, _] = sm(f, !0), O.addEventListener("progress", p)), u && O.upload && ([l, y] = sm(u), O.upload.addEventListener("progress", l), O.upload.addEventListener("loadend", y)), (i.cancelToken || i.signal) && (c = (D)=>{
            O && (n(!D || D.type ? new Od(null, e, O) : D), O.abort(), O = null);
        }, i.cancelToken && i.cancelToken.subscribe(c), i.signal && (i.signal.aborted ? c() : i.signal.addEventListener("abort", c)));
        const U = nte(i.url);
        if (U && Mi.protocols.indexOf(U) === -1) {
            n(new dr("Unsupported protocol " + U + ":", dr.ERR_BAD_REQUEST, e));
            return;
        }
        O.send(o || null);
    });
}, dte = (e, t)=>{
    const { length: r } = e = e ? e.filter(Boolean) : [];
    if (t || r) {
        let n = new AbortController(), i;
        const o = function(f) {
            if (!i) {
                i = !0, a();
                const c = f instanceof Error ? f : this.reason;
                n.abort(c instanceof dr ? c : new Od(c instanceof Error ? c.message : c));
            }
        };
        let s = t && setTimeout(()=>{
            s = null, o(new dr(`timeout ${t} of ms exceeded`, dr.ETIMEDOUT));
        }, t);
        const a = ()=>{
            e && (s && clearTimeout(s), s = null, e.forEach((f)=>{
                f.unsubscribe ? f.unsubscribe(o) : f.removeEventListener("abort", o);
            }), e = null);
        };
        e.forEach((f)=>f.addEventListener("abort", o));
        const { signal: u } = n;
        return u.unsubscribe = ()=>Je.asap(a), u;
    }
}, hte = function*(e, t) {
    let r = e.byteLength;
    if (r < t) {
        yield e;
        return;
    }
    let n = 0, i;
    for(; n < r;)i = n + t, yield e.slice(n, i), n = i;
}, pte = async function*(e, t) {
    for await (const r of gte(e))yield* hte(r, t);
}, gte = async function*(e) {
    if (e[Symbol.asyncIterator]) {
        yield* e;
        return;
    }
    const t = e.getReader();
    try {
        for(;;){
            const { done: r, value: n } = await t.read();
            if (r) break;
            yield n;
        }
    } finally{
        await t.cancel();
    }
}, wk = (e, t, r, n)=>{
    const i = pte(e, t);
    let o = 0, s, a = (u)=>{
        s || (s = !0, n && n(u));
    };
    return new ReadableStream({
        async pull (u) {
            try {
                const { done: f, value: c } = await i.next();
                if (f) {
                    a(), u.close();
                    return;
                }
                let l = c.byteLength;
                if (r) {
                    let p = o += l;
                    r(p);
                }
                u.enqueue(new Uint8Array(c));
            } catch (f) {
                throw a(f), f;
            }
        },
        cancel (u) {
            return a(u), i.return();
        }
    }, {
        highWaterMark: 2
    });
}, Db = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", OP = Db && typeof ReadableStream == "function", yte = Db && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e)=>(t)=>e.encode(t))(new TextEncoder()) : async (e)=>new Uint8Array(await new Response(e).arrayBuffer())), PP = (e, ...t)=>{
    try {
        return !!e(...t);
    } catch  {
        return !1;
    }
}, mte = OP && PP(()=>{
    let e = !1;
    const t = new Request(Mi.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex () {
            return e = !0, "half";
        }
    }).headers.has("Content-Type");
    return e && !t;
}), vk = 64 * 1024, qE = OP && PP(()=>Je.isReadableStream(new Response("").body)), am = {
    stream: qE && ((e)=>e.body)
};
Db && ((e)=>{
    [
        "text",
        "arrayBuffer",
        "blob",
        "formData",
        "stream"
    ].forEach((t)=>{
        !am[t] && (am[t] = Je.isFunction(e[t]) ? (r)=>r[t]() : (r, n)=>{
            throw new dr(`Response type '${t}' is not supported`, dr.ERR_NOT_SUPPORT, n);
        });
    });
})(new Response());
const bte = async (e)=>{
    if (e == null) return 0;
    if (Je.isBlob(e)) return e.size;
    if (Je.isSpecCompliantForm(e)) return (await new Request(Mi.origin, {
        method: "POST",
        body: e
    }).arrayBuffer()).byteLength;
    if (Je.isArrayBufferView(e) || Je.isArrayBuffer(e)) return e.byteLength;
    if (Je.isURLSearchParams(e) && (e = e + ""), Je.isString(e)) return (await yte(e)).byteLength;
}, wte = async (e, t)=>{
    const r = Je.toFiniteNumber(e.getContentLength());
    return r ?? bte(t);
}, vte = Db && (async (e)=>{
    let { url: t, method: r, data: n, signal: i, cancelToken: o, timeout: s, onDownloadProgress: a, onUploadProgress: u, responseType: f, headers: c, withCredentials: l = "same-origin", fetchOptions: p } = BP(e);
    f = f ? (f + "").toLowerCase() : "text";
    let y = dte([
        i,
        o && o.toAbortSignal()
    ], s), _;
    const A = y && y.unsubscribe && (()=>{
        y.unsubscribe();
    });
    let O;
    try {
        if (u && mte && r !== "get" && r !== "head" && (O = await wte(c, n)) !== 0) {
            let K = new Request(t, {
                method: "POST",
                body: n,
                duplex: "half"
            }), re;
            if (Je.isFormData(n) && (re = K.headers.get("content-type")) && c.setContentType(re), K.body) {
                const [Q, G] = yk(O, sm(mk(u)));
                n = wk(K.body, vk, Q, G);
            }
        }
        Je.isString(l) || (l = l ? "include" : "omit");
        const N = "credentials" in Request.prototype;
        _ = new Request(t, {
            ...p,
            signal: y,
            method: r.toUpperCase(),
            headers: c.normalize().toJSON(),
            body: n,
            duplex: "half",
            credentials: N ? l : void 0
        });
        let U = await fetch(_, p);
        const D = qE && (f === "stream" || f === "response");
        if (qE && (a || D && A)) {
            const K = {};
            [
                "status",
                "statusText",
                "headers"
            ].forEach((R)=>{
                K[R] = U[R];
            });
            const re = Je.toFiniteNumber(U.headers.get("content-length")), [Q, G] = a && yk(re, sm(mk(a), !0)) || [];
            U = new Response(wk(U.body, vk, Q, ()=>{
                G && G(), A && A();
            }), K);
        }
        f = f || "text";
        let H = await am[Je.findKey(am, f) || "text"](U, e);
        return !D && A && A(), await new Promise((K, re)=>{
            kP(K, re, {
                data: H,
                headers: po.from(U.headers),
                status: U.status,
                statusText: U.statusText,
                config: e,
                request: _
            });
        });
    } catch (N) {
        throw A && A(), N && N.name === "TypeError" && /Load failed|fetch/i.test(N.message) ? Object.assign(new dr("Network Error", dr.ERR_NETWORK, e, _), {
            cause: N.cause || N
        }) : dr.from(N, N && N.code, e, _);
    }
}), KE = {
    http: Cee,
    xhr: lte,
    fetch: vte
};
Je.forEach(KE, (e, t)=>{
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            });
        } catch  {}
        Object.defineProperty(e, "adapterName", {
            value: t
        });
    }
});
const _k = (e)=>`- ${e}`, _te = (e)=>Je.isFunction(e) || e === null || e === !1, NP = {
    getAdapter: (e)=>{
        e = Je.isArray(e) ? e : [
            e
        ];
        const { length: t } = e;
        let r, n;
        const i = {};
        for(let o = 0; o < t; o++){
            r = e[o];
            let s;
            if (n = r, !_te(r) && (n = KE[(s = String(r)).toLowerCase()], n === void 0)) throw new dr(`Unknown adapter '${s}'`);
            if (n) break;
            i[s || "#" + o] = n;
        }
        if (!n) {
            const o = Object.entries(i).map(([a, u])=>`adapter ${a} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build"));
            let s = t ? o.length > 1 ? `since :
` + o.map(_k).join(`
`) : " " + _k(o[0]) : "as no adapter specified";
            throw new dr("There is no suitable adapter to dispatch the request " + s, "ERR_NOT_SUPPORT");
        }
        return n;
    },
    adapters: KE
};
function m_(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Od(null, e);
}
function Ek(e) {
    return m_(e), e.headers = po.from(e.headers), e.data = y_.call(e, e.transformRequest), [
        "post",
        "put",
        "patch"
    ].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), NP.getAdapter(e.adapter || u0.adapter)(e).then(function(n) {
        return m_(e), n.data = y_.call(e, e.transformResponse, n), n.headers = po.from(n.headers), n;
    }, function(n) {
        return TP(n) || (m_(e), n && n.response && (n.response.data = y_.call(e, e.transformResponse, n.response), n.response.headers = po.from(n.response.headers))), Promise.reject(n);
    });
}
const MP = "1.10.0", Fb = {};
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((e, t)=>{
    Fb[e] = function(n) {
        return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
    };
});
const xk = {};
Fb.transitional = function(t, r, n) {
    function i(o, s) {
        return "[Axios v" + MP + "] Transitional option '" + o + "'" + s + (n ? ". " + n : "");
    }
    return (o, s, a)=>{
        if (t === !1) throw new dr(i(s, " has been removed" + (r ? " in " + r : "")), dr.ERR_DEPRECATED);
        return r && !xk[s] && (xk[s] = !0, console.warn(i(s, " has been deprecated since v" + r + " and will be removed in the near future"))), t ? t(o, s, a) : !0;
    };
};
Fb.spelling = function(t) {
    return (r, n)=>(console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function Ete(e, t, r) {
    if (typeof e != "object") throw new dr("options must be an object", dr.ERR_BAD_OPTION_VALUE);
    const n = Object.keys(e);
    let i = n.length;
    for(; i-- > 0;){
        const o = n[i], s = t[o];
        if (s) {
            const a = e[o], u = a === void 0 || s(a, o, e);
            if (u !== !0) throw new dr("option " + o + " must be " + u, dr.ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (r !== !0) throw new dr("Unknown option " + o, dr.ERR_BAD_OPTION);
    }
}
const Ny = {
    assertOptions: Ete,
    validators: Fb
}, Ys = Ny.validators;
let hf = class {
    constructor(t){
        this.defaults = t || {}, this.interceptors = {
            request: new pk(),
            response: new pk()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(t, r) {
        try {
            return await this._request(t, r);
        } catch (n) {
            if (n instanceof Error) {
                let i = {};
                Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
                const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
                } catch  {}
            }
            throw n;
        }
    }
    _request(t, r) {
        typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = Ef(this.defaults, r);
        const { transitional: n, paramsSerializer: i, headers: o } = r;
        n !== void 0 && Ny.assertOptions(n, {
            silentJSONParsing: Ys.transitional(Ys.boolean),
            forcedJSONParsing: Ys.transitional(Ys.boolean),
            clarifyTimeoutError: Ys.transitional(Ys.boolean)
        }, !1), i != null && (Je.isFunction(i) ? r.paramsSerializer = {
            serialize: i
        } : Ny.assertOptions(i, {
            encode: Ys.function,
            serialize: Ys.function
        }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Ny.assertOptions(r, {
            baseUrl: Ys.spelling("baseURL"),
            withXsrfToken: Ys.spelling("withXSRFToken")
        }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
        let s = o && Je.merge(o.common, o[r.method]);
        o && Je.forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (_)=>{
            delete o[_];
        }), r.headers = po.concat(s, o);
        const a = [];
        let u = !0;
        this.interceptors.request.forEach(function(A) {
            typeof A.runWhen == "function" && A.runWhen(r) === !1 || (u = u && A.synchronous, a.unshift(A.fulfilled, A.rejected));
        });
        const f = [];
        this.interceptors.response.forEach(function(A) {
            f.push(A.fulfilled, A.rejected);
        });
        let c, l = 0, p;
        if (!u) {
            const _ = [
                Ek.bind(this),
                void 0
            ];
            for(_.unshift.apply(_, a), _.push.apply(_, f), p = _.length, c = Promise.resolve(r); l < p;)c = c.then(_[l++], _[l++]);
            return c;
        }
        p = a.length;
        let y = r;
        for(l = 0; l < p;){
            const _ = a[l++], A = a[l++];
            try {
                y = _(y);
            } catch (O) {
                A.call(this, O);
                break;
            }
        }
        try {
            c = Ek.call(this, y);
        } catch (_) {
            return Promise.reject(_);
        }
        for(l = 0, p = f.length; l < p;)c = c.then(f[l++], f[l++]);
        return c;
    }
    getUri(t) {
        t = Ef(this.defaults, t);
        const r = IP(t.baseURL, t.url, t.allowAbsoluteUrls);
        return xP(r, t.params, t.paramsSerializer);
    }
};
Je.forEach([
    "delete",
    "get",
    "head",
    "options"
], function(t) {
    hf.prototype[t] = function(r, n) {
        return this.request(Ef(n || {}, {
            method: t,
            url: r,
            data: (n || {}).data
        }));
    };
});
Je.forEach([
    "post",
    "put",
    "patch"
], function(t) {
    function r(n) {
        return function(o, s, a) {
            return this.request(Ef(a || {}, {
                method: t,
                headers: n ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: o,
                data: s
            }));
        };
    }
    hf.prototype[t] = r(), hf.prototype[t + "Form"] = r(!0);
});
let xte = class RP {
    constructor(t){
        if (typeof t != "function") throw new TypeError("executor must be a function.");
        let r;
        this.promise = new Promise(function(o) {
            r = o;
        });
        const n = this;
        this.promise.then((i)=>{
            if (!n._listeners) return;
            let o = n._listeners.length;
            for(; o-- > 0;)n._listeners[o](i);
            n._listeners = null;
        }), this.promise.then = (i)=>{
            let o;
            const s = new Promise((a)=>{
                n.subscribe(a), o = a;
            }).then(i);
            return s.cancel = function() {
                n.unsubscribe(o);
            }, s;
        }, t(function(o, s, a) {
            n.reason || (n.reason = new Od(o, s, a), r(n.reason));
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(t) {
        if (this.reason) {
            t(this.reason);
            return;
        }
        this._listeners ? this._listeners.push(t) : this._listeners = [
            t
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(t) {
        if (!this._listeners) return;
        const r = this._listeners.indexOf(t);
        r !== -1 && this._listeners.splice(r, 1);
    }
    toAbortSignal() {
        const t = new AbortController(), r = (n)=>{
            t.abort(n);
        };
        return this.subscribe(r), t.signal.unsubscribe = ()=>this.unsubscribe(r), t.signal;
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let t;
        return {
            token: new RP(function(i) {
                t = i;
            }),
            cancel: t
        };
    }
};
function Ste(e) {
    return function(r) {
        return e.apply(null, r);
    };
}
function Ate(e) {
    return Je.isObject(e) && e.isAxiosError === !0;
}
const WE = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(WE).forEach(([e, t])=>{
    WE[t] = e;
});
function CP(e) {
    const t = new hf(e), r = lP(hf.prototype.request, t);
    return Je.extend(r, hf.prototype, t, {
        allOwnKeys: !0
    }), Je.extend(r, t, null, {
        allOwnKeys: !0
    }), r.create = function(i) {
        return CP(Ef(e, i));
    }, r;
}
const rn = CP(u0);
rn.Axios = hf;
rn.CanceledError = Od;
rn.CancelToken = xte;
rn.isCancel = TP;
rn.VERSION = MP;
rn.toFormData = Lb;
rn.AxiosError = dr;
rn.Cancel = rn.CanceledError;
rn.all = function(t) {
    return Promise.all(t);
};
rn.spread = Ste;
rn.isAxiosError = Ate;
rn.mergeConfig = Ef;
rn.AxiosHeaders = po;
rn.formToJSON = (e)=>AP(Je.isHTMLForm(e) ? new FormData(e) : e);
rn.getAdapter = NP.getAdapter;
rn.HttpStatusCode = WE;
rn.default = rn;
const { Axios: mve, AxiosError: bve, CanceledError: wve, isCancel: vve, CancelToken: _ve, VERSION: Eve, all: xve, Cancel: Sve, isAxiosError: Ave, spread: Tve, toFormData: kve, AxiosHeaders: Ive, HttpStatusCode: Bve, formToJSON: Ove, getAdapter: Pve, mergeConfig: Nve } = rn, UP = "https://mainnet.sandshrew.io/v2", Tte = "https://signet.sandshrew.io/v2", kte = "https://testnet.sandshrew.io/v2", Ite = "https://ladder-chain-sieve.sandshrew.io/v2", ql = "lasereyes", Bte = "VIOi9IApvUkDFWBQ7I9oHsfUMWOIfDeO", $P = "bVG4GSXShooC9f67hq5YQWAJfZyRPrEN", Ote = "https://xbt-mainnet.gomaestro-api.org/v0", Pte = "https://xbt-testnet.gomaestro-api.org/v0", Nte = "https://mempool.space", Mte = "https://mempool.space/testnet", Rte = "https://mempool.space/testnet4", Cte = "https://mempool.space/signet", Ute = "https://mempool.fractalbitcoin.io", $te = "https://mempool-testnet.fractalbitcoin.io", Lte = "https://static.unisat.io/content", Sk = "https://static-testnet.unisat.io/content", Dte = "https://ordinals-testnet4.unisat.io/content", Fte = "https://ordinals.fractalbitcoin.io/content", zte = "https://ordinals-testnet.fractalbitcoin.io/content", jte = "https://static.unisat.io/preview", Ak = "https://static-testnet.unisat.io/preview", Hte = "https://ordinals-testnet4.unisat.io/preview", qte = "https://ordinals.fractalbitcoin.io/preview", Kte = "https://ordinals-testnet.fractalbitcoin.io/preview", Bi = (e)=>{
    switch(e){
        case Ni:
            return Mte;
        case ao:
            return Rte;
        case Ro:
            return Cte;
        case yc:
            return Ute;
        case co:
            return $te;
        default:
            return Nte;
    }
}, cm = (e, t)=>e === dt.TESTNET4 ? Pte : Ote, $l = (e, t)=>{
    switch(e){
        case uP:
            return Ite;
        case Ni:
            return kte;
        case Ro:
            return Tte;
        default:
            return UP;
    }
}, Wte = (e)=>{
    switch(e){
        case Ni:
            return Sk;
        case ao:
            return Dte;
        case Ro:
            return Sk;
        case yc:
            return Fte;
        case co:
            return zte;
        default:
            return Lte;
    }
}, Vte = (e)=>{
    switch(e){
        case Ni:
            return Ak;
        case ao:
            return Hte;
        case Ro:
            return Ak;
        case yc:
            return qte;
        case co:
            return Kte;
        default:
            return jte;
    }
};
o3(bb);
const Dr = (e)=>e === Ni || e === ao || e === Ro ? $H : zs, um = (e)=>e.find(({ purpose: t })=>t === "ordinals"), fm = (e)=>e.find(({ purpose: t })=>t === "payment"), id = async (e, t)=>{
    try {
        const r = await J3(e, t);
        return r ? r.reduce((n, i)=>n + BigInt(i.value), 0n) : 0n;
    } catch (r) {
        throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
    }
};
function X3(e, t, r) {
    const a = e * 57 + t * 41, u = r * 34;
    return 10 + a + u;
}
async function J3(e, t) {
    if (e.startsWith("t")) {
        if (t === ln) return [];
        if (t === yc) return [];
        if (t === co) return [];
    }
    return console.log("address", e), console.log("network", t), e.startsWith("bcrt") && t === uP ? [] : await rn.get(`${Bi(t)}/api/address/${e}/utxo`).then((r)=>r.data);
}
async function zb(e, t, r, n, i, o, s = 7) {
    const a = e === t, u = await J3(t, o);
    if (!u) throw new Error("No UTXOs found");
    const f = u.sort((_, A)=>A.value - _.value), c = new Cr({
        network: Dr(o)
    }), l = X3(1, 0, 2), p = Math.floor(l * s) + n;
    let y = 0;
    for await (const _ of f){
        const { txid: A, vout: O, value: N } = _, U = hs(t, Dr(o));
        if (c.addInput({
            hash: A,
            index: O,
            witnessUtxo: {
                script: U,
                value: BigInt(N)
            }
        }), !a) {
            const D = d0(i, o);
            c.updateInput(O, {
                redeemScript: D
            });
        }
        if (y += N, y >= p) break;
    }
    if (y < p) throw new Error("Insufficient funds");
    return c.addOutput({
        address: r,
        value: BigInt(n)
    }), y > p && c.addOutput({
        address: t,
        value: BigInt(y - p)
    }), {
        psbtBase64: c.toBase64(),
        psbtHex: c.toHex()
    };
}
function jb(e) {
    return e == null ? void 0 : e.reduce((t, r)=>t + r.value, 0);
}
async function Hb(e, t) {
    return (await rn.post(`${Bi(t)}/api/tx`, e, {
        headers: {
            "Content-Type": "text/plain"
        }
    })).data;
}
const LP = (e)=>e === Ni || e === ao || e === Ro, qb = (e)=>e === ln || e === yc || e === co;
var Aa = {}, oi = {};
Object.defineProperty(oi, "__esModule", {
    value: !0
});
oi.sha512_256 = oi.SHA512_256 = oi.sha512_224 = oi.SHA512_224 = oi.sha384 = oi.SHA384 = oi.sha512 = oi.SHA512 = void 0;
const Ou = en;
oi.SHA512 = Ou.SHA512;
oi.sha512 = Ou.sha512;
oi.SHA384 = Ou.SHA384;
oi.sha384 = Ou.sha384;
oi.SHA512_224 = Ou.SHA512_224;
oi.sha512_224 = Ou.sha512_224;
oi.SHA512_256 = Ou.SHA512_256;
oi.sha512_256 = Ou.sha512_256;
var Kb = {};
Object.defineProperty(Kb, "__esModule", {
    value: !0
});
Kb.pbkdf2 = Zte;
Kb.pbkdf2Async = Yte;
const Gte = Qp, Bs = Hr;
function DP(e, t, r, n) {
    (0, Bs.ahash)(e);
    const i = (0, Bs.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, n), { c: o, dkLen: s, asyncTick: a } = i;
    if ((0, Bs.anumber)(o), (0, Bs.anumber)(s), (0, Bs.anumber)(a), o < 1) throw new Error("iterations (c) should be >= 1");
    const u = (0, Bs.kdfInputToBytes)(t), f = (0, Bs.kdfInputToBytes)(r), c = new Uint8Array(s), l = Gte.hmac.create(e, u), p = l._cloneInto().update(f);
    return {
        c: o,
        dkLen: s,
        asyncTick: a,
        DK: c,
        PRF: l,
        PRFSalt: p
    };
}
function FP(e, t, r, n, i) {
    return e.destroy(), t.destroy(), n && n.destroy(), (0, Bs.clean)(i), r;
}
function Zte(e, t, r, n) {
    const { c: i, dkLen: o, DK: s, PRF: a, PRFSalt: u } = DP(e, t, r, n);
    let f;
    const c = new Uint8Array(4), l = (0, Bs.createView)(c), p = new Uint8Array(a.outputLen);
    for(let y = 1, _ = 0; _ < o; y++, _ += a.outputLen){
        const A = s.subarray(_, _ + a.outputLen);
        l.setInt32(0, y, !1), (f = u._cloneInto(f)).update(c).digestInto(p), A.set(p.subarray(0, A.length));
        for(let O = 1; O < i; O++){
            a._cloneInto(f).update(p).digestInto(p);
            for(let N = 0; N < A.length; N++)A[N] ^= p[N];
        }
    }
    return FP(a, u, s, f, p);
}
async function Yte(e, t, r, n) {
    const { c: i, dkLen: o, asyncTick: s, DK: a, PRF: u, PRFSalt: f } = DP(e, t, r, n);
    let c;
    const l = new Uint8Array(4), p = (0, Bs.createView)(l), y = new Uint8Array(u.outputLen);
    for(let _ = 1, A = 0; A < o; _++, A += u.outputLen){
        const O = a.subarray(A, A + u.outputLen);
        p.setInt32(0, _, !1), (c = f._cloneInto(c)).update(l).digestInto(y), O.set(y.subarray(0, O.length)), await (0, Bs.asyncLoop)(i - 1, s, ()=>{
            u._cloneInto(c).update(y).digestInto(y);
            for(let N = 0; N < O.length; N++)O[N] ^= y[N];
        });
    }
    return FP(u, f, a, c, y);
}
var Zi = {};
const Xte = [
    "abdikace",
    "abeceda",
    "adresa",
    "agrese",
    "akce",
    "aktovka",
    "alej",
    "alkohol",
    "amputace",
    "ananas",
    "andulka",
    "anekdota",
    "anketa",
    "antika",
    "anulovat",
    "archa",
    "arogance",
    "asfalt",
    "asistent",
    "aspirace",
    "astma",
    "astronom",
    "atlas",
    "atletika",
    "atol",
    "autobus",
    "azyl",
    "babka",
    "bachor",
    "bacil",
    "baculka",
    "badatel",
    "bageta",
    "bagr",
    "bahno",
    "bakterie",
    "balada",
    "baletka",
    "balkon",
    "balonek",
    "balvan",
    "balza",
    "bambus",
    "bankomat",
    "barbar",
    "baret",
    "barman",
    "baroko",
    "barva",
    "baterka",
    "batoh",
    "bavlna",
    "bazalka",
    "bazilika",
    "bazuka",
    "bedna",
    "beran",
    "beseda",
    "bestie",
    "beton",
    "bezinka",
    "bezmoc",
    "beztak",
    "bicykl",
    "bidlo",
    "biftek",
    "bikiny",
    "bilance",
    "biograf",
    "biolog",
    "bitva",
    "bizon",
    "blahobyt",
    "blatouch",
    "blecha",
    "bledule",
    "blesk",
    "blikat",
    "blizna",
    "blokovat",
    "bloudit",
    "blud",
    "bobek",
    "bobr",
    "bodlina",
    "bodnout",
    "bohatost",
    "bojkot",
    "bojovat",
    "bokorys",
    "bolest",
    "borec",
    "borovice",
    "bota",
    "boubel",
    "bouchat",
    "bouda",
    "boule",
    "bourat",
    "boxer",
    "bradavka",
    "brambora",
    "branka",
    "bratr",
    "brepta",
    "briketa",
    "brko",
    "brloh",
    "bronz",
    "broskev",
    "brunetka",
    "brusinka",
    "brzda",
    "brzy",
    "bublina",
    "bubnovat",
    "buchta",
    "buditel",
    "budka",
    "budova",
    "bufet",
    "bujarost",
    "bukvice",
    "buldok",
    "bulva",
    "bunda",
    "bunkr",
    "burza",
    "butik",
    "buvol",
    "buzola",
    "bydlet",
    "bylina",
    "bytovka",
    "bzukot",
    "capart",
    "carevna",
    "cedr",
    "cedule",
    "cejch",
    "cejn",
    "cela",
    "celer",
    "celkem",
    "celnice",
    "cenina",
    "cennost",
    "cenovka",
    "centrum",
    "cenzor",
    "cestopis",
    "cetka",
    "chalupa",
    "chapadlo",
    "charita",
    "chata",
    "chechtat",
    "chemie",
    "chichot",
    "chirurg",
    "chlad",
    "chleba",
    "chlubit",
    "chmel",
    "chmura",
    "chobot",
    "chochol",
    "chodba",
    "cholera",
    "chomout",
    "chopit",
    "choroba",
    "chov",
    "chrapot",
    "chrlit",
    "chrt",
    "chrup",
    "chtivost",
    "chudina",
    "chutnat",
    "chvat",
    "chvilka",
    "chvost",
    "chyba",
    "chystat",
    "chytit",
    "cibule",
    "cigareta",
    "cihelna",
    "cihla",
    "cinkot",
    "cirkus",
    "cisterna",
    "citace",
    "citrus",
    "cizinec",
    "cizost",
    "clona",
    "cokoliv",
    "couvat",
    "ctitel",
    "ctnost",
    "cudnost",
    "cuketa",
    "cukr",
    "cupot",
    "cvaknout",
    "cval",
    "cvik",
    "cvrkot",
    "cyklista",
    "daleko",
    "dareba",
    "datel",
    "datum",
    "dcera",
    "debata",
    "dechovka",
    "decibel",
    "deficit",
    "deflace",
    "dekl",
    "dekret",
    "demokrat",
    "deprese",
    "derby",
    "deska",
    "detektiv",
    "dikobraz",
    "diktovat",
    "dioda",
    "diplom",
    "disk",
    "displej",
    "divadlo",
    "divoch",
    "dlaha",
    "dlouho",
    "dluhopis",
    "dnes",
    "dobro",
    "dobytek",
    "docent",
    "dochutit",
    "dodnes",
    "dohled",
    "dohoda",
    "dohra",
    "dojem",
    "dojnice",
    "doklad",
    "dokola",
    "doktor",
    "dokument",
    "dolar",
    "doleva",
    "dolina",
    "doma",
    "dominant",
    "domluvit",
    "domov",
    "donutit",
    "dopad",
    "dopis",
    "doplnit",
    "doposud",
    "doprovod",
    "dopustit",
    "dorazit",
    "dorost",
    "dort",
    "dosah",
    "doslov",
    "dostatek",
    "dosud",
    "dosyta",
    "dotaz",
    "dotek",
    "dotknout",
    "doufat",
    "doutnat",
    "dovozce",
    "dozadu",
    "doznat",
    "dozorce",
    "drahota",
    "drak",
    "dramatik",
    "dravec",
    "draze",
    "drdol",
    "drobnost",
    "drogerie",
    "drozd",
    "drsnost",
    "drtit",
    "drzost",
    "duben",
    "duchovno",
    "dudek",
    "duha",
    "duhovka",
    "dusit",
    "dusno",
    "dutost",
    "dvojice",
    "dvorec",
    "dynamit",
    "ekolog",
    "ekonomie",
    "elektron",
    "elipsa",
    "email",
    "emise",
    "emoce",
    "empatie",
    "epizoda",
    "epocha",
    "epopej",
    "epos",
    "esej",
    "esence",
    "eskorta",
    "eskymo",
    "etiketa",
    "euforie",
    "evoluce",
    "exekuce",
    "exkurze",
    "expedice",
    "exploze",
    "export",
    "extrakt",
    "facka",
    "fajfka",
    "fakulta",
    "fanatik",
    "fantazie",
    "farmacie",
    "favorit",
    "fazole",
    "federace",
    "fejeton",
    "fenka",
    "fialka",
    "figurant",
    "filozof",
    "filtr",
    "finance",
    "finta",
    "fixace",
    "fjord",
    "flanel",
    "flirt",
    "flotila",
    "fond",
    "fosfor",
    "fotbal",
    "fotka",
    "foton",
    "frakce",
    "freska",
    "fronta",
    "fukar",
    "funkce",
    "fyzika",
    "galeje",
    "garant",
    "genetika",
    "geolog",
    "gilotina",
    "glazura",
    "glejt",
    "golem",
    "golfista",
    "gotika",
    "graf",
    "gramofon",
    "granule",
    "grep",
    "gril",
    "grog",
    "groteska",
    "guma",
    "hadice",
    "hadr",
    "hala",
    "halenka",
    "hanba",
    "hanopis",
    "harfa",
    "harpuna",
    "havran",
    "hebkost",
    "hejkal",
    "hejno",
    "hejtman",
    "hektar",
    "helma",
    "hematom",
    "herec",
    "herna",
    "heslo",
    "hezky",
    "historik",
    "hladovka",
    "hlasivky",
    "hlava",
    "hledat",
    "hlen",
    "hlodavec",
    "hloh",
    "hloupost",
    "hltat",
    "hlubina",
    "hluchota",
    "hmat",
    "hmota",
    "hmyz",
    "hnis",
    "hnojivo",
    "hnout",
    "hoblina",
    "hoboj",
    "hoch",
    "hodiny",
    "hodlat",
    "hodnota",
    "hodovat",
    "hojnost",
    "hokej",
    "holinka",
    "holka",
    "holub",
    "homole",
    "honitba",
    "honorace",
    "horal",
    "horda",
    "horizont",
    "horko",
    "horlivec",
    "hormon",
    "hornina",
    "horoskop",
    "horstvo",
    "hospoda",
    "hostina",
    "hotovost",
    "houba",
    "houf",
    "houpat",
    "houska",
    "hovor",
    "hradba",
    "hranice",
    "hravost",
    "hrazda",
    "hrbolek",
    "hrdina",
    "hrdlo",
    "hrdost",
    "hrnek",
    "hrobka",
    "hromada",
    "hrot",
    "hrouda",
    "hrozen",
    "hrstka",
    "hrubost",
    "hryzat",
    "hubenost",
    "hubnout",
    "hudba",
    "hukot",
    "humr",
    "husita",
    "hustota",
    "hvozd",
    "hybnost",
    "hydrant",
    "hygiena",
    "hymna",
    "hysterik",
    "idylka",
    "ihned",
    "ikona",
    "iluze",
    "imunita",
    "infekce",
    "inflace",
    "inkaso",
    "inovace",
    "inspekce",
    "internet",
    "invalida",
    "investor",
    "inzerce",
    "ironie",
    "jablko",
    "jachta",
    "jahoda",
    "jakmile",
    "jakost",
    "jalovec",
    "jantar",
    "jarmark",
    "jaro",
    "jasan",
    "jasno",
    "jatka",
    "javor",
    "jazyk",
    "jedinec",
    "jedle",
    "jednatel",
    "jehlan",
    "jekot",
    "jelen",
    "jelito",
    "jemnost",
    "jenom",
    "jepice",
    "jeseter",
    "jevit",
    "jezdec",
    "jezero",
    "jinak",
    "jindy",
    "jinoch",
    "jiskra",
    "jistota",
    "jitrnice",
    "jizva",
    "jmenovat",
    "jogurt",
    "jurta",
    "kabaret",
    "kabel",
    "kabinet",
    "kachna",
    "kadet",
    "kadidlo",
    "kahan",
    "kajak",
    "kajuta",
    "kakao",
    "kaktus",
    "kalamita",
    "kalhoty",
    "kalibr",
    "kalnost",
    "kamera",
    "kamkoliv",
    "kamna",
    "kanibal",
    "kanoe",
    "kantor",
    "kapalina",
    "kapela",
    "kapitola",
    "kapka",
    "kaple",
    "kapota",
    "kapr",
    "kapusta",
    "kapybara",
    "karamel",
    "karotka",
    "karton",
    "kasa",
    "katalog",
    "katedra",
    "kauce",
    "kauza",
    "kavalec",
    "kazajka",
    "kazeta",
    "kazivost",
    "kdekoliv",
    "kdesi",
    "kedluben",
    "kemp",
    "keramika",
    "kino",
    "klacek",
    "kladivo",
    "klam",
    "klapot",
    "klasika",
    "klaun",
    "klec",
    "klenba",
    "klepat",
    "klesnout",
    "klid",
    "klima",
    "klisna",
    "klobouk",
    "klokan",
    "klopa",
    "kloub",
    "klubovna",
    "klusat",
    "kluzkost",
    "kmen",
    "kmitat",
    "kmotr",
    "kniha",
    "knot",
    "koalice",
    "koberec",
    "kobka",
    "kobliha",
    "kobyla",
    "kocour",
    "kohout",
    "kojenec",
    "kokos",
    "koktejl",
    "kolaps",
    "koleda",
    "kolize",
    "kolo",
    "komando",
    "kometa",
    "komik",
    "komnata",
    "komora",
    "kompas",
    "komunita",
    "konat",
    "koncept",
    "kondice",
    "konec",
    "konfese",
    "kongres",
    "konina",
    "konkurs",
    "kontakt",
    "konzerva",
    "kopanec",
    "kopie",
    "kopnout",
    "koprovka",
    "korbel",
    "korektor",
    "kormidlo",
    "koroptev",
    "korpus",
    "koruna",
    "koryto",
    "korzet",
    "kosatec",
    "kostka",
    "kotel",
    "kotleta",
    "kotoul",
    "koukat",
    "koupelna",
    "kousek",
    "kouzlo",
    "kovboj",
    "koza",
    "kozoroh",
    "krabice",
    "krach",
    "krajina",
    "kralovat",
    "krasopis",
    "kravata",
    "kredit",
    "krejcar",
    "kresba",
    "kreveta",
    "kriket",
    "kritik",
    "krize",
    "krkavec",
    "krmelec",
    "krmivo",
    "krocan",
    "krok",
    "kronika",
    "kropit",
    "kroupa",
    "krovka",
    "krtek",
    "kruhadlo",
    "krupice",
    "krutost",
    "krvinka",
    "krychle",
    "krypta",
    "krystal",
    "kryt",
    "kudlanka",
    "kufr",
    "kujnost",
    "kukla",
    "kulajda",
    "kulich",
    "kulka",
    "kulomet",
    "kultura",
    "kuna",
    "kupodivu",
    "kurt",
    "kurzor",
    "kutil",
    "kvalita",
    "kvasinka",
    "kvestor",
    "kynolog",
    "kyselina",
    "kytara",
    "kytice",
    "kytka",
    "kytovec",
    "kyvadlo",
    "labrador",
    "lachtan",
    "ladnost",
    "laik",
    "lakomec",
    "lamela",
    "lampa",
    "lanovka",
    "lasice",
    "laso",
    "lastura",
    "latinka",
    "lavina",
    "lebka",
    "leckdy",
    "leden",
    "lednice",
    "ledovka",
    "ledvina",
    "legenda",
    "legie",
    "legrace",
    "lehce",
    "lehkost",
    "lehnout",
    "lektvar",
    "lenochod",
    "lentilka",
    "lepenka",
    "lepidlo",
    "letadlo",
    "letec",
    "letmo",
    "letokruh",
    "levhart",
    "levitace",
    "levobok",
    "libra",
    "lichotka",
    "lidojed",
    "lidskost",
    "lihovina",
    "lijavec",
    "lilek",
    "limetka",
    "linie",
    "linka",
    "linoleum",
    "listopad",
    "litina",
    "litovat",
    "lobista",
    "lodivod",
    "logika",
    "logoped",
    "lokalita",
    "loket",
    "lomcovat",
    "lopata",
    "lopuch",
    "lord",
    "losos",
    "lotr",
    "loudal",
    "louh",
    "louka",
    "louskat",
    "lovec",
    "lstivost",
    "lucerna",
    "lucifer",
    "lump",
    "lusk",
    "lustrace",
    "lvice",
    "lyra",
    "lyrika",
    "lysina",
    "madam",
    "madlo",
    "magistr",
    "mahagon",
    "majetek",
    "majitel",
    "majorita",
    "makak",
    "makovice",
    "makrela",
    "malba",
    "malina",
    "malovat",
    "malvice",
    "maminka",
    "mandle",
    "manko",
    "marnost",
    "masakr",
    "maskot",
    "masopust",
    "matice",
    "matrika",
    "maturita",
    "mazanec",
    "mazivo",
    "mazlit",
    "mazurka",
    "mdloba",
    "mechanik",
    "meditace",
    "medovina",
    "melasa",
    "meloun",
    "mentolka",
    "metla",
    "metoda",
    "metr",
    "mezera",
    "migrace",
    "mihnout",
    "mihule",
    "mikina",
    "mikrofon",
    "milenec",
    "milimetr",
    "milost",
    "mimika",
    "mincovna",
    "minibar",
    "minomet",
    "minulost",
    "miska",
    "mistr",
    "mixovat",
    "mladost",
    "mlha",
    "mlhovina",
    "mlok",
    "mlsat",
    "mluvit",
    "mnich",
    "mnohem",
    "mobil",
    "mocnost",
    "modelka",
    "modlitba",
    "mohyla",
    "mokro",
    "molekula",
    "momentka",
    "monarcha",
    "monokl",
    "monstrum",
    "montovat",
    "monzun",
    "mosaz",
    "moskyt",
    "most",
    "motivace",
    "motorka",
    "motyka",
    "moucha",
    "moudrost",
    "mozaika",
    "mozek",
    "mozol",
    "mramor",
    "mravenec",
    "mrkev",
    "mrtvola",
    "mrzet",
    "mrzutost",
    "mstitel",
    "mudrc",
    "muflon",
    "mulat",
    "mumie",
    "munice",
    "muset",
    "mutace",
    "muzeum",
    "muzikant",
    "myslivec",
    "mzda",
    "nabourat",
    "nachytat",
    "nadace",
    "nadbytek",
    "nadhoz",
    "nadobro",
    "nadpis",
    "nahlas",
    "nahnat",
    "nahodile",
    "nahradit",
    "naivita",
    "najednou",
    "najisto",
    "najmout",
    "naklonit",
    "nakonec",
    "nakrmit",
    "nalevo",
    "namazat",
    "namluvit",
    "nanometr",
    "naoko",
    "naopak",
    "naostro",
    "napadat",
    "napevno",
    "naplnit",
    "napnout",
    "naposled",
    "naprosto",
    "narodit",
    "naruby",
    "narychlo",
    "nasadit",
    "nasekat",
    "naslepo",
    "nastat",
    "natolik",
    "navenek",
    "navrch",
    "navzdory",
    "nazvat",
    "nebe",
    "nechat",
    "necky",
    "nedaleko",
    "nedbat",
    "neduh",
    "negace",
    "nehet",
    "nehoda",
    "nejen",
    "nejprve",
    "neklid",
    "nelibost",
    "nemilost",
    "nemoc",
    "neochota",
    "neonka",
    "nepokoj",
    "nerost",
    "nerv",
    "nesmysl",
    "nesoulad",
    "netvor",
    "neuron",
    "nevina",
    "nezvykle",
    "nicota",
    "nijak",
    "nikam",
    "nikdy",
    "nikl",
    "nikterak",
    "nitro",
    "nocleh",
    "nohavice",
    "nominace",
    "nora",
    "norek",
    "nositel",
    "nosnost",
    "nouze",
    "noviny",
    "novota",
    "nozdra",
    "nuda",
    "nudle",
    "nuget",
    "nutit",
    "nutnost",
    "nutrie",
    "nymfa",
    "obal",
    "obarvit",
    "obava",
    "obdiv",
    "obec",
    "obehnat",
    "obejmout",
    "obezita",
    "obhajoba",
    "obilnice",
    "objasnit",
    "objekt",
    "obklopit",
    "oblast",
    "oblek",
    "obliba",
    "obloha",
    "obluda",
    "obnos",
    "obohatit",
    "obojek",
    "obout",
    "obrazec",
    "obrna",
    "obruba",
    "obrys",
    "obsah",
    "obsluha",
    "obstarat",
    "obuv",
    "obvaz",
    "obvinit",
    "obvod",
    "obvykle",
    "obyvatel",
    "obzor",
    "ocas",
    "ocel",
    "ocenit",
    "ochladit",
    "ochota",
    "ochrana",
    "ocitnout",
    "odboj",
    "odbyt",
    "odchod",
    "odcizit",
    "odebrat",
    "odeslat",
    "odevzdat",
    "odezva",
    "odhadce",
    "odhodit",
    "odjet",
    "odjinud",
    "odkaz",
    "odkoupit",
    "odliv",
    "odluka",
    "odmlka",
    "odolnost",
    "odpad",
    "odpis",
    "odplout",
    "odpor",
    "odpustit",
    "odpykat",
    "odrazka",
    "odsoudit",
    "odstup",
    "odsun",
    "odtok",
    "odtud",
    "odvaha",
    "odveta",
    "odvolat",
    "odvracet",
    "odznak",
    "ofina",
    "ofsajd",
    "ohlas",
    "ohnisko",
    "ohrada",
    "ohrozit",
    "ohryzek",
    "okap",
    "okenice",
    "oklika",
    "okno",
    "okouzlit",
    "okovy",
    "okrasa",
    "okres",
    "okrsek",
    "okruh",
    "okupant",
    "okurka",
    "okusit",
    "olejnina",
    "olizovat",
    "omak",
    "omeleta",
    "omezit",
    "omladina",
    "omlouvat",
    "omluva",
    "omyl",
    "onehdy",
    "opakovat",
    "opasek",
    "operace",
    "opice",
    "opilost",
    "opisovat",
    "opora",
    "opozice",
    "opravdu",
    "oproti",
    "orbital",
    "orchestr",
    "orgie",
    "orlice",
    "orloj",
    "ortel",
    "osada",
    "oschnout",
    "osika",
    "osivo",
    "oslava",
    "oslepit",
    "oslnit",
    "oslovit",
    "osnova",
    "osoba",
    "osolit",
    "ospalec",
    "osten",
    "ostraha",
    "ostuda",
    "ostych",
    "osvojit",
    "oteplit",
    "otisk",
    "otop",
    "otrhat",
    "otrlost",
    "otrok",
    "otruby",
    "otvor",
    "ovanout",
    "ovar",
    "oves",
    "ovlivnit",
    "ovoce",
    "oxid",
    "ozdoba",
    "pachatel",
    "pacient",
    "padouch",
    "pahorek",
    "pakt",
    "palanda",
    "palec",
    "palivo",
    "paluba",
    "pamflet",
    "pamlsek",
    "panenka",
    "panika",
    "panna",
    "panovat",
    "panstvo",
    "pantofle",
    "paprika",
    "parketa",
    "parodie",
    "parta",
    "paruka",
    "paryba",
    "paseka",
    "pasivita",
    "pastelka",
    "patent",
    "patrona",
    "pavouk",
    "pazneht",
    "pazourek",
    "pecka",
    "pedagog",
    "pejsek",
    "peklo",
    "peloton",
    "penalta",
    "pendrek",
    "penze",
    "periskop",
    "pero",
    "pestrost",
    "petarda",
    "petice",
    "petrolej",
    "pevnina",
    "pexeso",
    "pianista",
    "piha",
    "pijavice",
    "pikle",
    "piknik",
    "pilina",
    "pilnost",
    "pilulka",
    "pinzeta",
    "pipeta",
    "pisatel",
    "pistole",
    "pitevna",
    "pivnice",
    "pivovar",
    "placenta",
    "plakat",
    "plamen",
    "planeta",
    "plastika",
    "platit",
    "plavidlo",
    "plaz",
    "plech",
    "plemeno",
    "plenta",
    "ples",
    "pletivo",
    "plevel",
    "plivat",
    "plnit",
    "plno",
    "plocha",
    "plodina",
    "plomba",
    "plout",
    "pluk",
    "plyn",
    "pobavit",
    "pobyt",
    "pochod",
    "pocit",
    "poctivec",
    "podat",
    "podcenit",
    "podepsat",
    "podhled",
    "podivit",
    "podklad",
    "podmanit",
    "podnik",
    "podoba",
    "podpora",
    "podraz",
    "podstata",
    "podvod",
    "podzim",
    "poezie",
    "pohanka",
    "pohnutka",
    "pohovor",
    "pohroma",
    "pohyb",
    "pointa",
    "pojistka",
    "pojmout",
    "pokazit",
    "pokles",
    "pokoj",
    "pokrok",
    "pokuta",
    "pokyn",
    "poledne",
    "polibek",
    "polknout",
    "poloha",
    "polynom",
    "pomalu",
    "pominout",
    "pomlka",
    "pomoc",
    "pomsta",
    "pomyslet",
    "ponechat",
    "ponorka",
    "ponurost",
    "popadat",
    "popel",
    "popisek",
    "poplach",
    "poprosit",
    "popsat",
    "popud",
    "poradce",
    "porce",
    "porod",
    "porucha",
    "poryv",
    "posadit",
    "posed",
    "posila",
    "poskok",
    "poslanec",
    "posoudit",
    "pospolu",
    "postava",
    "posudek",
    "posyp",
    "potah",
    "potkan",
    "potlesk",
    "potomek",
    "potrava",
    "potupa",
    "potvora",
    "poukaz",
    "pouto",
    "pouzdro",
    "povaha",
    "povidla",
    "povlak",
    "povoz",
    "povrch",
    "povstat",
    "povyk",
    "povzdech",
    "pozdrav",
    "pozemek",
    "poznatek",
    "pozor",
    "pozvat",
    "pracovat",
    "prahory",
    "praktika",
    "prales",
    "praotec",
    "praporek",
    "prase",
    "pravda",
    "princip",
    "prkno",
    "probudit",
    "procento",
    "prodej",
    "profese",
    "prohra",
    "projekt",
    "prolomit",
    "promile",
    "pronikat",
    "propad",
    "prorok",
    "prosba",
    "proton",
    "proutek",
    "provaz",
    "prskavka",
    "prsten",
    "prudkost",
    "prut",
    "prvek",
    "prvohory",
    "psanec",
    "psovod",
    "pstruh",
    "ptactvo",
    "puberta",
    "puch",
    "pudl",
    "pukavec",
    "puklina",
    "pukrle",
    "pult",
    "pumpa",
    "punc",
    "pupen",
    "pusa",
    "pusinka",
    "pustina",
    "putovat",
    "putyka",
    "pyramida",
    "pysk",
    "pytel",
    "racek",
    "rachot",
    "radiace",
    "radnice",
    "radon",
    "raft",
    "ragby",
    "raketa",
    "rakovina",
    "rameno",
    "rampouch",
    "rande",
    "rarach",
    "rarita",
    "rasovna",
    "rastr",
    "ratolest",
    "razance",
    "razidlo",
    "reagovat",
    "reakce",
    "recept",
    "redaktor",
    "referent",
    "reflex",
    "rejnok",
    "reklama",
    "rekord",
    "rekrut",
    "rektor",
    "reputace",
    "revize",
    "revma",
    "revolver",
    "rezerva",
    "riskovat",
    "riziko",
    "robotika",
    "rodokmen",
    "rohovka",
    "rokle",
    "rokoko",
    "romaneto",
    "ropovod",
    "ropucha",
    "rorejs",
    "rosol",
    "rostlina",
    "rotmistr",
    "rotoped",
    "rotunda",
    "roubenka",
    "roucho",
    "roup",
    "roura",
    "rovina",
    "rovnice",
    "rozbor",
    "rozchod",
    "rozdat",
    "rozeznat",
    "rozhodce",
    "rozinka",
    "rozjezd",
    "rozkaz",
    "rozloha",
    "rozmar",
    "rozpad",
    "rozruch",
    "rozsah",
    "roztok",
    "rozum",
    "rozvod",
    "rubrika",
    "ruchadlo",
    "rukavice",
    "rukopis",
    "ryba",
    "rybolov",
    "rychlost",
    "rydlo",
    "rypadlo",
    "rytina",
    "ryzost",
    "sadista",
    "sahat",
    "sako",
    "samec",
    "samizdat",
    "samota",
    "sanitka",
    "sardinka",
    "sasanka",
    "satelit",
    "sazba",
    "sazenice",
    "sbor",
    "schovat",
    "sebranka",
    "secese",
    "sedadlo",
    "sediment",
    "sedlo",
    "sehnat",
    "sejmout",
    "sekera",
    "sekta",
    "sekunda",
    "sekvoje",
    "semeno",
    "seno",
    "servis",
    "sesadit",
    "seshora",
    "seskok",
    "seslat",
    "sestra",
    "sesuv",
    "sesypat",
    "setba",
    "setina",
    "setkat",
    "setnout",
    "setrvat",
    "sever",
    "seznam",
    "shoda",
    "shrnout",
    "sifon",
    "silnice",
    "sirka",
    "sirotek",
    "sirup",
    "situace",
    "skafandr",
    "skalisko",
    "skanzen",
    "skaut",
    "skeptik",
    "skica",
    "skladba",
    "sklenice",
    "sklo",
    "skluz",
    "skoba",
    "skokan",
    "skoro",
    "skripta",
    "skrz",
    "skupina",
    "skvost",
    "skvrna",
    "slabika",
    "sladidlo",
    "slanina",
    "slast",
    "slavnost",
    "sledovat",
    "slepec",
    "sleva",
    "slezina",
    "slib",
    "slina",
    "sliznice",
    "slon",
    "sloupek",
    "slovo",
    "sluch",
    "sluha",
    "slunce",
    "slupka",
    "slza",
    "smaragd",
    "smetana",
    "smilstvo",
    "smlouva",
    "smog",
    "smrad",
    "smrk",
    "smrtka",
    "smutek",
    "smysl",
    "snad",
    "snaha",
    "snob",
    "sobota",
    "socha",
    "sodovka",
    "sokol",
    "sopka",
    "sotva",
    "souboj",
    "soucit",
    "soudce",
    "souhlas",
    "soulad",
    "soumrak",
    "souprava",
    "soused",
    "soutok",
    "souviset",
    "spalovna",
    "spasitel",
    "spis",
    "splav",
    "spodek",
    "spojenec",
    "spolu",
    "sponzor",
    "spornost",
    "spousta",
    "sprcha",
    "spustit",
    "sranda",
    "sraz",
    "srdce",
    "srna",
    "srnec",
    "srovnat",
    "srpen",
    "srst",
    "srub",
    "stanice",
    "starosta",
    "statika",
    "stavba",
    "stehno",
    "stezka",
    "stodola",
    "stolek",
    "stopa",
    "storno",
    "stoupat",
    "strach",
    "stres",
    "strhnout",
    "strom",
    "struna",
    "studna",
    "stupnice",
    "stvol",
    "styk",
    "subjekt",
    "subtropy",
    "suchar",
    "sudost",
    "sukno",
    "sundat",
    "sunout",
    "surikata",
    "surovina",
    "svah",
    "svalstvo",
    "svetr",
    "svatba",
    "svazek",
    "svisle",
    "svitek",
    "svoboda",
    "svodidlo",
    "svorka",
    "svrab",
    "sykavka",
    "sykot",
    "synek",
    "synovec",
    "sypat",
    "sypkost",
    "syrovost",
    "sysel",
    "sytost",
    "tabletka",
    "tabule",
    "tahoun",
    "tajemno",
    "tajfun",
    "tajga",
    "tajit",
    "tajnost",
    "taktika",
    "tamhle",
    "tampon",
    "tancovat",
    "tanec",
    "tanker",
    "tapeta",
    "tavenina",
    "tazatel",
    "technika",
    "tehdy",
    "tekutina",
    "telefon",
    "temnota",
    "tendence",
    "tenista",
    "tenor",
    "teplota",
    "tepna",
    "teprve",
    "terapie",
    "termoska",
    "textil",
    "ticho",
    "tiskopis",
    "titulek",
    "tkadlec",
    "tkanina",
    "tlapka",
    "tleskat",
    "tlukot",
    "tlupa",
    "tmel",
    "toaleta",
    "topinka",
    "topol",
    "torzo",
    "touha",
    "toulec",
    "tradice",
    "traktor",
    "tramp",
    "trasa",
    "traverza",
    "trefit",
    "trest",
    "trezor",
    "trhavina",
    "trhlina",
    "trochu",
    "trojice",
    "troska",
    "trouba",
    "trpce",
    "trpitel",
    "trpkost",
    "trubec",
    "truchlit",
    "truhlice",
    "trus",
    "trvat",
    "tudy",
    "tuhnout",
    "tuhost",
    "tundra",
    "turista",
    "turnaj",
    "tuzemsko",
    "tvaroh",
    "tvorba",
    "tvrdost",
    "tvrz",
    "tygr",
    "tykev",
    "ubohost",
    "uboze",
    "ubrat",
    "ubrousek",
    "ubrus",
    "ubytovna",
    "ucho",
    "uctivost",
    "udivit",
    "uhradit",
    "ujednat",
    "ujistit",
    "ujmout",
    "ukazatel",
    "uklidnit",
    "uklonit",
    "ukotvit",
    "ukrojit",
    "ulice",
    "ulita",
    "ulovit",
    "umyvadlo",
    "unavit",
    "uniforma",
    "uniknout",
    "upadnout",
    "uplatnit",
    "uplynout",
    "upoutat",
    "upravit",
    "uran",
    "urazit",
    "usednout",
    "usilovat",
    "usmrtit",
    "usnadnit",
    "usnout",
    "usoudit",
    "ustlat",
    "ustrnout",
    "utahovat",
    "utkat",
    "utlumit",
    "utonout",
    "utopenec",
    "utrousit",
    "uvalit",
    "uvolnit",
    "uvozovka",
    "uzdravit",
    "uzel",
    "uzenina",
    "uzlina",
    "uznat",
    "vagon",
    "valcha",
    "valoun",
    "vana",
    "vandal",
    "vanilka",
    "varan",
    "varhany",
    "varovat",
    "vcelku",
    "vchod",
    "vdova",
    "vedro",
    "vegetace",
    "vejce",
    "velbloud",
    "veletrh",
    "velitel",
    "velmoc",
    "velryba",
    "venkov",
    "veranda",
    "verze",
    "veselka",
    "veskrze",
    "vesnice",
    "vespodu",
    "vesta",
    "veterina",
    "veverka",
    "vibrace",
    "vichr",
    "videohra",
    "vidina",
    "vidle",
    "vila",
    "vinice",
    "viset",
    "vitalita",
    "vize",
    "vizitka",
    "vjezd",
    "vklad",
    "vkus",
    "vlajka",
    "vlak",
    "vlasec",
    "vlevo",
    "vlhkost",
    "vliv",
    "vlnovka",
    "vloupat",
    "vnucovat",
    "vnuk",
    "voda",
    "vodivost",
    "vodoznak",
    "vodstvo",
    "vojensky",
    "vojna",
    "vojsko",
    "volant",
    "volba",
    "volit",
    "volno",
    "voskovka",
    "vozidlo",
    "vozovna",
    "vpravo",
    "vrabec",
    "vracet",
    "vrah",
    "vrata",
    "vrba",
    "vrcholek",
    "vrhat",
    "vrstva",
    "vrtule",
    "vsadit",
    "vstoupit",
    "vstup",
    "vtip",
    "vybavit",
    "vybrat",
    "vychovat",
    "vydat",
    "vydra",
    "vyfotit",
    "vyhledat",
    "vyhnout",
    "vyhodit",
    "vyhradit",
    "vyhubit",
    "vyjasnit",
    "vyjet",
    "vyjmout",
    "vyklopit",
    "vykonat",
    "vylekat",
    "vymazat",
    "vymezit",
    "vymizet",
    "vymyslet",
    "vynechat",
    "vynikat",
    "vynutit",
    "vypadat",
    "vyplatit",
    "vypravit",
    "vypustit",
    "vyrazit",
    "vyrovnat",
    "vyrvat",
    "vyslovit",
    "vysoko",
    "vystavit",
    "vysunout",
    "vysypat",
    "vytasit",
    "vytesat",
    "vytratit",
    "vyvinout",
    "vyvolat",
    "vyvrhel",
    "vyzdobit",
    "vyznat",
    "vzadu",
    "vzbudit",
    "vzchopit",
    "vzdor",
    "vzduch",
    "vzdychat",
    "vzestup",
    "vzhledem",
    "vzkaz",
    "vzlykat",
    "vznik",
    "vzorek",
    "vzpoura",
    "vztah",
    "vztek",
    "xylofon",
    "zabrat",
    "zabydlet",
    "zachovat",
    "zadarmo",
    "zadusit",
    "zafoukat",
    "zahltit",
    "zahodit",
    "zahrada",
    "zahynout",
    "zajatec",
    "zajet",
    "zajistit",
    "zaklepat",
    "zakoupit",
    "zalepit",
    "zamezit",
    "zamotat",
    "zamyslet",
    "zanechat",
    "zanikat",
    "zaplatit",
    "zapojit",
    "zapsat",
    "zarazit",
    "zastavit",
    "zasunout",
    "zatajit",
    "zatemnit",
    "zatknout",
    "zaujmout",
    "zavalit",
    "zavelet",
    "zavinit",
    "zavolat",
    "zavrtat",
    "zazvonit",
    "zbavit",
    "zbrusu",
    "zbudovat",
    "zbytek",
    "zdaleka",
    "zdarma",
    "zdatnost",
    "zdivo",
    "zdobit",
    "zdroj",
    "zdvih",
    "zdymadlo",
    "zelenina",
    "zeman",
    "zemina",
    "zeptat",
    "zezadu",
    "zezdola",
    "zhatit",
    "zhltnout",
    "zhluboka",
    "zhotovit",
    "zhruba",
    "zima",
    "zimnice",
    "zjemnit",
    "zklamat",
    "zkoumat",
    "zkratka",
    "zkumavka",
    "zlato",
    "zlehka",
    "zloba",
    "zlom",
    "zlost",
    "zlozvyk",
    "zmapovat",
    "zmar",
    "zmatek",
    "zmije",
    "zmizet",
    "zmocnit",
    "zmodrat",
    "zmrzlina",
    "zmutovat",
    "znak",
    "znalost",
    "znamenat",
    "znovu",
    "zobrazit",
    "zotavit",
    "zoubek",
    "zoufale",
    "zplodit",
    "zpomalit",
    "zprava",
    "zprostit",
    "zprudka",
    "zprvu",
    "zrada",
    "zranit",
    "zrcadlo",
    "zrnitost",
    "zrno",
    "zrovna",
    "zrychlit",
    "zrzavost",
    "zticha",
    "ztratit",
    "zubovina",
    "zubr",
    "zvednout",
    "zvenku",
    "zvesela",
    "zvon",
    "zvrat",
    "zvukovod",
    "zvyk"
], Jte = [
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "这",
    "中",
    "大",
    "为",
    "上",
    "个",
    "国",
    "我",
    "以",
    "要",
    "他",
    "时",
    "来",
    "用",
    "们",
    "生",
    "到",
    "作",
    "地",
    "于",
    "出",
    "就",
    "分",
    "对",
    "成",
    "会",
    "可",
    "主",
    "发",
    "年",
    "动",
    "同",
    "工",
    "也",
    "能",
    "下",
    "过",
    "子",
    "说",
    "产",
    "种",
    "面",
    "而",
    "方",
    "后",
    "多",
    "定",
    "行",
    "学",
    "法",
    "所",
    "民",
    "得",
    "经",
    "十",
    "三",
    "之",
    "进",
    "着",
    "等",
    "部",
    "度",
    "家",
    "电",
    "力",
    "里",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "现",
    "实",
    "加",
    "量",
    "都",
    "两",
    "体",
    "制",
    "机",
    "当",
    "使",
    "点",
    "从",
    "业",
    "本",
    "去",
    "把",
    "性",
    "好",
    "应",
    "开",
    "它",
    "合",
    "还",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "义",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "间",
    "样",
    "与",
    "关",
    "各",
    "重",
    "新",
    "线",
    "内",
    "数",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "么",
    "利",
    "比",
    "或",
    "但",
    "质",
    "气",
    "第",
    "向",
    "道",
    "命",
    "此",
    "变",
    "条",
    "只",
    "没",
    "结",
    "解",
    "问",
    "意",
    "建",
    "月",
    "公",
    "无",
    "系",
    "军",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "并",
    "提",
    "直",
    "题",
    "党",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "员",
    "革",
    "位",
    "入",
    "常",
    "文",
    "总",
    "次",
    "品",
    "式",
    "活",
    "设",
    "及",
    "管",
    "特",
    "件",
    "长",
    "求",
    "老",
    "头",
    "基",
    "资",
    "边",
    "流",
    "路",
    "级",
    "少",
    "图",
    "山",
    "统",
    "接",
    "知",
    "较",
    "将",
    "组",
    "见",
    "计",
    "别",
    "她",
    "手",
    "角",
    "期",
    "根",
    "论",
    "运",
    "农",
    "指",
    "几",
    "九",
    "区",
    "强",
    "放",
    "决",
    "西",
    "被",
    "干",
    "做",
    "必",
    "战",
    "先",
    "回",
    "则",
    "任",
    "取",
    "据",
    "处",
    "队",
    "南",
    "给",
    "色",
    "光",
    "门",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "规",
    "热",
    "领",
    "七",
    "海",
    "口",
    "东",
    "导",
    "器",
    "压",
    "志",
    "世",
    "金",
    "增",
    "争",
    "济",
    "阶",
    "油",
    "思",
    "术",
    "极",
    "交",
    "受",
    "联",
    "什",
    "认",
    "六",
    "共",
    "权",
    "收",
    "证",
    "改",
    "清",
    "美",
    "再",
    "采",
    "转",
    "更",
    "单",
    "风",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "带",
    "安",
    "场",
    "身",
    "车",
    "例",
    "真",
    "务",
    "具",
    "万",
    "每",
    "目",
    "至",
    "达",
    "走",
    "积",
    "示",
    "议",
    "声",
    "报",
    "斗",
    "完",
    "类",
    "八",
    "离",
    "华",
    "名",
    "确",
    "才",
    "科",
    "张",
    "信",
    "马",
    "节",
    "话",
    "米",
    "整",
    "空",
    "元",
    "况",
    "今",
    "集",
    "温",
    "传",
    "土",
    "许",
    "步",
    "群",
    "广",
    "石",
    "记",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "观",
    "越",
    "织",
    "装",
    "影",
    "算",
    "低",
    "持",
    "音",
    "众",
    "书",
    "布",
    "复",
    "容",
    "儿",
    "须",
    "际",
    "商",
    "非",
    "验",
    "连",
    "断",
    "深",
    "难",
    "近",
    "矿",
    "千",
    "周",
    "委",
    "素",
    "技",
    "备",
    "半",
    "办",
    "青",
    "省",
    "列",
    "习",
    "响",
    "约",
    "支",
    "般",
    "史",
    "感",
    "劳",
    "便",
    "团",
    "往",
    "酸",
    "历",
    "市",
    "克",
    "何",
    "除",
    "消",
    "构",
    "府",
    "称",
    "太",
    "准",
    "精",
    "值",
    "号",
    "率",
    "族",
    "维",
    "划",
    "选",
    "标",
    "写",
    "存",
    "候",
    "毛",
    "亲",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "养",
    "易",
    "置",
    "派",
    "层",
    "片",
    "始",
    "却",
    "专",
    "状",
    "育",
    "厂",
    "京",
    "识",
    "适",
    "属",
    "圆",
    "包",
    "火",
    "住",
    "调",
    "满",
    "县",
    "局",
    "照",
    "参",
    "红",
    "细",
    "引",
    "听",
    "该",
    "铁",
    "价",
    "严",
    "首",
    "底",
    "液",
    "官",
    "德",
    "随",
    "病",
    "苏",
    "失",
    "尔",
    "死",
    "讲",
    "配",
    "女",
    "黄",
    "推",
    "显",
    "谈",
    "罪",
    "神",
    "艺",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "营",
    "项",
    "防",
    "举",
    "球",
    "英",
    "氧",
    "势",
    "告",
    "李",
    "台",
    "落",
    "木",
    "帮",
    "轮",
    "破",
    "亚",
    "师",
    "围",
    "注",
    "远",
    "字",
    "材",
    "排",
    "供",
    "河",
    "态",
    "封",
    "另",
    "施",
    "减",
    "树",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "叶",
    "鱼",
    "波",
    "视",
    "仅",
    "费",
    "紧",
    "爱",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "续",
    "轻",
    "服",
    "试",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "护",
    "司",
    "足",
    "某",
    "练",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "负",
    "击",
    "范",
    "继",
    "兴",
    "似",
    "余",
    "坚",
    "曲",
    "输",
    "修",
    "故",
    "城",
    "夫",
    "够",
    "送",
    "笔",
    "船",
    "占",
    "右",
    "财",
    "吃",
    "富",
    "春",
    "职",
    "觉",
    "汉",
    "画",
    "功",
    "巴",
    "跟",
    "虽",
    "杂",
    "飞",
    "检",
    "吸",
    "助",
    "升",
    "阳",
    "互",
    "初",
    "创",
    "抗",
    "考",
    "投",
    "坏",
    "策",
    "古",
    "径",
    "换",
    "未",
    "跑",
    "留",
    "钢",
    "曾",
    "端",
    "责",
    "站",
    "简",
    "述",
    "钱",
    "副",
    "尽",
    "帝",
    "射",
    "草",
    "冲",
    "承",
    "独",
    "令",
    "限",
    "阿",
    "宣",
    "环",
    "双",
    "请",
    "超",
    "微",
    "让",
    "控",
    "州",
    "良",
    "轴",
    "找",
    "否",
    "纪",
    "益",
    "依",
    "优",
    "顶",
    "础",
    "载",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敌",
    "略",
    "客",
    "袁",
    "冷",
    "胜",
    "绝",
    "析",
    "块",
    "剂",
    "测",
    "丝",
    "协",
    "诉",
    "念",
    "陈",
    "仍",
    "罗",
    "盐",
    "友",
    "洋",
    "错",
    "苦",
    "夜",
    "刑",
    "移",
    "频",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "终",
    "聚",
    "汽",
    "村",
    "云",
    "哪",
    "既",
    "距",
    "卫",
    "停",
    "烈",
    "央",
    "察",
    "烧",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "游",
    "久",
    "菜",
    "味",
    "旧",
    "模",
    "湖",
    "货",
    "损",
    "预",
    "阻",
    "毫",
    "普",
    "稳",
    "乙",
    "妈",
    "植",
    "息",
    "扩",
    "银",
    "语",
    "挥",
    "酒",
    "守",
    "拿",
    "序",
    "纸",
    "医",
    "缺",
    "雨",
    "吗",
    "针",
    "刘",
    "啊",
    "急",
    "唱",
    "误",
    "训",
    "愿",
    "审",
    "附",
    "获",
    "茶",
    "鲜",
    "粮",
    "斤",
    "孩",
    "脱",
    "硫",
    "肥",
    "善",
    "龙",
    "演",
    "父",
    "渐",
    "血",
    "欢",
    "械",
    "掌",
    "歌",
    "沙",
    "刚",
    "攻",
    "谓",
    "盾",
    "讨",
    "晚",
    "粒",
    "乱",
    "燃",
    "矛",
    "乎",
    "杀",
    "药",
    "宁",
    "鲁",
    "贵",
    "钟",
    "煤",
    "读",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "丰",
    "培",
    "握",
    "兰",
    "担",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "执",
    "答",
    "乐",
    "谁",
    "顺",
    "烟",
    "缩",
    "征",
    "脸",
    "喜",
    "松",
    "脚",
    "困",
    "异",
    "免",
    "背",
    "星",
    "福",
    "买",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "静",
    "补",
    "评",
    "翻",
    "肉",
    "践",
    "尼",
    "衣",
    "宽",
    "扬",
    "棉",
    "希",
    "伤",
    "操",
    "垂",
    "秋",
    "宜",
    "氢",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "宪",
    "庆",
    "编",
    "牛",
    "触",
    "映",
    "雷",
    "销",
    "诗",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "绿",
    "晶",
    "厚",
    "盟",
    "衡",
    "鸡",
    "孙",
    "延",
    "危",
    "胶",
    "屋",
    "乡",
    "临",
    "陆",
    "顾",
    "掉",
    "呀",
    "灯",
    "岁",
    "措",
    "束",
    "耐",
    "剧",
    "玉",
    "赵",
    "跳",
    "哥",
    "季",
    "课",
    "凯",
    "胡",
    "额",
    "款",
    "绍",
    "卷",
    "齐",
    "伟",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "炉",
    "岩",
    "弱",
    "零",
    "杨",
    "奏",
    "沿",
    "露",
    "杆",
    "探",
    "滑",
    "镇",
    "饭",
    "浓",
    "航",
    "怀",
    "赶",
    "库",
    "夺",
    "伊",
    "灵",
    "税",
    "途",
    "灭",
    "赛",
    "归",
    "召",
    "鼓",
    "播",
    "盘",
    "裁",
    "险",
    "康",
    "唯",
    "录",
    "菌",
    "纯",
    "借",
    "糖",
    "盖",
    "横",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "枪",
    "润",
    "幅",
    "哈",
    "竟",
    "熟",
    "虫",
    "泽",
    "脑",
    "壤",
    "碳",
    "欧",
    "遍",
    "侧",
    "寨",
    "敢",
    "彻",
    "虑",
    "斜",
    "薄",
    "庭",
    "纳",
    "弹",
    "饲",
    "伸",
    "折",
    "麦",
    "湿",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "筑",
    "恶",
    "户",
    "访",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "迹",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "摆",
    "灰",
    "彩",
    "卖",
    "耗",
    "夏",
    "择",
    "忙",
    "铜",
    "献",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "阵",
    "阴",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "楼",
    "避",
    "谋",
    "吨",
    "野",
    "猪",
    "旗",
    "累",
    "偏",
    "典",
    "馆",
    "索",
    "秦",
    "脂",
    "潮",
    "爷",
    "豆",
    "忽",
    "托",
    "惊",
    "塑",
    "遗",
    "愈",
    "朱",
    "替",
    "纤",
    "粗",
    "倾",
    "尚",
    "痛",
    "楚",
    "谢",
    "奋",
    "购",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "监",
    "捕",
    "弟",
    "暴",
    "割",
    "贯",
    "殊",
    "释",
    "词",
    "亡",
    "壁",
    "顿",
    "宝",
    "午",
    "尘",
    "闻",
    "揭",
    "炮",
    "残",
    "冬",
    "桥",
    "妇",
    "警",
    "综",
    "招",
    "吴",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "摇",
    "谷",
    "赞",
    "箱",
    "隔",
    "订",
    "男",
    "吹",
    "园",
    "纷",
    "唐",
    "败",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "荣",
    "闭",
    "湾",
    "键",
    "凡",
    "驻",
    "锅",
    "救",
    "恩",
    "剥",
    "凝",
    "碱",
    "齿",
    "截",
    "炼",
    "麻",
    "纺",
    "禁",
    "废",
    "盛",
    "版",
    "缓",
    "净",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "庄",
    "街",
    "藏",
    "姑",
    "贸",
    "腐",
    "奴",
    "啦",
    "惯",
    "乘",
    "伙",
    "恢",
    "匀",
    "纱",
    "扎",
    "辩",
    "耳",
    "彪",
    "臣",
    "亿",
    "璃",
    "抵",
    "脉",
    "秀",
    "萨",
    "俄",
    "网",
    "舞",
    "店",
    "喷",
    "纵",
    "寸",
    "汗",
    "挂",
    "洪",
    "贺",
    "闪",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "墙",
    "软",
    "勇",
    "像",
    "滚",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "荡",
    "腿",
    "仪",
    "旅",
    "尾",
    "轧",
    "冰",
    "贡",
    "登",
    "黎",
    "削",
    "钻",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "币",
    "港",
    "伏",
    "轨",
    "亩",
    "毕",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "岛",
    "甘",
    "泡",
    "睡",
    "童",
    "铸",
    "汤",
    "阀",
    "休",
    "汇",
    "舍",
    "牧",
    "绕",
    "炸",
    "哲",
    "磷",
    "绩",
    "朋",
    "淡",
    "尖",
    "启",
    "陷",
    "柴",
    "呈",
    "徒",
    "颜",
    "泪",
    "稍",
    "忘",
    "泵",
    "蓝",
    "拖",
    "洞",
    "授",
    "镜",
    "辛",
    "壮",
    "锋",
    "贫",
    "虚",
    "弯",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "纲",
    "弄",
    "隶",
    "疑",
    "氏",
    "宫",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "违",
    "夹",
    "腰",
    "缘",
    "珠",
    "穷",
    "森",
    "枝",
    "竹",
    "沟",
    "催",
    "绳",
    "忆",
    "邦",
    "剩",
    "幸",
    "浆",
    "栏",
    "拥",
    "牙",
    "贮",
    "礼",
    "滤",
    "钠",
    "纹",
    "罢",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罚",
    "焦",
    "潜",
    "伍",
    "墨",
    "欲",
    "缝",
    "姓",
    "刊",
    "饱",
    "仿",
    "奖",
    "铝",
    "鬼",
    "丽",
    "跨",
    "默",
    "挖",
    "链",
    "扫",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "诸",
    "弧",
    "励",
    "梅",
    "奶",
    "洁",
    "灾",
    "舟",
    "鉴",
    "苯",
    "讼",
    "抱",
    "毁",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "届",
    "跃",
    "渡",
    "挑",
    "丹",
    "艰",
    "贝",
    "碰",
    "拔",
    "爹",
    "戴",
    "码",
    "梦",
    "芽",
    "熔",
    "赤",
    "渔",
    "哭",
    "敬",
    "颗",
    "奔",
    "铅",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "仓",
    "魏",
    "锐",
    "晓",
    "氮",
    "兼",
    "隐",
    "碍",
    "赫",
    "拨",
    "忠",
    "肃",
    "缸",
    "牵",
    "抢",
    "博",
    "巧",
    "壳",
    "兄",
    "杜",
    "讯",
    "诚",
    "碧",
    "祥",
    "柯",
    "页",
    "巡",
    "矩",
    "悲",
    "灌",
    "龄",
    "伦",
    "票",
    "寻",
    "桂",
    "铺",
    "圣",
    "恐",
    "恰",
    "郑",
    "趣",
    "抬",
    "荒",
    "腾",
    "贴",
    "柔",
    "滴",
    "猛",
    "阔",
    "辆",
    "妻",
    "填",
    "撤",
    "储",
    "签",
    "闹",
    "扰",
    "紫",
    "砂",
    "递",
    "戏",
    "吊",
    "陶",
    "伐",
    "喂",
    "疗",
    "瓶",
    "婆",
    "抚",
    "臂",
    "摸",
    "忍",
    "虾",
    "蜡",
    "邻",
    "胸",
    "巩",
    "挤",
    "偶",
    "弃",
    "槽",
    "劲",
    "乳",
    "邓",
    "吉",
    "仁",
    "烂",
    "砖",
    "租",
    "乌",
    "舰",
    "伴",
    "瓜",
    "浅",
    "丙",
    "暂",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "胆",
    "详",
    "簧",
    "踏",
    "瓷",
    "谱",
    "呆",
    "宾",
    "糊",
    "洛",
    "辉",
    "愤",
    "竞",
    "隙",
    "怒",
    "粘",
    "乃",
    "绪",
    "肩",
    "籍",
    "敏",
    "涂",
    "熙",
    "皆",
    "侦",
    "悬",
    "掘",
    "享",
    "纠",
    "醒",
    "狂",
    "锁",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "赏",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鸭",
    "趋",
    "凤",
    "晨",
    "畜",
    "辈",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "滩",
    "棋",
    "驱",
    "筛",
    "峡",
    "冒",
    "啥",
    "寿",
    "译",
    "浸",
    "泉",
    "帽",
    "迟",
    "硅",
    "疆",
    "贷",
    "漏",
    "稿",
    "冠",
    "嫩",
    "胁",
    "芯",
    "牢",
    "叛",
    "蚀",
    "奥",
    "鸣",
    "岭",
    "羊",
    "凭",
    "串",
    "塘",
    "绘",
    "酵",
    "融",
    "盆",
    "锡",
    "庙",
    "筹",
    "冻",
    "辅",
    "摄",
    "袭",
    "筋",
    "拒",
    "僚",
    "旱",
    "钾",
    "鸟",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韩",
    "逼",
    "扭",
    "侨",
    "凉",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "馏",
    "劝",
    "豪",
    "辽",
    "勃",
    "鸿",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "辊",
    "掩",
    "饮",
    "搬",
    "骂",
    "辞",
    "勾",
    "扣",
    "估",
    "蒋",
    "绒",
    "雾",
    "丈",
    "朵",
    "姆",
    "拟",
    "宇",
    "辑",
    "陕",
    "雕",
    "偿",
    "蓄",
    "崇",
    "剪",
    "倡",
    "厅",
    "咬",
    "驶",
    "薯",
    "刷",
    "斥",
    "番",
    "赋",
    "奉",
    "佛",
    "浇",
    "漫",
    "曼",
    "扇",
    "钙",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "亏",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "骗",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "胀",
    "谐",
    "抛",
    "霉",
    "桑",
    "岗",
    "嘛",
    "衰",
    "盗",
    "渗",
    "脏",
    "赖",
    "涌",
    "甜",
    "曹",
    "阅",
    "肌",
    "哩",
    "厉",
    "烃",
    "纬",
    "毅",
    "昨",
    "伪",
    "症",
    "煮",
    "叹",
    "钉",
    "搭",
    "茎",
    "笼",
    "酷",
    "偷",
    "弓",
    "锥",
    "恒",
    "杰",
    "坑",
    "鼻",
    "翼",
    "纶",
    "叙",
    "狱",
    "逮",
    "罐",
    "络",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "骤",
    "穆",
    "冶",
    "枯",
    "册",
    "尸",
    "凸",
    "绅",
    "坯",
    "牺",
    "焰",
    "轰",
    "欣",
    "晋",
    "瘦",
    "御",
    "锭",
    "锦",
    "丧",
    "旬",
    "锻",
    "垄",
    "搜",
    "扑",
    "邀",
    "亭",
    "酯",
    "迈",
    "舒",
    "脆",
    "酶",
    "闲",
    "忧",
    "酚",
    "顽",
    "羽",
    "涨",
    "卸",
    "仗",
    "陪",
    "辟",
    "惩",
    "杭",
    "姚",
    "肚",
    "捉",
    "飘",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "饰",
    "萧",
    "雅",
    "邮",
    "迁",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "烦",
    "债",
    "帐",
    "斑",
    "铃",
    "旨",
    "醇",
    "董",
    "饼",
    "雏",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "贤",
    "拆",
    "歪",
    "葡",
    "胺",
    "丢",
    "浩",
    "徽",
    "昂",
    "垫",
    "挡",
    "览",
    "贪",
    "慰",
    "缴",
    "汪",
    "慌",
    "冯",
    "诺",
    "姜",
    "谊",
    "凶",
    "劣",
    "诬",
    "耀",
    "昏",
    "躺",
    "盈",
    "骑",
    "乔",
    "溪",
    "丛",
    "卢",
    "抹",
    "闷",
    "咨",
    "刮",
    "驾",
    "缆",
    "悟",
    "摘",
    "铒",
    "掷",
    "颇",
    "幻",
    "柄",
    "惠",
    "惨",
    "佳",
    "仇",
    "腊",
    "窝",
    "涤",
    "剑",
    "瞧",
    "堡",
    "泼",
    "葱",
    "罩",
    "霍",
    "捞",
    "胎",
    "苍",
    "滨",
    "俩",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "疯",
    "淮",
    "遂",
    "熊",
    "粪",
    "烘",
    "宿",
    "档",
    "戈",
    "驳",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "肠",
    "撑",
    "晒",
    "辨",
    "殿",
    "莲",
    "摊",
    "搅",
    "酱",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皱",
    "畅",
    "叠",
    "阁",
    "莱",
    "敲",
    "辖",
    "钩",
    "痕",
    "坝",
    "巷",
    "饿",
    "祸",
    "丘",
    "玄",
    "溜",
    "曰",
    "逻",
    "彭",
    "尝",
    "卿",
    "妨",
    "艇",
    "吞",
    "韦",
    "怨",
    "矮",
    "歇"
], Qte = [
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "這",
    "中",
    "大",
    "為",
    "上",
    "個",
    "國",
    "我",
    "以",
    "要",
    "他",
    "時",
    "來",
    "用",
    "們",
    "生",
    "到",
    "作",
    "地",
    "於",
    "出",
    "就",
    "分",
    "對",
    "成",
    "會",
    "可",
    "主",
    "發",
    "年",
    "動",
    "同",
    "工",
    "也",
    "能",
    "下",
    "過",
    "子",
    "說",
    "產",
    "種",
    "面",
    "而",
    "方",
    "後",
    "多",
    "定",
    "行",
    "學",
    "法",
    "所",
    "民",
    "得",
    "經",
    "十",
    "三",
    "之",
    "進",
    "著",
    "等",
    "部",
    "度",
    "家",
    "電",
    "力",
    "裡",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "現",
    "實",
    "加",
    "量",
    "都",
    "兩",
    "體",
    "制",
    "機",
    "當",
    "使",
    "點",
    "從",
    "業",
    "本",
    "去",
    "把",
    "性",
    "好",
    "應",
    "開",
    "它",
    "合",
    "還",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "義",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "間",
    "樣",
    "與",
    "關",
    "各",
    "重",
    "新",
    "線",
    "內",
    "數",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "麼",
    "利",
    "比",
    "或",
    "但",
    "質",
    "氣",
    "第",
    "向",
    "道",
    "命",
    "此",
    "變",
    "條",
    "只",
    "沒",
    "結",
    "解",
    "問",
    "意",
    "建",
    "月",
    "公",
    "無",
    "系",
    "軍",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "並",
    "提",
    "直",
    "題",
    "黨",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "員",
    "革",
    "位",
    "入",
    "常",
    "文",
    "總",
    "次",
    "品",
    "式",
    "活",
    "設",
    "及",
    "管",
    "特",
    "件",
    "長",
    "求",
    "老",
    "頭",
    "基",
    "資",
    "邊",
    "流",
    "路",
    "級",
    "少",
    "圖",
    "山",
    "統",
    "接",
    "知",
    "較",
    "將",
    "組",
    "見",
    "計",
    "別",
    "她",
    "手",
    "角",
    "期",
    "根",
    "論",
    "運",
    "農",
    "指",
    "幾",
    "九",
    "區",
    "強",
    "放",
    "決",
    "西",
    "被",
    "幹",
    "做",
    "必",
    "戰",
    "先",
    "回",
    "則",
    "任",
    "取",
    "據",
    "處",
    "隊",
    "南",
    "給",
    "色",
    "光",
    "門",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "規",
    "熱",
    "領",
    "七",
    "海",
    "口",
    "東",
    "導",
    "器",
    "壓",
    "志",
    "世",
    "金",
    "增",
    "爭",
    "濟",
    "階",
    "油",
    "思",
    "術",
    "極",
    "交",
    "受",
    "聯",
    "什",
    "認",
    "六",
    "共",
    "權",
    "收",
    "證",
    "改",
    "清",
    "美",
    "再",
    "採",
    "轉",
    "更",
    "單",
    "風",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "帶",
    "安",
    "場",
    "身",
    "車",
    "例",
    "真",
    "務",
    "具",
    "萬",
    "每",
    "目",
    "至",
    "達",
    "走",
    "積",
    "示",
    "議",
    "聲",
    "報",
    "鬥",
    "完",
    "類",
    "八",
    "離",
    "華",
    "名",
    "確",
    "才",
    "科",
    "張",
    "信",
    "馬",
    "節",
    "話",
    "米",
    "整",
    "空",
    "元",
    "況",
    "今",
    "集",
    "溫",
    "傳",
    "土",
    "許",
    "步",
    "群",
    "廣",
    "石",
    "記",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "觀",
    "越",
    "織",
    "裝",
    "影",
    "算",
    "低",
    "持",
    "音",
    "眾",
    "書",
    "布",
    "复",
    "容",
    "兒",
    "須",
    "際",
    "商",
    "非",
    "驗",
    "連",
    "斷",
    "深",
    "難",
    "近",
    "礦",
    "千",
    "週",
    "委",
    "素",
    "技",
    "備",
    "半",
    "辦",
    "青",
    "省",
    "列",
    "習",
    "響",
    "約",
    "支",
    "般",
    "史",
    "感",
    "勞",
    "便",
    "團",
    "往",
    "酸",
    "歷",
    "市",
    "克",
    "何",
    "除",
    "消",
    "構",
    "府",
    "稱",
    "太",
    "準",
    "精",
    "值",
    "號",
    "率",
    "族",
    "維",
    "劃",
    "選",
    "標",
    "寫",
    "存",
    "候",
    "毛",
    "親",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "養",
    "易",
    "置",
    "派",
    "層",
    "片",
    "始",
    "卻",
    "專",
    "狀",
    "育",
    "廠",
    "京",
    "識",
    "適",
    "屬",
    "圓",
    "包",
    "火",
    "住",
    "調",
    "滿",
    "縣",
    "局",
    "照",
    "參",
    "紅",
    "細",
    "引",
    "聽",
    "該",
    "鐵",
    "價",
    "嚴",
    "首",
    "底",
    "液",
    "官",
    "德",
    "隨",
    "病",
    "蘇",
    "失",
    "爾",
    "死",
    "講",
    "配",
    "女",
    "黃",
    "推",
    "顯",
    "談",
    "罪",
    "神",
    "藝",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "營",
    "項",
    "防",
    "舉",
    "球",
    "英",
    "氧",
    "勢",
    "告",
    "李",
    "台",
    "落",
    "木",
    "幫",
    "輪",
    "破",
    "亞",
    "師",
    "圍",
    "注",
    "遠",
    "字",
    "材",
    "排",
    "供",
    "河",
    "態",
    "封",
    "另",
    "施",
    "減",
    "樹",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "葉",
    "魚",
    "波",
    "視",
    "僅",
    "費",
    "緊",
    "愛",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "續",
    "輕",
    "服",
    "試",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "護",
    "司",
    "足",
    "某",
    "練",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "負",
    "擊",
    "范",
    "繼",
    "興",
    "似",
    "餘",
    "堅",
    "曲",
    "輸",
    "修",
    "故",
    "城",
    "夫",
    "夠",
    "送",
    "筆",
    "船",
    "佔",
    "右",
    "財",
    "吃",
    "富",
    "春",
    "職",
    "覺",
    "漢",
    "畫",
    "功",
    "巴",
    "跟",
    "雖",
    "雜",
    "飛",
    "檢",
    "吸",
    "助",
    "昇",
    "陽",
    "互",
    "初",
    "創",
    "抗",
    "考",
    "投",
    "壞",
    "策",
    "古",
    "徑",
    "換",
    "未",
    "跑",
    "留",
    "鋼",
    "曾",
    "端",
    "責",
    "站",
    "簡",
    "述",
    "錢",
    "副",
    "盡",
    "帝",
    "射",
    "草",
    "衝",
    "承",
    "獨",
    "令",
    "限",
    "阿",
    "宣",
    "環",
    "雙",
    "請",
    "超",
    "微",
    "讓",
    "控",
    "州",
    "良",
    "軸",
    "找",
    "否",
    "紀",
    "益",
    "依",
    "優",
    "頂",
    "礎",
    "載",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敵",
    "略",
    "客",
    "袁",
    "冷",
    "勝",
    "絕",
    "析",
    "塊",
    "劑",
    "測",
    "絲",
    "協",
    "訴",
    "念",
    "陳",
    "仍",
    "羅",
    "鹽",
    "友",
    "洋",
    "錯",
    "苦",
    "夜",
    "刑",
    "移",
    "頻",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "終",
    "聚",
    "汽",
    "村",
    "雲",
    "哪",
    "既",
    "距",
    "衛",
    "停",
    "烈",
    "央",
    "察",
    "燒",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "遊",
    "久",
    "菜",
    "味",
    "舊",
    "模",
    "湖",
    "貨",
    "損",
    "預",
    "阻",
    "毫",
    "普",
    "穩",
    "乙",
    "媽",
    "植",
    "息",
    "擴",
    "銀",
    "語",
    "揮",
    "酒",
    "守",
    "拿",
    "序",
    "紙",
    "醫",
    "缺",
    "雨",
    "嗎",
    "針",
    "劉",
    "啊",
    "急",
    "唱",
    "誤",
    "訓",
    "願",
    "審",
    "附",
    "獲",
    "茶",
    "鮮",
    "糧",
    "斤",
    "孩",
    "脫",
    "硫",
    "肥",
    "善",
    "龍",
    "演",
    "父",
    "漸",
    "血",
    "歡",
    "械",
    "掌",
    "歌",
    "沙",
    "剛",
    "攻",
    "謂",
    "盾",
    "討",
    "晚",
    "粒",
    "亂",
    "燃",
    "矛",
    "乎",
    "殺",
    "藥",
    "寧",
    "魯",
    "貴",
    "鐘",
    "煤",
    "讀",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "豐",
    "培",
    "握",
    "蘭",
    "擔",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "執",
    "答",
    "樂",
    "誰",
    "順",
    "煙",
    "縮",
    "徵",
    "臉",
    "喜",
    "松",
    "腳",
    "困",
    "異",
    "免",
    "背",
    "星",
    "福",
    "買",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "靜",
    "補",
    "評",
    "翻",
    "肉",
    "踐",
    "尼",
    "衣",
    "寬",
    "揚",
    "棉",
    "希",
    "傷",
    "操",
    "垂",
    "秋",
    "宜",
    "氫",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "憲",
    "慶",
    "編",
    "牛",
    "觸",
    "映",
    "雷",
    "銷",
    "詩",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "綠",
    "晶",
    "厚",
    "盟",
    "衡",
    "雞",
    "孫",
    "延",
    "危",
    "膠",
    "屋",
    "鄉",
    "臨",
    "陸",
    "顧",
    "掉",
    "呀",
    "燈",
    "歲",
    "措",
    "束",
    "耐",
    "劇",
    "玉",
    "趙",
    "跳",
    "哥",
    "季",
    "課",
    "凱",
    "胡",
    "額",
    "款",
    "紹",
    "卷",
    "齊",
    "偉",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "爐",
    "岩",
    "弱",
    "零",
    "楊",
    "奏",
    "沿",
    "露",
    "桿",
    "探",
    "滑",
    "鎮",
    "飯",
    "濃",
    "航",
    "懷",
    "趕",
    "庫",
    "奪",
    "伊",
    "靈",
    "稅",
    "途",
    "滅",
    "賽",
    "歸",
    "召",
    "鼓",
    "播",
    "盤",
    "裁",
    "險",
    "康",
    "唯",
    "錄",
    "菌",
    "純",
    "借",
    "糖",
    "蓋",
    "橫",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "槍",
    "潤",
    "幅",
    "哈",
    "竟",
    "熟",
    "蟲",
    "澤",
    "腦",
    "壤",
    "碳",
    "歐",
    "遍",
    "側",
    "寨",
    "敢",
    "徹",
    "慮",
    "斜",
    "薄",
    "庭",
    "納",
    "彈",
    "飼",
    "伸",
    "折",
    "麥",
    "濕",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "築",
    "惡",
    "戶",
    "訪",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "跡",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "擺",
    "灰",
    "彩",
    "賣",
    "耗",
    "夏",
    "擇",
    "忙",
    "銅",
    "獻",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "陣",
    "陰",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "樓",
    "避",
    "謀",
    "噸",
    "野",
    "豬",
    "旗",
    "累",
    "偏",
    "典",
    "館",
    "索",
    "秦",
    "脂",
    "潮",
    "爺",
    "豆",
    "忽",
    "托",
    "驚",
    "塑",
    "遺",
    "愈",
    "朱",
    "替",
    "纖",
    "粗",
    "傾",
    "尚",
    "痛",
    "楚",
    "謝",
    "奮",
    "購",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "監",
    "捕",
    "弟",
    "暴",
    "割",
    "貫",
    "殊",
    "釋",
    "詞",
    "亡",
    "壁",
    "頓",
    "寶",
    "午",
    "塵",
    "聞",
    "揭",
    "炮",
    "殘",
    "冬",
    "橋",
    "婦",
    "警",
    "綜",
    "招",
    "吳",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "搖",
    "谷",
    "贊",
    "箱",
    "隔",
    "訂",
    "男",
    "吹",
    "園",
    "紛",
    "唐",
    "敗",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "榮",
    "閉",
    "灣",
    "鍵",
    "凡",
    "駐",
    "鍋",
    "救",
    "恩",
    "剝",
    "凝",
    "鹼",
    "齒",
    "截",
    "煉",
    "麻",
    "紡",
    "禁",
    "廢",
    "盛",
    "版",
    "緩",
    "淨",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "莊",
    "街",
    "藏",
    "姑",
    "貿",
    "腐",
    "奴",
    "啦",
    "慣",
    "乘",
    "夥",
    "恢",
    "勻",
    "紗",
    "扎",
    "辯",
    "耳",
    "彪",
    "臣",
    "億",
    "璃",
    "抵",
    "脈",
    "秀",
    "薩",
    "俄",
    "網",
    "舞",
    "店",
    "噴",
    "縱",
    "寸",
    "汗",
    "掛",
    "洪",
    "賀",
    "閃",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "牆",
    "軟",
    "勇",
    "像",
    "滾",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "盪",
    "腿",
    "儀",
    "旅",
    "尾",
    "軋",
    "冰",
    "貢",
    "登",
    "黎",
    "削",
    "鑽",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "幣",
    "港",
    "伏",
    "軌",
    "畝",
    "畢",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "島",
    "甘",
    "泡",
    "睡",
    "童",
    "鑄",
    "湯",
    "閥",
    "休",
    "匯",
    "舍",
    "牧",
    "繞",
    "炸",
    "哲",
    "磷",
    "績",
    "朋",
    "淡",
    "尖",
    "啟",
    "陷",
    "柴",
    "呈",
    "徒",
    "顏",
    "淚",
    "稍",
    "忘",
    "泵",
    "藍",
    "拖",
    "洞",
    "授",
    "鏡",
    "辛",
    "壯",
    "鋒",
    "貧",
    "虛",
    "彎",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "綱",
    "弄",
    "隸",
    "疑",
    "氏",
    "宮",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "違",
    "夾",
    "腰",
    "緣",
    "珠",
    "窮",
    "森",
    "枝",
    "竹",
    "溝",
    "催",
    "繩",
    "憶",
    "邦",
    "剩",
    "幸",
    "漿",
    "欄",
    "擁",
    "牙",
    "貯",
    "禮",
    "濾",
    "鈉",
    "紋",
    "罷",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罰",
    "焦",
    "潛",
    "伍",
    "墨",
    "欲",
    "縫",
    "姓",
    "刊",
    "飽",
    "仿",
    "獎",
    "鋁",
    "鬼",
    "麗",
    "跨",
    "默",
    "挖",
    "鏈",
    "掃",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "諸",
    "弧",
    "勵",
    "梅",
    "奶",
    "潔",
    "災",
    "舟",
    "鑑",
    "苯",
    "訟",
    "抱",
    "毀",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "屆",
    "躍",
    "渡",
    "挑",
    "丹",
    "艱",
    "貝",
    "碰",
    "拔",
    "爹",
    "戴",
    "碼",
    "夢",
    "芽",
    "熔",
    "赤",
    "漁",
    "哭",
    "敬",
    "顆",
    "奔",
    "鉛",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "倉",
    "魏",
    "銳",
    "曉",
    "氮",
    "兼",
    "隱",
    "礙",
    "赫",
    "撥",
    "忠",
    "肅",
    "缸",
    "牽",
    "搶",
    "博",
    "巧",
    "殼",
    "兄",
    "杜",
    "訊",
    "誠",
    "碧",
    "祥",
    "柯",
    "頁",
    "巡",
    "矩",
    "悲",
    "灌",
    "齡",
    "倫",
    "票",
    "尋",
    "桂",
    "鋪",
    "聖",
    "恐",
    "恰",
    "鄭",
    "趣",
    "抬",
    "荒",
    "騰",
    "貼",
    "柔",
    "滴",
    "猛",
    "闊",
    "輛",
    "妻",
    "填",
    "撤",
    "儲",
    "簽",
    "鬧",
    "擾",
    "紫",
    "砂",
    "遞",
    "戲",
    "吊",
    "陶",
    "伐",
    "餵",
    "療",
    "瓶",
    "婆",
    "撫",
    "臂",
    "摸",
    "忍",
    "蝦",
    "蠟",
    "鄰",
    "胸",
    "鞏",
    "擠",
    "偶",
    "棄",
    "槽",
    "勁",
    "乳",
    "鄧",
    "吉",
    "仁",
    "爛",
    "磚",
    "租",
    "烏",
    "艦",
    "伴",
    "瓜",
    "淺",
    "丙",
    "暫",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "膽",
    "詳",
    "簧",
    "踏",
    "瓷",
    "譜",
    "呆",
    "賓",
    "糊",
    "洛",
    "輝",
    "憤",
    "競",
    "隙",
    "怒",
    "粘",
    "乃",
    "緒",
    "肩",
    "籍",
    "敏",
    "塗",
    "熙",
    "皆",
    "偵",
    "懸",
    "掘",
    "享",
    "糾",
    "醒",
    "狂",
    "鎖",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "賞",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鴨",
    "趨",
    "鳳",
    "晨",
    "畜",
    "輩",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "灘",
    "棋",
    "驅",
    "篩",
    "峽",
    "冒",
    "啥",
    "壽",
    "譯",
    "浸",
    "泉",
    "帽",
    "遲",
    "矽",
    "疆",
    "貸",
    "漏",
    "稿",
    "冠",
    "嫩",
    "脅",
    "芯",
    "牢",
    "叛",
    "蝕",
    "奧",
    "鳴",
    "嶺",
    "羊",
    "憑",
    "串",
    "塘",
    "繪",
    "酵",
    "融",
    "盆",
    "錫",
    "廟",
    "籌",
    "凍",
    "輔",
    "攝",
    "襲",
    "筋",
    "拒",
    "僚",
    "旱",
    "鉀",
    "鳥",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韓",
    "逼",
    "扭",
    "僑",
    "涼",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "餾",
    "勸",
    "豪",
    "遼",
    "勃",
    "鴻",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "輥",
    "掩",
    "飲",
    "搬",
    "罵",
    "辭",
    "勾",
    "扣",
    "估",
    "蔣",
    "絨",
    "霧",
    "丈",
    "朵",
    "姆",
    "擬",
    "宇",
    "輯",
    "陝",
    "雕",
    "償",
    "蓄",
    "崇",
    "剪",
    "倡",
    "廳",
    "咬",
    "駛",
    "薯",
    "刷",
    "斥",
    "番",
    "賦",
    "奉",
    "佛",
    "澆",
    "漫",
    "曼",
    "扇",
    "鈣",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "虧",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "騙",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "脹",
    "諧",
    "拋",
    "黴",
    "桑",
    "崗",
    "嘛",
    "衰",
    "盜",
    "滲",
    "臟",
    "賴",
    "湧",
    "甜",
    "曹",
    "閱",
    "肌",
    "哩",
    "厲",
    "烴",
    "緯",
    "毅",
    "昨",
    "偽",
    "症",
    "煮",
    "嘆",
    "釘",
    "搭",
    "莖",
    "籠",
    "酷",
    "偷",
    "弓",
    "錐",
    "恆",
    "傑",
    "坑",
    "鼻",
    "翼",
    "綸",
    "敘",
    "獄",
    "逮",
    "罐",
    "絡",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "驟",
    "穆",
    "冶",
    "枯",
    "冊",
    "屍",
    "凸",
    "紳",
    "坯",
    "犧",
    "焰",
    "轟",
    "欣",
    "晉",
    "瘦",
    "禦",
    "錠",
    "錦",
    "喪",
    "旬",
    "鍛",
    "壟",
    "搜",
    "撲",
    "邀",
    "亭",
    "酯",
    "邁",
    "舒",
    "脆",
    "酶",
    "閒",
    "憂",
    "酚",
    "頑",
    "羽",
    "漲",
    "卸",
    "仗",
    "陪",
    "闢",
    "懲",
    "杭",
    "姚",
    "肚",
    "捉",
    "飄",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "飾",
    "蕭",
    "雅",
    "郵",
    "遷",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "煩",
    "債",
    "帳",
    "斑",
    "鈴",
    "旨",
    "醇",
    "董",
    "餅",
    "雛",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "賢",
    "拆",
    "歪",
    "葡",
    "胺",
    "丟",
    "浩",
    "徽",
    "昂",
    "墊",
    "擋",
    "覽",
    "貪",
    "慰",
    "繳",
    "汪",
    "慌",
    "馮",
    "諾",
    "姜",
    "誼",
    "兇",
    "劣",
    "誣",
    "耀",
    "昏",
    "躺",
    "盈",
    "騎",
    "喬",
    "溪",
    "叢",
    "盧",
    "抹",
    "悶",
    "諮",
    "刮",
    "駕",
    "纜",
    "悟",
    "摘",
    "鉺",
    "擲",
    "頗",
    "幻",
    "柄",
    "惠",
    "慘",
    "佳",
    "仇",
    "臘",
    "窩",
    "滌",
    "劍",
    "瞧",
    "堡",
    "潑",
    "蔥",
    "罩",
    "霍",
    "撈",
    "胎",
    "蒼",
    "濱",
    "倆",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "瘋",
    "淮",
    "遂",
    "熊",
    "糞",
    "烘",
    "宿",
    "檔",
    "戈",
    "駁",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "腸",
    "撐",
    "曬",
    "辨",
    "殿",
    "蓮",
    "攤",
    "攪",
    "醬",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皺",
    "暢",
    "疊",
    "閣",
    "萊",
    "敲",
    "轄",
    "鉤",
    "痕",
    "壩",
    "巷",
    "餓",
    "禍",
    "丘",
    "玄",
    "溜",
    "曰",
    "邏",
    "彭",
    "嘗",
    "卿",
    "妨",
    "艇",
    "吞",
    "韋",
    "怨",
    "矮",
    "歇"
], ere = [
    "가격",
    "가끔",
    "가난",
    "가능",
    "가득",
    "가르침",
    "가뭄",
    "가방",
    "가상",
    "가슴",
    "가운데",
    "가을",
    "가이드",
    "가입",
    "가장",
    "가정",
    "가족",
    "가죽",
    "각오",
    "각자",
    "간격",
    "간부",
    "간섭",
    "간장",
    "간접",
    "간판",
    "갈등",
    "갈비",
    "갈색",
    "갈증",
    "감각",
    "감기",
    "감소",
    "감수성",
    "감자",
    "감정",
    "갑자기",
    "강남",
    "강당",
    "강도",
    "강력히",
    "강변",
    "강북",
    "강사",
    "강수량",
    "강아지",
    "강원도",
    "강의",
    "강제",
    "강조",
    "같이",
    "개구리",
    "개나리",
    "개방",
    "개별",
    "개선",
    "개성",
    "개인",
    "객관적",
    "거실",
    "거액",
    "거울",
    "거짓",
    "거품",
    "걱정",
    "건강",
    "건물",
    "건설",
    "건조",
    "건축",
    "걸음",
    "검사",
    "검토",
    "게시판",
    "게임",
    "겨울",
    "견해",
    "결과",
    "결국",
    "결론",
    "결석",
    "결승",
    "결심",
    "결정",
    "결혼",
    "경계",
    "경고",
    "경기",
    "경력",
    "경복궁",
    "경비",
    "경상도",
    "경영",
    "경우",
    "경쟁",
    "경제",
    "경주",
    "경찰",
    "경치",
    "경향",
    "경험",
    "계곡",
    "계단",
    "계란",
    "계산",
    "계속",
    "계약",
    "계절",
    "계층",
    "계획",
    "고객",
    "고구려",
    "고궁",
    "고급",
    "고등학생",
    "고무신",
    "고민",
    "고양이",
    "고장",
    "고전",
    "고집",
    "고춧가루",
    "고통",
    "고향",
    "곡식",
    "골목",
    "골짜기",
    "골프",
    "공간",
    "공개",
    "공격",
    "공군",
    "공급",
    "공기",
    "공동",
    "공무원",
    "공부",
    "공사",
    "공식",
    "공업",
    "공연",
    "공원",
    "공장",
    "공짜",
    "공책",
    "공통",
    "공포",
    "공항",
    "공휴일",
    "과목",
    "과일",
    "과장",
    "과정",
    "과학",
    "관객",
    "관계",
    "관광",
    "관념",
    "관람",
    "관련",
    "관리",
    "관습",
    "관심",
    "관점",
    "관찰",
    "광경",
    "광고",
    "광장",
    "광주",
    "괴로움",
    "굉장히",
    "교과서",
    "교문",
    "교복",
    "교실",
    "교양",
    "교육",
    "교장",
    "교직",
    "교통",
    "교환",
    "교훈",
    "구경",
    "구름",
    "구멍",
    "구별",
    "구분",
    "구석",
    "구성",
    "구속",
    "구역",
    "구입",
    "구청",
    "구체적",
    "국가",
    "국기",
    "국내",
    "국립",
    "국물",
    "국민",
    "국수",
    "국어",
    "국왕",
    "국적",
    "국제",
    "국회",
    "군대",
    "군사",
    "군인",
    "궁극적",
    "권리",
    "권위",
    "권투",
    "귀국",
    "귀신",
    "규정",
    "규칙",
    "균형",
    "그날",
    "그냥",
    "그늘",
    "그러나",
    "그룹",
    "그릇",
    "그림",
    "그제서야",
    "그토록",
    "극복",
    "극히",
    "근거",
    "근교",
    "근래",
    "근로",
    "근무",
    "근본",
    "근원",
    "근육",
    "근처",
    "글씨",
    "글자",
    "금강산",
    "금고",
    "금년",
    "금메달",
    "금액",
    "금연",
    "금요일",
    "금지",
    "긍정적",
    "기간",
    "기관",
    "기념",
    "기능",
    "기독교",
    "기둥",
    "기록",
    "기름",
    "기법",
    "기본",
    "기분",
    "기쁨",
    "기숙사",
    "기술",
    "기억",
    "기업",
    "기온",
    "기운",
    "기원",
    "기적",
    "기준",
    "기침",
    "기혼",
    "기획",
    "긴급",
    "긴장",
    "길이",
    "김밥",
    "김치",
    "김포공항",
    "깍두기",
    "깜빡",
    "깨달음",
    "깨소금",
    "껍질",
    "꼭대기",
    "꽃잎",
    "나들이",
    "나란히",
    "나머지",
    "나물",
    "나침반",
    "나흘",
    "낙엽",
    "난방",
    "날개",
    "날씨",
    "날짜",
    "남녀",
    "남대문",
    "남매",
    "남산",
    "남자",
    "남편",
    "남학생",
    "낭비",
    "낱말",
    "내년",
    "내용",
    "내일",
    "냄비",
    "냄새",
    "냇물",
    "냉동",
    "냉면",
    "냉방",
    "냉장고",
    "넥타이",
    "넷째",
    "노동",
    "노란색",
    "노력",
    "노인",
    "녹음",
    "녹차",
    "녹화",
    "논리",
    "논문",
    "논쟁",
    "놀이",
    "농구",
    "농담",
    "농민",
    "농부",
    "농업",
    "농장",
    "농촌",
    "높이",
    "눈동자",
    "눈물",
    "눈썹",
    "뉴욕",
    "느낌",
    "늑대",
    "능동적",
    "능력",
    "다방",
    "다양성",
    "다음",
    "다이어트",
    "다행",
    "단계",
    "단골",
    "단독",
    "단맛",
    "단순",
    "단어",
    "단위",
    "단점",
    "단체",
    "단추",
    "단편",
    "단풍",
    "달걀",
    "달러",
    "달력",
    "달리",
    "닭고기",
    "담당",
    "담배",
    "담요",
    "담임",
    "답변",
    "답장",
    "당근",
    "당분간",
    "당연히",
    "당장",
    "대규모",
    "대낮",
    "대단히",
    "대답",
    "대도시",
    "대략",
    "대량",
    "대륙",
    "대문",
    "대부분",
    "대신",
    "대응",
    "대장",
    "대전",
    "대접",
    "대중",
    "대책",
    "대출",
    "대충",
    "대통령",
    "대학",
    "대한민국",
    "대합실",
    "대형",
    "덩어리",
    "데이트",
    "도대체",
    "도덕",
    "도둑",
    "도망",
    "도서관",
    "도심",
    "도움",
    "도입",
    "도자기",
    "도저히",
    "도전",
    "도중",
    "도착",
    "독감",
    "독립",
    "독서",
    "독일",
    "독창적",
    "동화책",
    "뒷모습",
    "뒷산",
    "딸아이",
    "마누라",
    "마늘",
    "마당",
    "마라톤",
    "마련",
    "마무리",
    "마사지",
    "마약",
    "마요네즈",
    "마을",
    "마음",
    "마이크",
    "마중",
    "마지막",
    "마찬가지",
    "마찰",
    "마흔",
    "막걸리",
    "막내",
    "막상",
    "만남",
    "만두",
    "만세",
    "만약",
    "만일",
    "만점",
    "만족",
    "만화",
    "많이",
    "말기",
    "말씀",
    "말투",
    "맘대로",
    "망원경",
    "매년",
    "매달",
    "매력",
    "매번",
    "매스컴",
    "매일",
    "매장",
    "맥주",
    "먹이",
    "먼저",
    "먼지",
    "멀리",
    "메일",
    "며느리",
    "며칠",
    "면담",
    "멸치",
    "명단",
    "명령",
    "명예",
    "명의",
    "명절",
    "명칭",
    "명함",
    "모금",
    "모니터",
    "모델",
    "모든",
    "모범",
    "모습",
    "모양",
    "모임",
    "모조리",
    "모집",
    "모퉁이",
    "목걸이",
    "목록",
    "목사",
    "목소리",
    "목숨",
    "목적",
    "목표",
    "몰래",
    "몸매",
    "몸무게",
    "몸살",
    "몸속",
    "몸짓",
    "몸통",
    "몹시",
    "무관심",
    "무궁화",
    "무더위",
    "무덤",
    "무릎",
    "무슨",
    "무엇",
    "무역",
    "무용",
    "무조건",
    "무지개",
    "무척",
    "문구",
    "문득",
    "문법",
    "문서",
    "문제",
    "문학",
    "문화",
    "물가",
    "물건",
    "물결",
    "물고기",
    "물론",
    "물리학",
    "물음",
    "물질",
    "물체",
    "미국",
    "미디어",
    "미사일",
    "미술",
    "미역",
    "미용실",
    "미움",
    "미인",
    "미팅",
    "미혼",
    "민간",
    "민족",
    "민주",
    "믿음",
    "밀가루",
    "밀리미터",
    "밑바닥",
    "바가지",
    "바구니",
    "바나나",
    "바늘",
    "바닥",
    "바닷가",
    "바람",
    "바이러스",
    "바탕",
    "박물관",
    "박사",
    "박수",
    "반대",
    "반드시",
    "반말",
    "반발",
    "반성",
    "반응",
    "반장",
    "반죽",
    "반지",
    "반찬",
    "받침",
    "발가락",
    "발걸음",
    "발견",
    "발달",
    "발레",
    "발목",
    "발바닥",
    "발생",
    "발음",
    "발자국",
    "발전",
    "발톱",
    "발표",
    "밤하늘",
    "밥그릇",
    "밥맛",
    "밥상",
    "밥솥",
    "방금",
    "방면",
    "방문",
    "방바닥",
    "방법",
    "방송",
    "방식",
    "방안",
    "방울",
    "방지",
    "방학",
    "방해",
    "방향",
    "배경",
    "배꼽",
    "배달",
    "배드민턴",
    "백두산",
    "백색",
    "백성",
    "백인",
    "백제",
    "백화점",
    "버릇",
    "버섯",
    "버튼",
    "번개",
    "번역",
    "번지",
    "번호",
    "벌금",
    "벌레",
    "벌써",
    "범위",
    "범인",
    "범죄",
    "법률",
    "법원",
    "법적",
    "법칙",
    "베이징",
    "벨트",
    "변경",
    "변동",
    "변명",
    "변신",
    "변호사",
    "변화",
    "별도",
    "별명",
    "별일",
    "병실",
    "병아리",
    "병원",
    "보관",
    "보너스",
    "보라색",
    "보람",
    "보름",
    "보상",
    "보안",
    "보자기",
    "보장",
    "보전",
    "보존",
    "보통",
    "보편적",
    "보험",
    "복도",
    "복사",
    "복숭아",
    "복습",
    "볶음",
    "본격적",
    "본래",
    "본부",
    "본사",
    "본성",
    "본인",
    "본질",
    "볼펜",
    "봉사",
    "봉지",
    "봉투",
    "부근",
    "부끄러움",
    "부담",
    "부동산",
    "부문",
    "부분",
    "부산",
    "부상",
    "부엌",
    "부인",
    "부작용",
    "부장",
    "부정",
    "부족",
    "부지런히",
    "부친",
    "부탁",
    "부품",
    "부회장",
    "북부",
    "북한",
    "분노",
    "분량",
    "분리",
    "분명",
    "분석",
    "분야",
    "분위기",
    "분필",
    "분홍색",
    "불고기",
    "불과",
    "불교",
    "불꽃",
    "불만",
    "불법",
    "불빛",
    "불안",
    "불이익",
    "불행",
    "브랜드",
    "비극",
    "비난",
    "비닐",
    "비둘기",
    "비디오",
    "비로소",
    "비만",
    "비명",
    "비밀",
    "비바람",
    "비빔밥",
    "비상",
    "비용",
    "비율",
    "비중",
    "비타민",
    "비판",
    "빌딩",
    "빗물",
    "빗방울",
    "빗줄기",
    "빛깔",
    "빨간색",
    "빨래",
    "빨리",
    "사건",
    "사계절",
    "사나이",
    "사냥",
    "사람",
    "사랑",
    "사립",
    "사모님",
    "사물",
    "사방",
    "사상",
    "사생활",
    "사설",
    "사슴",
    "사실",
    "사업",
    "사용",
    "사월",
    "사장",
    "사전",
    "사진",
    "사촌",
    "사춘기",
    "사탕",
    "사투리",
    "사흘",
    "산길",
    "산부인과",
    "산업",
    "산책",
    "살림",
    "살인",
    "살짝",
    "삼계탕",
    "삼국",
    "삼십",
    "삼월",
    "삼촌",
    "상관",
    "상금",
    "상대",
    "상류",
    "상반기",
    "상상",
    "상식",
    "상업",
    "상인",
    "상자",
    "상점",
    "상처",
    "상추",
    "상태",
    "상표",
    "상품",
    "상황",
    "새벽",
    "색깔",
    "색연필",
    "생각",
    "생명",
    "생물",
    "생방송",
    "생산",
    "생선",
    "생신",
    "생일",
    "생활",
    "서랍",
    "서른",
    "서명",
    "서민",
    "서비스",
    "서양",
    "서울",
    "서적",
    "서점",
    "서쪽",
    "서클",
    "석사",
    "석유",
    "선거",
    "선물",
    "선배",
    "선생",
    "선수",
    "선원",
    "선장",
    "선전",
    "선택",
    "선풍기",
    "설거지",
    "설날",
    "설렁탕",
    "설명",
    "설문",
    "설사",
    "설악산",
    "설치",
    "설탕",
    "섭씨",
    "성공",
    "성당",
    "성명",
    "성별",
    "성인",
    "성장",
    "성적",
    "성질",
    "성함",
    "세금",
    "세미나",
    "세상",
    "세월",
    "세종대왕",
    "세탁",
    "센터",
    "센티미터",
    "셋째",
    "소규모",
    "소극적",
    "소금",
    "소나기",
    "소년",
    "소득",
    "소망",
    "소문",
    "소설",
    "소속",
    "소아과",
    "소용",
    "소원",
    "소음",
    "소중히",
    "소지품",
    "소질",
    "소풍",
    "소형",
    "속담",
    "속도",
    "속옷",
    "손가락",
    "손길",
    "손녀",
    "손님",
    "손등",
    "손목",
    "손뼉",
    "손실",
    "손질",
    "손톱",
    "손해",
    "솔직히",
    "솜씨",
    "송아지",
    "송이",
    "송편",
    "쇠고기",
    "쇼핑",
    "수건",
    "수년",
    "수단",
    "수돗물",
    "수동적",
    "수면",
    "수명",
    "수박",
    "수상",
    "수석",
    "수술",
    "수시로",
    "수업",
    "수염",
    "수영",
    "수입",
    "수준",
    "수집",
    "수출",
    "수컷",
    "수필",
    "수학",
    "수험생",
    "수화기",
    "숙녀",
    "숙소",
    "숙제",
    "순간",
    "순서",
    "순수",
    "순식간",
    "순위",
    "숟가락",
    "술병",
    "술집",
    "숫자",
    "스님",
    "스물",
    "스스로",
    "스승",
    "스웨터",
    "스위치",
    "스케이트",
    "스튜디오",
    "스트레스",
    "스포츠",
    "슬쩍",
    "슬픔",
    "습관",
    "습기",
    "승객",
    "승리",
    "승부",
    "승용차",
    "승진",
    "시각",
    "시간",
    "시골",
    "시금치",
    "시나리오",
    "시댁",
    "시리즈",
    "시멘트",
    "시민",
    "시부모",
    "시선",
    "시설",
    "시스템",
    "시아버지",
    "시어머니",
    "시월",
    "시인",
    "시일",
    "시작",
    "시장",
    "시절",
    "시점",
    "시중",
    "시즌",
    "시집",
    "시청",
    "시합",
    "시험",
    "식구",
    "식기",
    "식당",
    "식량",
    "식료품",
    "식물",
    "식빵",
    "식사",
    "식생활",
    "식초",
    "식탁",
    "식품",
    "신고",
    "신규",
    "신념",
    "신문",
    "신발",
    "신비",
    "신사",
    "신세",
    "신용",
    "신제품",
    "신청",
    "신체",
    "신화",
    "실감",
    "실내",
    "실력",
    "실례",
    "실망",
    "실수",
    "실습",
    "실시",
    "실장",
    "실정",
    "실질적",
    "실천",
    "실체",
    "실컷",
    "실태",
    "실패",
    "실험",
    "실현",
    "심리",
    "심부름",
    "심사",
    "심장",
    "심정",
    "심판",
    "쌍둥이",
    "씨름",
    "씨앗",
    "아가씨",
    "아나운서",
    "아드님",
    "아들",
    "아쉬움",
    "아스팔트",
    "아시아",
    "아울러",
    "아저씨",
    "아줌마",
    "아직",
    "아침",
    "아파트",
    "아프리카",
    "아픔",
    "아홉",
    "아흔",
    "악기",
    "악몽",
    "악수",
    "안개",
    "안경",
    "안과",
    "안내",
    "안녕",
    "안동",
    "안방",
    "안부",
    "안주",
    "알루미늄",
    "알코올",
    "암시",
    "암컷",
    "압력",
    "앞날",
    "앞문",
    "애인",
    "애정",
    "액수",
    "앨범",
    "야간",
    "야단",
    "야옹",
    "약간",
    "약국",
    "약속",
    "약수",
    "약점",
    "약품",
    "약혼녀",
    "양념",
    "양력",
    "양말",
    "양배추",
    "양주",
    "양파",
    "어둠",
    "어려움",
    "어른",
    "어젯밤",
    "어쨌든",
    "어쩌다가",
    "어쩐지",
    "언니",
    "언덕",
    "언론",
    "언어",
    "얼굴",
    "얼른",
    "얼음",
    "얼핏",
    "엄마",
    "업무",
    "업종",
    "업체",
    "엉덩이",
    "엉망",
    "엉터리",
    "엊그제",
    "에너지",
    "에어컨",
    "엔진",
    "여건",
    "여고생",
    "여관",
    "여군",
    "여권",
    "여대생",
    "여덟",
    "여동생",
    "여든",
    "여론",
    "여름",
    "여섯",
    "여성",
    "여왕",
    "여인",
    "여전히",
    "여직원",
    "여학생",
    "여행",
    "역사",
    "역시",
    "역할",
    "연결",
    "연구",
    "연극",
    "연기",
    "연락",
    "연설",
    "연세",
    "연속",
    "연습",
    "연애",
    "연예인",
    "연인",
    "연장",
    "연주",
    "연출",
    "연필",
    "연합",
    "연휴",
    "열기",
    "열매",
    "열쇠",
    "열심히",
    "열정",
    "열차",
    "열흘",
    "염려",
    "엽서",
    "영국",
    "영남",
    "영상",
    "영양",
    "영역",
    "영웅",
    "영원히",
    "영하",
    "영향",
    "영혼",
    "영화",
    "옆구리",
    "옆방",
    "옆집",
    "예감",
    "예금",
    "예방",
    "예산",
    "예상",
    "예선",
    "예술",
    "예습",
    "예식장",
    "예약",
    "예전",
    "예절",
    "예정",
    "예컨대",
    "옛날",
    "오늘",
    "오락",
    "오랫동안",
    "오렌지",
    "오로지",
    "오른발",
    "오븐",
    "오십",
    "오염",
    "오월",
    "오전",
    "오직",
    "오징어",
    "오페라",
    "오피스텔",
    "오히려",
    "옥상",
    "옥수수",
    "온갖",
    "온라인",
    "온몸",
    "온종일",
    "온통",
    "올가을",
    "올림픽",
    "올해",
    "옷차림",
    "와이셔츠",
    "와인",
    "완성",
    "완전",
    "왕비",
    "왕자",
    "왜냐하면",
    "왠지",
    "외갓집",
    "외국",
    "외로움",
    "외삼촌",
    "외출",
    "외침",
    "외할머니",
    "왼발",
    "왼손",
    "왼쪽",
    "요금",
    "요일",
    "요즘",
    "요청",
    "용기",
    "용서",
    "용어",
    "우산",
    "우선",
    "우승",
    "우연히",
    "우정",
    "우체국",
    "우편",
    "운동",
    "운명",
    "운반",
    "운전",
    "운행",
    "울산",
    "울음",
    "움직임",
    "웃어른",
    "웃음",
    "워낙",
    "원고",
    "원래",
    "원서",
    "원숭이",
    "원인",
    "원장",
    "원피스",
    "월급",
    "월드컵",
    "월세",
    "월요일",
    "웨이터",
    "위반",
    "위법",
    "위성",
    "위원",
    "위험",
    "위협",
    "윗사람",
    "유난히",
    "유럽",
    "유명",
    "유물",
    "유산",
    "유적",
    "유치원",
    "유학",
    "유행",
    "유형",
    "육군",
    "육상",
    "육십",
    "육체",
    "은행",
    "음력",
    "음료",
    "음반",
    "음성",
    "음식",
    "음악",
    "음주",
    "의견",
    "의논",
    "의문",
    "의복",
    "의식",
    "의심",
    "의외로",
    "의욕",
    "의원",
    "의학",
    "이것",
    "이곳",
    "이념",
    "이놈",
    "이달",
    "이대로",
    "이동",
    "이렇게",
    "이력서",
    "이론적",
    "이름",
    "이민",
    "이발소",
    "이별",
    "이불",
    "이빨",
    "이상",
    "이성",
    "이슬",
    "이야기",
    "이용",
    "이웃",
    "이월",
    "이윽고",
    "이익",
    "이전",
    "이중",
    "이튿날",
    "이틀",
    "이혼",
    "인간",
    "인격",
    "인공",
    "인구",
    "인근",
    "인기",
    "인도",
    "인류",
    "인물",
    "인생",
    "인쇄",
    "인연",
    "인원",
    "인재",
    "인종",
    "인천",
    "인체",
    "인터넷",
    "인하",
    "인형",
    "일곱",
    "일기",
    "일단",
    "일대",
    "일등",
    "일반",
    "일본",
    "일부",
    "일상",
    "일생",
    "일손",
    "일요일",
    "일월",
    "일정",
    "일종",
    "일주일",
    "일찍",
    "일체",
    "일치",
    "일행",
    "일회용",
    "임금",
    "임무",
    "입대",
    "입력",
    "입맛",
    "입사",
    "입술",
    "입시",
    "입원",
    "입장",
    "입학",
    "자가용",
    "자격",
    "자극",
    "자동",
    "자랑",
    "자부심",
    "자식",
    "자신",
    "자연",
    "자원",
    "자율",
    "자전거",
    "자정",
    "자존심",
    "자판",
    "작가",
    "작년",
    "작성",
    "작업",
    "작용",
    "작은딸",
    "작품",
    "잔디",
    "잔뜩",
    "잔치",
    "잘못",
    "잠깐",
    "잠수함",
    "잠시",
    "잠옷",
    "잠자리",
    "잡지",
    "장관",
    "장군",
    "장기간",
    "장래",
    "장례",
    "장르",
    "장마",
    "장면",
    "장모",
    "장미",
    "장비",
    "장사",
    "장소",
    "장식",
    "장애인",
    "장인",
    "장점",
    "장차",
    "장학금",
    "재능",
    "재빨리",
    "재산",
    "재생",
    "재작년",
    "재정",
    "재채기",
    "재판",
    "재학",
    "재활용",
    "저것",
    "저고리",
    "저곳",
    "저녁",
    "저런",
    "저렇게",
    "저번",
    "저울",
    "저절로",
    "저축",
    "적극",
    "적당히",
    "적성",
    "적용",
    "적응",
    "전개",
    "전공",
    "전기",
    "전달",
    "전라도",
    "전망",
    "전문",
    "전반",
    "전부",
    "전세",
    "전시",
    "전용",
    "전자",
    "전쟁",
    "전주",
    "전철",
    "전체",
    "전통",
    "전혀",
    "전후",
    "절대",
    "절망",
    "절반",
    "절약",
    "절차",
    "점검",
    "점수",
    "점심",
    "점원",
    "점점",
    "점차",
    "접근",
    "접시",
    "접촉",
    "젓가락",
    "정거장",
    "정도",
    "정류장",
    "정리",
    "정말",
    "정면",
    "정문",
    "정반대",
    "정보",
    "정부",
    "정비",
    "정상",
    "정성",
    "정오",
    "정원",
    "정장",
    "정지",
    "정치",
    "정확히",
    "제공",
    "제과점",
    "제대로",
    "제목",
    "제발",
    "제법",
    "제삿날",
    "제안",
    "제일",
    "제작",
    "제주도",
    "제출",
    "제품",
    "제한",
    "조각",
    "조건",
    "조금",
    "조깅",
    "조명",
    "조미료",
    "조상",
    "조선",
    "조용히",
    "조절",
    "조정",
    "조직",
    "존댓말",
    "존재",
    "졸업",
    "졸음",
    "종교",
    "종로",
    "종류",
    "종소리",
    "종업원",
    "종종",
    "종합",
    "좌석",
    "죄인",
    "주관적",
    "주름",
    "주말",
    "주머니",
    "주먹",
    "주문",
    "주민",
    "주방",
    "주변",
    "주식",
    "주인",
    "주일",
    "주장",
    "주전자",
    "주택",
    "준비",
    "줄거리",
    "줄기",
    "줄무늬",
    "중간",
    "중계방송",
    "중국",
    "중년",
    "중단",
    "중독",
    "중반",
    "중부",
    "중세",
    "중소기업",
    "중순",
    "중앙",
    "중요",
    "중학교",
    "즉석",
    "즉시",
    "즐거움",
    "증가",
    "증거",
    "증권",
    "증상",
    "증세",
    "지각",
    "지갑",
    "지경",
    "지극히",
    "지금",
    "지급",
    "지능",
    "지름길",
    "지리산",
    "지방",
    "지붕",
    "지식",
    "지역",
    "지우개",
    "지원",
    "지적",
    "지점",
    "지진",
    "지출",
    "직선",
    "직업",
    "직원",
    "직장",
    "진급",
    "진동",
    "진로",
    "진료",
    "진리",
    "진짜",
    "진찰",
    "진출",
    "진통",
    "진행",
    "질문",
    "질병",
    "질서",
    "짐작",
    "집단",
    "집안",
    "집중",
    "짜증",
    "찌꺼기",
    "차남",
    "차라리",
    "차량",
    "차림",
    "차별",
    "차선",
    "차츰",
    "착각",
    "찬물",
    "찬성",
    "참가",
    "참기름",
    "참새",
    "참석",
    "참여",
    "참외",
    "참조",
    "찻잔",
    "창가",
    "창고",
    "창구",
    "창문",
    "창밖",
    "창작",
    "창조",
    "채널",
    "채점",
    "책가방",
    "책방",
    "책상",
    "책임",
    "챔피언",
    "처벌",
    "처음",
    "천국",
    "천둥",
    "천장",
    "천재",
    "천천히",
    "철도",
    "철저히",
    "철학",
    "첫날",
    "첫째",
    "청년",
    "청바지",
    "청소",
    "청춘",
    "체계",
    "체력",
    "체온",
    "체육",
    "체중",
    "체험",
    "초등학생",
    "초반",
    "초밥",
    "초상화",
    "초순",
    "초여름",
    "초원",
    "초저녁",
    "초점",
    "초청",
    "초콜릿",
    "촛불",
    "총각",
    "총리",
    "총장",
    "촬영",
    "최근",
    "최상",
    "최선",
    "최신",
    "최악",
    "최종",
    "추석",
    "추억",
    "추진",
    "추천",
    "추측",
    "축구",
    "축소",
    "축제",
    "축하",
    "출근",
    "출발",
    "출산",
    "출신",
    "출연",
    "출입",
    "출장",
    "출판",
    "충격",
    "충고",
    "충돌",
    "충분히",
    "충청도",
    "취업",
    "취직",
    "취향",
    "치약",
    "친구",
    "친척",
    "칠십",
    "칠월",
    "칠판",
    "침대",
    "침묵",
    "침실",
    "칫솔",
    "칭찬",
    "카메라",
    "카운터",
    "칼국수",
    "캐릭터",
    "캠퍼스",
    "캠페인",
    "커튼",
    "컨디션",
    "컬러",
    "컴퓨터",
    "코끼리",
    "코미디",
    "콘서트",
    "콜라",
    "콤플렉스",
    "콩나물",
    "쾌감",
    "쿠데타",
    "크림",
    "큰길",
    "큰딸",
    "큰소리",
    "큰아들",
    "큰어머니",
    "큰일",
    "큰절",
    "클래식",
    "클럽",
    "킬로",
    "타입",
    "타자기",
    "탁구",
    "탁자",
    "탄생",
    "태권도",
    "태양",
    "태풍",
    "택시",
    "탤런트",
    "터널",
    "터미널",
    "테니스",
    "테스트",
    "테이블",
    "텔레비전",
    "토론",
    "토마토",
    "토요일",
    "통계",
    "통과",
    "통로",
    "통신",
    "통역",
    "통일",
    "통장",
    "통제",
    "통증",
    "통합",
    "통화",
    "퇴근",
    "퇴원",
    "퇴직금",
    "튀김",
    "트럭",
    "특급",
    "특별",
    "특성",
    "특수",
    "특징",
    "특히",
    "튼튼히",
    "티셔츠",
    "파란색",
    "파일",
    "파출소",
    "판결",
    "판단",
    "판매",
    "판사",
    "팔십",
    "팔월",
    "팝송",
    "패션",
    "팩스",
    "팩시밀리",
    "팬티",
    "퍼센트",
    "페인트",
    "편견",
    "편의",
    "편지",
    "편히",
    "평가",
    "평균",
    "평생",
    "평소",
    "평양",
    "평일",
    "평화",
    "포스터",
    "포인트",
    "포장",
    "포함",
    "표면",
    "표정",
    "표준",
    "표현",
    "품목",
    "품질",
    "풍경",
    "풍속",
    "풍습",
    "프랑스",
    "프린터",
    "플라스틱",
    "피곤",
    "피망",
    "피아노",
    "필름",
    "필수",
    "필요",
    "필자",
    "필통",
    "핑계",
    "하느님",
    "하늘",
    "하드웨어",
    "하룻밤",
    "하반기",
    "하숙집",
    "하순",
    "하여튼",
    "하지만",
    "하천",
    "하품",
    "하필",
    "학과",
    "학교",
    "학급",
    "학기",
    "학년",
    "학력",
    "학번",
    "학부모",
    "학비",
    "학생",
    "학술",
    "학습",
    "학용품",
    "학원",
    "학위",
    "학자",
    "학점",
    "한계",
    "한글",
    "한꺼번에",
    "한낮",
    "한눈",
    "한동안",
    "한때",
    "한라산",
    "한마디",
    "한문",
    "한번",
    "한복",
    "한식",
    "한여름",
    "한쪽",
    "할머니",
    "할아버지",
    "할인",
    "함께",
    "함부로",
    "합격",
    "합리적",
    "항공",
    "항구",
    "항상",
    "항의",
    "해결",
    "해군",
    "해답",
    "해당",
    "해물",
    "해석",
    "해설",
    "해수욕장",
    "해안",
    "핵심",
    "핸드백",
    "햄버거",
    "햇볕",
    "햇살",
    "행동",
    "행복",
    "행사",
    "행운",
    "행위",
    "향기",
    "향상",
    "향수",
    "허락",
    "허용",
    "헬기",
    "현관",
    "현금",
    "현대",
    "현상",
    "현실",
    "현장",
    "현재",
    "현지",
    "혈액",
    "협력",
    "형부",
    "형사",
    "형수",
    "형식",
    "형제",
    "형태",
    "형편",
    "혜택",
    "호기심",
    "호남",
    "호랑이",
    "호박",
    "호텔",
    "호흡",
    "혹시",
    "홀로",
    "홈페이지",
    "홍보",
    "홍수",
    "홍차",
    "화면",
    "화분",
    "화살",
    "화요일",
    "화장",
    "화학",
    "확보",
    "확인",
    "확장",
    "확정",
    "환갑",
    "환경",
    "환영",
    "환율",
    "환자",
    "활기",
    "활동",
    "활발히",
    "활용",
    "활짝",
    "회견",
    "회관",
    "회복",
    "회색",
    "회원",
    "회장",
    "회전",
    "횟수",
    "횡단보도",
    "효율적",
    "후반",
    "후춧가루",
    "훈련",
    "훨씬",
    "휴식",
    "휴일",
    "흉내",
    "흐름",
    "흑백",
    "흑인",
    "흔적",
    "흔히",
    "흥미",
    "흥분",
    "희곡",
    "희망",
    "희생",
    "흰색",
    "힘껏"
], tre = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "académie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquérir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adéquat",
    "adhésif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aérer",
    "aéronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agréable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algèbre",
    "algue",
    "aliéner",
    "aliment",
    "alléger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alvéole",
    "amateur",
    "ambigu",
    "ambre",
    "aménager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "anéantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "apéritif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "artériel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "bannière",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "bélier",
    "belote",
    "bénéfice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "bétail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "brèche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "caféine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "caméra",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cédille",
    "ceinture",
    "céleste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cérébral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chéquier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimère",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinéma",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohésion",
    "coiffer",
    "coincer",
    "colère",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comédie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortège",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "créature",
    "créditer",
    "crémeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critère",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillère",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "débattre",
    "débiter",
    "déborder",
    "débrider",
    "débutant",
    "décaler",
    "décembre",
    "déchirer",
    "décider",
    "déclarer",
    "décorer",
    "décrire",
    "décupler",
    "dédale",
    "déductif",
    "déesse",
    "défensif",
    "défiler",
    "défrayer",
    "dégager",
    "dégivrer",
    "déglutir",
    "dégrafer",
    "déjeuner",
    "délice",
    "déloger",
    "demander",
    "demeurer",
    "démolir",
    "dénicher",
    "dénouer",
    "dentelle",
    "dénuder",
    "départ",
    "dépenser",
    "déphaser",
    "déplacer",
    "déposer",
    "déranger",
    "dérober",
    "désastre",
    "descente",
    "désert",
    "désigner",
    "désobéir",
    "dessiner",
    "destrier",
    "détacher",
    "détester",
    "détourer",
    "détresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "différer",
    "digérer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "éblouir",
    "écarter",
    "écharpe",
    "échelle",
    "éclairer",
    "éclipse",
    "éclore",
    "écluse",
    "école",
    "économie",
    "écorce",
    "écouter",
    "écraser",
    "écrémer",
    "écrivain",
    "écrou",
    "écume",
    "écureuil",
    "édifier",
    "éduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "égaliser",
    "égarer",
    "éjecter",
    "élaborer",
    "élargir",
    "électron",
    "élégant",
    "éléphant",
    "élève",
    "éligible",
    "élitisme",
    "éloge",
    "élucider",
    "éluder",
    "emballer",
    "embellir",
    "embryon",
    "émeraude",
    "émission",
    "emmener",
    "émotion",
    "émouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "émulsion",
    "encadrer",
    "enchère",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "énergie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "énigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "énumérer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "éolien",
    "épaissir",
    "épargne",
    "épatant",
    "épaule",
    "épicerie",
    "épidémie",
    "épier",
    "épilogue",
    "épine",
    "épisode",
    "épitaphe",
    "époque",
    "épreuve",
    "éprouver",
    "épuisant",
    "équerre",
    "équipe",
    "ériger",
    "érosion",
    "erreur",
    "éruption",
    "escalier",
    "espadon",
    "espèce",
    "espiègle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "étagère",
    "étaler",
    "étanche",
    "étatique",
    "éteindre",
    "étendoir",
    "éternel",
    "éthanol",
    "éthique",
    "ethnie",
    "étirer",
    "étoffer",
    "étoile",
    "étonnant",
    "étourdir",
    "étrange",
    "étroit",
    "étude",
    "euphorie",
    "évaluer",
    "évasion",
    "éventail",
    "évidence",
    "éviter",
    "évolutif",
    "évoquer",
    "exact",
    "exagérer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "exécuter",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expédier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "fébrile",
    "féconder",
    "fédérer",
    "félin",
    "femme",
    "fémur",
    "fendoir",
    "féodal",
    "fermer",
    "féroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "février",
    "fiasco",
    "ficeler",
    "fictif",
    "fidèle",
    "figure",
    "filature",
    "filetage",
    "filière",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fléau",
    "flèche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougère",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "frégate",
    "freiner",
    "frelon",
    "frémir",
    "frénésie",
    "frère",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "géant",
    "gélatine",
    "gélule",
    "gendarme",
    "général",
    "génie",
    "genou",
    "gentil",
    "géologie",
    "géomètre",
    "géranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyère",
    "guépard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "hélium",
    "hématome",
    "herbe",
    "hérisson",
    "hermine",
    "héron",
    "hésiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogène",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiène",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "impérial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inédit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingérer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irréel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvénile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacérer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "légal",
    "léger",
    "légume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lézard",
    "liasse",
    "libérer",
    "libre",
    "licence",
    "licorne",
    "liège",
    "lièvre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "linéaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisière",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumière",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "maléfice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "matériel",
    "matière",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "méchant",
    "méconnu",
    "médaille",
    "médecin",
    "méditer",
    "méduse",
    "meilleur",
    "mélange",
    "mélodie",
    "membre",
    "mémoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "mérite",
    "merle",
    "messager",
    "mesure",
    "métal",
    "météore",
    "méthode",
    "métier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "minéral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murène",
    "murmure",
    "muscle",
    "muséum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystère",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nébuleux",
    "nectar",
    "néfaste",
    "négation",
    "négliger",
    "négocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numéro",
    "nuptial",
    "nuque",
    "nutritif",
    "obéir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "océan",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onéreux",
    "onirique",
    "opale",
    "opaque",
    "opérer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygène",
    "ozone",
    "paisible",
    "palace",
    "palmarès",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pastèque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pélican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "pénétrer",
    "pénible",
    "pensif",
    "pénurie",
    "pépite",
    "péplum",
    "perdrix",
    "perforer",
    "période",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "pétale",
    "petit",
    "pétrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "pièce",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poésie",
    "poète",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "pondérer",
    "poney",
    "portique",
    "position",
    "posséder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "précieux",
    "prédire",
    "préfixe",
    "prélude",
    "prénom",
    "présence",
    "prétexte",
    "prévoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "problème",
    "procéder",
    "prodige",
    "profond",
    "progrès",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospère",
    "protéger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quiétude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "réactif",
    "réagir",
    "réaliser",
    "réanimer",
    "recevoir",
    "réciter",
    "réclamer",
    "récolter",
    "recruter",
    "reculer",
    "recycler",
    "rédiger",
    "redouter",
    "refaire",
    "réflexe",
    "réformer",
    "refrain",
    "refuge",
    "régalien",
    "région",
    "réglage",
    "régulier",
    "réitérer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remède",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "réserve",
    "résineux",
    "résoudre",
    "respect",
    "rester",
    "résultat",
    "rétablir",
    "retenir",
    "réticule",
    "retomber",
    "retracer",
    "réunion",
    "réussir",
    "revanche",
    "revivre",
    "révolte",
    "révulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "rivière",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scélérat",
    "scénario",
    "sceptre",
    "schéma",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "séance",
    "sécable",
    "sécher",
    "secouer",
    "sécréter",
    "sédatif",
    "séduire",
    "seigneur",
    "séjour",
    "sélectif",
    "semaine",
    "sembler",
    "semence",
    "séminal",
    "sénateur",
    "sensible",
    "sentence",
    "séparer",
    "séquence",
    "serein",
    "sergent",
    "sérieux",
    "serrure",
    "sérum",
    "service",
    "sésame",
    "sévir",
    "sevrage",
    "sextuple",
    "sidéral",
    "siècle",
    "siéger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincère",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "spécial",
    "sphère",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succès",
    "sucre",
    "suffixe",
    "suggérer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symétrie",
    "synapse",
    "syntaxe",
    "système",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "témoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tétine",
    "texte",
    "thème",
    "théorie",
    "thérapie",
    "thorax",
    "tibia",
    "tiède",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolérant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trèfle",
    "tremper",
    "trésor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "végétal",
    "véhicule",
    "veinard",
    "véloce",
    "vendredi",
    "vénérer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "vérin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "vétéran",
    "vétuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "vidéo",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipère",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xénon",
    "yacht",
    "zèbre",
    "zénith",
    "zeste",
    "zoologie"
], rre = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
], nre = [
    "ábaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "acción",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "ácido",
    "aclarar",
    "acné",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aéreo",
    "afectar",
    "afición",
    "afinar",
    "afirmar",
    "ágil",
    "agitar",
    "agonía",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "águila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacrán",
    "alambre",
    "alarma",
    "alba",
    "álbum",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodón",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almíbar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ámbar",
    "ámbito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "andén",
    "anemia",
    "ángulo",
    "anillo",
    "ánimo",
    "anís",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "añadir",
    "añejo",
    "año",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "araña",
    "arar",
    "árbitro",
    "árbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "área",
    "árido",
    "aries",
    "armonía",
    "arnés",
    "aroma",
    "arpa",
    "arpón",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "áspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "ático",
    "atleta",
    "átomo",
    "atraer",
    "atroz",
    "atún",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avión",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafrán",
    "azar",
    "azote",
    "azúcar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahía",
    "baile",
    "bajar",
    "balanza",
    "balcón",
    "balde",
    "bambú",
    "banco",
    "banda",
    "baño",
    "barba",
    "barco",
    "barniz",
    "barro",
    "báscula",
    "bastón",
    "basura",
    "batalla",
    "batería",
    "batir",
    "batuta",
    "baúl",
    "bazar",
    "bebé",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsái",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botín",
    "bóveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufón",
    "búho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzón",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadáver",
    "cadena",
    "caer",
    "café",
    "caída",
    "caimán",
    "caja",
    "cajón",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cáncer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "caña",
    "cañón",
    "caoba",
    "caos",
    "capaz",
    "capitán",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbón",
    "cárcel",
    "careta",
    "carga",
    "cariño",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "célebre",
    "celoso",
    "célula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "césped",
    "cetro",
    "chacal",
    "chaleco",
    "champú",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclón",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "ciprés",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clínica",
    "cobre",
    "cocción",
    "cochino",
    "cocina",
    "coco",
    "código",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojín",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "cómodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazón",
    "corbata",
    "corcho",
    "cordón",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "cráneo",
    "cráter",
    "crear",
    "crecer",
    "creído",
    "crema",
    "cría",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "crónica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupón",
    "cúpula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "dátil",
    "deber",
    "débil",
    "década",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfín",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvío",
    "detalle",
    "detener",
    "deuda",
    "día",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "difícil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseño",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragón",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueño",
    "dulce",
    "dúo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ébano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edición",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "élite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emoción",
    "empate",
    "empeño",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encía",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engaño",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "enseñar",
    "entero",
    "entrar",
    "envase",
    "envío",
    "época",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espía",
    "esposa",
    "espuma",
    "esquí",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "ética",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "éxito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fábrica",
    "fábula",
    "fachada",
    "fácil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraón",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fértil",
    "fervor",
    "festín",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficción",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "flúor",
    "fobia",
    "foca",
    "fogata",
    "fogón",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "frágil",
    "franja",
    "frase",
    "fraude",
    "freír",
    "freno",
    "fresa",
    "frío",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "función",
    "funda",
    "furgón",
    "furia",
    "fusil",
    "fútbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galería",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilán",
    "gemelo",
    "gemir",
    "gen",
    "género",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "gráfico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grúa",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guía",
    "guiño",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "hábil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazaña",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "héroe",
    "hervir",
    "hielo",
    "hierro",
    "hígado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "húmedo",
    "humilde",
    "humo",
    "hundir",
    "huracán",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "ídolo",
    "iglesia",
    "iglú",
    "igual",
    "ilegal",
    "ilusión",
    "imagen",
    "imán",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "índice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interés",
    "íntimo",
    "intuir",
    "inútil",
    "invierno",
    "ira",
    "iris",
    "ironía",
    "isla",
    "islote",
    "jabalí",
    "jabón",
    "jamón",
    "jarabe",
    "jardín",
    "jarra",
    "jaula",
    "jazmín",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "júpiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladrón",
    "lagarto",
    "lágrima",
    "laguna",
    "laico",
    "lamer",
    "lámina",
    "lámpara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lápiz",
    "largo",
    "larva",
    "lástima",
    "lata",
    "látex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "lección",
    "leche",
    "lector",
    "leer",
    "legión",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "leña",
    "león",
    "leopardo",
    "lesión",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "líder",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "límite",
    "limón",
    "limpio",
    "lince",
    "lindo",
    "línea",
    "lingote",
    "lino",
    "linterna",
    "líquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "loción",
    "loco",
    "locura",
    "lógica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maíz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mamá",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniquí",
    "manjar",
    "mano",
    "manso",
    "manta",
    "mañana",
    "mapa",
    "máquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "mármol",
    "marrón",
    "martes",
    "marzo",
    "masa",
    "máscara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "máximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "médula",
    "mejilla",
    "mejor",
    "melena",
    "melón",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menú",
    "mercado",
    "merengue",
    "mérito",
    "mes",
    "mesón",
    "meta",
    "meter",
    "método",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millón",
    "mimo",
    "mina",
    "minero",
    "mínimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "moción",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "moño",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "móvil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muñeca",
    "mural",
    "muro",
    "músculo",
    "museo",
    "musgo",
    "música",
    "muslo",
    "nácar",
    "nación",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "náusea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "néctar",
    "negar",
    "negocio",
    "negro",
    "neón",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "niñez",
    "niño",
    "nítido",
    "nivel",
    "nobleza",
    "noche",
    "nómina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "núcleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "número",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "océano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oído",
    "oír",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opción",
    "ópera",
    "opinar",
    "oponer",
    "optar",
    "óptica",
    "opuesto",
    "oración",
    "orador",
    "oral",
    "órbita",
    "orca",
    "orden",
    "oreja",
    "órgano",
    "orgía",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadía",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otoño",
    "otro",
    "oveja",
    "óvulo",
    "óxido",
    "oxígeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "página",
    "pago",
    "país",
    "pájaro",
    "palabra",
    "palco",
    "paleta",
    "pálido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "pánico",
    "pantera",
    "pañuelo",
    "papá",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "párpado",
    "parque",
    "párrafo",
    "parte",
    "pasar",
    "paseo",
    "pasión",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peatón",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldaño",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "peñón",
    "peón",
    "peor",
    "pepino",
    "pequeño",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pésimo",
    "pestaña",
    "pétalo",
    "petróleo",
    "pez",
    "pezuña",
    "picar",
    "pichón",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "piña",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "pitón",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesía",
    "poeta",
    "polen",
    "policía",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porción",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "príncipe",
    "prisión",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "próximo",
    "prueba",
    "público",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmón",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "puñal",
    "puño",
    "pupa",
    "pupila",
    "puré",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "química",
    "quince",
    "quitar",
    "rábano",
    "rabia",
    "rabo",
    "ración",
    "radical",
    "raíz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rápido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razón",
    "reacción",
    "realidad",
    "rebaño",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refrán",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehén",
    "reino",
    "reír",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "revés",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rígido",
    "rigor",
    "rincón",
    "riñón",
    "río",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubí",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sábado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmón",
    "salón",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sanción",
    "sandía",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sartén",
    "sastre",
    "satán",
    "sauna",
    "saxofón",
    "sección",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "señal",
    "señor",
    "separar",
    "sepia",
    "sequía",
    "ser",
    "serie",
    "sermón",
    "servir",
    "sesenta",
    "sesión",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "sílaba",
    "silbar",
    "silencio",
    "silla",
    "símbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "sólido",
    "soltar",
    "solución",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sostén",
    "sótano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueño",
    "suerte",
    "sufrir",
    "sujeto",
    "sultán",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureño",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabú",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talón",
    "tamaño",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapón",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazón",
    "teatro",
    "techo",
    "tecla",
    "técnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "teléfono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoría",
    "terapia",
    "terco",
    "término",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburón",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "tímido",
    "timo",
    "tinta",
    "tío",
    "típico",
    "tipo",
    "tira",
    "tirón",
    "titán",
    "títere",
    "título",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "tórax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "tóxico",
    "trabajo",
    "tractor",
    "traer",
    "tráfico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trébol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tubería",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "túnel",
    "túnica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "úlcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "uña",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "útil",
    "utopía",
    "uva",
    "vaca",
    "vacío",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "válido",
    "valle",
    "valor",
    "válvula",
    "vampiro",
    "vara",
    "variar",
    "varón",
    "vaso",
    "vecino",
    "vector",
    "vehículo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "vía",
    "viaje",
    "vibrar",
    "vicio",
    "víctima",
    "vida",
    "vídeo",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "viñedo",
    "violín",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "víspera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcán",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
], ire = [
    "あいこくしん",
    "あいさつ",
    "あいだ",
    "あおぞら",
    "あかちゃん",
    "あきる",
    "あけがた",
    "あける",
    "あこがれる",
    "あさい",
    "あさひ",
    "あしあと",
    "あじわう",
    "あずかる",
    "あずき",
    "あそぶ",
    "あたえる",
    "あたためる",
    "あたりまえ",
    "あたる",
    "あつい",
    "あつかう",
    "あっしゅく",
    "あつまり",
    "あつめる",
    "あてな",
    "あてはまる",
    "あひる",
    "あぶら",
    "あぶる",
    "あふれる",
    "あまい",
    "あまど",
    "あまやかす",
    "あまり",
    "あみもの",
    "あめりか",
    "あやまる",
    "あゆむ",
    "あらいぐま",
    "あらし",
    "あらすじ",
    "あらためる",
    "あらゆる",
    "あらわす",
    "ありがとう",
    "あわせる",
    "あわてる",
    "あんい",
    "あんがい",
    "あんこ",
    "あんぜん",
    "あんてい",
    "あんない",
    "あんまり",
    "いいだす",
    "いおん",
    "いがい",
    "いがく",
    "いきおい",
    "いきなり",
    "いきもの",
    "いきる",
    "いくじ",
    "いくぶん",
    "いけばな",
    "いけん",
    "いこう",
    "いこく",
    "いこつ",
    "いさましい",
    "いさん",
    "いしき",
    "いじゅう",
    "いじょう",
    "いじわる",
    "いずみ",
    "いずれ",
    "いせい",
    "いせえび",
    "いせかい",
    "いせき",
    "いぜん",
    "いそうろう",
    "いそがしい",
    "いだい",
    "いだく",
    "いたずら",
    "いたみ",
    "いたりあ",
    "いちおう",
    "いちじ",
    "いちど",
    "いちば",
    "いちぶ",
    "いちりゅう",
    "いつか",
    "いっしゅん",
    "いっせい",
    "いっそう",
    "いったん",
    "いっち",
    "いってい",
    "いっぽう",
    "いてざ",
    "いてん",
    "いどう",
    "いとこ",
    "いない",
    "いなか",
    "いねむり",
    "いのち",
    "いのる",
    "いはつ",
    "いばる",
    "いはん",
    "いびき",
    "いひん",
    "いふく",
    "いへん",
    "いほう",
    "いみん",
    "いもうと",
    "いもたれ",
    "いもり",
    "いやがる",
    "いやす",
    "いよかん",
    "いよく",
    "いらい",
    "いらすと",
    "いりぐち",
    "いりょう",
    "いれい",
    "いれもの",
    "いれる",
    "いろえんぴつ",
    "いわい",
    "いわう",
    "いわかん",
    "いわば",
    "いわゆる",
    "いんげんまめ",
    "いんさつ",
    "いんしょう",
    "いんよう",
    "うえき",
    "うえる",
    "うおざ",
    "うがい",
    "うかぶ",
    "うかべる",
    "うきわ",
    "うくらいな",
    "うくれれ",
    "うけたまわる",
    "うけつけ",
    "うけとる",
    "うけもつ",
    "うける",
    "うごかす",
    "うごく",
    "うこん",
    "うさぎ",
    "うしなう",
    "うしろがみ",
    "うすい",
    "うすぎ",
    "うすぐらい",
    "うすめる",
    "うせつ",
    "うちあわせ",
    "うちがわ",
    "うちき",
    "うちゅう",
    "うっかり",
    "うつくしい",
    "うったえる",
    "うつる",
    "うどん",
    "うなぎ",
    "うなじ",
    "うなずく",
    "うなる",
    "うねる",
    "うのう",
    "うぶげ",
    "うぶごえ",
    "うまれる",
    "うめる",
    "うもう",
    "うやまう",
    "うよく",
    "うらがえす",
    "うらぐち",
    "うらない",
    "うりあげ",
    "うりきれ",
    "うるさい",
    "うれしい",
    "うれゆき",
    "うれる",
    "うろこ",
    "うわき",
    "うわさ",
    "うんこう",
    "うんちん",
    "うんてん",
    "うんどう",
    "えいえん",
    "えいが",
    "えいきょう",
    "えいご",
    "えいせい",
    "えいぶん",
    "えいよう",
    "えいわ",
    "えおり",
    "えがお",
    "えがく",
    "えきたい",
    "えくせる",
    "えしゃく",
    "えすて",
    "えつらん",
    "えのぐ",
    "えほうまき",
    "えほん",
    "えまき",
    "えもじ",
    "えもの",
    "えらい",
    "えらぶ",
    "えりあ",
    "えんえん",
    "えんかい",
    "えんぎ",
    "えんげき",
    "えんしゅう",
    "えんぜつ",
    "えんそく",
    "えんちょう",
    "えんとつ",
    "おいかける",
    "おいこす",
    "おいしい",
    "おいつく",
    "おうえん",
    "おうさま",
    "おうじ",
    "おうせつ",
    "おうたい",
    "おうふく",
    "おうべい",
    "おうよう",
    "おえる",
    "おおい",
    "おおう",
    "おおどおり",
    "おおや",
    "おおよそ",
    "おかえり",
    "おかず",
    "おがむ",
    "おかわり",
    "おぎなう",
    "おきる",
    "おくさま",
    "おくじょう",
    "おくりがな",
    "おくる",
    "おくれる",
    "おこす",
    "おこなう",
    "おこる",
    "おさえる",
    "おさない",
    "おさめる",
    "おしいれ",
    "おしえる",
    "おじぎ",
    "おじさん",
    "おしゃれ",
    "おそらく",
    "おそわる",
    "おたがい",
    "おたく",
    "おだやか",
    "おちつく",
    "おっと",
    "おつり",
    "おでかけ",
    "おとしもの",
    "おとなしい",
    "おどり",
    "おどろかす",
    "おばさん",
    "おまいり",
    "おめでとう",
    "おもいで",
    "おもう",
    "おもたい",
    "おもちゃ",
    "おやつ",
    "おやゆび",
    "およぼす",
    "おらんだ",
    "おろす",
    "おんがく",
    "おんけい",
    "おんしゃ",
    "おんせん",
    "おんだん",
    "おんちゅう",
    "おんどけい",
    "かあつ",
    "かいが",
    "がいき",
    "がいけん",
    "がいこう",
    "かいさつ",
    "かいしゃ",
    "かいすいよく",
    "かいぜん",
    "かいぞうど",
    "かいつう",
    "かいてん",
    "かいとう",
    "かいふく",
    "がいへき",
    "かいほう",
    "かいよう",
    "がいらい",
    "かいわ",
    "かえる",
    "かおり",
    "かかえる",
    "かがく",
    "かがし",
    "かがみ",
    "かくご",
    "かくとく",
    "かざる",
    "がぞう",
    "かたい",
    "かたち",
    "がちょう",
    "がっきゅう",
    "がっこう",
    "がっさん",
    "がっしょう",
    "かなざわし",
    "かのう",
    "がはく",
    "かぶか",
    "かほう",
    "かほご",
    "かまう",
    "かまぼこ",
    "かめれおん",
    "かゆい",
    "かようび",
    "からい",
    "かるい",
    "かろう",
    "かわく",
    "かわら",
    "がんか",
    "かんけい",
    "かんこう",
    "かんしゃ",
    "かんそう",
    "かんたん",
    "かんち",
    "がんばる",
    "きあい",
    "きあつ",
    "きいろ",
    "ぎいん",
    "きうい",
    "きうん",
    "きえる",
    "きおう",
    "きおく",
    "きおち",
    "きおん",
    "きかい",
    "きかく",
    "きかんしゃ",
    "ききて",
    "きくばり",
    "きくらげ",
    "きけんせい",
    "きこう",
    "きこえる",
    "きこく",
    "きさい",
    "きさく",
    "きさま",
    "きさらぎ",
    "ぎじかがく",
    "ぎしき",
    "ぎじたいけん",
    "ぎじにってい",
    "ぎじゅつしゃ",
    "きすう",
    "きせい",
    "きせき",
    "きせつ",
    "きそう",
    "きぞく",
    "きぞん",
    "きたえる",
    "きちょう",
    "きつえん",
    "ぎっちり",
    "きつつき",
    "きつね",
    "きてい",
    "きどう",
    "きどく",
    "きない",
    "きなが",
    "きなこ",
    "きぬごし",
    "きねん",
    "きのう",
    "きのした",
    "きはく",
    "きびしい",
    "きひん",
    "きふく",
    "きぶん",
    "きぼう",
    "きほん",
    "きまる",
    "きみつ",
    "きむずかしい",
    "きめる",
    "きもだめし",
    "きもち",
    "きもの",
    "きゃく",
    "きやく",
    "ぎゅうにく",
    "きよう",
    "きょうりゅう",
    "きらい",
    "きらく",
    "きりん",
    "きれい",
    "きれつ",
    "きろく",
    "ぎろん",
    "きわめる",
    "ぎんいろ",
    "きんかくじ",
    "きんじょ",
    "きんようび",
    "ぐあい",
    "くいず",
    "くうかん",
    "くうき",
    "くうぐん",
    "くうこう",
    "ぐうせい",
    "くうそう",
    "ぐうたら",
    "くうふく",
    "くうぼ",
    "くかん",
    "くきょう",
    "くげん",
    "ぐこう",
    "くさい",
    "くさき",
    "くさばな",
    "くさる",
    "くしゃみ",
    "くしょう",
    "くすのき",
    "くすりゆび",
    "くせげ",
    "くせん",
    "ぐたいてき",
    "くださる",
    "くたびれる",
    "くちこみ",
    "くちさき",
    "くつした",
    "ぐっすり",
    "くつろぐ",
    "くとうてん",
    "くどく",
    "くなん",
    "くねくね",
    "くのう",
    "くふう",
    "くみあわせ",
    "くみたてる",
    "くめる",
    "くやくしょ",
    "くらす",
    "くらべる",
    "くるま",
    "くれる",
    "くろう",
    "くわしい",
    "ぐんかん",
    "ぐんしょく",
    "ぐんたい",
    "ぐんて",
    "けあな",
    "けいかく",
    "けいけん",
    "けいこ",
    "けいさつ",
    "げいじゅつ",
    "けいたい",
    "げいのうじん",
    "けいれき",
    "けいろ",
    "けおとす",
    "けおりもの",
    "げきか",
    "げきげん",
    "げきだん",
    "げきちん",
    "げきとつ",
    "げきは",
    "げきやく",
    "げこう",
    "げこくじょう",
    "げざい",
    "けさき",
    "げざん",
    "けしき",
    "けしごむ",
    "けしょう",
    "げすと",
    "けたば",
    "けちゃっぷ",
    "けちらす",
    "けつあつ",
    "けつい",
    "けつえき",
    "けっこん",
    "けつじょ",
    "けっせき",
    "けってい",
    "けつまつ",
    "げつようび",
    "げつれい",
    "けつろん",
    "げどく",
    "けとばす",
    "けとる",
    "けなげ",
    "けなす",
    "けなみ",
    "けぬき",
    "げねつ",
    "けねん",
    "けはい",
    "げひん",
    "けぶかい",
    "げぼく",
    "けまり",
    "けみかる",
    "けむし",
    "けむり",
    "けもの",
    "けらい",
    "けろけろ",
    "けわしい",
    "けんい",
    "けんえつ",
    "けんお",
    "けんか",
    "げんき",
    "けんげん",
    "けんこう",
    "けんさく",
    "けんしゅう",
    "けんすう",
    "げんそう",
    "けんちく",
    "けんてい",
    "けんとう",
    "けんない",
    "けんにん",
    "げんぶつ",
    "けんま",
    "けんみん",
    "けんめい",
    "けんらん",
    "けんり",
    "こあくま",
    "こいぬ",
    "こいびと",
    "ごうい",
    "こうえん",
    "こうおん",
    "こうかん",
    "ごうきゅう",
    "ごうけい",
    "こうこう",
    "こうさい",
    "こうじ",
    "こうすい",
    "ごうせい",
    "こうそく",
    "こうたい",
    "こうちゃ",
    "こうつう",
    "こうてい",
    "こうどう",
    "こうない",
    "こうはい",
    "ごうほう",
    "ごうまん",
    "こうもく",
    "こうりつ",
    "こえる",
    "こおり",
    "ごかい",
    "ごがつ",
    "ごかん",
    "こくご",
    "こくさい",
    "こくとう",
    "こくない",
    "こくはく",
    "こぐま",
    "こけい",
    "こける",
    "ここのか",
    "こころ",
    "こさめ",
    "こしつ",
    "こすう",
    "こせい",
    "こせき",
    "こぜん",
    "こそだて",
    "こたい",
    "こたえる",
    "こたつ",
    "こちょう",
    "こっか",
    "こつこつ",
    "こつばん",
    "こつぶ",
    "こてい",
    "こてん",
    "ことがら",
    "ことし",
    "ことば",
    "ことり",
    "こなごな",
    "こねこね",
    "このまま",
    "このみ",
    "このよ",
    "ごはん",
    "こひつじ",
    "こふう",
    "こふん",
    "こぼれる",
    "ごまあぶら",
    "こまかい",
    "ごますり",
    "こまつな",
    "こまる",
    "こむぎこ",
    "こもじ",
    "こもち",
    "こもの",
    "こもん",
    "こやく",
    "こやま",
    "こゆう",
    "こゆび",
    "こよい",
    "こよう",
    "こりる",
    "これくしょん",
    "ころっけ",
    "こわもて",
    "こわれる",
    "こんいん",
    "こんかい",
    "こんき",
    "こんしゅう",
    "こんすい",
    "こんだて",
    "こんとん",
    "こんなん",
    "こんびに",
    "こんぽん",
    "こんまけ",
    "こんや",
    "こんれい",
    "こんわく",
    "ざいえき",
    "さいかい",
    "さいきん",
    "ざいげん",
    "ざいこ",
    "さいしょ",
    "さいせい",
    "ざいたく",
    "ざいちゅう",
    "さいてき",
    "ざいりょう",
    "さうな",
    "さかいし",
    "さがす",
    "さかな",
    "さかみち",
    "さがる",
    "さぎょう",
    "さくし",
    "さくひん",
    "さくら",
    "さこく",
    "さこつ",
    "さずかる",
    "ざせき",
    "さたん",
    "さつえい",
    "ざつおん",
    "ざっか",
    "ざつがく",
    "さっきょく",
    "ざっし",
    "さつじん",
    "ざっそう",
    "さつたば",
    "さつまいも",
    "さてい",
    "さといも",
    "さとう",
    "さとおや",
    "さとし",
    "さとる",
    "さのう",
    "さばく",
    "さびしい",
    "さべつ",
    "さほう",
    "さほど",
    "さます",
    "さみしい",
    "さみだれ",
    "さむけ",
    "さめる",
    "さやえんどう",
    "さゆう",
    "さよう",
    "さよく",
    "さらだ",
    "ざるそば",
    "さわやか",
    "さわる",
    "さんいん",
    "さんか",
    "さんきゃく",
    "さんこう",
    "さんさい",
    "ざんしょ",
    "さんすう",
    "さんせい",
    "さんそ",
    "さんち",
    "さんま",
    "さんみ",
    "さんらん",
    "しあい",
    "しあげ",
    "しあさって",
    "しあわせ",
    "しいく",
    "しいん",
    "しうち",
    "しえい",
    "しおけ",
    "しかい",
    "しかく",
    "じかん",
    "しごと",
    "しすう",
    "じだい",
    "したうけ",
    "したぎ",
    "したて",
    "したみ",
    "しちょう",
    "しちりん",
    "しっかり",
    "しつじ",
    "しつもん",
    "してい",
    "してき",
    "してつ",
    "じてん",
    "じどう",
    "しなぎれ",
    "しなもの",
    "しなん",
    "しねま",
    "しねん",
    "しのぐ",
    "しのぶ",
    "しはい",
    "しばかり",
    "しはつ",
    "しはらい",
    "しはん",
    "しひょう",
    "しふく",
    "じぶん",
    "しへい",
    "しほう",
    "しほん",
    "しまう",
    "しまる",
    "しみん",
    "しむける",
    "じむしょ",
    "しめい",
    "しめる",
    "しもん",
    "しゃいん",
    "しゃうん",
    "しゃおん",
    "じゃがいも",
    "しやくしょ",
    "しゃくほう",
    "しゃけん",
    "しゃこ",
    "しゃざい",
    "しゃしん",
    "しゃせん",
    "しゃそう",
    "しゃたい",
    "しゃちょう",
    "しゃっきん",
    "じゃま",
    "しゃりん",
    "しゃれい",
    "じゆう",
    "じゅうしょ",
    "しゅくはく",
    "じゅしん",
    "しゅっせき",
    "しゅみ",
    "しゅらば",
    "じゅんばん",
    "しょうかい",
    "しょくたく",
    "しょっけん",
    "しょどう",
    "しょもつ",
    "しらせる",
    "しらべる",
    "しんか",
    "しんこう",
    "じんじゃ",
    "しんせいじ",
    "しんちく",
    "しんりん",
    "すあげ",
    "すあし",
    "すあな",
    "ずあん",
    "すいえい",
    "すいか",
    "すいとう",
    "ずいぶん",
    "すいようび",
    "すうがく",
    "すうじつ",
    "すうせん",
    "すおどり",
    "すきま",
    "すくう",
    "すくない",
    "すける",
    "すごい",
    "すこし",
    "ずさん",
    "すずしい",
    "すすむ",
    "すすめる",
    "すっかり",
    "ずっしり",
    "ずっと",
    "すてき",
    "すてる",
    "すねる",
    "すのこ",
    "すはだ",
    "すばらしい",
    "ずひょう",
    "ずぶぬれ",
    "すぶり",
    "すふれ",
    "すべて",
    "すべる",
    "ずほう",
    "すぼん",
    "すまい",
    "すめし",
    "すもう",
    "すやき",
    "すらすら",
    "するめ",
    "すれちがう",
    "すろっと",
    "すわる",
    "すんぜん",
    "すんぽう",
    "せあぶら",
    "せいかつ",
    "せいげん",
    "せいじ",
    "せいよう",
    "せおう",
    "せかいかん",
    "せきにん",
    "せきむ",
    "せきゆ",
    "せきらんうん",
    "せけん",
    "せこう",
    "せすじ",
    "せたい",
    "せたけ",
    "せっかく",
    "せっきゃく",
    "ぜっく",
    "せっけん",
    "せっこつ",
    "せっさたくま",
    "せつぞく",
    "せつだん",
    "せつでん",
    "せっぱん",
    "せつび",
    "せつぶん",
    "せつめい",
    "せつりつ",
    "せなか",
    "せのび",
    "せはば",
    "せびろ",
    "せぼね",
    "せまい",
    "せまる",
    "せめる",
    "せもたれ",
    "せりふ",
    "ぜんあく",
    "せんい",
    "せんえい",
    "せんか",
    "せんきょ",
    "せんく",
    "せんげん",
    "ぜんご",
    "せんさい",
    "せんしゅ",
    "せんすい",
    "せんせい",
    "せんぞ",
    "せんたく",
    "せんちょう",
    "せんてい",
    "せんとう",
    "せんぬき",
    "せんねん",
    "せんぱい",
    "ぜんぶ",
    "ぜんぽう",
    "せんむ",
    "せんめんじょ",
    "せんもん",
    "せんやく",
    "せんゆう",
    "せんよう",
    "ぜんら",
    "ぜんりゃく",
    "せんれい",
    "せんろ",
    "そあく",
    "そいとげる",
    "そいね",
    "そうがんきょう",
    "そうき",
    "そうご",
    "そうしん",
    "そうだん",
    "そうなん",
    "そうび",
    "そうめん",
    "そうり",
    "そえもの",
    "そえん",
    "そがい",
    "そげき",
    "そこう",
    "そこそこ",
    "そざい",
    "そしな",
    "そせい",
    "そせん",
    "そそぐ",
    "そだてる",
    "そつう",
    "そつえん",
    "そっかん",
    "そつぎょう",
    "そっけつ",
    "そっこう",
    "そっせん",
    "そっと",
    "そとがわ",
    "そとづら",
    "そなえる",
    "そなた",
    "そふぼ",
    "そぼく",
    "そぼろ",
    "そまつ",
    "そまる",
    "そむく",
    "そむりえ",
    "そめる",
    "そもそも",
    "そよかぜ",
    "そらまめ",
    "そろう",
    "そんかい",
    "そんけい",
    "そんざい",
    "そんしつ",
    "そんぞく",
    "そんちょう",
    "ぞんび",
    "ぞんぶん",
    "そんみん",
    "たあい",
    "たいいん",
    "たいうん",
    "たいえき",
    "たいおう",
    "だいがく",
    "たいき",
    "たいぐう",
    "たいけん",
    "たいこ",
    "たいざい",
    "だいじょうぶ",
    "だいすき",
    "たいせつ",
    "たいそう",
    "だいたい",
    "たいちょう",
    "たいてい",
    "だいどころ",
    "たいない",
    "たいねつ",
    "たいのう",
    "たいはん",
    "だいひょう",
    "たいふう",
    "たいへん",
    "たいほ",
    "たいまつばな",
    "たいみんぐ",
    "たいむ",
    "たいめん",
    "たいやき",
    "たいよう",
    "たいら",
    "たいりょく",
    "たいる",
    "たいわん",
    "たうえ",
    "たえる",
    "たおす",
    "たおる",
    "たおれる",
    "たかい",
    "たかね",
    "たきび",
    "たくさん",
    "たこく",
    "たこやき",
    "たさい",
    "たしざん",
    "だじゃれ",
    "たすける",
    "たずさわる",
    "たそがれ",
    "たたかう",
    "たたく",
    "ただしい",
    "たたみ",
    "たちばな",
    "だっかい",
    "だっきゃく",
    "だっこ",
    "だっしゅつ",
    "だったい",
    "たてる",
    "たとえる",
    "たなばた",
    "たにん",
    "たぬき",
    "たのしみ",
    "たはつ",
    "たぶん",
    "たべる",
    "たぼう",
    "たまご",
    "たまる",
    "だむる",
    "ためいき",
    "ためす",
    "ためる",
    "たもつ",
    "たやすい",
    "たよる",
    "たらす",
    "たりきほんがん",
    "たりょう",
    "たりる",
    "たると",
    "たれる",
    "たれんと",
    "たろっと",
    "たわむれる",
    "だんあつ",
    "たんい",
    "たんおん",
    "たんか",
    "たんき",
    "たんけん",
    "たんご",
    "たんさん",
    "たんじょうび",
    "だんせい",
    "たんそく",
    "たんたい",
    "だんち",
    "たんてい",
    "たんとう",
    "だんな",
    "たんにん",
    "だんねつ",
    "たんのう",
    "たんぴん",
    "だんぼう",
    "たんまつ",
    "たんめい",
    "だんれつ",
    "だんろ",
    "だんわ",
    "ちあい",
    "ちあん",
    "ちいき",
    "ちいさい",
    "ちえん",
    "ちかい",
    "ちから",
    "ちきゅう",
    "ちきん",
    "ちけいず",
    "ちけん",
    "ちこく",
    "ちさい",
    "ちしき",
    "ちしりょう",
    "ちせい",
    "ちそう",
    "ちたい",
    "ちたん",
    "ちちおや",
    "ちつじょ",
    "ちてき",
    "ちてん",
    "ちぬき",
    "ちぬり",
    "ちのう",
    "ちひょう",
    "ちへいせん",
    "ちほう",
    "ちまた",
    "ちみつ",
    "ちみどろ",
    "ちめいど",
    "ちゃんこなべ",
    "ちゅうい",
    "ちゆりょく",
    "ちょうし",
    "ちょさくけん",
    "ちらし",
    "ちらみ",
    "ちりがみ",
    "ちりょう",
    "ちるど",
    "ちわわ",
    "ちんたい",
    "ちんもく",
    "ついか",
    "ついたち",
    "つうか",
    "つうじょう",
    "つうはん",
    "つうわ",
    "つかう",
    "つかれる",
    "つくね",
    "つくる",
    "つけね",
    "つける",
    "つごう",
    "つたえる",
    "つづく",
    "つつじ",
    "つつむ",
    "つとめる",
    "つながる",
    "つなみ",
    "つねづね",
    "つのる",
    "つぶす",
    "つまらない",
    "つまる",
    "つみき",
    "つめたい",
    "つもり",
    "つもる",
    "つよい",
    "つるぼ",
    "つるみく",
    "つわもの",
    "つわり",
    "てあし",
    "てあて",
    "てあみ",
    "ていおん",
    "ていか",
    "ていき",
    "ていけい",
    "ていこく",
    "ていさつ",
    "ていし",
    "ていせい",
    "ていたい",
    "ていど",
    "ていねい",
    "ていひょう",
    "ていへん",
    "ていぼう",
    "てうち",
    "ておくれ",
    "てきとう",
    "てくび",
    "でこぼこ",
    "てさぎょう",
    "てさげ",
    "てすり",
    "てそう",
    "てちがい",
    "てちょう",
    "てつがく",
    "てつづき",
    "でっぱ",
    "てつぼう",
    "てつや",
    "でぬかえ",
    "てぬき",
    "てぬぐい",
    "てのひら",
    "てはい",
    "てぶくろ",
    "てふだ",
    "てほどき",
    "てほん",
    "てまえ",
    "てまきずし",
    "てみじか",
    "てみやげ",
    "てらす",
    "てれび",
    "てわけ",
    "てわたし",
    "でんあつ",
    "てんいん",
    "てんかい",
    "てんき",
    "てんぐ",
    "てんけん",
    "てんごく",
    "てんさい",
    "てんし",
    "てんすう",
    "でんち",
    "てんてき",
    "てんとう",
    "てんない",
    "てんぷら",
    "てんぼうだい",
    "てんめつ",
    "てんらんかい",
    "でんりょく",
    "でんわ",
    "どあい",
    "といれ",
    "どうかん",
    "とうきゅう",
    "どうぐ",
    "とうし",
    "とうむぎ",
    "とおい",
    "とおか",
    "とおく",
    "とおす",
    "とおる",
    "とかい",
    "とかす",
    "ときおり",
    "ときどき",
    "とくい",
    "とくしゅう",
    "とくてん",
    "とくに",
    "とくべつ",
    "とけい",
    "とける",
    "とこや",
    "とさか",
    "としょかん",
    "とそう",
    "とたん",
    "とちゅう",
    "とっきゅう",
    "とっくん",
    "とつぜん",
    "とつにゅう",
    "とどける",
    "ととのえる",
    "とない",
    "となえる",
    "となり",
    "とのさま",
    "とばす",
    "どぶがわ",
    "とほう",
    "とまる",
    "とめる",
    "ともだち",
    "ともる",
    "どようび",
    "とらえる",
    "とんかつ",
    "どんぶり",
    "ないかく",
    "ないこう",
    "ないしょ",
    "ないす",
    "ないせん",
    "ないそう",
    "なおす",
    "ながい",
    "なくす",
    "なげる",
    "なこうど",
    "なさけ",
    "なたでここ",
    "なっとう",
    "なつやすみ",
    "ななおし",
    "なにごと",
    "なにもの",
    "なにわ",
    "なのか",
    "なふだ",
    "なまいき",
    "なまえ",
    "なまみ",
    "なみだ",
    "なめらか",
    "なめる",
    "なやむ",
    "ならう",
    "ならび",
    "ならぶ",
    "なれる",
    "なわとび",
    "なわばり",
    "にあう",
    "にいがた",
    "にうけ",
    "におい",
    "にかい",
    "にがて",
    "にきび",
    "にくしみ",
    "にくまん",
    "にげる",
    "にさんかたんそ",
    "にしき",
    "にせもの",
    "にちじょう",
    "にちようび",
    "にっか",
    "にっき",
    "にっけい",
    "にっこう",
    "にっさん",
    "にっしょく",
    "にっすう",
    "にっせき",
    "にってい",
    "になう",
    "にほん",
    "にまめ",
    "にもつ",
    "にやり",
    "にゅういん",
    "にりんしゃ",
    "にわとり",
    "にんい",
    "にんか",
    "にんき",
    "にんげん",
    "にんしき",
    "にんずう",
    "にんそう",
    "にんたい",
    "にんち",
    "にんてい",
    "にんにく",
    "にんぷ",
    "にんまり",
    "にんむ",
    "にんめい",
    "にんよう",
    "ぬいくぎ",
    "ぬかす",
    "ぬぐいとる",
    "ぬぐう",
    "ぬくもり",
    "ぬすむ",
    "ぬまえび",
    "ぬめり",
    "ぬらす",
    "ぬんちゃく",
    "ねあげ",
    "ねいき",
    "ねいる",
    "ねいろ",
    "ねぐせ",
    "ねくたい",
    "ねくら",
    "ねこぜ",
    "ねこむ",
    "ねさげ",
    "ねすごす",
    "ねそべる",
    "ねだん",
    "ねつい",
    "ねっしん",
    "ねつぞう",
    "ねったいぎょ",
    "ねぶそく",
    "ねふだ",
    "ねぼう",
    "ねほりはほり",
    "ねまき",
    "ねまわし",
    "ねみみ",
    "ねむい",
    "ねむたい",
    "ねもと",
    "ねらう",
    "ねわざ",
    "ねんいり",
    "ねんおし",
    "ねんかん",
    "ねんきん",
    "ねんぐ",
    "ねんざ",
    "ねんし",
    "ねんちゃく",
    "ねんど",
    "ねんぴ",
    "ねんぶつ",
    "ねんまつ",
    "ねんりょう",
    "ねんれい",
    "のいず",
    "のおづま",
    "のがす",
    "のきなみ",
    "のこぎり",
    "のこす",
    "のこる",
    "のせる",
    "のぞく",
    "のぞむ",
    "のたまう",
    "のちほど",
    "のっく",
    "のばす",
    "のはら",
    "のべる",
    "のぼる",
    "のみもの",
    "のやま",
    "のらいぬ",
    "のらねこ",
    "のりもの",
    "のりゆき",
    "のれん",
    "のんき",
    "ばあい",
    "はあく",
    "ばあさん",
    "ばいか",
    "ばいく",
    "はいけん",
    "はいご",
    "はいしん",
    "はいすい",
    "はいせん",
    "はいそう",
    "はいち",
    "ばいばい",
    "はいれつ",
    "はえる",
    "はおる",
    "はかい",
    "ばかり",
    "はかる",
    "はくしゅ",
    "はけん",
    "はこぶ",
    "はさみ",
    "はさん",
    "はしご",
    "ばしょ",
    "はしる",
    "はせる",
    "ぱそこん",
    "はそん",
    "はたん",
    "はちみつ",
    "はつおん",
    "はっかく",
    "はづき",
    "はっきり",
    "はっくつ",
    "はっけん",
    "はっこう",
    "はっさん",
    "はっしん",
    "はったつ",
    "はっちゅう",
    "はってん",
    "はっぴょう",
    "はっぽう",
    "はなす",
    "はなび",
    "はにかむ",
    "はぶらし",
    "はみがき",
    "はむかう",
    "はめつ",
    "はやい",
    "はやし",
    "はらう",
    "はろうぃん",
    "はわい",
    "はんい",
    "はんえい",
    "はんおん",
    "はんかく",
    "はんきょう",
    "ばんぐみ",
    "はんこ",
    "はんしゃ",
    "はんすう",
    "はんだん",
    "ぱんち",
    "ぱんつ",
    "はんてい",
    "はんとし",
    "はんのう",
    "はんぱ",
    "はんぶん",
    "はんぺん",
    "はんぼうき",
    "はんめい",
    "はんらん",
    "はんろん",
    "ひいき",
    "ひうん",
    "ひえる",
    "ひかく",
    "ひかり",
    "ひかる",
    "ひかん",
    "ひくい",
    "ひけつ",
    "ひこうき",
    "ひこく",
    "ひさい",
    "ひさしぶり",
    "ひさん",
    "びじゅつかん",
    "ひしょ",
    "ひそか",
    "ひそむ",
    "ひたむき",
    "ひだり",
    "ひたる",
    "ひつぎ",
    "ひっこし",
    "ひっし",
    "ひつじゅひん",
    "ひっす",
    "ひつぜん",
    "ぴったり",
    "ぴっちり",
    "ひつよう",
    "ひてい",
    "ひとごみ",
    "ひなまつり",
    "ひなん",
    "ひねる",
    "ひはん",
    "ひびく",
    "ひひょう",
    "ひほう",
    "ひまわり",
    "ひまん",
    "ひみつ",
    "ひめい",
    "ひめじし",
    "ひやけ",
    "ひやす",
    "ひよう",
    "びょうき",
    "ひらがな",
    "ひらく",
    "ひりつ",
    "ひりょう",
    "ひるま",
    "ひるやすみ",
    "ひれい",
    "ひろい",
    "ひろう",
    "ひろき",
    "ひろゆき",
    "ひんかく",
    "ひんけつ",
    "ひんこん",
    "ひんしゅ",
    "ひんそう",
    "ぴんち",
    "ひんぱん",
    "びんぼう",
    "ふあん",
    "ふいうち",
    "ふうけい",
    "ふうせん",
    "ぷうたろう",
    "ふうとう",
    "ふうふ",
    "ふえる",
    "ふおん",
    "ふかい",
    "ふきん",
    "ふくざつ",
    "ふくぶくろ",
    "ふこう",
    "ふさい",
    "ふしぎ",
    "ふじみ",
    "ふすま",
    "ふせい",
    "ふせぐ",
    "ふそく",
    "ぶたにく",
    "ふたん",
    "ふちょう",
    "ふつう",
    "ふつか",
    "ふっかつ",
    "ふっき",
    "ふっこく",
    "ぶどう",
    "ふとる",
    "ふとん",
    "ふのう",
    "ふはい",
    "ふひょう",
    "ふへん",
    "ふまん",
    "ふみん",
    "ふめつ",
    "ふめん",
    "ふよう",
    "ふりこ",
    "ふりる",
    "ふるい",
    "ふんいき",
    "ぶんがく",
    "ぶんぐ",
    "ふんしつ",
    "ぶんせき",
    "ふんそう",
    "ぶんぽう",
    "へいあん",
    "へいおん",
    "へいがい",
    "へいき",
    "へいげん",
    "へいこう",
    "へいさ",
    "へいしゃ",
    "へいせつ",
    "へいそ",
    "へいたく",
    "へいてん",
    "へいねつ",
    "へいわ",
    "へきが",
    "へこむ",
    "べにいろ",
    "べにしょうが",
    "へらす",
    "へんかん",
    "べんきょう",
    "べんごし",
    "へんさい",
    "へんたい",
    "べんり",
    "ほあん",
    "ほいく",
    "ぼうぎょ",
    "ほうこく",
    "ほうそう",
    "ほうほう",
    "ほうもん",
    "ほうりつ",
    "ほえる",
    "ほおん",
    "ほかん",
    "ほきょう",
    "ぼきん",
    "ほくろ",
    "ほけつ",
    "ほけん",
    "ほこう",
    "ほこる",
    "ほしい",
    "ほしつ",
    "ほしゅ",
    "ほしょう",
    "ほせい",
    "ほそい",
    "ほそく",
    "ほたて",
    "ほたる",
    "ぽちぶくろ",
    "ほっきょく",
    "ほっさ",
    "ほったん",
    "ほとんど",
    "ほめる",
    "ほんい",
    "ほんき",
    "ほんけ",
    "ほんしつ",
    "ほんやく",
    "まいにち",
    "まかい",
    "まかせる",
    "まがる",
    "まける",
    "まこと",
    "まさつ",
    "まじめ",
    "ますく",
    "まぜる",
    "まつり",
    "まとめ",
    "まなぶ",
    "まぬけ",
    "まねく",
    "まほう",
    "まもる",
    "まゆげ",
    "まよう",
    "まろやか",
    "まわす",
    "まわり",
    "まわる",
    "まんが",
    "まんきつ",
    "まんぞく",
    "まんなか",
    "みいら",
    "みうち",
    "みえる",
    "みがく",
    "みかた",
    "みかん",
    "みけん",
    "みこん",
    "みじかい",
    "みすい",
    "みすえる",
    "みせる",
    "みっか",
    "みつかる",
    "みつける",
    "みてい",
    "みとめる",
    "みなと",
    "みなみかさい",
    "みねらる",
    "みのう",
    "みのがす",
    "みほん",
    "みもと",
    "みやげ",
    "みらい",
    "みりょく",
    "みわく",
    "みんか",
    "みんぞく",
    "むいか",
    "むえき",
    "むえん",
    "むかい",
    "むかう",
    "むかえ",
    "むかし",
    "むぎちゃ",
    "むける",
    "むげん",
    "むさぼる",
    "むしあつい",
    "むしば",
    "むじゅん",
    "むしろ",
    "むすう",
    "むすこ",
    "むすぶ",
    "むすめ",
    "むせる",
    "むせん",
    "むちゅう",
    "むなしい",
    "むのう",
    "むやみ",
    "むよう",
    "むらさき",
    "むりょう",
    "むろん",
    "めいあん",
    "めいうん",
    "めいえん",
    "めいかく",
    "めいきょく",
    "めいさい",
    "めいし",
    "めいそう",
    "めいぶつ",
    "めいれい",
    "めいわく",
    "めぐまれる",
    "めざす",
    "めした",
    "めずらしい",
    "めだつ",
    "めまい",
    "めやす",
    "めんきょ",
    "めんせき",
    "めんどう",
    "もうしあげる",
    "もうどうけん",
    "もえる",
    "もくし",
    "もくてき",
    "もくようび",
    "もちろん",
    "もどる",
    "もらう",
    "もんく",
    "もんだい",
    "やおや",
    "やける",
    "やさい",
    "やさしい",
    "やすい",
    "やすたろう",
    "やすみ",
    "やせる",
    "やそう",
    "やたい",
    "やちん",
    "やっと",
    "やっぱり",
    "やぶる",
    "やめる",
    "ややこしい",
    "やよい",
    "やわらかい",
    "ゆうき",
    "ゆうびんきょく",
    "ゆうべ",
    "ゆうめい",
    "ゆけつ",
    "ゆしゅつ",
    "ゆせん",
    "ゆそう",
    "ゆたか",
    "ゆちゃく",
    "ゆでる",
    "ゆにゅう",
    "ゆびわ",
    "ゆらい",
    "ゆれる",
    "ようい",
    "ようか",
    "ようきゅう",
    "ようじ",
    "ようす",
    "ようちえん",
    "よかぜ",
    "よかん",
    "よきん",
    "よくせい",
    "よくぼう",
    "よけい",
    "よごれる",
    "よさん",
    "よしゅう",
    "よそう",
    "よそく",
    "よっか",
    "よてい",
    "よどがわく",
    "よねつ",
    "よやく",
    "よゆう",
    "よろこぶ",
    "よろしい",
    "らいう",
    "らくがき",
    "らくご",
    "らくさつ",
    "らくだ",
    "らしんばん",
    "らせん",
    "らぞく",
    "らたい",
    "らっか",
    "られつ",
    "りえき",
    "りかい",
    "りきさく",
    "りきせつ",
    "りくぐん",
    "りくつ",
    "りけん",
    "りこう",
    "りせい",
    "りそう",
    "りそく",
    "りてん",
    "りねん",
    "りゆう",
    "りゅうがく",
    "りよう",
    "りょうり",
    "りょかん",
    "りょくちゃ",
    "りょこう",
    "りりく",
    "りれき",
    "りろん",
    "りんご",
    "るいけい",
    "るいさい",
    "るいじ",
    "るいせき",
    "るすばん",
    "るりがわら",
    "れいかん",
    "れいぎ",
    "れいせい",
    "れいぞうこ",
    "れいとう",
    "れいぼう",
    "れきし",
    "れきだい",
    "れんあい",
    "れんけい",
    "れんこん",
    "れんさい",
    "れんしゅう",
    "れんぞく",
    "れんらく",
    "ろうか",
    "ろうご",
    "ろうじん",
    "ろうそく",
    "ろくが",
    "ろこつ",
    "ろじうら",
    "ろしゅつ",
    "ろせん",
    "ろてん",
    "ろめん",
    "ろれつ",
    "ろんぎ",
    "ろんぱ",
    "ろんぶん",
    "ろんり",
    "わかす",
    "わかめ",
    "わかやま",
    "わかれる",
    "わしつ",
    "わじまし",
    "わすれもの",
    "わらう",
    "われる"
], ore = [
    "abacate",
    "abaixo",
    "abalar",
    "abater",
    "abduzir",
    "abelha",
    "aberto",
    "abismo",
    "abotoar",
    "abranger",
    "abreviar",
    "abrigar",
    "abrupto",
    "absinto",
    "absoluto",
    "absurdo",
    "abutre",
    "acabado",
    "acalmar",
    "acampar",
    "acanhar",
    "acaso",
    "aceitar",
    "acelerar",
    "acenar",
    "acervo",
    "acessar",
    "acetona",
    "achatar",
    "acidez",
    "acima",
    "acionado",
    "acirrar",
    "aclamar",
    "aclive",
    "acolhida",
    "acomodar",
    "acoplar",
    "acordar",
    "acumular",
    "acusador",
    "adaptar",
    "adega",
    "adentro",
    "adepto",
    "adequar",
    "aderente",
    "adesivo",
    "adeus",
    "adiante",
    "aditivo",
    "adjetivo",
    "adjunto",
    "admirar",
    "adorar",
    "adquirir",
    "adubo",
    "adverso",
    "advogado",
    "aeronave",
    "afastar",
    "aferir",
    "afetivo",
    "afinador",
    "afivelar",
    "aflito",
    "afluente",
    "afrontar",
    "agachar",
    "agarrar",
    "agasalho",
    "agenciar",
    "agilizar",
    "agiota",
    "agitado",
    "agora",
    "agradar",
    "agreste",
    "agrupar",
    "aguardar",
    "agulha",
    "ajoelhar",
    "ajudar",
    "ajustar",
    "alameda",
    "alarme",
    "alastrar",
    "alavanca",
    "albergue",
    "albino",
    "alcatra",
    "aldeia",
    "alecrim",
    "alegria",
    "alertar",
    "alface",
    "alfinete",
    "algum",
    "alheio",
    "aliar",
    "alicate",
    "alienar",
    "alinhar",
    "aliviar",
    "almofada",
    "alocar",
    "alpiste",
    "alterar",
    "altitude",
    "alucinar",
    "alugar",
    "aluno",
    "alusivo",
    "alvo",
    "amaciar",
    "amador",
    "amarelo",
    "amassar",
    "ambas",
    "ambiente",
    "ameixa",
    "amenizar",
    "amido",
    "amistoso",
    "amizade",
    "amolador",
    "amontoar",
    "amoroso",
    "amostra",
    "amparar",
    "ampliar",
    "ampola",
    "anagrama",
    "analisar",
    "anarquia",
    "anatomia",
    "andaime",
    "anel",
    "anexo",
    "angular",
    "animar",
    "anjo",
    "anomalia",
    "anotado",
    "ansioso",
    "anterior",
    "anuidade",
    "anunciar",
    "anzol",
    "apagador",
    "apalpar",
    "apanhado",
    "apego",
    "apelido",
    "apertada",
    "apesar",
    "apetite",
    "apito",
    "aplauso",
    "aplicada",
    "apoio",
    "apontar",
    "aposta",
    "aprendiz",
    "aprovar",
    "aquecer",
    "arame",
    "aranha",
    "arara",
    "arcada",
    "ardente",
    "areia",
    "arejar",
    "arenito",
    "aresta",
    "argiloso",
    "argola",
    "arma",
    "arquivo",
    "arraial",
    "arrebate",
    "arriscar",
    "arroba",
    "arrumar",
    "arsenal",
    "arterial",
    "artigo",
    "arvoredo",
    "asfaltar",
    "asilado",
    "aspirar",
    "assador",
    "assinar",
    "assoalho",
    "assunto",
    "astral",
    "atacado",
    "atadura",
    "atalho",
    "atarefar",
    "atear",
    "atender",
    "aterro",
    "ateu",
    "atingir",
    "atirador",
    "ativo",
    "atoleiro",
    "atracar",
    "atrevido",
    "atriz",
    "atual",
    "atum",
    "auditor",
    "aumentar",
    "aura",
    "aurora",
    "autismo",
    "autoria",
    "autuar",
    "avaliar",
    "avante",
    "avaria",
    "avental",
    "avesso",
    "aviador",
    "avisar",
    "avulso",
    "axila",
    "azarar",
    "azedo",
    "azeite",
    "azulejo",
    "babar",
    "babosa",
    "bacalhau",
    "bacharel",
    "bacia",
    "bagagem",
    "baiano",
    "bailar",
    "baioneta",
    "bairro",
    "baixista",
    "bajular",
    "baleia",
    "baliza",
    "balsa",
    "banal",
    "bandeira",
    "banho",
    "banir",
    "banquete",
    "barato",
    "barbado",
    "baronesa",
    "barraca",
    "barulho",
    "baseado",
    "bastante",
    "batata",
    "batedor",
    "batida",
    "batom",
    "batucar",
    "baunilha",
    "beber",
    "beijo",
    "beirada",
    "beisebol",
    "beldade",
    "beleza",
    "belga",
    "beliscar",
    "bendito",
    "bengala",
    "benzer",
    "berimbau",
    "berlinda",
    "berro",
    "besouro",
    "bexiga",
    "bezerro",
    "bico",
    "bicudo",
    "bienal",
    "bifocal",
    "bifurcar",
    "bigorna",
    "bilhete",
    "bimestre",
    "bimotor",
    "biologia",
    "biombo",
    "biosfera",
    "bipolar",
    "birrento",
    "biscoito",
    "bisneto",
    "bispo",
    "bissexto",
    "bitola",
    "bizarro",
    "blindado",
    "bloco",
    "bloquear",
    "boato",
    "bobagem",
    "bocado",
    "bocejo",
    "bochecha",
    "boicotar",
    "bolada",
    "boletim",
    "bolha",
    "bolo",
    "bombeiro",
    "bonde",
    "boneco",
    "bonita",
    "borbulha",
    "borda",
    "boreal",
    "borracha",
    "bovino",
    "boxeador",
    "branco",
    "brasa",
    "braveza",
    "breu",
    "briga",
    "brilho",
    "brincar",
    "broa",
    "brochura",
    "bronzear",
    "broto",
    "bruxo",
    "bucha",
    "budismo",
    "bufar",
    "bule",
    "buraco",
    "busca",
    "busto",
    "buzina",
    "cabana",
    "cabelo",
    "cabide",
    "cabo",
    "cabrito",
    "cacau",
    "cacetada",
    "cachorro",
    "cacique",
    "cadastro",
    "cadeado",
    "cafezal",
    "caiaque",
    "caipira",
    "caixote",
    "cajado",
    "caju",
    "calafrio",
    "calcular",
    "caldeira",
    "calibrar",
    "calmante",
    "calota",
    "camada",
    "cambista",
    "camisa",
    "camomila",
    "campanha",
    "camuflar",
    "canavial",
    "cancelar",
    "caneta",
    "canguru",
    "canhoto",
    "canivete",
    "canoa",
    "cansado",
    "cantar",
    "canudo",
    "capacho",
    "capela",
    "capinar",
    "capotar",
    "capricho",
    "captador",
    "capuz",
    "caracol",
    "carbono",
    "cardeal",
    "careca",
    "carimbar",
    "carneiro",
    "carpete",
    "carreira",
    "cartaz",
    "carvalho",
    "casaco",
    "casca",
    "casebre",
    "castelo",
    "casulo",
    "catarata",
    "cativar",
    "caule",
    "causador",
    "cautelar",
    "cavalo",
    "caverna",
    "cebola",
    "cedilha",
    "cegonha",
    "celebrar",
    "celular",
    "cenoura",
    "censo",
    "centeio",
    "cercar",
    "cerrado",
    "certeiro",
    "cerveja",
    "cetim",
    "cevada",
    "chacota",
    "chaleira",
    "chamado",
    "chapada",
    "charme",
    "chatice",
    "chave",
    "chefe",
    "chegada",
    "cheiro",
    "cheque",
    "chicote",
    "chifre",
    "chinelo",
    "chocalho",
    "chover",
    "chumbo",
    "chutar",
    "chuva",
    "cicatriz",
    "ciclone",
    "cidade",
    "cidreira",
    "ciente",
    "cigana",
    "cimento",
    "cinto",
    "cinza",
    "ciranda",
    "circuito",
    "cirurgia",
    "citar",
    "clareza",
    "clero",
    "clicar",
    "clone",
    "clube",
    "coado",
    "coagir",
    "cobaia",
    "cobertor",
    "cobrar",
    "cocada",
    "coelho",
    "coentro",
    "coeso",
    "cogumelo",
    "coibir",
    "coifa",
    "coiote",
    "colar",
    "coleira",
    "colher",
    "colidir",
    "colmeia",
    "colono",
    "coluna",
    "comando",
    "combinar",
    "comentar",
    "comitiva",
    "comover",
    "complexo",
    "comum",
    "concha",
    "condor",
    "conectar",
    "confuso",
    "congelar",
    "conhecer",
    "conjugar",
    "consumir",
    "contrato",
    "convite",
    "cooperar",
    "copeiro",
    "copiador",
    "copo",
    "coquetel",
    "coragem",
    "cordial",
    "corneta",
    "coronha",
    "corporal",
    "correio",
    "cortejo",
    "coruja",
    "corvo",
    "cosseno",
    "costela",
    "cotonete",
    "couro",
    "couve",
    "covil",
    "cozinha",
    "cratera",
    "cravo",
    "creche",
    "credor",
    "creme",
    "crer",
    "crespo",
    "criada",
    "criminal",
    "crioulo",
    "crise",
    "criticar",
    "crosta",
    "crua",
    "cruzeiro",
    "cubano",
    "cueca",
    "cuidado",
    "cujo",
    "culatra",
    "culminar",
    "culpar",
    "cultura",
    "cumprir",
    "cunhado",
    "cupido",
    "curativo",
    "curral",
    "cursar",
    "curto",
    "cuspir",
    "custear",
    "cutelo",
    "damasco",
    "datar",
    "debater",
    "debitar",
    "deboche",
    "debulhar",
    "decalque",
    "decimal",
    "declive",
    "decote",
    "decretar",
    "dedal",
    "dedicado",
    "deduzir",
    "defesa",
    "defumar",
    "degelo",
    "degrau",
    "degustar",
    "deitado",
    "deixar",
    "delator",
    "delegado",
    "delinear",
    "delonga",
    "demanda",
    "demitir",
    "demolido",
    "dentista",
    "depenado",
    "depilar",
    "depois",
    "depressa",
    "depurar",
    "deriva",
    "derramar",
    "desafio",
    "desbotar",
    "descanso",
    "desenho",
    "desfiado",
    "desgaste",
    "desigual",
    "deslize",
    "desmamar",
    "desova",
    "despesa",
    "destaque",
    "desviar",
    "detalhar",
    "detentor",
    "detonar",
    "detrito",
    "deusa",
    "dever",
    "devido",
    "devotado",
    "dezena",
    "diagrama",
    "dialeto",
    "didata",
    "difuso",
    "digitar",
    "dilatado",
    "diluente",
    "diminuir",
    "dinastia",
    "dinheiro",
    "diocese",
    "direto",
    "discreta",
    "disfarce",
    "disparo",
    "disquete",
    "dissipar",
    "distante",
    "ditador",
    "diurno",
    "diverso",
    "divisor",
    "divulgar",
    "dizer",
    "dobrador",
    "dolorido",
    "domador",
    "dominado",
    "donativo",
    "donzela",
    "dormente",
    "dorsal",
    "dosagem",
    "dourado",
    "doutor",
    "drenagem",
    "drible",
    "drogaria",
    "duelar",
    "duende",
    "dueto",
    "duplo",
    "duquesa",
    "durante",
    "duvidoso",
    "eclodir",
    "ecoar",
    "ecologia",
    "edificar",
    "edital",
    "educado",
    "efeito",
    "efetivar",
    "ejetar",
    "elaborar",
    "eleger",
    "eleitor",
    "elenco",
    "elevador",
    "eliminar",
    "elogiar",
    "embargo",
    "embolado",
    "embrulho",
    "embutido",
    "emenda",
    "emergir",
    "emissor",
    "empatia",
    "empenho",
    "empinado",
    "empolgar",
    "emprego",
    "empurrar",
    "emulador",
    "encaixe",
    "encenado",
    "enchente",
    "encontro",
    "endeusar",
    "endossar",
    "enfaixar",
    "enfeite",
    "enfim",
    "engajado",
    "engenho",
    "englobar",
    "engomado",
    "engraxar",
    "enguia",
    "enjoar",
    "enlatar",
    "enquanto",
    "enraizar",
    "enrolado",
    "enrugar",
    "ensaio",
    "enseada",
    "ensino",
    "ensopado",
    "entanto",
    "enteado",
    "entidade",
    "entortar",
    "entrada",
    "entulho",
    "envergar",
    "enviado",
    "envolver",
    "enxame",
    "enxerto",
    "enxofre",
    "enxuto",
    "epiderme",
    "equipar",
    "ereto",
    "erguido",
    "errata",
    "erva",
    "ervilha",
    "esbanjar",
    "esbelto",
    "escama",
    "escola",
    "escrita",
    "escuta",
    "esfinge",
    "esfolar",
    "esfregar",
    "esfumado",
    "esgrima",
    "esmalte",
    "espanto",
    "espelho",
    "espiga",
    "esponja",
    "espreita",
    "espumar",
    "esquerda",
    "estaca",
    "esteira",
    "esticar",
    "estofado",
    "estrela",
    "estudo",
    "esvaziar",
    "etanol",
    "etiqueta",
    "euforia",
    "europeu",
    "evacuar",
    "evaporar",
    "evasivo",
    "eventual",
    "evidente",
    "evoluir",
    "exagero",
    "exalar",
    "examinar",
    "exato",
    "exausto",
    "excesso",
    "excitar",
    "exclamar",
    "executar",
    "exemplo",
    "exibir",
    "exigente",
    "exonerar",
    "expandir",
    "expelir",
    "expirar",
    "explanar",
    "exposto",
    "expresso",
    "expulsar",
    "externo",
    "extinto",
    "extrato",
    "fabricar",
    "fabuloso",
    "faceta",
    "facial",
    "fada",
    "fadiga",
    "faixa",
    "falar",
    "falta",
    "familiar",
    "fandango",
    "fanfarra",
    "fantoche",
    "fardado",
    "farelo",
    "farinha",
    "farofa",
    "farpa",
    "fartura",
    "fatia",
    "fator",
    "favorita",
    "faxina",
    "fazenda",
    "fechado",
    "feijoada",
    "feirante",
    "felino",
    "feminino",
    "fenda",
    "feno",
    "fera",
    "feriado",
    "ferrugem",
    "ferver",
    "festejar",
    "fetal",
    "feudal",
    "fiapo",
    "fibrose",
    "ficar",
    "ficheiro",
    "figurado",
    "fileira",
    "filho",
    "filme",
    "filtrar",
    "firmeza",
    "fisgada",
    "fissura",
    "fita",
    "fivela",
    "fixador",
    "fixo",
    "flacidez",
    "flamingo",
    "flanela",
    "flechada",
    "flora",
    "flutuar",
    "fluxo",
    "focal",
    "focinho",
    "fofocar",
    "fogo",
    "foguete",
    "foice",
    "folgado",
    "folheto",
    "forjar",
    "formiga",
    "forno",
    "forte",
    "fosco",
    "fossa",
    "fragata",
    "fralda",
    "frango",
    "frasco",
    "fraterno",
    "freira",
    "frente",
    "fretar",
    "frieza",
    "friso",
    "fritura",
    "fronha",
    "frustrar",
    "fruteira",
    "fugir",
    "fulano",
    "fuligem",
    "fundar",
    "fungo",
    "funil",
    "furador",
    "furioso",
    "futebol",
    "gabarito",
    "gabinete",
    "gado",
    "gaiato",
    "gaiola",
    "gaivota",
    "galega",
    "galho",
    "galinha",
    "galocha",
    "ganhar",
    "garagem",
    "garfo",
    "gargalo",
    "garimpo",
    "garoupa",
    "garrafa",
    "gasoduto",
    "gasto",
    "gata",
    "gatilho",
    "gaveta",
    "gazela",
    "gelado",
    "geleia",
    "gelo",
    "gemada",
    "gemer",
    "gemido",
    "generoso",
    "gengiva",
    "genial",
    "genoma",
    "genro",
    "geologia",
    "gerador",
    "germinar",
    "gesso",
    "gestor",
    "ginasta",
    "gincana",
    "gingado",
    "girafa",
    "girino",
    "glacial",
    "glicose",
    "global",
    "glorioso",
    "goela",
    "goiaba",
    "golfe",
    "golpear",
    "gordura",
    "gorjeta",
    "gorro",
    "gostoso",
    "goteira",
    "governar",
    "gracejo",
    "gradual",
    "grafite",
    "gralha",
    "grampo",
    "granada",
    "gratuito",
    "graveto",
    "graxa",
    "grego",
    "grelhar",
    "greve",
    "grilo",
    "grisalho",
    "gritaria",
    "grosso",
    "grotesco",
    "grudado",
    "grunhido",
    "gruta",
    "guache",
    "guarani",
    "guaxinim",
    "guerrear",
    "guiar",
    "guincho",
    "guisado",
    "gula",
    "guloso",
    "guru",
    "habitar",
    "harmonia",
    "haste",
    "haver",
    "hectare",
    "herdar",
    "heresia",
    "hesitar",
    "hiato",
    "hibernar",
    "hidratar",
    "hiena",
    "hino",
    "hipismo",
    "hipnose",
    "hipoteca",
    "hoje",
    "holofote",
    "homem",
    "honesto",
    "honrado",
    "hormonal",
    "hospedar",
    "humorado",
    "iate",
    "ideia",
    "idoso",
    "ignorado",
    "igreja",
    "iguana",
    "ileso",
    "ilha",
    "iludido",
    "iluminar",
    "ilustrar",
    "imagem",
    "imediato",
    "imenso",
    "imersivo",
    "iminente",
    "imitador",
    "imortal",
    "impacto",
    "impedir",
    "implante",
    "impor",
    "imprensa",
    "impune",
    "imunizar",
    "inalador",
    "inapto",
    "inativo",
    "incenso",
    "inchar",
    "incidir",
    "incluir",
    "incolor",
    "indeciso",
    "indireto",
    "indutor",
    "ineficaz",
    "inerente",
    "infantil",
    "infestar",
    "infinito",
    "inflamar",
    "informal",
    "infrator",
    "ingerir",
    "inibido",
    "inicial",
    "inimigo",
    "injetar",
    "inocente",
    "inodoro",
    "inovador",
    "inox",
    "inquieto",
    "inscrito",
    "inseto",
    "insistir",
    "inspetor",
    "instalar",
    "insulto",
    "intacto",
    "integral",
    "intimar",
    "intocado",
    "intriga",
    "invasor",
    "inverno",
    "invicto",
    "invocar",
    "iogurte",
    "iraniano",
    "ironizar",
    "irreal",
    "irritado",
    "isca",
    "isento",
    "isolado",
    "isqueiro",
    "italiano",
    "janeiro",
    "jangada",
    "janta",
    "jararaca",
    "jardim",
    "jarro",
    "jasmim",
    "jato",
    "javali",
    "jazida",
    "jejum",
    "joaninha",
    "joelhada",
    "jogador",
    "joia",
    "jornal",
    "jorrar",
    "jovem",
    "juba",
    "judeu",
    "judoca",
    "juiz",
    "julgador",
    "julho",
    "jurado",
    "jurista",
    "juro",
    "justa",
    "labareda",
    "laboral",
    "lacre",
    "lactante",
    "ladrilho",
    "lagarta",
    "lagoa",
    "laje",
    "lamber",
    "lamentar",
    "laminar",
    "lampejo",
    "lanche",
    "lapidar",
    "lapso",
    "laranja",
    "lareira",
    "largura",
    "lasanha",
    "lastro",
    "lateral",
    "latido",
    "lavanda",
    "lavoura",
    "lavrador",
    "laxante",
    "lazer",
    "lealdade",
    "lebre",
    "legado",
    "legendar",
    "legista",
    "leigo",
    "leiloar",
    "leitura",
    "lembrete",
    "leme",
    "lenhador",
    "lentilha",
    "leoa",
    "lesma",
    "leste",
    "letivo",
    "letreiro",
    "levar",
    "leveza",
    "levitar",
    "liberal",
    "libido",
    "liderar",
    "ligar",
    "ligeiro",
    "limitar",
    "limoeiro",
    "limpador",
    "linda",
    "linear",
    "linhagem",
    "liquidez",
    "listagem",
    "lisura",
    "litoral",
    "livro",
    "lixa",
    "lixeira",
    "locador",
    "locutor",
    "lojista",
    "lombo",
    "lona",
    "longe",
    "lontra",
    "lorde",
    "lotado",
    "loteria",
    "loucura",
    "lousa",
    "louvar",
    "luar",
    "lucidez",
    "lucro",
    "luneta",
    "lustre",
    "lutador",
    "luva",
    "macaco",
    "macete",
    "machado",
    "macio",
    "madeira",
    "madrinha",
    "magnata",
    "magreza",
    "maior",
    "mais",
    "malandro",
    "malha",
    "malote",
    "maluco",
    "mamilo",
    "mamoeiro",
    "mamute",
    "manada",
    "mancha",
    "mandato",
    "manequim",
    "manhoso",
    "manivela",
    "manobrar",
    "mansa",
    "manter",
    "manusear",
    "mapeado",
    "maquinar",
    "marcador",
    "maresia",
    "marfim",
    "margem",
    "marinho",
    "marmita",
    "maroto",
    "marquise",
    "marreco",
    "martelo",
    "marujo",
    "mascote",
    "masmorra",
    "massagem",
    "mastigar",
    "matagal",
    "materno",
    "matinal",
    "matutar",
    "maxilar",
    "medalha",
    "medida",
    "medusa",
    "megafone",
    "meiga",
    "melancia",
    "melhor",
    "membro",
    "memorial",
    "menino",
    "menos",
    "mensagem",
    "mental",
    "merecer",
    "mergulho",
    "mesada",
    "mesclar",
    "mesmo",
    "mesquita",
    "mestre",
    "metade",
    "meteoro",
    "metragem",
    "mexer",
    "mexicano",
    "micro",
    "migalha",
    "migrar",
    "milagre",
    "milenar",
    "milhar",
    "mimado",
    "minerar",
    "minhoca",
    "ministro",
    "minoria",
    "miolo",
    "mirante",
    "mirtilo",
    "misturar",
    "mocidade",
    "moderno",
    "modular",
    "moeda",
    "moer",
    "moinho",
    "moita",
    "moldura",
    "moleza",
    "molho",
    "molinete",
    "molusco",
    "montanha",
    "moqueca",
    "morango",
    "morcego",
    "mordomo",
    "morena",
    "mosaico",
    "mosquete",
    "mostarda",
    "motel",
    "motim",
    "moto",
    "motriz",
    "muda",
    "muito",
    "mulata",
    "mulher",
    "multar",
    "mundial",
    "munido",
    "muralha",
    "murcho",
    "muscular",
    "museu",
    "musical",
    "nacional",
    "nadador",
    "naja",
    "namoro",
    "narina",
    "narrado",
    "nascer",
    "nativa",
    "natureza",
    "navalha",
    "navegar",
    "navio",
    "neblina",
    "nebuloso",
    "negativa",
    "negociar",
    "negrito",
    "nervoso",
    "neta",
    "neural",
    "nevasca",
    "nevoeiro",
    "ninar",
    "ninho",
    "nitidez",
    "nivelar",
    "nobreza",
    "noite",
    "noiva",
    "nomear",
    "nominal",
    "nordeste",
    "nortear",
    "notar",
    "noticiar",
    "noturno",
    "novelo",
    "novilho",
    "novo",
    "nublado",
    "nudez",
    "numeral",
    "nupcial",
    "nutrir",
    "nuvem",
    "obcecado",
    "obedecer",
    "objetivo",
    "obrigado",
    "obscuro",
    "obstetra",
    "obter",
    "obturar",
    "ocidente",
    "ocioso",
    "ocorrer",
    "oculista",
    "ocupado",
    "ofegante",
    "ofensiva",
    "oferenda",
    "oficina",
    "ofuscado",
    "ogiva",
    "olaria",
    "oleoso",
    "olhar",
    "oliveira",
    "ombro",
    "omelete",
    "omisso",
    "omitir",
    "ondulado",
    "oneroso",
    "ontem",
    "opcional",
    "operador",
    "oponente",
    "oportuno",
    "oposto",
    "orar",
    "orbitar",
    "ordem",
    "ordinal",
    "orfanato",
    "orgasmo",
    "orgulho",
    "oriental",
    "origem",
    "oriundo",
    "orla",
    "ortodoxo",
    "orvalho",
    "oscilar",
    "ossada",
    "osso",
    "ostentar",
    "otimismo",
    "ousadia",
    "outono",
    "outubro",
    "ouvido",
    "ovelha",
    "ovular",
    "oxidar",
    "oxigenar",
    "pacato",
    "paciente",
    "pacote",
    "pactuar",
    "padaria",
    "padrinho",
    "pagar",
    "pagode",
    "painel",
    "pairar",
    "paisagem",
    "palavra",
    "palestra",
    "palheta",
    "palito",
    "palmada",
    "palpitar",
    "pancada",
    "panela",
    "panfleto",
    "panqueca",
    "pantanal",
    "papagaio",
    "papelada",
    "papiro",
    "parafina",
    "parcial",
    "pardal",
    "parede",
    "partida",
    "pasmo",
    "passado",
    "pastel",
    "patamar",
    "patente",
    "patinar",
    "patrono",
    "paulada",
    "pausar",
    "peculiar",
    "pedalar",
    "pedestre",
    "pediatra",
    "pedra",
    "pegada",
    "peitoral",
    "peixe",
    "pele",
    "pelicano",
    "penca",
    "pendurar",
    "peneira",
    "penhasco",
    "pensador",
    "pente",
    "perceber",
    "perfeito",
    "pergunta",
    "perito",
    "permitir",
    "perna",
    "perplexo",
    "persiana",
    "pertence",
    "peruca",
    "pescado",
    "pesquisa",
    "pessoa",
    "petiscar",
    "piada",
    "picado",
    "piedade",
    "pigmento",
    "pilastra",
    "pilhado",
    "pilotar",
    "pimenta",
    "pincel",
    "pinguim",
    "pinha",
    "pinote",
    "pintar",
    "pioneiro",
    "pipoca",
    "piquete",
    "piranha",
    "pires",
    "pirueta",
    "piscar",
    "pistola",
    "pitanga",
    "pivete",
    "planta",
    "plaqueta",
    "platina",
    "plebeu",
    "plumagem",
    "pluvial",
    "pneu",
    "poda",
    "poeira",
    "poetisa",
    "polegada",
    "policiar",
    "poluente",
    "polvilho",
    "pomar",
    "pomba",
    "ponderar",
    "pontaria",
    "populoso",
    "porta",
    "possuir",
    "postal",
    "pote",
    "poupar",
    "pouso",
    "povoar",
    "praia",
    "prancha",
    "prato",
    "praxe",
    "prece",
    "predador",
    "prefeito",
    "premiar",
    "prensar",
    "preparar",
    "presilha",
    "pretexto",
    "prevenir",
    "prezar",
    "primata",
    "princesa",
    "prisma",
    "privado",
    "processo",
    "produto",
    "profeta",
    "proibido",
    "projeto",
    "prometer",
    "propagar",
    "prosa",
    "protetor",
    "provador",
    "publicar",
    "pudim",
    "pular",
    "pulmonar",
    "pulseira",
    "punhal",
    "punir",
    "pupilo",
    "pureza",
    "puxador",
    "quadra",
    "quantia",
    "quarto",
    "quase",
    "quebrar",
    "queda",
    "queijo",
    "quente",
    "querido",
    "quimono",
    "quina",
    "quiosque",
    "rabanada",
    "rabisco",
    "rachar",
    "racionar",
    "radial",
    "raiar",
    "rainha",
    "raio",
    "raiva",
    "rajada",
    "ralado",
    "ramal",
    "ranger",
    "ranhura",
    "rapadura",
    "rapel",
    "rapidez",
    "raposa",
    "raquete",
    "raridade",
    "rasante",
    "rascunho",
    "rasgar",
    "raspador",
    "rasteira",
    "rasurar",
    "ratazana",
    "ratoeira",
    "realeza",
    "reanimar",
    "reaver",
    "rebaixar",
    "rebelde",
    "rebolar",
    "recado",
    "recente",
    "recheio",
    "recibo",
    "recordar",
    "recrutar",
    "recuar",
    "rede",
    "redimir",
    "redonda",
    "reduzida",
    "reenvio",
    "refinar",
    "refletir",
    "refogar",
    "refresco",
    "refugiar",
    "regalia",
    "regime",
    "regra",
    "reinado",
    "reitor",
    "rejeitar",
    "relativo",
    "remador",
    "remendo",
    "remorso",
    "renovado",
    "reparo",
    "repelir",
    "repleto",
    "repolho",
    "represa",
    "repudiar",
    "requerer",
    "resenha",
    "resfriar",
    "resgatar",
    "residir",
    "resolver",
    "respeito",
    "ressaca",
    "restante",
    "resumir",
    "retalho",
    "reter",
    "retirar",
    "retomada",
    "retratar",
    "revelar",
    "revisor",
    "revolta",
    "riacho",
    "rica",
    "rigidez",
    "rigoroso",
    "rimar",
    "ringue",
    "risada",
    "risco",
    "risonho",
    "robalo",
    "rochedo",
    "rodada",
    "rodeio",
    "rodovia",
    "roedor",
    "roleta",
    "romano",
    "roncar",
    "rosado",
    "roseira",
    "rosto",
    "rota",
    "roteiro",
    "rotina",
    "rotular",
    "rouco",
    "roupa",
    "roxo",
    "rubro",
    "rugido",
    "rugoso",
    "ruivo",
    "rumo",
    "rupestre",
    "russo",
    "sabor",
    "saciar",
    "sacola",
    "sacudir",
    "sadio",
    "safira",
    "saga",
    "sagrada",
    "saibro",
    "salada",
    "saleiro",
    "salgado",
    "saliva",
    "salpicar",
    "salsicha",
    "saltar",
    "salvador",
    "sambar",
    "samurai",
    "sanar",
    "sanfona",
    "sangue",
    "sanidade",
    "sapato",
    "sarda",
    "sargento",
    "sarjeta",
    "saturar",
    "saudade",
    "saxofone",
    "sazonal",
    "secar",
    "secular",
    "seda",
    "sedento",
    "sediado",
    "sedoso",
    "sedutor",
    "segmento",
    "segredo",
    "segundo",
    "seiva",
    "seleto",
    "selvagem",
    "semanal",
    "semente",
    "senador",
    "senhor",
    "sensual",
    "sentado",
    "separado",
    "sereia",
    "seringa",
    "serra",
    "servo",
    "setembro",
    "setor",
    "sigilo",
    "silhueta",
    "silicone",
    "simetria",
    "simpatia",
    "simular",
    "sinal",
    "sincero",
    "singular",
    "sinopse",
    "sintonia",
    "sirene",
    "siri",
    "situado",
    "soberano",
    "sobra",
    "socorro",
    "sogro",
    "soja",
    "solda",
    "soletrar",
    "solteiro",
    "sombrio",
    "sonata",
    "sondar",
    "sonegar",
    "sonhador",
    "sono",
    "soprano",
    "soquete",
    "sorrir",
    "sorteio",
    "sossego",
    "sotaque",
    "soterrar",
    "sovado",
    "sozinho",
    "suavizar",
    "subida",
    "submerso",
    "subsolo",
    "subtrair",
    "sucata",
    "sucesso",
    "suco",
    "sudeste",
    "sufixo",
    "sugador",
    "sugerir",
    "sujeito",
    "sulfato",
    "sumir",
    "suor",
    "superior",
    "suplicar",
    "suposto",
    "suprimir",
    "surdina",
    "surfista",
    "surpresa",
    "surreal",
    "surtir",
    "suspiro",
    "sustento",
    "tabela",
    "tablete",
    "tabuada",
    "tacho",
    "tagarela",
    "talher",
    "talo",
    "talvez",
    "tamanho",
    "tamborim",
    "tampa",
    "tangente",
    "tanto",
    "tapar",
    "tapioca",
    "tardio",
    "tarefa",
    "tarja",
    "tarraxa",
    "tatuagem",
    "taurino",
    "taxativo",
    "taxista",
    "teatral",
    "tecer",
    "tecido",
    "teclado",
    "tedioso",
    "teia",
    "teimar",
    "telefone",
    "telhado",
    "tempero",
    "tenente",
    "tensor",
    "tentar",
    "termal",
    "terno",
    "terreno",
    "tese",
    "tesoura",
    "testado",
    "teto",
    "textura",
    "texugo",
    "tiara",
    "tigela",
    "tijolo",
    "timbrar",
    "timidez",
    "tingido",
    "tinteiro",
    "tiragem",
    "titular",
    "toalha",
    "tocha",
    "tolerar",
    "tolice",
    "tomada",
    "tomilho",
    "tonel",
    "tontura",
    "topete",
    "tora",
    "torcido",
    "torneio",
    "torque",
    "torrada",
    "torto",
    "tostar",
    "touca",
    "toupeira",
    "toxina",
    "trabalho",
    "tracejar",
    "tradutor",
    "trafegar",
    "trajeto",
    "trama",
    "trancar",
    "trapo",
    "traseiro",
    "tratador",
    "travar",
    "treino",
    "tremer",
    "trepidar",
    "trevo",
    "triagem",
    "tribo",
    "triciclo",
    "tridente",
    "trilogia",
    "trindade",
    "triplo",
    "triturar",
    "triunfal",
    "trocar",
    "trombeta",
    "trova",
    "trunfo",
    "truque",
    "tubular",
    "tucano",
    "tudo",
    "tulipa",
    "tupi",
    "turbo",
    "turma",
    "turquesa",
    "tutelar",
    "tutorial",
    "uivar",
    "umbigo",
    "unha",
    "unidade",
    "uniforme",
    "urologia",
    "urso",
    "urtiga",
    "urubu",
    "usado",
    "usina",
    "usufruir",
    "vacina",
    "vadiar",
    "vagaroso",
    "vaidoso",
    "vala",
    "valente",
    "validade",
    "valores",
    "vantagem",
    "vaqueiro",
    "varanda",
    "vareta",
    "varrer",
    "vascular",
    "vasilha",
    "vassoura",
    "vazar",
    "vazio",
    "veado",
    "vedar",
    "vegetar",
    "veicular",
    "veleiro",
    "velhice",
    "veludo",
    "vencedor",
    "vendaval",
    "venerar",
    "ventre",
    "verbal",
    "verdade",
    "vereador",
    "vergonha",
    "vermelho",
    "verniz",
    "versar",
    "vertente",
    "vespa",
    "vestido",
    "vetorial",
    "viaduto",
    "viagem",
    "viajar",
    "viatura",
    "vibrador",
    "videira",
    "vidraria",
    "viela",
    "viga",
    "vigente",
    "vigiar",
    "vigorar",
    "vilarejo",
    "vinco",
    "vinheta",
    "vinil",
    "violeta",
    "virada",
    "virtude",
    "visitar",
    "visto",
    "vitral",
    "viveiro",
    "vizinho",
    "voador",
    "voar",
    "vogal",
    "volante",
    "voleibol",
    "voltagem",
    "volumoso",
    "vontade",
    "vulto",
    "vuvuzela",
    "xadrez",
    "xarope",
    "xeque",
    "xeretar",
    "xerife",
    "xingar",
    "zangado",
    "zarpar",
    "zebu",
    "zelador",
    "zombar",
    "zoologia",
    "zumbido"
], sre = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];
Object.defineProperty(Zi, "__esModule", {
    value: !0
});
const Uo = {};
Zi.wordlists = Uo;
let Tn;
var Ta = Zi._default = Tn;
try {
    Ta = Zi._default = Tn = Xte, Uo.czech = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = Jte, Uo.chinese_simplified = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = Qte, Uo.chinese_traditional = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = ere, Uo.korean = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = tre, Uo.french = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = rre, Uo.italian = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = nre, Uo.spanish = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = ire, Uo.japanese = Tn, Uo.JA = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = ore, Uo.portuguese = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = sre, Uo.english = Tn, Uo.EN = Tn;
} catch  {}
Object.defineProperty(Aa, "__esModule", {
    value: !0
});
const are = us, zP = oi, jP = Kb, cre = Hr, lm = Zi;
let fp = lm._default;
const Tk = "Invalid mnemonic", pf = "Invalid entropy", ure = "Invalid mnemonic checksum", HP = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function lp(e) {
    return (e || "").normalize("NFKD");
}
function qP(e, t, r) {
    for(; e.length < r;)e = t + e;
    return e;
}
function KP(e) {
    return parseInt(e, 2);
}
function WP(e) {
    return e.map((t)=>qP(t.toString(2), "0", 8)).join("");
}
function VP(e) {
    const r = e.length * 8 / 32, n = are.sha256(Uint8Array.from(e));
    return WP(Array.from(n)).slice(0, r);
}
function GP(e) {
    return "mnemonic" + (e || "");
}
function fre(e, t) {
    const r = Uint8Array.from(We.from(lp(e), "utf8")), n = Uint8Array.from(We.from(GP(lp(t)), "utf8")), i = jP.pbkdf2(zP.sha512, r, n, {
        c: 2048,
        dkLen: 64
    });
    return We.from(i);
}
Aa.mnemonicToSeedSync = fre;
function lre(e, t) {
    const r = Uint8Array.from(We.from(lp(e), "utf8")), n = Uint8Array.from(We.from(GP(lp(t)), "utf8"));
    return jP.pbkdf2Async(zP.sha512, r, n, {
        c: 2048,
        dkLen: 64
    }).then((i)=>We.from(i));
}
var dre = Aa.mnemonicToSeed = lre;
function ZP(e, t) {
    if (t = t || fp, !t) throw new Error(HP);
    const r = lp(e).split(" ");
    if (r.length % 3 !== 0) throw new Error(Tk);
    const n = r.map((c)=>{
        const l = t.indexOf(c);
        if (l === -1) throw new Error(Tk);
        return qP(l.toString(2), "0", 11);
    }).join(""), i = Math.floor(n.length / 33) * 32, o = n.slice(0, i), s = n.slice(i), a = o.match(/(.{1,8})/g).map(KP);
    if (a.length < 16) throw new Error(pf);
    if (a.length > 32) throw new Error(pf);
    if (a.length % 4 !== 0) throw new Error(pf);
    const u = We.from(a);
    if (VP(u) !== s) throw new Error(ure);
    return u.toString("hex");
}
Aa.mnemonicToEntropy = ZP;
function YP(e, t) {
    if (We.isBuffer(e) || (e = We.from(e, "hex")), t = t || fp, !t) throw new Error(HP);
    if (e.length < 16) throw new TypeError(pf);
    if (e.length > 32) throw new TypeError(pf);
    if (e.length % 4 !== 0) throw new TypeError(pf);
    const r = WP(Array.from(e)), n = VP(e), s = (r + n).match(/(.{1,11})/g).map((a)=>{
        const u = KP(a);
        return t[u];
    });
    return t[0] === "あいこくしん" ? s.join("　") : s.join(" ");
}
var hre = Aa.entropyToMnemonic = YP;
function pre(e, t, r) {
    if (e = e || 128, e % 32 !== 0) throw new TypeError(pf);
    return t = t || ((n)=>We.from(cre.randomBytes(n))), YP(t(e / 8), r);
}
Aa.generateMnemonic = pre;
function gre(e, t) {
    try {
        ZP(e, t);
    } catch  {
        return !1;
    }
    return !0;
}
Aa.validateMnemonic = gre;
function yre(e) {
    const t = lm.wordlists[e];
    if (t) fp = t;
    else throw new Error('Could not find wordlist for language "' + e + '"');
}
Aa.setDefaultWordlist = yre;
function mre() {
    if (!fp) throw new Error("No Default Wordlist set");
    return Object.keys(lm.wordlists).filter((e)=>e === "JA" || e === "EN" ? !1 : lm.wordlists[e].every((t, r)=>t === fp[r]))[0];
}
Aa.getDefaultWordlist = mre;
var bre = Zi;
Aa.wordlists = bre.wordlists;
let XP = class extends e7 {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, bq(t);
        const n = t3(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen, o = new Uint8Array(i);
        o.set(n.length > i ? t.create().update(n).digest() : n);
        for(let s = 0; s < o.length; s++)o[s] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let s = 0; s < o.length; s++)o[s] ^= 106;
        this.oHash.update(o), hu(o);
    }
    update(t) {
        return Zy(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        Zy(this), cb(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const JP = (e, t, r)=>new XP(e, t).update(r).digest();
JP.create = (e, t)=>new XP(e, t);
const wre = Wq;
function vre(e) {
    return s7(pi(e));
}
function kk(e, t) {
    return JP(wre, e, t);
}
const yr = (e)=>aK(e);
function _re(e) {
    if (Wn(e.isPoint(yr("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Wn(!e.isPoint(yr("030000000000000000000000000000000000000000000000000000000000000005"))), Wn(e.isPrivate(yr("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Wn(e.isPrivate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), Wn(!e.isPrivate(yr("0000000000000000000000000000000000000000000000000000000000000000"))), Wn(!e.isPrivate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), Wn(!e.isPrivate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), Wn(ja(e.pointFromScalar(yr("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), yr("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
        Wn(e.xOnlyPointAddTweak(yr("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
        let t = e.xOnlyPointAddTweak(yr("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), yr("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
        Wn(ja(t.xOnlyPubkey, yr("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(yr("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), yr("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    Wn(ja(e.pointAddScalar(yr("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), yr("0000000000000000000000000000000000000000000000000000000000000003")), yr("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), Wn(ja(e.privateAdd(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), yr("0000000000000000000000000000000000000000000000000000000000000002")), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (Wn(ja(e.privateNegate(yr("0000000000000000000000000000000000000000000000000000000000000001")), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), Wn(ja(e.privateNegate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), yr("0000000000000000000000000000000000000000000000000000000000000003")) === 0), Wn(ja(e.privateNegate(yr("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), yr("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), Wn(ja(e.sign(yr("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), yr("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), Wn(e.verify(yr("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), yr("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), yr("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && Wn(ja(e.signSchnorr(yr("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), yr("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), yr("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), yr("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && Wn(e.verifySchnorr(yr("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), yr("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), yr("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function Wn(e) {
    if (!e) throw new Error("ecc library invalid");
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function VE(e) {
    return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function QP(e, t) {
    return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((r)=>typeof r == "string") : t.every((r)=>Number.isSafeInteger(r)) : !1;
}
function Ere(e) {
    if (typeof e != "function") throw new Error("function expected");
    return !0;
}
function GE(e, t) {
    if (typeof t != "string") throw new Error(`${e}: string expected`);
    return !0;
}
function Q3(e) {
    if (!Number.isSafeInteger(e)) throw new Error(`invalid integer: ${e}`);
}
function ZE(e) {
    if (!Array.isArray(e)) throw new Error("array expected");
}
function eN(e, t) {
    if (!QP(!0, t)) throw new Error(`${e}: array of strings expected`);
}
function xre(e, t) {
    if (!QP(!1, t)) throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function tN(...e) {
    const t = (o)=>o, r = (o, s)=>(a)=>o(s(a)), n = e.map((o)=>o.encode).reduceRight(r, t), i = e.map((o)=>o.decode).reduce(r, t);
    return {
        encode: n,
        decode: i
    };
}
// @__NO_SIDE_EFFECTS__
function Sre(e) {
    const t = typeof e == "string" ? e.split("") : e, r = t.length;
    eN("alphabet", t);
    const n = new Map(t.map((i, o)=>[
            i,
            o
        ]));
    return {
        encode: (i)=>(ZE(i), i.map((o)=>{
                if (!Number.isSafeInteger(o) || o < 0 || o >= r) throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);
                return t[o];
            })),
        decode: (i)=>(ZE(i), i.map((o)=>{
                GE("alphabet.decode", o);
                const s = n.get(o);
                if (s === void 0) throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);
                return s;
            }))
    };
}
// @__NO_SIDE_EFFECTS__
function Are(e = "") {
    return GE("join", e), {
        encode: (t)=>(eN("join.decode", t), t.join(e)),
        decode: (t)=>(GE("join.decode", t), t.split(e))
    };
}
function Ik(e, t, r) {
    if (t < 2) throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
    if (ZE(e), !e.length) return [];
    let n = 0;
    const i = [], o = Array.from(e, (a)=>{
        if (Q3(a), a < 0 || a >= t) throw new Error(`invalid integer: ${a}`);
        return a;
    }), s = o.length;
    for(;;){
        let a = 0, u = !0;
        for(let f = n; f < s; f++){
            const c = o[f], l = t * a, p = l + c;
            if (!Number.isSafeInteger(p) || l / t !== a || p - c !== l) throw new Error("convertRadix: carry overflow");
            const y = p / r;
            a = p % r;
            const _ = Math.floor(y);
            if (o[f] = _, !Number.isSafeInteger(_) || _ * r + a !== p) throw new Error("convertRadix: carry overflow");
            if (u) _ ? u = !1 : n = f;
            else continue;
        }
        if (i.push(a), u) break;
    }
    for(let a = 0; a < e.length - 1 && e[a] === 0; a++)i.push(0);
    return i.reverse();
}
// @__NO_SIDE_EFFECTS__
function Tre(e) {
    Q3(e);
    const t = 2 ** 8;
    return {
        encode: (r)=>{
            if (!VE(r)) throw new Error("radix.encode input should be Uint8Array");
            return Ik(Array.from(r), t, e);
        },
        decode: (r)=>(xre("radix.decode", r), Uint8Array.from(Ik(r, e, t)))
    };
}
function kre(e, t) {
    return Q3(e), Ere(t), {
        encode (r) {
            if (!VE(r)) throw new Error("checksum.encode: input should be Uint8Array");
            const n = t(r).slice(0, e), i = new Uint8Array(r.length + e);
            return i.set(r), i.set(n, r.length), i;
        },
        decode (r) {
            if (!VE(r)) throw new Error("checksum.decode: input should be Uint8Array");
            const n = r.slice(0, -e), i = r.slice(-e), o = t(n).slice(0, e);
            for(let s = 0; s < e; s++)if (o[s] !== i[s]) throw new Error("Invalid checksum");
            return n;
        }
    };
}
const Ire = /* @__NO_SIDE_EFFECTS__ */ (e)=>/* @__PURE__ */ tN(/* @__PURE__ */ Tre(58), /* @__PURE__ */ Sre(e), /* @__PURE__ */ Are("")), Bre = /* @__PURE__ */ Ire("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Ore = (e)=>/* @__PURE__ */ tN(kre(4, (t)=>e(e(t))), Bre), Pre = Ore;
var Ha;
function Nre(e) {
    return {
        lang: (e == null ? void 0 : e.lang) ?? (Ha == null ? void 0 : Ha.lang),
        message: e == null ? void 0 : e.message,
        abortEarly: (e == null ? void 0 : e.abortEarly) ?? (Ha == null ? void 0 : Ha.abortEarly),
        abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (Ha == null ? void 0 : Ha.abortPipeEarly)
    };
}
var b_;
function Mre(e) {
    return b_ == null ? void 0 : b_.get(e);
}
var w_;
function Rre(e) {
    return w_ == null ? void 0 : w_.get(e);
}
var v_;
function Cre(e, t) {
    var r;
    return (r = v_ == null ? void 0 : v_.get(e)) == null ? void 0 : r.get(t);
}
function dp(e) {
    var r, n;
    const t = typeof e;
    return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function mc(e, t, r, n, i) {
    const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? dp(o), u = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: s,
        received: a,
        message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
        // @ts-expect-error
        requirement: e.requirement,
        path: i == null ? void 0 : i.path,
        issues: i == null ? void 0 : i.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, f = e.kind === "schema", c = (i == null ? void 0 : i.message) ?? // @ts-expect-error
    e.message ?? Cre(e.reference, u.lang) ?? (f ? Rre(u.lang) : null) ?? n.message ?? Mre(u.lang);
    c && (u.message = typeof c == "function" ? c(u) : c), f && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [
        u
    ];
}
var Ure = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(t){
        super(t[0].message);
        /**
     * The error issues.
     */ pt(this, "issues");
        this.name = "ValiError", this.issues = t;
    }
};
function Wb(e) {
    return {
        kind: "validation",
        type: "integer",
        reference: Wb,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run (t, r) {
            return t.typed && !this.requirement(t.value) && mc(this, "integer", t, r), t;
        }
    };
}
function eS(e, t) {
    return {
        kind: "validation",
        type: "length",
        reference: eS,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length !== this.requirement && mc(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function Vb(e, t) {
    return {
        kind: "validation",
        type: "max_value",
        reference: Vb,
        async: !1,
        expects: `<=${e instanceof Date ? e.toJSON() : dp(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value > this.requirement && mc(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : dp(r.value)
            }), r;
        }
    };
}
function Gb(e, t) {
    return {
        kind: "validation",
        type: "min_value",
        reference: Gb,
        async: !1,
        expects: `>=${e instanceof Date ? e.toJSON() : dp(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value < this.requirement && mc(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : dp(r.value)
            }), r;
        }
    };
}
function rN(e, t) {
    return {
        kind: "validation",
        type: "regex",
        reference: rN,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement.test(r.value) && mc(this, "format", r, n), r;
        }
    };
}
function Zb(e, t) {
    return {
        kind: "schema",
        type: "instance",
        reference: Zb,
        expects: e.name,
        async: !1,
        class: e,
        message: t,
        _run (r, n) {
            return r.value instanceof this.class ? r.typed = !0 : mc(this, "type", r, n), r;
        }
    };
}
function Yb(e) {
    return {
        kind: "schema",
        type: "number",
        reference: Yb,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : mc(this, "type", t, r), t;
        }
    };
}
function YE(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: YE,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
            } else mc(this, "type", r, n);
            return r;
        }
    };
}
function nN(e) {
    return {
        kind: "schema",
        type: "string",
        reference: nN,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : mc(this, "type", t, r), t;
        }
    };
}
function qa(e, t, r) {
    const n = e._run({
        typed: !1,
        value: t
    }, Nre(r));
    if (n.issues) throw new Ure(n.issues);
    return n.value;
}
function Pd(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
const XE = Pd(Yb(), Wb(), Gb(0), Vb(4294967295)), $re = Pd(Yb(), Wb(), Gb(0), Vb(2147483647)), Lre = Pd(Yb(), Wb(), Gb(0), Vb(255)), __ = Pd(Zb(Uint8Array), eS(32)), Dre = Pd(Zb(Uint8Array), eS(33)), Fre = YE({
    wif: Lre,
    bip32: YE({
        public: XE,
        private: XE
    })
}), zre = Pd(nN(), rN(/^(m\/)?(\d+'?\/)*\d+'?$/));
function jre(e, t, r) {
    if (t.length !== 32) throw new TypeError("Invalid privateKey length");
    var n = new Uint8Array(34), i = new DataView(n.buffer);
    return i.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function Hre(e) {
    return Ql.encode(jre(e.version, e.privateKey));
}
const Bk = Pre(pi), Ok = {
    encode: (e)=>Bk.encode(e),
    decode: (e)=>Bk.decode(e)
};
function qre(e) {
    _re(e);
    const t = {
        messagePrefix: `Bitcoin Signed Message:
`,
        bech32: "bc",
        bip32: {
            public: 76067358,
            private: 76066276
        },
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
    }, r = 2147483648;
    function n(p) {
        return p.length === 32 ? p : p.slice(1, 33);
    }
    class i {
        constructor(y, _){
            pt(this, "__D");
            pt(this, "__Q");
            pt(this, "lowR", !1);
            this.__D = y, this.__Q = _;
        }
        get publicKey() {
            return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, !0)), this.__Q;
        }
        get privateKey() {
            return this.__D;
        }
        sign(y, _) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (_ === void 0 && (_ = this.lowR), _ === !1) return e.sign(y, this.privateKey);
            {
                let A = e.sign(y, this.privateKey);
                const O = new Uint8Array(32);
                let N = 0;
                for(; A[0] > 127;)N++, Zu(O, 0, N, "LE"), A = e.sign(y, this.privateKey, O);
                return A;
            }
        }
        signSchnorr(y) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (!e.signSchnorr) throw new Error("signSchnorr not supported by ecc library");
            return e.signSchnorr(y, this.privateKey);
        }
        verify(y, _) {
            return e.verify(y, this.publicKey, _);
        }
        verifySchnorr(y, _) {
            if (!e.verifySchnorr) throw new Error("verifySchnorr not supported by ecc library");
            return e.verifySchnorr(y, this.publicKey.subarray(1, 33), _);
        }
    }
    class o extends i {
        constructor(_, A, O, N, U = 0, D = 0, H = 0){
            super(_, A);
            pt(this, "chainCode");
            pt(this, "network");
            pt(this, "__DEPTH");
            pt(this, "__INDEX");
            pt(this, "__PARENT_FINGERPRINT");
            this.chainCode = O, this.network = N, this.__DEPTH = U, this.__INDEX = D, this.__PARENT_FINGERPRINT = H, qa(Fre, N);
        }
        get depth() {
            return this.__DEPTH;
        }
        get index() {
            return this.__INDEX;
        }
        get parentFingerprint() {
            return this.__PARENT_FINGERPRINT;
        }
        get identifier() {
            return vre(this.publicKey);
        }
        get fingerprint() {
            return this.identifier.slice(0, 4);
        }
        get compressed() {
            return !0;
        }
        // Private === not neutered
        // Public === neutered
        isNeutered() {
            return this.__D === void 0;
        }
        neutered() {
            return c(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
        }
        toBase58() {
            const _ = this.network, A = this.isNeutered() ? _.bip32.public : _.bip32.private, O = new Uint8Array(78);
            return Zu(O, 0, A, "BE"), W4(O, 4, this.depth), Zu(O, 5, this.parentFingerprint, "BE"), Zu(O, 9, this.index, "BE"), O.set(this.chainCode, 13), this.isNeutered() ? O.set(this.publicKey, 45) : (W4(O, 45, 0), O.set(this.privateKey, 46)), Ok.encode(O);
        }
        toWIF() {
            if (!this.privateKey) throw new TypeError("Missing private key");
            return Hre({
                version: this.network.wif,
                privateKey: this.privateKey
            });
        }
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
        derive(_) {
            qa(XE, _);
            const A = _ >= r, O = new Uint8Array(37);
            if (A) {
                if (this.isNeutered()) throw new TypeError("Missing private key for hardened child key");
                O[0] = 0, O.set(this.privateKey, 1), Zu(O, 33, _, "BE");
            } else O.set(this.publicKey, 0), Zu(O, 33, _, "BE");
            const N = kk(this.chainCode, O), U = N.slice(0, 32), D = N.slice(32);
            if (!e.isPrivate(U)) return this.derive(_ + 1);
            let H;
            if (this.isNeutered()) {
                const K = e.pointAddScalar(this.publicKey, U, !0);
                if (K === null) return this.derive(_ + 1);
                H = c(K, D, this.network, this.depth + 1, _, xl(this.fingerprint, 0, "BE"));
            } else {
                const K = e.privateAdd(this.privateKey, U);
                if (K == null) return this.derive(_ + 1);
                H = u(K, D, this.network, this.depth + 1, _, xl(this.fingerprint, 0, "BE"));
            }
            return H;
        }
        deriveHardened(_) {
            if (typeof qa($re, _) == "number") return this.derive(_ + r);
            throw new TypeError("Expected UInt31, got " + _);
        }
        derivePath(_) {
            qa(zre, _);
            let A = _.split("/");
            if (A[0] === "m") {
                if (this.parentFingerprint) throw new TypeError("Expected master, got child");
                A = A.slice(1);
            }
            return A.reduce((O, N)=>{
                let U;
                return N.slice(-1) === "'" ? (U = parseInt(N.slice(0, -1), 10), O.deriveHardened(U)) : (U = parseInt(N, 10), O.derive(U));
            }, this);
        }
        tweak(_) {
            return this.privateKey ? this.tweakFromPrivateKey(_) : this.tweakFromPublicKey(_);
        }
        tweakFromPublicKey(_) {
            const A = n(this.publicKey);
            if (!e.xOnlyPointAddTweak) throw new Error("xOnlyPointAddTweak not supported by ecc library");
            const O = e.xOnlyPointAddTweak(A, _);
            if (!O || O.xOnlyPubkey === null) throw new Error("Cannot tweak public key!");
            const N = Uint8Array.from([
                O.parity === 0 ? 2 : 3
            ]), U = sK([
                N,
                O.xOnlyPubkey
            ]);
            return new i(void 0, U);
        }
        tweakFromPrivateKey(_) {
            const A = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, O = (()=>{
                if (A) {
                    if (e.privateNegate) return e.privateNegate(this.privateKey);
                    throw new Error("privateNegate not supported by ecc library");
                } else return this.privateKey;
            })(), N = e.privateAdd(O, _);
            if (!N) throw new Error("Invalid tweaked private key!");
            return new i(N, void 0);
        }
    }
    function s(p, y) {
        const _ = Ok.decode(p);
        if (_.length !== 78) throw new TypeError("Invalid buffer length");
        y = y || t;
        const A = xl(_, 0, "BE");
        if (A !== y.bip32.private && A !== y.bip32.public) throw new TypeError("Invalid network version");
        const O = _[4], N = xl(_, 5, "BE");
        if (O === 0 && N !== 0) throw new TypeError("Invalid parent fingerprint");
        const U = xl(_, 9, "BE");
        if (O === 0 && U !== 0) throw new TypeError("Invalid index");
        const D = _.slice(13, 45);
        let H;
        if (A === y.bip32.private) {
            if (_[45] !== 0) throw new TypeError("Invalid private key");
            const K = _.slice(46, 78);
            H = u(K, D, y, O, U, N);
        } else {
            const K = _.slice(45, 78);
            H = c(K, D, y, O, U, N);
        }
        return H;
    }
    function a(p, y, _) {
        return u(p, y, _);
    }
    function u(p, y, _, A, O, N) {
        if (qa(__, p), qa(__, y), _ = _ || t, !e.isPrivate(p)) throw new TypeError("Private key not in range [1, n)");
        return new o(p, void 0, y, _, A, O, N);
    }
    function f(p, y, _) {
        return c(p, y, _);
    }
    function c(p, y, _, A, O, N) {
        if (qa(Dre, p), qa(__, y), _ = _ || t, !e.isPoint(p)) throw new TypeError("Point is not on the curve");
        return new o(void 0, p, y, _, A, O, N);
    }
    function l(p, y) {
        if (qa(Zb(Uint8Array), p), p.length < 16) throw new TypeError("Seed should be at least 128 bits");
        if (p.length > 64) throw new TypeError("Seed should be at most 512 bits");
        y = y || t;
        const _ = kk(oK("Bitcoin seed"), p), A = _.slice(0, 32), O = _.slice(32);
        return a(A, O, y);
    }
    return {
        fromSeed: l,
        fromBase58: s,
        fromPublicKey: f,
        fromPrivateKey: a
    };
}
const Rve = "text/html", Cve = "text/css", Kre = "text/plain", Uve = "text/javascript", $ve = "text/markdown", Lve = "application/json", Dve = "application/javascript", Fve = "application/xml", zve = "application/pdf", jve = "application/zip", Hve = "application/gzip", qve = "application/xhtml+xml", Kve = "application/rss+xml", Wve = "application/atom+xml", Vve = "application/x-www-form-urlencoded", Gve = "application/octet-stream", Zve = "image/jpeg", Yve = "image/png", Xve = "image/gif", Jve = "image/svg+xml", Qve = "image/webp", e2e = "image/x-icon", t2e = "video/mp4", r2e = "video/webm", n2e = "video/ogg", i2e = "audio/mpeg", o2e = "audio/wav", s2e = "audio/ogg", a2e = "multipart/form-data", Pk = "btc", Nk = "brc20", Mk = "runes", Rk = "alkanes", Xb = "bip322", f0 = "ecdsa", l0 = "bip322-simple", iN = async (e = ln)=>await rn.get(`${Bi(e)}/api/v1/fees/recommended`, {
        headers: {
            "Content-Type": "application/json"
        }
    }).then((t)=>t.data), Wre = qre(bb);
o3(bb);
async function Vre(e) {
    const t = crypto.getRandomValues(new Uint8Array(32)), r = hre(We.from(t)), n = await dre(r);
    return Wre.fromSeed(n, Dr(e)).derivePath("m/44'/0'/0'/0/0").privateKey;
}
const Jb = (e, t)=>{
    try {
        const r = Dr(t), n = _7(e);
        if (n.version === r.pubKeyHash) return uG;
        if (n.version === r.scriptHash) {
            const i = Sn(n.hash);
            return i && i.length === 2 && i[0] === Kr.OP_0 ? fG : Xp;
        }
    } catch  {
        try {
            const r = a3(e);
            if (r.version === 0 && r.data.length === 20) return Ay;
            if (r.version === 0 && r.data.length === 32) return lG;
            if (r.version === 1 && r.data.length === 32) return df;
        } catch  {
            return "unknown";
        }
    }
    return "unknown";
}, Gre = (e, t)=>{
    const r = Dr(t);
    return hs(e, r);
};
function oN(e, t) {
    const r = Dr(t);
    return hs(e, r);
}
function d0(e, t) {
    var i;
    const r = Gp({
        pubkey: We.from(e, "hex"),
        network: Dr(t)
    }), n = _d({
        redeem: r,
        network: Dr(t)
    });
    return (i = n == null ? void 0 : n.redeem) == null ? void 0 : i.output;
}
function di(e, t, r) {
    var n;
    if (!e || typeof e != "object") return r;
    for (const i of t)if (e[i] !== void 0) return ((n = e[i]) == null ? void 0 : n.toString()) || r;
    return r;
}
function Yg(e, t, r) {
    if (!e || typeof e != "object") return r;
    for (const n of t)if (e[n] !== void 0) {
        const i = Number(e[n]);
        return isNaN(i) ? r : i;
    }
    return r;
}
function Kl(e, t = "unknown", r) {
    var _, A;
    if (!e) return console.warn(`Invalid inscription data from source: ${t}`), {
        id: "",
        inscriptionId: "",
        content: "",
        number: 0,
        address: "",
        contentType: "unknown",
        output: "",
        location: "",
        preview: "",
        genesisTransaction: "",
        height: 0,
        outputValue: 0
    };
    const n = di(e, [
        "id",
        "inscription_id",
        "inscriptionId"
    ], ""), i = Yg(e, [
        "num",
        "number",
        "inscriptionNumber"
    ], 0), o = di(e, [
        "address",
        "owner",
        "ownerAddress"
    ], ""), s = di(e, [
        "content_type",
        "contentType",
        "mime",
        "mimeType"
    ], "unknown");
    let a = di(e, [
        "utxo_txid",
        "txid",
        "transaction_id"
    ], ""), u = Yg(e, [
        "vout",
        "utxo_vout"
    ], 0), f = di(e, [
        "output"
    ], "");
    f || a && (f = `${a}:${u}`), f && (!a || !u) && (console.warn(`Invalid inscription location from source: ${t}`), a = f.split(":")[0], u = Number.parseInt(f.split(":")[1]));
    const c = Yg(e, [
        "output_value",
        "value",
        "outputValue",
        "postage",
        "satoshis"
    ], 0), l = Yg(e, [
        "height",
        "block_height"
    ], 0);
    let p = di(e, [
        "genesis_tx_id",
        "genesisTx",
        "genesis_txid",
        "genesisTransaction"
    ], ((A = (_ = e.inscription_id) == null ? void 0 : _.split("i")) == null ? void 0 : A[0]) || e.txid || "");
    const y = e.utxo_sat_offset !== void 0 ? e.utxo_sat_offset : 0;
    if (!n) throw console.warn(`Invalid inscription data from source: ${t}`), new Error(`Invalid inscription data from source: ${t}`);
    if (!o) throw console.warn(`Invalid inscription address from source: ${t}`), new Error(`Invalid inscription address from source: ${t}`);
    if (!f) throw console.warn(`Invalid inscription output from source: ${t}`), new Error(`Invalid inscription output from source: ${t}`);
    if (!s) throw console.warn(`Invalid inscription content type from source: ${t}`), new Error(`Invalid inscription content type from source: ${t}`);
    return p || (p = n.split("i")[0]), {
        address: o,
        id: n,
        inscriptionId: n,
        number: i,
        outputValue: c,
        contentType: s,
        output: f,
        location: `${a}:${u}:${y}`,
        content: `${Wte(r)}/${n}`,
        preview: `${Vte(r)}/${n}`,
        genesisTransaction: p,
        height: l,
        offset: y
    };
}
function Zre(e, t = "unknown") {
    const r = [];
    if (!e) return console.warn(`Invalid BRC20 balance data from source: ${t}`), r;
    if (e.data && typeof e.data == "object") return Object.entries(e.data).forEach(([n, i])=>{
        const o = di(i, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), s = di(i, [
            "transferable",
            "transferableBalance"
        ], "na"), a = di(i, [
            "available",
            "availableBalance"
        ], "0");
        if (!o || !a) {
            console.warn(`Invalid BRC20 balance data from source: ${t}`);
            return;
        }
        const u = {
            ticker: n,
            overall: o,
            transferable: s ?? "na",
            available: a
        };
        r.push(u);
    }), r;
    if (Array.isArray(e)) return e.forEach((n)=>{
        const i = di(n, [
            "ticker",
            "tick",
            "token"
        ], "");
        if (!i) {
            console.warn(`Missing ticker in BRC20 balance from source: ${t}`);
            return;
        }
        const o = di(n, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), s = di(n, [
            "transferable",
            "transferableBalance"
        ], "0"), a = di(n, [
            "available",
            "availableBalance"
        ], "0");
        if (!o || !a) {
            console.warn(`Invalid BRC20 balance data from source: ${t}`);
            return;
        }
        const u = {
            ticker: i,
            overall: o,
            transferable: s ?? "na",
            available: a
        };
        r.push(u);
    }), r;
    if (typeof e == "object" && !Array.isArray(e)) {
        const n = di(e, [
            "ticker",
            "tick",
            "token"
        ], "");
        if (!n) return console.warn(`Missing ticker in BRC20 balance from source: ${t}`), r;
        const i = di(e, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), o = di(e, [
            "transferable",
            "transferableBalance"
        ], "0"), s = di(e, [
            "available",
            "availableBalance"
        ], "0");
        if (!i || !s) throw console.warn(`Invalid BRC20 balance data from source: ${t}`), new Error(`Invalid BRC20 balance data from source: ${t}`);
        const a = {
            ticker: n,
            overall: i,
            transferable: o ?? "na",
            available: s
        };
        return r.push(a), r;
    }
    return console.warn(`Unrecognized BRC20 balance format from source: ${t}`), r;
}
class Yre {
    constructor(t, r){
        pt(this, "apiUrl", "");
        pt(this, "apiKey", "");
        pt(this, "networks");
        this.networks = {
            [ao]: {
                apiKey: $P,
                apiUrl: cm(dt.TESTNET4)
            },
            ...r == null ? void 0 : r.networks
        }, this.setNetwork(t);
    }
    getName() {
        return t9;
    }
    setNetwork(t) {
        this.networks[t] ? (this.apiUrl = this.networks[t].apiUrl, this.apiKey = this.networks[t].apiKey) : (this.apiUrl = cm(t), this.apiKey = this.networks.mainnet.apiKey);
    }
    async call(t, r, n) {
        const i = `${this.apiUrl}${r}`;
        try {
            const o = {
                headers: {
                    "Content-Type": "application/json",
                    "api-key": this.apiKey
                }
            }, s = t === "get" ? await rn.get(i, o) : await rn.post(i, n, o);
            if (!s || !s.data) throw new Error(`Invalid response from Maestro API: ${JSON.stringify(s)}`);
            return s.data;
        } catch (o) {
            throw console.error("MaestroDataSource.call error:", o), o;
        }
    }
    async getAddressBtcBalance(t) {
        return (await this.call("get", `/addresses/${t}/balance`)).data;
    }
    async getAddressBrc20Balances(t) {
        return await this.call("get", `/addresses/${t}/brc20`);
    }
    async getAddressInscriptions(t, r = 0, n = 10) {
        let i, o = r, s = 100, a = null;
        for(; o > 0;){
            const p = Math.min(s, o), y = new URLSearchParams();
            y.append("count", p.toString()), i && y.append("cursor", i);
            const _ = `/addresses/${t}/inscriptions?${y.toString()}`;
            if (a = await this.call("get", _), !a.next_cursor && o > p) return {
                ...a,
                data: []
            };
            i = a.next_cursor, o -= p;
        }
        const u = new URLSearchParams();
        u.append("count", n.toString()), i && u.append("cursor", i);
        const f = `/addresses/${t}/inscriptions?${u.toString()}`, c = await this.call("get", f);
        return {
            ...c,
            data: c.data.map((p)=>({
                    ...p,
                    address: t
                }))
        };
    }
    async getInscriptionInfo(t) {
        return await this.call("get", `/assets/inscriptions/${t}`);
    }
    async getBrc20ByTicker(t) {
        return this.call("get", `/assets/brc20/${t}`);
    }
    async getRuneById(t) {
        return this.call("get", `/assets/runes/${t}`);
    }
    async getRuneByName(t) {
        return this.call("get", `/assets/runes/${t}`);
    }
    async getTransactionInfo(t) {
        return this.call("get", `/rpc/transaction/${t}`);
    }
    async broadcastTransaction(t) {
        return await this.call("post", "/arpc/transaction/submit", t);
    }
    async getRawTransaction(t) {
        return this.call("get", `/raw-transactions/${t}`);
    }
    async getRecommendedFees() {
        const r = (await this.call("get", "/mempool/fee_rates")).data[0].sats_per_vb, n = r.median, i = r.min;
        return {
            fastFee: n,
            minFee: i
        };
    }
    async getOrdAddress(t) {
        return this.call("get", `/inscriptions/${t}`);
    }
}
class Xre {
    constructor(t, r){
        pt(this, "apiUrl", "");
        pt(this, "networks");
        pt(this, "network");
        this.networks = {
            [ln]: {
                apiUrl: Bi("mainnet")
            },
            [Ni]: {
                apiUrl: Bi("testnet")
            },
            [ao]: {
                apiUrl: Bi("testnet4")
            },
            [Ro]: {
                apiUrl: Bi("signet")
            },
            [yc]: {
                apiUrl: Bi("fractal-mainnet")
            },
            [co]: {
                apiUrl: Bi("fractal-testnet")
            },
            ...r == null ? void 0 : r.networks
        }, this.network = t, this.setNetwork(t);
    }
    getName() {
        return vG;
    }
    setNetwork(t) {
        this.networks[t] ? this.apiUrl = this.networks[t].apiUrl : this.apiUrl = Bi(t), this.network = t;
    }
    async call(t, r, n) {
        try {
            const i = `${this.apiUrl}${r}`, o = {
                headers: {
                    "Content-Type": t === "post" ? "text/plain" : "application/json"
                }
            };
            return (t === "get" ? await rn.get(i, o) : await rn.post(i, n, o)).data;
        } catch (i) {
            throw console.error("MempoolSpaceDataSource.call error:", i), i;
        }
    }
    async getOutputValueByVOutIndex(t, r) {
        const i = Date.now();
        for(;;)try {
            const o = await this.getTransaction(t);
            if (o != null && o.vout && o.vout.length > 0) return Math.floor(o.vout[r].value);
            if (Date.now() - i > 6e4) return null;
            await new Promise((s)=>setTimeout(s, 5e3));
        } catch (o) {
            if (console.error("Error fetching transaction output value:", o), Date.now() - i > 6e4) return null;
            await new Promise((s)=>setTimeout(s, 5e3));
        }
    }
    async waitForTransaction(t) {
        const n = Date.now();
        for(;;)try {
            if (await this.getTransaction(t)) return console.log("Transaction found in mempool:", t), !0;
            if (Date.now() - n > 6e4) return !1;
            await new Promise((o)=>setTimeout(o, 5e3));
        } catch  {
            if (Date.now() - n > 6e4) return !1;
            await new Promise((o)=>setTimeout(o, 5e3));
        }
    }
    async getAddressUtxos(t) {
        if (t.startsWith("bcrt")) return [];
        const r = await this.call("get", `/api/address/${t}/utxo`), n = hs(t, Dr(this.network));
        return r.map((i)=>({
                ...i,
                scriptPk: We.from(n).toString("hex")
            }));
    }
    async getTransaction(t) {
        return await this.call("get", `/api/tx/${t}`);
    }
    async getRecommendedFees() {
        const t = await this.call("get", "/api/v1/fees/recommended"), r = t.fastestFee, n = t.minimumFee;
        return {
            fastFee: r,
            minFee: n
        };
    }
    async broadcastTransaction(t) {
        return await this.call("post", "/api/tx", t);
    }
}
async function* Jre(e, t, r) {
    const n = /* @__PURE__ */ new Set();
    async function i() {
        const [o, s] = await Promise.race(n);
        return n.delete(o), s;
    }
    for (const o of t){
        const s = (async ()=>await r(o, t))().then((a)=>[
                s,
                a
            ]);
        n.add(s), n.size >= e && (yield await i());
    }
    for(; n.size;)yield await i();
}
var Qre = Jre;
const ene = /* @__PURE__ */ c7(Qre);
var tS = {}, ka = {}, mo = {}, Lf = {}, rS = {};
(function(e) {
    var t = typeof Object.defineProperties == "function" ? Object.defineProperty : function(v, B, Y) {
        v != Array.prototype && v != Object.prototype && (v[B] = Y.value);
    }, r = (("TURBOPACK compile-time value", "undefined") < "u" && window === Ge || typeof Ge < "u" && Ge != null, Ge);
    function n(v, B) {
        if (B) {
            var Y = r;
            v = v.split(".");
            for(var pe = 0; pe < v.length - 1; pe++){
                var ke = v[pe];
                ke in Y || (Y[ke] = {}), Y = Y[ke];
            }
            v = v[v.length - 1], pe = Y[v], B = B(pe), B != pe && B != null && t(Y, v, {
                configurable: !0,
                writable: !0,
                value: B
            });
        }
    }
    function i(v) {
        var B = 0;
        return function() {
            return B < v.length ? {
                done: !1,
                value: v[B++]
            } : {
                done: !0
            };
        };
    }
    function o() {
        o = function() {}, r.Symbol || (r.Symbol = a);
    }
    function s(v, B) {
        this.a = v, t(this, "description", {
            configurable: !0,
            writable: !0,
            value: B
        });
    }
    s.prototype.toString = function() {
        return this.a;
    };
    var a = /* @__PURE__ */ function() {
        function v(Y) {
            if (this instanceof v) throw new TypeError("Symbol is not a constructor");
            return new s("jscomp_symbol_" + (Y || "") + "_" + B++, Y);
        }
        var B = 0;
        return v;
    }();
    function u() {
        o();
        var v = r.Symbol.iterator;
        v || (v = r.Symbol.iterator = r.Symbol("Symbol.iterator")), typeof Array.prototype[v] != "function" && t(Array.prototype, v, {
            configurable: !0,
            writable: !0,
            value: function() {
                return f(i(this));
            }
        }), u = function() {};
    }
    function f(v) {
        return u(), v = {
            next: v
        }, v[r.Symbol.iterator] = function() {
            return this;
        }, v;
    }
    function c(v, B) {
        u(), v instanceof String && (v += "");
        var Y = 0, pe = {
            next: function() {
                if (Y < v.length) {
                    var ke = Y++;
                    return {
                        value: B(ke, v[ke]),
                        done: !1
                    };
                }
                return pe.next = function() {
                    return {
                        done: !0,
                        value: void 0
                    };
                }, pe.next();
            }
        };
        return pe[Symbol.iterator] = function() {
            return pe;
        }, pe;
    }
    n("Array.prototype.entries", function(v) {
        return v || function() {
            return c(this, function(B, Y) {
                return [
                    B,
                    Y
                ];
            });
        };
    });
    var l = Ge || self;
    function p(v, B, Y) {
        v = v.split("."), Y = Y || l, v[0] in Y || typeof Y.execScript > "u" || Y.execScript("var " + v[0]);
        for(var pe; v.length && (pe = v.shift());)v.length || B === void 0 ? Y[pe] && Y[pe] !== Object.prototype[pe] ? Y = Y[pe] : Y = Y[pe] = {} : Y[pe] = B;
    }
    function y(v) {
        var B = typeof v;
        if (B == "object") if (v) {
            if (v instanceof Array) return "array";
            if (v instanceof Object) return B;
            var Y = Object.prototype.toString.call(v);
            if (Y == "[object Window]") return "object";
            if (Y == "[object Array]" || typeof v.length == "number" && typeof v.splice < "u" && typeof v.propertyIsEnumerable < "u" && !v.propertyIsEnumerable("splice")) return "array";
            if (Y == "[object Function]" || typeof v.call < "u" && typeof v.propertyIsEnumerable < "u" && !v.propertyIsEnumerable("call")) return "function";
        } else return "null";
        else if (B == "function" && typeof v.call > "u") return "object";
        return B;
    }
    function _(v) {
        var B = typeof v;
        return B == "object" && v != null || B == "function";
    }
    function A(v, B, Y) {
        p(v, B, Y);
    }
    function O(v, B) {
        function Y() {}
        Y.prototype = B.prototype, v.prototype = new Y(), v.prototype.constructor = v;
    }
    var N = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    function U(v, B) {
        for(var Y, pe, ke = 1; ke < arguments.length; ke++){
            pe = arguments[ke];
            for(Y in pe)v[Y] = pe[Y];
            for(var qe = 0; qe < N.length; qe++)Y = N[qe], Object.prototype.hasOwnProperty.call(pe, Y) && (v[Y] = pe[Y]);
        }
    }
    var D = Array.prototype.forEach ? function(v, B) {
        Array.prototype.forEach.call(v, B, void 0);
    } : function(v, B) {
        for(var Y = v.length, pe = typeof v == "string" ? v.split("") : v, ke = 0; ke < Y; ke++)ke in pe && B.call(void 0, pe[ke], ke, v);
    }, H = Array.prototype.map ? function(v, B) {
        return Array.prototype.map.call(v, B, void 0);
    } : function(v, B) {
        for(var Y = v.length, pe = Array(Y), ke = typeof v == "string" ? v.split("") : v, qe = 0; qe < Y; qe++)qe in ke && (pe[qe] = B.call(void 0, ke[qe], qe, v));
        return pe;
    };
    function K(v, B, Y) {
        return 2 >= arguments.length ? Array.prototype.slice.call(v, B) : Array.prototype.slice.call(v, B, Y);
    }
    function re(v, B, Y, pe) {
        var ke = "Assertion failed";
        if (Y) {
            ke += ": " + Y;
            var qe = pe;
        } else v && (ke += ": " + v, qe = B);
        throw Error(ke, qe || []);
    }
    function Q(v, B, Y) {
        for(var pe = [], ke = 2; ke < arguments.length; ++ke)pe[ke - 2] = arguments[ke];
        return v || re("", null, B, pe), v;
    }
    function G(v, B, Y) {
        for(var pe = [], ke = 2; ke < arguments.length; ++ke)pe[ke - 2] = arguments[ke];
        typeof v != "string" && re("Expected string but got %s: %s.", [
            y(v),
            v
        ], B, pe);
    }
    function R(v, B, Y) {
        for(var pe = [], ke = 2; ke < arguments.length; ++ke)pe[ke - 2] = arguments[ke];
        Array.isArray(v) || re("Expected array but got %s: %s.", [
            y(v),
            v
        ], B, pe);
    }
    function X(v, B) {
        for(var Y = [], pe = 1; pe < arguments.length; ++pe)Y[pe - 1] = arguments[pe];
        throw Error("Failure" + (v ? ": " + v : ""), Y);
    }
    function $(v, B, Y, pe) {
        for(var ke = [], qe = 3; qe < arguments.length; ++qe)ke[qe - 3] = arguments[qe];
        v instanceof B || re("Expected instanceof %s but got %s.", [
            S(B),
            S(v)
        ], Y, ke);
    }
    function S(v) {
        return v instanceof Function ? v.displayName || v.name || "unknown type name" : v instanceof Object ? v.constructor.displayName || v.constructor.name || Object.prototype.toString.call(v) : v === null ? "null" : typeof v;
    }
    function w(v, B) {
        if (this.c = v, this.b = B, this.a = {}, this.arrClean = !0, 0 < this.c.length) {
            for(v = 0; v < this.c.length; v++){
                B = this.c[v];
                var Y = B[0];
                this.a[Y.toString()] = new T(Y, B[1]);
            }
            this.arrClean = !0;
        }
    }
    p("jspb.Map", w, void 0), w.prototype.g = function() {
        if (this.arrClean) {
            if (this.b) {
                var v = this.a, B;
                for(B in v)if (Object.prototype.hasOwnProperty.call(v, B)) {
                    var Y = v[B].a;
                    Y && Y.g();
                }
            }
        } else {
            for(this.c.length = 0, v = E(this), v.sort(), B = 0; B < v.length; B++){
                var pe = this.a[v[B]];
                (Y = pe.a) && Y.g(), this.c.push([
                    pe.key,
                    pe.value
                ]);
            }
            this.arrClean = !0;
        }
        return this.c;
    }, w.prototype.toArray = w.prototype.g, w.prototype.Mc = function(v, B) {
        for(var Y = this.g(), pe = [], ke = 0; ke < Y.length; ke++){
            var qe = this.a[Y[ke][0].toString()];
            m(this, qe);
            var ut = qe.a;
            ut ? (Q(B), pe.push([
                qe.key,
                B(v, ut)
            ])) : pe.push([
                qe.key,
                qe.value
            ]);
        }
        return pe;
    }, w.prototype.toObject = w.prototype.Mc, w.fromObject = function(v, B, Y) {
        B = new w([], B);
        for(var pe = 0; pe < v.length; pe++){
            var ke = v[pe][0], qe = Y(v[pe][1]);
            B.set(ke, qe);
        }
        return B;
    };
    function g(v) {
        this.a = 0, this.b = v;
    }
    g.prototype.next = function() {
        return this.a < this.b.length ? {
            done: !1,
            value: this.b[this.a++]
        } : {
            done: !0,
            value: void 0
        };
    }, typeof Symbol < "u" && (g.prototype[Symbol.iterator] = function() {
        return this;
    }), w.prototype.Jb = function() {
        return E(this).length;
    }, w.prototype.getLength = w.prototype.Jb, w.prototype.clear = function() {
        this.a = {}, this.arrClean = !1;
    }, w.prototype.clear = w.prototype.clear, w.prototype.Cb = function(v) {
        v = v.toString();
        var B = this.a.hasOwnProperty(v);
        return delete this.a[v], this.arrClean = !1, B;
    }, w.prototype.del = w.prototype.Cb, w.prototype.Eb = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++){
            var pe = this.a[B[Y]];
            v.push([
                pe.key,
                pe.value
            ]);
        }
        return v;
    }, w.prototype.getEntryList = w.prototype.Eb, w.prototype.entries = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++){
            var pe = this.a[B[Y]];
            v.push([
                pe.key,
                m(this, pe)
            ]);
        }
        return new g(v);
    }, w.prototype.entries = w.prototype.entries, w.prototype.keys = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++)v.push(this.a[B[Y]].key);
        return new g(v);
    }, w.prototype.keys = w.prototype.keys, w.prototype.values = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++)v.push(m(this, this.a[B[Y]]));
        return new g(v);
    }, w.prototype.values = w.prototype.values, w.prototype.forEach = function(v, B) {
        var Y = E(this);
        Y.sort();
        for(var pe = 0; pe < Y.length; pe++){
            var ke = this.a[Y[pe]];
            v.call(B, m(this, ke), ke.key, this);
        }
    }, w.prototype.forEach = w.prototype.forEach, w.prototype.set = function(v, B) {
        var Y = new T(v);
        return this.b ? (Y.a = B, Y.value = B.g()) : Y.value = B, this.a[v.toString()] = Y, this.arrClean = !1, this;
    }, w.prototype.set = w.prototype.set;
    function m(v, B) {
        return v.b ? (B.a || (B.a = new v.b(B.value)), B.a) : B.value;
    }
    w.prototype.get = function(v) {
        if (v = this.a[v.toString()]) return m(this, v);
    }, w.prototype.get = w.prototype.get, w.prototype.has = function(v) {
        return v.toString() in this.a;
    }, w.prototype.has = w.prototype.has, w.prototype.Jc = function(v, B, Y, pe, ke) {
        var qe = E(this);
        qe.sort();
        for(var ut = 0; ut < qe.length; ut++){
            var Ft = this.a[qe[ut]];
            B.Va(v), Y.call(B, 1, Ft.key), this.b ? pe.call(B, 2, m(this, Ft), ke) : pe.call(B, 2, Ft.value), B.Ya();
        }
    }, w.prototype.serializeBinary = w.prototype.Jc, w.deserializeBinary = function(v, B, Y, pe, ke, qe, ut) {
        for(; B.oa() && !B.bb();){
            var Ft = B.c;
            Ft == 1 ? qe = Y.call(B) : Ft == 2 && (v.b ? (Q(ke), ut || (ut = new v.b()), pe.call(B, ut, ke)) : ut = pe.call(B));
        }
        Q(qe != null), Q(ut != null), v.set(qe, ut);
    };
    function E(v) {
        v = v.a;
        var B = [], Y;
        for(Y in v)Object.prototype.hasOwnProperty.call(v, Y) && B.push(Y);
        return B;
    }
    function T(v, B) {
        this.key = v, this.value = B, this.a = void 0;
    }
    function I(v) {
        if (8192 >= v.length) return String.fromCharCode.apply(null, v);
        for(var B = "", Y = 0; Y < v.length; Y += 8192)B += String.fromCharCode.apply(null, K(v, Y, Y + 8192));
        return B;
    }
    var P = {
        "\0": "\\0",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\x0B",
        '"': '\\"',
        "\\": "\\\\",
        "<": "\\u003C"
    }, k = {
        "'": "\\'"
    }, L = {}, j = null;
    function ie(v, B) {
        B === void 0 && (B = 0), he(), B = L[B];
        for(var Y = [], pe = 0; pe < v.length; pe += 3){
            var ke = v[pe], qe = pe + 1 < v.length, ut = qe ? v[pe + 1] : 0, Ft = pe + 2 < v.length, pn = Ft ? v[pe + 2] : 0, bs = ke >> 2;
            ke = (ke & 3) << 4 | ut >> 4, ut = (ut & 15) << 2 | pn >> 6, pn &= 63, Ft || (pn = 64, qe || (ut = 64)), Y.push(B[bs], B[ke], B[ut] || "", B[pn] || "");
        }
        return Y.join("");
    }
    function ue(v) {
        var B = v.length, Y = 3 * B / 4;
        Y % 3 ? Y = Math.floor(Y) : "=.".indexOf(v[B - 1]) != -1 && (Y = "=.".indexOf(v[B - 2]) != -1 ? Y - 2 : Y - 1);
        var pe = new Uint8Array(Y), ke = 0;
        return ce(v, function(qe) {
            pe[ke++] = qe;
        }), pe.subarray(0, ke);
    }
    function ce(v, B) {
        function Y(pn) {
            for(; pe < v.length;){
                var bs = v.charAt(pe++), M0 = j[bs];
                if (M0 != null) return M0;
                if (!/^[\s\xa0]*$/.test(bs)) throw Error("Unknown base64 encoding at char: " + bs);
            }
            return pn;
        }
        he();
        for(var pe = 0;;){
            var ke = Y(-1), qe = Y(0), ut = Y(64), Ft = Y(64);
            if (Ft === 64 && ke === -1) break;
            B(ke << 2 | qe >> 4), ut != 64 && (B(qe << 4 & 240 | ut >> 2), Ft != 64 && B(ut << 6 & 192 | Ft));
        }
    }
    function he() {
        if (!j) {
            j = {};
            for(var v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), B = [
                "+/=",
                "+/",
                "-_=",
                "-_.",
                "-_"
            ], Y = 0; 5 > Y; Y++){
                var pe = v.concat(B[Y].split(""));
                L[Y] = pe;
                for(var ke = 0; ke < pe.length; ke++){
                    var qe = pe[ke];
                    j[qe] === void 0 && (j[qe] = ke);
                }
            }
        }
    }
    p("jspb.ConstBinaryMessage", function() {}, void 0), p("jspb.BinaryMessage", function() {}, void 0), p("jspb.BinaryConstants.FieldType", {
        yb: -1,
        ee: 1,
        FLOAT: 2,
        ke: 3,
        te: 4,
        je: 5,
        xb: 6,
        wb: 7,
        BOOL: 8,
        re: 9,
        ie: 10,
        le: 11,
        ce: 12,
        se: 13,
        ge: 14,
        me: 15,
        ne: 16,
        oe: 17,
        pe: 18,
        he: 30,
        ve: 31
    }, void 0), p("jspb.BinaryConstants.WireType", {
        yb: -1,
        ue: 0,
        xb: 1,
        de: 2,
        qe: 3,
        fe: 4,
        wb: 5
    }, void 0), p("jspb.BinaryConstants.FieldTypeToWireType", function(v) {
        switch(v){
            case 5:
            case 3:
            case 13:
            case 4:
            case 17:
            case 18:
            case 8:
            case 14:
            case 31:
                return 0;
            case 1:
            case 6:
            case 16:
            case 30:
                return 1;
            case 9:
            case 11:
            case 12:
                return 2;
            case 2:
            case 7:
            case 15:
                return 5;
            default:
                return -1;
        }
    }, void 0), p("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0), p("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0), p("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0), p("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0), p("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0), p("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0), p("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0), p("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0), p("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0), p("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0), p("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0), p("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0), p("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0), p("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0), p("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
    var ee = 0, ae = 0;
    p("jspb.utils.getSplit64Low", function() {
        return ee;
    }, void 0), p("jspb.utils.getSplit64High", function() {
        return ae;
    }, void 0);
    function ye(v) {
        var B = v >>> 0;
        v = Math.floor((v - B) / 4294967296) >>> 0, ee = B, ae = v;
    }
    p("jspb.utils.splitUint64", ye, void 0);
    function Se(v) {
        var B = 0 > v;
        v = Math.abs(v);
        var Y = v >>> 0;
        v = Math.floor((v - Y) / 4294967296), v >>>= 0, B && (v = ~v >>> 0, Y = (~Y >>> 0) + 1, 4294967295 < Y && (Y = 0, v++, 4294967295 < v && (v = 0))), ee = Y, ae = v;
    }
    p("jspb.utils.splitInt64", Se, void 0);
    function De(v) {
        var B = 0 > v;
        v = 2 * Math.abs(v), ye(v), v = ee;
        var Y = ae;
        B && (v == 0 ? Y == 0 ? Y = v = 4294967295 : (Y--, v = 4294967295) : v--), ee = v, ae = Y;
    }
    p("jspb.utils.splitZigzag64", De, void 0);
    function Re(v) {
        var B = 0 > v ? 1 : 0;
        if (v = B ? -v : v, v === 0) 0 < 1 / v ? ee = ae = 0 : (ae = 0, ee = 2147483648);
        else if (isNaN(v)) ae = 0, ee = 2147483647;
        else if (34028234663852886e22 < v) ae = 0, ee = (B << 31 | 2139095040) >>> 0;
        else if (11754943508222875e-54 > v) v = Math.round(v / Math.pow(2, -149)), ae = 0, ee = (B << 31 | v) >>> 0;
        else {
            var Y = Math.floor(Math.log(v) / Math.LN2);
            v *= Math.pow(2, -Y), v = Math.round(8388608 * v), 16777216 <= v && ++Y, ae = 0, ee = (B << 31 | Y + 127 << 23 | v & 8388607) >>> 0;
        }
    }
    p("jspb.utils.splitFloat32", Re, void 0);
    function Ce(v) {
        var B = 0 > v ? 1 : 0;
        if (v = B ? -v : v, v === 0) ae = 0 < 1 / v ? 0 : 2147483648, ee = 0;
        else if (isNaN(v)) ae = 2147483647, ee = 4294967295;
        else if (17976931348623157e292 < v) ae = (B << 31 | 2146435072) >>> 0, ee = 0;
        else if (22250738585072014e-324 > v) v /= Math.pow(2, -1074), ae = (B << 31 | v / 4294967296) >>> 0, ee = v >>> 0;
        else {
            var Y = v, pe = 0;
            if (2 <= Y) for(; 2 <= Y && 1023 > pe;)pe++, Y /= 2;
            else for(; 1 > Y && -1022 < pe;)Y *= 2, pe--;
            v *= Math.pow(2, -pe), ae = (B << 31 | pe + 1023 << 20 | 1048576 * v & 1048575) >>> 0, ee = 4503599627370496 * v >>> 0;
        }
    }
    p("jspb.utils.splitFloat64", Ce, void 0);
    function M(v) {
        var B = v.charCodeAt(4), Y = v.charCodeAt(5), pe = v.charCodeAt(6), ke = v.charCodeAt(7);
        ee = v.charCodeAt(0) + (v.charCodeAt(1) << 8) + (v.charCodeAt(2) << 16) + (v.charCodeAt(3) << 24) >>> 0, ae = B + (Y << 8) + (pe << 16) + (ke << 24) >>> 0;
    }
    p("jspb.utils.splitHash64", M, void 0);
    function z(v, B) {
        return 4294967296 * B + (v >>> 0);
    }
    p("jspb.utils.joinUint64", z, void 0);
    function de(v, B) {
        var Y = B & 2147483648;
        return Y && (v = ~v + 1 >>> 0, B = ~B >>> 0, v == 0 && (B = B + 1 >>> 0)), v = z(v, B), Y ? -v : v;
    }
    p("jspb.utils.joinInt64", de, void 0);
    function _e(v, B, Y) {
        var pe = B >> 31;
        return Y(v << 1 ^ pe, (B << 1 | v >>> 31) ^ pe);
    }
    p("jspb.utils.toZigzag64", _e, void 0);
    function Ie(v, B) {
        return je(v, B, de);
    }
    p("jspb.utils.joinZigzag64", Ie, void 0);
    function je(v, B, Y) {
        var pe = -(v & 1);
        return Y((v >>> 1 | B << 31) ^ pe, B >>> 1 ^ pe);
    }
    p("jspb.utils.fromZigzag64", je, void 0);
    function Ke(v) {
        var B = 2 * (v >> 31) + 1, Y = v >>> 23 & 255;
        return v &= 8388607, Y == 255 ? v ? NaN : 1 / 0 * B : Y == 0 ? B * Math.pow(2, -149) * v : B * Math.pow(2, Y - 150) * (v + Math.pow(2, 23));
    }
    p("jspb.utils.joinFloat32", Ke, void 0);
    function Ue(v, B) {
        var Y = 2 * (B >> 31) + 1, pe = B >>> 20 & 2047;
        return v = 4294967296 * (B & 1048575) + v, pe == 2047 ? v ? NaN : 1 / 0 * Y : pe == 0 ? Y * Math.pow(2, -1074) * v : Y * Math.pow(2, pe - 1075) * (v + 4503599627370496);
    }
    p("jspb.utils.joinFloat64", Ue, void 0);
    function h(v, B) {
        return String.fromCharCode(v >>> 0 & 255, v >>> 8 & 255, v >>> 16 & 255, v >>> 24 & 255, B >>> 0 & 255, B >>> 8 & 255, B >>> 16 & 255, B >>> 24 & 255);
    }
    p("jspb.utils.joinHash64", h, void 0), p("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
    function x(v, B) {
        function Y(ke, qe) {
            return ke = ke ? String(ke) : "", qe ? "0000000".slice(ke.length) + ke : ke;
        }
        if (2097151 >= B) return "" + z(v, B);
        var pe = (v >>> 24 | B << 8) >>> 0 & 16777215;
        return B = B >> 16 & 65535, v = (v & 16777215) + 6777216 * pe + 6710656 * B, pe += 8147497 * B, B *= 2, 1e7 <= v && (pe += Math.floor(v / 1e7), v %= 1e7), 1e7 <= pe && (B += Math.floor(pe / 1e7), pe %= 1e7), Y(B, 0) + Y(pe, B) + Y(v, 1);
    }
    p("jspb.utils.joinUnsignedDecimalString", x, void 0);
    function q(v, B) {
        var Y = B & 2147483648;
        return Y && (v = ~v + 1 >>> 0, B = ~B + (v == 0 ? 1 : 0) >>> 0), v = x(v, B), Y ? "-" + v : v;
    }
    p("jspb.utils.joinSignedDecimalString", q, void 0);
    function te(v, B) {
        M(v), v = ee;
        var Y = ae;
        return B ? q(v, Y) : x(v, Y);
    }
    p("jspb.utils.hash64ToDecimalString", te, void 0), p("jspb.utils.hash64ArrayToDecimalStrings", function(v, B) {
        for(var Y = Array(v.length), pe = 0; pe < v.length; pe++)Y[pe] = te(v[pe], B);
        return Y;
    }, void 0);
    function fe(v) {
        function B(ut, Ft) {
            for(var pn = 0; 8 > pn && (ut !== 1 || 0 < Ft); pn++)Ft = ut * ke[pn] + Ft, ke[pn] = Ft & 255, Ft >>>= 8;
        }
        function Y() {
            for(var ut = 0; 8 > ut; ut++)ke[ut] = ~ke[ut] & 255;
        }
        Q(0 < v.length);
        var pe = !1;
        v[0] === "-" && (pe = !0, v = v.slice(1));
        for(var ke = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ], qe = 0; qe < v.length; qe++)B(10, v.charCodeAt(qe) - 48);
        return pe && (Y(), B(1, 1)), I(ke);
    }
    p("jspb.utils.decimalStringToHash64", fe, void 0), p("jspb.utils.splitDecimalString", function(v) {
        M(fe(v));
    }, void 0);
    function ne(v) {
        return String.fromCharCode(10 > v ? 48 + v : 87 + v);
    }
    function W(v) {
        return 97 <= v ? v - 97 + 10 : v - 48;
    }
    p("jspb.utils.hash64ToHexString", function(v) {
        var B = Array(18);
        B[0] = "0", B[1] = "x";
        for(var Y = 0; 8 > Y; Y++){
            var pe = v.charCodeAt(7 - Y);
            B[2 * Y + 2] = ne(pe >> 4), B[2 * Y + 3] = ne(pe & 15);
        }
        return B.join("");
    }, void 0), p("jspb.utils.hexStringToHash64", function(v) {
        v = v.toLowerCase(), Q(v.length == 18), Q(v[0] == "0"), Q(v[1] == "x");
        for(var B = "", Y = 0; 8 > Y; Y++)B = String.fromCharCode(16 * W(v.charCodeAt(2 * Y + 2)) + W(v.charCodeAt(2 * Y + 3))) + B;
        return B;
    }, void 0), p("jspb.utils.hash64ToNumber", function(v, B) {
        M(v), v = ee;
        var Y = ae;
        return B ? de(v, Y) : z(v, Y);
    }, void 0), p("jspb.utils.numberToHash64", function(v) {
        return Se(v), h(ee, ae);
    }, void 0), p("jspb.utils.countVarints", function(v, B, Y) {
        for(var pe = 0, ke = B; ke < Y; ke++)pe += v[ke] >> 7;
        return Y - B - pe;
    }, void 0), p("jspb.utils.countVarintFields", function(v, B, Y, pe) {
        var ke = 0;
        if (pe *= 8, 128 > pe) for(; B < Y && v[B++] == pe;)for(ke++;;){
            var qe = v[B++];
            if (!(qe & 128)) break;
        }
        else for(; B < Y;){
            for(qe = pe; 128 < qe;){
                if (v[B] != (qe & 127 | 128)) return ke;
                B++, qe >>= 7;
            }
            if (v[B++] != qe) break;
            for(ke++; qe = v[B++], (qe & 128) != 0;);
        }
        return ke;
    }, void 0);
    function J(v, B, Y, pe, ke) {
        var qe = 0;
        if (128 > pe) for(; B < Y && v[B++] == pe;)qe++, B += ke;
        else for(; B < Y;){
            for(var ut = pe; 128 < ut;){
                if (v[B++] != (ut & 127 | 128)) return qe;
                ut >>= 7;
            }
            if (v[B++] != ut) break;
            qe++, B += ke;
        }
        return qe;
    }
    p("jspb.utils.countFixed32Fields", function(v, B, Y, pe) {
        return J(v, B, Y, 8 * pe + 5, 4);
    }, void 0), p("jspb.utils.countFixed64Fields", function(v, B, Y, pe) {
        return J(v, B, Y, 8 * pe + 1, 8);
    }, void 0), p("jspb.utils.countDelimitedFields", function(v, B, Y, pe) {
        var ke = 0;
        for(pe = 8 * pe + 2; B < Y;){
            for(var qe = pe; 128 < qe;){
                if (v[B++] != (qe & 127 | 128)) return ke;
                qe >>= 7;
            }
            if (v[B++] != qe) break;
            ke++;
            for(var ut = 0, Ft = 1; qe = v[B++], ut += (qe & 127) * Ft, Ft *= 128, (qe & 128) != 0;);
            B += ut;
        }
        return ke;
    }, void 0), p("jspb.utils.debugBytesToTextFormat", function(v) {
        var B = '"';
        if (v) {
            v = V(v);
            for(var Y = 0; Y < v.length; Y++)B += "\\x", 16 > v[Y] && (B += "0"), B += v[Y].toString(16);
        }
        return B + '"';
    }, void 0), p("jspb.utils.debugScalarToTextFormat", function(v) {
        if (typeof v == "string") {
            v = String(v);
            for(var B = [
                '"'
            ], Y = 0; Y < v.length; Y++){
                var pe = v.charAt(Y), ke = pe.charCodeAt(0), qe = Y + 1, ut;
                (ut = P[pe]) || (31 < ke && 127 > ke || (ke = pe, ke in k ? pe = k[ke] : ke in P ? pe = k[ke] = P[ke] : (ut = ke.charCodeAt(0), 31 < ut && 127 > ut ? pe = ke : (256 > ut ? (pe = "\\x", (16 > ut || 256 < ut) && (pe += "0")) : (pe = "\\u", 4096 > ut && (pe += "0")), pe += ut.toString(16).toUpperCase()), pe = k[ke] = pe)), ut = pe), B[qe] = ut;
            }
            B.push('"'), v = B.join("");
        } else v = v.toString();
        return v;
    }, void 0), p("jspb.utils.stringToByteArray", function(v) {
        for(var B = new Uint8Array(v.length), Y = 0; Y < v.length; Y++){
            var pe = v.charCodeAt(Y);
            if (255 < pe) throw Error("Conversion error: string contains codepoint outside of byte range");
            B[Y] = pe;
        }
        return B;
    }, void 0);
    function V(v) {
        return v.constructor === Uint8Array ? v : v.constructor === ArrayBuffer ? new Uint8Array(v) : v.constructor === Array ? new Uint8Array(v) : v.constructor === String ? ue(v) : v instanceof Uint8Array ? new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : (X("Type not convertible to Uint8Array."), new Uint8Array(0));
    }
    p("jspb.utils.byteSourceToUint8Array", V, void 0);
    function C(v, B, Y) {
        this.b = null, this.a = this.c = this.h = 0, this.v = !1, v && this.H(v, B, Y);
    }
    p("jspb.BinaryDecoder", C, void 0);
    var Z = [];
    C.getInstanceCacheLength = function() {
        return Z.length;
    };
    function le(v, B, Y) {
        if (Z.length) {
            var pe = Z.pop();
            return v && pe.H(v, B, Y), pe;
        }
        return new C(v, B, Y);
    }
    C.alloc = le, C.prototype.Ca = function() {
        this.clear(), 100 > Z.length && Z.push(this);
    }, C.prototype.free = C.prototype.Ca, C.prototype.clone = function() {
        return le(this.b, this.h, this.c - this.h);
    }, C.prototype.clone = C.prototype.clone, C.prototype.clear = function() {
        this.b = null, this.a = this.c = this.h = 0, this.v = !1;
    }, C.prototype.clear = C.prototype.clear, C.prototype.Y = function() {
        return this.b;
    }, C.prototype.getBuffer = C.prototype.Y, C.prototype.H = function(v, B, Y) {
        this.b = V(v), this.h = B !== void 0 ? B : 0, this.c = Y !== void 0 ? this.h + Y : this.b.length, this.a = this.h;
    }, C.prototype.setBlock = C.prototype.H, C.prototype.Db = function() {
        return this.c;
    }, C.prototype.getEnd = C.prototype.Db, C.prototype.setEnd = function(v) {
        this.c = v;
    }, C.prototype.setEnd = C.prototype.setEnd, C.prototype.reset = function() {
        this.a = this.h;
    }, C.prototype.reset = C.prototype.reset, C.prototype.B = function() {
        return this.a;
    }, C.prototype.getCursor = C.prototype.B, C.prototype.Ma = function(v) {
        this.a = v;
    }, C.prototype.setCursor = C.prototype.Ma, C.prototype.advance = function(v) {
        this.a += v, Q(this.a <= this.c);
    }, C.prototype.advance = C.prototype.advance, C.prototype.ya = function() {
        return this.a == this.c;
    }, C.prototype.atEnd = C.prototype.ya, C.prototype.Qb = function() {
        return this.a > this.c;
    }, C.prototype.pastEnd = C.prototype.Qb, C.prototype.getError = function() {
        return this.v || 0 > this.a || this.a > this.c;
    }, C.prototype.getError = C.prototype.getError, C.prototype.w = function(v) {
        for(var B = 128, Y = 0, pe = 0, ke = 0; 4 > ke && 128 <= B; ke++)B = this.b[this.a++], Y |= (B & 127) << 7 * ke;
        if (128 <= B && (B = this.b[this.a++], Y |= (B & 127) << 28, pe |= (B & 127) >> 4), 128 <= B) for(ke = 0; 5 > ke && 128 <= B; ke++)B = this.b[this.a++], pe |= (B & 127) << 7 * ke + 3;
        if (128 > B) return v(Y >>> 0, pe >>> 0);
        X("Failed to read varint, encoding is invalid."), this.v = !0;
    }, C.prototype.readSplitVarint64 = C.prototype.w, C.prototype.ea = function(v) {
        return this.w(function(B, Y) {
            return je(B, Y, v);
        });
    }, C.prototype.readSplitZigzagVarint64 = C.prototype.ea, C.prototype.ta = function(v) {
        var B = this.b, Y = this.a;
        this.a += 8;
        for(var pe = 0, ke = 0, qe = Y + 7; qe >= Y; qe--)pe = pe << 8 | B[qe], ke = ke << 8 | B[qe + 4];
        return v(pe, ke);
    }, C.prototype.readSplitFixed64 = C.prototype.ta, C.prototype.kb = function() {
        for(; this.b[this.a] & 128;)this.a++;
        this.a++;
    }, C.prototype.skipVarint = C.prototype.kb, C.prototype.mb = function(v) {
        for(; 128 < v;)this.a--, v >>>= 7;
        this.a--;
    }, C.prototype.unskipVarint = C.prototype.mb, C.prototype.o = function() {
        var v = this.b, B = v[this.a], Y = B & 127;
        return 128 > B ? (this.a += 1, Q(this.a <= this.c), Y) : (B = v[this.a + 1], Y |= (B & 127) << 7, 128 > B ? (this.a += 2, Q(this.a <= this.c), Y) : (B = v[this.a + 2], Y |= (B & 127) << 14, 128 > B ? (this.a += 3, Q(this.a <= this.c), Y) : (B = v[this.a + 3], Y |= (B & 127) << 21, 128 > B ? (this.a += 4, Q(this.a <= this.c), Y) : (B = v[this.a + 4], Y |= (B & 15) << 28, 128 > B ? (this.a += 5, Q(this.a <= this.c), Y >>> 0) : (this.a += 5, 128 <= v[this.a++] && 128 <= v[this.a++] && 128 <= v[this.a++] && 128 <= v[this.a++] && 128 <= v[this.a++] && Q(!1), Q(this.a <= this.c), Y)))));
    }, C.prototype.readUnsignedVarint32 = C.prototype.o, C.prototype.da = function() {
        return ~~this.o();
    }, C.prototype.readSignedVarint32 = C.prototype.da, C.prototype.O = function() {
        return this.o().toString();
    }, C.prototype.Ea = function() {
        return this.da().toString();
    }, C.prototype.readSignedVarint32String = C.prototype.Ea, C.prototype.Ia = function() {
        var v = this.o();
        return v >>> 1 ^ -(v & 1);
    }, C.prototype.readZigzagVarint32 = C.prototype.Ia, C.prototype.Ga = function() {
        return this.w(z);
    }, C.prototype.readUnsignedVarint64 = C.prototype.Ga, C.prototype.Ha = function() {
        return this.w(x);
    }, C.prototype.readUnsignedVarint64String = C.prototype.Ha, C.prototype.sa = function() {
        return this.w(de);
    }, C.prototype.readSignedVarint64 = C.prototype.sa, C.prototype.Fa = function() {
        return this.w(q);
    }, C.prototype.readSignedVarint64String = C.prototype.Fa, C.prototype.Ja = function() {
        return this.w(Ie);
    }, C.prototype.readZigzagVarint64 = C.prototype.Ja, C.prototype.fb = function() {
        return this.ea(h);
    }, C.prototype.readZigzagVarintHash64 = C.prototype.fb, C.prototype.Ka = function() {
        return this.ea(q);
    }, C.prototype.readZigzagVarint64String = C.prototype.Ka, C.prototype.Gc = function() {
        var v = this.b[this.a];
        return this.a += 1, Q(this.a <= this.c), v;
    }, C.prototype.readUint8 = C.prototype.Gc, C.prototype.Ec = function() {
        var v = this.b[this.a], B = this.b[this.a + 1];
        return this.a += 2, Q(this.a <= this.c), v << 0 | B << 8;
    }, C.prototype.readUint16 = C.prototype.Ec, C.prototype.m = function() {
        var v = this.b[this.a], B = this.b[this.a + 1], Y = this.b[this.a + 2], pe = this.b[this.a + 3];
        return this.a += 4, Q(this.a <= this.c), (v << 0 | B << 8 | Y << 16 | pe << 24) >>> 0;
    }, C.prototype.readUint32 = C.prototype.m, C.prototype.ga = function() {
        var v = this.m(), B = this.m();
        return z(v, B);
    }, C.prototype.readUint64 = C.prototype.ga, C.prototype.ha = function() {
        var v = this.m(), B = this.m();
        return x(v, B);
    }, C.prototype.readUint64String = C.prototype.ha, C.prototype.Xb = function() {
        var v = this.b[this.a];
        return this.a += 1, Q(this.a <= this.c), v << 24 >> 24;
    }, C.prototype.readInt8 = C.prototype.Xb, C.prototype.Vb = function() {
        var v = this.b[this.a], B = this.b[this.a + 1];
        return this.a += 2, Q(this.a <= this.c), (v << 0 | B << 8) << 16 >> 16;
    }, C.prototype.readInt16 = C.prototype.Vb, C.prototype.P = function() {
        var v = this.b[this.a], B = this.b[this.a + 1], Y = this.b[this.a + 2], pe = this.b[this.a + 3];
        return this.a += 4, Q(this.a <= this.c), v << 0 | B << 8 | Y << 16 | pe << 24;
    }, C.prototype.readInt32 = C.prototype.P, C.prototype.ba = function() {
        var v = this.m(), B = this.m();
        return de(v, B);
    }, C.prototype.readInt64 = C.prototype.ba, C.prototype.ca = function() {
        var v = this.m(), B = this.m();
        return q(v, B);
    }, C.prototype.readInt64String = C.prototype.ca, C.prototype.aa = function() {
        var v = this.m();
        return Ke(v);
    }, C.prototype.readFloat = C.prototype.aa, C.prototype.Z = function() {
        var v = this.m(), B = this.m();
        return Ue(v, B);
    }, C.prototype.readDouble = C.prototype.Z, C.prototype.pa = function() {
        return !!this.b[this.a++];
    }, C.prototype.readBool = C.prototype.pa, C.prototype.ra = function() {
        return this.da();
    }, C.prototype.readEnum = C.prototype.ra, C.prototype.fa = function(v) {
        var B = this.b, Y = this.a;
        v = Y + v;
        for(var pe = [], ke = ""; Y < v;){
            var qe = B[Y++];
            if (128 > qe) pe.push(qe);
            else {
                if (192 > qe) continue;
                if (224 > qe) {
                    var ut = B[Y++];
                    pe.push((qe & 31) << 6 | ut & 63);
                } else if (240 > qe) {
                    ut = B[Y++];
                    var Ft = B[Y++];
                    pe.push((qe & 15) << 12 | (ut & 63) << 6 | Ft & 63);
                } else if (248 > qe) {
                    ut = B[Y++], Ft = B[Y++];
                    var pn = B[Y++];
                    qe = (qe & 7) << 18 | (ut & 63) << 12 | (Ft & 63) << 6 | pn & 63, qe -= 65536, pe.push((qe >> 10 & 1023) + 55296, (qe & 1023) + 56320);
                }
            }
            8192 <= pe.length && (ke += String.fromCharCode.apply(null, pe), pe.length = 0);
        }
        return ke += I(pe), this.a = Y, ke;
    }, C.prototype.readString = C.prototype.fa, C.prototype.Dc = function() {
        var v = this.o();
        return this.fa(v);
    }, C.prototype.readStringWithLength = C.prototype.Dc, C.prototype.qa = function(v) {
        if (0 > v || this.a + v > this.b.length) return this.v = !0, X("Invalid byte length!"), new Uint8Array(0);
        var B = this.b.subarray(this.a, this.a + v);
        return this.a += v, Q(this.a <= this.c), B;
    }, C.prototype.readBytes = C.prototype.qa, C.prototype.ia = function() {
        return this.w(h);
    }, C.prototype.readVarintHash64 = C.prototype.ia, C.prototype.$ = function() {
        var v = this.b, B = this.a, Y = v[B], pe = v[B + 1], ke = v[B + 2], qe = v[B + 3], ut = v[B + 4], Ft = v[B + 5], pn = v[B + 6];
        return v = v[B + 7], this.a += 8, String.fromCharCode(Y, pe, ke, qe, ut, Ft, pn, v);
    }, C.prototype.readFixedHash64 = C.prototype.$;
    function se(v, B, Y) {
        this.a = le(v, B, Y), this.O = this.a.B(), this.b = this.c = -1, this.h = !1, this.v = null;
    }
    p("jspb.BinaryReader", se, void 0);
    var Ne = [];
    se.clearInstanceCache = function() {
        Ne = [];
    }, se.getInstanceCacheLength = function() {
        return Ne.length;
    };
    function Le(v, B, Y) {
        if (Ne.length) {
            var pe = Ne.pop();
            return v && pe.a.H(v, B, Y), pe;
        }
        return new se(v, B, Y);
    }
    se.alloc = Le, se.prototype.zb = Le, se.prototype.alloc = se.prototype.zb, se.prototype.Ca = function() {
        this.a.clear(), this.b = this.c = -1, this.h = !1, this.v = null, 100 > Ne.length && Ne.push(this);
    }, se.prototype.free = se.prototype.Ca, se.prototype.Fb = function() {
        return this.O;
    }, se.prototype.getFieldCursor = se.prototype.Fb, se.prototype.B = function() {
        return this.a.B();
    }, se.prototype.getCursor = se.prototype.B, se.prototype.Y = function() {
        return this.a.Y();
    }, se.prototype.getBuffer = se.prototype.Y, se.prototype.Hb = function() {
        return this.c;
    }, se.prototype.getFieldNumber = se.prototype.Hb, se.prototype.Lb = function() {
        return this.b;
    }, se.prototype.getWireType = se.prototype.Lb, se.prototype.Mb = function() {
        return this.b == 2;
    }, se.prototype.isDelimited = se.prototype.Mb, se.prototype.bb = function() {
        return this.b == 4;
    }, se.prototype.isEndGroup = se.prototype.bb, se.prototype.getError = function() {
        return this.h || this.a.getError();
    }, se.prototype.getError = se.prototype.getError, se.prototype.H = function(v, B, Y) {
        this.a.H(v, B, Y), this.b = this.c = -1;
    }, se.prototype.setBlock = se.prototype.H, se.prototype.reset = function() {
        this.a.reset(), this.b = this.c = -1;
    }, se.prototype.reset = se.prototype.reset, se.prototype.advance = function(v) {
        this.a.advance(v);
    }, se.prototype.advance = se.prototype.advance, se.prototype.oa = function() {
        if (this.a.ya()) return !1;
        if (this.getError()) return X("Decoder hit an error"), !1;
        this.O = this.a.B();
        var v = this.a.o(), B = v >>> 3;
        return v &= 7, v != 0 && v != 5 && v != 1 && v != 2 && v != 3 && v != 4 ? (X("Invalid wire type: %s (at position %s)", v, this.O), this.h = !0, !1) : (this.c = B, this.b = v, !0);
    }, se.prototype.nextField = se.prototype.oa, se.prototype.Oa = function() {
        this.a.mb(this.c << 3 | this.b);
    }, se.prototype.unskipHeader = se.prototype.Oa, se.prototype.Lc = function() {
        var v = this.c;
        for(this.Oa(); this.oa() && this.c == v;)this.C();
        this.a.ya() || this.Oa();
    }, se.prototype.skipMatchingFields = se.prototype.Lc, se.prototype.lb = function() {
        this.b != 0 ? (X("Invalid wire type for skipVarintField"), this.C()) : this.a.kb();
    }, se.prototype.skipVarintField = se.prototype.lb, se.prototype.gb = function() {
        if (this.b != 2) X("Invalid wire type for skipDelimitedField"), this.C();
        else {
            var v = this.a.o();
            this.a.advance(v);
        }
    }, se.prototype.skipDelimitedField = se.prototype.gb, se.prototype.hb = function() {
        this.b != 5 ? (X("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4);
    }, se.prototype.skipFixed32Field = se.prototype.hb, se.prototype.ib = function() {
        this.b != 1 ? (X("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8);
    }, se.prototype.skipFixed64Field = se.prototype.ib, se.prototype.jb = function() {
        var v = this.c;
        do {
            if (!this.oa()) {
                X("Unmatched start-group tag: stream EOF"), this.h = !0;
                break;
            }
            if (this.b == 4) {
                this.c != v && (X("Unmatched end-group tag"), this.h = !0);
                break;
            }
            this.C();
        }while (!0)
    }, se.prototype.skipGroup = se.prototype.jb, se.prototype.C = function() {
        switch(this.b){
            case 0:
                this.lb();
                break;
            case 1:
                this.ib();
                break;
            case 2:
                this.gb();
                break;
            case 5:
                this.hb();
                break;
            case 3:
                this.jb();
                break;
            default:
                X("Invalid wire encoding for field.");
        }
    }, se.prototype.skipField = se.prototype.C, se.prototype.Hc = function(v, B) {
        this.v === null && (this.v = {}), Q(!this.v[v]), this.v[v] = B;
    }, se.prototype.registerReadCallback = se.prototype.Hc, se.prototype.Ic = function(v) {
        return Q(this.v !== null), v = this.v[v], Q(v), v(this);
    }, se.prototype.runReadCallback = se.prototype.Ic, se.prototype.Yb = function(v, B) {
        Q(this.b == 2);
        var Y = this.a.c, pe = this.a.o();
        pe = this.a.B() + pe, this.a.setEnd(pe), B(v, this), this.a.Ma(pe), this.a.setEnd(Y);
    }, se.prototype.readMessage = se.prototype.Yb, se.prototype.Ub = function(v, B, Y) {
        Q(this.b == 3), Q(this.c == v), Y(B, this), this.h || this.b == 4 || (X("Group submessage did not end with an END_GROUP tag"), this.h = !0);
    }, se.prototype.readGroup = se.prototype.Ub, se.prototype.Gb = function() {
        Q(this.b == 2);
        var v = this.a.o(), B = this.a.B(), Y = B + v;
        return v = le(this.a.Y(), B, v), this.a.Ma(Y), v;
    }, se.prototype.getFieldDecoder = se.prototype.Gb, se.prototype.P = function() {
        return Q(this.b == 0), this.a.da();
    }, se.prototype.readInt32 = se.prototype.P, se.prototype.Wb = function() {
        return Q(this.b == 0), this.a.Ea();
    }, se.prototype.readInt32String = se.prototype.Wb, se.prototype.ba = function() {
        return Q(this.b == 0), this.a.sa();
    }, se.prototype.readInt64 = se.prototype.ba, se.prototype.ca = function() {
        return Q(this.b == 0), this.a.Fa();
    }, se.prototype.readInt64String = se.prototype.ca, se.prototype.m = function() {
        return Q(this.b == 0), this.a.o();
    }, se.prototype.readUint32 = se.prototype.m, se.prototype.Fc = function() {
        return Q(this.b == 0), this.a.O();
    }, se.prototype.readUint32String = se.prototype.Fc, se.prototype.ga = function() {
        return Q(this.b == 0), this.a.Ga();
    }, se.prototype.readUint64 = se.prototype.ga, se.prototype.ha = function() {
        return Q(this.b == 0), this.a.Ha();
    }, se.prototype.readUint64String = se.prototype.ha, se.prototype.zc = function() {
        return Q(this.b == 0), this.a.Ia();
    }, se.prototype.readSint32 = se.prototype.zc, se.prototype.Ac = function() {
        return Q(this.b == 0), this.a.Ja();
    }, se.prototype.readSint64 = se.prototype.Ac, se.prototype.Bc = function() {
        return Q(this.b == 0), this.a.Ka();
    }, se.prototype.readSint64String = se.prototype.Bc, se.prototype.Rb = function() {
        return Q(this.b == 5), this.a.m();
    }, se.prototype.readFixed32 = se.prototype.Rb, se.prototype.Sb = function() {
        return Q(this.b == 1), this.a.ga();
    }, se.prototype.readFixed64 = se.prototype.Sb, se.prototype.Tb = function() {
        return Q(this.b == 1), this.a.ha();
    }, se.prototype.readFixed64String = se.prototype.Tb, se.prototype.vc = function() {
        return Q(this.b == 5), this.a.P();
    }, se.prototype.readSfixed32 = se.prototype.vc, se.prototype.wc = function() {
        return Q(this.b == 5), this.a.P().toString();
    }, se.prototype.readSfixed32String = se.prototype.wc, se.prototype.xc = function() {
        return Q(this.b == 1), this.a.ba();
    }, se.prototype.readSfixed64 = se.prototype.xc, se.prototype.yc = function() {
        return Q(this.b == 1), this.a.ca();
    }, se.prototype.readSfixed64String = se.prototype.yc, se.prototype.aa = function() {
        return Q(this.b == 5), this.a.aa();
    }, se.prototype.readFloat = se.prototype.aa, se.prototype.Z = function() {
        return Q(this.b == 1), this.a.Z();
    }, se.prototype.readDouble = se.prototype.Z, se.prototype.pa = function() {
        return Q(this.b == 0), !!this.a.o();
    }, se.prototype.readBool = se.prototype.pa, se.prototype.ra = function() {
        return Q(this.b == 0), this.a.sa();
    }, se.prototype.readEnum = se.prototype.ra, se.prototype.fa = function() {
        Q(this.b == 2);
        var v = this.a.o();
        return this.a.fa(v);
    }, se.prototype.readString = se.prototype.fa, se.prototype.qa = function() {
        Q(this.b == 2);
        var v = this.a.o();
        return this.a.qa(v);
    }, se.prototype.readBytes = se.prototype.qa, se.prototype.ia = function() {
        return Q(this.b == 0), this.a.ia();
    }, se.prototype.readVarintHash64 = se.prototype.ia, se.prototype.Cc = function() {
        return Q(this.b == 0), this.a.fb();
    }, se.prototype.readSintHash64 = se.prototype.Cc, se.prototype.w = function(v) {
        return Q(this.b == 0), this.a.w(v);
    }, se.prototype.readSplitVarint64 = se.prototype.w, se.prototype.ea = function(v) {
        return Q(this.b == 0), this.a.w(function(B, Y) {
            return je(B, Y, v);
        });
    }, se.prototype.readSplitZigzagVarint64 = se.prototype.ea, se.prototype.$ = function() {
        return Q(this.b == 1), this.a.$();
    }, se.prototype.readFixedHash64 = se.prototype.$, se.prototype.ta = function(v) {
        return Q(this.b == 1), this.a.ta(v);
    }, se.prototype.readSplitFixed64 = se.prototype.ta;
    function rt(v, B) {
        Q(v.b == 2);
        var Y = v.a.o();
        Y = v.a.B() + Y;
        for(var pe = []; v.a.B() < Y;)pe.push(B.call(v.a));
        return pe;
    }
    se.prototype.gc = function() {
        return rt(this, this.a.da);
    }, se.prototype.readPackedInt32 = se.prototype.gc, se.prototype.hc = function() {
        return rt(this, this.a.Ea);
    }, se.prototype.readPackedInt32String = se.prototype.hc, se.prototype.ic = function() {
        return rt(this, this.a.sa);
    }, se.prototype.readPackedInt64 = se.prototype.ic, se.prototype.jc = function() {
        return rt(this, this.a.Fa);
    }, se.prototype.readPackedInt64String = se.prototype.jc, se.prototype.qc = function() {
        return rt(this, this.a.o);
    }, se.prototype.readPackedUint32 = se.prototype.qc, se.prototype.rc = function() {
        return rt(this, this.a.O);
    }, se.prototype.readPackedUint32String = se.prototype.rc, se.prototype.sc = function() {
        return rt(this, this.a.Ga);
    }, se.prototype.readPackedUint64 = se.prototype.sc, se.prototype.tc = function() {
        return rt(this, this.a.Ha);
    }, se.prototype.readPackedUint64String = se.prototype.tc, se.prototype.nc = function() {
        return rt(this, this.a.Ia);
    }, se.prototype.readPackedSint32 = se.prototype.nc, se.prototype.oc = function() {
        return rt(this, this.a.Ja);
    }, se.prototype.readPackedSint64 = se.prototype.oc, se.prototype.pc = function() {
        return rt(this, this.a.Ka);
    }, se.prototype.readPackedSint64String = se.prototype.pc, se.prototype.bc = function() {
        return rt(this, this.a.m);
    }, se.prototype.readPackedFixed32 = se.prototype.bc, se.prototype.cc = function() {
        return rt(this, this.a.ga);
    }, se.prototype.readPackedFixed64 = se.prototype.cc, se.prototype.dc = function() {
        return rt(this, this.a.ha);
    }, se.prototype.readPackedFixed64String = se.prototype.dc, se.prototype.kc = function() {
        return rt(this, this.a.P);
    }, se.prototype.readPackedSfixed32 = se.prototype.kc, se.prototype.lc = function() {
        return rt(this, this.a.ba);
    }, se.prototype.readPackedSfixed64 = se.prototype.lc, se.prototype.mc = function() {
        return rt(this, this.a.ca);
    }, se.prototype.readPackedSfixed64String = se.prototype.mc, se.prototype.fc = function() {
        return rt(this, this.a.aa);
    }, se.prototype.readPackedFloat = se.prototype.fc, se.prototype.$b = function() {
        return rt(this, this.a.Z);
    }, se.prototype.readPackedDouble = se.prototype.$b, se.prototype.Zb = function() {
        return rt(this, this.a.pa);
    }, se.prototype.readPackedBool = se.prototype.Zb, se.prototype.ac = function() {
        return rt(this, this.a.ra);
    }, se.prototype.readPackedEnum = se.prototype.ac, se.prototype.uc = function() {
        return rt(this, this.a.ia);
    }, se.prototype.readPackedVarintHash64 = se.prototype.uc, se.prototype.ec = function() {
        return rt(this, this.a.$);
    }, se.prototype.readPackedFixedHash64 = se.prototype.ec;
    function yt(v, B, Y, pe, ke) {
        this.ma = v, this.Ba = B, this.la = Y, this.Na = pe, this.na = ke;
    }
    p("jspb.ExtensionFieldInfo", yt, void 0);
    function _t(v, B, Y, pe, ke, qe) {
        this.Za = v, this.za = B, this.Aa = Y, this.Wa = pe, this.Ab = ke, this.Nb = qe;
    }
    p("jspb.ExtensionFieldBinaryInfo", _t, void 0), yt.prototype.F = function() {
        return !!this.la;
    }, yt.prototype.isMessageType = yt.prototype.F;
    function Qe() {}
    p("jspb.Message", Qe, void 0), Qe.GENERATE_TO_OBJECT = !0, Qe.GENERATE_FROM_OBJECT = !0;
    var Rt = typeof Uint8Array == "function";
    Qe.prototype.Ib = function() {
        return this.b;
    }, Qe.prototype.getJsPbMessageId = Qe.prototype.Ib, Qe.initialize = function(v, B, Y, pe, ke, qe) {
        v.f = null, B || (B = Y ? [
            Y
        ] : []), v.b = Y ? String(Y) : void 0, v.D = Y === 0 ? -1 : 0, v.u = B;
        e: {
            if (Y = v.u.length, B = -1, Y && (B = Y - 1, Y = v.u[B], !(Y === null || typeof Y != "object" || Array.isArray(Y) || Rt && Y instanceof Uint8Array))) {
                v.G = B - v.D, v.i = Y;
                break e;
            }
            -1 < pe ? (v.G = Math.max(pe, B + 1 - v.D), v.i = null) : v.G = Number.MAX_VALUE;
        }
        if (v.a = {}, ke) for(pe = 0; pe < ke.length; pe++)B = ke[pe], B < v.G ? (B += v.D, v.u[B] = v.u[B] || Lt) : (Ur(v), v.i[B] = v.i[B] || Lt);
        if (qe && qe.length) for(pe = 0; pe < qe.length; pe++)at(v, qe[pe]);
    };
    var Lt = Object.freeze ? Object.freeze([]) : [];
    function Ur(v) {
        var B = v.G + v.D;
        v.u[B] || (v.i = v.u[B] = {});
    }
    function jr(v, B, Y) {
        for(var pe = [], ke = 0; ke < v.length; ke++)pe[ke] = B.call(v[ke], Y, v[ke]);
        return pe;
    }
    Qe.toObjectList = jr, Qe.toObjectExtension = function(v, B, Y, pe, ke) {
        for(var qe in Y){
            var ut = Y[qe], Ft = pe.call(v, ut);
            if (Ft != null) {
                for(var pn in ut.Ba)if (ut.Ba.hasOwnProperty(pn)) break;
                B[pn] = ut.Na ? ut.na ? jr(Ft, ut.Na, ke) : ut.Na(ke, Ft) : Ft;
            }
        }
    }, Qe.serializeBinaryExtensions = function(v, B, Y, pe) {
        for(var ke in Y){
            var qe = Y[ke], ut = qe.Za;
            if (!qe.Aa) throw Error("Message extension present that was generated without binary serialization support");
            var Ft = pe.call(v, ut);
            if (Ft != null) if (ut.F()) if (qe.Wa) qe.Aa.call(B, ut.ma, Ft, qe.Wa);
            else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
            else qe.Aa.call(B, ut.ma, Ft);
        }
    }, Qe.readBinaryExtension = function(v, B, Y, pe, ke) {
        var qe = Y[B.c];
        if (qe) {
            if (Y = qe.Za, !qe.za) throw Error("Deserializing extension whose generated code does not support binary format");
            if (Y.F()) {
                var ut = new Y.la();
                qe.za.call(B, ut, qe.Ab);
            } else ut = qe.za.call(B);
            Y.na && !qe.Nb ? (B = pe.call(v, Y)) ? B.push(ut) : ke.call(v, Y, [
                ut
            ]) : ke.call(v, Y, ut);
        } else B.C();
    };
    function Et(v, B) {
        if (B < v.G) {
            B += v.D;
            var Y = v.u[B];
            return Y === Lt ? v.u[B] = [] : Y;
        }
        if (v.i) return Y = v.i[B], Y === Lt ? v.i[B] = [] : Y;
    }
    Qe.getField = Et, Qe.getRepeatedField = function(v, B) {
        return Et(v, B);
    };
    function Xt(v, B) {
        return v = Et(v, B), v == null ? v : +v;
    }
    Qe.getOptionalFloatingPointField = Xt;
    function wr(v, B) {
        return v = Et(v, B), v == null ? v : !!v;
    }
    Qe.getBooleanField = wr, Qe.getRepeatedFloatingPointField = function(v, B) {
        var Y = Et(v, B);
        if (v.a || (v.a = {}), !v.a[B]) {
            for(var pe = 0; pe < Y.length; pe++)Y[pe] = +Y[pe];
            v.a[B] = !0;
        }
        return Y;
    }, Qe.getRepeatedBooleanField = function(v, B) {
        var Y = Et(v, B);
        if (v.a || (v.a = {}), !v.a[B]) {
            for(var pe = 0; pe < Y.length; pe++)Y[pe] = !!Y[pe];
            v.a[B] = !0;
        }
        return Y;
    };
    function zt(v) {
        return v == null || typeof v == "string" ? v : Rt && v instanceof Uint8Array ? ie(v) : (X("Cannot coerce to b64 string: " + y(v)), null);
    }
    Qe.bytesAsB64 = zt;
    function Ae(v) {
        return v == null || v instanceof Uint8Array ? v : typeof v == "string" ? ue(v) : (X("Cannot coerce to Uint8Array: " + y(v)), null);
    }
    Qe.bytesAsU8 = Ae, Qe.bytesListAsB64 = function(v) {
        return we(v), v.length && typeof v[0] != "string" ? H(v, zt) : v;
    }, Qe.bytesListAsU8 = function(v) {
        return we(v), !v.length || v[0] instanceof Uint8Array ? v : H(v, Ae);
    };
    function we(v) {
        if (v && 1 < v.length) {
            var B = y(v[0]);
            D(v, function(Y) {
                y(Y) != B && X("Inconsistent type in JSPB repeated field array. Got " + y(Y) + " expected " + B);
            });
        }
    }
    function xe(v, B, Y) {
        return v = Et(v, B), v ?? Y;
    }
    Qe.getFieldWithDefault = xe, Qe.getBooleanFieldWithDefault = function(v, B, Y) {
        return v = wr(v, B), v ?? Y;
    }, Qe.getFloatingPointFieldWithDefault = function(v, B, Y) {
        return v = Xt(v, B), v ?? Y;
    }, Qe.getFieldProto3 = xe, Qe.getMapField = function(v, B, Y, pe) {
        if (v.f || (v.f = {}), B in v.f) return v.f[B];
        var ke = Et(v, B);
        if (!ke) {
            if (Y) return;
            ke = [], Me(v, B, ke);
        }
        return v.f[B] = new w(ke, pe);
    };
    function Me(v, B, Y) {
        return $(v, Qe), B < v.G ? v.u[B + v.D] = Y : (Ur(v), v.i[B] = Y), v;
    }
    Qe.setField = Me, Qe.setProto3IntField = function(v, B, Y) {
        return ze(v, B, Y, 0);
    }, Qe.setProto3FloatField = function(v, B, Y) {
        return ze(v, B, Y, 0);
    }, Qe.setProto3BooleanField = function(v, B, Y) {
        return ze(v, B, Y, !1);
    }, Qe.setProto3StringField = function(v, B, Y) {
        return ze(v, B, Y, "");
    }, Qe.setProto3BytesField = function(v, B, Y) {
        return ze(v, B, Y, "");
    }, Qe.setProto3EnumField = function(v, B, Y) {
        return ze(v, B, Y, 0);
    }, Qe.setProto3StringIntField = function(v, B, Y) {
        return ze(v, B, Y, "0");
    };
    function ze(v, B, Y, pe) {
        return $(v, Qe), Y !== pe ? Me(v, B, Y) : B < v.G ? v.u[B + v.D] = null : (Ur(v), delete v.i[B]), v;
    }
    Qe.addToRepeatedField = function(v, B, Y, pe) {
        return $(v, Qe), B = Et(v, B), pe != null ? B.splice(pe, 0, Y) : B.push(Y), v;
    };
    function Ve(v, B, Y, pe) {
        return $(v, Qe), (Y = at(v, Y)) && Y !== B && pe !== void 0 && (v.f && Y in v.f && (v.f[Y] = void 0), Me(v, Y, void 0)), Me(v, B, pe);
    }
    Qe.setOneofField = Ve;
    function at(v, B) {
        for(var Y, pe, ke = 0; ke < B.length; ke++){
            var qe = B[ke], ut = Et(v, qe);
            ut != null && (Y = qe, pe = ut, Me(v, qe, void 0));
        }
        return Y ? (Me(v, Y, pe), Y) : 0;
    }
    Qe.computeOneofCase = at, Qe.getWrapperField = function(v, B, Y, pe) {
        if (v.f || (v.f = {}), !v.f[Y]) {
            var ke = Et(v, Y);
            (pe || ke) && (v.f[Y] = new B(ke));
        }
        return v.f[Y];
    }, Qe.getRepeatedWrapperField = function(v, B, Y) {
        return ct(v, B, Y), B = v.f[Y], B == Lt && (B = v.f[Y] = []), B;
    };
    function ct(v, B, Y) {
        if (v.f || (v.f = {}), !v.f[Y]) {
            for(var pe = Et(v, Y), ke = [], qe = 0; qe < pe.length; qe++)ke[qe] = new B(pe[qe]);
            v.f[Y] = ke;
        }
    }
    Qe.setWrapperField = function(v, B, Y) {
        $(v, Qe), v.f || (v.f = {});
        var pe = Y && Y.g();
        return v.f[B] = Y, Me(v, B, pe);
    }, Qe.setOneofWrapperField = function(v, B, Y, pe) {
        $(v, Qe), v.f || (v.f = {});
        var ke = pe && pe.g();
        return v.f[B] = pe, Ve(v, B, Y, ke);
    }, Qe.setRepeatedWrapperField = function(v, B, Y) {
        $(v, Qe), v.f || (v.f = {}), Y = Y || [];
        for(var pe = [], ke = 0; ke < Y.length; ke++)pe[ke] = Y[ke].g();
        return v.f[B] = Y, Me(v, B, pe);
    }, Qe.addToRepeatedWrapperField = function(v, B, Y, pe, ke) {
        ct(v, pe, B);
        var qe = v.f[B];
        return qe || (qe = v.f[B] = []), Y = Y || new pe(), v = Et(v, B), ke != null ? (qe.splice(ke, 0, Y), v.splice(ke, 0, Y.g())) : (qe.push(Y), v.push(Y.g())), Y;
    }, Qe.toMap = function(v, B, Y, pe) {
        for(var ke = {}, qe = 0; qe < v.length; qe++)ke[B.call(v[qe])] = Y ? Y.call(v[qe], pe, v[qe]) : v[qe];
        return ke;
    };
    function lt(v) {
        if (v.f) for(var B in v.f){
            var Y = v.f[B];
            if (Array.isArray(Y)) for(var pe = 0; pe < Y.length; pe++)Y[pe] && Y[pe].g();
            else Y && Y.g();
        }
    }
    Qe.prototype.g = function() {
        return lt(this), this.u;
    }, Qe.prototype.toArray = Qe.prototype.g, Qe.prototype.toString = function() {
        return lt(this), this.u.toString();
    }, Qe.prototype.getExtension = function(v) {
        if (this.i) {
            this.f || (this.f = {});
            var B = v.ma;
            if (v.na) {
                if (v.F()) return this.f[B] || (this.f[B] = H(this.i[B] || [], function(Y) {
                    return new v.la(Y);
                })), this.f[B];
            } else if (v.F()) return !this.f[B] && this.i[B] && (this.f[B] = new v.la(this.i[B])), this.f[B];
            return this.i[B];
        }
    }, Qe.prototype.getExtension = Qe.prototype.getExtension, Qe.prototype.Kc = function(v, B) {
        this.f || (this.f = {}), Ur(this);
        var Y = v.ma;
        return v.na ? (B = B || [], v.F() ? (this.f[Y] = B, this.i[Y] = H(B, function(pe) {
            return pe.g();
        })) : this.i[Y] = B) : v.F() ? (this.f[Y] = B, this.i[Y] = B && B.g()) : this.i[Y] = B, this;
    }, Qe.prototype.setExtension = Qe.prototype.Kc, Qe.difference = function(v, B) {
        if (!(v instanceof B.constructor)) throw Error("Messages have different types.");
        var Y = v.g();
        B = B.g();
        var pe = [], ke = 0, qe = Y.length > B.length ? Y.length : B.length;
        for(v.b && (pe[0] = v.b, ke = 1); ke < qe; ke++)wt(Y[ke], B[ke]) || (pe[ke] = B[ke]);
        return new v.constructor(pe);
    }, Qe.equals = function(v, B) {
        return v == B || !(!v || !B) && v instanceof B.constructor && wt(v.g(), B.g());
    };
    function mt(v, B) {
        v = v || {}, B = B || {};
        var Y = {}, pe;
        for(pe in v)Y[pe] = 0;
        for(pe in B)Y[pe] = 0;
        for(pe in Y)if (!wt(v[pe], B[pe])) return !1;
        return !0;
    }
    Qe.compareExtensions = mt;
    function wt(v, B) {
        if (v == B) return !0;
        if (!_(v) || !_(B)) return typeof v == "number" && isNaN(v) || typeof B == "number" && isNaN(B) ? String(v) == String(B) : !1;
        if (v.constructor != B.constructor) return !1;
        if (Rt && v.constructor === Uint8Array) {
            if (v.length != B.length) return !1;
            for(var Y = 0; Y < v.length; Y++)if (v[Y] != B[Y]) return !1;
            return !0;
        }
        if (v.constructor === Array) {
            var pe = void 0, ke = void 0, qe = Math.max(v.length, B.length);
            for(Y = 0; Y < qe; Y++){
                var ut = v[Y], Ft = B[Y];
                if (ut && ut.constructor == Object && (Q(pe === void 0), Q(Y === v.length - 1), pe = ut, ut = void 0), Ft && Ft.constructor == Object && (Q(ke === void 0), Q(Y === B.length - 1), ke = Ft, Ft = void 0), !wt(ut, Ft)) return !1;
            }
            return pe || ke ? (pe = pe || {}, ke = ke || {}, mt(pe, ke)) : !0;
        }
        if (v.constructor === Object) return mt(v, B);
        throw Error("Invalid type in JSPB array");
    }
    Qe.compareFields = wt, Qe.prototype.Bb = function() {
        return bt(this);
    }, Qe.prototype.cloneMessage = Qe.prototype.Bb, Qe.prototype.clone = function() {
        return bt(this);
    }, Qe.prototype.clone = Qe.prototype.clone, Qe.clone = function(v) {
        return bt(v);
    };
    function bt(v) {
        return new v.constructor(Mt(v.g()));
    }
    Qe.copyInto = function(v, B) {
        $(v, Qe), $(B, Qe), Q(v.constructor == B.constructor, "Copy source and target message should have the same type."), v = bt(v);
        for(var Y = B.g(), pe = v.g(), ke = Y.length = 0; ke < pe.length; ke++)Y[ke] = pe[ke];
        B.f = v.f, B.i = v.i;
    };
    function Mt(v) {
        if (Array.isArray(v)) {
            for(var B = Array(v.length), Y = 0; Y < v.length; Y++){
                var pe = v[Y];
                pe != null && (B[Y] = typeof pe == "object" ? Mt(Q(pe)) : pe);
            }
            return B;
        }
        if (Rt && v instanceof Uint8Array) return new Uint8Array(v);
        B = {};
        for(Y in v)pe = v[Y], pe != null && (B[Y] = typeof pe == "object" ? Mt(Q(pe)) : pe);
        return B;
    }
    Qe.registerMessageType = function(v, B) {
        B.we = v;
    };
    var Ct = {
        dump: function(v) {
            return $(v, Qe, "jspb.Message instance expected"), Q(v.getExtension, "Only unobfuscated and unoptimized compilation modes supported."), Ct.X(v);
        }
    };
    p("jspb.debug.dump", Ct.dump, void 0), Ct.X = function(v) {
        var B = y(v);
        if (B == "number" || B == "string" || B == "boolean" || B == "null" || B == "undefined" || typeof Uint8Array < "u" && v instanceof Uint8Array) return v;
        if (B == "array") return R(v), H(v, Ct.X);
        if (v instanceof w) {
            var Y = {};
            v = v.entries();
            for(var pe = v.next(); !pe.done; pe = v.next())Y[pe.value[0]] = Ct.X(pe.value[1]);
            return Y;
        }
        $(v, Qe, "Only messages expected: " + v), B = v.constructor;
        var ke = {
            $name: B.name || B.displayName
        };
        for(Ft in B.prototype){
            var qe = /^get([A-Z]\w*)/.exec(Ft);
            if (qe && Ft != "getExtension" && Ft != "getJsPbMessageId") {
                var ut = "has" + qe[1];
                (!v[ut] || v[ut]()) && (ut = v[Ft](), ke[Ct.$a(qe[1])] = Ct.X(ut));
            }
        }
        if (v.extensionObject_) return ke.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", ke;
        for(pe in B.extensions)if (/^\d+$/.test(pe)) {
            ut = B.extensions[pe];
            var Ft = v.getExtension(ut);
            qe = void 0, ut = ut.Ba;
            var pn = [], bs = 0;
            for(qe in ut)pn[bs++] = qe;
            qe = pn[0], Ft != null && (Y || (Y = ke.$extensions = {}), Y[Ct.$a(qe)] = Ct.X(Ft));
        }
        return ke;
    }, Ct.$a = function(v) {
        return v.replace(/^[A-Z]/, function(B) {
            return B.toLowerCase();
        });
    };
    function Xe() {
        this.a = [];
    }
    p("jspb.BinaryEncoder", Xe, void 0), Xe.prototype.length = function() {
        return this.a.length;
    }, Xe.prototype.length = Xe.prototype.length, Xe.prototype.end = function() {
        var v = this.a;
        return this.a = [], v;
    }, Xe.prototype.end = Xe.prototype.end, Xe.prototype.l = function(v, B) {
        for(Q(v == Math.floor(v)), Q(B == Math.floor(B)), Q(0 <= v && 4294967296 > v), Q(0 <= B && 4294967296 > B); 0 < B || 127 < v;)this.a.push(v & 127 | 128), v = (v >>> 7 | B << 25) >>> 0, B >>>= 7;
        this.a.push(v);
    }, Xe.prototype.writeSplitVarint64 = Xe.prototype.l, Xe.prototype.A = function(v, B) {
        Q(v == Math.floor(v)), Q(B == Math.floor(B)), Q(0 <= v && 4294967296 > v), Q(0 <= B && 4294967296 > B), this.s(v), this.s(B);
    }, Xe.prototype.writeSplitFixed64 = Xe.prototype.A, Xe.prototype.j = function(v) {
        for(Q(v == Math.floor(v)), Q(0 <= v && 4294967296 > v); 127 < v;)this.a.push(v & 127 | 128), v >>>= 7;
        this.a.push(v);
    }, Xe.prototype.writeUnsignedVarint32 = Xe.prototype.j, Xe.prototype.M = function(v) {
        if (Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), 0 <= v) this.j(v);
        else {
            for(var B = 0; 9 > B; B++)this.a.push(v & 127 | 128), v >>= 7;
            this.a.push(1);
        }
    }, Xe.prototype.writeSignedVarint32 = Xe.prototype.M, Xe.prototype.va = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 18446744073709552e3 > v), Se(v), this.l(ee, ae);
    }, Xe.prototype.writeUnsignedVarint64 = Xe.prototype.va, Xe.prototype.ua = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= v && 9223372036854776e3 > v), Se(v), this.l(ee, ae);
    }, Xe.prototype.writeSignedVarint64 = Xe.prototype.ua, Xe.prototype.wa = function(v) {
        Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), this.j((v << 1 ^ v >> 31) >>> 0);
    }, Xe.prototype.writeZigzagVarint32 = Xe.prototype.wa, Xe.prototype.xa = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= v && 9223372036854776e3 > v), De(v), this.l(ee, ae);
    }, Xe.prototype.writeZigzagVarint64 = Xe.prototype.xa, Xe.prototype.Ta = function(v) {
        this.W(fe(v));
    }, Xe.prototype.writeZigzagVarint64String = Xe.prototype.Ta, Xe.prototype.W = function(v) {
        var B = this;
        M(v), _e(ee, ae, function(Y, pe) {
            B.l(Y >>> 0, pe >>> 0);
        });
    }, Xe.prototype.writeZigzagVarintHash64 = Xe.prototype.W, Xe.prototype.be = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 256 > v), this.a.push(v >>> 0 & 255);
    }, Xe.prototype.writeUint8 = Xe.prototype.be, Xe.prototype.ae = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 65536 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255);
    }, Xe.prototype.writeUint16 = Xe.prototype.ae, Xe.prototype.s = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 4294967296 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255), this.a.push(v >>> 16 & 255), this.a.push(v >>> 24 & 255);
    }, Xe.prototype.writeUint32 = Xe.prototype.s, Xe.prototype.V = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 18446744073709552e3 > v), ye(v), this.s(ee), this.s(ae);
    }, Xe.prototype.writeUint64 = Xe.prototype.V, Xe.prototype.Qc = function(v) {
        Q(v == Math.floor(v)), Q(-128 <= v && 128 > v), this.a.push(v >>> 0 & 255);
    }, Xe.prototype.writeInt8 = Xe.prototype.Qc, Xe.prototype.Pc = function(v) {
        Q(v == Math.floor(v)), Q(-32768 <= v && 32768 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255);
    }, Xe.prototype.writeInt16 = Xe.prototype.Pc, Xe.prototype.S = function(v) {
        Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255), this.a.push(v >>> 16 & 255), this.a.push(v >>> 24 & 255);
    }, Xe.prototype.writeInt32 = Xe.prototype.S, Xe.prototype.T = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= v && 9223372036854776e3 > v), Se(v), this.A(ee, ae);
    }, Xe.prototype.writeInt64 = Xe.prototype.T, Xe.prototype.ka = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= +v && 9223372036854776e3 > +v), M(fe(v)), this.A(ee, ae);
    }, Xe.prototype.writeInt64String = Xe.prototype.ka, Xe.prototype.L = function(v) {
        Q(v === 1 / 0 || v === -1 / 0 || isNaN(v) || -34028234663852886e22 <= v && 34028234663852886e22 >= v), Re(v), this.s(ee);
    }, Xe.prototype.writeFloat = Xe.prototype.L, Xe.prototype.J = function(v) {
        Q(v === 1 / 0 || v === -1 / 0 || isNaN(v) || -17976931348623157e292 <= v && 17976931348623157e292 >= v), Ce(v), this.s(ee), this.s(ae);
    }, Xe.prototype.writeDouble = Xe.prototype.J, Xe.prototype.I = function(v) {
        Q(typeof v == "boolean" || typeof v == "number"), this.a.push(v ? 1 : 0);
    }, Xe.prototype.writeBool = Xe.prototype.I, Xe.prototype.R = function(v) {
        Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), this.M(v);
    }, Xe.prototype.writeEnum = Xe.prototype.R, Xe.prototype.ja = function(v) {
        this.a.push.apply(this.a, v);
    }, Xe.prototype.writeBytes = Xe.prototype.ja, Xe.prototype.N = function(v) {
        M(v), this.l(ee, ae);
    }, Xe.prototype.writeVarintHash64 = Xe.prototype.N, Xe.prototype.K = function(v) {
        M(v), this.s(ee), this.s(ae);
    }, Xe.prototype.writeFixedHash64 = Xe.prototype.K, Xe.prototype.U = function(v) {
        var B = this.a.length;
        G(v);
        for(var Y = 0; Y < v.length; Y++){
            var pe = v.charCodeAt(Y);
            if (128 > pe) this.a.push(pe);
            else if (2048 > pe) this.a.push(pe >> 6 | 192), this.a.push(pe & 63 | 128);
            else if (65536 > pe) if (55296 <= pe && 56319 >= pe && Y + 1 < v.length) {
                var ke = v.charCodeAt(Y + 1);
                56320 <= ke && 57343 >= ke && (pe = 1024 * (pe - 55296) + ke - 56320 + 65536, this.a.push(pe >> 18 | 240), this.a.push(pe >> 12 & 63 | 128), this.a.push(pe >> 6 & 63 | 128), this.a.push(pe & 63 | 128), Y++);
            } else this.a.push(pe >> 12 | 224), this.a.push(pe >> 6 & 63 | 128), this.a.push(pe & 63 | 128);
        }
        return this.a.length - B;
    }, Xe.prototype.writeString = Xe.prototype.U;
    function xt(v, B) {
        this.lo = v, this.hi = B;
    }
    p("jspb.arith.UInt64", xt, void 0), xt.prototype.cmp = function(v) {
        return this.hi < v.hi || this.hi == v.hi && this.lo < v.lo ? -1 : this.hi == v.hi && this.lo == v.lo ? 0 : 1;
    }, xt.prototype.cmp = xt.prototype.cmp, xt.prototype.La = function() {
        return new xt((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
    }, xt.prototype.rightShift = xt.prototype.La, xt.prototype.Da = function() {
        return new xt(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
    }, xt.prototype.leftShift = xt.prototype.Da, xt.prototype.cb = function() {
        return !!(this.hi & 2147483648);
    }, xt.prototype.msb = xt.prototype.cb, xt.prototype.Ob = function() {
        return !!(this.lo & 1);
    }, xt.prototype.lsb = xt.prototype.Ob, xt.prototype.Ua = function() {
        return this.lo == 0 && this.hi == 0;
    }, xt.prototype.zero = xt.prototype.Ua, xt.prototype.add = function(v) {
        return new xt((this.lo + v.lo & 4294967295) >>> 0 >>> 0, ((this.hi + v.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + v.lo ? 1 : 0) >>> 0);
    }, xt.prototype.add = xt.prototype.add, xt.prototype.sub = function(v) {
        return new xt((this.lo - v.lo & 4294967295) >>> 0 >>> 0, ((this.hi - v.hi & 4294967295) >>> 0) - (0 > this.lo - v.lo ? 1 : 0) >>> 0);
    }, xt.prototype.sub = xt.prototype.sub;
    function St(v, B) {
        var Y = v & 65535;
        v >>>= 16;
        var pe = B & 65535, ke = B >>> 16;
        for(B = Y * pe + 65536 * (Y * ke & 65535) + 65536 * (v * pe & 65535), Y = v * ke + (Y * ke >>> 16) + (v * pe >>> 16); 4294967296 <= B;)B -= 4294967296, Y += 1;
        return new xt(B >>> 0, Y >>> 0);
    }
    xt.mul32x32 = St, xt.prototype.eb = function(v) {
        var B = St(this.lo, v);
        return v = St(this.hi, v), v.hi = v.lo, v.lo = 0, B.add(v);
    }, xt.prototype.mul = xt.prototype.eb, xt.prototype.Xa = function(v) {
        if (v == 0) return [];
        var B = new xt(0, 0), Y = new xt(this.lo, this.hi);
        v = new xt(v, 0);
        for(var pe = new xt(1, 0); !v.cb();)v = v.Da(), pe = pe.Da();
        for(; !pe.Ua();)0 >= v.cmp(Y) && (B = B.add(pe), Y = Y.sub(v)), v = v.La(), pe = pe.La();
        return [
            B,
            Y
        ];
    }, xt.prototype.div = xt.prototype.Xa, xt.prototype.toString = function() {
        for(var v = "", B = this; !B.Ua();){
            B = B.Xa(10);
            var Y = B[0];
            v = B[1].lo + v, B = Y;
        }
        return v == "" && (v = "0"), v;
    }, xt.prototype.toString = xt.prototype.toString;
    function Pe(v) {
        for(var B = new xt(0, 0), Y = new xt(0, 0), pe = 0; pe < v.length; pe++){
            if ("0" > v[pe] || "9" < v[pe]) return null;
            Y.lo = parseInt(v[pe], 10), B = B.eb(10).add(Y);
        }
        return B;
    }
    xt.fromString = Pe, xt.prototype.clone = function() {
        return new xt(this.lo, this.hi);
    }, xt.prototype.clone = xt.prototype.clone;
    function et(v, B) {
        this.lo = v, this.hi = B;
    }
    p("jspb.arith.Int64", et, void 0), et.prototype.add = function(v) {
        return new et((this.lo + v.lo & 4294967295) >>> 0 >>> 0, ((this.hi + v.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + v.lo ? 1 : 0) >>> 0);
    }, et.prototype.add = et.prototype.add, et.prototype.sub = function(v) {
        return new et((this.lo - v.lo & 4294967295) >>> 0 >>> 0, ((this.hi - v.hi & 4294967295) >>> 0) - (0 > this.lo - v.lo ? 1 : 0) >>> 0);
    }, et.prototype.sub = et.prototype.sub, et.prototype.clone = function() {
        return new et(this.lo, this.hi);
    }, et.prototype.clone = et.prototype.clone, et.prototype.toString = function() {
        var v = (this.hi & 2147483648) != 0, B = new xt(this.lo, this.hi);
        return v && (B = new xt(0, 0).sub(B)), (v ? "-" : "") + B.toString();
    }, et.prototype.toString = et.prototype.toString;
    function vt(v) {
        var B = 0 < v.length && v[0] == "-";
        return B && (v = v.substring(1)), v = Pe(v), v === null ? null : (B && (v = new xt(0, 0).sub(v)), new et(v.lo, v.hi));
    }
    et.fromString = vt;
    function be() {
        this.c = [], this.b = 0, this.a = new Xe(), this.h = [];
    }
    p("jspb.BinaryWriter", be, void 0);
    function $r(v, B) {
        var Y = v.a.end();
        v.c.push(Y), v.c.push(B), v.b += Y.length + B.length;
    }
    function jt(v, B) {
        return kt(v, B, 2), B = v.a.end(), v.c.push(B), v.b += B.length, B.push(v.b), B;
    }
    function nr(v, B) {
        var Y = B.pop();
        for(Y = v.b + v.a.length() - Y, Q(0 <= Y); 127 < Y;)B.push(Y & 127 | 128), Y >>>= 7, v.b++;
        B.push(Y), v.b++;
    }
    be.prototype.pb = function(v, B, Y) {
        $r(this, v.subarray(B, Y));
    }, be.prototype.writeSerializedMessage = be.prototype.pb, be.prototype.Pb = function(v, B, Y) {
        v != null && B != null && Y != null && this.pb(v, B, Y);
    }, be.prototype.maybeWriteSerializedMessage = be.prototype.Pb, be.prototype.reset = function() {
        this.c = [], this.a.end(), this.b = 0, this.h = [];
    }, be.prototype.reset = be.prototype.reset, be.prototype.ab = function() {
        Q(this.h.length == 0);
        for(var v = new Uint8Array(this.b + this.a.length()), B = this.c, Y = B.length, pe = 0, ke = 0; ke < Y; ke++){
            var qe = B[ke];
            v.set(qe, pe), pe += qe.length;
        }
        return B = this.a.end(), v.set(B, pe), pe += B.length, Q(pe == v.length), this.c = [
            v
        ], v;
    }, be.prototype.getResultBuffer = be.prototype.ab, be.prototype.Kb = function(v) {
        return ie(this.ab(), v);
    }, be.prototype.getResultBase64String = be.prototype.Kb, be.prototype.Va = function(v) {
        this.h.push(jt(this, v));
    }, be.prototype.beginSubMessage = be.prototype.Va, be.prototype.Ya = function() {
        Q(0 <= this.h.length), nr(this, this.h.pop());
    }, be.prototype.endSubMessage = be.prototype.Ya;
    function kt(v, B, Y) {
        Q(1 <= B && B == Math.floor(B)), v.a.j(8 * B + Y);
    }
    be.prototype.Nc = function(v, B, Y) {
        switch(v){
            case 1:
                this.J(B, Y);
                break;
            case 2:
                this.L(B, Y);
                break;
            case 3:
                this.T(B, Y);
                break;
            case 4:
                this.V(B, Y);
                break;
            case 5:
                this.S(B, Y);
                break;
            case 6:
                this.Qa(B, Y);
                break;
            case 7:
                this.Pa(B, Y);
                break;
            case 8:
                this.I(B, Y);
                break;
            case 9:
                this.U(B, Y);
                break;
            case 10:
                X("Group field type not supported in writeAny()");
                break;
            case 11:
                X("Message field type not supported in writeAny()");
                break;
            case 12:
                this.ja(B, Y);
                break;
            case 13:
                this.s(B, Y);
                break;
            case 14:
                this.R(B, Y);
                break;
            case 15:
                this.Ra(B, Y);
                break;
            case 16:
                this.Sa(B, Y);
                break;
            case 17:
                this.rb(B, Y);
                break;
            case 18:
                this.sb(B, Y);
                break;
            case 30:
                this.K(B, Y);
                break;
            case 31:
                this.N(B, Y);
                break;
            default:
                X("Invalid field type in writeAny()");
        }
    }, be.prototype.writeAny = be.prototype.Nc;
    function Hn(v, B, Y) {
        Y != null && (kt(v, B, 0), v.a.j(Y));
    }
    function Zr(v, B, Y) {
        Y != null && (kt(v, B, 0), v.a.M(Y));
    }
    be.prototype.S = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), Zr(this, v, B));
    }, be.prototype.writeInt32 = be.prototype.S, be.prototype.ob = function(v, B) {
        B != null && (B = parseInt(B, 10), Q(-2147483648 <= B && 2147483648 > B), Zr(this, v, B));
    }, be.prototype.writeInt32String = be.prototype.ob, be.prototype.T = function(v, B) {
        B != null && (Q(-9223372036854776e3 <= B && 9223372036854776e3 > B), B != null && (kt(this, v, 0), this.a.ua(B)));
    }, be.prototype.writeInt64 = be.prototype.T, be.prototype.ka = function(v, B) {
        B != null && (B = vt(B), kt(this, v, 0), this.a.l(B.lo, B.hi));
    }, be.prototype.writeInt64String = be.prototype.ka, be.prototype.s = function(v, B) {
        B != null && (Q(0 <= B && 4294967296 > B), Hn(this, v, B));
    }, be.prototype.writeUint32 = be.prototype.s, be.prototype.ub = function(v, B) {
        B != null && (B = parseInt(B, 10), Q(0 <= B && 4294967296 > B), Hn(this, v, B));
    }, be.prototype.writeUint32String = be.prototype.ub, be.prototype.V = function(v, B) {
        B != null && (Q(0 <= B && 18446744073709552e3 > B), B != null && (kt(this, v, 0), this.a.va(B)));
    }, be.prototype.writeUint64 = be.prototype.V, be.prototype.vb = function(v, B) {
        B != null && (B = Pe(B), kt(this, v, 0), this.a.l(B.lo, B.hi));
    }, be.prototype.writeUint64String = be.prototype.vb, be.prototype.rb = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), B != null && (kt(this, v, 0), this.a.wa(B)));
    }, be.prototype.writeSint32 = be.prototype.rb, be.prototype.sb = function(v, B) {
        B != null && (Q(-9223372036854776e3 <= B && 9223372036854776e3 > B), B != null && (kt(this, v, 0), this.a.xa(B)));
    }, be.prototype.writeSint64 = be.prototype.sb, be.prototype.$d = function(v, B) {
        B != null && B != null && (kt(this, v, 0), this.a.W(B));
    }, be.prototype.writeSintHash64 = be.prototype.$d, be.prototype.Zd = function(v, B) {
        B != null && B != null && (kt(this, v, 0), this.a.Ta(B));
    }, be.prototype.writeSint64String = be.prototype.Zd, be.prototype.Pa = function(v, B) {
        B != null && (Q(0 <= B && 4294967296 > B), kt(this, v, 5), this.a.s(B));
    }, be.prototype.writeFixed32 = be.prototype.Pa, be.prototype.Qa = function(v, B) {
        B != null && (Q(0 <= B && 18446744073709552e3 > B), kt(this, v, 1), this.a.V(B));
    }, be.prototype.writeFixed64 = be.prototype.Qa, be.prototype.nb = function(v, B) {
        B != null && (B = Pe(B), kt(this, v, 1), this.a.A(B.lo, B.hi));
    }, be.prototype.writeFixed64String = be.prototype.nb, be.prototype.Ra = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), kt(this, v, 5), this.a.S(B));
    }, be.prototype.writeSfixed32 = be.prototype.Ra, be.prototype.Sa = function(v, B) {
        B != null && (Q(-9223372036854776e3 <= B && 9223372036854776e3 > B), kt(this, v, 1), this.a.T(B));
    }, be.prototype.writeSfixed64 = be.prototype.Sa, be.prototype.qb = function(v, B) {
        B != null && (B = vt(B), kt(this, v, 1), this.a.A(B.lo, B.hi));
    }, be.prototype.writeSfixed64String = be.prototype.qb, be.prototype.L = function(v, B) {
        B != null && (kt(this, v, 5), this.a.L(B));
    }, be.prototype.writeFloat = be.prototype.L, be.prototype.J = function(v, B) {
        B != null && (kt(this, v, 1), this.a.J(B));
    }, be.prototype.writeDouble = be.prototype.J, be.prototype.I = function(v, B) {
        B != null && (Q(typeof B == "boolean" || typeof B == "number"), kt(this, v, 0), this.a.I(B));
    }, be.prototype.writeBool = be.prototype.I, be.prototype.R = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), kt(this, v, 0), this.a.M(B));
    }, be.prototype.writeEnum = be.prototype.R, be.prototype.U = function(v, B) {
        B != null && (v = jt(this, v), this.a.U(B), nr(this, v));
    }, be.prototype.writeString = be.prototype.U, be.prototype.ja = function(v, B) {
        B != null && (B = V(B), kt(this, v, 2), this.a.j(B.length), $r(this, B));
    }, be.prototype.writeBytes = be.prototype.ja, be.prototype.Rc = function(v, B, Y) {
        B != null && (v = jt(this, v), Y(B, this), nr(this, v));
    }, be.prototype.writeMessage = be.prototype.Rc, be.prototype.Sc = function(v, B, Y) {
        B != null && (kt(this, 1, 3), kt(this, 2, 0), this.a.M(v), v = jt(this, 3), Y(B, this), nr(this, v), kt(this, 1, 4));
    }, be.prototype.writeMessageSet = be.prototype.Sc, be.prototype.Oc = function(v, B, Y) {
        B != null && (kt(this, v, 3), Y(B, this), kt(this, v, 4));
    }, be.prototype.writeGroup = be.prototype.Oc, be.prototype.K = function(v, B) {
        B != null && (Q(B.length == 8), kt(this, v, 1), this.a.K(B));
    }, be.prototype.writeFixedHash64 = be.prototype.K, be.prototype.N = function(v, B) {
        B != null && (Q(B.length == 8), kt(this, v, 0), this.a.N(B));
    }, be.prototype.writeVarintHash64 = be.prototype.N, be.prototype.A = function(v, B, Y) {
        kt(this, v, 1), this.a.A(B, Y);
    }, be.prototype.writeSplitFixed64 = be.prototype.A, be.prototype.l = function(v, B, Y) {
        kt(this, v, 0), this.a.l(B, Y);
    }, be.prototype.writeSplitVarint64 = be.prototype.l, be.prototype.tb = function(v, B, Y) {
        kt(this, v, 0);
        var pe = this.a;
        _e(B, Y, function(ke, qe) {
            pe.l(ke >>> 0, qe >>> 0);
        });
    }, be.prototype.writeSplitZigzagVarint64 = be.prototype.tb, be.prototype.Ed = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)Zr(this, v, B[Y]);
    }, be.prototype.writeRepeatedInt32 = be.prototype.Ed, be.prototype.Fd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ob(v, B[Y]);
    }, be.prototype.writeRepeatedInt32String = be.prototype.Fd, be.prototype.Gd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.ua(pe));
        }
    }, be.prototype.writeRepeatedInt64 = be.prototype.Gd, be.prototype.Qd = function(v, B, Y, pe) {
        if (B != null) for(var ke = 0; ke < B.length; ke++)this.A(v, Y(B[ke]), pe(B[ke]));
    }, be.prototype.writeRepeatedSplitFixed64 = be.prototype.Qd, be.prototype.Rd = function(v, B, Y, pe) {
        if (B != null) for(var ke = 0; ke < B.length; ke++)this.l(v, Y(B[ke]), pe(B[ke]));
    }, be.prototype.writeRepeatedSplitVarint64 = be.prototype.Rd, be.prototype.Sd = function(v, B, Y, pe) {
        if (B != null) for(var ke = 0; ke < B.length; ke++)this.tb(v, Y(B[ke]), pe(B[ke]));
    }, be.prototype.writeRepeatedSplitZigzagVarint64 = be.prototype.Sd, be.prototype.Hd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ka(v, B[Y]);
    }, be.prototype.writeRepeatedInt64String = be.prototype.Hd, be.prototype.Ud = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)Hn(this, v, B[Y]);
    }, be.prototype.writeRepeatedUint32 = be.prototype.Ud, be.prototype.Vd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ub(v, B[Y]);
    }, be.prototype.writeRepeatedUint32String = be.prototype.Vd, be.prototype.Wd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.va(pe));
        }
    }, be.prototype.writeRepeatedUint64 = be.prototype.Wd, be.prototype.Xd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.vb(v, B[Y]);
    }, be.prototype.writeRepeatedUint64String = be.prototype.Xd, be.prototype.Md = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.wa(pe));
        }
    }, be.prototype.writeRepeatedSint32 = be.prototype.Md, be.prototype.Nd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.xa(pe));
        }
    }, be.prototype.writeRepeatedSint64 = be.prototype.Nd, be.prototype.Od = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.Ta(pe));
        }
    }, be.prototype.writeRepeatedSint64String = be.prototype.Od, be.prototype.Pd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.W(pe));
        }
    }, be.prototype.writeRepeatedSintHash64 = be.prototype.Pd, be.prototype.yd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Pa(v, B[Y]);
    }, be.prototype.writeRepeatedFixed32 = be.prototype.yd, be.prototype.zd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Qa(v, B[Y]);
    }, be.prototype.writeRepeatedFixed64 = be.prototype.zd, be.prototype.Ad = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.nb(v, B[Y]);
    }, be.prototype.writeRepeatedFixed64String = be.prototype.Ad, be.prototype.Jd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Ra(v, B[Y]);
    }, be.prototype.writeRepeatedSfixed32 = be.prototype.Jd, be.prototype.Kd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Sa(v, B[Y]);
    }, be.prototype.writeRepeatedSfixed64 = be.prototype.Kd, be.prototype.Ld = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.qb(v, B[Y]);
    }, be.prototype.writeRepeatedSfixed64String = be.prototype.Ld, be.prototype.Cd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.L(v, B[Y]);
    }, be.prototype.writeRepeatedFloat = be.prototype.Cd, be.prototype.wd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.J(v, B[Y]);
    }, be.prototype.writeRepeatedDouble = be.prototype.wd, be.prototype.ud = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.I(v, B[Y]);
    }, be.prototype.writeRepeatedBool = be.prototype.ud, be.prototype.xd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.R(v, B[Y]);
    }, be.prototype.writeRepeatedEnum = be.prototype.xd, be.prototype.Td = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.U(v, B[Y]);
    }, be.prototype.writeRepeatedString = be.prototype.Td, be.prototype.vd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ja(v, B[Y]);
    }, be.prototype.writeRepeatedBytes = be.prototype.vd, be.prototype.Id = function(v, B, Y) {
        if (B != null) for(var pe = 0; pe < B.length; pe++){
            var ke = jt(this, v);
            Y(B[pe], this), nr(this, ke);
        }
    }, be.prototype.writeRepeatedMessage = be.prototype.Id, be.prototype.Dd = function(v, B, Y) {
        if (B != null) for(var pe = 0; pe < B.length; pe++)kt(this, v, 3), Y(B[pe], this), kt(this, v, 4);
    }, be.prototype.writeRepeatedGroup = be.prototype.Dd, be.prototype.Bd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.K(v, B[Y]);
    }, be.prototype.writeRepeatedFixedHash64 = be.prototype.Bd, be.prototype.Yd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.N(v, B[Y]);
    }, be.prototype.writeRepeatedVarintHash64 = be.prototype.Yd, be.prototype.ad = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.M(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedInt32 = be.prototype.ad, be.prototype.bd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.M(parseInt(B[Y], 10));
            nr(this, v);
        }
    }, be.prototype.writePackedInt32String = be.prototype.bd, be.prototype.cd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.ua(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedInt64 = be.prototype.cd, be.prototype.md = function(v, B, Y, pe) {
        if (B != null) {
            v = jt(this, v);
            for(var ke = 0; ke < B.length; ke++)this.a.A(Y(B[ke]), pe(B[ke]));
            nr(this, v);
        }
    }, be.prototype.writePackedSplitFixed64 = be.prototype.md, be.prototype.nd = function(v, B, Y, pe) {
        if (B != null) {
            v = jt(this, v);
            for(var ke = 0; ke < B.length; ke++)this.a.l(Y(B[ke]), pe(B[ke]));
            nr(this, v);
        }
    }, be.prototype.writePackedSplitVarint64 = be.prototype.nd, be.prototype.od = function(v, B, Y, pe) {
        if (B != null) {
            v = jt(this, v);
            for(var ke = this.a, qe = 0; qe < B.length; qe++)_e(Y(B[qe]), pe(B[qe]), function(ut, Ft) {
                ke.l(ut >>> 0, Ft >>> 0);
            });
            nr(this, v);
        }
    }, be.prototype.writePackedSplitZigzagVarint64 = be.prototype.od, be.prototype.dd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++){
                var pe = vt(B[Y]);
                this.a.l(pe.lo, pe.hi);
            }
            nr(this, v);
        }
    }, be.prototype.writePackedInt64String = be.prototype.dd, be.prototype.pd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.j(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedUint32 = be.prototype.pd, be.prototype.qd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.j(parseInt(B[Y], 10));
            nr(this, v);
        }
    }, be.prototype.writePackedUint32String = be.prototype.qd, be.prototype.rd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.va(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedUint64 = be.prototype.rd, be.prototype.sd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++){
                var pe = Pe(B[Y]);
                this.a.l(pe.lo, pe.hi);
            }
            nr(this, v);
        }
    }, be.prototype.writePackedUint64String = be.prototype.sd, be.prototype.hd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.wa(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedSint32 = be.prototype.hd, be.prototype.jd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.xa(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedSint64 = be.prototype.jd, be.prototype.kd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.W(fe(B[Y]));
            nr(this, v);
        }
    }, be.prototype.writePackedSint64String = be.prototype.kd, be.prototype.ld = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.W(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedSintHash64 = be.prototype.ld, be.prototype.Wc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(4 * B.length), v = 0; v < B.length; v++)this.a.s(B[v]);
    }, be.prototype.writePackedFixed32 = be.prototype.Wc, be.prototype.Xc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.V(B[v]);
    }, be.prototype.writePackedFixed64 = be.prototype.Xc, be.prototype.Yc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++){
            var Y = Pe(B[v]);
            this.a.A(Y.lo, Y.hi);
        }
    }, be.prototype.writePackedFixed64String = be.prototype.Yc, be.prototype.ed = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(4 * B.length), v = 0; v < B.length; v++)this.a.S(B[v]);
    }, be.prototype.writePackedSfixed32 = be.prototype.ed, be.prototype.fd = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.T(B[v]);
    }, be.prototype.writePackedSfixed64 = be.prototype.fd, be.prototype.gd = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.ka(B[v]);
    }, be.prototype.writePackedSfixed64String = be.prototype.gd, be.prototype.$c = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(4 * B.length), v = 0; v < B.length; v++)this.a.L(B[v]);
    }, be.prototype.writePackedFloat = be.prototype.$c, be.prototype.Uc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.J(B[v]);
    }, be.prototype.writePackedDouble = be.prototype.Uc, be.prototype.Tc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(B.length), v = 0; v < B.length; v++)this.a.I(B[v]);
    }, be.prototype.writePackedBool = be.prototype.Tc, be.prototype.Vc = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.R(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedEnum = be.prototype.Vc, be.prototype.Zc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.K(B[v]);
    }, be.prototype.writePackedFixedHash64 = be.prototype.Zc, be.prototype.td = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.N(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedVarintHash64 = be.prototype.td, e.debug = Ct, e.Map = w, e.Message = Qe, e.BinaryReader = se, e.BinaryWriter = be, e.ExtensionFieldInfo = yt, e.ExtensionFieldBinaryInfo = _t, e.exportSymbol = A, e.inherits = O, e.object = {
        extend: U
    }, e.typeOf = y;
})(rS);
var tne = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), rne = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), nne = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && tne(t, e, r);
    return rne(t, e), t;
}, yn = Ge && Ge.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
};
Object.defineProperty(Lf, "__esModule", {
    value: !0
});
Lf.protorune = void 0;
const Be = nne(rS);
var Ck;
(function(e) {
    var t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U, D, H, K, re, Q, G;
    class R extends Be.Message {
        constructor(M){
            super(), t.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, t, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "txindex" in M && M.txindex != null && (this.txindex = M.txindex));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        get txindex() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set txindex(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new R({});
            return M.height != null && (z.height = M.height), M.txindex != null && (z.txindex = M.txindex), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), this.txindex != null && (M.txindex = this.txindex), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint32(1, this.height), this.txindex != 0 && z.writeUint32(2, this.txindex), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new R();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint32();
                    break;
                case 2:
                    de.txindex = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return R.deserialize(M);
        }
    }
    t = /* @__PURE__ */ new WeakMap(), e.RuneId = R;
    class X extends Be.Message {
        constructor(M){
            super(), r.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, r, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "transaction" in M && M.transaction != null && (this.transaction = M.transaction));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        get transaction() {
            return Be.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set transaction(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new X({});
            return M.height != null && (z.height = M.height), M.transaction != null && (z.transaction = M.transaction), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), this.transaction != null && (M.transaction = this.transaction), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint64(1, this.height), this.transaction.length && z.writeBytes(2, this.transaction), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new X();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint64();
                    break;
                case 2:
                    de.transaction = z.readBytes();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return X.deserialize(M);
        }
    }
    r = /* @__PURE__ */ new WeakMap(), e.TransactionRecord = X;
    class $ extends Be.Message {
        constructor(M){
            super(), n.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, n, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "txindex" in M && M.txindex != null && (this.txindex = M.txindex));
        }
        get height() {
            return Be.Message.getWrapperField(this, he, 1);
        }
        set height(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_height() {
            return Be.Message.getField(this, 1) != null;
        }
        get txindex() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set txindex(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_txindex() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new $({});
            return M.height != null && (z.height = he.fromObject(M.height)), M.txindex != null && (z.txindex = he.fromObject(M.txindex)), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height.toObject()), this.txindex != null && (M.txindex = this.txindex.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_height && z.writeMessage(1, this.height, ()=>this.height.serialize(z)), this.has_txindex && z.writeMessage(2, this.txindex, ()=>this.txindex.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new $();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.height, ()=>de.height = he.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.txindex, ()=>de.txindex = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return $.deserialize(M);
        }
    }
    n = /* @__PURE__ */ new WeakMap(), e.ProtoruneRuneId = $;
    class S extends Be.Message {
        constructor(M){
            super(), i.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, i, "f")), !Array.isArray(M) && typeof M == "object" && ("runeId" in M && M.runeId != null && (this.runeId = M.runeId), "name" in M && M.name != null && (this.name = M.name), "divisibility" in M && M.divisibility != null && (this.divisibility = M.divisibility), "spacers" in M && M.spacers != null && (this.spacers = M.spacers), "symbol" in M && M.symbol != null && (this.symbol = M.symbol), "runes_symbol" in M && M.runes_symbol != null && (this.runes_symbol = M.runes_symbol));
        }
        get runeId() {
            return Be.Message.getWrapperField(this, $, 1);
        }
        set runeId(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_runeId() {
            return Be.Message.getField(this, 1) != null;
        }
        get name() {
            return Be.Message.getFieldWithDefault(this, 2, "");
        }
        set name(M) {
            Be.Message.setField(this, 2, M);
        }
        get divisibility() {
            return Be.Message.getFieldWithDefault(this, 3, 0);
        }
        set divisibility(M) {
            Be.Message.setField(this, 3, M);
        }
        get spacers() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set spacers(M) {
            Be.Message.setField(this, 4, M);
        }
        get symbol() {
            return Be.Message.getFieldWithDefault(this, 5, "");
        }
        set symbol(M) {
            Be.Message.setField(this, 5, M);
        }
        get runes_symbol() {
            return Be.Message.getFieldWithDefault(this, 6, 0);
        }
        set runes_symbol(M) {
            Be.Message.setField(this, 6, M);
        }
        static fromObject(M) {
            const z = new S({});
            return M.runeId != null && (z.runeId = $.fromObject(M.runeId)), M.name != null && (z.name = M.name), M.divisibility != null && (z.divisibility = M.divisibility), M.spacers != null && (z.spacers = M.spacers), M.symbol != null && (z.symbol = M.symbol), M.runes_symbol != null && (z.runes_symbol = M.runes_symbol), z;
        }
        toObject() {
            const M = {};
            return this.runeId != null && (M.runeId = this.runeId.toObject()), this.name != null && (M.name = this.name), this.divisibility != null && (M.divisibility = this.divisibility), this.spacers != null && (M.spacers = this.spacers), this.symbol != null && (M.symbol = this.symbol), this.runes_symbol != null && (M.runes_symbol = this.runes_symbol), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_runeId && z.writeMessage(1, this.runeId, ()=>this.runeId.serialize(z)), this.name.length && z.writeString(2, this.name), this.divisibility != 0 && z.writeUint32(3, this.divisibility), this.spacers != 0 && z.writeUint32(4, this.spacers), this.symbol.length && z.writeString(5, this.symbol), this.runes_symbol != 0 && z.writeUint32(6, this.runes_symbol), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new S();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.runeId, ()=>de.runeId = $.deserialize(z));
                    break;
                case 2:
                    de.name = z.readString();
                    break;
                case 3:
                    de.divisibility = z.readUint32();
                    break;
                case 4:
                    de.spacers = z.readUint32();
                    break;
                case 5:
                    de.symbol = z.readString();
                    break;
                case 6:
                    de.runes_symbol = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return S.deserialize(M);
        }
    }
    i = /* @__PURE__ */ new WeakMap(), e.Rune = S;
    class w extends Be.Message {
        constructor(M){
            super(), o.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, o, "f")), !Array.isArray(M) && typeof M == "object" && ("rune" in M && M.rune != null && (this.rune = M.rune), "balance" in M && M.balance != null && (this.balance = M.balance));
        }
        get rune() {
            return Be.Message.getWrapperField(this, S, 1);
        }
        set rune(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_rune() {
            return Be.Message.getField(this, 1) != null;
        }
        get balance() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set balance(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_balance() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new w({});
            return M.rune != null && (z.rune = S.fromObject(M.rune)), M.balance != null && (z.balance = he.fromObject(M.balance)), z;
        }
        toObject() {
            const M = {};
            return this.rune != null && (M.rune = this.rune.toObject()), this.balance != null && (M.balance = this.balance.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_rune && z.writeMessage(1, this.rune, ()=>this.rune.serialize(z)), this.has_balance && z.writeMessage(2, this.balance, ()=>this.balance.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new w();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.rune, ()=>de.rune = S.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.balance, ()=>de.balance = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return w.deserialize(M);
        }
    }
    o = /* @__PURE__ */ new WeakMap(), e.BalanceSheetItem = w;
    class g extends Be.Message {
        constructor(M){
            super(), s.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, s, "f")), !Array.isArray(M) && typeof M == "object" && "entries" in M && M.entries != null && (this.entries = M.entries);
        }
        get entries() {
            return Be.Message.getRepeatedWrapperField(this, w, 1);
        }
        set entries(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        static fromObject(M) {
            const z = new g({});
            return M.entries != null && (z.entries = M.entries.map((de)=>w.fromObject(de))), z;
        }
        toObject() {
            const M = {};
            return this.entries != null && (M.entries = this.entries.map((z)=>z.toObject())), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.entries.length && z.writeRepeatedMessage(1, this.entries, (de)=>de.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new g();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.entries, ()=>Be.Message.addToRepeatedWrapperField(de, 1, w.deserialize(z), w));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return g.deserialize(M);
        }
    }
    s = /* @__PURE__ */ new WeakMap(), e.BalanceSheet = g;
    class m extends Be.Message {
        constructor(M){
            super(), a.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, a, "f")), !Array.isArray(M) && typeof M == "object" && ("txid" in M && M.txid != null && (this.txid = M.txid), "vout" in M && M.vout != null && (this.vout = M.vout));
        }
        get txid() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(M) {
            Be.Message.setField(this, 1, M);
        }
        get vout() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new m({});
            return M.txid != null && (z.txid = M.txid), M.vout != null && (z.vout = M.vout), z;
        }
        toObject() {
            const M = {};
            return this.txid != null && (M.txid = this.txid), this.vout != null && (M.vout = this.vout), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.txid.length && z.writeBytes(1, this.txid), this.vout != 0 && z.writeUint32(2, this.vout), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new m();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.txid = z.readBytes();
                    break;
                case 2:
                    de.vout = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return m.deserialize(M);
        }
    }
    a = /* @__PURE__ */ new WeakMap(), e.Outpoint = m;
    class E extends Be.Message {
        constructor(M){
            super(), u.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, u, "f")), !Array.isArray(M) && typeof M == "object" && ("txid" in M && M.txid != null && (this.txid = M.txid), "vout" in M && M.vout != null && (this.vout = M.vout), "protocol" in M && M.protocol != null && (this.protocol = M.protocol));
        }
        get txid() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(M) {
            Be.Message.setField(this, 1, M);
        }
        get vout() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(M) {
            Be.Message.setField(this, 2, M);
        }
        get protocol() {
            return Be.Message.getWrapperField(this, he, 3);
        }
        set protocol(M) {
            Be.Message.setWrapperField(this, 3, M);
        }
        get has_protocol() {
            return Be.Message.getField(this, 3) != null;
        }
        static fromObject(M) {
            const z = new E({});
            return M.txid != null && (z.txid = M.txid), M.vout != null && (z.vout = M.vout), M.protocol != null && (z.protocol = he.fromObject(M.protocol)), z;
        }
        toObject() {
            const M = {};
            return this.txid != null && (M.txid = this.txid), this.vout != null && (M.vout = this.vout), this.protocol != null && (M.protocol = this.protocol.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.txid.length && z.writeBytes(1, this.txid), this.vout != 0 && z.writeUint32(2, this.vout), this.has_protocol && z.writeMessage(3, this.protocol, ()=>this.protocol.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new E();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.txid = z.readBytes();
                    break;
                case 2:
                    de.vout = z.readUint32();
                    break;
                case 3:
                    z.readMessage(de.protocol, ()=>de.protocol = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return E.deserialize(M);
        }
    }
    u = /* @__PURE__ */ new WeakMap(), e.OutpointWithProtocol = E;
    class T extends Be.Message {
        constructor(M){
            super(), f.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, f, "f")), !Array.isArray(M) && typeof M == "object" && ("script" in M && M.script != null && (this.script = M.script), "value" in M && M.value != null && (this.value = M.value));
        }
        get script() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set script(M) {
            Be.Message.setField(this, 1, M);
        }
        get value() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set value(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new T({});
            return M.script != null && (z.script = M.script), M.value != null && (z.value = M.value), z;
        }
        toObject() {
            const M = {};
            return this.script != null && (M.script = this.script), this.value != null && (M.value = this.value), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.script.length && z.writeBytes(1, this.script), this.value != 0 && z.writeUint64(2, this.value), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new T();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.script = z.readBytes();
                    break;
                case 2:
                    de.value = z.readUint64();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return T.deserialize(M);
        }
    }
    f = /* @__PURE__ */ new WeakMap(), e.Output = T;
    class I extends Be.Message {
        constructor(M){
            super(), c.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, c, "f")), !Array.isArray(M) && typeof M == "object" && ("balances" in M && M.balances != null && (this.balances = M.balances), "outpoint" in M && M.outpoint != null && (this.outpoint = M.outpoint), "output" in M && M.output != null && (this.output = M.output), "height" in M && M.height != null && (this.height = M.height), "txindex" in M && M.txindex != null && (this.txindex = M.txindex));
        }
        get balances() {
            return Be.Message.getWrapperField(this, g, 1);
        }
        set balances(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_balances() {
            return Be.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return Be.Message.getWrapperField(this, m, 2);
        }
        set outpoint(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_outpoint() {
            return Be.Message.getField(this, 2) != null;
        }
        get output() {
            return Be.Message.getWrapperField(this, T, 3);
        }
        set output(M) {
            Be.Message.setWrapperField(this, 3, M);
        }
        get has_output() {
            return Be.Message.getField(this, 3) != null;
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set height(M) {
            Be.Message.setField(this, 4, M);
        }
        get txindex() {
            return Be.Message.getFieldWithDefault(this, 5, 0);
        }
        set txindex(M) {
            Be.Message.setField(this, 5, M);
        }
        static fromObject(M) {
            const z = new I({});
            return M.balances != null && (z.balances = g.fromObject(M.balances)), M.outpoint != null && (z.outpoint = m.fromObject(M.outpoint)), M.output != null && (z.output = T.fromObject(M.output)), M.height != null && (z.height = M.height), M.txindex != null && (z.txindex = M.txindex), z;
        }
        toObject() {
            const M = {};
            return this.balances != null && (M.balances = this.balances.toObject()), this.outpoint != null && (M.outpoint = this.outpoint.toObject()), this.output != null && (M.output = this.output.toObject()), this.height != null && (M.height = this.height), this.txindex != null && (M.txindex = this.txindex), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_balances && z.writeMessage(1, this.balances, ()=>this.balances.serialize(z)), this.has_outpoint && z.writeMessage(2, this.outpoint, ()=>this.outpoint.serialize(z)), this.has_output && z.writeMessage(3, this.output, ()=>this.output.serialize(z)), this.height != 0 && z.writeUint32(4, this.height), this.txindex != 0 && z.writeUint32(5, this.txindex), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new I();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.balances, ()=>de.balances = g.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.outpoint, ()=>de.outpoint = m.deserialize(z));
                    break;
                case 3:
                    z.readMessage(de.output, ()=>de.output = T.deserialize(z));
                    break;
                case 4:
                    de.height = z.readUint32();
                    break;
                case 5:
                    de.txindex = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return I.deserialize(M);
        }
    }
    c = /* @__PURE__ */ new WeakMap(), e.OutpointResponse = I;
    class P extends Be.Message {
        constructor(M){
            super(), l.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, l, "f")), !Array.isArray(M) && typeof M == "object" && ("start" in M && M.start != null && (this.start = M.start), "end" in M && M.end != null && (this.end = M.end));
        }
        get start() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set start(M) {
            Be.Message.setField(this, 1, M);
        }
        get end() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set end(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new P({});
            return M.start != null && (z.start = M.start), M.end != null && (z.end = M.end), z;
        }
        toObject() {
            const M = {};
            return this.start != null && (M.start = this.start), this.end != null && (M.end = this.end), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.start != 0 && z.writeUint32(1, this.start), this.end != 0 && z.writeUint32(2, this.end), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new P();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.start = z.readUint32();
                    break;
                case 2:
                    de.end = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return P.deserialize(M);
        }
    }
    l = /* @__PURE__ */ new WeakMap(), e.PaginationInput = P;
    class k extends Be.Message {
        constructor(M){
            super(), p.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, p, "f")), !Array.isArray(M) && typeof M == "object" && "wallet" in M && M.wallet != null && (this.wallet = M.wallet);
        }
        get wallet() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set wallet(M) {
            Be.Message.setField(this, 1, M);
        }
        static fromObject(M) {
            const z = new k({});
            return M.wallet != null && (z.wallet = M.wallet), z;
        }
        toObject() {
            const M = {};
            return this.wallet != null && (M.wallet = this.wallet), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.wallet.length && z.writeBytes(1, this.wallet), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new k();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.wallet = z.readBytes();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return k.deserialize(M);
        }
    }
    p = /* @__PURE__ */ new WeakMap(), e.WalletRequest = k;
    class L extends Be.Message {
        constructor(M){
            super(), y.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, y, "f")), !Array.isArray(M) && typeof M == "object" && ("outpoints" in M && M.outpoints != null && (this.outpoints = M.outpoints), "balances" in M && M.balances != null && (this.balances = M.balances));
        }
        get outpoints() {
            return Be.Message.getRepeatedWrapperField(this, I, 1);
        }
        set outpoints(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        get balances() {
            return Be.Message.getWrapperField(this, g, 2);
        }
        set balances(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_balances() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new L({});
            return M.outpoints != null && (z.outpoints = M.outpoints.map((de)=>I.fromObject(de))), M.balances != null && (z.balances = g.fromObject(M.balances)), z;
        }
        toObject() {
            const M = {};
            return this.outpoints != null && (M.outpoints = this.outpoints.map((z)=>z.toObject())), this.balances != null && (M.balances = this.balances.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.outpoints.length && z.writeRepeatedMessage(1, this.outpoints, (de)=>de.serialize(z)), this.has_balances && z.writeMessage(2, this.balances, ()=>this.balances.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new L();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.outpoints, ()=>Be.Message.addToRepeatedWrapperField(de, 1, I.deserialize(z), I));
                    break;
                case 2:
                    z.readMessage(de.balances, ()=>de.balances = g.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return L.deserialize(M);
        }
    }
    y = /* @__PURE__ */ new WeakMap(), e.WalletResponse = L;
    class j extends Be.Message {
        constructor(M){
            super(), _.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, _, "f")), !Array.isArray(M) && typeof M == "object" && ("wallet" in M && M.wallet != null && (this.wallet = M.wallet), "protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag));
        }
        get wallet() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set wallet(M) {
            Be.Message.setField(this, 1, M);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new j({});
            return M.wallet != null && (z.wallet = M.wallet), M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), z;
        }
        toObject() {
            const M = {};
            return this.wallet != null && (M.wallet = this.wallet), this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.wallet.length && z.writeBytes(1, this.wallet), this.has_protocol_tag && z.writeMessage(2, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new j();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.wallet = z.readBytes();
                    break;
                case 2:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return j.deserialize(M);
        }
    }
    _ = /* @__PURE__ */ new WeakMap(), e.ProtorunesWalletRequest = j;
    class ie extends Be.Message {
        constructor(M){
            super(), A.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, A, "f")), !Array.isArray(M) && typeof M == "object" && "height" in M && M.height != null && (this.height = M.height);
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        static fromObject(M) {
            const z = new ie({});
            return M.height != null && (z.height = M.height), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint64(1, this.height), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ie();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint64();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ie.deserialize(M);
        }
    }
    A = /* @__PURE__ */ new WeakMap(), e.RunesByHeightRequest = ie;
    class ue extends Be.Message {
        constructor(M){
            super(), O.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, O, "f")), !Array.isArray(M) && typeof M == "object" && "runes" in M && M.runes != null && (this.runes = M.runes);
        }
        get runes() {
            return Be.Message.getRepeatedWrapperField(this, S, 1);
        }
        set runes(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        static fromObject(M) {
            const z = new ue({});
            return M.runes != null && (z.runes = M.runes.map((de)=>S.fromObject(de))), z;
        }
        toObject() {
            const M = {};
            return this.runes != null && (M.runes = this.runes.map((z)=>z.toObject())), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.runes.length && z.writeRepeatedMessage(1, this.runes, (de)=>de.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ue();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.runes, ()=>Be.Message.addToRepeatedWrapperField(de, 1, S.deserialize(z), S));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ue.deserialize(M);
        }
    }
    O = /* @__PURE__ */ new WeakMap(), e.RunesResponse = ue;
    class ce extends Be.Message {
        constructor(M){
            super(), N.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, N, "f")), !Array.isArray(M) && typeof M == "object" && ("protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag), "pointer" in M && M.pointer != null && (this.pointer = M.pointer));
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 1);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 1) != null;
        }
        get pointer() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set pointer(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new ce({});
            return M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), M.pointer != null && (z.pointer = M.pointer), z;
        }
        toObject() {
            const M = {};
            return this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), this.pointer != null && (M.pointer = this.pointer), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_protocol_tag && z.writeMessage(1, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), this.pointer != 0 && z.writeUint32(2, this.pointer), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ce();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                case 2:
                    de.pointer = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ce.deserialize(M);
        }
    }
    N = /* @__PURE__ */ new WeakMap(), e.ProtoBurn = ce;
    class he extends Be.Message {
        constructor(M){
            super(), U.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, U, "f")), !Array.isArray(M) && typeof M == "object" && ("lo" in M && M.lo != null && (this.lo = M.lo), "hi" in M && M.hi != null && (this.hi = M.hi));
        }
        get lo() {
            return Be.Message.getFieldWithDefault(this, 1, "0");
        }
        set lo(M) {
            Be.Message.setField(this, 1, M);
        }
        get hi() {
            return Be.Message.getFieldWithDefault(this, 2, "0");
        }
        set hi(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new he({});
            return M.lo != null && (z.lo = M.lo), M.hi != null && (z.hi = M.hi), z;
        }
        toObject() {
            const M = {};
            return this.lo != null && (M.lo = this.lo), this.hi != null && (M.hi = this.hi), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.lo != "0" && z.writeUint64String(1, this.lo), this.hi != "0" && z.writeUint64String(2, this.hi), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new he();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.lo = z.readUint64String();
                    break;
                case 2:
                    de.hi = z.readUint64String();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return he.deserialize(M);
        }
    }
    U = /* @__PURE__ */ new WeakMap(), e.uint128 = he;
    class ee extends Be.Message {
        constructor(M){
            super(), D.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, D, "f")), !Array.isArray(M) && typeof M == "object" && ("rune" in M && M.rune != null && (this.rune = M.rune), "amount" in M && M.amount != null && (this.amount = M.amount));
        }
        get rune() {
            return Be.Message.getWrapperField(this, $, 1);
        }
        set rune(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_rune() {
            return Be.Message.getField(this, 1) != null;
        }
        get amount() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set amount(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_amount() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new ee({});
            return M.rune != null && (z.rune = $.fromObject(M.rune)), M.amount != null && (z.amount = he.fromObject(M.amount)), z;
        }
        toObject() {
            const M = {};
            return this.rune != null && (M.rune = this.rune.toObject()), this.amount != null && (M.amount = this.amount.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_rune && z.writeMessage(1, this.rune, ()=>this.rune.serialize(z)), this.has_amount && z.writeMessage(2, this.amount, ()=>this.amount.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ee();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.rune, ()=>de.rune = $.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.amount, ()=>de.amount = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ee.deserialize(M);
        }
    }
    D = /* @__PURE__ */ new WeakMap(), e.Clause = ee;
    class ae extends Be.Message {
        constructor(M){
            super(), H.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, H, "f")), !Array.isArray(M) && typeof M == "object" && "clauses" in M && M.clauses != null && (this.clauses = M.clauses);
        }
        get clauses() {
            return Be.Message.getRepeatedWrapperField(this, ee, 1);
        }
        set clauses(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        static fromObject(M) {
            const z = new ae({});
            return M.clauses != null && (z.clauses = M.clauses.map((de)=>ee.fromObject(de))), z;
        }
        toObject() {
            const M = {};
            return this.clauses != null && (M.clauses = this.clauses.map((z)=>z.toObject())), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.clauses.length && z.writeRepeatedMessage(1, this.clauses, (de)=>de.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ae();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.clauses, ()=>Be.Message.addToRepeatedWrapperField(de, 1, ee.deserialize(z), ee));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ae.deserialize(M);
        }
    }
    H = /* @__PURE__ */ new WeakMap(), e.Predicate = ae;
    class ye extends Be.Message {
        constructor(M){
            super(), K.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, K, "f")), !Array.isArray(M) && typeof M == "object" && ("calldata" in M && M.calldata != null && (this.calldata = M.calldata), "predicate" in M && M.predicate != null && (this.predicate = M.predicate), "pointer" in M && M.pointer != null && (this.pointer = M.pointer), "refund_pointer" in M && M.refund_pointer != null && (this.refund_pointer = M.refund_pointer));
        }
        get calldata() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set calldata(M) {
            Be.Message.setField(this, 1, M);
        }
        get predicate() {
            return Be.Message.getWrapperField(this, ae, 2);
        }
        set predicate(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_predicate() {
            return Be.Message.getField(this, 2) != null;
        }
        get pointer() {
            return Be.Message.getFieldWithDefault(this, 3, 0);
        }
        set pointer(M) {
            Be.Message.setField(this, 3, M);
        }
        get refund_pointer() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set refund_pointer(M) {
            Be.Message.setField(this, 4, M);
        }
        static fromObject(M) {
            const z = new ye({});
            return M.calldata != null && (z.calldata = M.calldata), M.predicate != null && (z.predicate = ae.fromObject(M.predicate)), M.pointer != null && (z.pointer = M.pointer), M.refund_pointer != null && (z.refund_pointer = M.refund_pointer), z;
        }
        toObject() {
            const M = {};
            return this.calldata != null && (M.calldata = this.calldata), this.predicate != null && (M.predicate = this.predicate.toObject()), this.pointer != null && (M.pointer = this.pointer), this.refund_pointer != null && (M.refund_pointer = this.refund_pointer), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.calldata.length && z.writeBytes(1, this.calldata), this.has_predicate && z.writeMessage(2, this.predicate, ()=>this.predicate.serialize(z)), this.pointer != 0 && z.writeUint32(3, this.pointer), this.refund_pointer != 0 && z.writeUint32(4, this.refund_pointer), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ye();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.calldata = z.readBytes();
                    break;
                case 2:
                    z.readMessage(de.predicate, ()=>de.predicate = ae.deserialize(z));
                    break;
                case 3:
                    de.pointer = z.readUint32();
                    break;
                case 4:
                    de.refund_pointer = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ye.deserialize(M);
        }
    }
    K = /* @__PURE__ */ new WeakMap(), e.ProtoMessage = ye;
    class Se extends Be.Message {
        constructor(M){
            super(), re.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, re, "f")), !Array.isArray(M) && typeof M == "object" && "protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 1);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 1) != null;
        }
        static fromObject(M) {
            const z = new Se({});
            return M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), z;
        }
        toObject() {
            const M = {};
            return this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_protocol_tag && z.writeMessage(1, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new Se();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return Se.deserialize(M);
        }
    }
    re = /* @__PURE__ */ new WeakMap(), e.RuntimeInput = Se;
    class De extends Be.Message {
        constructor(M){
            super(), Q.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, Q, "f")), !Array.isArray(M) && typeof M == "object" && "balances" in M && M.balances != null && (this.balances = M.balances);
        }
        get balances() {
            return Be.Message.getWrapperField(this, g, 1);
        }
        set balances(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_balances() {
            return Be.Message.getField(this, 1) != null;
        }
        static fromObject(M) {
            const z = new De({});
            return M.balances != null && (z.balances = g.fromObject(M.balances)), z;
        }
        toObject() {
            const M = {};
            return this.balances != null && (M.balances = this.balances.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_balances && z.writeMessage(1, this.balances, ()=>this.balances.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new De();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.balances, ()=>de.balances = g.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return De.deserialize(M);
        }
    }
    Q = /* @__PURE__ */ new WeakMap(), e.Runtime = De;
    class Re extends Be.Message {
        constructor(M){
            super(), G.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, G, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new Re({});
            return M.height != null && (z.height = M.height), M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint64(1, this.height), this.has_protocol_tag && z.writeMessage(2, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new Re();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint64();
                    break;
                case 2:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return Re.deserialize(M);
        }
    }
    G = /* @__PURE__ */ new WeakMap(), e.ProtorunesByHeightRequest = Re;
})(Ck || (Lf.protorune = Ck = {}));
var h0 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.addHexPrefix = e.stripHexPrefix = void 0;
    const t = (n)=>n.slice(0, 2) == "0x" ? n.slice(2) : n;
    e.stripHexPrefix = t;
    const r = (n)=>"0x" + (0, e.stripHexPrefix)(n);
    e.addHexPrefix = r;
})(h0);
var Jr = {}, Qb = {};
Object.defineProperty(Qb, "__esModule", {
    value: !0
});
Qb.SeekBuffer = void 0;
let ine = class {
    constructor(t){
        this.buffer = t, this.seekIndex = 0;
    }
    readUInt8() {
        if (!this.isFinished()) return this.buffer.readUInt8(this.seekIndex++);
    }
    isFinished() {
        return this.seekIndex >= this.buffer.length;
    }
};
Qb.SeekBuffer = ine;
var Nd = {}, one = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), sne = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), ane = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && one(t, e, r);
    return sne(t, e), t;
}, Xr = Ge && Ge.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
};
Object.defineProperty(Nd, "__esModule", {
    value: !0
});
Nd.alkanes = void 0;
const Ee = ane(rS);
var Uk;
(function(e) {
    var t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U, D, H, K, re, Q, G, R, X, $;
    let S;
    (function(Ue) {
        Ue[Ue.NONE = 0] = "NONE", Ue[Ue.CALL = 1] = "CALL", Ue[Ue.DELEGATECALL = 2] = "DELEGATECALL", Ue[Ue.STATICCALL = 3] = "STATICCALL";
    })(S = e.AlkanesTraceCallType || (e.AlkanesTraceCallType = {}));
    let w;
    (function(Ue) {
        Ue[Ue.SUCCESS = 0] = "SUCCESS", Ue[Ue.FAILURE = 1] = "FAILURE";
    })(w = e.AlkanesTraceStatusFlag || (e.AlkanesTraceStatusFlag = {}));
    class g extends Ee.Message {
        constructor(h){
            super(), t.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, t, "f")), !Array.isArray(h) && typeof h == "object" && ("lo" in h && h.lo != null && (this.lo = h.lo), "hi" in h && h.hi != null && (this.hi = h.hi));
        }
        get lo() {
            return Ee.Message.getFieldWithDefault(this, 1, "0");
        }
        set lo(h) {
            Ee.Message.setField(this, 1, h);
        }
        get hi() {
            return Ee.Message.getFieldWithDefault(this, 2, "0");
        }
        set hi(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new g({});
            return h.lo != null && (x.lo = h.lo), h.hi != null && (x.hi = h.hi), x;
        }
        toObject() {
            const h = {};
            return this.lo != null && (h.lo = this.lo), this.hi != null && (h.hi = this.hi), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.lo != "0" && x.writeUint64String(1, this.lo), this.hi != "0" && x.writeUint64String(2, this.hi), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new g();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.lo = x.readUint64String();
                    break;
                case 2:
                    q.hi = x.readUint64String();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return g.deserialize(h);
        }
    }
    t = /* @__PURE__ */ new WeakMap(), e.uint128 = g;
    class m extends Ee.Message {
        constructor(h){
            super(), r.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, r, "f")), !Array.isArray(h) && typeof h == "object" && "id" in h && h.id != null && (this.id = h.id);
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new m({});
            return h.id != null && (x.id = E.fromObject(h.id)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new m();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return m.deserialize(h);
        }
    }
    r = /* @__PURE__ */ new WeakMap(), e.BytecodeRequest = m;
    class E extends Ee.Message {
        constructor(h){
            super(), n.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, n, "f")), !Array.isArray(h) && typeof h == "object" && ("block" in h && h.block != null && (this.block = h.block), "tx" in h && h.tx != null && (this.tx = h.tx));
        }
        get block() {
            return Ee.Message.getWrapperField(this, g, 1);
        }
        set block(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_block() {
            return Ee.Message.getField(this, 1) != null;
        }
        get tx() {
            return Ee.Message.getWrapperField(this, g, 2);
        }
        set tx(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_tx() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new E({});
            return h.block != null && (x.block = g.fromObject(h.block)), h.tx != null && (x.tx = g.fromObject(h.tx)), x;
        }
        toObject() {
            const h = {};
            return this.block != null && (h.block = this.block.toObject()), this.tx != null && (h.tx = this.tx.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_block && x.writeMessage(1, this.block, ()=>this.block.serialize(x)), this.has_tx && x.writeMessage(2, this.tx, ()=>this.tx.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new E();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.block, ()=>q.block = g.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.tx, ()=>q.tx = g.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return E.deserialize(h);
        }
    }
    n = /* @__PURE__ */ new WeakMap(), e.AlkaneId = E;
    class T extends Ee.Message {
        constructor(h){
            super(), i.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, i, "f")), !Array.isArray(h) && typeof h == "object" && ("id" in h && h.id != null && (this.id = h.id), "value" in h && h.value != null && (this.value = h.value));
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        get value() {
            return Ee.Message.getWrapperField(this, g, 2);
        }
        set value(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_value() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new T({});
            return h.id != null && (x.id = E.fromObject(h.id)), h.value != null && (x.value = g.fromObject(h.value)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), this.value != null && (h.value = this.value.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), this.has_value && x.writeMessage(2, this.value, ()=>this.value.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new T();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.value, ()=>q.value = g.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return T.deserialize(h);
        }
    }
    i = /* @__PURE__ */ new WeakMap(), e.AlkaneTransfer = T;
    class I extends Ee.Message {
        constructor(h){
            super(), o.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, o, "f")), !Array.isArray(h) && typeof h == "object" && ("alkanes" in h && h.alkanes != null && (this.alkanes = h.alkanes), "transaction" in h && h.transaction != null && (this.transaction = h.transaction), "block" in h && h.block != null && (this.block = h.block), "height" in h && h.height != null && (this.height = h.height), "txindex" in h && h.txindex != null && (this.txindex = h.txindex), "calldata" in h && h.calldata != null && (this.calldata = h.calldata), "vout" in h && h.vout != null && (this.vout = h.vout), "pointer" in h && h.pointer != null && (this.pointer = h.pointer), "refund_pointer" in h && h.refund_pointer != null && (this.refund_pointer = h.refund_pointer));
        }
        get alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 1);
        }
        set alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        get transaction() {
            return Ee.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set transaction(h) {
            Ee.Message.setField(this, 2, h);
        }
        get block() {
            return Ee.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
        }
        set block(h) {
            Ee.Message.setField(this, 3, h);
        }
        get height() {
            return Ee.Message.getFieldWithDefault(this, 4, 0);
        }
        set height(h) {
            Ee.Message.setField(this, 4, h);
        }
        get txindex() {
            return Ee.Message.getFieldWithDefault(this, 6, 0);
        }
        set txindex(h) {
            Ee.Message.setField(this, 6, h);
        }
        get calldata() {
            return Ee.Message.getFieldWithDefault(this, 5, new Uint8Array(0));
        }
        set calldata(h) {
            Ee.Message.setField(this, 5, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 7, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 7, h);
        }
        get pointer() {
            return Ee.Message.getFieldWithDefault(this, 8, 0);
        }
        set pointer(h) {
            Ee.Message.setField(this, 8, h);
        }
        get refund_pointer() {
            return Ee.Message.getFieldWithDefault(this, 9, 0);
        }
        set refund_pointer(h) {
            Ee.Message.setField(this, 9, h);
        }
        static fromObject(h) {
            const x = new I({});
            return h.alkanes != null && (x.alkanes = h.alkanes.map((q)=>T.fromObject(q))), h.transaction != null && (x.transaction = h.transaction), h.block != null && (x.block = h.block), h.height != null && (x.height = h.height), h.txindex != null && (x.txindex = h.txindex), h.calldata != null && (x.calldata = h.calldata), h.vout != null && (x.vout = h.vout), h.pointer != null && (x.pointer = h.pointer), h.refund_pointer != null && (x.refund_pointer = h.refund_pointer), x;
        }
        toObject() {
            const h = {};
            return this.alkanes != null && (h.alkanes = this.alkanes.map((x)=>x.toObject())), this.transaction != null && (h.transaction = this.transaction), this.block != null && (h.block = this.block), this.height != null && (h.height = this.height), this.txindex != null && (h.txindex = this.txindex), this.calldata != null && (h.calldata = this.calldata), this.vout != null && (h.vout = this.vout), this.pointer != null && (h.pointer = this.pointer), this.refund_pointer != null && (h.refund_pointer = this.refund_pointer), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.alkanes.length && x.writeRepeatedMessage(1, this.alkanes, (q)=>q.serialize(x)), this.transaction.length && x.writeBytes(2, this.transaction), this.block.length && x.writeBytes(3, this.block), this.height != 0 && x.writeUint64(4, this.height), this.txindex != 0 && x.writeUint32(6, this.txindex), this.calldata.length && x.writeBytes(5, this.calldata), this.vout != 0 && x.writeUint32(7, this.vout), this.pointer != 0 && x.writeUint32(8, this.pointer), this.refund_pointer != 0 && x.writeUint32(9, this.refund_pointer), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new I();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, T.deserialize(x), T));
                    break;
                case 2:
                    q.transaction = x.readBytes();
                    break;
                case 3:
                    q.block = x.readBytes();
                    break;
                case 4:
                    q.height = x.readUint64();
                    break;
                case 6:
                    q.txindex = x.readUint32();
                    break;
                case 5:
                    q.calldata = x.readBytes();
                    break;
                case 7:
                    q.vout = x.readUint32();
                    break;
                case 8:
                    q.pointer = x.readUint32();
                    break;
                case 9:
                    q.refund_pointer = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return I.deserialize(h);
        }
    }
    o = /* @__PURE__ */ new WeakMap(), e.MessageContextParcel = I;
    class P extends Ee.Message {
        constructor(h){
            super(), s.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, s, "f")), !Array.isArray(h) && typeof h == "object" && ("key" in h && h.key != null && (this.key = h.key), "value" in h && h.value != null && (this.value = h.value));
        }
        get key() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set key(h) {
            Ee.Message.setField(this, 1, h);
        }
        get value() {
            return Ee.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set value(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new P({});
            return h.key != null && (x.key = h.key), h.value != null && (x.value = h.value), x;
        }
        toObject() {
            const h = {};
            return this.key != null && (h.key = this.key), this.value != null && (h.value = this.value), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.key.length && x.writeBytes(1, this.key), this.value.length && x.writeBytes(2, this.value), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new P();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.key = x.readBytes();
                    break;
                case 2:
                    q.value = x.readBytes();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return P.deserialize(h);
        }
    }
    s = /* @__PURE__ */ new WeakMap(), e.KeyValuePair = P;
    class k extends Ee.Message {
        constructor(h){
            super(), a.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1,
                2
            ], Xr(this, a, "f")), !Array.isArray(h) && typeof h == "object" && ("alkanes" in h && h.alkanes != null && (this.alkanes = h.alkanes), "storage" in h && h.storage != null && (this.storage = h.storage), "data" in h && h.data != null && (this.data = h.data));
        }
        get alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 1);
        }
        set alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        get storage() {
            return Ee.Message.getRepeatedWrapperField(this, P, 2);
        }
        set storage(h) {
            Ee.Message.setRepeatedWrapperField(this, 2, h);
        }
        get data() {
            return Ee.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
        }
        set data(h) {
            Ee.Message.setField(this, 3, h);
        }
        static fromObject(h) {
            const x = new k({});
            return h.alkanes != null && (x.alkanes = h.alkanes.map((q)=>T.fromObject(q))), h.storage != null && (x.storage = h.storage.map((q)=>P.fromObject(q))), h.data != null && (x.data = h.data), x;
        }
        toObject() {
            const h = {};
            return this.alkanes != null && (h.alkanes = this.alkanes.map((x)=>x.toObject())), this.storage != null && (h.storage = this.storage.map((x)=>x.toObject())), this.data != null && (h.data = this.data), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.alkanes.length && x.writeRepeatedMessage(1, this.alkanes, (q)=>q.serialize(x)), this.storage.length && x.writeRepeatedMessage(2, this.storage, (q)=>q.serialize(x)), this.data.length && x.writeBytes(3, this.data), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new k();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, T.deserialize(x), T));
                    break;
                case 2:
                    x.readMessage(q.storage, ()=>Ee.Message.addToRepeatedWrapperField(q, 2, P.deserialize(x), P));
                    break;
                case 3:
                    q.data = x.readBytes();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return k.deserialize(h);
        }
    }
    a = /* @__PURE__ */ new WeakMap(), e.ExtendedCallResponse = k;
    class L extends Ee.Message {
        constructor(h){
            super(), u.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                3,
                5
            ], Xr(this, u, "f")), !Array.isArray(h) && typeof h == "object" && ("myself" in h && h.myself != null && (this.myself = h.myself), "caller" in h && h.caller != null && (this.caller = h.caller), "inputs" in h && h.inputs != null && (this.inputs = h.inputs), "vout" in h && h.vout != null && (this.vout = h.vout), "incoming_alkanes" in h && h.incoming_alkanes != null && (this.incoming_alkanes = h.incoming_alkanes));
        }
        get myself() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set myself(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_myself() {
            return Ee.Message.getField(this, 1) != null;
        }
        get caller() {
            return Ee.Message.getWrapperField(this, E, 2);
        }
        set caller(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_caller() {
            return Ee.Message.getField(this, 2) != null;
        }
        get inputs() {
            return Ee.Message.getRepeatedWrapperField(this, g, 3);
        }
        set inputs(h) {
            Ee.Message.setRepeatedWrapperField(this, 3, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 4, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 4, h);
        }
        get incoming_alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 5);
        }
        set incoming_alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 5, h);
        }
        static fromObject(h) {
            const x = new L({});
            return h.myself != null && (x.myself = E.fromObject(h.myself)), h.caller != null && (x.caller = E.fromObject(h.caller)), h.inputs != null && (x.inputs = h.inputs.map((q)=>g.fromObject(q))), h.vout != null && (x.vout = h.vout), h.incoming_alkanes != null && (x.incoming_alkanes = h.incoming_alkanes.map((q)=>T.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.myself != null && (h.myself = this.myself.toObject()), this.caller != null && (h.caller = this.caller.toObject()), this.inputs != null && (h.inputs = this.inputs.map((x)=>x.toObject())), this.vout != null && (h.vout = this.vout), this.incoming_alkanes != null && (h.incoming_alkanes = this.incoming_alkanes.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_myself && x.writeMessage(1, this.myself, ()=>this.myself.serialize(x)), this.has_caller && x.writeMessage(2, this.caller, ()=>this.caller.serialize(x)), this.inputs.length && x.writeRepeatedMessage(3, this.inputs, (q)=>q.serialize(x)), this.vout != 0 && x.writeUint32(4, this.vout), this.incoming_alkanes.length && x.writeRepeatedMessage(5, this.incoming_alkanes, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new L();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.myself, ()=>q.myself = E.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.caller, ()=>q.caller = E.deserialize(x));
                    break;
                case 3:
                    x.readMessage(q.inputs, ()=>Ee.Message.addToRepeatedWrapperField(q, 3, g.deserialize(x), g));
                    break;
                case 4:
                    q.vout = x.readUint32();
                    break;
                case 5:
                    x.readMessage(q.incoming_alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 5, T.deserialize(x), T));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return L.deserialize(h);
        }
    }
    u = /* @__PURE__ */ new WeakMap(), e.Context = L;
    class j extends Ee.Message {
        constructor(h){
            super(), f.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, f, "f")), !Array.isArray(h) && typeof h == "object" && ("inner" in h && h.inner != null && (this.inner = h.inner), "fuel" in h && h.fuel != null && (this.fuel = h.fuel));
        }
        get inner() {
            return Ee.Message.getWrapperField(this, L, 1);
        }
        set inner(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_inner() {
            return Ee.Message.getField(this, 1) != null;
        }
        get fuel() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set fuel(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new j({});
            return h.inner != null && (x.inner = L.fromObject(h.inner)), h.fuel != null && (x.fuel = h.fuel), x;
        }
        toObject() {
            const h = {};
            return this.inner != null && (h.inner = this.inner.toObject()), this.fuel != null && (h.fuel = this.fuel), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_inner && x.writeMessage(1, this.inner, ()=>this.inner.serialize(x)), this.fuel != 0 && x.writeUint64(2, this.fuel), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new j();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.inner, ()=>q.inner = L.deserialize(x));
                    break;
                case 2:
                    q.fuel = x.readUint64();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return j.deserialize(h);
        }
    }
    f = /* @__PURE__ */ new WeakMap(), e.TraceContext = j;
    class ie extends Ee.Message {
        constructor(h){
            super(), c.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, c, "f")), !Array.isArray(h) && typeof h == "object" && ("call_type" in h && h.call_type != null && (this.call_type = h.call_type), "context" in h && h.context != null && (this.context = h.context));
        }
        get call_type() {
            return Ee.Message.getFieldWithDefault(this, 1, S.NONE);
        }
        set call_type(h) {
            Ee.Message.setField(this, 1, h);
        }
        get context() {
            return Ee.Message.getWrapperField(this, j, 2);
        }
        set context(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_context() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new ie({});
            return h.call_type != null && (x.call_type = h.call_type), h.context != null && (x.context = j.fromObject(h.context)), x;
        }
        toObject() {
            const h = {};
            return this.call_type != null && (h.call_type = this.call_type), this.context != null && (h.context = this.context.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.call_type != S.NONE && x.writeEnum(1, this.call_type), this.has_context && x.writeMessage(2, this.context, ()=>this.context.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ie();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.call_type = x.readEnum();
                    break;
                case 2:
                    x.readMessage(q.context, ()=>q.context = j.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ie.deserialize(h);
        }
    }
    c = /* @__PURE__ */ new WeakMap(), e.AlkanesEnterContext = ie;
    class ue extends Ee.Message {
        constructor(h){
            super(), l.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, l, "f")), !Array.isArray(h) && typeof h == "object" && ("status" in h && h.status != null && (this.status = h.status), "response" in h && h.response != null && (this.response = h.response));
        }
        get status() {
            return Ee.Message.getFieldWithDefault(this, 1, w.SUCCESS);
        }
        set status(h) {
            Ee.Message.setField(this, 1, h);
        }
        get response() {
            return Ee.Message.getWrapperField(this, k, 2);
        }
        set response(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_response() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new ue({});
            return h.status != null && (x.status = h.status), h.response != null && (x.response = k.fromObject(h.response)), x;
        }
        toObject() {
            const h = {};
            return this.status != null && (h.status = this.status), this.response != null && (h.response = this.response.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.status != w.SUCCESS && x.writeEnum(1, this.status), this.has_response && x.writeMessage(2, this.response, ()=>this.response.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ue();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.status = x.readEnum();
                    break;
                case 2:
                    x.readMessage(q.response, ()=>q.response = k.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ue.deserialize(h);
        }
    }
    l = /* @__PURE__ */ new WeakMap(), e.AlkanesExitContext = ue;
    class ce extends Ee.Message {
        constructor(h){
            super(), p.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, p, "f")), !Array.isArray(h) && typeof h == "object" && "new_alkane" in h && h.new_alkane != null && (this.new_alkane = h.new_alkane);
        }
        get new_alkane() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set new_alkane(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_new_alkane() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new ce({});
            return h.new_alkane != null && (x.new_alkane = E.fromObject(h.new_alkane)), x;
        }
        toObject() {
            const h = {};
            return this.new_alkane != null && (h.new_alkane = this.new_alkane.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_new_alkane && x.writeMessage(1, this.new_alkane, ()=>this.new_alkane.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ce();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.new_alkane, ()=>q.new_alkane = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ce.deserialize(h);
        }
    }
    p = /* @__PURE__ */ new WeakMap(), e.AlkanesCreate = ce;
    class he extends Ee.Message {
        constructor(h){
            super(), y.set(this, [
                [
                    1,
                    2,
                    3
                ]
            ]), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, y, "f")), !Array.isArray(h) && typeof h == "object" && ("enter_context" in h && h.enter_context != null && (this.enter_context = h.enter_context), "exit_context" in h && h.exit_context != null && (this.exit_context = h.exit_context), "create_alkane" in h && h.create_alkane != null && (this.create_alkane = h.create_alkane));
        }
        get enter_context() {
            return Ee.Message.getWrapperField(this, ie, 1);
        }
        set enter_context(h) {
            Ee.Message.setOneofWrapperField(this, 1, Xr(this, y, "f")[0], h);
        }
        get has_enter_context() {
            return Ee.Message.getField(this, 1) != null;
        }
        get exit_context() {
            return Ee.Message.getWrapperField(this, ue, 2);
        }
        set exit_context(h) {
            Ee.Message.setOneofWrapperField(this, 2, Xr(this, y, "f")[0], h);
        }
        get has_exit_context() {
            return Ee.Message.getField(this, 2) != null;
        }
        get create_alkane() {
            return Ee.Message.getWrapperField(this, ce, 3);
        }
        set create_alkane(h) {
            Ee.Message.setOneofWrapperField(this, 3, Xr(this, y, "f")[0], h);
        }
        get has_create_alkane() {
            return Ee.Message.getField(this, 3) != null;
        }
        get event() {
            return ({
                0: "none",
                1: "enter_context",
                2: "exit_context",
                3: "create_alkane"
            })[Ee.Message.computeOneofCase(this, [
                1,
                2,
                3
            ])];
        }
        static fromObject(h) {
            const x = new he({});
            return h.enter_context != null && (x.enter_context = ie.fromObject(h.enter_context)), h.exit_context != null && (x.exit_context = ue.fromObject(h.exit_context)), h.create_alkane != null && (x.create_alkane = ce.fromObject(h.create_alkane)), x;
        }
        toObject() {
            const h = {};
            return this.enter_context != null && (h.enter_context = this.enter_context.toObject()), this.exit_context != null && (h.exit_context = this.exit_context.toObject()), this.create_alkane != null && (h.create_alkane = this.create_alkane.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_enter_context && x.writeMessage(1, this.enter_context, ()=>this.enter_context.serialize(x)), this.has_exit_context && x.writeMessage(2, this.exit_context, ()=>this.exit_context.serialize(x)), this.has_create_alkane && x.writeMessage(3, this.create_alkane, ()=>this.create_alkane.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new he();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.enter_context, ()=>q.enter_context = ie.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.exit_context, ()=>q.exit_context = ue.deserialize(x));
                    break;
                case 3:
                    x.readMessage(q.create_alkane, ()=>q.create_alkane = ce.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return he.deserialize(h);
        }
    }
    y = /* @__PURE__ */ new WeakMap(), e.AlkanesTraceEvent = he;
    class ee extends Ee.Message {
        constructor(h){
            super(), _.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, _, "f")), !Array.isArray(h) && typeof h == "object" && ("traces" in h && h.traces != null && (this.traces = h.traces), "outpoint" in h && h.outpoint != null && (this.outpoint = h.outpoint), "txindex" in h && h.txindex != null && (this.txindex = h.txindex));
        }
        get traces() {
            return Ee.Message.getWrapperField(this, ye, 1);
        }
        set traces(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_traces() {
            return Ee.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return Ee.Message.getWrapperField(this, z, 2);
        }
        set outpoint(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_outpoint() {
            return Ee.Message.getField(this, 2) != null;
        }
        get txindex() {
            return Ee.Message.getFieldWithDefault(this, 3, 0);
        }
        set txindex(h) {
            Ee.Message.setField(this, 3, h);
        }
        static fromObject(h) {
            const x = new ee({});
            return h.traces != null && (x.traces = ye.fromObject(h.traces)), h.outpoint != null && (x.outpoint = z.fromObject(h.outpoint)), h.txindex != null && (x.txindex = h.txindex), x;
        }
        toObject() {
            const h = {};
            return this.traces != null && (h.traces = this.traces.toObject()), this.outpoint != null && (h.outpoint = this.outpoint.toObject()), this.txindex != null && (h.txindex = this.txindex), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_traces && x.writeMessage(1, this.traces, ()=>this.traces.serialize(x)), this.has_outpoint && x.writeMessage(2, this.outpoint, ()=>this.outpoint.serialize(x)), this.txindex != 0 && x.writeUint64(3, this.txindex), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ee();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.traces, ()=>q.traces = ye.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.outpoint, ()=>q.outpoint = z.deserialize(x));
                    break;
                case 3:
                    q.txindex = x.readUint64();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ee.deserialize(h);
        }
    }
    _ = /* @__PURE__ */ new WeakMap(), e.AlkanesBlockEvent = ee;
    class ae extends Ee.Message {
        constructor(h){
            super(), A.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, A, "f")), !Array.isArray(h) && typeof h == "object" && "events" in h && h.events != null && (this.events = h.events);
        }
        get events() {
            return Ee.Message.getRepeatedWrapperField(this, ee, 1);
        }
        set events(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new ae({});
            return h.events != null && (x.events = h.events.map((q)=>ee.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.events != null && (h.events = this.events.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.events.length && x.writeRepeatedMessage(1, this.events, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ae();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.events, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, ee.deserialize(x), ee));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ae.deserialize(h);
        }
    }
    A = /* @__PURE__ */ new WeakMap(), e.AlkanesBlockTraceEvent = ae;
    class ye extends Ee.Message {
        constructor(h){
            super(), O.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, O, "f")), !Array.isArray(h) && typeof h == "object" && "events" in h && h.events != null && (this.events = h.events);
        }
        get events() {
            return Ee.Message.getRepeatedWrapperField(this, he, 1);
        }
        set events(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new ye({});
            return h.events != null && (x.events = h.events.map((q)=>he.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.events != null && (h.events = this.events.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.events.length && x.writeRepeatedMessage(1, this.events, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ye();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.events, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, he.deserialize(x), he));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ye.deserialize(h);
        }
    }
    O = /* @__PURE__ */ new WeakMap(), e.AlkanesTrace = ye;
    class Se extends Ee.Message {
        constructor(h){
            super(), N.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, N, "f")), !Array.isArray(h) && typeof h == "object" && ("execution" in h && h.execution != null && (this.execution = h.execution), "gas_used" in h && h.gas_used != null && (this.gas_used = h.gas_used), "error" in h && h.error != null && (this.error = h.error));
        }
        get execution() {
            return Ee.Message.getWrapperField(this, k, 1);
        }
        set execution(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_execution() {
            return Ee.Message.getField(this, 1) != null;
        }
        get gas_used() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set gas_used(h) {
            Ee.Message.setField(this, 2, h);
        }
        get error() {
            return Ee.Message.getFieldWithDefault(this, 3, "");
        }
        set error(h) {
            Ee.Message.setField(this, 3, h);
        }
        static fromObject(h) {
            const x = new Se({});
            return h.execution != null && (x.execution = k.fromObject(h.execution)), h.gas_used != null && (x.gas_used = h.gas_used), h.error != null && (x.error = h.error), x;
        }
        toObject() {
            const h = {};
            return this.execution != null && (h.execution = this.execution.toObject()), this.gas_used != null && (h.gas_used = this.gas_used), this.error != null && (h.error = this.error), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_execution && x.writeMessage(1, this.execution, ()=>this.execution.serialize(x)), this.gas_used != 0 && x.writeUint64(2, this.gas_used), this.error.length && x.writeString(3, this.error), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Se();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.execution, ()=>q.execution = k.deserialize(x));
                    break;
                case 2:
                    q.gas_used = x.readUint64();
                    break;
                case 3:
                    q.error = x.readString();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Se.deserialize(h);
        }
    }
    N = /* @__PURE__ */ new WeakMap(), e.SimulateResponse = Se;
    class De extends Ee.Message {
        constructor(h){
            super(), U.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, U, "f")), !Array.isArray(h) && typeof h == "object" && "id" in h && h.id != null && (this.id = h.id);
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new De({});
            return h.id != null && (x.id = E.fromObject(h.id)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new De();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return De.deserialize(h);
        }
    }
    U = /* @__PURE__ */ new WeakMap(), e.AlkaneInventoryRequest = De;
    class Re extends Ee.Message {
        constructor(h){
            super(), D.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, D, "f")), !Array.isArray(h) && typeof h == "object" && "alkanes" in h && h.alkanes != null && (this.alkanes = h.alkanes);
        }
        get alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 1);
        }
        set alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new Re({});
            return h.alkanes != null && (x.alkanes = h.alkanes.map((q)=>T.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.alkanes != null && (h.alkanes = this.alkanes.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.alkanes.length && x.writeRepeatedMessage(1, this.alkanes, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Re();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, T.deserialize(x), T));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Re.deserialize(h);
        }
    }
    D = /* @__PURE__ */ new WeakMap(), e.AlkaneInventoryResponse = Re;
    class Ce extends Ee.Message {
        constructor(h){
            super(), H.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, H, "f")), !Array.isArray(h) && typeof h == "object" && "id" in h && h.id != null && (this.id = h.id);
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new Ce({});
            return h.id != null && (x.id = E.fromObject(h.id)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Ce();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Ce.deserialize(h);
        }
    }
    H = /* @__PURE__ */ new WeakMap(), e.AlkaneIdToOutpointRequest = Ce;
    class M extends Ee.Message {
        constructor(h){
            super(), K.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, K, "f")), !Array.isArray(h) && typeof h == "object" && ("txid" in h && h.txid != null && (this.txid = h.txid), "vout" in h && h.vout != null && (this.vout = h.vout));
        }
        get txid() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(h) {
            Ee.Message.setField(this, 1, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new M({});
            return h.txid != null && (x.txid = h.txid), h.vout != null && (x.vout = h.vout), x;
        }
        toObject() {
            const h = {};
            return this.txid != null && (h.txid = this.txid), this.vout != null && (h.vout = this.vout), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.txid.length && x.writeBytes(1, this.txid), this.vout != 0 && x.writeUint32(2, this.vout), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new M();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.txid = x.readBytes();
                    break;
                case 2:
                    q.vout = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return M.deserialize(h);
        }
    }
    K = /* @__PURE__ */ new WeakMap(), e.AlkaneIdToOutpointResponse = M;
    class z extends Ee.Message {
        constructor(h){
            super(), re.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, re, "f")), !Array.isArray(h) && typeof h == "object" && ("txid" in h && h.txid != null && (this.txid = h.txid), "vout" in h && h.vout != null && (this.vout = h.vout));
        }
        get txid() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(h) {
            Ee.Message.setField(this, 1, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new z({});
            return h.txid != null && (x.txid = h.txid), h.vout != null && (x.vout = h.vout), x;
        }
        toObject() {
            const h = {};
            return this.txid != null && (h.txid = this.txid), this.vout != null && (h.vout = this.vout), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.txid.length && x.writeBytes(1, this.txid), this.vout != 0 && x.writeUint32(2, this.vout), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new z();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.txid = x.readBytes();
                    break;
                case 2:
                    q.vout = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return z.deserialize(h);
        }
    }
    re = /* @__PURE__ */ new WeakMap(), e.Outpoint = z;
    class de extends Ee.Message {
        constructor(h){
            super(), Q.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, Q, "f")), !Array.isArray(h) && typeof h == "object" && ("outpoint" in h && h.outpoint != null && (this.outpoint = h.outpoint), "trace" in h && h.trace != null && (this.trace = h.trace));
        }
        get outpoint() {
            return Ee.Message.getWrapperField(this, z, 1);
        }
        set outpoint(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_outpoint() {
            return Ee.Message.getField(this, 1) != null;
        }
        get trace() {
            return Ee.Message.getWrapperField(this, ye, 2);
        }
        set trace(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_trace() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new de({});
            return h.outpoint != null && (x.outpoint = z.fromObject(h.outpoint)), h.trace != null && (x.trace = ye.fromObject(h.trace)), x;
        }
        toObject() {
            const h = {};
            return this.outpoint != null && (h.outpoint = this.outpoint.toObject()), this.trace != null && (h.trace = this.trace.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_outpoint && x.writeMessage(1, this.outpoint, ()=>this.outpoint.serialize(x)), this.has_trace && x.writeMessage(2, this.trace, ()=>this.trace.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new de();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.outpoint, ()=>q.outpoint = z.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.trace, ()=>q.trace = ye.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return de.deserialize(h);
        }
    }
    Q = /* @__PURE__ */ new WeakMap(), e.Trace = de;
    class _e extends Ee.Message {
        constructor(h){
            super(), G.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, G, "f")), !Array.isArray(h) && typeof h == "object" && "block" in h && h.block != null && (this.block = h.block);
        }
        get block() {
            return Ee.Message.getFieldWithDefault(this, 1, 0);
        }
        set block(h) {
            Ee.Message.setField(this, 1, h);
        }
        static fromObject(h) {
            const x = new _e({});
            return h.block != null && (x.block = h.block), x;
        }
        toObject() {
            const h = {};
            return this.block != null && (h.block = this.block), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.block != 0 && x.writeUint64(1, this.block), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new _e();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.block = x.readUint64();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return _e.deserialize(h);
        }
    }
    G = /* @__PURE__ */ new WeakMap(), e.TraceBlockRequest = _e;
    class Ie extends Ee.Message {
        constructor(h){
            super(), R.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, R, "f")), !Array.isArray(h) && typeof h == "object" && "height" in h && h.height != null && (this.height = h.height);
        }
        get height() {
            return Ee.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(h) {
            Ee.Message.setField(this, 1, h);
        }
        static fromObject(h) {
            const x = new Ie({});
            return h.height != null && (x.height = h.height), x;
        }
        toObject() {
            const h = {};
            return this.height != null && (h.height = this.height), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.height != 0 && x.writeUint32(1, this.height), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Ie();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.height = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Ie.deserialize(h);
        }
    }
    R = /* @__PURE__ */ new WeakMap(), e.BlockRequest = Ie;
    class je extends Ee.Message {
        constructor(h){
            super(), X.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, X, "f")), !Array.isArray(h) && typeof h == "object" && ("block" in h && h.block != null && (this.block = h.block), "height" in h && h.height != null && (this.height = h.height));
        }
        get block() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set block(h) {
            Ee.Message.setField(this, 1, h);
        }
        get height() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set height(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new je({});
            return h.block != null && (x.block = h.block), h.height != null && (x.height = h.height), x;
        }
        toObject() {
            const h = {};
            return this.block != null && (h.block = this.block), this.height != null && (h.height = this.height), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.block.length && x.writeBytes(1, this.block), this.height != 0 && x.writeUint32(2, this.height), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new je();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.block = x.readBytes();
                    break;
                case 2:
                    q.height = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return je.deserialize(h);
        }
    }
    X = /* @__PURE__ */ new WeakMap(), e.BlockResponse = je;
    class Ke extends Ee.Message {
        constructor(h){
            super(), $.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, $, "f")), !Array.isArray(h) && typeof h == "object" && "traces" in h && h.traces != null && (this.traces = h.traces);
        }
        get traces() {
            return Ee.Message.getRepeatedWrapperField(this, de, 1);
        }
        set traces(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new Ke({});
            return h.traces != null && (x.traces = h.traces.map((q)=>de.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.traces != null && (h.traces = this.traces.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.traces.length && x.writeRepeatedMessage(1, this.traces, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Ke();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.traces, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, de.deserialize(x), de));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Ke.deserialize(h);
        }
    }
    $ = /* @__PURE__ */ new WeakMap(), e.TraceBlockResponse = Ke;
})(Uk || (Nd.alkanes = Uk = {}));
Object.defineProperty(Jr, "__esModule", {
    value: !0
});
Jr.fromBuffer = Jr.toBuffer = void 0;
Jr.toProtobufAlkaneTransfer = une;
Jr.unpack = fne;
Jr.leftPad15 = sN;
Jr.leftPadByte = nS;
Jr.rightPadByte = lne;
Jr.leftPad16 = iS;
Jr.leftPad8 = QE;
Jr.toUint128 = My;
Jr.fromUint128 = dne;
Jr.toHexString = ex;
Jr.u128ToBuffer = aN;
Jr.encodeVarInt = cN;
Jr.encipher = hne;
Jr.decipher = uN;
Jr.decodeVarInt = fN;
Jr.tryDecodeVarInt = lN;
Jr.pack = yne;
Jr.decipherPacked = mne;
const cne = Qb, JE = Nd;
function une(e) {
    return new JE.alkanes.AlkaneTransfer({
        id: new JE.alkanes.AlkaneId({
            block: My(e.id.block),
            tx: My(e.id.tx)
        }),
        value: My(e.value)
    });
}
function fne(e) {
    return Array.from(e).reduce((t, r, n)=>(n % 15 === 0 && t.push([]), t[t.length - 1].push(r), t), []).map((t)=>BigInt("0x" + We.from(t.reverse()).toString("hex")));
}
function sN(e) {
    if (e.length > 30) throw Error("varint in encoding cannot exceed 15 bytes");
    return "0".repeat(30 - e.length) + e;
}
function nS(e) {
    return e.length % 2 ? "0" + e : e;
}
function lne(e) {
    return e.length % 2 ? e + "0" : e;
}
function iS(e) {
    if (e.length > 16) throw Error("varint in encoding cannot exceed 15 bytes");
    return "0".repeat(32 - e.length) + e;
}
function QE(e) {
    return "0".repeat(16 - e.length) + e;
}
function My(e) {
    let t = iS(e.toString(16));
    return new JE.alkanes.uint128({
        hi: BigInt("0x" + t.substr(0, 16)).toString(10),
        lo: BigInt("0x" + t.substr(16, 32)).toString(10)
    });
}
function dne(e) {
    return aN(e);
}
function ex(e) {
    return BigInt(e).toString(16);
}
function aN(e) {
    return BigInt("0x" + We.from(QE(ex(e.hi)) + QE(ex(e.lo)), "hex").toString("hex"));
}
function cN(e) {
    const t = [];
    for(; e >> 7n > 0n;)t.push(Number(e & 0xffn) | 128), e = BigInt(e >> 7n);
    return t.push(Number(e & 0xffn)), We.from(t);
}
function hne(e) {
    return We.concat(e.map((t)=>cN(t)));
}
const pne = (e)=>We.from(Array.from(We.from(iS(e.toString(16)), "hex")).reverse());
Jr.toBuffer = pne;
const gne = (e)=>BigInt("0x" + We.from(Array.from(e).reverse()).toString("hex"));
Jr.fromBuffer = gne;
function uN(e) {
    let t = new cne.SeekBuffer(e), r = null;
    const n = [];
    for(; (r = fN(t)) !== BigInt(-1);)n.push(r);
    return n;
}
function fN(e) {
    try {
        return lN(e);
    } catch  {
        return BigInt(-1);
    }
}
function lN(e) {
    let t = BigInt(0);
    for(let r = 0; r <= 18; r++){
        const n = e.readUInt8();
        if (n === void 0) throw new Error("Unterminated");
        const i = BigInt(n) & 127n;
        if (r === 18 && (i & 124n) !== 0n) throw new Error("Overflow");
        if (t = BigInt(t | i << BigInt(7 * r)), !(n & 128)) return t;
    }
    throw new Error("Overlong");
}
function yne(e) {
    return We.concat(e.map((t)=>We.from(sN(We.from(Array.from(We.from(nS(t.toString(16)), "hex")).reverse()).toString("hex")), "hex")));
}
function mne(e) {
    return uN(We.concat(e.map((t)=>We.from(Array.from(We.from(nS(t.toString(16)), "hex")).reverse()))));
}
Object.defineProperty(mo, "__esModule", {
    value: !0
});
mo.encodeOutpointInput = Sne;
mo.decodeRunes = dN;
mo.decodeOutpointViewBase = hN;
mo.decodeOutpointView = Ane;
mo.decodeRunesResponse = Tne;
mo.encodeBlockHeightInput = kne;
mo.encodeProtorunesByHeightInput = Ine;
mo.encodeAlkanesIdToOutpointInput = Bne;
mo.decodeAlkanesIdToOutpointResponse = One;
const bne = Lf, oS = h0, Wl = Jr, { OutpointResponse: wne, Outpoint: vne, BalanceSheet: u2e, RunesResponse: _ne, ProtorunesByHeightRequest: Ene, RunesByHeightRequest: xne } = bne.protorune, tx = Nd;
function Sne(e, t) {
    const r = {
        txid: We.from(e, "hex"),
        vout: t
    };
    return "0x" + We.from(new vne(r).serializeBinary()).toString("hex");
}
function dN(e) {
    return e ? e.entries.map((t)=>{
        const r = t.balance, n = t.rune, i = "•", o = n.spacers.toString(2);
        let s = n.name, a = s;
        const u = n.symbol;
        let f = 0;
        return o.split("").reverse().map((l, p)=>{
            l == "1" && (a = `${a.slice(0, p + 1 + f)}${i}${a.slice(p + 1 + f)}`, f++);
        }), {
            rune: {
                id: {
                    block: (0, Wl.fromUint128)(n.runeId.height),
                    tx: (0, Wl.fromUint128)(n.runeId.txindex)
                },
                name: s,
                spacedName: a,
                divisibility: n.divisibility,
                spacers: n.spacers,
                symbol: u
            },
            balance: (0, Wl.fromUint128)(r)
        };
    }) : [];
}
function hN(e) {
    return {
        runes: dN(e.balances),
        outpoint: {
            txid: We.from(e.outpoint.txid).toString("hex"),
            vout: e.outpoint.vout
        },
        output: e.output ? {
            value: e.output.value,
            script: We.from(e.output.script).toString("hex")
        } : {
            value: "",
            script: ""
        },
        height: e.height,
        txindex: e.txindex
    };
}
function Ane(e) {
    const t = Uint8Array.from(We.from((0, oS.stripHexPrefix)(e), "hex")), r = wne.deserializeBinary(t);
    return hN(r);
}
function Tne(e) {
    if (!e || e === "0x") return {
        runes: []
    };
    const t = We.from((0, oS.stripHexPrefix)(e), "hex");
    return t.length === 0 ? {
        runes: []
    } : {
        runes: _ne.deserializeBinary(t).runes.map((n)=>{
            var i, o;
            return {
                runeId: `${((i = n.runeId) == null ? void 0 : i.height) || 0}:${((o = n.runeId) == null ? void 0 : o.txindex) || 0}`,
                name: We.from(n.name).toString("utf8"),
                divisibility: n.divisibility,
                spacers: n.spacers,
                symbol: n.symbol
            };
        })
    };
}
function kne(e) {
    const t = {
        height: e
    };
    return "0x" + We.from(new xne(t).serializeBinary()).toString("hex");
}
function Ine(e, t) {
    const r = {
        height: e,
        protocol_tag: (0, Wl.toUint128)(t)
    };
    return "0x" + We.from(new Ene(r).serializeBinary()).toString("hex");
}
function Bne(e, t) {
    const r = new tx.alkanes.AlkaneId({
        block: (0, Wl.toUint128)(e),
        tx: (0, Wl.toUint128)(t)
    });
    return "0x" + We.from(new tx.alkanes.AlkaneIdToOutpointRequest({
        id: r
    }).serializeBinary()).toString("hex");
}
function One(e) {
    if (!e || e === "0x") return {
        outpoint: {}
    };
    const t = We.from((0, oS.stripHexPrefix)(e), "hex");
    if (t.length === 0) return {
        outpoint: {}
    };
    const r = tx.alkanes.AlkaneIdToOutpointResponse.deserializeBinary(t);
    return {
        outpoint: {
            txid: We.from(r.txid).toString("hex"),
            vout: r.vout
        }
    };
}
Object.defineProperty(ka, "__esModule", {
    value: !0
});
ka.encodeProtorunesWalletInput = Fne;
ka.encodeTransactionId = zne;
ka.encodeWalletInput = jne;
ka.decodeTransactionResult = Hne;
ka.decodeWalletOutput = qne;
ka.encodeRuntimeInput = Kne;
ka.decodeRuntimeOutput = Wne;
const pN = mo, Pne = Lf, Nne = mo, hp = h0, Mne = Jr, { ProtorunesWalletRequest: Rne, TransactionRecord: Cne, WalletRequest: Une, WalletResponse: $ne, RuntimeInput: Lne, Runtime: Dne, Outpoint: f2e } = Pne.protorune;
function gN(e) {
    return (0, Mne.toUint128)(e);
}
function Fne(e, t) {
    const r = {
        wallet: Uint8Array.from(We.from(e, "utf-8")),
        protocol_tag: gN(t)
    };
    return "0x" + We.from(new Rne(r).serializeBinary()).toString("hex");
}
function zne(e) {
    return We.from((0, hp.stripHexPrefix)(e), "hex");
}
function jne(e) {
    const t = {
        wallet: Uint8Array.from(We.from(e, "utf-8"))
    };
    return "0x" + We.from(new Une(t).serializeBinary()).toString("hex");
}
function Hne(e) {
    const { transaction: t, height: r } = Cne.deserializeBinary(Uint8Array.from(We.from((0, hp.stripHexPrefix)(e), "hex")));
    return {
        transaction: (0, hp.addHexPrefix)(We.from(t).toString("hex")),
        height: Number(r)
    };
}
function qne(e) {
    const t = $ne.deserializeBinary(Uint8Array.from(We.from((0, hp.stripHexPrefix)(e), "hex")));
    return {
        outpoints: t.outpoints.map((r)=>(0, Nne.decodeOutpointViewBase)(r)),
        balanceSheet: (0, pN.decodeRunes)(t.balances)
    };
}
function Kne(e) {
    const t = {
        protocolTag: gN(e)
    };
    return "0x" + We.from(new Lne(t).serializeBinary()).toString("hex");
}
function Wne(e) {
    const t = Dne.deserializeBinary(Uint8Array.from(We.from((0, hp.stripHexPrefix)(e), "hex")));
    return {
        balances: (0, pN.decodeRunes)(t.balances)
    };
}
var Bn = {};
Object.defineProperty(Bn, "__esModule", {
    value: !0
});
Bn.formatKey = mN;
Bn.toAlkaneTransfer = e1;
Bn.toBytecodeRequest = bN;
Bn.encodeBlockRequest = Gne;
Bn.encodeGetBytecodeRequest = Zne;
Bn.fromCallType = wN;
Bn.toAlkaneId = pp;
Bn.toStorageSlot = sS;
Bn.toContext = vN;
Bn.toResponse = _N;
Bn.toEvent = aS;
Bn.encodeTraceRequest = Yne;
Bn.encodeTraceBlockRequest = Xne;
Bn.decodeBlockResponse = Jne;
Bn.decodeTraceBlockResponse = Qne;
Bn.decodeTraceResponse = eie;
Bn.encodeSimulateRequest = tie;
Bn.decodeSimulateResponse = rie;
Bn.outpointResponseToObject = EN;
Bn.decodeOutpointResponse = nie;
Bn.decodeMetaResponse = iie;
const Cs = Jr, ba = Nd, mu = h0, yN = Lf, { SimulateResponse: l2e, MessageContextParcel: d2e, AlkanesTrace: h2e } = ba.alkanes, Vne = 47;
function mN(e) {
    return Array.from(e).reduce((t, r)=>r === Vne ? (t.push([]), t) : (t[t.length - 1].push(r), t), [
        []
    ]).map((t)=>{
        const r = We.from(t).toString("utf8");
        return /^\w+$/.test(r) ? r : We.from(t).toString("hex");
    }).join("/");
}
function e1(e) {
    return {
        id: pp(e.id),
        value: (0, Cs.fromUint128)(e.value)
    };
}
function bN({ block: e, tx: t }) {
    return new ba.alkanes.BytecodeRequest({
        id: new ba.alkanes.AlkaneId({
            block: (0, Cs.toUint128)(e),
            tx: (0, Cs.toUint128)(t)
        })
    });
}
function Gne({ height: e }) {
    return new ba.alkanes.BlockRequest({
        height: e
    });
}
function Zne(e) {
    const t = bN(e);
    return (0, mu.addHexPrefix)(We.from(t.serializeBinary()).toString("hex"));
}
function wN(e) {
    switch(e){
        case 1:
            return "call";
        case 2:
            return "delegatecall";
        case 3:
            return "staticcall";
        default:
            return "unknowncall";
    }
}
function pp(e) {
    return {
        block: typeof e.block == "bigint" ? e.block : (0, Cs.fromUint128)(e.block),
        tx: typeof e.tx == "bigint" ? e.tx : (0, Cs.fromUint128)(e.tx)
    };
}
function sS(e) {
    return {
        key: mN(e.key),
        value: "0x" + We.from(e.value).toString("hex")
    };
}
function vN(e) {
    return {
        myself: pp(e.myself),
        caller: pp(e.caller),
        inputs: e.inputs.map((t)=>(0, Cs.fromUint128)(t)),
        incomingAlkanes: e.incoming_alkanes.map((t)=>e1(t)),
        vout: e.vout
    };
}
function _N(e) {
    return {
        alkanes: e.alkanes.map((t)=>e1(t)),
        data: "0x" + We.from(e.data).toString("hex"),
        storage: e.storage.map((t)=>sS(t))
    };
}
function aS(e) {
    let t = Object.keys(e)[0];
    switch(t){
        case "create_alkane":
            return {
                event: "create",
                data: pp(e[t].new_alkane)
            };
        case "enter_context":
            return {
                event: "invoke",
                data: {
                    type: wN(e[t].call_type),
                    context: vN(e[t].context.inner),
                    fuel: e[t].context.fuel
                }
            };
        case "exit_context":
            return {
                event: "return",
                data: {
                    status: e[t].status == 0 ? "success" : "revert",
                    response: _N(e[t].response)
                }
            };
    }
}
function Yne({ txid: e, vout: t }) {
    const r = {
        txid: We.from((0, mu.stripHexPrefix)(e), "hex"),
        vout: t
    };
    return "0x" + We.from(new yN.protorune.Outpoint(r).serializeBinary()).toString("hex");
}
function Xne({ block: e }) {
    const t = {
        block: Number(e)
    };
    return "0x" + We.from(new ba.alkanes.TraceBlockRequest(t).serializeBinary()).toString("hex");
}
function Jne(e) {
    return (0, mu.addHexPrefix)(We.from(ba.alkanes.BlockResponse.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex")).block).toString("hex"));
}
function Qne(e) {
    return ba.alkanes.TraceBlockResponse.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex")).traces.map(({ outpoint: t, trace: r })=>({
            outpoint: {
                txid: We.from(t.txid).toString("hex"),
                vout: t.vout
            },
            trace: r.events.map((n)=>aS(n))
        }));
}
function eie(e) {
    return ba.alkanes.AlkanesTrace.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex")).toObject().events.map((r)=>aS(r));
}
function tie({ alkanes: e, transaction: t, height: r, block: n, inputs: i, target: o, txindex: s, vout: a, pointer: u, refundPointer: f }) {
    const c = {
        alkanes: e.map((l)=>(0, Cs.toProtobufAlkaneTransfer)(l)),
        transaction: Uint8Array.from(We.from(t, "hex")),
        height: Number(r),
        txindex: s,
        calldata: (0, Cs.encipher)([
            o.block,
            o.tx,
            ...i
        ]),
        block: Uint8Array.from(We.from(n, "hex")),
        vout: a,
        pointer: u,
        refund_pointer: f
    };
    return "0x" + We.from(new ba.alkanes.MessageContextParcel(c).serializeBinary()).toString("hex");
}
class dm {
    constructor(){}
}
dm.SUCCESS = 0;
dm.REVERT = 1;
function rie(e) {
    const t = ba.alkanes.SimulateResponse.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex"));
    return t.error || !t.execution ? {
        status: dm.REVERT,
        gasUsed: 0,
        execution: {
            alkanes: [],
            storage: [],
            data: "0x",
            error: t.error
        }
    } : {
        status: dm.SUCCESS,
        gasUsed: t.gas_used,
        execution: {
            alkanes: t.execution.alkanes.map(e1),
            storage: t.execution.storage.map(sS),
            error: null,
            data: "0x" + We.from(t.execution.data).toString("hex")
        }
    };
}
function EN(e) {
    return e.map((t)=>({
            token: {
                id: {
                    block: (0, Cs.fromUint128)(t.rune.runeId.height),
                    tx: (0, Cs.fromUint128)(t.rune.runeId.txindex)
                },
                name: t.rune.name,
                symbol: t.rune.symbol
            },
            value: (0, Cs.fromUint128)(t.balance)
        }));
}
function nie(e) {
    return EN(((yN.protorune.OutpointResponse.deserializeBinary(We.from(e.substr(2), "hex")).toObject() || {}).balances || {}).entries || []);
}
function iie(e) {
    if (!e || e === "0x") return null;
    const t = We.from((0, mu.stripHexPrefix)(e), "hex");
    try {
        return JSON.parse(t.toString("utf8"));
    } catch (r) {
        return console.error("Failed to parse meta response as JSON:", r), null;
    }
}
var t1 = {}, Md = {}, hm = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */ hm.exports;
(function(e, t) {
    (function(r) {
        var n = t && !t.nodeType && t, i = e && !e.nodeType && e, o = typeof Ge == "object" && Ge;
        (o.global === o || o.window === o || o.self === o) && (r = o);
        var s, a = 2147483647, u = 36, f = 1, c = 26, l = 38, p = 700, y = 72, _ = 128, A = "-", O = /^xn--/, N = /[^\x20-\x7E]/, U = /[\x2E\u3002\uFF0E\uFF61]/g, D = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, H = u - f, K = Math.floor, re = String.fromCharCode, Q;
        function G(k) {
            throw new RangeError(D[k]);
        }
        function R(k, L) {
            for(var j = k.length, ie = []; j--;)ie[j] = L(k[j]);
            return ie;
        }
        function X(k, L) {
            var j = k.split("@"), ie = "";
            j.length > 1 && (ie = j[0] + "@", k = j[1]), k = k.replace(U, ".");
            var ue = k.split("."), ce = R(ue, L).join(".");
            return ie + ce;
        }
        function $(k) {
            for(var L = [], j = 0, ie = k.length, ue, ce; j < ie;)ue = k.charCodeAt(j++), ue >= 55296 && ue <= 56319 && j < ie ? (ce = k.charCodeAt(j++), (ce & 64512) == 56320 ? L.push(((ue & 1023) << 10) + (ce & 1023) + 65536) : (L.push(ue), j--)) : L.push(ue);
            return L;
        }
        function S(k) {
            return R(k, function(L) {
                var j = "";
                return L > 65535 && (L -= 65536, j += re(L >>> 10 & 1023 | 55296), L = 56320 | L & 1023), j += re(L), j;
            }).join("");
        }
        function w(k) {
            return k - 48 < 10 ? k - 22 : k - 65 < 26 ? k - 65 : k - 97 < 26 ? k - 97 : u;
        }
        function g(k, L) {
            return k + 22 + 75 * (k < 26) - ((L != 0) << 5);
        }
        function m(k, L, j) {
            var ie = 0;
            for(k = j ? K(k / p) : k >> 1, k += K(k / L); k > H * c >> 1; ie += u)k = K(k / H);
            return K(ie + (H + 1) * k / (k + l));
        }
        function E(k) {
            var L = [], j = k.length, ie, ue = 0, ce = _, he = y, ee, ae, ye, Se, De, Re, Ce, M, z;
            for(ee = k.lastIndexOf(A), ee < 0 && (ee = 0), ae = 0; ae < ee; ++ae)k.charCodeAt(ae) >= 128 && G("not-basic"), L.push(k.charCodeAt(ae));
            for(ye = ee > 0 ? ee + 1 : 0; ye < j;){
                for(Se = ue, De = 1, Re = u; ye >= j && G("invalid-input"), Ce = w(k.charCodeAt(ye++)), (Ce >= u || Ce > K((a - ue) / De)) && G("overflow"), ue += Ce * De, M = Re <= he ? f : Re >= he + c ? c : Re - he, !(Ce < M); Re += u)z = u - M, De > K(a / z) && G("overflow"), De *= z;
                ie = L.length + 1, he = m(ue - Se, ie, Se == 0), K(ue / ie) > a - ce && G("overflow"), ce += K(ue / ie), ue %= ie, L.splice(ue++, 0, ce);
            }
            return S(L);
        }
        function T(k) {
            var L, j, ie, ue, ce, he, ee, ae, ye, Se, De, Re = [], Ce, M, z, de;
            for(k = $(k), Ce = k.length, L = _, j = 0, ce = y, he = 0; he < Ce; ++he)De = k[he], De < 128 && Re.push(re(De));
            for(ie = ue = Re.length, ue && Re.push(A); ie < Ce;){
                for(ee = a, he = 0; he < Ce; ++he)De = k[he], De >= L && De < ee && (ee = De);
                for(M = ie + 1, ee - L > K((a - j) / M) && G("overflow"), j += (ee - L) * M, L = ee, he = 0; he < Ce; ++he)if (De = k[he], De < L && ++j > a && G("overflow"), De == L) {
                    for(ae = j, ye = u; Se = ye <= ce ? f : ye >= ce + c ? c : ye - ce, !(ae < Se); ye += u)de = ae - Se, z = u - Se, Re.push(re(g(Se + de % z, 0))), ae = K(de / z);
                    Re.push(re(g(ae, 0))), ce = m(j, M, ie == ue), j = 0, ++ie;
                }
                ++j, ++L;
            }
            return Re.join("");
        }
        function I(k) {
            return X(k, function(L) {
                return O.test(L) ? E(L.slice(4).toLowerCase()) : L;
            });
        }
        function P(k) {
            return X(k, function(L) {
                return N.test(L) ? "xn--" + T(L) : L;
            });
        }
        if (s = {
            /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */ version: "1.4.1",
            /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */ ucs2: {
                decode: $,
                encode: S
            },
            decode: E,
            encode: T,
            toASCII: P,
            toUnicode: I
        }, n && i) if (e.exports == n) i.exports = s;
        else for(Q in s)s.hasOwnProperty(Q) && (n[Q] = s[Q]);
        else r.punycode = s;
    })(Ge);
})(hm, hm.exports);
var oie = hm.exports, Rd = TypeError, cS = typeof Map == "function" && Map.prototype, E_ = Object.getOwnPropertyDescriptor && cS ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, pm = cS && E_ && typeof E_.get == "function" ? E_.get : null, $k = cS && Map.prototype.forEach, uS = typeof Set == "function" && Set.prototype, x_ = Object.getOwnPropertyDescriptor && uS ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, gm = uS && x_ && typeof x_.get == "function" ? x_.get : null, Lk = uS && Set.prototype.forEach, sie = typeof WeakMap == "function" && WeakMap.prototype, Fh = sie ? WeakMap.prototype.has : null, aie = typeof WeakSet == "function" && WeakSet.prototype, zh = aie ? WeakSet.prototype.has : null, cie = typeof WeakRef == "function" && WeakRef.prototype, Dk = cie ? WeakRef.prototype.deref : null, uie = Boolean.prototype.valueOf, fie = Object.prototype.toString, lie = Function.prototype.toString, die = String.prototype.match, fS = String.prototype.slice, uu = String.prototype.replace, hie = String.prototype.toUpperCase, Fk = String.prototype.toLowerCase, xN = RegExp.prototype.test, zk = Array.prototype.concat, da = Array.prototype.join, pie = Array.prototype.slice, jk = Math.floor, rx = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, S_ = Object.getOwnPropertySymbols, nx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, od = typeof Symbol == "function" && typeof Symbol.iterator == "object", jh = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === od || !0) ? Symbol.toStringTag : null, SN = Object.prototype.propertyIsEnumerable, Hk = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
    return e.__proto__;
} : null);
function qk(e, t) {
    if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || xN.call(/e/, t)) return t;
    var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof e == "number") {
        var n = e < 0 ? -jk(-e) : jk(e);
        if (n !== e) {
            var i = String(n), o = fS.call(t, i.length + 1);
            return uu.call(i, r, "$&_") + "." + uu.call(uu.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
    }
    return uu.call(t, r, "$&_");
}
var ix = Iu, Kk = ix.custom, Wk = kN(Kk) ? Kk : null, AN = {
    __proto__: null,
    double: '"',
    single: "'"
}, gie = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
}, r1 = function e(t, r, n, i) {
    var o = r || {};
    if (Xa(o, "quoteStyle") && !Xa(AN, o.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Xa(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var s = Xa(o, "customInspect") ? o.customInspect : !0;
    if (typeof s != "boolean" && s !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Xa(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Xa(o, "numericSeparator") && typeof o.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var a = o.numericSeparator;
    if (typeof t > "u") return "undefined";
    if (t === null) return "null";
    if (typeof t == "boolean") return t ? "true" : "false";
    if (typeof t == "string") return BN(t, o);
    if (typeof t == "number") {
        if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
        var u = String(t);
        return a ? qk(t, u) : u;
    }
    if (typeof t == "bigint") {
        var f = String(t) + "n";
        return a ? qk(t, f) : f;
    }
    var c = typeof o.depth > "u" ? 5 : o.depth;
    if (typeof n > "u" && (n = 0), n >= c && c > 0 && typeof t == "object") return ox(t) ? "[Array]" : "[Object]";
    var l = Mie(o, n);
    if (typeof i > "u") i = [];
    else if (IN(i, t) >= 0) return "[Circular]";
    function p(w, g, m) {
        if (g && (i = pie.call(i), i.push(g)), m) {
            var E = {
                depth: o.depth
            };
            return Xa(o, "quoteStyle") && (E.quoteStyle = o.quoteStyle), e(w, E, n + 1, i);
        }
        return e(w, o, n + 1, i);
    }
    if (typeof t == "function" && !Vk(t)) {
        var y = Sie(t), _ = Xg(t, p);
        return "[Function" + (y ? ": " + y : " (anonymous)") + "]" + (_.length > 0 ? " { " + da.call(_, ", ") + " }" : "");
    }
    if (kN(t)) {
        var A = od ? uu.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : nx.call(t);
        return typeof t == "object" && !od ? ph(A) : A;
    }
    if (Oie(t)) {
        for(var O = "<" + Fk.call(String(t.nodeName)), N = t.attributes || [], U = 0; U < N.length; U++)O += " " + N[U].name + "=" + TN(yie(N[U].value), "double", o);
        return O += ">", t.childNodes && t.childNodes.length && (O += "..."), O += "</" + Fk.call(String(t.nodeName)) + ">", O;
    }
    if (ox(t)) {
        if (t.length === 0) return "[]";
        var D = Xg(t, p);
        return l && !Nie(D) ? "[" + sx(D, l) + "]" : "[ " + da.call(D, ", ") + " ]";
    }
    if (bie(t)) {
        var H = Xg(t, p);
        return !("cause" in Error.prototype) && "cause" in t && !SN.call(t, "cause") ? "{ [" + String(t) + "] " + da.call(zk.call("[cause]: " + p(t.cause), H), ", ") + " }" : H.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + da.call(H, ", ") + " }";
    }
    if (typeof t == "object" && s) {
        if (Wk && typeof t[Wk] == "function" && ix) return ix(t, {
            depth: c - n
        });
        if (s !== "symbol" && typeof t.inspect == "function") return t.inspect();
    }
    if (Aie(t)) {
        var K = [];
        return $k && $k.call(t, function(w, g) {
            K.push(p(g, t, !0) + " => " + p(w, t));
        }), Gk("Map", pm.call(t), K, l);
    }
    if (Iie(t)) {
        var re = [];
        return Lk && Lk.call(t, function(w) {
            re.push(p(w, t));
        }), Gk("Set", gm.call(t), re, l);
    }
    if (Tie(t)) return A_("WeakMap");
    if (Bie(t)) return A_("WeakSet");
    if (kie(t)) return A_("WeakRef");
    if (vie(t)) return ph(p(Number(t)));
    if (Eie(t)) return ph(p(rx.call(t)));
    if (_ie(t)) return ph(uie.call(t));
    if (wie(t)) return ph(p(String(t)));
    if (("TURBOPACK compile-time value", "undefined") < "u" && t === window) return "{ [object Window] }";
    if (typeof globalThis < "u" && t === globalThis || typeof Ge < "u" && t === Ge) return "{ [object globalThis] }";
    if (!mie(t) && !Vk(t)) {
        var Q = Xg(t, p), G = Hk ? Hk(t) === Object.prototype : t instanceof Object || t.constructor === Object, R = t instanceof Object ? "" : "null prototype", X = !G && jh && Object(t) === t && jh in t ? fS.call(Pu(t), 8, -1) : R ? "Object" : "", $ = G || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", S = $ + (X || R ? "[" + da.call(zk.call([], X || [], R || []), ": ") + "] " : "");
        return Q.length === 0 ? S + "{}" : l ? S + "{" + sx(Q, l) + "}" : S + "{ " + da.call(Q, ", ") + " }";
    }
    return String(t);
};
function TN(e, t, r) {
    var n = r.quoteStyle || t, i = AN[n];
    return i + e + i;
}
function yie(e) {
    return uu.call(String(e), /"/g, "&quot;");
}
function Df(e) {
    return !jh || !(typeof e == "object" && (jh in e || typeof e[jh] < "u"));
}
function ox(e) {
    return Pu(e) === "[object Array]" && Df(e);
}
function mie(e) {
    return Pu(e) === "[object Date]" && Df(e);
}
function Vk(e) {
    return Pu(e) === "[object RegExp]" && Df(e);
}
function bie(e) {
    return Pu(e) === "[object Error]" && Df(e);
}
function wie(e) {
    return Pu(e) === "[object String]" && Df(e);
}
function vie(e) {
    return Pu(e) === "[object Number]" && Df(e);
}
function _ie(e) {
    return Pu(e) === "[object Boolean]" && Df(e);
}
function kN(e) {
    if (od) return e && typeof e == "object" && e instanceof Symbol;
    if (typeof e == "symbol") return !0;
    if (!e || typeof e != "object" || !nx) return !1;
    try {
        return nx.call(e), !0;
    } catch  {}
    return !1;
}
function Eie(e) {
    if (!e || typeof e != "object" || !rx) return !1;
    try {
        return rx.call(e), !0;
    } catch  {}
    return !1;
}
var xie = Object.prototype.hasOwnProperty || function(e) {
    return e in this;
};
function Xa(e, t) {
    return xie.call(e, t);
}
function Pu(e) {
    return fie.call(e);
}
function Sie(e) {
    if (e.name) return e.name;
    var t = die.call(lie.call(e), /^function\s*([\w$]+)/);
    return t ? t[1] : null;
}
function IN(e, t) {
    if (e.indexOf) return e.indexOf(t);
    for(var r = 0, n = e.length; r < n; r++)if (e[r] === t) return r;
    return -1;
}
function Aie(e) {
    if (!pm || !e || typeof e != "object") return !1;
    try {
        pm.call(e);
        try {
            gm.call(e);
        } catch  {
            return !0;
        }
        return e instanceof Map;
    } catch  {}
    return !1;
}
function Tie(e) {
    if (!Fh || !e || typeof e != "object") return !1;
    try {
        Fh.call(e, Fh);
        try {
            zh.call(e, zh);
        } catch  {
            return !0;
        }
        return e instanceof WeakMap;
    } catch  {}
    return !1;
}
function kie(e) {
    if (!Dk || !e || typeof e != "object") return !1;
    try {
        return Dk.call(e), !0;
    } catch  {}
    return !1;
}
function Iie(e) {
    if (!gm || !e || typeof e != "object") return !1;
    try {
        gm.call(e);
        try {
            pm.call(e);
        } catch  {
            return !0;
        }
        return e instanceof Set;
    } catch  {}
    return !1;
}
function Bie(e) {
    if (!zh || !e || typeof e != "object") return !1;
    try {
        zh.call(e, zh);
        try {
            Fh.call(e, Fh);
        } catch  {
            return !0;
        }
        return e instanceof WeakSet;
    } catch  {}
    return !1;
}
function Oie(e) {
    return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function BN(e, t) {
    if (e.length > t.maxStringLength) {
        var r = e.length - t.maxStringLength, n = "... " + r + " more character" + (r > 1 ? "s" : "");
        return BN(fS.call(e, 0, t.maxStringLength), t) + n;
    }
    var i = gie[t.quoteStyle || "single"];
    i.lastIndex = 0;
    var o = uu.call(uu.call(e, i, "\\$1"), /[\x00-\x1f]/g, Pie);
    return TN(o, "single", t);
}
function Pie(e) {
    var t = e.charCodeAt(0), r = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + hie.call(t.toString(16));
}
function ph(e) {
    return "Object(" + e + ")";
}
function A_(e) {
    return e + " { ? }";
}
function Gk(e, t, r, n) {
    var i = n ? sx(r, n) : da.call(r, ", ");
    return e + " (" + t + ") {" + i + "}";
}
function Nie(e) {
    for(var t = 0; t < e.length; t++)if (IN(e[t], `
`) >= 0) return !1;
    return !0;
}
function Mie(e, t) {
    var r;
    if (e.indent === "	") r = "	";
    else if (typeof e.indent == "number" && e.indent > 0) r = da.call(Array(e.indent + 1), " ");
    else return null;
    return {
        base: r,
        prev: da.call(Array(t + 1), r)
    };
}
function sx(e, t) {
    if (e.length === 0) return "";
    var r = `
` + t.prev + t.base;
    return r + da.call(e, "," + r) + `
` + t.prev;
}
function Xg(e, t) {
    var r = ox(e), n = [];
    if (r) {
        n.length = e.length;
        for(var i = 0; i < e.length; i++)n[i] = Xa(e, i) ? t(e[i], e) : "";
    }
    var o = typeof S_ == "function" ? S_(e) : [], s;
    if (od) {
        s = {};
        for(var a = 0; a < o.length; a++)s["$" + o[a]] = o[a];
    }
    for(var u in e)Xa(e, u) && (r && String(Number(u)) === u && u < e.length || od && s["$" + u] instanceof Symbol || (xN.call(/[^\w$]/, u) ? n.push(t(u, e) + ": " + t(e[u], e)) : n.push(u + ": " + t(e[u], e))));
    if (typeof S_ == "function") for(var f = 0; f < o.length; f++)SN.call(e, o[f]) && n.push("[" + t(o[f]) + "]: " + t(e[o[f]], e));
    return n;
}
var Rie = r1, Cie = Rd, n1 = function(e, t, r) {
    for(var n = e, i; (i = n.next) != null; n = i)if (i.key === t) return n.next = i.next, r || (i.next = /** @type {NonNullable<typeof list.next>} */ e.next, e.next = i), i;
}, Uie = function(e, t) {
    if (e) {
        var r = n1(e, t);
        return r && r.value;
    }
}, $ie = function(e, t, r) {
    var n = n1(e, t);
    n ? n.value = r : e.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: t,
        next: e.next,
        value: r
    };
}, Lie = function(e, t) {
    return e ? !!n1(e, t) : !1;
}, Die = function(e, t) {
    if (e) return n1(e, t, !0);
}, Fie = function() {
    var t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new Cie("Side channel does not contain " + Rie(n));
        },
        delete: function(n) {
            var i = t && t.next, o = Die(t, n);
            return o && i && i === o && (t = void 0), !!o;
        },
        get: function(n) {
            return Uie(t, n);
        },
        has: function(n) {
            return Lie(t, n);
        },
        set: function(n, i) {
            t || (t = {
                next: void 0
            }), $ie(/** @type {NonNullable<typeof $o>} */ t, n, i);
        }
    };
    return r;
}, ON = Object, zie = Error, jie = EvalError, Hie = RangeError, qie = ReferenceError, Kie = SyntaxError, Wie = URIError, Vie = Math.abs, Gie = Math.floor, Zie = Math.max, Yie = Math.min, Xie = Math.pow, Jie = Math.round, Qie = Number.isNaN || function(t) {
    return t !== t;
}, eoe = Qie, toe = function(t) {
    return eoe(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, roe = Object.getOwnPropertyDescriptor, Ry = roe;
if (Ry) try {
    Ry([], "length");
} catch  {
    Ry = null;
}
var PN = Ry, Cy = Object.defineProperty || !1;
if (Cy) try {
    Cy({}, "a", {
        value: 1
    });
} catch  {
    Cy = !1;
}
var noe = Cy, T_, Zk;
function ioe() {
    return Zk || (Zk = 1, T_ = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var t = {}, r = Symbol("test"), n = Object(r);
        if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]") return !1;
        var i = 42;
        t[r] = i;
        for(var o in t)return !1;
        if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(t);
        if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var a = /** @type {PropertyDescriptor} */ Object.getOwnPropertyDescriptor(t, r);
            if (a.value !== i || a.enumerable !== !0) return !1;
        }
        return !0;
    }), T_;
}
var k_, Yk;
function ooe() {
    if (Yk) return k_;
    Yk = 1;
    var e = typeof Symbol < "u" && Symbol, t = ioe();
    return k_ = function() {
        return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
    }, k_;
}
var I_, Xk;
function NN() {
    return Xk || (Xk = 1, I_ = typeof Reflect < "u" && Reflect.getPrototypeOf || null), I_;
}
var B_, Jk;
function MN() {
    if (Jk) return B_;
    Jk = 1;
    var e = ON;
    return B_ = e.getPrototypeOf || null, B_;
}
var soe = "Function.prototype.bind called on incompatible ", aoe = Object.prototype.toString, coe = Math.max, uoe = "[object Function]", Qk = function(t, r) {
    for(var n = [], i = 0; i < t.length; i += 1)n[i] = t[i];
    for(var o = 0; o < r.length; o += 1)n[o + t.length] = r[o];
    return n;
}, foe = function(t, r) {
    for(var n = [], i = r, o = 0; i < t.length; i += 1, o += 1)n[o] = t[i];
    return n;
}, loe = function(e, t) {
    for(var r = "", n = 0; n < e.length; n += 1)r += e[n], n + 1 < e.length && (r += t);
    return r;
}, doe = function(t) {
    var r = this;
    if (typeof r != "function" || aoe.apply(r) !== uoe) throw new TypeError(soe + r);
    for(var n = foe(arguments, 1), i, o = function() {
        if (this instanceof i) {
            var c = r.apply(this, Qk(n, arguments));
            return Object(c) === c ? c : this;
        }
        return r.apply(t, Qk(n, arguments));
    }, s = coe(0, r.length - n.length), a = [], u = 0; u < s; u++)a[u] = "$" + u;
    if (i = Function("binder", "return function (" + loe(a, ",") + "){ return binder.apply(this,arguments); }")(o), r.prototype) {
        var f = function() {};
        f.prototype = r.prototype, i.prototype = new f(), f.prototype = null;
    }
    return i;
}, hoe = doe, i1 = Function.prototype.bind || hoe, lS = Function.prototype.call, O_, eI;
function RN() {
    return eI || (eI = 1, O_ = Function.prototype.apply), O_;
}
var poe = typeof Reflect < "u" && Reflect && Reflect.apply, goe = i1, yoe = RN(), moe = lS, boe = poe, woe = boe || goe.call(moe, yoe), voe = i1, _oe = Rd, Eoe = lS, xoe = woe, CN = function(t) {
    if (t.length < 1 || typeof t[0] != "function") throw new _oe("a function is required");
    return xoe(voe, Eoe, t);
}, P_, tI;
function Soe() {
    if (tI) return P_;
    tI = 1;
    var e = CN, t = PN, r;
    try {
        r = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
    } catch (s) {
        if (!s || typeof s != "object" || !("code" in s) || s.code !== "ERR_PROTO_ACCESS") throw s;
    }
    var n = !!r && t && t(Object.prototype, /** @type {keyof typeof Object.prototype} */ "__proto__"), i = Object, o = i.getPrototypeOf;
    return P_ = n && typeof n.get == "function" ? e([
        n.get
    ]) : typeof o == "function" ? /** @type {import('./get')} */ function(a) {
        return o(a == null ? a : i(a));
    } : !1, P_;
}
var N_, rI;
function Aoe() {
    if (rI) return N_;
    rI = 1;
    var e = NN(), t = MN(), r = Soe();
    return N_ = e ? function(i) {
        return e(i);
    } : t ? function(i) {
        if (!i || typeof i != "object" && typeof i != "function") throw new TypeError("getProto: not an object");
        return t(i);
    } : r ? function(i) {
        return r(i);
    } : null, N_;
}
var M_, nI;
function Toe() {
    if (nI) return M_;
    nI = 1;
    var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = i1;
    return M_ = r.call(e, t), M_;
}
var Mr, koe = ON, Ioe = zie, Boe = jie, Ooe = Hie, Poe = qie, sd = Kie, Vl = Rd, Noe = Wie, Moe = Vie, Roe = Gie, Coe = Zie, Uoe = Yie, $oe = Xie, Loe = Jie, Doe = toe, UN = Function, R_ = function(e) {
    try {
        return UN('"use strict"; return (' + e + ").constructor;")();
    } catch  {}
}, gp = PN, Foe = noe, C_ = function() {
    throw new Vl();
}, zoe = gp ? function() {
    try {
        return arguments.callee, C_;
    } catch  {
        try {
            return gp(arguments, "callee").get;
        } catch  {
            return C_;
        }
    }
}() : C_, pl = ooe()(), ni = Aoe(), joe = MN(), Hoe = NN(), $N = RN(), p0 = lS, Sl = {}, qoe = typeof Uint8Array > "u" || !ni ? Mr : ni(Uint8Array), gf = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Mr : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Mr : ArrayBuffer,
    "%ArrayIteratorPrototype%": pl && ni ? ni([][Symbol.iterator]()) : Mr,
    "%AsyncFromSyncIteratorPrototype%": Mr,
    "%AsyncFunction%": Sl,
    "%AsyncGenerator%": Sl,
    "%AsyncGeneratorFunction%": Sl,
    "%AsyncIteratorPrototype%": Sl,
    "%Atomics%": typeof Atomics > "u" ? Mr : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Mr : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Mr : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Mr : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Mr : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Ioe,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": Boe,
    "%Float16Array%": typeof Float16Array > "u" ? Mr : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? Mr : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Mr : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Mr : FinalizationRegistry,
    "%Function%": UN,
    "%GeneratorFunction%": Sl,
    "%Int8Array%": typeof Int8Array > "u" ? Mr : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Mr : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Mr : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": pl && ni ? ni(ni([][Symbol.iterator]())) : Mr,
    "%JSON%": typeof JSON == "object" ? JSON : Mr,
    "%Map%": typeof Map > "u" ? Mr : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !pl || !ni ? Mr : ni(/* @__PURE__ */ new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": koe,
    "%Object.getOwnPropertyDescriptor%": gp,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Mr : Promise,
    "%Proxy%": typeof Proxy > "u" ? Mr : Proxy,
    "%RangeError%": Ooe,
    "%ReferenceError%": Poe,
    "%Reflect%": typeof Reflect > "u" ? Mr : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Mr : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !pl || !ni ? Mr : ni(/* @__PURE__ */ new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Mr : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": pl && ni ? ni(""[Symbol.iterator]()) : Mr,
    "%Symbol%": pl ? Symbol : Mr,
    "%SyntaxError%": sd,
    "%ThrowTypeError%": zoe,
    "%TypedArray%": qoe,
    "%TypeError%": Vl,
    "%Uint8Array%": typeof Uint8Array > "u" ? Mr : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Mr : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Mr : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Mr : Uint32Array,
    "%URIError%": Noe,
    "%WeakMap%": typeof WeakMap > "u" ? Mr : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Mr : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Mr : WeakSet,
    "%Function.prototype.call%": p0,
    "%Function.prototype.apply%": $N,
    "%Object.defineProperty%": Foe,
    "%Object.getPrototypeOf%": joe,
    "%Math.abs%": Moe,
    "%Math.floor%": Roe,
    "%Math.max%": Coe,
    "%Math.min%": Uoe,
    "%Math.pow%": $oe,
    "%Math.round%": Loe,
    "%Math.sign%": Doe,
    "%Reflect.getPrototypeOf%": Hoe
};
if (ni) try {
    null.error;
} catch (e) {
    var Koe = ni(ni(e));
    gf["%Error.prototype%"] = Koe;
}
var Woe = function e(t) {
    var r;
    if (t === "%AsyncFunction%") r = R_("async function () {}");
    else if (t === "%GeneratorFunction%") r = R_("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") r = R_("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var n = e("%AsyncGeneratorFunction%");
        n && (r = n.prototype);
    } else if (t === "%AsyncIteratorPrototype%") {
        var i = e("%AsyncGenerator%");
        i && ni && (r = ni(i.prototype));
    }
    return gf[t] = r, r;
}, iI = {
    __proto__: null,
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
}, g0 = i1, ym = Toe(), Voe = g0.call(p0, Array.prototype.concat), Goe = g0.call($N, Array.prototype.splice), oI = g0.call(p0, String.prototype.replace), mm = g0.call(p0, String.prototype.slice), Zoe = g0.call(p0, RegExp.prototype.exec), Yoe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Xoe = /\\(\\)?/g, Joe = function(t) {
    var r = mm(t, 0, 1), n = mm(t, -1);
    if (r === "%" && n !== "%") throw new sd("invalid intrinsic syntax, expected closing `%`");
    if (n === "%" && r !== "%") throw new sd("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return oI(t, Yoe, function(o, s, a, u) {
        i[i.length] = a ? oI(u, Xoe, "$1") : s || o;
    }), i;
}, Qoe = function(t, r) {
    var n = t, i;
    if (ym(iI, n) && (i = iI[n], n = "%" + i[0] + "%"), ym(gf, n)) {
        var o = gf[n];
        if (o === Sl && (o = Woe(n)), typeof o > "u" && !r) throw new Vl("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return {
            alias: i,
            name: n,
            value: o
        };
    }
    throw new sd("intrinsic " + t + " does not exist!");
}, dS = function(t, r) {
    if (typeof t != "string" || t.length === 0) throw new Vl("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r != "boolean") throw new Vl('"allowMissing" argument must be a boolean');
    if (Zoe(/^%?[^%]*%?$/, t) === null) throw new sd("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var n = Joe(t), i = n.length > 0 ? n[0] : "", o = Qoe("%" + i + "%", r), s = o.name, a = o.value, u = !1, f = o.alias;
    f && (i = f[0], Goe(n, Voe([
        0,
        1
    ], f)));
    for(var c = 1, l = !0; c < n.length; c += 1){
        var p = n[c], y = mm(p, 0, 1), _ = mm(p, -1);
        if ((y === '"' || y === "'" || y === "`" || _ === '"' || _ === "'" || _ === "`") && y !== _) throw new sd("property names with quotes must have matching quotes");
        if ((p === "constructor" || !l) && (u = !0), i += "." + p, s = "%" + i + "%", ym(gf, s)) a = gf[s];
        else if (a != null) {
            if (!(p in a)) {
                if (!r) throw new Vl("base intrinsic for " + t + " exists, but the property is not available.");
                return;
            }
            if (gp && c + 1 >= n.length) {
                var A = gp(a, p);
                l = !!A, l && "get" in A && !("originalValue" in A.get) ? a = A.get : a = a[p];
            } else l = ym(a, p), a = a[p];
            l && !u && (gf[s] = a);
        }
    }
    return a;
}, LN = dS, DN = CN, ese = DN([
    LN("%String.prototype.indexOf%")
]), FN = function(t, r) {
    var n = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ LN(t, !!r);
    return typeof n == "function" && ese(t, ".prototype.") > -1 ? DN(/** @type {const} */ [
        n
    ]) : n;
}, tse = dS, y0 = FN, rse = r1, nse = Rd, sI = tse("%Map%", !0), ise = y0("Map.prototype.get", !0), ose = y0("Map.prototype.set", !0), sse = y0("Map.prototype.has", !0), ase = y0("Map.prototype.delete", !0), cse = y0("Map.prototype.size", !0), zN = !!sI && /** @type {Exclude<import('.'), false>} */ function() {
    var t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new nse("Side channel does not contain " + rse(n));
        },
        delete: function(n) {
            if (t) {
                var i = ase(t, n);
                return cse(t) === 0 && (t = void 0), i;
            }
            return !1;
        },
        get: function(n) {
            if (t) return ise(t, n);
        },
        has: function(n) {
            return t ? sse(t, n) : !1;
        },
        set: function(n, i) {
            t || (t = new sI()), ose(t, n, i);
        }
    };
    return r;
}, use = dS, o1 = FN, fse = r1, Jg = zN, lse = Rd, gl = use("%WeakMap%", !0), dse = o1("WeakMap.prototype.get", !0), hse = o1("WeakMap.prototype.set", !0), pse = o1("WeakMap.prototype.has", !0), gse = o1("WeakMap.prototype.delete", !0), yse = gl ? /** @type {Exclude<import('.'), false>} */ function() {
    var t, r, n = {
        assert: function(i) {
            if (!n.has(i)) throw new lse("Side channel does not contain " + fse(i));
        },
        delete: function(i) {
            if (gl && i && (typeof i == "object" || typeof i == "function")) {
                if (t) return gse(t, i);
            } else if (Jg && r) return r.delete(i);
            return !1;
        },
        get: function(i) {
            return gl && i && (typeof i == "object" || typeof i == "function") && t ? dse(t, i) : r && r.get(i);
        },
        has: function(i) {
            return gl && i && (typeof i == "object" || typeof i == "function") && t ? pse(t, i) : !!r && r.has(i);
        },
        set: function(i, o) {
            gl && i && (typeof i == "object" || typeof i == "function") ? (t || (t = new gl()), hse(t, i, o)) : Jg && (r || (r = Jg()), r.set(i, o));
        }
    };
    return n;
} : Jg, mse = Rd, bse = r1, wse = Fie, vse = zN, _se = yse, Ese = _se || vse || wse, xse = function() {
    var t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new mse("Side channel does not contain " + bse(n));
        },
        delete: function(n) {
            return !!t && t.delete(n);
        },
        get: function(n) {
            return t && t.get(n);
        },
        has: function(n) {
            return !!t && t.has(n);
        },
        set: function(n, i) {
            t || (t = Ese()), t.set(n, i);
        }
    };
    return r;
}, Sse = String.prototype.replace, Ase = /%20/g, U_ = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}, hS = {
    default: U_.RFC3986,
    formatters: {
        RFC1738: function(e) {
            return Sse.call(e, Ase, "+");
        },
        RFC3986: function(e) {
            return String(e);
        }
    },
    RFC1738: U_.RFC1738,
    RFC3986: U_.RFC3986
}, Tse = hS, $_ = Object.prototype.hasOwnProperty, ef = Array.isArray, Xs = function() {
    for(var e = [], t = 0; t < 256; ++t)e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e;
}(), kse = function(t) {
    for(; t.length > 1;){
        var r = t.pop(), n = r.obj[r.prop];
        if (ef(n)) {
            for(var i = [], o = 0; o < n.length; ++o)typeof n[o] < "u" && i.push(n[o]);
            r.obj[r.prop] = i;
        }
    }
}, jN = function(t, r) {
    for(var n = r && r.plainObjects ? {
        __proto__: null
    } : {}, i = 0; i < t.length; ++i)typeof t[i] < "u" && (n[i] = t[i]);
    return n;
}, Ise = function e(t, r, n) {
    if (!r) return t;
    if (typeof r != "object" && typeof r != "function") {
        if (ef(t)) t.push(r);
        else if (t && typeof t == "object") (n && (n.plainObjects || n.allowPrototypes) || !$_.call(Object.prototype, r)) && (t[r] = !0);
        else return [
            t,
            r
        ];
        return t;
    }
    if (!t || typeof t != "object") return [
        t
    ].concat(r);
    var i = t;
    return ef(t) && !ef(r) && (i = jN(t, n)), ef(t) && ef(r) ? (r.forEach(function(o, s) {
        if ($_.call(t, s)) {
            var a = t[s];
            a && typeof a == "object" && o && typeof o == "object" ? t[s] = e(a, o, n) : t.push(o);
        } else t[s] = o;
    }), t) : Object.keys(r).reduce(function(o, s) {
        var a = r[s];
        return $_.call(o, s) ? o[s] = e(o[s], a, n) : o[s] = a, o;
    }, i);
}, Bse = function(t, r) {
    return Object.keys(r).reduce(function(n, i) {
        return n[i] = r[i], n;
    }, t);
}, Ose = function(e, t, r) {
    var n = e.replace(/\+/g, " ");
    if (r === "iso-8859-1") return n.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(n);
    } catch  {
        return n;
    }
}, L_ = 1024, Pse = function(t, r, n, i, o) {
    if (t.length === 0) return t;
    var s = t;
    if (typeof t == "symbol" ? s = Symbol.prototype.toString.call(t) : typeof t != "string" && (s = String(t)), n === "iso-8859-1") return escape(s).replace(/%u[0-9a-f]{4}/gi, function(y) {
        return "%26%23" + parseInt(y.slice(2), 16) + "%3B";
    });
    for(var a = "", u = 0; u < s.length; u += L_){
        for(var f = s.length >= L_ ? s.slice(u, u + L_) : s, c = [], l = 0; l < f.length; ++l){
            var p = f.charCodeAt(l);
            if (p === 45 || p === 46 || p === 95 || p === 126 || p >= 48 && p <= 57 || p >= 65 && p <= 90 || p >= 97 && p <= 122 || o === Tse.RFC1738 && (p === 40 || p === 41)) {
                c[c.length] = f.charAt(l);
                continue;
            }
            if (p < 128) {
                c[c.length] = Xs[p];
                continue;
            }
            if (p < 2048) {
                c[c.length] = Xs[192 | p >> 6] + Xs[128 | p & 63];
                continue;
            }
            if (p < 55296 || p >= 57344) {
                c[c.length] = Xs[224 | p >> 12] + Xs[128 | p >> 6 & 63] + Xs[128 | p & 63];
                continue;
            }
            l += 1, p = 65536 + ((p & 1023) << 10 | f.charCodeAt(l) & 1023), c[c.length] = Xs[240 | p >> 18] + Xs[128 | p >> 12 & 63] + Xs[128 | p >> 6 & 63] + Xs[128 | p & 63];
        }
        a += c.join("");
    }
    return a;
}, Nse = function(t) {
    for(var r = [
        {
            obj: {
                o: t
            },
            prop: "o"
        }
    ], n = [], i = 0; i < r.length; ++i)for(var o = r[i], s = o.obj[o.prop], a = Object.keys(s), u = 0; u < a.length; ++u){
        var f = a[u], c = s[f];
        typeof c == "object" && c !== null && n.indexOf(c) === -1 && (r.push({
            obj: s,
            prop: f
        }), n.push(c));
    }
    return kse(r), t;
}, Mse = function(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]";
}, Rse = function(t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, Cse = function(t, r) {
    return [].concat(t, r);
}, Use = function(t, r) {
    if (ef(t)) {
        for(var n = [], i = 0; i < t.length; i += 1)n.push(r(t[i]));
        return n;
    }
    return r(t);
}, HN = {
    arrayToObject: jN,
    assign: Bse,
    combine: Cse,
    compact: Nse,
    decode: Ose,
    encode: Pse,
    isBuffer: Rse,
    isRegExp: Mse,
    maybeMap: Use,
    merge: Ise
}, qN = xse, Uy = HN, Hh = hS, $se = Object.prototype.hasOwnProperty, KN = {
    brackets: function(t) {
        return t + "[]";
    },
    comma: "comma",
    indices: function(t, r) {
        return t + "[" + r + "]";
    },
    repeat: function(t) {
        return t;
    }
}, la = Array.isArray, Lse = Array.prototype.push, WN = function(e, t) {
    Lse.apply(e, la(t) ? t : [
        t
    ]);
}, Dse = Date.prototype.toISOString, aI = Hh.default, Gn = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    commaRoundTrip: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: Uy.encode,
    encodeValuesOnly: !1,
    filter: void 0,
    format: aI,
    formatter: Hh.formatters[aI],
    // deprecated
    indices: !1,
    serializeDate: function(t) {
        return Dse.call(t);
    },
    skipNulls: !1,
    strictNullHandling: !1
}, Fse = function(t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, D_ = {}, zse = function e(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U) {
    for(var D = t, H = U, K = 0, re = !1; (H = H.get(D_)) !== void 0 && !re;){
        var Q = H.get(t);
        if (K += 1, typeof Q < "u") {
            if (Q === K) throw new RangeError("Cyclic object value");
            re = !0;
        }
        typeof H.get(D_) > "u" && (K = 0);
    }
    if (typeof c == "function" ? D = c(r, D) : D instanceof Date ? D = y(D) : n === "comma" && la(D) && (D = Uy.maybeMap(D, function(k) {
        return k instanceof Date ? y(k) : k;
    })), D === null) {
        if (s) return f && !O ? f(r, Gn.encoder, N, "key", _) : r;
        D = "";
    }
    if (Fse(D) || Uy.isBuffer(D)) {
        if (f) {
            var G = O ? r : f(r, Gn.encoder, N, "key", _);
            return [
                A(G) + "=" + A(f(D, Gn.encoder, N, "value", _))
            ];
        }
        return [
            A(r) + "=" + A(String(D))
        ];
    }
    var R = [];
    if (typeof D > "u") return R;
    var X;
    if (n === "comma" && la(D)) O && f && (D = Uy.maybeMap(D, f)), X = [
        {
            value: D.length > 0 ? D.join(",") || null : void 0
        }
    ];
    else if (la(c)) X = c;
    else {
        var $ = Object.keys(D);
        X = l ? $.sort(l) : $;
    }
    var S = u ? String(r).replace(/\./g, "%2E") : String(r), w = i && la(D) && D.length === 1 ? S + "[]" : S;
    if (o && la(D) && D.length === 0) return w + "[]";
    for(var g = 0; g < X.length; ++g){
        var m = X[g], E = typeof m == "object" && m && typeof m.value < "u" ? m.value : D[m];
        if (!(a && E === null)) {
            var T = p && u ? String(m).replace(/\./g, "%2E") : String(m), I = la(D) ? typeof n == "function" ? n(w, T) : w : w + (p ? "." + T : "[" + T + "]");
            U.set(t, K);
            var P = qN();
            P.set(D_, U), WN(R, e(E, I, n, i, o, s, a, u, n === "comma" && O && la(D) ? null : f, c, l, p, y, _, A, O, N, P));
        }
    }
    return R;
}, jse = function(t) {
    if (!t) return Gn;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function") throw new TypeError("Encoder has to be a function.");
    var r = t.charset || Gn.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var n = Hh.default;
    if (typeof t.format < "u") {
        if (!$se.call(Hh.formatters, t.format)) throw new TypeError("Unknown format option provided.");
        n = t.format;
    }
    var i = Hh.formatters[n], o = Gn.filter;
    (typeof t.filter == "function" || la(t.filter)) && (o = t.filter);
    var s;
    if (t.arrayFormat in KN ? s = t.arrayFormat : "indices" in t ? s = t.indices ? "indices" : "repeat" : s = Gn.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var a = typeof t.allowDots > "u" ? t.encodeDotInKeys === !0 ? !0 : Gn.allowDots : !!t.allowDots;
    return {
        addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Gn.addQueryPrefix,
        allowDots: a,
        allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Gn.allowEmptyArrays,
        arrayFormat: s,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Gn.charsetSentinel,
        commaRoundTrip: !!t.commaRoundTrip,
        delimiter: typeof t.delimiter > "u" ? Gn.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : Gn.encode,
        encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Gn.encodeDotInKeys,
        encoder: typeof t.encoder == "function" ? t.encoder : Gn.encoder,
        encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Gn.encodeValuesOnly,
        filter: o,
        format: n,
        formatter: i,
        serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Gn.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Gn.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Gn.strictNullHandling
    };
}, Hse = function(e, t) {
    var r = e, n = jse(t), i, o;
    typeof n.filter == "function" ? (o = n.filter, r = o("", r)) : la(n.filter) && (o = n.filter, i = o);
    var s = [];
    if (typeof r != "object" || r === null) return "";
    var a = KN[n.arrayFormat], u = a === "comma" && n.commaRoundTrip;
    i || (i = Object.keys(r)), n.sort && i.sort(n.sort);
    for(var f = qN(), c = 0; c < i.length; ++c){
        var l = i[c], p = r[l];
        n.skipNulls && p === null || WN(s, zse(p, l, a, u, n.allowEmptyArrays, n.strictNullHandling, n.skipNulls, n.encodeDotInKeys, n.encode ? n.encoder : null, n.filter, n.sort, n.allowDots, n.serializeDate, n.format, n.formatter, n.encodeValuesOnly, n.charset, f));
    }
    var y = s.join(n.delimiter), _ = n.addQueryPrefix === !0 ? "?" : "";
    return n.charsetSentinel && (n.charset === "iso-8859-1" ? _ += "utf8=%26%2310003%3B&" : _ += "utf8=%E2%9C%93&"), y.length > 0 ? _ + y : "";
}, xf = HN, ax = Object.prototype.hasOwnProperty, cI = Array.isArray, Nn = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: xf.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1,
    throwOnLimitExceeded: !1
}, qse = function(e) {
    return e.replace(/&#(\d+);/g, function(t, r) {
        return String.fromCharCode(parseInt(r, 10));
    });
}, VN = function(e, t, r) {
    if (e && typeof e == "string" && t.comma && e.indexOf(",") > -1) return e.split(",");
    if (t.throwOnLimitExceeded && r >= t.arrayLimit) throw new RangeError("Array limit exceeded. Only " + t.arrayLimit + " element" + (t.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return e;
}, Kse = "utf8=%26%2310003%3B", Wse = "utf8=%E2%9C%93", Vse = function(t, r) {
    var n = {
        __proto__: null
    }, i = r.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
    i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var o = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, s = i.split(r.delimiter, r.throwOnLimitExceeded ? o + 1 : o);
    if (r.throwOnLimitExceeded && s.length > o) throw new RangeError("Parameter limit exceeded. Only " + o + " parameter" + (o === 1 ? "" : "s") + " allowed.");
    var a = -1, u, f = r.charset;
    if (r.charsetSentinel) for(u = 0; u < s.length; ++u)s[u].indexOf("utf8=") === 0 && (s[u] === Wse ? f = "utf-8" : s[u] === Kse && (f = "iso-8859-1"), a = u, u = s.length);
    for(u = 0; u < s.length; ++u)if (u !== a) {
        var c = s[u], l = c.indexOf("]="), p = l === -1 ? c.indexOf("=") : l + 1, y, _;
        p === -1 ? (y = r.decoder(c, Nn.decoder, f, "key"), _ = r.strictNullHandling ? null : "") : (y = r.decoder(c.slice(0, p), Nn.decoder, f, "key"), _ = xf.maybeMap(VN(c.slice(p + 1), r, cI(n[y]) ? n[y].length : 0), function(O) {
            return r.decoder(O, Nn.decoder, f, "value");
        })), _ && r.interpretNumericEntities && f === "iso-8859-1" && (_ = qse(String(_))), c.indexOf("[]=") > -1 && (_ = cI(_) ? [
            _
        ] : _);
        var A = ax.call(n, y);
        A && r.duplicates === "combine" ? n[y] = xf.combine(n[y], _) : (!A || r.duplicates === "last") && (n[y] = _);
    }
    return n;
}, Gse = function(e, t, r, n) {
    var i = 0;
    if (e.length > 0 && e[e.length - 1] === "[]") {
        var o = e.slice(0, -1).join("");
        i = Array.isArray(t) && t[o] ? t[o].length : 0;
    }
    for(var s = n ? t : VN(t, r, i), a = e.length - 1; a >= 0; --a){
        var u, f = e[a];
        if (f === "[]" && r.parseArrays) u = r.allowEmptyArrays && (s === "" || r.strictNullHandling && s === null) ? [] : xf.combine([], s);
        else {
            u = r.plainObjects ? {
                __proto__: null
            } : {};
            var c = f.charAt(0) === "[" && f.charAt(f.length - 1) === "]" ? f.slice(1, -1) : f, l = r.decodeDotInKeys ? c.replace(/%2E/g, ".") : c, p = parseInt(l, 10);
            !r.parseArrays && l === "" ? u = {
                0: s
            } : !isNaN(p) && f !== l && String(p) === l && p >= 0 && r.parseArrays && p <= r.arrayLimit ? (u = [], u[p] = s) : l !== "__proto__" && (u[l] = s);
        }
        s = u;
    }
    return s;
}, Zse = function(t, r, n, i) {
    if (t) {
        var o = n.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, s = /(\[[^[\]]*])/, a = /(\[[^[\]]*])/g, u = n.depth > 0 && s.exec(o), f = u ? o.slice(0, u.index) : o, c = [];
        if (f) {
            if (!n.plainObjects && ax.call(Object.prototype, f) && !n.allowPrototypes) return;
            c.push(f);
        }
        for(var l = 0; n.depth > 0 && (u = a.exec(o)) !== null && l < n.depth;){
            if (l += 1, !n.plainObjects && ax.call(Object.prototype, u[1].slice(1, -1)) && !n.allowPrototypes) return;
            c.push(u[1]);
        }
        if (u) {
            if (n.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + n.depth + " and strictDepth is true");
            c.push("[" + o.slice(u.index) + "]");
        }
        return Gse(c, r, n, i);
    }
}, Yse = function(t) {
    if (!t) return Nn;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.decodeDotInKeys < "u" && typeof t.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.decoder !== null && typeof t.decoder < "u" && typeof t.decoder != "function") throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof t.throwOnLimitExceeded < "u" && typeof t.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var r = typeof t.charset > "u" ? Nn.charset : t.charset, n = typeof t.duplicates > "u" ? Nn.duplicates : t.duplicates;
    if (n !== "combine" && n !== "first" && n !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
    var i = typeof t.allowDots > "u" ? t.decodeDotInKeys === !0 ? !0 : Nn.allowDots : !!t.allowDots;
    return {
        allowDots: i,
        allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Nn.allowEmptyArrays,
        allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Nn.allowPrototypes,
        allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Nn.allowSparse,
        arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Nn.arrayLimit,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Nn.charsetSentinel,
        comma: typeof t.comma == "boolean" ? t.comma : Nn.comma,
        decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Nn.decodeDotInKeys,
        decoder: typeof t.decoder == "function" ? t.decoder : Nn.decoder,
        delimiter: typeof t.delimiter == "string" || xf.isRegExp(t.delimiter) ? t.delimiter : Nn.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Nn.depth,
        duplicates: n,
        ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Nn.interpretNumericEntities,
        parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Nn.parameterLimit,
        parseArrays: t.parseArrays !== !1,
        plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Nn.plainObjects,
        strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Nn.strictDepth,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Nn.strictNullHandling,
        throwOnLimitExceeded: typeof t.throwOnLimitExceeded == "boolean" ? t.throwOnLimitExceeded : !1
    };
}, Xse = function(e, t) {
    var r = Yse(t);
    if (e === "" || e === null || typeof e > "u") return r.plainObjects ? {
        __proto__: null
    } : {};
    for(var n = typeof e == "string" ? Vse(e, r) : e, i = r.plainObjects ? {
        __proto__: null
    } : {}, o = Object.keys(n), s = 0; s < o.length; ++s){
        var a = o[s], u = Zse(a, n[a], r, typeof e == "string");
        i = xf.merge(i, u, r);
    }
    return r.allowSparse === !0 ? i : xf.compact(i);
}, Jse = Hse, Qse = Xse, eae = hS, tae = {
    formats: eae,
    parse: Qse,
    stringify: Jse
}, rae = oie;
function ls() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var nae = /^([a-z0-9.+-]+:)/i, iae = /:[0-9]*$/, oae = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, sae = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
], aae = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
].concat(sae), cx = [
    "'"
].concat(aae), uI = [
    "%",
    "/",
    "?",
    ";",
    "#"
].concat(cx), fI = [
    "/",
    "?",
    "#"
], cae = 255, lI = /^[+a-z0-9A-Z_-]{0,63}$/, uae = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, fae = {
    javascript: !0,
    "javascript:": !0
}, ux = {
    javascript: !0,
    "javascript:": !0
}, Gl = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}, fx = tae;
function m0(e, t, r) {
    if (e && typeof e == "object" && e instanceof ls) return e;
    var n = new ls();
    return n.parse(e, t, r), n;
}
ls.prototype.parse = function(e, t, r) {
    if (typeof e != "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o = e.split(i), s = /\\/g;
    o[0] = o[0].replace(s, "/"), e = o.join(i);
    var a = e;
    if (a = a.trim(), !r && e.split("#").length === 1) {
        var u = oae.exec(a);
        if (u) return this.path = a, this.href = a, this.pathname = u[1], u[2] ? (this.search = u[2], t ? this.query = fx.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
    }
    var f = nae.exec(a);
    if (f) {
        f = f[0];
        var c = f.toLowerCase();
        this.protocol = c, a = a.substr(f.length);
    }
    if (r || f || a.match(/^\/\/[^@/]+@[^@/]+/)) {
        var l = a.substr(0, 2) === "//";
        l && !(f && ux[f]) && (a = a.substr(2), this.slashes = !0);
    }
    if (!ux[f] && (l || f && !Gl[f])) {
        for(var p = -1, y = 0; y < fI.length; y++){
            var _ = a.indexOf(fI[y]);
            _ !== -1 && (p === -1 || _ < p) && (p = _);
        }
        var A, O;
        p === -1 ? O = a.lastIndexOf("@") : O = a.lastIndexOf("@", p), O !== -1 && (A = a.slice(0, O), a = a.slice(O + 1), this.auth = decodeURIComponent(A)), p = -1;
        for(var y = 0; y < uI.length; y++){
            var _ = a.indexOf(uI[y]);
            _ !== -1 && (p === -1 || _ < p) && (p = _);
        }
        p === -1 && (p = a.length), this.host = a.slice(0, p), a = a.slice(p), this.parseHost(), this.hostname = this.hostname || "";
        var N = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!N) for(var U = this.hostname.split(/\./), y = 0, D = U.length; y < D; y++){
            var H = U[y];
            if (H && !H.match(lI)) {
                for(var K = "", re = 0, Q = H.length; re < Q; re++)H.charCodeAt(re) > 127 ? K += "x" : K += H[re];
                if (!K.match(lI)) {
                    var G = U.slice(0, y), R = U.slice(y + 1), X = H.match(uae);
                    X && (G.push(X[1]), R.unshift(X[2])), R.length && (a = "/" + R.join(".") + a), this.hostname = G.join(".");
                    break;
                }
            }
        }
        this.hostname.length > cae ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), N || (this.hostname = rae.toASCII(this.hostname));
        var $ = this.port ? ":" + this.port : "", S = this.hostname || "";
        this.host = S + $, this.href += this.host, N && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a));
    }
    if (!fae[c]) for(var y = 0, D = cx.length; y < D; y++){
        var w = cx[y];
        if (a.indexOf(w) !== -1) {
            var g = encodeURIComponent(w);
            g === w && (g = escape(w)), a = a.split(w).join(g);
        }
    }
    var m = a.indexOf("#");
    m !== -1 && (this.hash = a.substr(m), a = a.slice(0, m));
    var E = a.indexOf("?");
    if (E !== -1 ? (this.search = a.substr(E), this.query = a.substr(E + 1), t && (this.query = fx.parse(this.query)), a = a.slice(0, E)) : t && (this.search = "", this.query = {}), a && (this.pathname = a), Gl[c] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var $ = this.pathname || "", T = this.search || "";
        this.path = $ + T;
    }
    return this.href = this.format(), this;
};
function lae(e) {
    return typeof e == "string" && (e = m0(e)), e instanceof ls ? e.format() : ls.prototype.format.call(e);
}
ls.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = !1, o = "";
    this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (o = fx.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1
    }));
    var s = this.search || o && "?" + o || "";
    return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Gl[t]) && i !== !1 ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), s && s.charAt(0) !== "?" && (s = "?" + s), r = r.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a);
    }), s = s.replace("#", "%23"), t + i + r + s + n;
};
function dae(e, t) {
    return m0(e, !1, !0).resolve(t);
}
ls.prototype.resolve = function(e) {
    return this.resolveObject(m0(e, !1, !0)).format();
};
function hae(e, t) {
    return e ? m0(e, !1, !0).resolveObject(t) : t;
}
ls.prototype.resolveObject = function(e) {
    if (typeof e == "string") {
        var t = new ls();
        t.parse(e, !1, !0), e = t;
    }
    for(var r = new ls(), n = Object.keys(this), i = 0; i < n.length; i++){
        var o = n[i];
        r[o] = this[o];
    }
    if (r.hash = e.hash, e.href === "") return r.href = r.format(), r;
    if (e.slashes && !e.protocol) {
        for(var s = Object.keys(e), a = 0; a < s.length; a++){
            var u = s[a];
            u !== "protocol" && (r[u] = e[u]);
        }
        return Gl[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
    }
    if (e.protocol && e.protocol !== r.protocol) {
        if (!Gl[e.protocol]) {
            for(var f = Object.keys(e), c = 0; c < f.length; c++){
                var l = f[c];
                r[l] = e[l];
            }
            return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !ux[e.protocol]) {
            for(var D = (e.pathname || "").split("/"); D.length && !(e.host = D.shift()););
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), D[0] !== "" && D.unshift(""), D.length < 2 && D.unshift(""), r.pathname = D.join("/");
        } else r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
            var p = r.pathname || "", y = r.search || "";
            r.path = p + y;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    }
    var _ = r.pathname && r.pathname.charAt(0) === "/", A = e.host || e.pathname && e.pathname.charAt(0) === "/", O = A || _ || r.host && e.pathname, N = O, U = r.pathname && r.pathname.split("/") || [], D = e.pathname && e.pathname.split("/") || [], H = r.protocol && !Gl[r.protocol];
    if (H && (r.hostname = "", r.port = null, r.host && (U[0] === "" ? U[0] = r.host : U.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (D[0] === "" ? D[0] = e.host : D.unshift(e.host)), e.host = null), O = O && (D[0] === "" || U[0] === "")), A) r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, U = D;
    else if (D.length) U || (U = []), U.pop(), U = U.concat(D), r.search = e.search, r.query = e.query;
    else if (e.search != null) {
        if (H) {
            r.host = U.shift(), r.hostname = r.host;
            var K = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            K && (r.auth = K.shift(), r.hostname = K.shift(), r.host = r.hostname);
        }
        return r.search = e.search, r.query = e.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
    }
    if (!U.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
    for(var re = U.slice(-1)[0], Q = (r.host || e.host || U.length > 1) && (re === "." || re === "..") || re === "", G = 0, R = U.length; R >= 0; R--)re = U[R], re === "." ? U.splice(R, 1) : re === ".." ? (U.splice(R, 1), G++) : G && (U.splice(R, 1), G--);
    if (!O && !N) for(; G--; G)U.unshift("..");
    O && U[0] !== "" && (!U[0] || U[0].charAt(0) !== "/") && U.unshift(""), Q && U.join("/").substr(-1) !== "/" && U.push("");
    var X = U[0] === "" || U[0] && U[0].charAt(0) === "/";
    if (H) {
        r.hostname = X ? "" : U.length ? U.shift() : "", r.host = r.hostname;
        var K = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
        K && (r.auth = K.shift(), r.hostname = K.shift(), r.host = r.hostname);
    }
    return O = O || r.host && U.length, O && !X && U.unshift(""), U.length > 0 ? r.pathname = U.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
ls.prototype.parseHost = function() {
    var e = this.host, t = iae.exec(e);
    t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
Md.parse = m0;
Md.resolve = dae;
Md.resolveObject = hae;
Md.format = lae;
Md.Url = ls;
var pae = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), gae = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), yae = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && pae(t, e, r);
    return gae(t, e), t;
}, mae = Ge && Ge.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    };
};
Object.defineProperty(t1, "__esModule", {
    value: !0
});
t1.BaseRpc = void 0;
const dI = yae(ka), Qg = mae(Md), hI = mo, pI = (e)=>e.substr(0, 2) === "0x" ? e : "0x" + e;
let gI = 0;
class bae {
    constructor({ baseUrl: t, memshrewUrl: r, headers: n, blockTag: i }){
        this.baseUrl = t || "http://localhost:8080", this.memshrewUrl = r || t, this.blockTag = i || "latest", this.headers = n || {};
    }
    async _preview({ method: t, input: r }) {
        const n = await (await fetch(Qg.default.format({
            ...Qg.default.parse(this.memshrewUrl || this.baseUrl),
            pathname: "/"
        }), {})).json();
        if (n.error) {
            const s = new Error(n.error.message);
            throw s.code = n.error.code, s;
        }
        if (n.length === 0) throw Error("no mempool block built by memshrew");
        const i = n.result[0], o = await (await fetch(Qg.default.format({
            ...Qg.default.parse(this.baseUrl),
            pathname: "/"
        }), {
            method: "POST",
            body: JSON.stringify({
                id: gI++,
                jsonrpc: "2.0",
                method: "metashrew_preview",
                params: [
                    i,
                    t,
                    r,
                    "latest"
                ]
            }),
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        })).json();
        return pI(o.result);
    }
    async _call({ method: t, input: r }, n = "latest") {
        if (n === "pending") return await this._preview({
            method: t,
            input: r
        });
        const i = await (await fetch(this.baseUrl, {
            method: "POST",
            body: JSON.stringify({
                id: gI++,
                jsonrpc: "2.0",
                method: "metashrew_view",
                params: [
                    t,
                    r,
                    n || this.blockTag
                ]
            }),
            headers: Object.assign({}, {
                "Content-Type": "application/json",
                Accept: "application/json"
            }, this.headers)
        })).json();
        return pI(i.result);
    }
    async runesbyaddress({ address: t }, r = "latest") {
        const n = dI.encodeWalletInput(t), i = await this._call({
            method: "runesbyaddress",
            input: n
        }, r);
        return dI.decodeWalletOutput(i);
    }
    async runesbyheight({ height: t }, r = "latest") {
        const n = (0, hI.encodeBlockHeightInput)(t), i = await this._call({
            method: "runesbyheight",
            input: n
        }, r);
        return (0, hI.decodeRunesResponse)(i);
    }
}
t1.BaseRpc = bae;
var uo = {}, hn = {}, Qn = {}, pS = {}, wi = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.isNone = e.isSome = e.None = e.Some = e.OptionType = void 0, e.OptionType = {
        Some: Symbol(":some"),
        None: Symbol(":none")
    };
    class t {
        constructor(a){
            this.val = a;
        }
        get type() {
            return e.OptionType.Some;
        }
        isSome() {
            return !0;
        }
        isNone() {
            return !1;
        }
        match(a) {
            return a.some(this.val);
        }
        map(a) {
            return n(a(this.val));
        }
        inspect(a) {
            return a(this.val), this;
        }
        andThen(a) {
            return a(this.val);
        }
        or(a) {
            return this;
        }
        orElse(a) {
            return this;
        }
        and(a) {
            return a;
        }
        unwrapOr(a) {
            return this.val;
        }
        unwrap() {
            return this.val;
        }
    }
    class r {
        get type() {
            return e.OptionType.None;
        }
        isSome() {
            return !1;
        }
        isNone() {
            return !0;
        }
        match({ none: a }) {
            return typeof a == "function" ? a() : a;
        }
        map(a) {
            return new r();
        }
        inspect(a) {
            return this;
        }
        andThen(a) {
            return new r();
        }
        or(a) {
            return a;
        }
        orElse(a) {
            return a();
        }
        and(a) {
            return new r();
        }
        unwrapOr(a) {
            return a;
        }
        unwrap() {
            throw new ReferenceError("Trying to unwrap None.");
        }
    }
    function n(s) {
        return new t(s);
    }
    e.Some = n, e.None = new r();
    function i(s) {
        return s.isSome();
    }
    e.isSome = i;
    function o(s) {
        return s.isNone();
    }
    e.isNone = o;
})(wi);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u8 = e.U8_MAX_BIGINT = void 0;
    const t = wi;
    e.U8_MAX_BIGINT = 0xffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U8_MAX_BIGINT;
    }
    e.u8 = r, function(n) {
        n.MAX = n(e.U8_MAX_BIGINT);
        function i(s, a) {
            const u = s + a;
            return u > n.MAX ? t.None : (0, t.Some)(n(u));
        }
        n.checkedAdd = i;
        function o(s, a) {
            const u = s - a;
            return u < 0n ? t.None : (0, t.Some)(n(u));
        }
        n.checkedSub = o;
    }(r || (e.u8 = r = {}));
})(pS);
var gS = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u32 = e.U32_MAX_BIGINT = void 0;
    const t = wi;
    e.U32_MAX_BIGINT = 0xffffffffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U32_MAX_BIGINT;
    }
    e.u32 = r, function(n) {
        n.MAX = n(e.U32_MAX_BIGINT);
        function i(s, a) {
            const u = s + a;
            return u > n.MAX ? t.None : (0, t.Some)(n(u));
        }
        n.checkedAdd = i;
        function o(s, a) {
            const u = s - a;
            return u < 0n ? t.None : (0, t.Some)(n(u));
        }
        n.checkedSub = o;
    }(r || (e.u32 = r = {}));
})(gS);
var yS = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u64 = e.U64_MAX_BIGINT = void 0;
    const t = wi;
    e.U64_MAX_BIGINT = 0xffffffffffffffffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U64_MAX_BIGINT;
    }
    e.u64 = r, function(n) {
        n.MAX = n(e.U64_MAX_BIGINT);
        function i(s, a) {
            const u = s + a;
            return u > n.MAX ? t.None : (0, t.Some)(n(u));
        }
        n.checkedAdd = i;
        function o(s, a) {
            const u = s - a;
            return u < 0n ? t.None : (0, t.Some)(n(u));
        }
        n.checkedSub = o;
    }(r || (e.u64 = r = {}));
})(yS);
var qh = {}, b0 = {};
Object.defineProperty(b0, "__esModule", {
    value: !0
});
b0.SeekBuffer = void 0;
class wae {
    constructor(t){
        this.buffer = t, this.seekIndex = 0;
    }
    readUInt8() {
        if (!this.isFinished()) return this.buffer.readUInt8(this.seekIndex++);
    }
    isFinished() {
        return this.seekIndex >= this.buffer.length;
    }
}
b0.SeekBuffer = wae;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getAllU128 = e.u128 = e.U128_MAX_BIGINT = void 0;
    const t = wi, r = b0, n = yS, i = gS, o = pS;
    e.U128_MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
    function s(u) {
        return (typeof u == "bigint" ? u : BigInt(u)) & e.U128_MAX_BIGINT;
    }
    e.u128 = s, function(u) {
        u.MAX = u(e.U128_MAX_BIGINT);
        function f(Q, G) {
            const R = Q + G;
            return R > u.MAX ? t.None : (0, t.Some)(u(R));
        }
        u.checkedAdd = f;
        function c(Q, G) {
            const R = u.checkedAdd(Q, G);
            if (R.isNone()) throw new Error("checked add overflow");
            return R.unwrap();
        }
        u.checkedAddThrow = c;
        function l(Q, G) {
            const R = Q - G;
            return R < 0n ? t.None : (0, t.Some)(u(R));
        }
        u.checkedSub = l;
        function p(Q, G) {
            const R = u.checkedSub(Q, G);
            if (R.isNone()) throw new Error("checked sub overflow");
            return R.unwrap();
        }
        u.checkedSubThrow = p;
        function y(Q, G) {
            const R = Q * G;
            return R > u.MAX ? t.None : (0, t.Some)(u(R));
        }
        u.checkedMultiply = y;
        function _(Q, G) {
            const R = Q + G;
            return R > u.MAX ? u.MAX : u(R);
        }
        u.saturatingAdd = _;
        function A(Q, G) {
            const R = Q * G;
            return R > u.MAX ? u.MAX : u(R);
        }
        u.saturatingMultiply = A;
        function O(Q, G) {
            return u(Q < G ? 0 : Q - G);
        }
        u.saturatingSub = O;
        function N(Q) {
            try {
                return (0, t.Some)(U(Q));
            } catch  {
                return t.None;
            }
        }
        u.decodeVarInt = N;
        function U(Q) {
            let G = u(0);
            for(let R = 0; R <= 18; R++){
                const X = Q.readUInt8();
                if (X === void 0) throw new Error("Unterminated");
                const $ = u(X) & 127n;
                if (R === 18 && ($ & 124n) !== 0n) throw new Error("Overflow");
                if (G = u(G | $ << u(7 * R)), !(X & 128)) return G;
            }
            throw new Error("Overlong");
        }
        u.tryDecodeVarInt = U;
        function D(Q) {
            const G = [];
            for(; Q >> 7n > 0n;)G.push(Number(Q & 0xffn) | 128), Q = u(Q >> 7n);
            return G.push(Number(Q & 0xffn)), We.from(G);
        }
        u.encodeVarInt = D;
        function H(Q) {
            return Q > n.u64.MAX ? t.None : (0, t.Some)((0, n.u64)(Q));
        }
        u.tryIntoU64 = H;
        function K(Q) {
            return Q > i.u32.MAX ? t.None : (0, t.Some)((0, i.u32)(Q));
        }
        u.tryIntoU32 = K;
        function re(Q) {
            return Q > o.u8.MAX ? t.None : (0, t.Some)((0, o.u8)(Q));
        }
        u.tryIntoU8 = re;
    }(s || (e.u128 = s = {}));
    function* a(u) {
        const f = new r.SeekBuffer(u);
        for(; !f.isFinished();){
            const c = s.tryDecodeVarInt(f);
            if (c === void 0) return;
            yield c;
        }
    }
    e.getAllU128 = a;
})(qh);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u128 = e.u64 = e.u32 = e.u8 = void 0;
    var t = pS;
    Object.defineProperty(e, "u8", {
        enumerable: !0,
        get: function() {
            return t.u8;
        }
    });
    var r = gS;
    Object.defineProperty(e, "u32", {
        enumerable: !0,
        get: function() {
            return r.u32;
        }
    });
    var n = yS;
    Object.defineProperty(e, "u64", {
        enumerable: !0,
        get: function() {
            return n.u64;
        }
    });
    var i = qh;
    Object.defineProperty(e, "u128", {
        enumerable: !0,
        get: function() {
            return i.u128;
        }
    });
})(Qn);
var uc = {};
Object.defineProperty(uc, "__esModule", {
    value: !0
});
uc.script = uc.opcodes = void 0;
var Kh;
(function(e) {
    function t(i) {
        return i < as.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
    }
    e.encodingLength = t;
    function r(i, o, s) {
        const a = t(o);
        return a === 1 ? i.writeUInt8(o, s) : a === 2 ? (i.writeUInt8(as.OP_PUSHDATA1, s), i.writeUInt8(o, s + 1)) : a === 3 ? (i.writeUInt8(as.OP_PUSHDATA2, s), i.writeUInt16LE(o, s + 1)) : (i.writeUInt8(as.OP_PUSHDATA4, s), i.writeUInt32LE(o, s + 1)), a;
    }
    e.encode = r;
    function n(i, o) {
        const s = i.readUInt8(o);
        let a, u;
        if (s < as.OP_PUSHDATA1) a = s, u = 1;
        else if (s === as.OP_PUSHDATA1) {
            if (o + 2 > i.length) return null;
            a = i.readUInt8(o + 1), u = 2;
        } else if (s === as.OP_PUSHDATA2) {
            if (o + 3 > i.length) return null;
            a = i.readUInt16LE(o + 1), u = 3;
        } else {
            if (o + 5 > i.length) return null;
            if (s !== as.OP_PUSHDATA4) throw new Error("Unexpected opcode");
            a = i.readUInt32LE(o + 1), u = 5;
        }
        return {
            opcode: s,
            number: a,
            size: u
        };
    }
    e.decode = n;
})(Kh || (Kh = {}));
const as = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
};
uc.opcodes = as;
as.OP_RESERVED;
function yI(e) {
    return We.isBuffer(e);
}
var mI;
(function(e) {
    function t(n) {
        const i = n.reduce((a, u)=>yI(u) ? a + Kh.encodingLength(u.length) + u.length : a + 1, 0), o = We.allocUnsafe(i);
        let s = 0;
        if (n.forEach((a)=>{
            yI(a) ? (s += Kh.encode(o, a.length, s), a.copy(o, s), s += a.length) : (o.writeUInt8(a, s), s += 1);
        }), s !== o.length) throw new Error("Could not decode chunks");
        return o;
    }
    e.compile = t;
    function* r(n) {
        let i = 0;
        for(; i < n.length;){
            const o = n[i];
            if (o >= as.OP_0 && o <= as.OP_PUSHDATA4) {
                const s = Kh.decode(n, i);
                if (s === null || (i += s.size, i + s.number > n.length)) return !1;
                const a = n.slice(i, i + s.number);
                i += s.number, yield a;
            } else yield o, i += 1;
        }
        return !0;
    }
    e.decompile = r;
})(mI || (uc.script = mI = {}));
Object.defineProperty(hn, "__esModule", {
    value: !0
});
hn.TAPROOT_SCRIPT_PUBKEY_TYPE = hn.COMMIT_CONFIRMATIONS = hn.TAPROOT_ANNEX_PREFIX = hn.MAGIC_NUMBER = hn.OP_RETURN = hn.MAX_SCRIPT_ELEMENT_SIZE = hn.SUBSIDY_HALVING_INTERVAL = hn.RESERVED = hn.MAX_DIVISIBILITY = void 0;
const GN = Qn, ZN = uc;
hn.MAX_DIVISIBILITY = (0, GN.u8)(38);
hn.RESERVED = (0, GN.u128)(6402364363415443603228541259936211926n);
hn.SUBSIDY_HALVING_INTERVAL = 21e4;
hn.MAX_SCRIPT_ELEMENT_SIZE = 520;
hn.OP_RETURN = ZN.opcodes.OP_RETURN;
hn.MAGIC_NUMBER = ZN.opcodes.OP_13;
hn.TAPROOT_ANNEX_PREFIX = 80;
hn.COMMIT_CONFIRMATIONS = 6;
hn.TAPROOT_SCRIPT_PUBKEY_TYPE = "witness_v1_taproot";
var Cd = {};
Object.defineProperty(Cd, "__esModule", {
    value: !0
});
var YN = Cd.ProtoruneRuneId = void 0;
const Js = wi, Qs = Qn;
class Wh {
    constructor(t, r){
        this.block = t, this.tx = r;
    }
    static new(t, r) {
        const n = new Wh(t, r);
        return n.block === (0, Qs.u128)(0) && n.tx > (0, Qs.u128)(0) ? Js.None : (0, Js.Some)(n);
    }
    static sort(t) {
        return [
            ...t
        ].sort((r, n)=>Number(r.block - n.block || r.tx - n.tx));
    }
    delta(t) {
        const r = Qs.u128.checkedSub(t.block, this.block);
        if (r.isNone()) return Js.None;
        const n = r.unwrap();
        let i;
        if (n === 0n) {
            const o = Qs.u128.checkedSub(t.tx, this.tx);
            if (o.isNone()) return Js.None;
            i = o.unwrap();
        } else i = t.tx;
        return (0, Js.Some)([
            (0, Qs.u128)(n),
            (0, Qs.u128)(i)
        ]);
    }
    next(t, r) {
        const n = (0, Js.Some)(t), i = (0, Js.Some)(r);
        if (n.isNone() || i.isNone()) return Js.None;
        const o = n.unwrap(), s = i.unwrap(), a = Qs.u128.checkedAdd(this.block, o);
        if (a.isNone()) return Js.None;
        let u;
        if (o === 0n) {
            const f = Qs.u128.checkedAdd(this.tx, s);
            if (f.isNone()) return Js.None;
            u = f.unwrap();
        } else u = s;
        return Wh.new(a.unwrap(), u);
    }
    toString() {
        return `${this.block}:${this.tx}`;
    }
    static fromString(t) {
        const r = t.split(":");
        if (r.length !== 2) throw new Error(`invalid rune ID: ${t}`);
        const [n, i] = r;
        if (!/^\d+$/.test(n) || !/^\d+$/.test(i)) throw new Error(`invalid rune ID: ${t}`);
        return new Wh((0, Qs.u128)(BigInt(n)), (0, Qs.u128)(BigInt(i)));
    }
}
YN = Cd.ProtoruneRuneId = Wh;
var Ud = {};
Object.defineProperty(Ud, "__esModule", {
    value: !0
});
Ud.Etching = void 0;
const bI = wi, gh = Qn;
class vae {
    constructor(t, r, n, i, o, s, a){
        this.divisibility = t, this.rune = r, this.spacers = n, this.terms = o, this.premine = s, this.turbo = a, this.symbol = i.andThen((u)=>{
            const f = u.codePointAt(0);
            return f !== void 0 ? (0, bI.Some)(String.fromCodePoint(f)) : bI.None;
        });
    }
    get supply() {
        const t = this.premine.unwrapOr((0, gh.u128)(0)), r = this.terms.andThen((i)=>i.cap).unwrapOr((0, gh.u128)(0)), n = this.terms.andThen((i)=>i.amount).unwrapOr((0, gh.u128)(0));
        return gh.u128.checkedMultiply(r, n).andThen((i)=>gh.u128.checkedAdd(t, i));
    }
}
Ud.Etching = vae;
var Ff = {};
Object.defineProperty(Ff, "__esModule", {
    value: !0
});
Ff.Tag = void 0;
const ey = wi, yl = Qn;
var bm;
(function(e) {
    e[e.BODY = 0] = "BODY", e[e.FLAGS = 2] = "FLAGS", e[e.RUNE = 4] = "RUNE", e[e.PREMINE = 6] = "PREMINE", e[e.CAP = 8] = "CAP", e[e.AMOUNT = 10] = "AMOUNT", e[e.HEIGHT_START = 12] = "HEIGHT_START", e[e.HEIGHT_END = 14] = "HEIGHT_END", e[e.OFFSET_START = 16] = "OFFSET_START", e[e.OFFSET_END = 18] = "OFFSET_END", e[e.MINT = 20] = "MINT", e[e.POINTER = 22] = "POINTER", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.DIVISIBILITY = 1] = "DIVISIBILITY", e[e.SPACERS = 3] = "SPACERS", e[e.SYMBOL = 5] = "SYMBOL", e[e.NOP = 127] = "NOP";
})(bm || (Ff.Tag = bm = {}));
(function(e) {
    function t(i, o, s, a) {
        const u = o.get((0, yl.u128)(i));
        if (u === void 0) return ey.None;
        const f = [];
        for (const l of [
            ...Array(s).keys()
        ]){
            if (u[l] === void 0) return ey.None;
            f[l] = u[l];
        }
        const c = a(f);
        return c.isNone() ? ey.None : (u.splice(0, s), u.length === 0 && o.delete((0, yl.u128)(i)), (0, ey.Some)(c.unwrap()));
    }
    e.take = t;
    function r(i, o) {
        return We.concat(o.map((s)=>[
                yl.u128.encodeVarInt((0, yl.u128)(i)),
                yl.u128.encodeVarInt(s)
            ]).flat());
    }
    e.encode = r;
    function n(i, o) {
        return o.map((s)=>e.encode(i, [
                (0, yl.u128)(s)
            ])).unwrapOr(We.alloc(0));
    }
    e.encodeOptionInt = n;
})(bm || (Ff.Tag = bm = {}));
var $d = {};
Object.defineProperty($d, "__esModule", {
    value: !0
});
$d.Tag = void 0;
const ml = Qn, ty = wi;
var wm;
(function(e) {
    e[e.BODY = 0] = "BODY", e[e.PROTOCOL = 16383] = "PROTOCOL", e[e.MESSAGE = 81] = "MESSAGE", e[e.BURN = 83] = "BURN", e[e.SPLIT = 85] = "SPLIT", e[e.POINTER = 91] = "POINTER", e[e.REFUND = 93] = "REFUND", e[e.FROM = 95] = "FROM", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.NOP = 127] = "NOP";
})(wm || ($d.Tag = wm = {}));
(function(e) {
    function t(i, o, s, a) {
        const u = o.get((0, ml.u128)(i));
        if (u === void 0) return ty.None;
        const f = [];
        for (const l of [
            ...Array(s).keys()
        ]){
            if (u[l] === void 0) return ty.None;
            f[l] = u[l];
        }
        const c = a(f);
        return c.isNone() ? ty.None : (u.splice(0, s), u.length === 0 && o.delete((0, ml.u128)(i)), (0, ty.Some)(c.unwrap()));
    }
    e.take = t;
    function r(i, o) {
        return We.concat(o.map((s)=>[
                ml.u128.encodeVarInt((0, ml.u128)(i)),
                ml.u128.encodeVarInt(s)
            ]).flat());
    }
    e.encode = r;
    function n(i, o) {
        return o.map((s)=>e.encode(i, [
                (0, ml.u128)(s)
            ])).unwrapOr(We.alloc(0));
    }
    e.encodeOptionInt = n;
})(wm || ($d.Tag = wm = {}));
var Ld = {};
Object.defineProperty(Ld, "__esModule", {
    value: !0
});
Ld.Flag = void 0;
const F_ = Qn;
var vm;
(function(e) {
    e[e.ETCHING = 0] = "ETCHING", e[e.TERMS = 1] = "TERMS", e[e.TURBO = 2] = "TURBO", e[e.CENOTAPH = 127] = "CENOTAPH";
})(vm || (Ld.Flag = vm = {}));
(function(e) {
    function t(i) {
        return (0, F_.u128)(1n << BigInt(i));
    }
    e.mask = t;
    function r(i, o) {
        const s = e.mask(o), a = (i & s) !== 0n;
        return {
            set: a,
            flags: a ? (0, F_.u128)(i - s) : i
        };
    }
    e.take = r;
    function n(i, o) {
        return (0, F_.u128)(i | e.mask(o));
    }
    e.set = n;
})(vm || (Ld.Flag = vm = {}));
var Dd = {}, Fd = {}, zf = {};
Object.defineProperty(zf, "__esModule", {
    value: !0
});
zf.Network = void 0;
const ry = hn;
var _m;
(function(e) {
    e[e.MAINNET = 0] = "MAINNET", e[e.SIGNET = 1] = "SIGNET", e[e.TESTNET = 2] = "TESTNET", e[e.REGTEST = 3] = "REGTEST";
})(_m || (zf.Network = _m = {}));
(function(e) {
    function t(r) {
        switch(r){
            case e.MAINNET:
                return ry.SUBSIDY_HALVING_INTERVAL * 4;
            case e.REGTEST:
                return ry.SUBSIDY_HALVING_INTERVAL * 0;
            case e.SIGNET:
                return ry.SUBSIDY_HALVING_INTERVAL * 0;
            case e.TESTNET:
                return ry.SUBSIDY_HALVING_INTERVAL * 12;
        }
    }
    e.getFirstRuneHeight = t;
})(_m || (zf.Network = _m = {}));
Object.defineProperty(Fd, "__esModule", {
    value: !0
});
Fd.Rune = void 0;
const _ae = zf, ny = hn, Ht = Qn;
class ks {
    constructor(t){
        this.value = t;
    }
    static getMinimumAtHeight(t, r) {
        let n = Ht.u128.saturatingAdd(r, (0, Ht.u128)(1));
        const i = (0, Ht.u128)(ny.SUBSIDY_HALVING_INTERVAL / 12);
        let o = (0, Ht.u128)(_ae.Network.getFirstRuneHeight(t)), s = Ht.u128.saturatingAdd(o, (0, Ht.u128)(ny.SUBSIDY_HALVING_INTERVAL));
        if (n < o) return new ks(ks.STEPS[12]);
        if (n >= s) return new ks((0, Ht.u128)(0));
        let a = Ht.u128.saturatingSub(n, o), u = Ht.u128.saturatingSub((0, Ht.u128)(12n), (0, Ht.u128)(a / i)), f = Number(u & (0, Ht.u128)(Ht.u32.MAX)), c = ks.STEPS[f], l = ks.STEPS[f - 1], p = (0, Ht.u128)(a % i);
        return new ks((0, Ht.u128)(c - (c - l) * p / i));
    }
    get reserved() {
        return this.value >= ny.RESERVED;
    }
    get commitment() {
        const t = We.alloc(16);
        t.writeBigUInt64LE(0xffffffffffffffffn & this.value, 0), t.writeBigUInt64LE(this.value >> 64n, 8);
        let r = t.length;
        for(; r > 0 && t.at(r - 1) === 0;)r--;
        return t.subarray(0, r);
    }
    static getReserved(t, r) {
        return new ks(Ht.u128.checkedAdd(ny.RESERVED, (0, Ht.u128)(t << 32n | r)).unwrap());
    }
    toString() {
        let t = this.value;
        if (t === Ht.u128.MAX) return "BCGDENLQRQWDSLRUGSNLBTMFIJAV";
        t = (0, Ht.u128)(t + 1n);
        let r = "";
        for(; t > 0;)r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Number((t - 1n) % 26n)] + r, t = (0, Ht.u128)((t - 1n) / 26n);
        return r;
    }
    static fromString(t) {
        let r = (0, Ht.u128)(0);
        for (const n of [
            ...Array(t.length).keys()
        ]){
            const i = t[n];
            if (n > 0 && (r = (0, Ht.u128)(r + 1n)), r = Ht.u128.checkedMultiply(r, (0, Ht.u128)(26)).unwrap(), "A" <= i && i <= "Z") r = Ht.u128.checkedAdd(r, (0, Ht.u128)(i.charCodeAt(0) - 65)).unwrap();
            else throw new Error(`invalid character in rune name: ${i}`);
        }
        return new ks(r);
    }
}
Fd.Rune = ks;
ks.STEPS = [
    (0, Ht.u128)(0n),
    (0, Ht.u128)(26n),
    (0, Ht.u128)(702n),
    (0, Ht.u128)(18278n),
    (0, Ht.u128)(475254n),
    (0, Ht.u128)(12356630n),
    (0, Ht.u128)(321272406n),
    (0, Ht.u128)(8353082582n),
    (0, Ht.u128)(217180147158n),
    (0, Ht.u128)(5646683826134n),
    (0, Ht.u128)(146813779479510n),
    (0, Ht.u128)(3817158266467286n),
    (0, Ht.u128)(99246114928149462n),
    (0, Ht.u128)(2580398988131886038n),
    (0, Ht.u128)(67090373691429037014n),
    (0, Ht.u128)(1744349715977154962390n),
    (0, Ht.u128)(45353092615406029022166n),
    (0, Ht.u128)(1179180408000556754576342n),
    (0, Ht.u128)(30658690608014475618984918n),
    (0, Ht.u128)(797125955808376366093607894n),
    (0, Ht.u128)(20725274851017785518433805270n),
    (0, Ht.u128)(538857146126462423479278937046n),
    (0, Ht.u128)(14010285799288023010461252363222n),
    (0, Ht.u128)(364267430781488598271992561443798n),
    (0, Ht.u128)(9470953200318703555071806597538774n),
    (0, Ht.u128)(246244783208286292431866971536008150n),
    (0, Ht.u128)(6402364363415443603228541259936211926n),
    (0, Ht.u128)(166461473448801533683942072758341510102n)
];
Object.defineProperty(Dd, "__esModule", {
    value: !0
});
Dd.SpacedRune = void 0;
const Eae = Fd;
class mS {
    constructor(t, r){
        this.rune = t, this.spacers = r;
    }
    static fromString(t) {
        let r = "", n = 0;
        for (const i of t)if ("A" <= i && i <= "Z") r += i;
        else if (i === "." || i === "•") {
            if (r.length === 0) throw new Error("leading spacer");
            const o = 1 << r.length - 1;
            if (n & o) throw new Error("double spacer");
            n |= o;
        } else throw new Error("invalid character");
        if (n >= 1 << r.length - 1) throw new Error("trailing spacer");
        return new mS(Eae.Rune.fromString(r), n);
    }
    toString() {
        const t = this.rune.toString();
        let r = 0, n = "";
        for (const i of t)n += i, r < t.length - 1 && this.spacers & 1 << r && (n += "•"), r++;
        return n;
    }
}
Dd.SpacedRune = mS;
Object.defineProperty(uo, "__esModule", {
    value: !0
});
uo.RunestoneProtostoneUpgrade = uo.MAX_U128_BYTES_COMPAT_W_RUNES = uo.MAX_LEB128_BYTES_IN_U128 = uo.MAX_SPACERS = void 0;
uo.isValidPayload = kae;
uo.encodeOptionInt = To;
uo.encodeRunestoneProtostone = Bae;
const Ll = hn, lx = Cd, xae = Ud, Ti = Ff, Sae = $d, fn = Qn, Fr = wi, bl = Ld, Aae = uc, Tae = Dd, z_ = Jr;
uo.MAX_SPACERS = 134217727;
function kae(e) {
    return We.isBuffer(e);
}
function To(e, t, r) {
    r.isSome() && (e.push(t), e.push(r.unwrap()));
}
uo.MAX_LEB128_BYTES_IN_U128 = 18;
uo.MAX_U128_BYTES_COMPAT_W_RUNES = 15;
class XN {
    constructor(t, r, n, i, o){
        this.mint = t, this.pointer = r, this.edicts = n, this.etching = i, this.protostones = o;
    }
    // removed decipher function -- can add it back if needed
    encipher() {
        const t = [];
        if (this.etching.isSome()) {
            const i = this.etching.unwrap();
            let o = (0, fn.u128)(0);
            if (o = bl.Flag.set(o, bl.Flag.ETCHING), i.terms.isSome() && (o = bl.Flag.set(o, bl.Flag.TERMS)), i.turbo && (o = bl.Flag.set(o, bl.Flag.TURBO)), t.push(Ti.Tag.FLAGS), t.push(o), To(t, Ti.Tag.RUNE, i.rune.map((s)=>s.value)), To(t, Ti.Tag.DIVISIBILITY, i.divisibility.map(fn.u128)), To(t, Ti.Tag.SYMBOL, i.spacers.map(fn.u128)), To(t, Ti.Tag.SYMBOL, i.symbol.map((s)=>(0, fn.u128)(s.codePointAt(0)))), To(t, Ti.Tag.PREMINE, i.premine), i.terms.isSome()) {
                const s = i.terms.unwrap();
                To(t, Ti.Tag.AMOUNT, s.amount), To(t, Ti.Tag.CAP, s.cap), To(t, Ti.Tag.HEIGHT_START, s.height[0]), To(t, Ti.Tag.HEIGHT_END, s.height[1]), To(t, Ti.Tag.OFFSET_START, s.offset[0]), To(t, Ti.Tag.OFFSET_END, s.offset[1]);
            }
        }
        if (this.mint.isSome()) {
            const i = this.mint.unwrap();
            t.push(Ti.Tag.MINT), t.push((0, fn.u128)(i.block)), t.push(Ti.Tag.MINT), t.push((0, fn.u128)(i.tx));
        }
        if (To(t, Ti.Tag.POINTER, this.pointer.map(fn.u128)), this.protostones.length) {
            let i = [];
            this.protostones.forEach((o)=>{
                o.encipher_payloads().forEach((s)=>i.push(s));
            }), (0, z_.unpack)((0, z_.encipher)(i)).forEach((o)=>{
                t.push((0, fn.u128)(Sae.Tag.PROTOCOL)), t.push((0, fn.u128)(o));
            });
        }
        if (this.edicts.length) {
            t.push((0, fn.u128)(Ti.Tag.BODY));
            const i = [
                ...this.edicts
            ].sort((s, a)=>Number(s.id.block - a.id.block || s.id.tx - a.id.tx));
            let o = new lx.ProtoruneRuneId((0, fn.u128)(0), (0, fn.u128)(0));
            for (const s of i){
                const [a, u] = o.delta(s.id).unwrap();
                t.push(a), t.push(u), t.push(s.amount), t.push((0, fn.u128)(s.output)), o = s.id;
            }
        }
        const r = [];
        r.push(Ll.OP_RETURN), r.push(Ll.MAGIC_NUMBER);
        const n = (0, z_.encipher)(t);
        for(let i = 0; i < n.length; i += Ll.MAX_SCRIPT_ELEMENT_SIZE)r.push(n.subarray(i, i + Ll.MAX_SCRIPT_ELEMENT_SIZE));
        return Aae.script.compile(r);
    }
}
uo.RunestoneProtostoneUpgrade = XN;
const Iae = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u8.MAX) throw Error("u8 overflow");
    return (0, fn.u8)(t);
}, wI = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u32.MAX) throw Error("u32 overflow");
    return (0, fn.u32)(t);
}, iy = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u64.MAX) throw Error("u64 overflow");
    return (0, fn.u64)(t);
}, oy = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u128.MAX) throw Error("u128 overflow");
    return (0, fn.u128)(t);
};
function Bae(e) {
    const t = e.mint ? (0, Fr.Some)(new lx.ProtoruneRuneId((0, fn.u128)(e.mint.block), (0, fn.u128)(e.mint.tx))) : Fr.None, r = e.pointer !== void 0 ? (0, Fr.Some)(e.pointer).map(wI) : Fr.None, n = (e.edicts ?? []).map((a)=>({
            id: new lx.ProtoruneRuneId((0, fn.u128)(a.id.block), (0, fn.u128)(a.id.tx)),
            amount: oy(a.amount),
            output: a.output
        })), i = e.protostones ?? [];
    let o = Fr.None, s;
    if (e.etching) {
        const a = e.etching, u = a.runeName ? Tae.SpacedRune.fromString(a.runeName) : void 0, f = (u == null ? void 0 : u.rune) !== void 0 ? (0, Fr.Some)(u.rune) : Fr.None;
        if (a.symbol && !(a.symbol.length === 1 || a.symbol.length === 2 && a.symbol.codePointAt(0) >= 65536)) throw Error("Symbol must be one code point");
        const c = a.divisibility !== void 0 ? (0, Fr.Some)(a.divisibility).map(Iae) : Fr.None, l = a.premine !== void 0 ? (0, Fr.Some)(a.premine).map(oy) : Fr.None, p = (u == null ? void 0 : u.spacers) !== void 0 && u.spacers !== 0 ? (0, Fr.Some)(wI(u.spacers)) : Fr.None, y = a.symbol ? (0, Fr.Some)(a.symbol) : Fr.None;
        if (c.isSome() && c.unwrap() > Ll.MAX_DIVISIBILITY) throw Error(`Divisibility is greater than protocol max ${Ll.MAX_DIVISIBILITY}`);
        let _ = Fr.None;
        if (a.terms) {
            const O = a.terms, N = O.amount !== void 0 ? (0, Fr.Some)(O.amount).map(oy) : Fr.None, U = O.cap !== void 0 ? (0, Fr.Some)(O.cap).map(oy) : Fr.None, D = O.height ? [
                O.height.start !== void 0 ? (0, Fr.Some)(O.height.start).map(iy) : Fr.None,
                O.height.end !== void 0 ? (0, Fr.Some)(O.height.end).map(iy) : Fr.None
            ] : [
                Fr.None,
                Fr.None
            ], H = O.offset ? [
                O.offset.start !== void 0 ? (0, Fr.Some)(O.offset.start).map(iy) : Fr.None,
                O.offset.end !== void 0 ? (0, Fr.Some)(O.offset.end).map(iy) : Fr.None
            ] : [
                Fr.None,
                Fr.None
            ];
            if (N.isSome() && U.isSome() && N.unwrap() * U.unwrap() > fn.u128.MAX) throw Error("Terms overflow with amount times cap");
            _ = (0, Fr.Some)({
                amount: N,
                cap: U,
                height: D,
                offset: H
            });
        }
        const A = a.turbo ?? !1;
        o = (0, Fr.Some)(new xae.Etching(c, f, p, y, _, l, A)), s = f.isSome() ? f.unwrap().commitment : void 0;
    }
    return {
        encodedRunestone: new XN(t, r, n, o, i).encipher(),
        etchingCommitment: s
    };
}
var w0 = {};
Object.defineProperty(w0, "__esModule", {
    value: !0
});
w0.ProtoStone = void 0;
const Pn = Qn, wl = $d, j_ = wi, Oae = Cd, Pae = Jr;
class Vh {
    constructor({ burn: t, message: r, protocolTag: n, edicts: i }){
        this.protocolTag = (0, Pn.u128)(n), this.edicts = i, t && (this.burn = {
            pointer: (0, j_.Some)((0, Pn.u32)(t.pointer)),
            from: t.from
        }), r && (this.message = {
            calldata: r.calldata,
            pointer: (0, j_.Some)((0, Pn.u32)(r.pointer)),
            refundPointer: (0, j_.Some)((0, Pn.u32)(r.refundPointer))
        });
    }
    // Enciphering a protostone doesn't make sense, removed this functionality
    // encipher() {
    //   const stack: (Buffer | number)[] = [];
    //   let payloads: Buffer[] = [];
    //   stack.push(OP_RETURN);
    //   if (this.burn) {
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.POINTER, this.burn.pointer.map(u128)),
    //     );
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.BURN, Some<u128>(this.protocolTag)),
    //     );
    //     stack.push(opcodes.OP_14);
    //   } else if (this.message) {
    //     payloads.push(u128.encodeVarInt(this.protocolTag));
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.POINTER, this.message.pointer.map(u128)),
    //     );
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.REFUND, this.message.refundPointer.map(u128)),
    //     );
    //     payloads.push(Tag.encode(Tag.MESSAGE, this.message.calldata));
    //     stack.push(opcodes.OP_16);
    //   } else if (this.split) {
    //     payloads.push(Tag.encode(Tag.SPLIT, this.split.order.map(u128)));
    //     stack.push(opcodes.OP_16);
    //   } else if (this.chunk) {
    //     payloads.push(this.chunk);
    //     stack.push(opcodes.OP_15);
    //   }
    //   const payload = Buffer.concat(payloads);
    //   for (let i = 0; i < payload.length; i += MAX_SCRIPT_ELEMENT_SIZE) {
    //     stack.push(payload.subarray(i, i + MAX_SCRIPT_ELEMENT_SIZE));
    //   }
    //   return script.compile(stack);
    // }
    encipher_payloads() {
        let t = [];
        if (this.burn ? (t.push((0, Pn.u128)(wl.Tag.POINTER)), t.push(this.burn.pointer.map(Pn.u128).unwrap()), this.burn.from && (t.push((0, Pn.u128)(wl.Tag.FROM)), t.push(this.burn.from.map(Pn.u128)[0]))) : this.message && (this.message.pointer.isSome() && (t.push((0, Pn.u128)(wl.Tag.POINTER)), t.push((0, Pn.u128)(this.message.pointer.map(Pn.u128).unwrap()))), this.message.refundPointer.isSome() && (t.push((0, Pn.u128)(wl.Tag.REFUND)), t.push((0, Pn.u128)(this.message.refundPointer.map(Pn.u128).unwrap()))), this.message.calldata.length && (0, Pae.unpack)(this.message.calldata).forEach((n)=>{
            t.push((0, Pn.u128)(wl.Tag.MESSAGE)), t.push((0, Pn.u128)(n));
        })), this.edicts && this.edicts.length) {
            t.push((0, Pn.u128)(wl.Tag.BODY));
            const n = [
                ...this.edicts
            ].sort((o, s)=>Number(o.id.block - s.id.block || o.id.tx - s.id.tx));
            let i = new Oae.ProtoruneRuneId((0, Pn.u128)(0), (0, Pn.u128)(0));
            for (const o of n){
                const [s, a] = i.delta(o.id).unwrap();
                t.push(s), t.push(a), t.push(o.amount), t.push((0, Pn.u128)(o.output)), i = o.id;
            }
        }
        const r = t.length;
        return t.unshift((0, Pn.u128)(r)), t.unshift((0, Pn.u128)(this.protocolTag)), t;
    }
    static burn({ protocolTag: t, edicts: r, ...n }) {
        return new Vh({
            burn: n,
            protocolTag: t,
            edicts: r
        });
    }
    static message({ protocolTag: t, edicts: r, ...n }) {
        return new Vh({
            message: n,
            protocolTag: t,
            edicts: r
        });
    }
    static edicts({ protocolTag: t, edicts: r }) {
        return new Vh({
            edicts: r,
            protocolTag: t
        });
    }
}
w0.ProtoStone = Vh;
var Nae = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), Mae = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), JN = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Nae(t, e, r);
    return Mae(t, e), t;
};
Object.defineProperty(tS, "__esModule", {
    value: !0
});
var QN = tS.AlkanesRpc = void 0;
const ea = JN(ka), Ao = JN(Bn), vl = mo, Rae = t1, vI = Lf, Cae = uo, sy = Qn, Uae = Cd, $ae = w0, Lae = Jr;
let Dae = class extends Rae.BaseRpc {
    async getbytecode({ block: t, tx: r }, n = "latest") {
        return await this._call({
            method: "getbytecode",
            input: Ao.encodeGetBytecodeRequest({
                block: t,
                tx: r
            })
        }, n);
    }
    async getblock(t, r = "latest") {
        return Ao.decodeBlockResponse(await this._call({
            method: "getblock",
            input: Ao.encodeBlockRequest({
                height: t
            })
        }, r));
    }
    async protorunesbyaddress({ address: t, protocolTag: r }, n = "latest") {
        const i = ea.encodeProtorunesWalletInput(t, r), o = await this._call({
            method: "protorunesbyaddress",
            input: i
        }, n);
        return console.log(o), ea.decodeWalletOutput(o);
    }
    async transactionbyid({ txid: t }, r = "latest") {
        const n = ea.encodeTransactionId(t), i = await this._call({
            method: "transactionbyid",
            input: n
        }, r);
        return ea.decodeTransactionResult(i);
    }
    async spendablesbyaddress({ address: t, protocolTag: r }, n = "latest") {
        const i = ea.encodeProtorunesWalletInput(t, r), o = await this._call({
            method: "spendablesbyaddress",
            input: i
        }, n);
        return ea.decodeWalletOutput(o);
    }
    async runesbyaddress({ address: t }, r = "latest") {
        const n = ea.encodeWalletInput(t), i = await this._call({
            method: "runesbyaddress",
            input: n
        }, r);
        return ea.decodeWalletOutput(i);
    }
    async runesbyheight({ height: t }, r = "latest") {
        const n = (0, vl.encodeBlockHeightInput)(t), i = await this._call({
            method: "runesbyheight",
            input: n
        }, r);
        return (0, vl.decodeRunesResponse)(i);
    }
    async protorunesbyheight({ height: t, protocolTag: r }, n = "latest") {
        const i = (0, vl.encodeProtorunesByHeightInput)(t, r), o = await this._call({
            method: "protorunesbyheight",
            input: i
        }, n);
        return (0, vl.decodeRunesResponse)(o);
    }
    async protorunesbyoutpoint({ txid: t, vout: r, protocolTag: n }, i = "latest") {
        const o = "0x" + We.from(new vI.protorune.OutpointWithProtocol({
            protocol: (0, Lae.toUint128)(n),
            txid: We.from(t, "hex"),
            vout: r
        }).serializeBinary()).toString("hex");
        return Ao.decodeOutpointResponse(await this._call({
            method: "protorunesbyoutpoint",
            input: o
        }, i));
    }
    async runesbyoutpoint({ txid: t, vout: r }, n = "latest") {
        const i = "0x" + We.from(new vI.protorune.Outpoint({
            txid: We.from(t, "hex"),
            vout: r
        }).serializeBinary()).toString("hex");
        return Ao.decodeOutpointResponse(await this._call({
            method: "protorunesbyoutpoint",
            input: i
        }, n));
    }
    async alkanesidtooutpoint({ block: t, tx: r }, n = "latest") {
        const i = (0, vl.encodeAlkanesIdToOutpointInput)(t, r), o = await this._call({
            method: "alkanes_id_to_outpoint",
            input: i
        }, n);
        return (0, vl.decodeAlkanesIdToOutpointResponse)(o);
    }
    async traceblock({ block: t }, r = "latest") {
        const n = Ao.encodeTraceBlockRequest({
            block: t
        }), i = await this._call({
            method: "traceblock",
            input: n
        }, r);
        return Ao.decodeTraceBlockResponse(i);
    }
    async trace({ txid: t, vout: r }, n = "latest") {
        const i = Ao.encodeTraceRequest({
            txid: t,
            vout: r
        }), o = await this._call({
            method: "trace",
            input: i
        }, n);
        return Ao.decodeTraceResponse(o);
    }
    async simulate({ alkanes: t, transaction: r, height: n, block: i, txindex: o, target: s, inputs: a, vout: u, pointer: f, refundPointer: c }, l = "latest") {
        const p = Ao.encodeSimulateRequest({
            alkanes: t,
            transaction: r,
            height: n,
            txindex: o,
            target: s,
            block: i,
            inputs: a,
            vout: u,
            pointer: f,
            refundPointer: c
        }), y = await this._call({
            method: "simulate",
            input: p
        }, l);
        return Ao.decodeSimulateResponse(y);
    }
    async meta({ alkanes: t, transaction: r, height: n, block: i, txindex: o, target: s, inputs: a, vout: u, pointer: f, refundPointer: c }, l = "latest") {
        const p = Ao.encodeSimulateRequest({
            alkanes: t,
            transaction: r,
            height: n,
            txindex: o,
            target: s,
            block: i,
            inputs: a,
            vout: u,
            pointer: f,
            refundPointer: c
        }), y = await this._call({
            method: "meta",
            input: p
        }, l);
        return Ao.decodeMetaResponse(y);
    }
    async runtime({ protocolTag: t }, r = "latest") {
        const n = ea.encodeRuntimeInput(t), i = await this._call({
            method: "protorunesbyaddress",
            input: n
        }, r);
        return ea.decodeRuntimeOutput(i);
    }
    async pack({ runes: t, cellpack: r, pointer: n, refundPointer: i, edicts: o }) {
        const s = new $ae.ProtoStone({
            message: {
                calldata: r,
                pointer: n,
                refundPointer: i
            },
            protocolTag: BigInt(1),
            edicts: o
        });
        return (0, Cae.encodeRunestoneProtostone)({
            edicts: t.map((a)=>({
                    id: new Uae.ProtoruneRuneId((0, sy.u128)(a.id.block), (0, sy.u128)(a.id.tx)),
                    output: (0, sy.u32)(2),
                    amount: (0, sy.u128)(a.value)
                })),
            pointer: 3,
            protostones: [
                s
            ]
        }).encodedRunestone;
    }
};
QN = tS.AlkanesRpc = Dae;
class Fae {
    constructor(){
        pt(this, "override");
        this.override = null;
    }
    set(t) {
        this.override = t;
    }
    exists() {
        return this.override !== null;
    }
    get() {
        return this.override;
    }
}
const _I = new Fae(), zae = (e)=>e.substr(0, 2) === "0x" ? e.substr(2) : e;
let jae = 0;
function dx(e) {
    switch(typeof e){
        case "bigint":
            return "0x" + e.toString(16);
        case "object":
            return e === null ? null : We.isBuffer(e) ? "0x" + e.toString("hex") : Array.isArray(e) ? e.map((t)=>dx(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
                    t,
                    dx(r)
                ]));
        default:
            return e;
    }
}
function hx(e) {
    switch(typeof e){
        case "string":
            return e !== "0x" && !isNaN(e) ? BigInt(e) : e.substr(0, 2) === "0x" || /^[0-9a-f]+$/.test(e) ? We.from(zae(e), "hex") : e;
        case "object":
            return e === null ? null : Array.isArray(e) ? e.map((t)=>hx(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
                    t,
                    hx(r)
                ]));
        default:
            return e;
    }
}
const H_ = [
    "99",
    "100",
    "101",
    "102",
    "103",
    "104",
    "1000"
], _l = [
    "name",
    "symbol",
    "totalSupply",
    "cap",
    "minted",
    "mintAmount",
    "data"
];
class EI {
    constructor(t){
        pt(this, "alkanesUrl");
        this.alkanesUrl = t;
    }
    async _metashrewCall(t, r = []) {
        const n = new QN({
            baseUrl: _I.get()
        });
        return dx(await n[t.split("_")[1]](hx(r[0] || {})));
    }
    async _call(t, r = []) {
        if (_I.get() !== null && t.match("alkanes_")) return await this._metashrewCall(t, r);
        const n = {
            jsonrpc: "2.0",
            method: t,
            params: r,
            id: jae++
        }, i = {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(n),
            cache: "no-cache"
        };
        try {
            const s = await (await fetch(this.alkanesUrl, i)).json();
            if (s.error) throw new Error(s.error.message);
            return s.result;
        } catch (o) {
            throw o instanceof Error && o.name === "AbortError" ? (console.error("Request Timeout:", o), new Error("Request timed out")) : (console.error("Request Error:", o), o);
        }
    }
    async metashrewHeight() {
        return await this._call("metashrew_height", []);
    }
    async getAlkanesByHeight({ height: t, protocolTag: r = "1" }) {
        return await this._call("alkanes_protorunesbyheight", [
            {
                height: t,
                protocolTag: r
            }
        ]);
    }
    async getAlkanesByAddress({ address: t, protocolTag: r = "1" }) {
        try {
            return (await this._call("alkanes_protorunesbyaddress", [
                {
                    address: t,
                    protocolTag: r
                }
            ])).outpoints.filter((o)=>o.runes.length > 0).map((o)=>({
                    ...o,
                    outpoint: {
                        vout: o.outpoint.vout,
                        txid: We.from(o.outpoint.txid, "hex").reverse().toString("hex")
                    },
                    runes: o.runes.map((s)=>({
                            ...s,
                            balance: parseInt(s.balance, 16).toString(),
                            rune: {
                                ...s.rune,
                                id: {
                                    block: parseInt(s.rune.id.block, 16).toString(),
                                    tx: parseInt(s.rune.id.tx, 16).toString()
                                }
                            }
                        }))
                }));
        } catch (n) {
            throw console.error("Error in getAlkanesByAddress:", n), n;
        }
    }
    async trace(t) {
        return t.txid = We.from(t.txid, "hex").reverse().toString("hex"), await await this._call("alkanes_trace", [
            t
        ]);
    }
    parsePoolInfo(t) {
        function r(i) {
            if (i.startsWith("0x") && (i = i.slice(2)), i.length % 32 !== 0) throw new Error("Invalid hex length. Expected multiples of 128-bit (32 hex chars).");
            const o = (u)=>{
                var c, l;
                const f = (l = (c = u.match(/.{2}/g)) == null ? void 0 : c.reverse()) == null ? void 0 : l.join("");
                if (!f) throw new Error("Failed to process hex segment.");
                return BigInt("0x" + f);
            };
            return (i.match(/.{32}/g) || []).map(o).map((u)=>u.toString());
        }
        const n = r(t);
        return {
            tokenA: {
                block: n[0],
                tx: n[1]
            },
            tokenB: {
                block: n[2],
                tx: n[3]
            },
            reserveA: n[4],
            reserveB: n[5]
        };
    }
    async simulate(t, r) {
        var i;
        const n = await this._call("alkanes_simulate", [
            {
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "20000",
                txindex: 0,
                inputs: [],
                pointer: 0,
                refundPointer: 0,
                vout: 0,
                ...t
            }
        ]);
        if (r) {
            const o = Number((i = t.inputs) == null ? void 0 : i[0]);
            n.parsed = r(n, o);
        } else n.parsed = this.parseSimulateReturn(n.execution.data);
        return n;
    }
    async simulatePoolInfo(t) {
        const r = await this._call("alkanes_simulate", [
            t
        ]), n = this.parsePoolInfo(r.execution.data);
        return r.parsed = n, r;
    }
    async getAlkanesByOutpoint({ txid: t, vout: r, protocolTag: n = "1", height: i = "latest" }) {
        return (await this._call("alkanes_protorunesbyoutpoint", [
            {
                txid: We.from(t, "hex").reverse().toString("hex"),
                vout: r,
                protocolTag: n
            },
            i
        ])).map((s)=>({
                ...s,
                token: {
                    ...s.token,
                    id: {
                        block: parseInt(s.token.id.block, 16).toString(),
                        tx: parseInt(s.token.id.tx, 16).toString()
                    }
                },
                value: parseInt(s.value, 16).toString()
            }));
    }
    async getAlkaneById({ block: t, tx: r }) {
        var i, o;
        const n = {
            id: {
                block: t,
                tx: r
            },
            data: "",
            name: "",
            mintActive: !1,
            percentageMinted: 0,
            symbol: "",
            totalSupply: 0,
            cap: 0,
            minted: 0,
            mintAmount: 0
        };
        for(let s = 0; s < H_.length; s++)try {
            const a = await this.simulate({
                target: {
                    block: t,
                    tx: r
                },
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "20000",
                txindex: 0,
                inputs: [
                    H_[s]
                ],
                pointer: 0,
                refundPointer: 0,
                vout: 0
            });
            a.status === 0 && (n[_l[s]] = Number(((i = a.parsed) == null ? void 0 : i.le) || 0), (_l[s] === "name" || _l[s] === "symbol" || _l[s] === "data") && (n[_l[s]] = ((o = a.parsed) == null ? void 0 : o.string) || ""), n.mintActive = Number(n.minted) < Number(n.cap), n.percentageMinted = Math.floor(n.minted / n.cap * 100));
        } catch (a) {
            console.log(a);
        }
        return n;
    }
    async getAlkanes({ limit: t, offset: r = 0 }) {
        if (t > 1e3) throw new Error("Max limit reached. Request fewer than 1000 alkanes per call");
        const n = Array.from({
            length: t
        }, (s, a)=>a + r), i = async (s)=>{
            const a = {
                id: {
                    block: "2",
                    tx: s.toString()
                }
            };
            let u = !1;
            const f = H_.filter((c)=>c !== void 0);
            try {
                if ((await Promise.all(f.map(async (p, y)=>{
                    if (!p) return null;
                    try {
                        const _ = await this.simulate({
                            target: {
                                block: "2",
                                tx: s.toString()
                            },
                            alkanes: [],
                            transaction: "0x",
                            block: "0x",
                            height: "20000",
                            txindex: 0,
                            inputs: [
                                p
                            ],
                            pointer: 0,
                            refundPointer: 0,
                            vout: 0
                        });
                        if ((_ == null ? void 0 : _.status) === 0) return {
                            opcode: p,
                            result: _,
                            opcodeIndex: y,
                            opcodeHRV: _l[y]
                        };
                    } catch  {
                        return null;
                    }
                }))).filter((p)=>p != null && p.opcodeHRV !== void 0).forEach(({ result: p, opcodeHRV: y })=>{
                    var _, A;
                    y && ([
                        "name",
                        "symbol",
                        "data"
                    ].includes(y) ? a[y] = ((_ = p.parsed) == null ? void 0 : _.string) || "" : a[y] = Number(((A = p.parsed) == null ? void 0 : A.le) || 0), u = !0);
                }), u) return a.mintActive = Number(a.minted || 0) < Number(a.cap || 0), a.percentageMinted = Math.floor((a.minted || 0) / (a.cap || 1) * 100), a;
            } catch (c) {
                return console.log(`Error processing alkane at index ${s}:`, c), null;
            }
            return null;
        }, o = [];
        for await (const s of ene(10, n, i))s !== null && o.push(s);
        return o;
    }
    async meta(t) {
        return await this._call("alkanes_meta", [
            {
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "0x",
                txindex: 0,
                inputs: [],
                pointer: 0,
                refundPointer: 0,
                vout: 0,
                ...t
            }
        ]);
    }
    parseSimulateReturn(t) {
        if (t === "0x") return;
        const r = (o)=>o.startsWith("0x") ? o.slice(2) : o, n = (o)=>"0x" + r(o);
        let i;
        try {
            if (i = We.from(r(t), "hex").toString("utf8"), /[\uFFFD]/.test(i)) throw new Error("Invalid UTF-8 string");
        } catch  {
            i = n(t);
        }
        return {
            string: i,
            bytes: n(t),
            le: BigInt(n(We.from(Array.from(We.from(r(t), "hex")).reverse()).toString("hex"))).toString(),
            be: BigInt(n(t)).toString()
        };
    }
}
function Hae({ block: e, tx: t }) {
    return `${e}:${t}`;
}
class qae {
    constructor(t, r){
        pt(this, "apiUrl", "");
        pt(this, "apiKey", "");
        pt(this, "networks");
        pt(this, "alkanesRpc");
        pt(this, "network");
        this.networks = {
            mainnet: {
                apiUrl: $l("mainnet"),
                apiKey: (r == null ? void 0 : r.apiKey) || ql
            },
            signet: {
                apiUrl: $l("signet"),
                apiKey: (r == null ? void 0 : r.apiKey) || ql
            },
            oylnet: {
                apiUrl: $l("oylnet"),
                apiKey: (r == null ? void 0 : r.apiKey) || "regtest"
            },
            ...r == null ? void 0 : r.networks
        }, this.setNetwork(t), this.alkanesRpc = new EI(`${this.apiUrl}/${this.apiKey}`), this.network = t;
    }
    getName() {
        return _G;
    }
    setNetwork(t) {
        if (this.networks[t]) this.apiUrl = this.networks[t].apiUrl, this.apiKey = this.networks[t].apiKey;
        else {
            const n = t === dt.TESTNET || t === dt.TESTNET4 || t === dt.SIGNET || t === dt.FRACTAL_TESTNET ? dt.SIGNET : dt.MAINNET;
            this.networks[n] ? (this.apiUrl = this.networks[n].apiUrl, this.apiKey = this.networks[n].apiKey) : (this.apiUrl = $l(t), this.apiKey = ql);
        }
        this.alkanesRpc = new EI(`${this.apiUrl}/${this.apiKey}`), this.network = t;
    }
    async call(t, r) {
        console.log("SandshrewDataSource.call", t, r), console.log("SandshrewDataSource.apiUrl", this.apiUrl), console.log("SandshrewDataSource.apiKey", this.apiKey);
        try {
            const n = `${this.apiUrl}/${this.apiKey}`;
            return (await rn.post(n, {
                jsonrpc: "2.0",
                id: t,
                method: t,
                params: r
            }, {
                headers: {
                    "Content-Type": "application/json"
                }
            })).data;
        } catch (n) {
            throw console.error("SandshrewDataSource.callRPC error:", n), n;
        }
    }
    async multicall(t) {
        return (await this.call("sandshrew_multicall", t)).result;
    }
    async getAlkanesByAddress(t) {
        return await this.alkanesRpc.getAlkanesByAddress({
            address: t
        });
    }
    async getAddressBtcBalance(t) {
        const n = (await this.call("esplora_address", [
            t
        ])).result;
        return (BigInt(n.chain_stats.funded_txo_sum) - BigInt(n.chain_stats.spent_txo_sum)).toString();
    }
    async getAddressUtxos(t) {
        const r = await this.call("esplora_address::utxo", [
            t
        ]), n = hs(t, Dr(this.network));
        return r.result.map((o)=>({
                ...o,
                scriptPk: We.from(n).toString("hex")
            }));
    }
    async getOutputValueByVOutIndex(t, r) {
        var o;
        return ((o = (await this.call("esplora_tx", [
            t
        ])).result.vout[r]) == null ? void 0 : o.value) ?? null;
    }
    async getAddressAlkanesBalances(t) {
        const r = await this.getAlkanesByAddress(t), n = {};
        for (const i of r)for (const o of i.runes){
            const s = Hae(o.rune.id);
            n[s] ? n[s].balance += BigInt(o.balance) : n[s] = {
                id: s,
                balance: BigInt(o.balance),
                name: o.rune.name,
                symbol: o.rune.symbol
            };
        }
        return Object.values(n);
    }
    async getTransaction(t) {
        return (await this.call("esplora_tx", [
            t
        ])).result;
    }
    async getRuneById(t) {
        return (await this.call("ord_rune", [
            t
        ])).result;
    }
    async getRuneByName(t) {
        return (await this.call("ord_rune", [
            t
        ])).result;
    }
    async broadcastTransaction(t) {
        return await this.call("broadcast_tx", [
            t
        ]);
    }
    async getOrdAddress(t) {
        return (await this.call("ord_address", [
            t
        ])).result;
    }
    async getTxInfo(t) {
        return (await this.call("esplora_tx", [
            t
        ])).result;
    }
    async batchOrdOutput({ outpoints: t, rune_name: r }) {
        const i = [];
        for(let o = 0; o < t.length; o += 1e3){
            const s = t.slice(o, o + 1e3), a = s.map((c)=>[
                    "ord_output",
                    [
                        c
                    ]
                ]), { result: u } = await this.call("sandshrew_multicall", a);
            for(let c = 0; c < u.length; c++)u[c].result.output = s[c];
            const f = u.filter((c)=>Object.keys(c.result.runes).includes(r));
            i.push(...f);
        }
        return i;
    }
    async batchOrdInscriptionInfo(t) {
        const n = [];
        for(let i = 0; i < t.length; i += 1e3){
            const s = t.slice(i, i + 1e3).map((u)=>[
                    "ord_inscription",
                    [
                        u
                    ]
                ]), { result: a } = await this.call("sandshrew_multicall", s);
            for(let u = 0; u < a.length; u++)n.push(a[u].result);
        }
        return n;
    }
    async getAddressRunesBalances(t) {
        try {
            const n = (await this.getOrdAddress(t)).runes_balances;
            if (!n) throw new Error("No runes data found");
            return n.map((i)=>({
                    name: i[0],
                    balance: i[1],
                    symbol: i[2]
                }));
        } catch (r) {
            throw console.error("Error fetching ord address:", r), r;
        }
    }
    async getInscriptionInfo(t) {
        const n = (await this.call("ord_inscription", [
            t
        ])).result;
        return {
            data: {
                inscription_id: n.id || t,
                inscription_number: n.number || 0,
                created_at: n.timestamp || 0,
                content_type: n.effective_content_type || "",
                content_body_preview: "",
                content_length: n.content_length || 0,
                collection_symbol: null
            },
            last_updated: {
                block_hash: "",
                block_height: n.height || 0
            }
        };
    }
    async getRecommendedFees() {
        const r = (await this.call("esplora_fee-estimates", [])).result, n = r[1] || 0, i = Math.min(...Object.values(r));
        return {
            fastFee: Math.round(n),
            minFee: Math.round(i)
        };
    }
    async getBalances(t) {
        if (Array.isArray(t)) {
            const n = t.map((o)=>[
                    "sandshrew_balances",
                    [
                        {
                            address: o
                        }
                    ]
                ]);
            return (await this.multicall(n)).map((o)=>o.result);
        }
        return [
            (await this.call("sandshrew_balances", [
                {
                    address: t
                }
            ])).result
        ];
    }
    async getRuneOutpoints({ address: t, runeId: r }) {
        const n = await this.getOrdAddress(t), { entry: i } = await this.getRuneById(r), o = i.spaced_rune, s = await this.batchOrdOutput({
            outpoints: n.outputs,
            rune_name: o
        });
        return await this.mapRuneBalances({
            ordOutputs: s
        });
    }
    async mapRuneBalances({ ordOutputs: t }) {
        var n;
        const r = [];
        for(let i = 0; i < t.length; i++){
            const o = t[i], { result: s } = o;
            if (!((n = s.output) != null && n.split(":"))) throw new Error("No output found");
            const { output: a, address: u, runes: f } = s, c = {
                output: a,
                wallet_addr: u,
                script: "",
                balances: [],
                decimals: [],
                rune_ids: [],
                value: s.value
            };
            if (c.script = We.from(oN(u, ln)).toString("hex"), typeof f == "object" && !Array.isArray(f)) for(const l in f)c.balances.push(f[l].amount), c.decimals.push(f[l].divisibility), c.rune_ids.push((await this.getRuneByName(l)).id);
            r.push(c);
        }
        return r;
    }
}
const eo = "Method not available on any data source", su = class su {
    constructor(t){
        pt(this, "dataSources", /* @__PURE__ */ new Map());
        pt(this, "network");
        pt(this, "customNetworks", /* @__PURE__ */ new Map());
        var n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U, D, H;
        const r = (t == null ? void 0 : t.network) || dt.MAINNET;
        this.network = r, this.customNetworks = new Map(Object.entries((t == null ? void 0 : t.customNetworks) || {})), this.dataSources.set("mempool", new Xre(r, {
            networks: {
                mainnet: {
                    apiUrl: ((i = (n = t == null ? void 0 : t.dataSources) == null ? void 0 : n.mempool) == null ? void 0 : i.url) || Bi(dt.MAINNET)
                },
                testnet: {
                    apiUrl: Bi(dt.TESTNET)
                },
                testnet4: {
                    apiUrl: Bi(dt.TESTNET4)
                },
                signet: {
                    apiUrl: Bi(dt.SIGNET)
                },
                "fractal-mainnet": {
                    apiUrl: Bi(dt.FRACTAL_MAINNET)
                },
                "fractal-testnet": {
                    apiUrl: Bi(dt.FRACTAL_TESTNET)
                },
                ...(s = (o = t == null ? void 0 : t.dataSources) == null ? void 0 : o.mempool) == null ? void 0 : s.networks
            }
        })), this.dataSources.set("sandshrew", new qae(r, {
            apiKey: (u = (a = t == null ? void 0 : t.dataSources) == null ? void 0 : a.sandshrew) == null ? void 0 : u.apiKey,
            networks: {
                mainnet: {
                    apiKey: ((c = (f = t == null ? void 0 : t.dataSources) == null ? void 0 : f.sandshrew) == null ? void 0 : c.apiKey) || ql,
                    apiUrl: $l(dt.MAINNET)
                },
                testnet: {
                    apiKey: ((p = (l = t == null ? void 0 : t.dataSources) == null ? void 0 : l.sandshrew) == null ? void 0 : p.apiKey) || ql,
                    apiUrl: $l(dt.TESTNET)
                },
                ...(_ = (y = t == null ? void 0 : t.dataSources) == null ? void 0 : y.sandshrew) == null ? void 0 : _.networks
            }
        })), this.dataSources.set("maestro", new Yre(r, {
            networks: {
                mainnet: {
                    apiKey: ((O = (A = t == null ? void 0 : t.dataSources) == null ? void 0 : A.maestro) == null ? void 0 : O.apiKey) || Bte,
                    apiUrl: cm(dt.MAINNET)
                },
                testnet4: {
                    apiKey: ((U = (N = t == null ? void 0 : t.dataSources) == null ? void 0 : N.maestro) == null ? void 0 : U.testnetApiKey) || $P,
                    apiUrl: cm(dt.TESTNET4)
                },
                ...(H = (D = t == null ? void 0 : t.dataSources) == null ? void 0 : D.maestro) == null ? void 0 : H.networks
            }
        }));
    }
    static init(t) {
        su.instance || (su.instance = new su(t));
    }
    static getInstance() {
        if (!su.instance) throw new Error("DataSourceManager has not been initialized");
        return su.instance;
    }
    updateNetwork(t) {
        var n, i;
        this.network = t;
        const r = (n = this.customNetworks.get(t)) == null ? void 0 : n.baseNetwork;
        for (const o of this.dataSources.values())(i = o.setNetwork) == null || i.call(o, t, r);
    }
    registerDataSource(t, r) {
        var n, i, o;
        this.dataSources.set(t, r), (o = (n = this.dataSources.get(t)) == null ? void 0 : n.setNetwork) == null || o.call(n, this.network, (i = this.customNetworks.get(this.network)) == null ? void 0 : i.baseNetwork);
    }
    getSource(t) {
        return this.dataSources.get(t);
    }
    async getAddressAlkanesBalances(t) {
        const r = this.findAvailableSource("getAddressAlkanesBalances");
        if (!r || !r.getAddressAlkanesBalances) throw new Error(eo);
        return await r.getAddressAlkanesBalances(t);
    }
    async getAlkanesByAddress(t) {
        const r = this.findAvailableSource("getAlkanesByAddress");
        if (!r || !r.getAlkanesByAddress) throw new Error(eo);
        return await r.getAlkanesByAddress(t);
    }
    async getAddressBtcBalance(t) {
        const r = this.findAvailableSource("getAddressBtcBalance");
        if (!r || !r.getAddressBtcBalance) throw new Error(eo);
        const n = await this.withFallback("sandshrew", async (i)=>{
            var o;
            return await ((o = i.getAddressBtcBalance) == null ? void 0 : o.call(i, t));
        });
        if (n === void 0) throw new Error("Unable to get balance from any data source");
        return n;
    }
    async getAddressBrc20Balances(t) {
        const r = this.findAvailableSource("getAddressBrc20Balances");
        if (!r || !r.getAddressBrc20Balances) throw new Error(eo);
        const n = await r.getAddressBrc20Balances(t);
        return Zre(n);
    }
    async getAddressInscriptions(t, r, n) {
        const i = this.findAvailableSource("getAddressInscriptions");
        if (!i || !i.getAddressInscriptions) throw new Error(eo);
        if (!i.getInscriptionInfo) throw new Error(eo);
        const o = dt.MAINNET, s = await i.getAddressInscriptions(t, r, n), a = i.getName();
        return a === t9 && s.data ? (await Promise.all(s.data.map(async (f)=>{
            try {
                if (!i.getInscriptionInfo) throw new Error(eo);
                const c = await i.getInscriptionInfo(f.inscription_id);
                return {
                    ...f,
                    ...c.data
                };
            } catch (c) {
                return console.error(`Failed to fetch details for inscription ${f.inscription_id}:`, c), f;
            }
        }))).map((f)=>Kl(f, a, o)) : s.inscriptions ? s.inscriptions.map((u)=>Kl(u, a, o)) : Array.isArray(s) ? s.map((u)=>Kl(u, a, o)) : (console.warn("Unable to normalize inscriptions from data source", a), []);
    }
    async getInscriptionInfo(t) {
        const r = this.findAvailableSource("getInscriptionInfo");
        if (!r || !r.getInscriptionInfo) throw new Error(eo);
        return await r.getInscriptionInfo(t);
    }
    async getRecommendedFees() {
        const t = this.findAvailableSource("getRecommendedFees");
        if (!t || !t.getRecommendedFees) throw new Error(eo);
        console.log("getting recommended fees");
        const r = await this.withFallback("sandshrew", async (n)=>{
            var i;
            return await ((i = n.getRecommendedFees) == null ? void 0 : i.call(n));
        });
        if (r === void 0) throw new Error("Unable to get recommended fees from any data source");
        return {
            fastFee: r.fastFee,
            minFee: r.minFee
        };
    }
    async getAddressUtxos(t) {
        const r = this.findAvailableSource("getAddressUtxos");
        if (!r || !r.getAddressUtxos) throw new Error(eo);
        const n = await this.withFallback("sandshrew", async (i)=>{
            var o;
            return await ((o = i.getAddressUtxos) == null ? void 0 : o.call(i, t));
        });
        if (n === void 0) throw new Error("Unable to get utxos from any data source");
        return n;
    }
    async getOutputValueByVOutIndex(t, r) {
        const n = this.findAvailableSource("getOutputValueByVOutIndex");
        if (!n || !n.getOutputValueByVOutIndex) throw new Error(eo);
        const i = await this.withFallback("sandshrew", async (o)=>{
            var s;
            return await ((s = o.getOutputValueByVOutIndex) == null ? void 0 : s.call(o, t, r));
        });
        if (i === void 0) throw new Error("Unable to get output value from any data source");
        return i;
    }
    async waitForTransaction(t) {
        const r = this.findAvailableSource("waitForTransaction");
        if (!r || !r.waitForTransaction) throw new Error(eo);
        return !!await r.waitForTransaction(t);
    }
    async getAddressRunesBalances(t) {
        const r = this.findAvailableSource("getAddressRunesBalances");
        if (!r || !r.getAddressRunesBalances) throw new Error(eo);
        return await r.getAddressRunesBalances(t);
    }
    async broadcastTransaction(t) {
        const r = this.findAvailableSource("broadcastTransaction");
        if (!r || !r.broadcastTransaction) throw new Error(eo);
        return await r.broadcastTransaction(t);
    }
    async withFallback(t, r) {
        const n = [
            t,
            ...Array.from(this.dataSources.keys()).filter((i)=>i !== t)
        ];
        for (const i of n)try {
            const o = this.getSource(i);
            if (!o) continue;
            return await r(o);
        } catch (o) {
            console.warn(`Fallback: ${i} failed`, o);
        }
        throw new Error("All data sources failed");
    }
    findAvailableSource(t) {
        const r = this.customNetworks.get(this.network);
        if (r) {
            const n = this.getSource(r.preferredDataSource);
            if (n && typeof n[t] == "function") return n;
        }
        for (const n of this.dataSources.values())if (typeof n[t] == "function") return n;
    }
    async getFormattedUTXOs(t) {
        const r = this.getSource("sandshrew");
        if (!r || !r.getBalances) throw new Error("Sandshrew data source with getBalances method is required");
        const n = await r.getBalances(t), i = [], o = Array.isArray(t) ? [
            ...new Set(t)
        ] : [
            t
        ];
        for(let s = 0; s < n.length; s++){
            const a = n[s], u = o[s], f = a.metashrewHeight, c = We.from(Gre(u, this.network)).toString("hex");
            for (const l of a.spendable){
                const [p, y] = l.outpoint.split(":");
                i.push({
                    txHash: p,
                    txOutputIndex: parseInt(y),
                    btcValue: l.value,
                    scriptPubKey: c,
                    address: u,
                    hasRunes: !1,
                    runes: [],
                    hasAlkanes: !1,
                    // No alkanes info in sandshrew_balances
                    alkanes: [],
                    hasInscriptions: !1,
                    inscriptions: [],
                    confirmations: l.height ? f - l.height : void 0
                });
            }
            for (const l of a.assets){
                const [p, y] = l.outpoint.split(":"), _ = (l.inscriptions || []).map((N)=>({
                        inscriptionId: N
                    })), A = [];
                if (l.ord_runes) for (const [N, U] of Object.entries(l.ord_runes))A.push({
                    runeId: N,
                    // Using name as ID
                    amount: U.amount
                });
                const O = [];
                if (l.runes) for (const N of l.runes)O.push({
                    id: parseInt(N.rune.id.block, 16) + ":" + parseInt(N.rune.id.tx, 16),
                    amount: parseInt(N.balance, 16),
                    // Convert hex to number
                    name: N.rune.name,
                    symbol: N.rune.symbol
                });
                i.push({
                    txHash: p,
                    txOutputIndex: parseInt(y),
                    btcValue: l.value,
                    scriptPubKey: c,
                    address: u,
                    hasRunes: A.length > 0,
                    runes: A,
                    hasAlkanes: O.length > 0,
                    alkanes: O,
                    hasInscriptions: _.length > 0,
                    inscriptions: _,
                    confirmations: l.height ? f - l.height : void 0
                });
            }
        }
        return i.sort((s, a)=>s.btcValue - a.btcValue), i;
    }
};
pt(su, "instance");
let nc = su;
const Kae = (e)=>/^(?:[A-Za-z0-9+/]{4})*?(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e), Wae = (e)=>/^[a-fA-F0-9]+$/.test(e), Vu = (e)=>{
    const t = [];
    let r = e;
    do {
        let n = r & BigInt(127);
        r >>= BigInt(7), r !== BigInt(0) && (n |= BigInt(128)), t.push(Number(n));
    }while (r !== BigInt(0))
    return {
        varint: We.from(t)
    };
};
function Sf(e) {
    return Object.fromEntries(Object.entries(e).filter(([t, r])=>r !== void 0));
}
const Vae = (e)=>{
    let t = 0n;
    const r = [];
    for (const n of e)n.inscriptions.length <= 0 && n.runes.length <= 0 && n.alkanes.length <= 0 && n.btcValue !== 546 && n.btcValue !== 330 && (r.push(n), t += BigInt(n.btcValue));
    return {
        utxos: r,
        totalAmount: t
    };
};
var ec = {}, eM = {}, bS = {};
(function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0, e.assertNumber = t;
    // @__NO_SIDE_EFFECTS__
    function t(S) {
        if (!Number.isSafeInteger(S)) throw new Error(`Wrong integer: ${S}`);
    }
    function r(S) {
        return S instanceof Uint8Array || S != null && typeof S == "object" && S.constructor.name === "Uint8Array";
    }
    // @__NO_SIDE_EFFECTS__
    function n(...S) {
        const w = (T)=>T, g = (T, I)=>(P)=>T(I(P)), m = S.map((T)=>T.encode).reduceRight(g, w), E = S.map((T)=>T.decode).reduce(g, w);
        return {
            encode: m,
            decode: E
        };
    }
    // @__NO_SIDE_EFFECTS__
    function i(S) {
        return {
            encode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
                return w.map((g)=>{
                    if (g < 0 || g >= S.length) throw new Error(`Digit index outside alphabet: ${g} (alphabet: ${S.length})`);
                    return S[g];
                });
            },
            decode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "string") throw new Error("alphabet.decode input should be array of strings");
                return w.map((g)=>{
                    if (typeof g != "string") throw new Error(`alphabet.decode: not string element=${g}`);
                    const m = S.indexOf(g);
                    if (m === -1) throw new Error(`Unknown letter: "${g}". Allowed: ${S}`);
                    return m;
                });
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function o(S = "") {
        if (typeof S != "string") throw new Error("join separator should be string");
        return {
            encode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "string") throw new Error("join.encode input should be array of strings");
                for (let g of w)if (typeof g != "string") throw new Error(`join.encode: non-string input=${g}`);
                return w.join(S);
            },
            decode: (w)=>{
                if (typeof w != "string") throw new Error("join.decode input should be string");
                return w.split(S);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function s(S, w = "=") {
        if (typeof w != "string") throw new Error("padding chr should be string");
        return {
            encode (g) {
                if (!Array.isArray(g) || g.length && typeof g[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let m of g)if (typeof m != "string") throw new Error(`padding.encode: non-string input=${m}`);
                for(; g.length * S % 8;)g.push(w);
                return g;
            },
            decode (g) {
                if (!Array.isArray(g) || g.length && typeof g[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let E of g)if (typeof E != "string") throw new Error(`padding.decode: non-string input=${E}`);
                let m = g.length;
                if (m * S % 8) throw new Error("Invalid padding: string should have whole number of bytes");
                for(; m > 0 && g[m - 1] === w; m--)if (!((m - 1) * S % 8)) throw new Error("Invalid padding: string has too much padding");
                return g.slice(0, m);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function a(S) {
        if (typeof S != "function") throw new Error("normalize fn should be function");
        return {
            encode: (w)=>w,
            decode: (w)=>S(w)
        };
    }
    // @__NO_SIDE_EFFECTS__
    function u(S, w, g) {
        if (w < 2) throw new Error(`convertRadix: wrong from=${w}, base cannot be less than 2`);
        if (g < 2) throw new Error(`convertRadix: wrong to=${g}, base cannot be less than 2`);
        if (!Array.isArray(S)) throw new Error("convertRadix: data should be array");
        if (!S.length) return [];
        let m = 0;
        const E = [], T = Array.from(S);
        for(T.forEach((I)=>{
            if (I < 0 || I >= w) throw new Error(`Wrong integer: ${I}`);
        });;){
            let I = 0, P = !0;
            for(let k = m; k < T.length; k++){
                const L = T[k], j = w * I + L;
                if (!Number.isSafeInteger(j) || w * I / w !== I || j - L !== w * I) throw new Error("convertRadix: carry overflow");
                I = j % g;
                const ie = Math.floor(j / g);
                if (T[k] = ie, !Number.isSafeInteger(ie) || ie * g + I !== j) throw new Error("convertRadix: carry overflow");
                if (P) ie ? P = !1 : m = k;
                else continue;
            }
            if (E.push(I), P) break;
        }
        for(let I = 0; I < S.length - 1 && S[I] === 0; I++)E.push(0);
        return E.reverse();
    }
    const f = /* @__NO_SIDE_EFFECTS__ */ (S, w)=>w ? /* @__PURE__ */ f(w, S % w) : S, c = /* @__NO_SIDE_EFFECTS__ */ (S, w)=>S + (w - /* @__PURE__ */ f(S, w));
    // @__NO_SIDE_EFFECTS__
    function l(S, w, g, m) {
        if (!Array.isArray(S)) throw new Error("convertRadix2: data should be array");
        if (w <= 0 || w > 32) throw new Error(`convertRadix2: wrong from=${w}`);
        if (g <= 0 || g > 32) throw new Error(`convertRadix2: wrong to=${g}`);
        if (/* @__PURE__ */ c(w, g) > 32) throw new Error(`convertRadix2: carry overflow from=${w} to=${g} carryBits=${/* @__PURE__ */ c(w, g)}`);
        let E = 0, T = 0;
        const I = 2 ** g - 1, P = [];
        for (const k of S){
            if (k >= 2 ** w) throw new Error(`convertRadix2: invalid data word=${k} from=${w}`);
            if (E = E << w | k, T + w > 32) throw new Error(`convertRadix2: carry overflow pos=${T} from=${w}`);
            for(T += w; T >= g; T -= g)P.push((E >> T - g & I) >>> 0);
            E &= 2 ** T - 1;
        }
        if (E = E << g - T & I, !m && T >= w) throw new Error("Excess padding");
        if (!m && E) throw new Error(`Non-zero padding: ${E}`);
        return m && T > 0 && P.push(E >>> 0), P;
    }
    // @__NO_SIDE_EFFECTS__
    function p(S) {
        return {
            encode: (w)=>{
                if (!r(w)) throw new Error("radix.encode input should be Uint8Array");
                return /* @__PURE__ */ u(Array.from(w), 2 ** 8, S);
            },
            decode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "number") throw new Error("radix.decode input should be array of numbers");
                return Uint8Array.from(/* @__PURE__ */ u(w, S, 2 ** 8));
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function y(S, w = !1) {
        if (S <= 0 || S > 32) throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ c(8, S) > 32 || /* @__PURE__ */ c(S, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (g)=>{
                if (!r(g)) throw new Error("radix2.encode input should be Uint8Array");
                return /* @__PURE__ */ l(Array.from(g), 8, S, !w);
            },
            decode: (g)=>{
                if (!Array.isArray(g) || g.length && typeof g[0] != "number") throw new Error("radix2.decode input should be array of numbers");
                return Uint8Array.from(/* @__PURE__ */ l(g, S, 8, w));
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function _(S) {
        if (typeof S != "function") throw new Error("unsafeWrapper fn should be function");
        return function(...w) {
            try {
                return S.apply(null, w);
            } catch  {}
        };
    }
    // @__NO_SIDE_EFFECTS__
    function A(S, w) {
        if (typeof w != "function") throw new Error("checksum fn should be function");
        return {
            encode (g) {
                if (!r(g)) throw new Error("checksum.encode: input should be Uint8Array");
                const m = w(g).slice(0, S), E = new Uint8Array(g.length + S);
                return E.set(g), E.set(m, g.length), E;
            },
            decode (g) {
                if (!r(g)) throw new Error("checksum.decode: input should be Uint8Array");
                const m = g.slice(0, -S), E = w(m).slice(0, S), T = g.slice(-S);
                for(let I = 0; I < S; I++)if (E[I] !== T[I]) throw new Error("Invalid checksum");
                return m;
            }
        };
    }
    e.utils = {
        alphabet: i,
        chain: n,
        checksum: A,
        convertRadix: u,
        convertRadix2: l,
        radix: p,
        radix2: y,
        join: o,
        padding: s
    }, e.base16 = /* @__PURE__ */ n(/* @__PURE__ */ y(4), /* @__PURE__ */ i("0123456789ABCDEF"), /* @__PURE__ */ o("")), e.base32 = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ s(5), /* @__PURE__ */ o("")), e.base32nopad = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ o("")), e.base32hex = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ s(5), /* @__PURE__ */ o("")), e.base32hexnopad = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ o("")), e.base32crockford = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ o(""), /* @__PURE__ */ a((S)=>S.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ s(6), /* @__PURE__ */ o("")), e.base64nopad = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ o("")), e.base64url = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ s(6), /* @__PURE__ */ o("")), e.base64urlnopad = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ o(""));
    const O = (S)=>/* @__PURE__ */ n(/* @__PURE__ */ p(58), /* @__PURE__ */ i(S), /* @__PURE__ */ o(""));
    e.base58 = O("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = O("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = O("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const N = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    e.base58xmr = {
        encode (S) {
            let w = "";
            for(let g = 0; g < S.length; g += 8){
                const m = S.subarray(g, g + 8);
                w += e.base58.encode(m).padStart(N[m.length], "1");
            }
            return w;
        },
        decode (S) {
            let w = [];
            for(let g = 0; g < S.length; g += 11){
                const m = S.slice(g, g + 11), E = N.indexOf(m.length), T = e.base58.decode(m);
                for(let I = 0; I < T.length - E; I++)if (T[I] !== 0) throw new Error("base58xmr: wrong padding");
                w = w.concat(Array.from(T.slice(T.length - E)));
            }
            return Uint8Array.from(w);
        }
    };
    const U = (S)=>/* @__PURE__ */ n(/* @__PURE__ */ A(4, (w)=>S(S(w))), e.base58);
    e.createBase58check = U, e.base58check = e.createBase58check;
    const D = /* @__PURE__ */ n(/* @__PURE__ */ i("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ o("")), H = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    // @__NO_SIDE_EFFECTS__
    function K(S) {
        const w = S >> 25;
        let g = (S & 33554431) << 5;
        for(let m = 0; m < H.length; m++)(w >> m & 1) === 1 && (g ^= H[m]);
        return g;
    }
    // @__NO_SIDE_EFFECTS__
    function re(S, w, g = 1) {
        const m = S.length;
        let E = 1;
        for(let T = 0; T < m; T++){
            const I = S.charCodeAt(T);
            if (I < 33 || I > 126) throw new Error(`Invalid prefix (${S})`);
            E = /* @__PURE__ */ K(E) ^ I >> 5;
        }
        E = /* @__PURE__ */ K(E);
        for(let T = 0; T < m; T++)E = /* @__PURE__ */ K(E) ^ S.charCodeAt(T) & 31;
        for (let T of w)E = /* @__PURE__ */ K(E) ^ T;
        for(let T = 0; T < 6; T++)E = /* @__PURE__ */ K(E);
        return E ^= g, D.encode(/* @__PURE__ */ l([
            E % 2 ** 30
        ], 30, 5, !1));
    }
    // @__NO_SIDE_EFFECTS__
    function Q(S) {
        const w = S === "bech32" ? 1 : 734539939, g = /* @__PURE__ */ y(5), m = g.decode, E = g.encode, T = /* @__PURE__ */ _(m);
        function I(ie, ue, ce = 90) {
            if (typeof ie != "string") throw new Error(`bech32.encode prefix should be string, not ${typeof ie}`);
            if (ue instanceof Uint8Array && (ue = Array.from(ue)), !Array.isArray(ue) || ue.length && typeof ue[0] != "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof ue}`);
            if (ie.length === 0) throw new TypeError(`Invalid prefix length ${ie.length}`);
            const he = ie.length + 7 + ue.length;
            if (ce !== !1 && he > ce) throw new TypeError(`Length ${he} exceeds limit ${ce}`);
            const ee = ie.toLowerCase(), ae = /* @__PURE__ */ re(ee, ue, w);
            return `${ee}1${D.encode(ue)}${ae}`;
        }
        function P(ie, ue = 90) {
            if (typeof ie != "string") throw new Error(`bech32.decode input should be string, not ${typeof ie}`);
            if (ie.length < 8 || ue !== !1 && ie.length > ue) throw new TypeError(`Wrong string length: ${ie.length} (${ie}). Expected (8..${ue})`);
            const ce = ie.toLowerCase();
            if (ie !== ce && ie !== ie.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const he = ce.lastIndexOf("1");
            if (he === 0 || he === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const ee = ce.slice(0, he), ae = ce.slice(he + 1);
            if (ae.length < 6) throw new Error("Data must be at least 6 characters long");
            const ye = D.decode(ae).slice(0, -6), Se = /* @__PURE__ */ re(ee, ye, w);
            if (!ae.endsWith(Se)) throw new Error(`Invalid checksum in ${ie}: expected "${Se}"`);
            return {
                prefix: ee,
                words: ye
            };
        }
        const k = /* @__PURE__ */ _(P);
        function L(ie) {
            const { prefix: ue, words: ce } = P(ie, !1);
            return {
                prefix: ue,
                words: ce,
                bytes: m(ce)
            };
        }
        function j(ie, ue) {
            return I(ie, E(ue));
        }
        return {
            encode: I,
            decode: P,
            encodeFromBytes: j,
            decodeToBytes: L,
            decodeUnsafe: k,
            fromWords: m,
            fromWordsUnsafe: T,
            toWords: E
        };
    }
    e.bech32 = /* @__PURE__ */ Q("bech32"), e.bech32m = /* @__PURE__ */ Q("bech32m"), e.utf8 = {
        encode: (S)=>new TextDecoder().decode(S),
        decode: (S)=>new TextEncoder().encode(S)
    }, e.hex = /* @__PURE__ */ n(/* @__PURE__ */ y(4), /* @__PURE__ */ i("0123456789abcdef"), /* @__PURE__ */ o(""), /* @__PURE__ */ a((S)=>{
        if (typeof S != "string" || S.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof S} with length ${S.length}`);
        return S.toLowerCase();
    }));
    const G = {
        utf8: e.utf8,
        hex: e.hex,
        base16: e.base16,
        base32: e.base32,
        base64: e.base64,
        base64url: e.base64url,
        base58: e.base58,
        base58xmr: e.base58xmr
    }, R = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", X = (S, w)=>{
        if (typeof S != "string" || !G.hasOwnProperty(S)) throw new TypeError(R);
        if (!r(w)) throw new TypeError("bytesToString() expects Uint8Array");
        return G[S].encode(w);
    };
    e.bytesToString = X, e.str = e.bytesToString;
    const $ = (S, w)=>{
        if (!G.hasOwnProperty(S)) throw new TypeError(R);
        if (typeof w != "string") throw new TypeError("stringToBytes() expects string");
        return G[S].decode(w);
    };
    e.stringToBytes = $, e.bytes = e.stringToBytes;
})(bS);
var wS = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.constant = e.magicBytes = e.magic = e.optional = e.flagged = e.flag = e.lazy = e.apply = e.hex = e.cstring = e.string = e.prefix = e.bytes = e.bool = e.F64LE = e.F64BE = e.F32LE = e.F32BE = e.I8 = e.U8 = e.I16BE = e.I16LE = e.U16BE = e.U16LE = e.I32BE = e.I32LE = e.U32BE = e.U32LE = e.int = e.I64BE = e.I64LE = e.U64BE = e.U64LE = e.I128BE = e.I128LE = e.U128BE = e.U128LE = e.I256BE = e.I256LE = e.U256BE = e.U256LE = e.bigint = e.bits = e.coders = e.isCoder = e.wrap = e.validate = e.utils = e.NULL = e.EMPTY = void 0, e._TEST = e.pointer = e.padRight = e.padLeft = e.ZeroPad = e.bitset = e.mappedTag = e.tag = e.map = e.array = e.tuple = e.struct = void 0;
    const t = bS;
    e.EMPTY = new Uint8Array(), e.NULL = new Uint8Array([
        0
    ]);
    function r(h, x) {
        if (h.length !== x.length) return !1;
        for(let q = 0; q < h.length; q++)if (h[q] !== x[q]) return !1;
        return !0;
    }
    function n(h) {
        return h instanceof Uint8Array || h != null && typeof h == "object" && h.constructor.name === "Uint8Array";
    }
    function i(...h) {
        let x = 0;
        for(let te = 0; te < h.length; te++){
            const fe = h[te];
            if (!n(fe)) throw new Error("Uint8Array expected");
            x += fe.length;
        }
        const q = new Uint8Array(x);
        for(let te = 0, fe = 0; te < h.length; te++){
            const ne = h[te];
            q.set(ne, fe), fe += ne.length;
        }
        return q;
    }
    const o = (h)=>new DataView(h.buffer, h.byteOffset, h.byteLength);
    function s(h) {
        return Object.prototype.toString.call(h) === "[object Object]";
    }
    function a(h) {
        return Number.isSafeInteger(h);
    }
    e.utils = {
        equalBytes: r,
        isBytes: n,
        isCoder: D,
        checkBounds: _,
        concatBytes: i,
        createView: o,
        isPlainObject: s
    };
    const u = (h)=>{
        if (h !== null && typeof h != "string" && !D(h) && !n(h) && !a(h)) throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${h} (${typeof h})`);
        return {
            encodeStream (x, q) {
                if (h === null) return;
                if (D(h)) return h.encodeStream(x, q);
                let te;
                if (typeof h == "number" ? te = h : typeof h == "string" && (te = c.resolve(x.stack, h)), typeof te == "bigint" && (te = Number(te)), te === void 0 || te !== q) throw x.err(`Wrong length: ${te} len=${h} exp=${q} (${typeof q})`);
            },
            decodeStream (x) {
                let q;
                if (D(h) ? q = Number(h.decodeStream(x)) : typeof h == "number" ? q = h : typeof h == "string" && (q = c.resolve(x.stack, h)), typeof q == "bigint" && (q = Number(q)), typeof q != "number") throw x.err(`Wrong length: ${q}`);
                return q;
            }
        };
    }, f = {
        BITS: 32,
        FULL_MASK: -1 >>> 0,
        // 1<<32 will overflow
        len: (h)=>Math.ceil(h / 32),
        create: (h)=>new Uint32Array(f.len(h)),
        clean: (h)=>h.fill(0),
        debug: (h)=>Array.from(h).map((x)=>(x >>> 0).toString(2).padStart(32, "0")),
        checkLen: (h, x)=>{
            if (f.len(x) !== h.length) throw new Error(`wrong length=${h.length}. Expected: ${f.len(x)}`);
        },
        chunkLen: (h, x, q)=>{
            if (x < 0) throw new Error(`wrong pos=${x}`);
            if (x + q > h) throw new Error(`wrong range=${x}/${q} of ${h}`);
        },
        set: (h, x, q, te = !0)=>!te && h[x] & q ? !1 : (h[x] |= q, !0),
        pos: (h, x)=>({
                chunk: Math.floor((h + x) / 32),
                mask: 1 << 32 - (h + x) % 32 - 1
            }),
        indices: (h, x, q = !1)=>{
            f.checkLen(h, x);
            const { FULL_MASK: te, BITS: fe } = f, ne = fe - x % fe, W = ne ? te >>> ne << ne : te, J = [];
            for(let V = 0; V < h.length; V++){
                let C = h[V];
                if (q && (C = ~C), V === h.length - 1 && (C &= W), C !== 0) for(let Z = 0; Z < fe; Z++){
                    const le = 1 << fe - Z - 1;
                    C & le && J.push(V * fe + Z);
                }
            }
            return J;
        },
        range: (h)=>{
            const x = [];
            let q;
            for (const te of h)q === void 0 || te !== q.pos + q.length ? x.push(q = {
                pos: te,
                length: 1
            }) : q.length += 1;
            return x;
        },
        rangeDebug: (h, x, q = !1)=>`[${f.range(f.indices(h, x, q)).map((te)=>`(${te.pos}/${te.length})`).join(", ")}]`,
        setRange: (h, x, q, te, fe = !0)=>{
            f.chunkLen(x, q, te);
            const { FULL_MASK: ne, BITS: W } = f, J = q % W ? Math.floor(q / W) : void 0, V = q + te, C = V % W ? Math.floor(V / W) : void 0;
            if (J !== void 0 && J === C) return f.set(h, J, ne >>> W - te << W - te - q, fe);
            if (J !== void 0 && !f.set(h, J, ne >>> q % W, fe)) return !1;
            const Z = J !== void 0 ? J + 1 : q / W, le = C !== void 0 ? C : V / W;
            for(let se = Z; se < le; se++)if (!f.set(h, se, ne, fe)) return !1;
            return !(C !== void 0 && J !== C && !f.set(h, C, ne << W - V % W, fe));
        }
    }, c = {
        /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */ pushObj: (h, x, q)=>{
            const te = {
                obj: x
            };
            h.push(te), q((fe, ne)=>{
                te.field = fe, ne(), te.field = void 0;
            }), h.pop();
        },
        path: (h)=>{
            const x = [];
            for (const q of h)q.field !== void 0 && x.push(q.field);
            return x.join("/");
        },
        err (h, x, q) {
            const te = new Error(`${h}(${c.path(x)}): ${typeof q == "string" ? q : q.message}`);
            return q instanceof Error && q.stack && (te.stack = q.stack), te;
        },
        resolve: (h, x)=>{
            const q = x.split("/"), te = h.map((W)=>W.obj);
            let fe = 0;
            for(; fe < q.length && q[fe] === ".."; fe++)te.pop();
            let ne = te.pop();
            for(; fe < q.length; fe++){
                if (!ne || ne[q[fe]] === void 0) return;
                ne = ne[q[fe]];
            }
            return ne;
        }
    };
    class l {
        constructor(x, q = {}, te = [], fe = void 0, ne = 0){
            this.data = x, this.opts = q, this.stack = te, this.parent = fe, this.parentOffset = ne, this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.view = o(x);
        }
        /**
     * Internal method for pointers.
     */ _enablePointers() {
            if (this.parent) return this.parent._enablePointers();
            this.bs || (this.bs = f.create(this.data.length), f.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
        }
        markBytesBS(x, q) {
            return this.parent ? this.parent.markBytesBS(this.parentOffset + x, q) : !q || !this.bs ? !0 : f.setRange(this.bs, this.data.length, x, q, !1);
        }
        markBytes(x) {
            const q = this.pos;
            this.pos += x;
            const te = this.markBytesBS(q, x);
            if (!this.opts.allowMultipleReads && !te) throw this.err(`multiple read pos=${this.pos} len=${x}`);
            return te;
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        readView(x, q) {
            if (!Number.isFinite(x)) throw this.err(`readView: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readView: Unexpected end of buffer");
            const te = q(this.view, this.pos);
            return this.markBytes(x), te;
        }
        // read bytes by absolute offset
        absBytes(x) {
            if (x > this.data.length) throw new Error("Unexpected end of buffer");
            return this.data.subarray(x);
        }
        finish() {
            if (!this.opts.allowUnreadBytes) {
                if (this.bitPos) throw this.err(`${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
                if (this.bs && !this.parent) {
                    const x = f.indices(this.bs, this.data.length, !0);
                    if (x.length) {
                        const q = f.range(x).map(({ pos: te, length: fe })=>`(${te}/${fe})[${t.hex.encode(this.data.subarray(te, te + fe))}]`).join(", ");
                        throw this.err(`unread byte ranges: ${q} (total=${this.data.length})`);
                    } else return;
                }
                if (!this.isEnd()) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
            }
        }
        // User methods
        err(x) {
            return c.err("Reader", this.stack, x);
        }
        offsetReader(x) {
            if (x > this.data.length) throw this.err("offsetReader: Unexpected end of buffer");
            return new l(this.absBytes(x), this.opts, this.stack, this, x);
        }
        bytes(x, q = !1) {
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(x)) throw this.err(`readBytes: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const te = this.data.subarray(this.pos, this.pos + x);
            return q || this.markBytes(x), te;
        }
        byte(x = !1) {
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            if (this.pos + 1 > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const q = this.data[this.pos];
            return x || this.markBytes(1), q;
        }
        get leftBytes() {
            return this.data.length - this.pos;
        }
        get totalBytes() {
            return this.data.length;
        }
        isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
        }
        // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
        bits(x) {
            if (x > 32) throw this.err("BitReader: cannot read more than 32 bits in single call");
            let q = 0;
            for(; x;){
                this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
                const te = Math.min(x, this.bitPos);
                this.bitPos -= te, q = q << te | this.bitBuf >> this.bitPos & 2 ** te - 1, this.bitBuf &= 2 ** this.bitPos - 1, x -= te;
            }
            return q >>> 0;
        }
        find(x, q = this.pos) {
            if (!n(x)) throw this.err(`find: needle is not bytes! ${x}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!x.length) throw this.err("find: needle is empty");
            for(let te = q; (te = this.data.indexOf(x[0], te)) !== -1; te++){
                if (te === -1 || this.data.length - te < x.length) return;
                if (r(x, this.data.subarray(te, te + x.length))) return te;
            }
        }
    }
    class p {
        constructor(x = []){
            this.stack = x, this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = !1, this.view = o(this.viewBuf);
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        writeView(x, q) {
            if (this.finished) throw this.err("buffer: finished");
            if (!a(x) || x > 8) throw new Error(`wrong writeView length=${x}`);
            q(this.view), this.bytes(this.viewBuf.slice(0, x)), this.viewBuf.fill(0);
        }
        // User methods
        err(x) {
            if (this.finished) throw this.err("buffer: finished");
            return c.err("Reader", this.stack, x);
        }
        bytes(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(x), this.pos += x.length;
        }
        byte(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([
                x
            ])), this.pos++;
        }
        finish(x = !0) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("buffer: ends with non-empty bit buffer");
            const q = this.buffers.concat(this.ptrs.map((ne)=>ne.buffer)), te = q.map((ne)=>ne.length).reduce((ne, W)=>ne + W, 0), fe = new Uint8Array(te);
            for(let ne = 0, W = 0; ne < q.length; ne++){
                const J = q[ne];
                fe.set(J, W), W += J.length;
            }
            for(let ne = this.pos, W = 0; W < this.ptrs.length; W++){
                const J = this.ptrs[W];
                fe.set(J.ptr.encode(ne), J.pos), ne += J.buffer.length;
            }
            if (x) {
                this.buffers = [];
                for (const ne of this.ptrs)ne.buffer.fill(0);
                this.ptrs = [], this.finished = !0, this.bitBuf = 0;
            }
            return fe;
        }
        bits(x, q) {
            if (q > 32) throw this.err("writeBits: cannot write more than 32 bits in single call");
            if (x >= 2 ** q) throw this.err(`writeBits: value (${x}) >= 2**bits (${q})`);
            for(; q;){
                const te = Math.min(q, 8 - this.bitPos);
                this.bitBuf = this.bitBuf << te | x >> q - te, this.bitPos += te, q -= te, x &= 2 ** q - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([
                    this.bitBuf
                ])), this.pos++);
            }
        }
    }
    const y = (h)=>Uint8Array.from(h).reverse();
    function _(h, x, q) {
        if (q) {
            const te = 2n ** (x - 1n);
            if (h < -te || h >= te) throw new Error(`value out of signed bounds. Expected ${-te} <= ${h} < ${te}`);
        } else if (0n > h || h >= 2n ** x) throw new Error(`value out of unsigned bounds. Expected 0 <= ${h} < ${2n ** x}`);
    }
    function A(h) {
        return {
            // NOTE: we cannot export validate here, since it is likely mistake.
            encodeStream: h.encodeStream,
            decodeStream: h.decodeStream,
            size: h.size,
            encode: (x)=>{
                const q = new p();
                return h.encodeStream(q, x), q.finish();
            },
            decode: (x, q = {})=>{
                const te = new l(x, q), fe = h.decodeStream(te);
                return te.finish(), fe;
            }
        };
    }
    function O(h, x) {
        if (!D(h)) throw new Error(`validate: invalid inner value ${h}`);
        if (typeof x != "function") throw new Error("validate: fn should be function");
        return A({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x(te);
                } catch (ne) {
                    throw q.err(ne);
                }
                h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x(te);
                } catch (fe) {
                    throw q.err(fe);
                }
            }
        });
    }
    e.validate = O;
    const N = (h)=>{
        const x = A(h);
        return h.validate ? O(x, h.validate) : x;
    };
    e.wrap = N;
    const U = (h)=>s(h) && typeof h.decode == "function" && typeof h.encode == "function";
    function D(h) {
        return s(h) && U(h) && typeof h.encodeStream == "function" && typeof h.decodeStream == "function" && (h.size === void 0 || a(h.size));
    }
    e.isCoder = D;
    function H() {
        return {
            encode: (h)=>{
                if (!Array.isArray(h)) throw new Error("array expected");
                const x = {};
                for (const q of h){
                    if (!Array.isArray(q) || q.length !== 2) throw new Error("array of two elements expected");
                    const te = q[0], fe = q[1];
                    if (x[te] !== void 0) throw new Error(`key(${te}) appears twice in struct`);
                    x[te] = fe;
                }
                return x;
            },
            decode: (h)=>{
                if (!s(h)) throw new Error(`expected plain object, got ${h}`);
                return Object.entries(h);
            }
        };
    }
    const K = {
        encode: (h)=>{
            if (typeof h != "bigint") throw new Error(`expected bigint, got ${typeof h}`);
            if (h > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`element bigger than MAX_SAFE_INTEGER=${h}`);
            return Number(h);
        },
        decode: (h)=>{
            if (!a(h)) throw new Error("element is not a safe integer");
            return BigInt(h);
        }
    };
    function re(h) {
        if (!s(h)) throw new Error("plain object expected");
        return {
            encode: (x)=>{
                if (!a(x) || !(x in h)) throw new Error(`wrong value ${x}`);
                return h[x];
            },
            decode: (x)=>{
                if (typeof x != "string") throw new Error(`wrong value ${typeof x}`);
                return h[x];
            }
        };
    }
    function Q(h, x = !1) {
        if (!a(h)) throw new Error(`decimal/precision: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`decimal/round: expected boolean, got ${typeof x}`);
        const q = 10n ** BigInt(h);
        return {
            encode: (te)=>{
                if (typeof te != "bigint") throw new Error(`expected bigint, got ${typeof te}`);
                let fe = (te < 0n ? -te : te).toString(10), ne = fe.length - h;
                ne < 0 && (fe = fe.padStart(fe.length - ne, "0"), ne = 0);
                let W = fe.length - 1;
                for(; W >= ne && fe[W] === "0"; W--);
                let J = fe.slice(0, ne), V = fe.slice(ne, W + 1);
                return J || (J = "0"), te < 0n && (J = "-" + J), V ? `${J}.${V}` : J;
            },
            decode: (te)=>{
                if (typeof te != "string") throw new Error(`expected string, got ${typeof te}`);
                if (te === "-0") throw new Error("negative zero is not allowed");
                let fe = !1;
                if (te.startsWith("-") && (fe = !0, te = te.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(te)) throw new Error(`wrong string value=${te}`);
                let ne = te.indexOf(".");
                ne = ne === -1 ? te.length : ne;
                const W = te.slice(0, ne), J = te.slice(ne + 1).replace(/0+$/, ""), V = BigInt(W) * q;
                if (!x && J.length > h) throw new Error(`fractional part cannot be represented with this precision (num=${te}, prec=${h})`);
                const C = Math.min(J.length, h), Z = BigInt(J.slice(0, C)) * 10n ** BigInt(h - C), le = V + Z;
                return fe ? -le : le;
            }
        };
    }
    function G(h) {
        if (!Array.isArray(h)) throw new Error(`expected array, got ${typeof h}`);
        for (const x of h)if (!U(x)) throw new Error(`wrong base coder ${x}`);
        return {
            encode: (x)=>{
                for (const q of h){
                    const te = q.encode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/encode: cannot find match in ${x}`);
            },
            decode: (x)=>{
                for (const q of h){
                    const te = q.decode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/decode: cannot find match in ${x}`);
            }
        };
    }
    const R = (h)=>{
        if (!U(h)) throw new Error("BaseCoder expected");
        return {
            encode: h.decode,
            decode: h.encode
        };
    };
    e.coders = {
        dict: H,
        numberBigint: K,
        tsEnum: re,
        decimal: Q,
        match: G,
        reverse: R
    };
    const X = (h)=>{
        if (!a(h)) throw new Error(`bits: wrong length ${h} (${typeof h})`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>x.bits(q, h),
            decodeStream: (x)=>x.bits(h),
            validate: (x)=>{
                if (!a(x)) throw new Error(`bits: wrong value ${x}`);
                return x;
            }
        });
    };
    e.bits = X;
    const $ = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`bigint/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`bigint/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`bigint/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`bigint/sized: expected boolean, got ${typeof te}`);
        const fe = BigInt(h), ne = 2n ** (8n * fe - 1n);
        return (0, e.wrap)({
            size: te ? h : void 0,
            encodeStream: (W, J)=>{
                q && J < 0 && (J = J | ne);
                const V = [];
                for(let Z = 0; Z < h; Z++)V.push(Number(J & 255n)), J >>= 8n;
                let C = new Uint8Array(V).reverse();
                if (!te) {
                    let Z = 0;
                    for(Z = 0; Z < C.length && C[Z] === 0; Z++);
                    C = C.subarray(Z);
                }
                W.bytes(x ? C.reverse() : C);
            },
            decodeStream: (W)=>{
                const J = W.bytes(te ? h : Math.min(h, W.leftBytes)), V = x ? J : y(J);
                let C = 0n;
                for(let Z = 0; Z < V.length; Z++)C |= BigInt(V[Z]) << 8n * BigInt(Z);
                return q && C & ne && (C = (C ^ ne) - ne), C;
            },
            validate: (W)=>{
                if (typeof W != "bigint") throw new Error(`bigint: invalid value: ${W}`);
                return _(W, 8n * fe, !!q), W;
            }
        });
    };
    e.bigint = $, e.U256LE = (0, e.bigint)(32, !0), e.U256BE = (0, e.bigint)(32, !1), e.I256LE = (0, e.bigint)(32, !0, !0), e.I256BE = (0, e.bigint)(32, !1, !0), e.U128LE = (0, e.bigint)(16, !0), e.U128BE = (0, e.bigint)(16, !1), e.I128LE = (0, e.bigint)(16, !0, !0), e.I128BE = (0, e.bigint)(16, !1, !0), e.U64LE = (0, e.bigint)(8, !0), e.U64BE = (0, e.bigint)(8, !1), e.I64LE = (0, e.bigint)(8, !0, !0), e.I64BE = (0, e.bigint)(8, !1, !0);
    const S = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`int/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`int/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`int/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`int/sized: expected boolean, got ${typeof te}`);
        if (h > 6) throw new Error("int supports size up to 6 bytes (48 bits): use bigints instead");
        return L((0, e.bigint)(h, x, q, te), e.coders.numberBigint);
    };
    e.int = S;
    const w = (h, x)=>(0, e.wrap)({
            size: h,
            encodeStream: (q, te)=>q.writeView(h, (fe)=>x.write(fe, te)),
            decodeStream: (q)=>q.readView(h, x.read),
            validate: (q)=>{
                if (typeof q != "number") throw new Error(`viewCoder: expected number, got ${typeof q}`);
                return x.validate && x.validate(q), q;
            }
        }), g = (h, x, q)=>{
        const te = h * 8, fe = 2 ** (te - 1), ne = (V)=>{
            if (!a(V)) throw new Error(`sintView: value is not safe integer: ${V}`);
            if (V < -fe || V >= fe) throw new Error(`sintView: value out of bounds. Expected ${-fe} <= ${V} < ${fe}`);
        }, W = 2 ** te, J = (V)=>{
            if (!a(V)) throw new Error(`uintView: value is not safe integer: ${V}`);
            if (0 > V || V >= W) throw new Error(`uintView: value out of bounds. Expected 0 <= ${V} < ${W}`);
        };
        return w(h, {
            write: q.write,
            read: q.read,
            validate: x ? ne : J
        });
    };
    e.U32LE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !0),
        write: (h, x)=>h.setUint32(0, x, !0)
    }), e.U32BE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !1),
        write: (h, x)=>h.setUint32(0, x, !1)
    }), e.I32LE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !0),
        write: (h, x)=>h.setInt32(0, x, !0)
    }), e.I32BE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !1),
        write: (h, x)=>h.setInt32(0, x, !1)
    }), e.U16LE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !0),
        write: (h, x)=>h.setUint16(0, x, !0)
    }), e.U16BE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !1),
        write: (h, x)=>h.setUint16(0, x, !1)
    }), e.I16LE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !0),
        write: (h, x)=>h.setInt16(0, x, !0)
    }), e.I16BE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !1),
        write: (h, x)=>h.setInt16(0, x, !1)
    }), e.U8 = g(1, !1, {
        read: (h, x)=>h.getUint8(x),
        write: (h, x)=>h.setUint8(0, x)
    }), e.I8 = g(1, !0, {
        read: (h, x)=>h.getInt8(x),
        write: (h, x)=>h.setInt8(0, x)
    });
    const m = (h)=>w(4, {
            read: (x, q)=>x.getFloat32(q, h),
            write: (x, q)=>x.setFloat32(0, q, h),
            validate: (x)=>{
                if (Math.fround(x) !== x && !Number.isNaN(x)) throw new Error(`f32: wrong value=${x}`);
            }
        }), E = (h)=>w(8, {
            read: (x, q)=>x.getFloat64(q, h),
            write: (x, q)=>x.setFloat64(0, q, h)
        });
    e.F32BE = m(!1), e.F32LE = m(!0), e.F64BE = E(!1), e.F64LE = E(!0), e.bool = (0, e.wrap)({
        size: 1,
        encodeStream: (h, x)=>h.byte(x ? 1 : 0),
        decodeStream: (h)=>{
            const x = h.byte();
            if (x !== 0 && x !== 1) throw h.err(`bool: invalid value ${x}`);
            return x === 1;
        },
        validate: (h)=>{
            if (typeof h != "boolean") throw new Error(`bool: invalid value ${h}`);
            return h;
        }
    });
    const T = (h, x = !1)=>{
        if (typeof x != "boolean") throw new Error(`bytes/le: expected boolean, got ${typeof x}`);
        const q = u(h), te = n(h);
        return (0, e.wrap)({
            size: typeof h == "number" ? h : void 0,
            encodeStream: (fe, ne)=>{
                te || q.encodeStream(fe, ne.length), fe.bytes(x ? y(ne) : ne), te && fe.bytes(h);
            },
            decodeStream: (fe)=>{
                let ne;
                if (te) {
                    const W = fe.find(h);
                    if (!W) throw fe.err("bytes: cannot find terminator");
                    ne = fe.bytes(W - fe.pos), fe.bytes(h.length);
                } else ne = fe.bytes(h === null ? fe.leftBytes : q.decodeStream(fe));
                return x ? y(ne) : ne;
            },
            validate: (fe)=>{
                if (!n(fe)) throw new Error(`bytes: invalid value ${fe}`);
                return fe;
            }
        });
    };
    e.bytes = T;
    function I(h, x) {
        if (!D(x)) throw new Error(`prefix: invalid inner value ${x}`);
        return L((0, e.bytes)(h), R(x));
    }
    e.prefix = I;
    const P = (h, x = !1)=>O(L((0, e.bytes)(h, x), t.utf8), (q)=>{
            if (typeof q != "string") throw new Error(`expected string, got ${typeof q}`);
            return q;
        });
    e.string = P, e.cstring = (0, e.string)(e.NULL);
    const k = (h, x = {
        isLE: !1,
        with0x: !1
    })=>{
        let q = L((0, e.bytes)(h, x.isLE), t.hex);
        if (typeof x.with0x != "boolean") throw new Error(`hex/with0x: expected boolean, got ${typeof x.with0x}`);
        return x.with0x && (q = L(q, {
            encode: (te)=>`0x${te}`,
            decode: (te)=>{
                if (!te.startsWith("0x")) throw new Error("hex(with0x=true).encode input should start with 0x");
                return te.slice(2);
            }
        })), q;
    };
    e.hex = k;
    function L(h, x) {
        if (!D(h)) throw new Error(`apply: invalid inner value ${h}`);
        if (!U(x)) throw new Error(`apply: invalid base value ${h}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x.decode(te);
                } catch (ne) {
                    throw q.err("" + ne);
                }
                return h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x.encode(te);
                } catch (fe) {
                    throw q.err("" + fe);
                }
            }
        });
    }
    e.apply = L;
    function j(h) {
        if (typeof h != "function") throw new Error(`lazy: expected function, got ${typeof h}`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>h().encodeStream(x, q),
            decodeStream: (x)=>h().decodeStream(x)
        });
    }
    e.lazy = j;
    const ie = (h, x = !1)=>{
        if (!n(h)) throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof h}`);
        if (typeof x != "boolean") throw new Error(`flag/xor: expected boolean, got ${typeof x}`);
        return (0, e.wrap)({
            size: h.length,
            encodeStream: (q, te)=>{
                !!te !== x && q.bytes(h);
            },
            decodeStream: (q)=>{
                let te = q.leftBytes >= h.length;
                return te && (te = r(q.bytes(h.length, !0), h), te && q.bytes(h.length)), te !== x;
            },
            validate: (q)=>{
                if (q !== void 0 && typeof q != "boolean") throw new Error(`flag: expected boolean value or undefined, got ${typeof q}`);
                return q;
            }
        });
    };
    e.flag = ie;
    function ue(h, x, q) {
        if (!D(x)) throw new Error(`flagged: invalid inner value ${x}`);
        if (typeof h != "string" && !D(x)) throw new Error(`flagged: wrong path=${h}`);
        return (0, e.wrap)({
            encodeStream: (te, fe)=>{
                typeof h == "string" ? c.resolve(te.stack, h) ? x.encodeStream(te, fe) : q && x.encodeStream(te, q) : (h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q && x.encodeStream(te, q));
            },
            decodeStream: (te)=>{
                let fe = !1;
                if (typeof h == "string" ? fe = !!c.resolve(te.stack, h) : fe = h.decodeStream(te), fe) return x.decodeStream(te);
                q && x.decodeStream(te);
            }
        });
    }
    e.flagged = ue;
    function ce(h, x, q) {
        if (!D(h) || !D(x)) throw new Error(`optional: invalid flag or inner value flag=${h} inner=${x}`);
        return (0, e.wrap)({
            size: q !== void 0 && h.size && x.size ? h.size + x.size : void 0,
            encodeStream: (te, fe)=>{
                h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q !== void 0 && x.encodeStream(te, q);
            },
            decodeStream: (te)=>{
                if (h.decodeStream(te)) return x.decodeStream(te);
                q !== void 0 && x.decodeStream(te);
            }
        });
    }
    e.optional = ce;
    function he(h, x, q = !0) {
        if (!D(h)) throw new Error(`magic: invalid inner value ${h}`);
        if (typeof q != "boolean") throw new Error(`magic: expected boolean, got ${typeof q}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                if (q && typeof fe != "object" && fe !== x || n(x) && !r(x, fe)) throw te.err(`magic: invalid value: ${fe} !== ${x}`);
            },
            validate: (te)=>{
                if (te !== void 0) throw new Error(`magic: wrong value=${typeof te}`);
                return te;
            }
        });
    }
    e.magic = he;
    const ee = (h)=>{
        const x = typeof h == "string" ? t.utf8.decode(h) : h;
        return he((0, e.bytes)(x.length), x);
    };
    e.magicBytes = ee;
    function ae(h) {
        return (0, e.wrap)({
            encodeStream: (x, q)=>{
                if (q !== h) throw new Error(`constant: invalid value ${q} (exp: ${h})`);
            },
            decodeStream: (x)=>h
        });
    }
    e.constant = ae;
    function ye(h) {
        let x = 0;
        for (const q of h){
            if (q.size === void 0) return;
            if (!a(q.size)) throw new Error(`sizeof: wrong element size=${x}`);
            x += q.size;
        }
        return x;
    }
    function Se(h) {
        if (!s(h)) throw new Error(`struct: expected plain object, got ${h}`);
        for(const x in h)if (!D(h[x])) throw new Error(`struct: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(Object.values(h)),
            encodeStream: (x, q)=>{
                x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = {};
                return x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>q[fe] = h[fe].decodeStream(x));
                }), q;
            },
            validate: (x)=>{
                if (typeof x != "object" || x === null) throw new Error(`struct: invalid value ${x}`);
                return x;
            }
        });
    }
    e.struct = Se;
    function De(h) {
        if (!Array.isArray(h)) throw new Error(`Packed.Tuple: got ${typeof h} instead of array`);
        for(let x = 0; x < h.length; x++)if (!D(h[x])) throw new Error(`tuple: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(h),
            encodeStream: (x, q)=>{
                if (!Array.isArray(q)) throw x.err(`tuple: invalid value ${q}`);
                x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = [];
                return x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>q.push(h[fe].decodeStream(x)));
                }), q;
            },
            validate: (x)=>{
                if (!Array.isArray(x)) throw new Error(`tuple: invalid value ${x}`);
                if (x.length !== h.length) throw new Error(`tuple: wrong length=${x.length}, expected ${h.length}`);
                return x;
            }
        });
    }
    e.tuple = De;
    function Re(h, x) {
        if (!D(x)) throw new Error(`array: invalid inner value ${x}`);
        const q = u(typeof h == "string" ? `../${h}` : h);
        return (0, e.wrap)({
            size: typeof h == "number" && x.size ? h * x.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te;
                ne.pushObj(fe, (W)=>{
                    n(h) || q.encodeStream(te, fe.length);
                    for(let J = 0; J < fe.length; J++)W(`${J}`, ()=>{
                        const V = fe[J], C = te.pos;
                        if (x.encodeStream(te, V), n(h)) {
                            if (h.length > ne.pos - C) return;
                            const Z = ne.finish(!1).subarray(C, ne.pos);
                            if (r(Z.subarray(0, h.length), h)) throw ne.err(`array: inner element encoding same as separator. elm=${V} data=${Z}`);
                        }
                    });
                }), n(h) && te.bytes(h);
            },
            decodeStream: (te)=>{
                const fe = [];
                return te.pushObj(fe, (ne)=>{
                    if (h === null) for(let W = 0; !te.isEnd() && (ne(`${W}`, ()=>fe.push(x.decodeStream(te))), !(x.size && te.leftBytes < x.size)); W++);
                    else if (n(h)) for(let W = 0;; W++){
                        if (r(te.bytes(h.length, !0), h)) {
                            te.bytes(h.length);
                            break;
                        }
                        ne(`${W}`, ()=>fe.push(x.decodeStream(te)));
                    }
                    else {
                        let W;
                        ne("arrayLen", ()=>W = q.decodeStream(te));
                        for(let J = 0; J < W; J++)ne(`${J}`, ()=>fe.push(x.decodeStream(te)));
                    }
                }), fe;
            },
            validate: (te)=>{
                if (!Array.isArray(te)) throw new Error(`array: invalid value ${te}`);
                return te;
            }
        });
    }
    e.array = Re;
    function Ce(h, x) {
        if (!D(h)) throw new Error(`map: invalid inner value ${h}`);
        if (!s(x)) throw new Error("map: variants should be plain object");
        const q = /* @__PURE__ */ new Map();
        for(const te in x)q.set(x[te], te);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x[fe]),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te), ne = q.get(fe);
                if (ne === void 0) throw te.err(`Enum: unknown value: ${fe} ${Array.from(q.keys())}`);
                return ne;
            },
            validate: (te)=>{
                if (typeof te != "string") throw new Error(`map: invalid value ${te}`);
                if (!(te in x)) throw new Error(`Map: unknown variant: ${te}`);
                return te;
            }
        });
    }
    e.map = Ce;
    function M(h, x) {
        if (!D(h)) throw new Error(`tag: invalid tag value ${h}`);
        if (!s(x)) throw new Error("tag: variants should be plain object");
        for(const q in x)if (!D(x[q])) throw new Error(`tag: variant ${q} is not CoderType`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                const { TAG: fe, data: ne } = te, W = x[fe];
                h.encodeStream(q, fe), W.encodeStream(q, ne);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q), fe = x[te];
                if (!fe) throw q.err(`Tag: invalid tag ${te}`);
                return {
                    TAG: te,
                    data: fe.decodeStream(q)
                };
            },
            validate: (q)=>{
                const { TAG: te } = q;
                if (!x[te]) throw new Error(`Tag: invalid tag ${te.toString()}`);
                return q;
            }
        });
    }
    e.tag = M;
    function z(h, x) {
        if (!D(h)) throw new Error(`mappedTag: invalid tag value ${M}`);
        if (!s(x)) throw new Error("mappedTag: variants should be plain object");
        const q = {}, te = {};
        for(const fe in x){
            const ne = x[fe];
            q[fe] = ne[0], te[fe] = ne[1];
        }
        return M(Ce(h, q), te);
    }
    e.mappedTag = z;
    function de(h, x = !1) {
        if (typeof x != "boolean") throw new Error(`bitset/pad: expected boolean, got ${typeof x}`);
        if (!Array.isArray(h)) throw new Error("bitset/names: expected array");
        for (const q of h)if (typeof q != "string") throw new Error("bitset/names: expected array of strings");
        return (0, e.wrap)({
            encodeStream: (q, te)=>{
                for(let fe = 0; fe < h.length; fe++)q.bits(+te[h[fe]], 1);
                x && h.length % 8 && q.bits(0, 8 - h.length % 8);
            },
            decodeStream: (q)=>{
                const te = {};
                for(let fe = 0; fe < h.length; fe++)te[h[fe]] = !!q.bits(1);
                return x && h.length % 8 && q.bits(8 - h.length % 8), te;
            },
            validate: (q)=>{
                if (!s(q)) throw new Error(`bitset: invalid value ${q}`);
                for (const te of Object.values(q))if (typeof te != "boolean") throw new Error("expected boolean");
                return q;
            }
        });
    }
    e.bitset = de;
    const _e = (h)=>0;
    e.ZeroPad = _e;
    function Ie(h, x) {
        return x % h === 0 ? 0 : h - x % h;
    }
    function je(h, x, q) {
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (!D(x)) throw new Error(`padLeft: invalid inner value ${x}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padLeft: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        if (!x.size) throw new Error("padLeft cannot have dynamic size");
        return (0, e.wrap)({
            size: x.size + Ie(h, x.size),
            encodeStream: (fe, ne)=>{
                const W = Ie(h, x.size);
                for(let J = 0; J < W; J++)fe.byte(te(J));
                x.encodeStream(fe, ne);
            },
            decodeStream: (fe)=>(fe.bytes(Ie(h, x.size)), x.decodeStream(fe))
        });
    }
    e.padLeft = je;
    function Ke(h, x, q) {
        if (!D(x)) throw new Error(`padRight: invalid inner value ${x}`);
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padRight: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        return (0, e.wrap)({
            size: x.size ? x.size + Ie(h, x.size) : void 0,
            encodeStream: (fe, ne)=>{
                const W = fe, J = W.pos;
                x.encodeStream(fe, ne);
                const V = Ie(h, W.pos - J);
                for(let C = 0; C < V; C++)fe.byte(te(C));
            },
            decodeStream: (fe)=>{
                const ne = fe.pos, W = x.decodeStream(fe);
                return fe.bytes(Ie(h, fe.pos - ne)), W;
            }
        });
    }
    e.padRight = Ke;
    function Ue(h, x, q = !1) {
        if (!D(h)) throw new Error(`pointer: invalid ptr value ${h}`);
        if (!D(x)) throw new Error(`pointer: invalid inner value ${x}`);
        if (typeof q != "boolean") throw new Error(`pointer/sized: expected boolean, got ${typeof q}`);
        if (!h.size) throw new Error("unsized pointer");
        return (0, e.wrap)({
            size: q ? h.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te, W = ne.pos;
                h.encodeStream(te, 0), ne.ptrs.push({
                    pos: W,
                    ptr: h,
                    buffer: x.encode(fe)
                });
            },
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                return te._enablePointers(), x.decodeStream(te.offsetReader(fe));
            }
        });
    }
    e.pointer = Ue, e._TEST = {
        _bitset: f,
        _Reader: l,
        _Writer: p,
        Path: c
    };
})(wS);
var vS = {}, wa = {}, no = {};
Object.defineProperty(no, "__esModule", {
    value: !0
});
no.ripemd160 = no.RIPEMD160 = no.md5 = no.MD5 = no.sha1 = no.SHA1 = void 0;
const yf = Pi, gi = Hr, Al = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
]), $c = /* @__PURE__ */ new Uint32Array(80);
class tM extends yf.HashMD {
    constructor(){
        super(64, 20, 8, !1), this.A = Al[0] | 0, this.B = Al[1] | 0, this.C = Al[2] | 0, this.D = Al[3] | 0, this.E = Al[4] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0;
    }
    process(t, r) {
        for(let u = 0; u < 16; u++, r += 4)$c[u] = t.getUint32(r, !1);
        for(let u = 16; u < 80; u++)$c[u] = (0, gi.rotl)($c[u - 3] ^ $c[u - 8] ^ $c[u - 14] ^ $c[u - 16], 1);
        let { A: n, B: i, C: o, D: s, E: a } = this;
        for(let u = 0; u < 80; u++){
            let f, c;
            u < 20 ? (f = (0, yf.Chi)(i, o, s), c = 1518500249) : u < 40 ? (f = i ^ o ^ s, c = 1859775393) : u < 60 ? (f = (0, yf.Maj)(i, o, s), c = 2400959708) : (f = i ^ o ^ s, c = 3395469782);
            const l = (0, gi.rotl)(n, 5) + f + a + c + $c[u] | 0;
            a = s, s = o, o = (0, gi.rotl)(i, 30), i = n, n = l;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, this.set(n, i, o, s, a);
    }
    roundClean() {
        (0, gi.clean)($c);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0), (0, gi.clean)(this.buffer);
    }
}
no.SHA1 = tM;
no.sha1 = (0, gi.createHasher)(()=>new tM());
const Gae = /* @__PURE__ */ Math.pow(2, 32), Zae = /* @__PURE__ */ Array.from({
    length: 64
}, (e, t)=>Math.floor(Gae * Math.abs(Math.sin(t + 1)))), ay = /* @__PURE__ */ Al.slice(0, 4), q_ = /* @__PURE__ */ new Uint32Array(16);
class rM extends yf.HashMD {
    constructor(){
        super(64, 16, 8, !0), this.A = ay[0] | 0, this.B = ay[1] | 0, this.C = ay[2] | 0, this.D = ay[3] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i } = this;
        return [
            t,
            r,
            n,
            i
        ];
    }
    set(t, r, n, i) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0;
    }
    process(t, r) {
        for(let a = 0; a < 16; a++, r += 4)q_[a] = t.getUint32(r, !0);
        let { A: n, B: i, C: o, D: s } = this;
        for(let a = 0; a < 64; a++){
            let u, f, c;
            a < 16 ? (u = (0, yf.Chi)(i, o, s), f = a, c = [
                7,
                12,
                17,
                22
            ]) : a < 32 ? (u = (0, yf.Chi)(s, i, o), f = (5 * a + 1) % 16, c = [
                5,
                9,
                14,
                20
            ]) : a < 48 ? (u = i ^ o ^ s, f = (3 * a + 5) % 16, c = [
                4,
                11,
                16,
                23
            ]) : (u = o ^ (i | ~s), f = 7 * a % 16, c = [
                6,
                10,
                15,
                21
            ]), u = u + n + Zae[a] + q_[f], n = s, s = o, o = i, i = i + (0, gi.rotl)(u, c[a % 4]);
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, this.set(n, i, o, s);
    }
    roundClean() {
        (0, gi.clean)(q_);
    }
    destroy() {
        this.set(0, 0, 0, 0), (0, gi.clean)(this.buffer);
    }
}
no.MD5 = rM;
no.md5 = (0, gi.createHasher)(()=>new rM());
const Yae = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), nM = Uint8Array.from(new Array(16).fill(0).map((e, t)=>t)), Xae = nM.map((e)=>(9 * e + 5) % 16), iM = /* @__PURE__ */ (()=>{
    const r = [
        [
            nM
        ],
        [
            Xae
        ]
    ];
    for(let n = 0; n < 4; n++)for (let i of r)i.push(i[n].map((o)=>Yae[o]));
    return r;
})(), oM = iM[0], sM = iM[1], aM = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>Uint8Array.from(e)), Jae = /* @__PURE__ */ oM.map((e, t)=>e.map((r)=>aM[t][r])), Qae = /* @__PURE__ */ sM.map((e, t)=>e.map((r)=>aM[t][r])), ece = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), tce = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]);
function xI(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const cy = /* @__PURE__ */ new Uint32Array(16);
let cM = class extends yf.HashMD {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)cy[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, u = a, f = this.h3 | 0, c = f, l = this.h4 | 0, p = l;
        for(let y = 0; y < 5; y++){
            const _ = 4 - y, A = ece[y], O = tce[y], N = oM[y], U = sM[y], D = Jae[y], H = Qae[y];
            for(let K = 0; K < 16; K++){
                const re = (0, gi.rotl)(n + xI(y, o, a, f) + cy[N[K]] + A, D[K]) + l | 0;
                n = l, l = f, f = (0, gi.rotl)(a, 10) | 0, a = o, o = re;
            }
            for(let K = 0; K < 16; K++){
                const re = (0, gi.rotl)(i + xI(_, s, u, c) + cy[U[K]] + O, H[K]) + p | 0;
                i = p, p = c, c = (0, gi.rotl)(u, 10) | 0, u = s, s = re;
            }
        }
        this.set(this.h1 + a + c | 0, this.h2 + f + p | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + u | 0);
    }
    roundClean() {
        (0, gi.clean)(cy);
    }
    destroy() {
        this.destroyed = !0, (0, gi.clean)(this.buffer), this.set(0, 0, 0, 0, 0);
    }
};
no.RIPEMD160 = cM;
no.ripemd160 = (0, gi.createHasher)(()=>new cM());
var jf = {}, zd = {};
(function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0;
    function t(ue) {
        return ue instanceof Uint8Array || ArrayBuffer.isView(ue) && ue.constructor.name === "Uint8Array";
    }
    function r(ue, ...ce) {
        if (!t(ue)) throw new Error("Uint8Array expected");
        if (ce.length > 0 && !ce.includes(ue.length)) throw new Error("Uint8Array expected of length " + ce + ", got length=" + ue.length);
    }
    function n(ue, ce) {
        return Array.isArray(ce) ? ce.length === 0 ? !0 : ue ? ce.every((he)=>typeof he == "string") : ce.every((he)=>Number.isSafeInteger(he)) : !1;
    }
    function i(ue) {
        if (typeof ue != "function") throw new Error("function expected");
        return !0;
    }
    function o(ue, ce) {
        if (typeof ce != "string") throw new Error(`${ue}: string expected`);
        return !0;
    }
    function s(ue) {
        if (!Number.isSafeInteger(ue)) throw new Error(`invalid integer: ${ue}`);
    }
    function a(ue) {
        if (!Array.isArray(ue)) throw new Error("array expected");
    }
    function u(ue, ce) {
        if (!n(!0, ce)) throw new Error(`${ue}: array of strings expected`);
    }
    function f(ue, ce) {
        if (!n(!1, ce)) throw new Error(`${ue}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function c(...ue) {
        const ce = (ye)=>ye, he = (ye, Se)=>(De)=>ye(Se(De)), ee = ue.map((ye)=>ye.encode).reduceRight(he, ce), ae = ue.map((ye)=>ye.decode).reduce(he, ce);
        return {
            encode: ee,
            decode: ae
        };
    }
    // @__NO_SIDE_EFFECTS__
    function l(ue) {
        const ce = typeof ue == "string" ? ue.split("") : ue, he = ce.length;
        u("alphabet", ce);
        const ee = new Map(ce.map((ae, ye)=>[
                ae,
                ye
            ]));
        return {
            encode: (ae)=>(a(ae), ae.map((ye)=>{
                    if (!Number.isSafeInteger(ye) || ye < 0 || ye >= he) throw new Error(`alphabet.encode: digit index outside alphabet "${ye}". Allowed: ${ue}`);
                    return ce[ye];
                })),
            decode: (ae)=>(a(ae), ae.map((ye)=>{
                    o("alphabet.decode", ye);
                    const Se = ee.get(ye);
                    if (Se === void 0) throw new Error(`Unknown letter: "${ye}". Allowed: ${ue}`);
                    return Se;
                }))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function p(ue = "") {
        return o("join", ue), {
            encode: (ce)=>(u("join.decode", ce), ce.join(ue)),
            decode: (ce)=>(o("join.decode", ce), ce.split(ue))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function y(ue, ce = "=") {
        return s(ue), o("padding", ce), {
            encode (he) {
                for(u("padding.encode", he); he.length * ue % 8;)he.push(ce);
                return he;
            },
            decode (he) {
                u("padding.decode", he);
                let ee = he.length;
                if (ee * ue % 8) throw new Error("padding: invalid, string should have whole number of bytes");
                for(; ee > 0 && he[ee - 1] === ce; ee--)if ((ee - 1) * ue % 8 === 0) throw new Error("padding: invalid, string has too much padding");
                return he.slice(0, ee);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function _(ue) {
        return i(ue), {
            encode: (ce)=>ce,
            decode: (ce)=>ue(ce)
        };
    }
    function A(ue, ce, he) {
        if (ce < 2) throw new Error(`convertRadix: invalid from=${ce}, base cannot be less than 2`);
        if (he < 2) throw new Error(`convertRadix: invalid to=${he}, base cannot be less than 2`);
        if (a(ue), !ue.length) return [];
        let ee = 0;
        const ae = [], ye = Array.from(ue, (De)=>{
            if (s(De), De < 0 || De >= ce) throw new Error(`invalid integer: ${De}`);
            return De;
        }), Se = ye.length;
        for(;;){
            let De = 0, Re = !0;
            for(let Ce = ee; Ce < Se; Ce++){
                const M = ye[Ce], z = ce * De, de = z + M;
                if (!Number.isSafeInteger(de) || z / ce !== De || de - M !== z) throw new Error("convertRadix: carry overflow");
                const _e = de / he;
                De = de % he;
                const Ie = Math.floor(_e);
                if (ye[Ce] = Ie, !Number.isSafeInteger(Ie) || Ie * he + De !== de) throw new Error("convertRadix: carry overflow");
                if (Re) Ie ? Re = !1 : ee = Ce;
                else continue;
            }
            if (ae.push(De), Re) break;
        }
        for(let De = 0; De < ue.length - 1 && ue[De] === 0; De++)ae.push(0);
        return ae.reverse();
    }
    const O = (ue, ce)=>ce === 0 ? ue : O(ce, ue % ce), N = /* @__NO_SIDE_EFFECTS__ */ (ue, ce)=>ue + (ce - O(ue, ce)), U = /* @__PURE__ */ (()=>{
        let ue = [];
        for(let ce = 0; ce < 40; ce++)ue.push(2 ** ce);
        return ue;
    })();
    function D(ue, ce, he, ee) {
        if (a(ue), ce <= 0 || ce > 32) throw new Error(`convertRadix2: wrong from=${ce}`);
        if (he <= 0 || he > 32) throw new Error(`convertRadix2: wrong to=${he}`);
        if (/* @__PURE__ */ N(ce, he) > 32) throw new Error(`convertRadix2: carry overflow from=${ce} to=${he} carryBits=${/* @__PURE__ */ N(ce, he)}`);
        let ae = 0, ye = 0;
        const Se = U[ce], De = U[he] - 1, Re = [];
        for (const Ce of ue){
            if (s(Ce), Ce >= Se) throw new Error(`convertRadix2: invalid data word=${Ce} from=${ce}`);
            if (ae = ae << ce | Ce, ye + ce > 32) throw new Error(`convertRadix2: carry overflow pos=${ye} from=${ce}`);
            for(ye += ce; ye >= he; ye -= he)Re.push((ae >> ye - he & De) >>> 0);
            const M = U[ye];
            if (M === void 0) throw new Error("invalid carry");
            ae &= M - 1;
        }
        if (ae = ae << he - ye & De, !ee && ye >= ce) throw new Error("Excess padding");
        if (!ee && ae > 0) throw new Error(`Non-zero padding: ${ae}`);
        return ee && ye > 0 && Re.push(ae >>> 0), Re;
    }
    // @__NO_SIDE_EFFECTS__
    function H(ue) {
        s(ue);
        const ce = 2 ** 8;
        return {
            encode: (he)=>{
                if (!t(he)) throw new Error("radix.encode input should be Uint8Array");
                return A(Array.from(he), ce, ue);
            },
            decode: (he)=>(f("radix.decode", he), Uint8Array.from(A(he, ue, ce)))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function K(ue, ce = !1) {
        if (s(ue), ue <= 0 || ue > 32) throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ N(8, ue) > 32 || /* @__PURE__ */ N(ue, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (he)=>{
                if (!t(he)) throw new Error("radix2.encode input should be Uint8Array");
                return D(Array.from(he), 8, ue, !ce);
            },
            decode: (he)=>(f("radix2.decode", he), Uint8Array.from(D(he, ue, 8, ce)))
        };
    }
    function re(ue) {
        return i(ue), function(...ce) {
            try {
                return ue.apply(null, ce);
            } catch  {}
        };
    }
    function Q(ue, ce) {
        return s(ue), i(ce), {
            encode (he) {
                if (!t(he)) throw new Error("checksum.encode: input should be Uint8Array");
                const ee = ce(he).slice(0, ue), ae = new Uint8Array(he.length + ue);
                return ae.set(he), ae.set(ee, he.length), ae;
            },
            decode (he) {
                if (!t(he)) throw new Error("checksum.decode: input should be Uint8Array");
                const ee = he.slice(0, -ue), ae = he.slice(-ue), ye = ce(ee).slice(0, ue);
                for(let Se = 0; Se < ue; Se++)if (ye[Se] !== ae[Se]) throw new Error("Invalid checksum");
                return ee;
            }
        };
    }
    e.utils = {
        alphabet: l,
        chain: c,
        checksum: Q,
        convertRadix: A,
        convertRadix2: D,
        radix: H,
        radix2: K,
        join: p,
        padding: y
    }, e.base16 = /* @__PURE__ */ c(/* @__PURE__ */ K(4), /* @__PURE__ */ l("0123456789ABCDEF"), /* @__PURE__ */ p("")), e.base32 = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ y(5), /* @__PURE__ */ p("")), e.base32nopad = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ p("")), e.base32hex = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ y(5), /* @__PURE__ */ p("")), e.base32hexnopad = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ p("")), e.base32crockford = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ p(""), /* @__PURE__ */ _((ue)=>ue.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    const G = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function", R = (ue, ce)=>{
        o("base64", ue);
        const he = ce ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/, ee = ce ? "base64url" : "base64";
        if (ue.length > 0 && !he.test(ue)) throw new Error("invalid base64");
        return Uint8Array.fromBase64(ue, {
            alphabet: ee,
            lastChunkHandling: "strict"
        });
    };
    e.base64 = G ? {
        encode (ue) {
            return r(ue), ue.toBase64();
        },
        decode (ue) {
            return R(ue, !1);
        }
    } : /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ y(6), /* @__PURE__ */ p("")), e.base64nopad = /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ p("")), e.base64url = G ? {
        encode (ue) {
            return r(ue), ue.toBase64({
                alphabet: "base64url"
            });
        },
        decode (ue) {
            return R(ue, !0);
        }
    } : /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ y(6), /* @__PURE__ */ p("")), e.base64urlnopad = /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ p(""));
    const X = /* @__NO_SIDE_EFFECTS__ */ (ue)=>/* @__PURE__ */ c(/* @__PURE__ */ H(58), /* @__PURE__ */ l(ue), /* @__PURE__ */ p(""));
    e.base58 = /* @__PURE__ */ X("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = /* @__PURE__ */ X("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = /* @__PURE__ */ X("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const $ = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    e.base58xmr = {
        encode (ue) {
            let ce = "";
            for(let he = 0; he < ue.length; he += 8){
                const ee = ue.subarray(he, he + 8);
                ce += e.base58.encode(ee).padStart($[ee.length], "1");
            }
            return ce;
        },
        decode (ue) {
            let ce = [];
            for(let he = 0; he < ue.length; he += 11){
                const ee = ue.slice(he, he + 11), ae = $.indexOf(ee.length), ye = e.base58.decode(ee);
                for(let Se = 0; Se < ye.length - ae; Se++)if (ye[Se] !== 0) throw new Error("base58xmr: wrong padding");
                ce = ce.concat(Array.from(ye.slice(ye.length - ae)));
            }
            return Uint8Array.from(ce);
        }
    };
    const S = (ue)=>/* @__PURE__ */ c(Q(4, (ce)=>ue(ue(ce))), e.base58);
    e.createBase58check = S, e.base58check = e.createBase58check;
    const w = /* @__PURE__ */ c(/* @__PURE__ */ l("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ p("")), g = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    function m(ue) {
        const ce = ue >> 25;
        let he = (ue & 33554431) << 5;
        for(let ee = 0; ee < g.length; ee++)(ce >> ee & 1) === 1 && (he ^= g[ee]);
        return he;
    }
    function E(ue, ce, he = 1) {
        const ee = ue.length;
        let ae = 1;
        for(let ye = 0; ye < ee; ye++){
            const Se = ue.charCodeAt(ye);
            if (Se < 33 || Se > 126) throw new Error(`Invalid prefix (${ue})`);
            ae = m(ae) ^ Se >> 5;
        }
        ae = m(ae);
        for(let ye = 0; ye < ee; ye++)ae = m(ae) ^ ue.charCodeAt(ye) & 31;
        for (let ye of ce)ae = m(ae) ^ ye;
        for(let ye = 0; ye < 6; ye++)ae = m(ae);
        return ae ^= he, w.encode(D([
            ae % U[30]
        ], 30, 5, !1));
    }
    // @__NO_SIDE_EFFECTS__
    function T(ue) {
        const ce = ue === "bech32" ? 1 : 734539939, he = /* @__PURE__ */ K(5), ee = he.decode, ae = he.encode, ye = re(ee);
        function Se(z, de, _e = 90) {
            o("bech32.encode prefix", z), t(de) && (de = Array.from(de)), f("bech32.encode", de);
            const Ie = z.length;
            if (Ie === 0) throw new TypeError(`Invalid prefix length ${Ie}`);
            const je = Ie + 7 + de.length;
            if (_e !== !1 && je > _e) throw new TypeError(`Length ${je} exceeds limit ${_e}`);
            const Ke = z.toLowerCase(), Ue = E(Ke, de, ce);
            return `${Ke}1${w.encode(de)}${Ue}`;
        }
        function De(z, de = 90) {
            o("bech32.decode input", z);
            const _e = z.length;
            if (_e < 8 || de !== !1 && _e > de) throw new TypeError(`invalid string length: ${_e} (${z}). Expected (8..${de})`);
            const Ie = z.toLowerCase();
            if (z !== Ie && z !== z.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const je = Ie.lastIndexOf("1");
            if (je === 0 || je === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const Ke = Ie.slice(0, je), Ue = Ie.slice(je + 1);
            if (Ue.length < 6) throw new Error("Data must be at least 6 characters long");
            const h = w.decode(Ue).slice(0, -6), x = E(Ke, h, ce);
            if (!Ue.endsWith(x)) throw new Error(`Invalid checksum in ${z}: expected "${x}"`);
            return {
                prefix: Ke,
                words: h
            };
        }
        const Re = re(De);
        function Ce(z) {
            const { prefix: de, words: _e } = De(z, !1);
            return {
                prefix: de,
                words: _e,
                bytes: ee(_e)
            };
        }
        function M(z, de) {
            return Se(z, ae(de));
        }
        return {
            encode: Se,
            decode: De,
            encodeFromBytes: M,
            decodeToBytes: Ce,
            decodeUnsafe: Re,
            fromWords: ee,
            fromWordsUnsafe: ye,
            toWords: ae
        };
    }
    e.bech32 = /* @__PURE__ */ T("bech32"), e.bech32m = /* @__PURE__ */ T("bech32m"), e.utf8 = {
        encode: (ue)=>new TextDecoder().decode(ue),
        decode: (ue)=>new TextEncoder().encode(ue)
    };
    const I = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", P = {
        encode (ue) {
            return r(ue), ue.toHex();
        },
        decode (ue) {
            return o("hex", ue), Uint8Array.fromHex(ue);
        }
    };
    e.hex = I ? P : /* @__PURE__ */ c(/* @__PURE__ */ K(4), /* @__PURE__ */ l("0123456789abcdef"), /* @__PURE__ */ p(""), /* @__PURE__ */ _((ue)=>{
        if (typeof ue != "string" || ue.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof ue} with length ${ue.length}`);
        return ue.toLowerCase();
    }));
    const k = {
        utf8: e.utf8,
        hex: e.hex,
        base16: e.base16,
        base32: e.base32,
        base64: e.base64,
        base64url: e.base64url,
        base58: e.base58,
        base58xmr: e.base58xmr
    }, L = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", j = (ue, ce)=>{
        if (typeof ue != "string" || !k.hasOwnProperty(ue)) throw new TypeError(L);
        if (!t(ce)) throw new TypeError("bytesToString() expects Uint8Array");
        return k[ue].encode(ce);
    };
    e.bytesToString = j, e.str = e.bytesToString;
    const ie = (ue, ce)=>{
        if (!k.hasOwnProperty(ue)) throw new TypeError(L);
        if (typeof ce != "string") throw new TypeError("stringToBytes() expects string");
        return k[ue].decode(ce);
    };
    e.stringToBytes = ie, e.bytes = e.stringToBytes;
})(zd);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._TEST = e.ZeroPad = e.magicBytes = e.flag = e.cstring = e.string = e.hex = e.bytes = e.bool = e.F64LE = e.F64BE = e.F32LE = e.F32BE = e.I8 = e.U8 = e.I16BE = e.I16LE = e.U16BE = e.U16LE = e.I32BE = e.I32LE = e.U32BE = e.U32LE = e.int = e.I64BE = e.I64LE = e.U64BE = e.U64LE = e.I128BE = e.I128LE = e.U128BE = e.U128LE = e.I256BE = e.I256LE = e.U256BE = e.U256LE = e.bigint = e.bits = e.coders = e.wrap = e.utils = e.NULL = e.EMPTY = void 0, e.validate = O, e.isCoder = D, e.prefix = I, e.apply = L, e.lazy = j, e.flagged = ue, e.optional = ce, e.magic = he, e.constant = ae, e.struct = Se, e.tuple = De, e.array = Re, e.map = Ce, e.tag = M, e.mappedTag = z, e.bitset = de, e.padLeft = je, e.padRight = Ke, e.pointer = Ue;
    const t = zd;
    e.EMPTY = new Uint8Array(), e.NULL = new Uint8Array([
        0
    ]);
    function r(h, x) {
        if (h.length !== x.length) return !1;
        for(let q = 0; q < h.length; q++)if (h[q] !== x[q]) return !1;
        return !0;
    }
    function n(h) {
        return h instanceof Uint8Array || ArrayBuffer.isView(h) && h.constructor.name === "Uint8Array";
    }
    function i(...h) {
        let x = 0;
        for(let te = 0; te < h.length; te++){
            const fe = h[te];
            if (!n(fe)) throw new Error("Uint8Array expected");
            x += fe.length;
        }
        const q = new Uint8Array(x);
        for(let te = 0, fe = 0; te < h.length; te++){
            const ne = h[te];
            q.set(ne, fe), fe += ne.length;
        }
        return q;
    }
    const o = (h)=>new DataView(h.buffer, h.byteOffset, h.byteLength);
    function s(h) {
        return Object.prototype.toString.call(h) === "[object Object]";
    }
    function a(h) {
        return Number.isSafeInteger(h);
    }
    e.utils = {
        equalBytes: r,
        isBytes: n,
        isCoder: D,
        checkBounds: _,
        concatBytes: i,
        createView: o,
        isPlainObject: s
    };
    const u = (h)=>{
        if (h !== null && typeof h != "string" && !D(h) && !n(h) && !a(h)) throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${h} (${typeof h})`);
        return {
            encodeStream (x, q) {
                if (h === null) return;
                if (D(h)) return h.encodeStream(x, q);
                let te;
                if (typeof h == "number" ? te = h : typeof h == "string" && (te = c.resolve(x.stack, h)), typeof te == "bigint" && (te = Number(te)), te === void 0 || te !== q) throw x.err(`Wrong length: ${te} len=${h} exp=${q} (${typeof q})`);
            },
            decodeStream (x) {
                let q;
                if (D(h) ? q = Number(h.decodeStream(x)) : typeof h == "number" ? q = h : typeof h == "string" && (q = c.resolve(x.stack, h)), typeof q == "bigint" && (q = Number(q)), typeof q != "number") throw x.err(`Wrong length: ${q}`);
                return q;
            }
        };
    }, f = {
        BITS: 32,
        FULL_MASK: -1 >>> 0,
        // 1<<32 will overflow
        len: (h)=>Math.ceil(h / 32),
        create: (h)=>new Uint32Array(f.len(h)),
        clean: (h)=>h.fill(0),
        debug: (h)=>Array.from(h).map((x)=>(x >>> 0).toString(2).padStart(32, "0")),
        checkLen: (h, x)=>{
            if (f.len(x) !== h.length) throw new Error(`wrong length=${h.length}. Expected: ${f.len(x)}`);
        },
        chunkLen: (h, x, q)=>{
            if (x < 0) throw new Error(`wrong pos=${x}`);
            if (x + q > h) throw new Error(`wrong range=${x}/${q} of ${h}`);
        },
        set: (h, x, q, te = !0)=>!te && h[x] & q ? !1 : (h[x] |= q, !0),
        pos: (h, x)=>({
                chunk: Math.floor((h + x) / 32),
                mask: 1 << 32 - (h + x) % 32 - 1
            }),
        indices: (h, x, q = !1)=>{
            f.checkLen(h, x);
            const { FULL_MASK: te, BITS: fe } = f, ne = fe - x % fe, W = ne ? te >>> ne << ne : te, J = [];
            for(let V = 0; V < h.length; V++){
                let C = h[V];
                if (q && (C = ~C), V === h.length - 1 && (C &= W), C !== 0) for(let Z = 0; Z < fe; Z++){
                    const le = 1 << fe - Z - 1;
                    C & le && J.push(V * fe + Z);
                }
            }
            return J;
        },
        range: (h)=>{
            const x = [];
            let q;
            for (const te of h)q === void 0 || te !== q.pos + q.length ? x.push(q = {
                pos: te,
                length: 1
            }) : q.length += 1;
            return x;
        },
        rangeDebug: (h, x, q = !1)=>`[${f.range(f.indices(h, x, q)).map((te)=>`(${te.pos}/${te.length})`).join(", ")}]`,
        setRange: (h, x, q, te, fe = !0)=>{
            f.chunkLen(x, q, te);
            const { FULL_MASK: ne, BITS: W } = f, J = q % W ? Math.floor(q / W) : void 0, V = q + te, C = V % W ? Math.floor(V / W) : void 0;
            if (J !== void 0 && J === C) return f.set(h, J, ne >>> W - te << W - te - q, fe);
            if (J !== void 0 && !f.set(h, J, ne >>> q % W, fe)) return !1;
            const Z = J !== void 0 ? J + 1 : q / W, le = C !== void 0 ? C : V / W;
            for(let se = Z; se < le; se++)if (!f.set(h, se, ne, fe)) return !1;
            return !(C !== void 0 && J !== C && !f.set(h, C, ne << W - V % W, fe));
        }
    }, c = {
        /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */ pushObj: (h, x, q)=>{
            const te = {
                obj: x
            };
            h.push(te), q((fe, ne)=>{
                te.field = fe, ne(), te.field = void 0;
            }), h.pop();
        },
        path: (h)=>{
            const x = [];
            for (const q of h)q.field !== void 0 && x.push(q.field);
            return x.join("/");
        },
        err: (h, x, q)=>{
            const te = new Error(`${h}(${c.path(x)}): ${typeof q == "string" ? q : q.message}`);
            return q instanceof Error && q.stack && (te.stack = q.stack), te;
        },
        resolve: (h, x)=>{
            const q = x.split("/"), te = h.map((W)=>W.obj);
            let fe = 0;
            for(; fe < q.length && q[fe] === ".."; fe++)te.pop();
            let ne = te.pop();
            for(; fe < q.length; fe++){
                if (!ne || ne[q[fe]] === void 0) return;
                ne = ne[q[fe]];
            }
            return ne;
        }
    };
    class l {
        constructor(x, q = {}, te = [], fe = void 0, ne = 0){
            this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.data = x, this.opts = q, this.stack = te, this.parent = fe, this.parentOffset = ne, this.view = o(x);
        }
        /** Internal method for pointers. */ _enablePointers() {
            if (this.parent) return this.parent._enablePointers();
            this.bs || (this.bs = f.create(this.data.length), f.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
        }
        markBytesBS(x, q) {
            return this.parent ? this.parent.markBytesBS(this.parentOffset + x, q) : !q || !this.bs ? !0 : f.setRange(this.bs, this.data.length, x, q, !1);
        }
        markBytes(x) {
            const q = this.pos;
            this.pos += x;
            const te = this.markBytesBS(q, x);
            if (!this.opts.allowMultipleReads && !te) throw this.err(`multiple read pos=${this.pos} len=${x}`);
            return te;
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        readView(x, q) {
            if (!Number.isFinite(x)) throw this.err(`readView: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readView: Unexpected end of buffer");
            const te = q(this.view, this.pos);
            return this.markBytes(x), te;
        }
        // read bytes by absolute offset
        absBytes(x) {
            if (x > this.data.length) throw new Error("Unexpected end of buffer");
            return this.data.subarray(x);
        }
        finish() {
            if (!this.opts.allowUnreadBytes) {
                if (this.bitPos) throw this.err(`${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
                if (this.bs && !this.parent) {
                    const x = f.indices(this.bs, this.data.length, !0);
                    if (x.length) {
                        const q = f.range(x).map(({ pos: te, length: fe })=>`(${te}/${fe})[${t.hex.encode(this.data.subarray(te, te + fe))}]`).join(", ");
                        throw this.err(`unread byte ranges: ${q} (total=${this.data.length})`);
                    } else return;
                }
                if (!this.isEnd()) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
            }
        }
        // User methods
        err(x) {
            return c.err("Reader", this.stack, x);
        }
        offsetReader(x) {
            if (x > this.data.length) throw this.err("offsetReader: Unexpected end of buffer");
            return new l(this.absBytes(x), this.opts, this.stack, this, x);
        }
        bytes(x, q = !1) {
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(x)) throw this.err(`readBytes: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const te = this.data.subarray(this.pos, this.pos + x);
            return q || this.markBytes(x), te;
        }
        byte(x = !1) {
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            if (this.pos + 1 > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const q = this.data[this.pos];
            return x || this.markBytes(1), q;
        }
        get leftBytes() {
            return this.data.length - this.pos;
        }
        get totalBytes() {
            return this.data.length;
        }
        isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
        }
        // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
        bits(x) {
            if (x > 32) throw this.err("BitReader: cannot read more than 32 bits in single call");
            let q = 0;
            for(; x;){
                this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
                const te = Math.min(x, this.bitPos);
                this.bitPos -= te, q = q << te | this.bitBuf >> this.bitPos & 2 ** te - 1, this.bitBuf &= 2 ** this.bitPos - 1, x -= te;
            }
            return q >>> 0;
        }
        find(x, q = this.pos) {
            if (!n(x)) throw this.err(`find: needle is not bytes! ${x}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!x.length) throw this.err("find: needle is empty");
            for(let te = q; (te = this.data.indexOf(x[0], te)) !== -1; te++){
                if (te === -1 || this.data.length - te < x.length) return;
                if (r(x, this.data.subarray(te, te + x.length))) return te;
            }
        }
    }
    class p {
        constructor(x = []){
            this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = !1, this.stack = x, this.view = o(this.viewBuf);
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        writeView(x, q) {
            if (this.finished) throw this.err("buffer: finished");
            if (!a(x) || x > 8) throw new Error(`wrong writeView length=${x}`);
            q(this.view), this.bytes(this.viewBuf.slice(0, x)), this.viewBuf.fill(0);
        }
        // User methods
        err(x) {
            if (this.finished) throw this.err("buffer: finished");
            return c.err("Reader", this.stack, x);
        }
        bytes(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(x), this.pos += x.length;
        }
        byte(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([
                x
            ])), this.pos++;
        }
        finish(x = !0) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("buffer: ends with non-empty bit buffer");
            const q = this.buffers.concat(this.ptrs.map((ne)=>ne.buffer)), te = q.map((ne)=>ne.length).reduce((ne, W)=>ne + W, 0), fe = new Uint8Array(te);
            for(let ne = 0, W = 0; ne < q.length; ne++){
                const J = q[ne];
                fe.set(J, W), W += J.length;
            }
            for(let ne = this.pos, W = 0; W < this.ptrs.length; W++){
                const J = this.ptrs[W];
                fe.set(J.ptr.encode(ne), J.pos), ne += J.buffer.length;
            }
            if (x) {
                this.buffers = [];
                for (const ne of this.ptrs)ne.buffer.fill(0);
                this.ptrs = [], this.finished = !0, this.bitBuf = 0;
            }
            return fe;
        }
        bits(x, q) {
            if (q > 32) throw this.err("writeBits: cannot write more than 32 bits in single call");
            if (x >= 2 ** q) throw this.err(`writeBits: value (${x}) >= 2**bits (${q})`);
            for(; q;){
                const te = Math.min(q, 8 - this.bitPos);
                this.bitBuf = this.bitBuf << te | x >> q - te, this.bitPos += te, q -= te, x &= 2 ** q - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([
                    this.bitBuf
                ])), this.pos++);
            }
        }
    }
    const y = (h)=>Uint8Array.from(h).reverse();
    function _(h, x, q) {
        if (q) {
            const te = 2n ** (x - 1n);
            if (h < -te || h >= te) throw new Error(`value out of signed bounds. Expected ${-te} <= ${h} < ${te}`);
        } else if (0n > h || h >= 2n ** x) throw new Error(`value out of unsigned bounds. Expected 0 <= ${h} < ${2n ** x}`);
    }
    function A(h) {
        return {
            // NOTE: we cannot export validate here, since it is likely mistake.
            encodeStream: h.encodeStream,
            decodeStream: h.decodeStream,
            size: h.size,
            encode: (x)=>{
                const q = new p();
                return h.encodeStream(q, x), q.finish();
            },
            decode: (x, q = {})=>{
                const te = new l(x, q), fe = h.decodeStream(te);
                return te.finish(), fe;
            }
        };
    }
    function O(h, x) {
        if (!D(h)) throw new Error(`validate: invalid inner value ${h}`);
        if (typeof x != "function") throw new Error("validate: fn should be function");
        return A({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x(te);
                } catch (ne) {
                    throw q.err(ne);
                }
                h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x(te);
                } catch (fe) {
                    throw q.err(fe);
                }
            }
        });
    }
    const N = (h)=>{
        const x = A(h);
        return h.validate ? O(x, h.validate) : x;
    };
    e.wrap = N;
    const U = (h)=>s(h) && typeof h.decode == "function" && typeof h.encode == "function";
    function D(h) {
        return s(h) && U(h) && typeof h.encodeStream == "function" && typeof h.decodeStream == "function" && (h.size === void 0 || a(h.size));
    }
    function H() {
        return {
            encode: (h)=>{
                if (!Array.isArray(h)) throw new Error("array expected");
                const x = {};
                for (const q of h){
                    if (!Array.isArray(q) || q.length !== 2) throw new Error("array of two elements expected");
                    const te = q[0], fe = q[1];
                    if (x[te] !== void 0) throw new Error(`key(${te}) appears twice in struct`);
                    x[te] = fe;
                }
                return x;
            },
            decode: (h)=>{
                if (!s(h)) throw new Error(`expected plain object, got ${h}`);
                return Object.entries(h);
            }
        };
    }
    const K = {
        encode: (h)=>{
            if (typeof h != "bigint") throw new Error(`expected bigint, got ${typeof h}`);
            if (h > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`element bigger than MAX_SAFE_INTEGER=${h}`);
            return Number(h);
        },
        decode: (h)=>{
            if (!a(h)) throw new Error("element is not a safe integer");
            return BigInt(h);
        }
    };
    function re(h) {
        if (!s(h)) throw new Error("plain object expected");
        return {
            encode: (x)=>{
                if (!a(x) || !(x in h)) throw new Error(`wrong value ${x}`);
                return h[x];
            },
            decode: (x)=>{
                if (typeof x != "string") throw new Error(`wrong value ${typeof x}`);
                return h[x];
            }
        };
    }
    function Q(h, x = !1) {
        if (!a(h)) throw new Error(`decimal/precision: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`decimal/round: expected boolean, got ${typeof x}`);
        const q = 10n ** BigInt(h);
        return {
            encode: (te)=>{
                if (typeof te != "bigint") throw new Error(`expected bigint, got ${typeof te}`);
                let fe = (te < 0n ? -te : te).toString(10), ne = fe.length - h;
                ne < 0 && (fe = fe.padStart(fe.length - ne, "0"), ne = 0);
                let W = fe.length - 1;
                for(; W >= ne && fe[W] === "0"; W--);
                let J = fe.slice(0, ne), V = fe.slice(ne, W + 1);
                return J || (J = "0"), te < 0n && (J = "-" + J), V ? `${J}.${V}` : J;
            },
            decode: (te)=>{
                if (typeof te != "string") throw new Error(`expected string, got ${typeof te}`);
                if (te === "-0") throw new Error("negative zero is not allowed");
                let fe = !1;
                if (te.startsWith("-") && (fe = !0, te = te.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(te)) throw new Error(`wrong string value=${te}`);
                let ne = te.indexOf(".");
                ne = ne === -1 ? te.length : ne;
                const W = te.slice(0, ne), J = te.slice(ne + 1).replace(/0+$/, ""), V = BigInt(W) * q;
                if (!x && J.length > h) throw new Error(`fractional part cannot be represented with this precision (num=${te}, prec=${h})`);
                const C = Math.min(J.length, h), Z = BigInt(J.slice(0, C)) * 10n ** BigInt(h - C), le = V + Z;
                return fe ? -le : le;
            }
        };
    }
    function G(h) {
        if (!Array.isArray(h)) throw new Error(`expected array, got ${typeof h}`);
        for (const x of h)if (!U(x)) throw new Error(`wrong base coder ${x}`);
        return {
            encode: (x)=>{
                for (const q of h){
                    const te = q.encode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/encode: cannot find match in ${x}`);
            },
            decode: (x)=>{
                for (const q of h){
                    const te = q.decode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/decode: cannot find match in ${x}`);
            }
        };
    }
    const R = (h)=>{
        if (!U(h)) throw new Error("BaseCoder expected");
        return {
            encode: h.decode,
            decode: h.encode
        };
    };
    e.coders = {
        dict: H,
        numberBigint: K,
        tsEnum: re,
        decimal: Q,
        match: G,
        reverse: R
    };
    const X = (h)=>{
        if (!a(h)) throw new Error(`bits: wrong length ${h} (${typeof h})`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>x.bits(q, h),
            decodeStream: (x)=>x.bits(h),
            validate: (x)=>{
                if (!a(x)) throw new Error(`bits: wrong value ${x}`);
                return x;
            }
        });
    };
    e.bits = X;
    const $ = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`bigint/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`bigint/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`bigint/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`bigint/sized: expected boolean, got ${typeof te}`);
        const fe = BigInt(h), ne = 2n ** (8n * fe - 1n);
        return (0, e.wrap)({
            size: te ? h : void 0,
            encodeStream: (W, J)=>{
                q && J < 0 && (J = J | ne);
                const V = [];
                for(let Z = 0; Z < h; Z++)V.push(Number(J & 255n)), J >>= 8n;
                let C = new Uint8Array(V).reverse();
                if (!te) {
                    let Z = 0;
                    for(Z = 0; Z < C.length && C[Z] === 0; Z++);
                    C = C.subarray(Z);
                }
                W.bytes(x ? C.reverse() : C);
            },
            decodeStream: (W)=>{
                const J = W.bytes(te ? h : Math.min(h, W.leftBytes)), V = x ? J : y(J);
                let C = 0n;
                for(let Z = 0; Z < V.length; Z++)C |= BigInt(V[Z]) << 8n * BigInt(Z);
                return q && C & ne && (C = (C ^ ne) - ne), C;
            },
            validate: (W)=>{
                if (typeof W != "bigint") throw new Error(`bigint: invalid value: ${W}`);
                return _(W, 8n * fe, !!q), W;
            }
        });
    };
    e.bigint = $, e.U256LE = (0, e.bigint)(32, !0), e.U256BE = (0, e.bigint)(32, !1), e.I256LE = (0, e.bigint)(32, !0, !0), e.I256BE = (0, e.bigint)(32, !1, !0), e.U128LE = (0, e.bigint)(16, !0), e.U128BE = (0, e.bigint)(16, !1), e.I128LE = (0, e.bigint)(16, !0, !0), e.I128BE = (0, e.bigint)(16, !1, !0), e.U64LE = (0, e.bigint)(8, !0), e.U64BE = (0, e.bigint)(8, !1), e.I64LE = (0, e.bigint)(8, !0, !0), e.I64BE = (0, e.bigint)(8, !1, !0);
    const S = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`int/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`int/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`int/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`int/sized: expected boolean, got ${typeof te}`);
        if (h > 6) throw new Error("int supports size up to 6 bytes (48 bits): use bigints instead");
        return L((0, e.bigint)(h, x, q, te), e.coders.numberBigint);
    };
    e.int = S;
    const w = (h, x)=>(0, e.wrap)({
            size: h,
            encodeStream: (q, te)=>q.writeView(h, (fe)=>x.write(fe, te)),
            decodeStream: (q)=>q.readView(h, x.read),
            validate: (q)=>{
                if (typeof q != "number") throw new Error(`viewCoder: expected number, got ${typeof q}`);
                return x.validate && x.validate(q), q;
            }
        }), g = (h, x, q)=>{
        const te = h * 8, fe = 2 ** (te - 1), ne = (V)=>{
            if (!a(V)) throw new Error(`sintView: value is not safe integer: ${V}`);
            if (V < -fe || V >= fe) throw new Error(`sintView: value out of bounds. Expected ${-fe} <= ${V} < ${fe}`);
        }, W = 2 ** te, J = (V)=>{
            if (!a(V)) throw new Error(`uintView: value is not safe integer: ${V}`);
            if (0 > V || V >= W) throw new Error(`uintView: value out of bounds. Expected 0 <= ${V} < ${W}`);
        };
        return w(h, {
            write: q.write,
            read: q.read,
            validate: x ? ne : J
        });
    };
    e.U32LE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !0),
        write: (h, x)=>h.setUint32(0, x, !0)
    }), e.U32BE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !1),
        write: (h, x)=>h.setUint32(0, x, !1)
    }), e.I32LE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !0),
        write: (h, x)=>h.setInt32(0, x, !0)
    }), e.I32BE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !1),
        write: (h, x)=>h.setInt32(0, x, !1)
    }), e.U16LE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !0),
        write: (h, x)=>h.setUint16(0, x, !0)
    }), e.U16BE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !1),
        write: (h, x)=>h.setUint16(0, x, !1)
    }), e.I16LE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !0),
        write: (h, x)=>h.setInt16(0, x, !0)
    }), e.I16BE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !1),
        write: (h, x)=>h.setInt16(0, x, !1)
    }), e.U8 = g(1, !1, {
        read: (h, x)=>h.getUint8(x),
        write: (h, x)=>h.setUint8(0, x)
    }), e.I8 = g(1, !0, {
        read: (h, x)=>h.getInt8(x),
        write: (h, x)=>h.setInt8(0, x)
    });
    const m = (h)=>w(4, {
            read: (x, q)=>x.getFloat32(q, h),
            write: (x, q)=>x.setFloat32(0, q, h),
            validate: (x)=>{
                if (Math.fround(x) !== x && !Number.isNaN(x)) throw new Error(`f32: wrong value=${x}`);
            }
        }), E = (h)=>w(8, {
            read: (x, q)=>x.getFloat64(q, h),
            write: (x, q)=>x.setFloat64(0, q, h)
        });
    e.F32BE = m(!1), e.F32LE = m(!0), e.F64BE = E(!1), e.F64LE = E(!0), e.bool = (0, e.wrap)({
        size: 1,
        encodeStream: (h, x)=>h.byte(x ? 1 : 0),
        decodeStream: (h)=>{
            const x = h.byte();
            if (x !== 0 && x !== 1) throw h.err(`bool: invalid value ${x}`);
            return x === 1;
        },
        validate: (h)=>{
            if (typeof h != "boolean") throw new Error(`bool: invalid value ${h}`);
            return h;
        }
    });
    const T = (h, x = !1)=>{
        if (typeof x != "boolean") throw new Error(`bytes/le: expected boolean, got ${typeof x}`);
        const q = u(h), te = n(h);
        return (0, e.wrap)({
            size: typeof h == "number" ? h : void 0,
            encodeStream: (fe, ne)=>{
                te || q.encodeStream(fe, ne.length), fe.bytes(x ? y(ne) : ne), te && fe.bytes(h);
            },
            decodeStream: (fe)=>{
                let ne;
                if (te) {
                    const W = fe.find(h);
                    if (!W) throw fe.err("bytes: cannot find terminator");
                    ne = fe.bytes(W - fe.pos), fe.bytes(h.length);
                } else ne = fe.bytes(h === null ? fe.leftBytes : q.decodeStream(fe));
                return x ? y(ne) : ne;
            },
            validate: (fe)=>{
                if (!n(fe)) throw new Error(`bytes: invalid value ${fe}`);
                return fe;
            }
        });
    };
    e.bytes = T;
    function I(h, x) {
        if (!D(x)) throw new Error(`prefix: invalid inner value ${x}`);
        return L(T(h), R(x));
    }
    const P = (h, x = !1)=>O(L(T(h, x), t.utf8), (q)=>{
            if (typeof q != "string") throw new Error(`expected string, got ${typeof q}`);
            return q;
        });
    e.string = P, e.cstring = (0, e.string)(e.NULL);
    const k = (h, x = {
        isLE: !1,
        with0x: !1
    })=>{
        let q = L(T(h, x.isLE), t.hex);
        const te = x.with0x;
        if (typeof te != "boolean") throw new Error(`hex/with0x: expected boolean, got ${typeof te}`);
        return te && (q = L(q, {
            encode: (fe)=>`0x${fe}`,
            decode: (fe)=>{
                if (!fe.startsWith("0x")) throw new Error("hex(with0x=true).encode input should start with 0x");
                return fe.slice(2);
            }
        })), q;
    };
    e.hex = k;
    function L(h, x) {
        if (!D(h)) throw new Error(`apply: invalid inner value ${h}`);
        if (!U(x)) throw new Error(`apply: invalid base value ${h}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x.decode(te);
                } catch (ne) {
                    throw q.err("" + ne);
                }
                return h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x.encode(te);
                } catch (fe) {
                    throw q.err("" + fe);
                }
            }
        });
    }
    function j(h) {
        if (typeof h != "function") throw new Error(`lazy: expected function, got ${typeof h}`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>h().encodeStream(x, q),
            decodeStream: (x)=>h().decodeStream(x)
        });
    }
    const ie = (h, x = !1)=>{
        if (!n(h)) throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof h}`);
        if (typeof x != "boolean") throw new Error(`flag/xor: expected boolean, got ${typeof x}`);
        return (0, e.wrap)({
            size: h.length,
            encodeStream: (q, te)=>{
                !!te !== x && q.bytes(h);
            },
            decodeStream: (q)=>{
                let te = q.leftBytes >= h.length;
                return te && (te = r(q.bytes(h.length, !0), h), te && q.bytes(h.length)), te !== x;
            },
            validate: (q)=>{
                if (q !== void 0 && typeof q != "boolean") throw new Error(`flag: expected boolean value or undefined, got ${typeof q}`);
                return q;
            }
        });
    };
    e.flag = ie;
    function ue(h, x, q) {
        if (!D(x)) throw new Error(`flagged: invalid inner value ${x}`);
        if (typeof h != "string" && !D(x)) throw new Error(`flagged: wrong path=${h}`);
        return (0, e.wrap)({
            encodeStream: (te, fe)=>{
                typeof h == "string" ? c.resolve(te.stack, h) ? x.encodeStream(te, fe) : q && x.encodeStream(te, q) : (h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q && x.encodeStream(te, q));
            },
            decodeStream: (te)=>{
                let fe = !1;
                if (typeof h == "string" ? fe = !!c.resolve(te.stack, h) : fe = h.decodeStream(te), fe) return x.decodeStream(te);
                q && x.decodeStream(te);
            }
        });
    }
    function ce(h, x, q) {
        if (!D(h) || !D(x)) throw new Error(`optional: invalid flag or inner value flag=${h} inner=${x}`);
        return (0, e.wrap)({
            size: q !== void 0 && h.size && x.size ? h.size + x.size : void 0,
            encodeStream: (te, fe)=>{
                h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q !== void 0 && x.encodeStream(te, q);
            },
            decodeStream: (te)=>{
                if (h.decodeStream(te)) return x.decodeStream(te);
                q !== void 0 && x.decodeStream(te);
            }
        });
    }
    function he(h, x, q = !0) {
        if (!D(h)) throw new Error(`magic: invalid inner value ${h}`);
        if (typeof q != "boolean") throw new Error(`magic: expected boolean, got ${typeof q}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                if (q && typeof fe != "object" && fe !== x || n(x) && !r(x, fe)) throw te.err(`magic: invalid value: ${fe} !== ${x}`);
            },
            validate: (te)=>{
                if (te !== void 0) throw new Error(`magic: wrong value=${typeof te}`);
                return te;
            }
        });
    }
    const ee = (h)=>{
        const x = typeof h == "string" ? t.utf8.decode(h) : h;
        return he(T(x.length), x);
    };
    e.magicBytes = ee;
    function ae(h) {
        return (0, e.wrap)({
            encodeStream: (x, q)=>{
                if (q !== h) throw new Error(`constant: invalid value ${q} (exp: ${h})`);
            },
            decodeStream: (x)=>h
        });
    }
    function ye(h) {
        let x = 0;
        for (const q of h){
            if (q.size === void 0) return;
            if (!a(q.size)) throw new Error(`sizeof: wrong element size=${x}`);
            x += q.size;
        }
        return x;
    }
    function Se(h) {
        if (!s(h)) throw new Error(`struct: expected plain object, got ${h}`);
        for(const x in h)if (!D(h[x])) throw new Error(`struct: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(Object.values(h)),
            encodeStream: (x, q)=>{
                x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = {};
                return x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>q[fe] = h[fe].decodeStream(x));
                }), q;
            },
            validate: (x)=>{
                if (typeof x != "object" || x === null) throw new Error(`struct: invalid value ${x}`);
                return x;
            }
        });
    }
    function De(h) {
        if (!Array.isArray(h)) throw new Error(`Packed.Tuple: got ${typeof h} instead of array`);
        for(let x = 0; x < h.length; x++)if (!D(h[x])) throw new Error(`tuple: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(h),
            encodeStream: (x, q)=>{
                if (!Array.isArray(q)) throw x.err(`tuple: invalid value ${q}`);
                x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = [];
                return x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>q.push(h[fe].decodeStream(x)));
                }), q;
            },
            validate: (x)=>{
                if (!Array.isArray(x)) throw new Error(`tuple: invalid value ${x}`);
                if (x.length !== h.length) throw new Error(`tuple: wrong length=${x.length}, expected ${h.length}`);
                return x;
            }
        });
    }
    function Re(h, x) {
        if (!D(x)) throw new Error(`array: invalid inner value ${x}`);
        const q = u(typeof h == "string" ? `../${h}` : h);
        return (0, e.wrap)({
            size: typeof h == "number" && x.size ? h * x.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te;
                ne.pushObj(fe, (W)=>{
                    n(h) || q.encodeStream(te, fe.length);
                    for(let J = 0; J < fe.length; J++)W(`${J}`, ()=>{
                        const V = fe[J], C = te.pos;
                        if (x.encodeStream(te, V), n(h)) {
                            if (h.length > ne.pos - C) return;
                            const Z = ne.finish(!1).subarray(C, ne.pos);
                            if (r(Z.subarray(0, h.length), h)) throw ne.err(`array: inner element encoding same as separator. elm=${V} data=${Z}`);
                        }
                    });
                }), n(h) && te.bytes(h);
            },
            decodeStream: (te)=>{
                const fe = [];
                return te.pushObj(fe, (ne)=>{
                    if (h === null) for(let W = 0; !te.isEnd() && (ne(`${W}`, ()=>fe.push(x.decodeStream(te))), !(x.size && te.leftBytes < x.size)); W++);
                    else if (n(h)) for(let W = 0;; W++){
                        if (r(te.bytes(h.length, !0), h)) {
                            te.bytes(h.length);
                            break;
                        }
                        ne(`${W}`, ()=>fe.push(x.decodeStream(te)));
                    }
                    else {
                        let W;
                        ne("arrayLen", ()=>W = q.decodeStream(te));
                        for(let J = 0; J < W; J++)ne(`${J}`, ()=>fe.push(x.decodeStream(te)));
                    }
                }), fe;
            },
            validate: (te)=>{
                if (!Array.isArray(te)) throw new Error(`array: invalid value ${te}`);
                return te;
            }
        });
    }
    function Ce(h, x) {
        if (!D(h)) throw new Error(`map: invalid inner value ${h}`);
        if (!s(x)) throw new Error("map: variants should be plain object");
        const q = /* @__PURE__ */ new Map();
        for(const te in x)q.set(x[te], te);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x[fe]),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te), ne = q.get(fe);
                if (ne === void 0) throw te.err(`Enum: unknown value: ${fe} ${Array.from(q.keys())}`);
                return ne;
            },
            validate: (te)=>{
                if (typeof te != "string") throw new Error(`map: invalid value ${te}`);
                if (!(te in x)) throw new Error(`Map: unknown variant: ${te}`);
                return te;
            }
        });
    }
    function M(h, x) {
        if (!D(h)) throw new Error(`tag: invalid tag value ${h}`);
        if (!s(x)) throw new Error("tag: variants should be plain object");
        for(const q in x)if (!D(x[q])) throw new Error(`tag: variant ${q} is not CoderType`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                const { TAG: fe, data: ne } = te, W = x[fe];
                h.encodeStream(q, fe), W.encodeStream(q, ne);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q), fe = x[te];
                if (!fe) throw q.err(`Tag: invalid tag ${te}`);
                return {
                    TAG: te,
                    data: fe.decodeStream(q)
                };
            },
            validate: (q)=>{
                const { TAG: te } = q;
                if (!x[te]) throw new Error(`Tag: invalid tag ${te.toString()}`);
                return q;
            }
        });
    }
    function z(h, x) {
        if (!D(h)) throw new Error(`mappedTag: invalid tag value ${M}`);
        if (!s(x)) throw new Error("mappedTag: variants should be plain object");
        const q = {}, te = {};
        for(const fe in x){
            const ne = x[fe];
            q[fe] = ne[0], te[fe] = ne[1];
        }
        return M(Ce(h, q), te);
    }
    function de(h, x = !1) {
        if (typeof x != "boolean") throw new Error(`bitset/pad: expected boolean, got ${typeof x}`);
        if (!Array.isArray(h)) throw new Error("bitset/names: expected array");
        for (const q of h)if (typeof q != "string") throw new Error("bitset/names: expected array of strings");
        return (0, e.wrap)({
            encodeStream: (q, te)=>{
                for(let fe = 0; fe < h.length; fe++)q.bits(+te[h[fe]], 1);
                x && h.length % 8 && q.bits(0, 8 - h.length % 8);
            },
            decodeStream: (q)=>{
                const te = {};
                for(let fe = 0; fe < h.length; fe++)te[h[fe]] = !!q.bits(1);
                return x && h.length % 8 && q.bits(8 - h.length % 8), te;
            },
            validate: (q)=>{
                if (!s(q)) throw new Error(`bitset: invalid value ${q}`);
                for (const te of Object.values(q))if (typeof te != "boolean") throw new Error("expected boolean");
                return q;
            }
        });
    }
    const _e = (h)=>0;
    e.ZeroPad = _e;
    function Ie(h, x) {
        return x % h === 0 ? 0 : h - x % h;
    }
    function je(h, x, q) {
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (!D(x)) throw new Error(`padLeft: invalid inner value ${x}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padLeft: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        if (!x.size) throw new Error("padLeft cannot have dynamic size");
        return (0, e.wrap)({
            size: x.size + Ie(h, x.size),
            encodeStream: (fe, ne)=>{
                const W = Ie(h, x.size);
                for(let J = 0; J < W; J++)fe.byte(te(J));
                x.encodeStream(fe, ne);
            },
            decodeStream: (fe)=>(fe.bytes(Ie(h, x.size)), x.decodeStream(fe))
        });
    }
    function Ke(h, x, q) {
        if (!D(x)) throw new Error(`padRight: invalid inner value ${x}`);
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padRight: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        return (0, e.wrap)({
            size: x.size ? x.size + Ie(h, x.size) : void 0,
            encodeStream: (fe, ne)=>{
                const W = fe, J = W.pos;
                x.encodeStream(fe, ne);
                const V = Ie(h, W.pos - J);
                for(let C = 0; C < V; C++)fe.byte(te(C));
            },
            decodeStream: (fe)=>{
                const ne = fe.pos, W = x.decodeStream(fe);
                return fe.bytes(Ie(h, fe.pos - ne)), W;
            }
        });
    }
    function Ue(h, x, q = !1) {
        if (!D(h)) throw new Error(`pointer: invalid ptr value ${h}`);
        if (!D(x)) throw new Error(`pointer: invalid inner value ${x}`);
        if (typeof q != "boolean") throw new Error(`pointer/sized: expected boolean, got ${typeof q}`);
        if (!h.size) throw new Error("unsized pointer");
        return (0, e.wrap)({
            size: q ? h.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te, W = ne.pos;
                h.encodeStream(te, 0), ne.ptrs.push({
                    pos: W,
                    ptr: h,
                    buffer: x.encode(fe)
                });
            },
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                return te._enablePointers(), x.decodeStream(te.offsetReader(fe));
            }
        });
    }
    e._TEST = {
        _bitset: f,
        _Reader: l,
        _Writer: p,
        Path: c
    };
})(jf);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.TEST_NETWORK = e.NETWORK = e.TAPROOT_UNSPENDABLE_KEY = e.PubT = e.tagSchnorr = e.signSchnorr = e.pubECDSA = e.pubSchnorr = e.randomPrivateKeyBytes = e.sha256x2 = e.hash160 = e.sha256 = e.isBytes = e.equalBytes = e.concatBytes = void 0, e.signECDSA = y, e.validatePubkey = A, e.tapTweak = O, e.taprootTweakPrivKey = N, e.taprootTweakPubkey = U, e.compareBytes = D;
    const t = p3, r = no, n = en;
    Object.defineProperty(e, "sha256", {
        enumerable: !0,
        get: function() {
            return n.sha256;
        }
    });
    const i = jf, o = t.secp256k1.ProjectivePoint, s = t.secp256k1.CURVE.n, a = i.utils.isBytes;
    e.isBytes = a;
    const u = i.utils.concatBytes;
    e.concatBytes = u;
    const f = i.utils.equalBytes;
    e.equalBytes = f;
    const c = (H)=>(0, r.ripemd160)((0, n.sha256)(H));
    e.hash160 = c;
    const l = (...H)=>(0, n.sha256)((0, n.sha256)(u(...H)));
    e.sha256x2 = l, e.randomPrivateKeyBytes = t.schnorr.utils.randomPrivateKey, e.pubSchnorr = t.schnorr.getPublicKey, e.pubECDSA = t.secp256k1.getPublicKey;
    const p = (H)=>H.r < s / 2n;
    function y(H, K, re = !1) {
        let Q = t.secp256k1.sign(H, K);
        if (re && !p(Q)) {
            const G = new Uint8Array(32);
            let R = 0;
            for(; !p(Q);)if (G.set(i.U32LE.encode(R++)), Q = t.secp256k1.sign(H, K, {
                extraEntropy: G
            }), R > 4294967295) throw new Error("lowR counter overflow: report the error");
        }
        return Q.toDERRawBytes();
    }
    e.signSchnorr = t.schnorr.sign, e.tagSchnorr = t.schnorr.utils.taggedHash;
    var _;
    (function(H) {
        H[H.ecdsa = 0] = "ecdsa", H[H.schnorr = 1] = "schnorr";
    })(_ || (e.PubT = _ = {}));
    function A(H, K) {
        const re = H.length;
        if (K === _.ecdsa) {
            if (re === 32) throw new Error("Expected non-Schnorr key");
            return o.fromHex(H), H;
        } else if (K === _.schnorr) {
            if (re !== 32) throw new Error("Expected 32-byte Schnorr key");
            return t.schnorr.utils.lift_x(t.schnorr.utils.bytesToNumberBE(H)), H;
        } else throw new Error("Unknown key type");
    }
    function O(H, K) {
        const re = t.schnorr.utils, Q = re.taggedHash("TapTweak", H, K), G = re.bytesToNumberBE(Q);
        if (G >= s) throw new Error("tweak higher than curve order");
        return G;
    }
    function N(H, K = Uint8Array.of()) {
        const re = t.schnorr.utils, Q = re.bytesToNumberBE(H), G = o.fromPrivateKey(Q), R = G.hasEvenY() ? Q : re.mod(-Q, s), X = re.pointToBytes(G), $ = O(X, K);
        return re.numberToBytesBE(re.mod(R + $, s), 32);
    }
    function U(H, K) {
        const re = t.schnorr.utils, Q = O(H, K), R = re.lift_x(re.bytesToNumberBE(H)).add(o.fromPrivateKey(Q)), X = R.hasEvenY() ? 0 : 1;
        return [
            re.pointToBytes(R),
            X
        ];
    }
    e.TAPROOT_UNSPENDABLE_KEY = (0, n.sha256)(o.BASE.toRawBytes(!1)), e.NETWORK = {
        bech32: "bc",
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
    }, e.TEST_NETWORK = {
        bech32: "tb",
        pubKeyHash: 111,
        scriptHash: 196,
        wif: 239
    };
    function D(H, K) {
        if (!a(H) || !a(K)) throw new Error(`cmp: wrong type a=${typeof H} b=${typeof K}`);
        const re = Math.min(H.length, K.length);
        for(let Q = 0; Q < re; Q++)if (H[Q] != K[Q]) return Math.sign(H[Q] - K[Q]);
        return Math.sign(H.length - K.length);
    }
})(wa);
var yp = {}, v0 = {}, jd = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RawOldTx = e.RawTx = e.RawOutput = e.RawInput = e.BTCArray = e.RawWitness = e.VarBytes = e.CompactSizeLen = e.CompactSize = e.Script = e.OP = e.MAX_SCRIPT_BYTE_LENGTH = void 0, e.ScriptNum = i, e.OpToNum = o;
    const t = jf, r = wa;
    e.MAX_SCRIPT_BYTE_LENGTH = 520;
    var n;
    (function(c) {
        c[c.OP_0 = 0] = "OP_0", c[c.PUSHDATA1 = 76] = "PUSHDATA1", c[c.PUSHDATA2 = 77] = "PUSHDATA2", c[c.PUSHDATA4 = 78] = "PUSHDATA4", c[c["1NEGATE"] = 79] = "1NEGATE", c[c.RESERVED = 80] = "RESERVED", c[c.OP_1 = 81] = "OP_1", c[c.OP_2 = 82] = "OP_2", c[c.OP_3 = 83] = "OP_3", c[c.OP_4 = 84] = "OP_4", c[c.OP_5 = 85] = "OP_5", c[c.OP_6 = 86] = "OP_6", c[c.OP_7 = 87] = "OP_7", c[c.OP_8 = 88] = "OP_8", c[c.OP_9 = 89] = "OP_9", c[c.OP_10 = 90] = "OP_10", c[c.OP_11 = 91] = "OP_11", c[c.OP_12 = 92] = "OP_12", c[c.OP_13 = 93] = "OP_13", c[c.OP_14 = 94] = "OP_14", c[c.OP_15 = 95] = "OP_15", c[c.OP_16 = 96] = "OP_16", c[c.NOP = 97] = "NOP", c[c.VER = 98] = "VER", c[c.IF = 99] = "IF", c[c.NOTIF = 100] = "NOTIF", c[c.VERIF = 101] = "VERIF", c[c.VERNOTIF = 102] = "VERNOTIF", c[c.ELSE = 103] = "ELSE", c[c.ENDIF = 104] = "ENDIF", c[c.VERIFY = 105] = "VERIFY", c[c.RETURN = 106] = "RETURN", c[c.TOALTSTACK = 107] = "TOALTSTACK", c[c.FROMALTSTACK = 108] = "FROMALTSTACK", c[c["2DROP"] = 109] = "2DROP", c[c["2DUP"] = 110] = "2DUP", c[c["3DUP"] = 111] = "3DUP", c[c["2OVER"] = 112] = "2OVER", c[c["2ROT"] = 113] = "2ROT", c[c["2SWAP"] = 114] = "2SWAP", c[c.IFDUP = 115] = "IFDUP", c[c.DEPTH = 116] = "DEPTH", c[c.DROP = 117] = "DROP", c[c.DUP = 118] = "DUP", c[c.NIP = 119] = "NIP", c[c.OVER = 120] = "OVER", c[c.PICK = 121] = "PICK", c[c.ROLL = 122] = "ROLL", c[c.ROT = 123] = "ROT", c[c.SWAP = 124] = "SWAP", c[c.TUCK = 125] = "TUCK", c[c.CAT = 126] = "CAT", c[c.SUBSTR = 127] = "SUBSTR", c[c.LEFT = 128] = "LEFT", c[c.RIGHT = 129] = "RIGHT", c[c.SIZE = 130] = "SIZE", c[c.INVERT = 131] = "INVERT", c[c.AND = 132] = "AND", c[c.OR = 133] = "OR", c[c.XOR = 134] = "XOR", c[c.EQUAL = 135] = "EQUAL", c[c.EQUALVERIFY = 136] = "EQUALVERIFY", c[c.RESERVED1 = 137] = "RESERVED1", c[c.RESERVED2 = 138] = "RESERVED2", c[c["1ADD"] = 139] = "1ADD", c[c["1SUB"] = 140] = "1SUB", c[c["2MUL"] = 141] = "2MUL", c[c["2DIV"] = 142] = "2DIV", c[c.NEGATE = 143] = "NEGATE", c[c.ABS = 144] = "ABS", c[c.NOT = 145] = "NOT", c[c["0NOTEQUAL"] = 146] = "0NOTEQUAL", c[c.ADD = 147] = "ADD", c[c.SUB = 148] = "SUB", c[c.MUL = 149] = "MUL", c[c.DIV = 150] = "DIV", c[c.MOD = 151] = "MOD", c[c.LSHIFT = 152] = "LSHIFT", c[c.RSHIFT = 153] = "RSHIFT", c[c.BOOLAND = 154] = "BOOLAND", c[c.BOOLOR = 155] = "BOOLOR", c[c.NUMEQUAL = 156] = "NUMEQUAL", c[c.NUMEQUALVERIFY = 157] = "NUMEQUALVERIFY", c[c.NUMNOTEQUAL = 158] = "NUMNOTEQUAL", c[c.LESSTHAN = 159] = "LESSTHAN", c[c.GREATERTHAN = 160] = "GREATERTHAN", c[c.LESSTHANOREQUAL = 161] = "LESSTHANOREQUAL", c[c.GREATERTHANOREQUAL = 162] = "GREATERTHANOREQUAL", c[c.MIN = 163] = "MIN", c[c.MAX = 164] = "MAX", c[c.WITHIN = 165] = "WITHIN", c[c.RIPEMD160 = 166] = "RIPEMD160", c[c.SHA1 = 167] = "SHA1", c[c.SHA256 = 168] = "SHA256", c[c.HASH160 = 169] = "HASH160", c[c.HASH256 = 170] = "HASH256", c[c.CODESEPARATOR = 171] = "CODESEPARATOR", c[c.CHECKSIG = 172] = "CHECKSIG", c[c.CHECKSIGVERIFY = 173] = "CHECKSIGVERIFY", c[c.CHECKMULTISIG = 174] = "CHECKMULTISIG", c[c.CHECKMULTISIGVERIFY = 175] = "CHECKMULTISIGVERIFY", c[c.NOP1 = 176] = "NOP1", c[c.CHECKLOCKTIMEVERIFY = 177] = "CHECKLOCKTIMEVERIFY", c[c.CHECKSEQUENCEVERIFY = 178] = "CHECKSEQUENCEVERIFY", c[c.NOP4 = 179] = "NOP4", c[c.NOP5 = 180] = "NOP5", c[c.NOP6 = 181] = "NOP6", c[c.NOP7 = 182] = "NOP7", c[c.NOP8 = 183] = "NOP8", c[c.NOP9 = 184] = "NOP9", c[c.NOP10 = 185] = "NOP10", c[c.CHECKSIGADD = 186] = "CHECKSIGADD", c[c.INVALID = 255] = "INVALID";
    })(n || (e.OP = n = {}));
    function i(c = 6, l = !1) {
        return t.wrap({
            encodeStream: (p, y)=>{
                if (y === 0n) return;
                const _ = y < 0, A = BigInt(y), O = [];
                for(let N = _ ? -A : A; N; N >>= 8n)O.push(Number(N & 0xffn));
                O[O.length - 1] >= 128 ? O.push(_ ? 128 : 0) : _ && (O[O.length - 1] |= 128), p.bytes(new Uint8Array(O));
            },
            decodeStream: (p)=>{
                const y = p.leftBytes;
                if (y > c) throw new Error(`ScriptNum: number (${y}) bigger than limit=${c}`);
                if (y === 0) return 0n;
                if (l) {
                    const O = p.bytes(y, !0);
                    if (!(O[O.length - 1] & 127) && (y <= 1 || !(O[O.length - 2] & 128))) throw new Error("Non-minimally encoded ScriptNum");
                }
                let _ = 0, A = 0n;
                for(let O = 0; O < y; ++O)_ = p.byte(), A |= BigInt(_) << 8n * BigInt(O);
                return _ >= 128 && (A &= 2n ** BigInt(y * 8) - 1n >> 1n, A = -A), A;
            }
        });
    }
    function o(c, l = 4, p = !0) {
        if (typeof c == "number") return c;
        if ((0, r.isBytes)(c)) try {
            const y = i(l, p).decode(c);
            return y > Number.MAX_SAFE_INTEGER ? void 0 : Number(y);
        } catch  {
            return;
        }
    }
    e.Script = t.wrap({
        encodeStream: (c, l)=>{
            for (let p of l){
                if (typeof p == "string") {
                    if (n[p] === void 0) throw new Error(`Unknown opcode=${p}`);
                    c.byte(n[p]);
                    continue;
                } else if (typeof p == "number") {
                    if (p === 0) {
                        c.byte(0);
                        continue;
                    } else if (1 <= p && p <= 16) {
                        c.byte(n.OP_1 - 1 + p);
                        continue;
                    }
                }
                if (typeof p == "number" && (p = i().encode(BigInt(p))), !(0, r.isBytes)(p)) throw new Error(`Wrong Script OP=${p} (${typeof p})`);
                const y = p.length;
                y < n.PUSHDATA1 ? c.byte(y) : y <= 255 ? (c.byte(n.PUSHDATA1), c.byte(y)) : y <= 65535 ? (c.byte(n.PUSHDATA2), c.bytes(t.U16LE.encode(y))) : (c.byte(n.PUSHDATA4), c.bytes(t.U32LE.encode(y))), c.bytes(p);
            }
        },
        decodeStream: (c)=>{
            const l = [];
            for(; !c.isEnd();){
                const p = c.byte();
                if (n.OP_0 < p && p <= n.PUSHDATA4) {
                    let y;
                    if (p < n.PUSHDATA1) y = p;
                    else if (p === n.PUSHDATA1) y = t.U8.decodeStream(c);
                    else if (p === n.PUSHDATA2) y = t.U16LE.decodeStream(c);
                    else if (p === n.PUSHDATA4) y = t.U32LE.decodeStream(c);
                    else throw new Error("Should be not possible");
                    l.push(c.bytes(y));
                } else if (p === 0) l.push(0);
                else if (n.OP_1 <= p && p <= n.OP_16) l.push(p - (n.OP_1 - 1));
                else {
                    const y = n[p];
                    if (y === void 0) throw new Error(`Unknown opcode=${p.toString(16)}`);
                    l.push(y);
                }
            }
            return l;
        }
    });
    const s = {
        253: [
            253,
            2,
            253n,
            65535n
        ],
        254: [
            254,
            4,
            65536n,
            4294967295n
        ],
        255: [
            255,
            8,
            4294967296n,
            18446744073709551615n
        ]
    };
    e.CompactSize = t.wrap({
        encodeStream: (c, l)=>{
            if (typeof l == "number" && (l = BigInt(l)), 0n <= l && l <= 252n) return c.byte(Number(l));
            for (const [p, y, _, A] of Object.values(s))if (!(_ > l || l > A)) {
                c.byte(p);
                for(let O = 0; O < y; O++)c.byte(Number(l >> 8n * BigInt(O) & 0xffn));
                return;
            }
            throw c.err(`VarInt too big: ${l}`);
        },
        decodeStream: (c)=>{
            const l = c.byte();
            if (l <= 252) return BigInt(l);
            const [p, y, _] = s[l];
            let A = 0n;
            for(let O = 0; O < y; O++)A |= BigInt(c.byte()) << 8n * BigInt(O);
            if (A < _) throw c.err(`Wrong CompactSize(${8 * y})`);
            return A;
        }
    }), e.CompactSizeLen = t.apply(e.CompactSize, t.coders.numberBigint), e.VarBytes = t.bytes(e.CompactSize), e.RawWitness = t.array(e.CompactSizeLen, e.VarBytes);
    const a = (c)=>t.array(e.CompactSize, c);
    e.BTCArray = a, e.RawInput = t.struct({
        txid: t.bytes(32, !0),
        // hash(prev_tx),
        index: t.U32LE,
        // output number of previous tx
        finalScriptSig: e.VarBytes,
        // btc merges input and output script, executes it. If ok = tx passes
        sequence: t.U32LE
    }), e.RawOutput = t.struct({
        amount: t.U64LE,
        script: e.VarBytes
    });
    const u = t.struct({
        version: t.I32LE,
        segwitFlag: t.flag(new Uint8Array([
            0,
            1
        ])),
        inputs: (0, e.BTCArray)(e.RawInput),
        outputs: (0, e.BTCArray)(e.RawOutput),
        witnesses: t.flagged("segwitFlag", t.array("inputs/length", e.RawWitness)),
        // < 500000000	Block number at which this transaction is unlocked
        // >= 500000000	UNIX timestamp at which this transaction is unlocked
        // Handled as part of PSBTv2
        lockTime: t.U32LE
    });
    function f(c) {
        if (c.segwitFlag && c.witnesses && !c.witnesses.length) throw new Error("Segwit flag with empty witnesses array");
        return c;
    }
    e.RawTx = t.validate(u, f), e.RawOldTx = t.struct({
        version: t.I32LE,
        inputs: (0, e.BTCArray)(e.RawInput),
        outputs: (0, e.BTCArray)(e.RawOutput),
        lockTime: t.U32LE
    });
})(jd);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RawPSBTV2 = e.RawPSBTV0 = e._DebugPSBT = e._RawPSBTV2 = e._RawPSBTV0 = e.PSBTOutputCoder = e.PSBTInputCoder = e.PSBTOutputUnsignedKeys = e.PSBTOutput = e.PSBTInputUnsignedKeys = e.PSBTInputFinalKeys = e.PSBTInput = e.PSBTGlobal = e.TaprootControlBlock = void 0, e.cleanPSBTFields = re, e.mergeKeyMap = G;
    const t = zd, r = jf, n = jd, i = wa, o = r.validate(r.bytes(null), (R)=>(0, i.validatePubkey)(R, i.PubT.ecdsa)), s = r.validate(r.bytes(32), (R)=>(0, i.validatePubkey)(R, i.PubT.schnorr)), a = r.validate(r.bytes(null), (R)=>{
        if (R.length !== 64 && R.length !== 65) throw new Error("Schnorr signature should be 64 or 65 bytes long");
        return R;
    }), u = r.struct({
        fingerprint: r.U32BE,
        path: r.array(null, r.U32LE)
    }), f = r.struct({
        hashes: r.array(n.CompactSizeLen, r.bytes(32)),
        der: u
    }), c = r.bytes(78), l = r.struct({
        pubKey: s,
        leafHash: r.bytes(32)
    }), p = r.struct({
        version: r.U8,
        // With parity :(
        internalKey: r.bytes(32),
        merklePath: r.array(null, r.bytes(32))
    });
    e.TaprootControlBlock = r.validate(p, (R)=>{
        if (R.merklePath.length > 128) throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");
        return R;
    });
    const y = r.array(null, r.struct({
        depth: r.U8,
        version: r.U8,
        script: n.VarBytes
    })), _ = r.bytes(null), A = r.bytes(20), O = r.bytes(32);
    e.PSBTGlobal = {
        unsignedTx: [
            0,
            !1,
            n.RawOldTx,
            [
                0
            ],
            [
                0
            ],
            !1
        ],
        xpub: [
            1,
            c,
            u,
            [],
            [
                0,
                2
            ],
            !1
        ],
        txVersion: [
            2,
            !1,
            r.U32LE,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        fallbackLocktime: [
            3,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        inputCount: [
            4,
            !1,
            n.CompactSizeLen,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        outputCount: [
            5,
            !1,
            n.CompactSizeLen,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        txModifiable: [
            6,
            !1,
            r.U8,
            [],
            [
                2
            ],
            !1
        ],
        // TODO: bitfield
        version: [
            251,
            !1,
            r.U32LE,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            _,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTInput = {
        nonWitnessUtxo: [
            0,
            !1,
            n.RawTx,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessUtxo: [
            1,
            !1,
            n.RawOutput,
            [],
            [
                0,
                2
            ],
            !1
        ],
        partialSig: [
            2,
            o,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        sighashType: [
            3,
            !1,
            r.U32LE,
            [],
            [
                0,
                2
            ],
            !1
        ],
        redeemScript: [
            4,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessScript: [
            5,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        bip32Derivation: [
            6,
            o,
            u,
            [],
            [
                0,
                2
            ],
            !1
        ],
        finalScriptSig: [
            7,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        finalScriptWitness: [
            8,
            !1,
            n.RawWitness,
            [],
            [
                0,
                2
            ],
            !1
        ],
        porCommitment: [
            9,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        ripemd160: [
            10,
            A,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        sha256: [
            11,
            O,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        hash160: [
            12,
            A,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        hash256: [
            13,
            O,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        txid: [
            14,
            !1,
            O,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        index: [
            15,
            !1,
            r.U32LE,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        sequence: [
            16,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !0
        ],
        requiredTimeLocktime: [
            17,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        requiredHeightLocktime: [
            18,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        tapKeySig: [
            19,
            !1,
            a,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapScriptSig: [
            20,
            l,
            a,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapLeafScript: [
            21,
            e.TaprootControlBlock,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapBip32Derivation: [
            22,
            O,
            f,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapInternalKey: [
            23,
            !1,
            s,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapMerkleRoot: [
            24,
            !1,
            O,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            _,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTInputFinalKeys = [
        "txid",
        "sequence",
        "index",
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknown"
    ], e.PSBTInputUnsignedKeys = [
        "partialSig",
        "finalScriptSig",
        "finalScriptWitness",
        "tapKeySig",
        "tapScriptSig"
    ], e.PSBTOutput = {
        redeemScript: [
            0,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessScript: [
            1,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        bip32Derivation: [
            2,
            o,
            u,
            [],
            [
                0,
                2
            ],
            !1
        ],
        amount: [
            3,
            !1,
            r.I64LE,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        script: [
            4,
            !1,
            _,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        tapInternalKey: [
            5,
            !1,
            s,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapTree: [
            6,
            !1,
            y,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapBip32Derivation: [
            7,
            s,
            f,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            _,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTOutputUnsignedKeys = [];
    const N = r.array(r.NULL, r.struct({
        //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)
        key: r.prefix(n.CompactSizeLen, r.struct({
            type: n.CompactSizeLen,
            key: r.bytes(null)
        })),
        //  <value> := <valuelen> <valuedata>
        value: r.bytes(n.CompactSizeLen)
    }));
    function U(R) {
        const [X, $, S, w, g, m] = R;
        return {
            type: X,
            kc: $,
            vc: S,
            reqInc: w,
            allowInc: g,
            silentIgnore: m
        };
    }
    r.struct({
        type: n.CompactSizeLen,
        key: r.bytes(null)
    });
    function D(R) {
        const X = {};
        for(const $ in R){
            const [S, w, g] = R[$];
            X[S] = [
                $,
                w,
                g
            ];
        }
        return r.wrap({
            encodeStream: ($, S)=>{
                let w = [];
                for(const g in R){
                    const m = S[g];
                    if (m === void 0) continue;
                    const [E, T, I] = R[g];
                    if (!T) w.push({
                        key: {
                            type: E,
                            key: r.EMPTY
                        },
                        value: I.encode(m)
                    });
                    else {
                        const P = m.map(([k, L])=>[
                                T.encode(k),
                                I.encode(L)
                            ]);
                        P.sort((k, L)=>(0, i.compareBytes)(k[0], L[0]));
                        for (const [k, L] of P)w.push({
                            key: {
                                key: k,
                                type: E
                            },
                            value: L
                        });
                    }
                }
                if (S.unknown) {
                    S.unknown.sort((g, m)=>(0, i.compareBytes)(g[0].key, m[0].key));
                    for (const [g, m] of S.unknown)w.push({
                        key: g,
                        value: m
                    });
                }
                N.encodeStream($, w);
            },
            decodeStream: ($)=>{
                const S = N.decodeStream($), w = {}, g = {};
                for (const m of S){
                    let E = "unknown", T = m.key.key, I = m.value;
                    if (X[m.key.type]) {
                        const [P, k, L] = X[m.key.type];
                        if (E = P, !k && T.length) throw new Error(`PSBT: Non-empty key for ${E} (key=${t.hex.encode(T)} value=${t.hex.encode(I)}`);
                        if (T = k ? k.decode(T) : void 0, I = L.decode(I), !k) {
                            if (w[E]) throw new Error(`PSBT: Same keys: ${E} (key=${T} value=${I})`);
                            w[E] = I, g[E] = !0;
                            continue;
                        }
                    } else T = {
                        type: m.key.type,
                        key: m.key.key
                    };
                    if (g[E]) throw new Error(`PSBT: Key type with empty key and no key=${E} val=${I}`);
                    w[E] || (w[E] = []), w[E].push([
                        T,
                        I
                    ]);
                }
                return w;
            }
        });
    }
    e.PSBTInputCoder = r.validate(D(e.PSBTInput), (R)=>{
        if (R.finalScriptWitness && !R.finalScriptWitness.length) throw new Error("validateInput: empty finalScriptWitness");
        if (R.partialSig && !R.partialSig.length) throw new Error("Empty partialSig");
        if (R.partialSig) for (const [X] of R.partialSig)(0, i.validatePubkey)(X, i.PubT.ecdsa);
        if (R.bip32Derivation) for (const [X] of R.bip32Derivation)(0, i.validatePubkey)(X, i.PubT.ecdsa);
        if (R.requiredTimeLocktime !== void 0 && R.requiredTimeLocktime < 5e8) throw new Error(`validateInput: wrong timeLocktime=${R.requiredTimeLocktime}`);
        if (R.requiredHeightLocktime !== void 0 && (R.requiredHeightLocktime <= 0 || R.requiredHeightLocktime >= 5e8)) throw new Error(`validateInput: wrong heighLocktime=${R.requiredHeightLocktime}`);
        if (R.tapLeafScript) for (const [X, $] of R.tapLeafScript){
            if ((X.version & 254) !== $[$.length - 1]) throw new Error("validateInput: tapLeafScript version mimatch");
            if ($[$.length - 1] & 1) throw new Error("validateInput: tapLeafScript version has parity bit!");
        }
        return R;
    }), e.PSBTOutputCoder = r.validate(D(e.PSBTOutput), (R)=>{
        if (R.bip32Derivation) for (const [X] of R.bip32Derivation)(0, i.validatePubkey)(X, i.PubT.ecdsa);
        return R;
    });
    const H = r.validate(D(e.PSBTGlobal), (R)=>{
        if ((R.version || 0) === 0) {
            if (!R.unsignedTx) throw new Error("PSBTv0: missing unsignedTx");
            for (const $ of R.unsignedTx.inputs)if ($.finalScriptSig && $.finalScriptSig.length) throw new Error("PSBTv0: input scriptSig found in unsignedTx");
        }
        return R;
    });
    e._RawPSBTV0 = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        global: H,
        inputs: r.array("global/unsignedTx/inputs/length", e.PSBTInputCoder),
        outputs: r.array(null, e.PSBTOutputCoder)
    }), e._RawPSBTV2 = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        global: H,
        inputs: r.array("global/inputCount", e.PSBTInputCoder),
        outputs: r.array("global/outputCount", e.PSBTOutputCoder)
    }), e._DebugPSBT = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        items: r.array(null, r.apply(r.array(r.NULL, r.tuple([
            r.hex(n.CompactSizeLen),
            r.bytes(n.CompactSize)
        ])), r.coders.dict()))
    });
    function K(R, X, $) {
        for(const S in $){
            if (S === "unknown" || !X[S]) continue;
            const { allowInc: w } = U(X[S]);
            if (!w.includes(R)) throw new Error(`PSBTv${R}: field ${S} is not allowed`);
        }
        for(const S in X){
            const { reqInc: w } = U(X[S]);
            if (w.includes(R) && $[S] === void 0) throw new Error(`PSBTv${R}: missing required field ${S}`);
        }
    }
    function re(R, X, $) {
        const S = {};
        for(const w in $){
            const g = w;
            if (g !== "unknown") {
                if (!X[g]) continue;
                const { allowInc: m, silentIgnore: E } = U(X[g]);
                if (!m.includes(R)) {
                    if (E) continue;
                    throw new Error(`Failed to serialize in PSBTv${R}: ${g} but versions allows inclusion=${m}`);
                }
            }
            S[g] = $[g];
        }
        return S;
    }
    function Q(R) {
        const X = R && R.global && R.global.version || 0;
        K(X, e.PSBTGlobal, R.global);
        for (const m of R.inputs)K(X, e.PSBTInput, m);
        for (const m of R.outputs)K(X, e.PSBTOutput, m);
        const $ = X ? R.global.inputCount : R.global.unsignedTx.inputs.length;
        if (R.inputs.length < $) throw new Error("Not enough inputs");
        const S = R.inputs.slice($);
        if (S.length > 1 || S.length && Object.keys(S[0]).length) throw new Error(`Unexpected inputs left in tx=${S}`);
        const w = X ? R.global.outputCount : R.global.unsignedTx.outputs.length;
        if (R.outputs.length < w) throw new Error("Not outputs inputs");
        const g = R.outputs.slice(w);
        if (g.length > 1 || g.length && Object.keys(g[0]).length) throw new Error(`Unexpected outputs left in tx=${g}`);
        return R;
    }
    function G(R, X, $, S, w) {
        const g = {
            ...$,
            ...X
        };
        for(const m in R){
            const E = m, [T, I, P] = R[E], k = S && !S.includes(m);
            if (X[m] === void 0 && m in X) {
                if (k) throw new Error(`Cannot remove signed field=${m}`);
                delete g[m];
            } else if (I) {
                const L = $ && $[m] ? $[m] : [];
                let j = X[E];
                if (j) {
                    if (!Array.isArray(j)) throw new Error(`keyMap(${m}): KV pairs should be [k, v][]`);
                    j = j.map((ce)=>{
                        if (ce.length !== 2) throw new Error(`keyMap(${m}): KV pairs should be [k, v][]`);
                        return [
                            typeof ce[0] == "string" ? I.decode(t.hex.decode(ce[0])) : ce[0],
                            typeof ce[1] == "string" ? P.decode(t.hex.decode(ce[1])) : ce[1]
                        ];
                    });
                    const ie = {}, ue = (ce, he, ee)=>{
                        if (ie[ce] === void 0) {
                            ie[ce] = [
                                he,
                                ee
                            ];
                            return;
                        }
                        const ae = t.hex.encode(P.encode(ie[ce][1])), ye = t.hex.encode(P.encode(ee));
                        if (ae !== ye) throw new Error(`keyMap(${E}): same key=${ce} oldVal=${ae} newVal=${ye}`);
                    };
                    for (const [ce, he] of L){
                        const ee = t.hex.encode(I.encode(ce));
                        ue(ee, ce, he);
                    }
                    for (const [ce, he] of j){
                        const ee = t.hex.encode(I.encode(ce));
                        if (he === void 0) {
                            if (k) throw new Error(`Cannot remove signed field=${E}/${ce}`);
                            delete ie[ee];
                        } else ue(ee, ce, he);
                    }
                    g[E] = Object.values(ie);
                }
            } else if (typeof g[m] == "string") g[m] = P.decode(t.hex.decode(g[m]));
            else if (k && m in X && $ && $[m] !== void 0 && !(0, i.equalBytes)(P.encode(X[m]), P.encode($[m]))) throw new Error(`Cannot change signed field=${m}`);
        }
        for(const m in g)if (!R[m]) {
            if (w && m === "unknown") continue;
            delete g[m];
        }
        return g;
    }
    e.RawPSBTV0 = r.validate(e._RawPSBTV0, Q), e.RawPSBTV2 = r.validate(e._RawPSBTV2, Q);
})(v0);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._sortPubkeys = e.p2tr_pk = e.p2tr_ns = e.tapLeafHash = e.TAP_LEAF_VERSION = e.p2ms = e.p2wpkh = e.p2wsh = e.p2sh = e.p2pkh = e.p2pk = e.OutScript = void 0, e.checkScript = re, e.taprootListToTree = m, e.p2tr = k, e.combinations = L, e.p2tr_ms = ue, e.getAddress = ce, e.multisig = ee, e.sortedMultisig = ae, e.WIF = Ce, e.Address = M;
    const t = zd, r = jf, n = v0, i = jd, o = wa, s = wa, a = {
        encode (z) {
            if (!(z.length !== 2 || z[0] !== 1 || !o.isBytes(z[1]) || t.hex.encode(z[1]) !== "4e73")) return {
                type: "p2a",
                script: i.Script.encode(z)
            };
        },
        decode: (z)=>{
            if (z.type === "p2a") return [
                1,
                t.hex.decode("4e73")
            ];
        }
    };
    function u(z, de) {
        try {
            return o.validatePubkey(z, de), !0;
        } catch  {
            return !1;
        }
    }
    const D = [
        a,
        {
            encode (z) {
                if (!(z.length !== 2 || !o.isBytes(z[0]) || !u(z[0], o.PubT.ecdsa) || z[1] !== "CHECKSIG")) return {
                    type: "pk",
                    pubkey: z[0]
                };
            },
            decode: (z)=>z.type === "pk" ? [
                    z.pubkey,
                    "CHECKSIG"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 5 || z[0] !== "DUP" || z[1] !== "HASH160" || !o.isBytes(z[2])) && !(z[3] !== "EQUALVERIFY" || z[4] !== "CHECKSIG")) return {
                    type: "pkh",
                    hash: z[2]
                };
            },
            decode: (z)=>z.type === "pkh" ? [
                    "DUP",
                    "HASH160",
                    z.hash,
                    "EQUALVERIFY",
                    "CHECKSIG"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 3 || z[0] !== "HASH160" || !o.isBytes(z[1]) || z[2] !== "EQUAL")) return {
                    type: "sh",
                    hash: z[1]
                };
            },
            decode: (z)=>z.type === "sh" ? [
                    "HASH160",
                    z.hash,
                    "EQUAL"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 2 || z[0] !== 0 || !o.isBytes(z[1])) && z[1].length === 32) return {
                    type: "wsh",
                    hash: z[1]
                };
            },
            decode: (z)=>z.type === "wsh" ? [
                    0,
                    z.hash
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 2 || z[0] !== 0 || !o.isBytes(z[1])) && z[1].length === 20) return {
                    type: "wpkh",
                    hash: z[1]
                };
            },
            decode: (z)=>z.type === "wpkh" ? [
                    0,
                    z.hash
                ] : void 0
        },
        {
            encode (z) {
                const de = z.length - 1;
                if (z[de] !== "CHECKMULTISIG") return;
                const _e = z[0], Ie = z[de - 1];
                if (typeof _e != "number" || typeof Ie != "number") return;
                const je = z.slice(1, -2);
                if (Ie === je.length) {
                    for (const Ke of je)if (!o.isBytes(Ke)) return;
                    return {
                        type: "ms",
                        m: _e,
                        pubkeys: je
                    };
                }
            },
            // checkmultisig(n, ..pubkeys, m)
            decode: (z)=>z.type === "ms" ? [
                    z.m,
                    ...z.pubkeys,
                    z.pubkeys.length,
                    "CHECKMULTISIG"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 2 || z[0] !== 1 || !o.isBytes(z[1]))) return {
                    type: "tr",
                    pubkey: z[1]
                };
            },
            decode: (z)=>z.type === "tr" ? [
                    1,
                    z.pubkey
                ] : void 0
        },
        {
            encode (z) {
                const de = z.length - 1;
                if (z[de] !== "CHECKSIG") return;
                const _e = [];
                for(let Ie = 0; Ie < de; Ie++){
                    const je = z[Ie];
                    if (Ie & 1) {
                        if (je !== "CHECKSIGVERIFY" || Ie === de - 1) return;
                        continue;
                    }
                    if (!o.isBytes(je)) return;
                    _e.push(je);
                }
                return {
                    type: "tr_ns",
                    pubkeys: _e
                };
            },
            decode: (z)=>{
                if (z.type !== "tr_ns") return;
                const de = [];
                for(let _e = 0; _e < z.pubkeys.length - 1; _e++)de.push(z.pubkeys[_e], "CHECKSIGVERIFY");
                return de.push(z.pubkeys[z.pubkeys.length - 1], "CHECKSIG"), de;
            }
        },
        {
            encode (z) {
                const de = z.length - 1;
                if (z[de] !== "NUMEQUAL" || z[1] !== "CHECKSIG") return;
                const _e = [], Ie = (0, i.OpToNum)(z[de - 1]);
                if (typeof Ie == "number") {
                    for(let je = 0; je < de - 1; je++){
                        const Ke = z[je];
                        if (je & 1) {
                            if (Ke !== (je === 1 ? "CHECKSIG" : "CHECKSIGADD")) throw new Error("OutScript.encode/tr_ms: wrong element");
                            continue;
                        }
                        if (!o.isBytes(Ke)) throw new Error("OutScript.encode/tr_ms: wrong key element");
                        _e.push(Ke);
                    }
                    return {
                        type: "tr_ms",
                        pubkeys: _e,
                        m: Ie
                    };
                }
            },
            decode: (z)=>{
                if (z.type !== "tr_ms") return;
                const de = [
                    z.pubkeys[0],
                    "CHECKSIG"
                ];
                for(let _e = 1; _e < z.pubkeys.length; _e++)de.push(z.pubkeys[_e], "CHECKSIGADD");
                return de.push(z.m, "NUMEQUAL"), de;
            }
        },
        {
            encode (z) {
                return {
                    type: "unknown",
                    script: i.Script.encode(z)
                };
            },
            decode: (z)=>z.type === "unknown" ? i.Script.decode(z.script) : void 0
        }
    ], H = r.apply(i.Script, r.coders.match(D));
    e.OutScript = r.validate(H, (z)=>{
        if (z.type === "pk" && !u(z.pubkey, o.PubT.ecdsa)) throw new Error("OutScript/pk: wrong key");
        if ((z.type === "pkh" || z.type === "sh" || z.type === "wpkh") && (!o.isBytes(z.hash) || z.hash.length !== 20)) throw new Error(`OutScript/${z.type}: wrong hash`);
        if (z.type === "wsh" && (!o.isBytes(z.hash) || z.hash.length !== 32)) throw new Error("OutScript/wsh: wrong hash");
        if (z.type === "tr" && (!o.isBytes(z.pubkey) || !u(z.pubkey, o.PubT.schnorr))) throw new Error("OutScript/tr: wrong taproot public key");
        if ((z.type === "ms" || z.type === "tr_ns" || z.type === "tr_ms") && !Array.isArray(z.pubkeys)) throw new Error("OutScript/multisig: wrong pubkeys array");
        if (z.type === "ms") {
            const de = z.pubkeys.length;
            for (const _e of z.pubkeys)if (!u(_e, o.PubT.ecdsa)) throw new Error("OutScript/multisig: wrong pubkey");
            if (z.m <= 0 || de > 16 || z.m > de) throw new Error("OutScript/multisig: invalid params");
        }
        if (z.type === "tr_ns" || z.type === "tr_ms") {
            for (const de of z.pubkeys)if (!u(de, o.PubT.schnorr)) throw new Error(`OutScript/${z.type}: wrong pubkey`);
        }
        if (z.type === "tr_ms") {
            const de = z.pubkeys.length;
            if (z.m <= 0 || de > 999 || z.m > de) throw new Error("OutScript/tr_ms: invalid params");
        }
        return z;
    });
    function K(z, de) {
        if (!o.equalBytes(z.hash, o.sha256(de))) throw new Error("checkScript: wsh wrong witnessScript hash");
        const _e = e.OutScript.decode(de);
        if (_e.type === "tr" || _e.type === "tr_ns" || _e.type === "tr_ms") throw new Error(`checkScript: P2${_e.type} cannot be wrapped in P2SH`);
        if (_e.type === "wpkh" || _e.type === "sh") throw new Error(`checkScript: P2${_e.type} cannot be wrapped in P2WSH`);
    }
    function re(z, de, _e) {
        if (z) {
            const Ie = e.OutScript.decode(z);
            if (Ie.type === "tr_ns" || Ie.type === "tr_ms" || Ie.type === "ms" || Ie.type == "pk") throw new Error(`checkScript: non-wrapped ${Ie.type}`);
            if (Ie.type === "sh" && de) {
                if (!o.equalBytes(Ie.hash, o.hash160(de))) throw new Error("checkScript: sh wrong redeemScript hash");
                const je = e.OutScript.decode(de);
                if (je.type === "tr" || je.type === "tr_ns" || je.type === "tr_ms") throw new Error(`checkScript: P2${je.type} cannot be wrapped in P2SH`);
                if (je.type === "sh") throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
            }
            Ie.type === "wsh" && _e && K(Ie, _e);
        }
        if (de) {
            const Ie = e.OutScript.decode(de);
            Ie.type === "wsh" && _e && K(Ie, _e);
        }
    }
    function Q(z) {
        const de = {};
        for (const _e of z){
            const Ie = t.hex.encode(_e);
            if (de[Ie]) throw new Error(`Multisig: non-uniq pubkey: ${z.map(t.hex.encode)}`);
            de[Ie] = !0;
        }
    }
    const G = (z, de = s.NETWORK)=>{
        if (!u(z, o.PubT.ecdsa)) throw new Error("P2PK: invalid publicKey");
        return {
            type: "pk",
            script: e.OutScript.encode({
                type: "pk",
                pubkey: z
            })
        };
    };
    e.p2pk = G;
    const R = (z, de = s.NETWORK)=>{
        if (!u(z, o.PubT.ecdsa)) throw new Error("P2PKH: invalid publicKey");
        const _e = o.hash160(z);
        return {
            type: "pkh",
            script: e.OutScript.encode({
                type: "pkh",
                hash: _e
            }),
            address: M(de).encode({
                type: "pkh",
                hash: _e
            }),
            hash: _e
        };
    };
    e.p2pkh = R;
    const X = (z, de = s.NETWORK)=>{
        const _e = z.script;
        if (!o.isBytes(_e)) throw new Error(`Wrong script: ${typeof z.script}, expected Uint8Array`);
        const Ie = o.hash160(_e), je = e.OutScript.encode({
            type: "sh",
            hash: Ie
        });
        return re(je, _e, z.witnessScript), z.witnessScript ? {
            type: "sh",
            redeemScript: _e,
            script: e.OutScript.encode({
                type: "sh",
                hash: Ie
            }),
            address: M(de).encode({
                type: "sh",
                hash: Ie
            }),
            hash: Ie,
            witnessScript: z.witnessScript
        } : {
            type: "sh",
            redeemScript: _e,
            script: e.OutScript.encode({
                type: "sh",
                hash: Ie
            }),
            address: M(de).encode({
                type: "sh",
                hash: Ie
            }),
            hash: Ie
        };
    };
    e.p2sh = X;
    const $ = (z, de = s.NETWORK)=>{
        const _e = z.script;
        if (!o.isBytes(_e)) throw new Error(`Wrong script: ${typeof _e}, expected Uint8Array`);
        const Ie = o.sha256(_e), je = e.OutScript.encode({
            type: "wsh",
            hash: Ie
        });
        return re(je, void 0, _e), {
            type: "wsh",
            witnessScript: _e,
            script: e.OutScript.encode({
                type: "wsh",
                hash: Ie
            }),
            address: M(de).encode({
                type: "wsh",
                hash: Ie
            }),
            hash: Ie
        };
    };
    e.p2wsh = $;
    const S = (z, de = s.NETWORK)=>{
        if (!u(z, o.PubT.ecdsa)) throw new Error("P2WPKH: invalid publicKey");
        if (z.length === 65) throw new Error("P2WPKH: uncompressed public key");
        const _e = o.hash160(z);
        return {
            type: "wpkh",
            script: e.OutScript.encode({
                type: "wpkh",
                hash: _e
            }),
            address: M(de).encode({
                type: "wpkh",
                hash: _e
            }),
            hash: _e
        };
    };
    e.p2wpkh = S;
    const w = (z, de, _e = !1)=>(_e || Q(de), {
            type: "ms",
            script: e.OutScript.encode({
                type: "ms",
                pubkeys: de,
                m: z
            })
        });
    e.p2ms = w;
    function g(z, de, _e = !1, Ie) {
        const je = e.OutScript.decode(z);
        if (je.type === "unknown") {
            if (Ie) {
                const h = r.apply(i.Script, r.coders.match(Ie)).decode(z);
                if (h !== void 0) {
                    if (typeof h.type != "string" || !h.type.startsWith("tr_")) throw new Error(`P2TR: invalid custom type=${h.type}`);
                    return;
                }
            }
            if (_e) return;
        }
        if (![
            "tr_ns",
            "tr_ms"
        ].includes(je.type)) throw new Error(`P2TR: invalid leaf script=${je.type}`);
        const Ke = je;
        if (!_e && Ke.pubkeys) for (const Ue of Ke.pubkeys){
            if (o.equalBytes(Ue, o.TAPROOT_UNSPENDABLE_KEY)) throw new Error("Unspendable taproot key in leaf script");
            if (o.equalBytes(Ue, de)) throw new Error("Using P2TR with leaf script with same key as internal key is not supported");
        }
    }
    function m(z) {
        const de = Array.from(z);
        for(; de.length >= 2;){
            de.sort((Ue, h)=>(h.weight || 1) - (Ue.weight || 1));
            const Ie = de.pop(), je = de.pop(), Ke = ((je == null ? void 0 : je.weight) || 1) + ((Ie == null ? void 0 : Ie.weight) || 1);
            de.push({
                weight: Ke,
                // Unwrap children array
                // TODO: Very hard to remove any here
                childs: [
                    (je == null ? void 0 : je.childs) || je,
                    (Ie == null ? void 0 : Ie.childs) || Ie
                ]
            });
        }
        const _e = de[0];
        return (_e == null ? void 0 : _e.childs) || _e;
    }
    function E(z, de = []) {
        if (!z) throw new Error("taprootAddPath: empty tree");
        if (z.type === "leaf") return {
            ...z,
            path: de
        };
        if (z.type !== "branch") throw new Error(`taprootAddPath: wrong type=${z}`);
        return {
            ...z,
            path: de,
            // Left element has right hash in path and otherwise
            left: E(z.left, [
                z.right.hash,
                ...de
            ]),
            right: E(z.right, [
                z.left.hash,
                ...de
            ])
        };
    }
    function T(z) {
        if (!z) throw new Error("taprootAddPath: empty tree");
        if (z.type === "leaf") return [
            z
        ];
        if (z.type !== "branch") throw new Error(`taprootWalkTree: wrong type=${z}`);
        return [
            ...T(z.left),
            ...T(z.right)
        ];
    }
    function I(z, de, _e = !1, Ie) {
        if (!z) throw new Error("taprootHashTree: empty tree");
        if (Array.isArray(z) && z.length === 1 && (z = z[0]), !Array.isArray(z)) {
            const { leafVersion: x, script: q } = z;
            if (z.tapLeafScript || z.tapMerkleRoot && !o.equalBytes(z.tapMerkleRoot, r.EMPTY)) throw new Error("P2TR: tapRoot leafScript cannot have tree");
            const te = typeof q == "string" ? t.hex.decode(q) : q;
            if (!o.isBytes(te)) throw new Error(`checkScript: wrong script type=${te}`);
            return g(te, de, _e, Ie), {
                type: "leaf",
                version: x,
                script: te,
                hash: (0, e.tapLeafHash)(te, x)
            };
        }
        if (z.length !== 2 && (z = m(z)), z.length !== 2) throw new Error("hashTree: non binary tree!");
        const je = I(z[0], de, _e, Ie), Ke = I(z[1], de, _e, Ie);
        let [Ue, h] = [
            je.hash,
            Ke.hash
        ];
        return o.compareBytes(h, Ue) === -1 && ([Ue, h] = [
            h,
            Ue
        ]), {
            type: "branch",
            left: je,
            right: Ke,
            hash: o.tagSchnorr("TapBranch", Ue, h)
        };
    }
    e.TAP_LEAF_VERSION = 192;
    const P = (z, de = e.TAP_LEAF_VERSION)=>o.tagSchnorr("TapLeaf", new Uint8Array([
            de
        ]), i.VarBytes.encode(z));
    e.tapLeafHash = P;
    function k(z, de, _e = s.NETWORK, Ie = !1, je) {
        if (!z && !de) throw new Error("p2tr: should have pubKey or scriptTree (or both)");
        const Ke = typeof z == "string" ? t.hex.decode(z) : z || o.TAPROOT_UNSPENDABLE_KEY;
        if (!u(Ke, o.PubT.schnorr)) throw new Error("p2tr: non-schnorr pubkey");
        if (de) {
            let Ue = E(I(de, Ke, Ie, je));
            const h = Ue.hash, [x, q] = o.taprootTweakPubkey(Ke, h), te = T(Ue).map((fe)=>({
                    ...fe,
                    controlBlock: n.TaprootControlBlock.encode({
                        version: (fe.version || e.TAP_LEAF_VERSION) + q,
                        internalKey: Ke,
                        merklePath: fe.path
                    })
                }));
            return {
                type: "tr",
                script: e.OutScript.encode({
                    type: "tr",
                    pubkey: x
                }),
                address: M(_e).encode({
                    type: "tr",
                    pubkey: x
                }),
                // For tests
                tweakedPubkey: x,
                // PSBT stuff
                tapInternalKey: Ke,
                leaves: te,
                tapLeafScript: te.map((fe)=>[
                        n.TaprootControlBlock.decode(fe.controlBlock),
                        o.concatBytes(fe.script, new Uint8Array([
                            fe.version || e.TAP_LEAF_VERSION
                        ]))
                    ]),
                tapMerkleRoot: h
            };
        } else {
            const Ue = o.taprootTweakPubkey(Ke, r.EMPTY)[0];
            return {
                type: "tr",
                script: e.OutScript.encode({
                    type: "tr",
                    pubkey: Ue
                }),
                address: M(_e).encode({
                    type: "tr",
                    pubkey: Ue
                }),
                // For tests
                tweakedPubkey: Ue,
                // PSBT stuff
                tapInternalKey: Ke
            };
        }
    }
    function L(z, de) {
        const _e = [];
        if (!Array.isArray(de)) throw new Error("combinations: lst arg should be array");
        const Ie = de.length;
        if (z > Ie) throw new Error("combinations: m > lst.length, no combinations possible");
        const je = Array.from({
            length: z
        }, (Ue, h)=>h), Ke = je.length - 1;
        e: for(;;){
            _e.push(je.map((h)=>de[h])), je[Ke] += 1;
            let Ue = Ke;
            for(; Ue >= 0 && je[Ue] > Ie - z + Ue; Ue--){
                if (je[Ue] = 0, Ue === 0) break e;
                je[Ue - 1] += 1;
            }
            for(Ue += 1; Ue < je.length; Ue++)je[Ue] = je[Ue - 1] + 1;
        }
        return _e;
    }
    const j = (z, de, _e = !1)=>(_e || Q(de), L(z, de).map((Ie)=>({
                type: "tr_ns",
                script: e.OutScript.encode({
                    type: "tr_ns",
                    pubkeys: Ie
                })
            })));
    e.p2tr_ns = j;
    const ie = (z)=>(0, e.p2tr_ns)(1, [
            z
        ], void 0)[0];
    e.p2tr_pk = ie;
    function ue(z, de, _e = !1) {
        return _e || Q(de), {
            type: "tr_ms",
            script: e.OutScript.encode({
                type: "tr_ms",
                pubkeys: de,
                m: z
            })
        };
    }
    function ce(z, de, _e = s.NETWORK) {
        if (z === "tr") return k(o.pubSchnorr(de), void 0, _e).address;
        const Ie = o.pubECDSA(de);
        if (z === "pkh") return (0, e.p2pkh)(Ie, _e).address;
        if (z === "wpkh") return (0, e.p2wpkh)(Ie, _e).address;
        throw new Error(`getAddress: unknown type=${z}`);
    }
    const he = (z)=>Array.from(z).sort(o.compareBytes);
    e._sortPubkeys = he;
    function ee(z, de, _e = !1, Ie = !1, je = s.NETWORK) {
        const Ke = (0, e.p2ms)(z, _e ? (0, e._sortPubkeys)(de) : de);
        return Ie ? (0, e.p2wsh)(Ke, je) : (0, e.p2sh)(Ke, je);
    }
    function ae(z, de, _e = !1, Ie = s.NETWORK) {
        return ee(z, de, !0, _e, Ie);
    }
    const ye = (0, t.createBase58check)(o.sha256);
    function Se(z, de) {
        if (de.length < 2 || de.length > 40) throw new Error("Witness: invalid length");
        if (z > 16) throw new Error("Witness: invalid version");
        if (z === 0 && !(de.length === 20 || de.length === 32)) throw new Error("Witness: invalid length for version");
    }
    function De(z, de, _e = s.NETWORK) {
        Se(z, de);
        const Ie = z === 0 ? t.bech32 : t.bech32m;
        return Ie.encode(_e.bech32, [
            z
        ].concat(Ie.toWords(de)));
    }
    function Re(z, de) {
        return ye.encode(o.concatBytes(Uint8Array.from(de), z));
    }
    function Ce(z = s.NETWORK) {
        return {
            encode (de) {
                const _e = o.concatBytes(de, new Uint8Array([
                    1
                ]));
                return Re(_e.subarray(0, 33), [
                    z.wif
                ]);
            },
            decode (de) {
                let _e = ye.decode(de);
                if (_e[0] !== z.wif) throw new Error("Wrong WIF prefix");
                if (_e = _e.subarray(1), _e.length !== 33) throw new Error("Wrong WIF length");
                if (_e[32] !== 1) throw new Error("Wrong WIF postfix");
                return _e.subarray(0, -1);
            }
        };
    }
    function M(z = s.NETWORK) {
        return {
            encode (de) {
                const { type: _e } = de;
                if (_e === "wpkh") return De(0, de.hash, z);
                if (_e === "wsh") return De(0, de.hash, z);
                if (_e === "tr") return De(1, de.pubkey, z);
                if (_e === "pkh") return Re(de.hash, [
                    z.pubKeyHash
                ]);
                if (_e === "sh") return Re(de.hash, [
                    z.scriptHash
                ]);
                throw new Error(`Unknown address type=${_e}`);
            },
            decode (de) {
                if (de.length < 14 || de.length > 74) throw new Error("Invalid address length");
                if (z.bech32 && de.toLowerCase().startsWith(`${z.bech32}1`)) {
                    let Ie;
                    try {
                        if (Ie = t.bech32.decode(de), Ie.words[0] !== 0) throw new Error(`bech32: wrong version=${Ie.words[0]}`);
                    } catch  {
                        if (Ie = t.bech32m.decode(de), Ie.words[0] === 0) throw new Error(`bech32m: wrong version=${Ie.words[0]}`);
                    }
                    if (Ie.prefix !== z.bech32) throw new Error(`wrong bech32 prefix=${Ie.prefix}`);
                    const [je, ...Ke] = Ie.words, Ue = t.bech32.fromWords(Ke);
                    if (Se(je, Ue), je === 0 && Ue.length === 32) return {
                        type: "wsh",
                        hash: Ue
                    };
                    if (je === 0 && Ue.length === 20) return {
                        type: "wpkh",
                        hash: Ue
                    };
                    if (je === 1 && Ue.length === 32) return {
                        type: "tr",
                        pubkey: Ue
                    };
                    throw new Error("Unknown witness program");
                }
                const _e = ye.decode(de);
                if (_e.length !== 21) throw new Error("Invalid base58 address");
                if (_e[0] === z.pubKeyHash) return {
                    type: "pkh",
                    hash: _e.slice(1)
                };
                if (_e[0] === z.scriptHash) return {
                    type: "sh",
                    hash: _e.slice(1)
                };
                throw new Error(`Invalid address prefix=${_e[0]}`);
            }
        };
    }
})(yp);
var Em = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Transaction = e.SigHash = e.SignatureHash = e.def = e.Decimal = e.DEFAULT_SEQUENCE = e.DEFAULT_LOCKTIME = e.DEFAULT_VERSION = e.PRECISION = e.toVsize = void 0, e.cloneDeep = p, e.inputBeforeSign = N, e.getPrevOut = G, e.normalizeInput = R, e.getInputType = X, e.PSBTCombine = S, e.bip32Path = g;
    const t = zd, r = jf, n = yp, i = v0, o = jd, s = wa, a = wa, u = new Uint8Array(32), f = {
        amount: 0xffffffffffffffffn,
        script: r.EMPTY
    }, c = (m)=>Math.ceil(m / 4);
    e.toVsize = c, e.PRECISION = 8, e.DEFAULT_VERSION = 2, e.DEFAULT_LOCKTIME = 0, e.DEFAULT_SEQUENCE = 4294967295, e.Decimal = r.coders.decimal(e.PRECISION);
    const l = (m, E)=>m === void 0 ? E : m;
    e.def = l;
    function p(m) {
        if (Array.isArray(m)) return m.map((E)=>p(E));
        if ((0, a.isBytes)(m)) return Uint8Array.from(m);
        if ([
            "number",
            "bigint",
            "boolean",
            "string",
            "undefined"
        ].includes(typeof m)) return m;
        if (m === null) return m;
        if (typeof m == "object") return Object.fromEntries(Object.entries(m).map(([E, T])=>[
                E,
                p(T)
            ]));
        throw new Error(`cloneDeep: unknown type=${m} (${typeof m})`);
    }
    var y;
    (function(m) {
        m[m.DEFAULT = 0] = "DEFAULT", m[m.ALL = 1] = "ALL", m[m.NONE = 2] = "NONE", m[m.SINGLE = 3] = "SINGLE", m[m.ANYONECANPAY = 128] = "ANYONECANPAY";
    })(y || (e.SignatureHash = y = {}));
    var _;
    (function(m) {
        m[m.DEFAULT = 0] = "DEFAULT", m[m.ALL = 1] = "ALL", m[m.NONE = 2] = "NONE", m[m.SINGLE = 3] = "SINGLE", m[m.DEFAULT_ANYONECANPAY = 128] = "DEFAULT_ANYONECANPAY", m[m.ALL_ANYONECANPAY = 129] = "ALL_ANYONECANPAY", m[m.NONE_ANYONECANPAY = 130] = "NONE_ANYONECANPAY", m[m.SINGLE_ANYONECANPAY = 131] = "SINGLE_ANYONECANPAY";
    })(_ || (e.SigHash = _ = {}));
    function A(m, E, T, I = r.EMPTY) {
        return (0, a.equalBytes)(T, E) && (m = s.taprootTweakPrivKey(m, I), E = s.pubSchnorr(m)), {
            privKey: m,
            pubKey: E
        };
    }
    function O(m) {
        if (m.script === void 0 || m.amount === void 0) throw new Error("Transaction/output: script and amount required");
        return {
            script: m.script,
            amount: m.amount
        };
    }
    function N(m) {
        if (m.txid === void 0 || m.index === void 0) throw new Error("Transaction/input: txid and index required");
        return {
            txid: m.txid,
            index: m.index,
            sequence: (0, e.def)(m.sequence, e.DEFAULT_SEQUENCE),
            finalScriptSig: (0, e.def)(m.finalScriptSig, r.EMPTY)
        };
    }
    function U(m) {
        for(const E in m){
            const T = E;
            i.PSBTInputFinalKeys.includes(T) || delete m[T];
        }
    }
    const D = r.struct({
        txid: r.bytes(32, !0),
        index: r.U32LE
    });
    function H(m) {
        if (typeof m != "number" || typeof _[m] != "string") throw new Error(`Invalid SigHash=${m}`);
        return m;
    }
    function K(m) {
        const E = m & 31;
        return {
            isAny: !!(m & y.ANYONECANPAY),
            isNone: E === y.NONE,
            isSingle: E === y.SINGLE
        };
    }
    function re(m) {
        if (m !== void 0 && ({}).toString.call(m) !== "[object Object]") throw new Error(`Wrong object type for transaction options: ${m}`);
        const E = {
            ...m,
            // Defaults
            version: (0, e.def)(m.version, e.DEFAULT_VERSION),
            lockTime: (0, e.def)(m.lockTime, 0),
            PSBTVersion: (0, e.def)(m.PSBTVersion, 0)
        };
        if (typeof E.allowUnknowInput < "u" && (m.allowUnknownInputs = E.allowUnknowInput), typeof E.allowUnknowOutput < "u" && (m.allowUnknownOutputs = E.allowUnknowOutput), typeof E.lockTime != "number") throw new Error("Transaction lock time should be number");
        if (r.U32LE.encode(E.lockTime), E.PSBTVersion !== 0 && E.PSBTVersion !== 2) throw new Error(`Unknown PSBT version ${E.PSBTVersion}`);
        for (const T of [
            "allowUnknownVersion",
            "allowUnknownOutputs",
            "allowUnknownInputs",
            "disableScriptCheck",
            "bip174jsCompat",
            "allowLegacyWitnessUtxo",
            "lowR"
        ]){
            const I = E[T];
            if (I !== void 0 && typeof I != "boolean") throw new Error(`Transation options wrong type: ${T}=${I} (${typeof I})`);
        }
        if (E.allowUnknownVersion ? typeof E.version == "number" : ![
            -1,
            0,
            1,
            2,
            3
        ].includes(E.version)) throw new Error(`Unknown version: ${E.version}`);
        if (E.customScripts !== void 0) {
            const T = E.customScripts;
            if (!Array.isArray(T)) throw new Error(`wrong custom scripts type (expected array): customScripts=${T} (${typeof T})`);
            for (const I of T){
                if (typeof I.encode != "function" || typeof I.decode != "function") throw new Error(`wrong script=${I} (${typeof I})`);
                if (I.finalizeTaproot !== void 0 && typeof I.finalizeTaproot != "function") throw new Error(`wrong script=${I} (${typeof I})`);
            }
        }
        return Object.freeze(E);
    }
    function Q(m) {
        if (m.nonWitnessUtxo && m.index !== void 0) {
            const E = m.nonWitnessUtxo.outputs.length - 1;
            if (m.index > E) throw new Error(`validateInput: index(${m.index}) not in nonWitnessUtxo`);
            const T = m.nonWitnessUtxo.outputs[m.index];
            if (m.witnessUtxo && (!(0, a.equalBytes)(m.witnessUtxo.script, T.script) || m.witnessUtxo.amount !== T.amount)) throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo");
            if (m.txid) {
                if (m.nonWitnessUtxo.outputs.length - 1 < m.index) throw new Error("nonWitnessUtxo: incorect output index");
                const P = $.fromRaw(o.RawTx.encode(m.nonWitnessUtxo), {
                    allowUnknownOutputs: !0,
                    disableScriptCheck: !0,
                    allowUnknownInputs: !0
                }), k = t.hex.encode(m.txid);
                if (P.isFinal && P.id !== k) throw new Error(`nonWitnessUtxo: wrong txid, exp=${k} got=${P.id}`);
            }
        }
        return m;
    }
    function G(m) {
        if (m.nonWitnessUtxo) {
            if (m.index === void 0) throw new Error("Unknown input index");
            return m.nonWitnessUtxo.outputs[m.index];
        } else {
            if (m.witnessUtxo) return m.witnessUtxo;
            throw new Error("Cannot find previous output info");
        }
    }
    function R(m, E, T, I = !1, P = !1) {
        let { nonWitnessUtxo: k, txid: L } = m;
        typeof k == "string" && (k = t.hex.decode(k)), (0, a.isBytes)(k) && (k = o.RawTx.decode(k)), !("nonWitnessUtxo" in m) && k === void 0 && (k = E == null ? void 0 : E.nonWitnessUtxo), typeof L == "string" && (L = t.hex.decode(L)), L === void 0 && (L = E == null ? void 0 : E.txid);
        let j = {
            ...E,
            ...m,
            nonWitnessUtxo: k,
            txid: L
        };
        !("nonWitnessUtxo" in m) && j.nonWitnessUtxo === void 0 && delete j.nonWitnessUtxo, j.sequence === void 0 && (j.sequence = e.DEFAULT_SEQUENCE), j.tapMerkleRoot === null && delete j.tapMerkleRoot, j = i.mergeKeyMap(i.PSBTInput, j, E, T, P), i.PSBTInputCoder.encode(j);
        let ie;
        return j.nonWitnessUtxo && j.index !== void 0 ? ie = j.nonWitnessUtxo.outputs[j.index] : j.witnessUtxo && (ie = j.witnessUtxo), ie && !I && (0, n.checkScript)(ie && ie.script, j.redeemScript, j.witnessScript), j;
    }
    function X(m, E = !1) {
        let T = "legacy", I = y.ALL;
        const P = G(m), k = n.OutScript.decode(P.script);
        let L = k.type, j = k;
        const ie = [
            k
        ];
        if (k.type === "tr") return I = y.DEFAULT, {
            txType: "taproot",
            type: "tr",
            last: k,
            lastScript: P.script,
            defaultSighash: I,
            sighash: m.sighashType || I
        };
        {
            if ((k.type === "wpkh" || k.type === "wsh") && (T = "segwit"), k.type === "sh") {
                if (!m.redeemScript) throw new Error("inputType: sh without redeemScript");
                let ee = n.OutScript.decode(m.redeemScript);
                (ee.type === "wpkh" || ee.type === "wsh") && (T = "segwit"), ie.push(ee), j = ee, L += `-${ee.type}`;
            }
            if (j.type === "wsh") {
                if (!m.witnessScript) throw new Error("inputType: wsh without witnessScript");
                let ee = n.OutScript.decode(m.witnessScript);
                ee.type === "wsh" && (T = "segwit"), ie.push(ee), j = ee, L += `-${ee.type}`;
            }
            const ue = ie[ie.length - 1];
            if (ue.type === "sh" || ue.type === "wsh") throw new Error("inputType: sh/wsh cannot be terminal type");
            const ce = n.OutScript.encode(ue), he = {
                type: L,
                txType: T,
                last: ue,
                lastScript: ce,
                defaultSighash: I,
                sighash: m.sighashType || I
            };
            if (T === "legacy" && !E && !m.nonWitnessUtxo) throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");
            return he;
        }
    }
    class $ {
        constructor(E = {}){
            this.global = {}, this.inputs = [], this.outputs = [];
            const T = this.opts = re(E);
            T.lockTime !== e.DEFAULT_LOCKTIME && (this.global.fallbackLocktime = T.lockTime), this.global.txVersion = T.version;
        }
        // Import
        static fromRaw(E, T = {}) {
            const I = o.RawTx.decode(E), P = new $({
                ...T,
                version: I.version,
                lockTime: I.lockTime
            });
            for (const k of I.outputs)P.addOutput(k);
            if (P.outputs = I.outputs, P.inputs = I.inputs, I.witnesses) for(let k = 0; k < I.witnesses.length; k++)P.inputs[k].finalScriptWitness = I.witnesses[k];
            return P;
        }
        // PSBT
        static fromPSBT(E, T = {}) {
            let I;
            try {
                I = i.RawPSBTV0.decode(E);
            } catch (he) {
                try {
                    I = i.RawPSBTV2.decode(E);
                } catch  {
                    throw he;
                }
            }
            const P = I.global.version || 0;
            if (P !== 0 && P !== 2) throw new Error(`Wrong PSBT version=${P}`);
            const k = I.global.unsignedTx, L = P === 0 ? k == null ? void 0 : k.version : I.global.txVersion, j = P === 0 ? k == null ? void 0 : k.lockTime : I.global.fallbackLocktime, ie = new $({
                ...T,
                version: L,
                lockTime: j,
                PSBTVersion: P
            }), ue = P === 0 ? k == null ? void 0 : k.inputs.length : I.global.inputCount;
            ie.inputs = I.inputs.slice(0, ue).map((he, ee)=>{
                var ae;
                return Q({
                    finalScriptSig: r.EMPTY,
                    ...(ae = I.global.unsignedTx) == null ? void 0 : ae.inputs[ee],
                    ...he
                });
            });
            const ce = P === 0 ? k == null ? void 0 : k.outputs.length : I.global.outputCount;
            return ie.outputs = I.outputs.slice(0, ce).map((he, ee)=>{
                var ae;
                return {
                    ...he,
                    ...(ae = I.global.unsignedTx) == null ? void 0 : ae.outputs[ee]
                };
            }), ie.global = {
                ...I.global,
                txVersion: L
            }, j !== e.DEFAULT_LOCKTIME && (ie.global.fallbackLocktime = j), ie;
        }
        toPSBT(E = this.opts.PSBTVersion) {
            if (E !== 0 && E !== 2) throw new Error(`Wrong PSBT version=${E}`);
            const T = this.inputs.map((k)=>Q(i.cleanPSBTFields(E, i.PSBTInput, k)));
            for (const k of T)k.partialSig && !k.partialSig.length && delete k.partialSig, k.finalScriptSig && !k.finalScriptSig.length && delete k.finalScriptSig, k.finalScriptWitness && !k.finalScriptWitness.length && delete k.finalScriptWitness;
            const I = this.outputs.map((k)=>i.cleanPSBTFields(E, i.PSBTOutput, k)), P = {
                ...this.global
            };
            return E === 0 ? (P.unsignedTx = o.RawOldTx.decode(o.RawOldTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(N).map((k)=>({
                        ...k,
                        finalScriptSig: r.EMPTY
                    })),
                outputs: this.outputs.map(O)
            })), delete P.fallbackLocktime, delete P.txVersion) : (P.version = E, P.txVersion = this.version, P.inputCount = this.inputs.length, P.outputCount = this.outputs.length, P.fallbackLocktime && P.fallbackLocktime === e.DEFAULT_LOCKTIME && delete P.fallbackLocktime), this.opts.bip174jsCompat && (T.length || T.push({}), I.length || I.push({})), (E === 0 ? i.RawPSBTV0 : i.RawPSBTV2).encode({
                global: P,
                inputs: T,
                outputs: I
            });
        }
        // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)
        get lockTime() {
            let E = e.DEFAULT_LOCKTIME, T = 0, I = e.DEFAULT_LOCKTIME, P = 0;
            for (const k of this.inputs)k.requiredHeightLocktime && (E = Math.max(E, k.requiredHeightLocktime), T++), k.requiredTimeLocktime && (I = Math.max(I, k.requiredTimeLocktime), P++);
            return T && T >= P ? E : I !== e.DEFAULT_LOCKTIME ? I : this.global.fallbackLocktime || e.DEFAULT_LOCKTIME;
        }
        get version() {
            if (this.global.txVersion === void 0) throw new Error("No global.txVersion");
            return this.global.txVersion;
        }
        inputStatus(E) {
            this.checkInputIdx(E);
            const T = this.inputs[E];
            return T.finalScriptSig && T.finalScriptSig.length || T.finalScriptWitness && T.finalScriptWitness.length ? "finalized" : T.tapKeySig || T.tapScriptSig && T.tapScriptSig.length || T.partialSig && T.partialSig.length ? "signed" : "unsigned";
        }
        // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range
        // We will lose some vectors -> smaller test coverage of preimages (very important!)
        inputSighash(E) {
            this.checkInputIdx(E);
            const T = this.inputs[E].sighashType, I = T === void 0 ? y.DEFAULT : T, P = I === y.DEFAULT ? y.ALL : I & 3;
            return {
                sigInputs: I & y.ANYONECANPAY,
                sigOutputs: P
            };
        }
        // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.
        // Some cache will be nice, but there chance to have bugs with cache invalidation
        signStatus() {
            let E = !0, T = !0, I = [], P = [];
            for(let k = 0; k < this.inputs.length; k++){
                if (this.inputStatus(k) === "unsigned") continue;
                const { sigInputs: j, sigOutputs: ie } = this.inputSighash(k);
                if (j === y.ANYONECANPAY ? I.push(k) : E = !1, ie === y.ALL) T = !1;
                else if (ie === y.SINGLE) P.push(k);
                else if (ie !== y.NONE) throw new Error(`Wrong signature hash output type: ${ie}`);
            }
            return {
                addInput: E,
                addOutput: T,
                inputs: I,
                outputs: P
            };
        }
        get isFinal() {
            for(let E = 0; E < this.inputs.length; E++)if (this.inputStatus(E) !== "finalized") return !1;
            return !0;
        }
        // Info utils
        get hasWitnesses() {
            let E = !1;
            for (const T of this.inputs)T.finalScriptWitness && T.finalScriptWitness.length && (E = !0);
            return E;
        }
        // https://en.bitcoin.it/wiki/Weight_units
        get weight() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            let E = 32;
            const T = this.outputs.map(O);
            E += 4 * o.CompactSizeLen.encode(this.outputs.length).length;
            for (const I of T)E += 32 + 4 * o.VarBytes.encode(I.script).length;
            this.hasWitnesses && (E += 2), E += 4 * o.CompactSizeLen.encode(this.inputs.length).length;
            for (const I of this.inputs)E += 160 + 4 * o.VarBytes.encode(I.finalScriptSig || r.EMPTY).length, this.hasWitnesses && I.finalScriptWitness && (E += o.RawWitness.encode(I.finalScriptWitness).length);
            return E;
        }
        get vsize() {
            return (0, e.toVsize)(this.weight);
        }
        toBytes(E = !1, T = !1) {
            return o.RawTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(N).map((I)=>({
                        ...I,
                        finalScriptSig: E && I.finalScriptSig || r.EMPTY
                    })),
                outputs: this.outputs.map(O),
                witnesses: this.inputs.map((I)=>I.finalScriptWitness || []),
                segwitFlag: T && this.hasWitnesses
            });
        }
        get unsignedTx() {
            return this.toBytes(!1, !1);
        }
        get hex() {
            return t.hex.encode(this.toBytes(!0, this.hasWitnesses));
        }
        get hash() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return t.hex.encode(s.sha256x2(this.toBytes(!0)));
        }
        get id() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return t.hex.encode(s.sha256x2(this.toBytes(!0)).reverse());
        }
        // Input stuff
        checkInputIdx(E) {
            if (!Number.isSafeInteger(E) || 0 > E || E >= this.inputs.length) throw new Error(`Wrong input index=${E}`);
        }
        getInput(E) {
            return this.checkInputIdx(E), p(this.inputs[E]);
        }
        get inputsLength() {
            return this.inputs.length;
        }
        // Modification
        addInput(E, T = !1) {
            if (!T && !this.signStatus().addInput) throw new Error("Tx has signed inputs, cannot add new one");
            return this.inputs.push(R(E, void 0, void 0, this.opts.disableScriptCheck)), this.inputs.length - 1;
        }
        updateInput(E, T, I = !1) {
            this.checkInputIdx(E);
            let P;
            if (!I) {
                const k = this.signStatus();
                (!k.addInput || k.inputs.includes(E)) && (P = i.PSBTInputUnsignedKeys);
            }
            this.inputs[E] = R(T, this.inputs[E], P, this.opts.disableScriptCheck, this.opts.allowUnknown);
        }
        // Output stuff
        checkOutputIdx(E) {
            if (!Number.isSafeInteger(E) || 0 > E || E >= this.outputs.length) throw new Error(`Wrong output index=${E}`);
        }
        getOutput(E) {
            return this.checkOutputIdx(E), p(this.outputs[E]);
        }
        getOutputAddress(E, T = a.NETWORK) {
            const I = this.getOutput(E);
            if (I.script) return (0, n.Address)(T).encode(n.OutScript.decode(I.script));
        }
        get outputsLength() {
            return this.outputs.length;
        }
        normalizeOutput(E, T, I) {
            let { amount: P, script: k } = E;
            if (P === void 0 && (P = T == null ? void 0 : T.amount), typeof P != "bigint") throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${P} of type ${typeof P}`);
            typeof k == "string" && (k = t.hex.decode(k)), k === void 0 && (k = T == null ? void 0 : T.script);
            let L = {
                ...T,
                ...E,
                amount: P,
                script: k
            };
            if (L.amount === void 0 && delete L.amount, L = i.mergeKeyMap(i.PSBTOutput, L, T, I, this.opts.allowUnknown), i.PSBTOutputCoder.encode(L), L.script && !this.opts.allowUnknownOutputs && n.OutScript.decode(L.script).type === "unknown") throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
            return this.opts.disableScriptCheck || (0, n.checkScript)(L.script, L.redeemScript, L.witnessScript), L;
        }
        addOutput(E, T = !1) {
            if (!T && !this.signStatus().addOutput) throw new Error("Tx has signed outputs, cannot add new one");
            return this.outputs.push(this.normalizeOutput(E)), this.outputs.length - 1;
        }
        updateOutput(E, T, I = !1) {
            this.checkOutputIdx(E);
            let P;
            if (!I) {
                const k = this.signStatus();
                (!k.addOutput || k.outputs.includes(E)) && (P = i.PSBTOutputUnsignedKeys);
            }
            this.outputs[E] = this.normalizeOutput(T, this.outputs[E], P);
        }
        addOutputAddress(E, T, I = a.NETWORK) {
            return this.addOutput({
                script: n.OutScript.encode((0, n.Address)(I).decode(E)),
                amount: T
            });
        }
        // Utils
        get fee() {
            let E = 0n;
            for (const I of this.inputs){
                const P = G(I);
                if (!P) throw new Error("Empty input amount");
                E += P.amount;
            }
            const T = this.outputs.map(O);
            for (const I of T)E -= I.amount;
            return E;
        }
        // Signing
        // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624
        // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,
        // but we are trying to be less complicated for audit purpose for now.
        preimageLegacy(E, T, I) {
            const { isAny: P, isNone: k, isSingle: L } = K(I);
            if (E < 0 || !Number.isSafeInteger(E)) throw new Error(`Invalid input idx=${E}`);
            if (L && E >= this.outputs.length || E >= this.inputs.length) return r.U256BE.encode(1n);
            T = o.Script.encode(o.Script.decode(T).filter((ce)=>ce !== "CODESEPARATOR"));
            let j = this.inputs.map(N).map((ce, he)=>({
                    ...ce,
                    finalScriptSig: he === E ? T : r.EMPTY
                }));
            P ? j = [
                j[E]
            ] : (k || L) && (j = j.map((ce, he)=>({
                    ...ce,
                    sequence: he === E ? ce.sequence : 0
                })));
            let ie = this.outputs.map(O);
            k ? ie = [] : L && (ie = ie.slice(0, E).fill(f).concat([
                ie[E]
            ]));
            const ue = o.RawTx.encode({
                lockTime: this.lockTime,
                version: this.version,
                segwitFlag: !1,
                inputs: j,
                outputs: ie
            });
            return s.sha256x2(ue, r.I32LE.encode(I));
        }
        preimageWitnessV0(E, T, I, P) {
            const { isAny: k, isNone: L, isSingle: j } = K(I);
            let ie = u, ue = u, ce = u;
            const he = this.inputs.map(N), ee = this.outputs.map(O);
            k || (ie = s.sha256x2(...he.map(D.encode))), !k && !j && !L && (ue = s.sha256x2(...he.map((ye)=>r.U32LE.encode(ye.sequence)))), !j && !L ? ce = s.sha256x2(...ee.map(o.RawOutput.encode)) : j && E < ee.length && (ce = s.sha256x2(o.RawOutput.encode(ee[E])));
            const ae = he[E];
            return s.sha256x2(r.I32LE.encode(this.version), ie, ue, r.bytes(32, !0).encode(ae.txid), r.U32LE.encode(ae.index), o.VarBytes.encode(T), r.U64LE.encode(P), r.U32LE.encode(ae.sequence), ce, r.U32LE.encode(this.lockTime), r.U32LE.encode(I));
        }
        preimageWitnessV1(E, T, I, P, k = -1, L, j = 192, ie) {
            if (!Array.isArray(P) || this.inputs.length !== P.length) throw new Error(`Invalid amounts array=${P}`);
            if (!Array.isArray(T) || this.inputs.length !== T.length) throw new Error(`Invalid prevOutScript array=${T}`);
            const ue = [
                r.U8.encode(0),
                r.U8.encode(I),
                // U8 sigHash
                r.I32LE.encode(this.version),
                r.U32LE.encode(this.lockTime)
            ], ce = I === y.DEFAULT ? y.ALL : I & 3, he = I & y.ANYONECANPAY, ee = this.inputs.map(N), ae = this.outputs.map(O);
            he !== y.ANYONECANPAY && ue.push(...[
                ee.map(D.encode),
                P.map(r.U64LE.encode),
                T.map(o.VarBytes.encode),
                ee.map((Se)=>r.U32LE.encode(Se.sequence))
            ].map((Se)=>s.sha256((0, a.concatBytes)(...Se)))), ce === y.ALL && ue.push(s.sha256((0, a.concatBytes)(...ae.map(o.RawOutput.encode))));
            const ye = (ie ? 1 : 0) | (L ? 2 : 0);
            if (ue.push(new Uint8Array([
                ye
            ])), he === y.ANYONECANPAY) {
                const Se = ee[E];
                ue.push(D.encode(Se), r.U64LE.encode(P[E]), o.VarBytes.encode(T[E]), r.U32LE.encode(Se.sequence));
            } else ue.push(r.U32LE.encode(E));
            return ye & 1 && ue.push(s.sha256(o.VarBytes.encode(ie || r.EMPTY))), ce === y.SINGLE && ue.push(E < ae.length ? s.sha256(o.RawOutput.encode(ae[E])) : u), L && ue.push((0, n.tapLeafHash)(L, j), r.U8.encode(0), r.I32LE.encode(k)), s.tagSchnorr("TapSighash", ...ue);
        }
        // Signer can be privateKey OR instance of bip32 HD stuff
        signIdx(E, T, I, P) {
            this.checkInputIdx(T);
            const k = this.inputs[T], L = X(k, this.opts.allowLegacyWitnessUtxo);
            if (!(0, a.isBytes)(E)) {
                if (!k.bip32Derivation || !k.bip32Derivation.length) throw new Error("bip32Derivation: empty");
                const ce = k.bip32Derivation.filter((ee)=>ee[1].fingerprint == E.fingerprint).map(([ee, { path: ae }])=>{
                    let ye = E;
                    for (const Se of ae)ye = ye.deriveChild(Se);
                    if (!(0, a.equalBytes)(ye.publicKey, ee)) throw new Error("bip32Derivation: wrong pubKey");
                    if (!ye.privateKey) throw new Error("bip32Derivation: no privateKey");
                    return ye;
                });
                if (!ce.length) throw new Error(`bip32Derivation: no items with fingerprint=${E.fingerprint}`);
                let he = !1;
                for (const ee of ce)this.signIdx(ee.privateKey, T) && (he = !0);
                return he;
            }
            I ? I.forEach(H) : I = [
                L.defaultSighash
            ];
            const j = L.sighash;
            if (!I.includes(j)) throw new Error(`Input with not allowed sigHash=${j}. Allowed: ${I.join(", ")}`);
            const { sigOutputs: ie } = this.inputSighash(T);
            if (ie === y.SINGLE && T >= this.outputs.length) throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${T}`);
            const ue = G(k);
            if (L.txType === "taproot") {
                const ce = this.inputs.map(G), he = ce.map((De)=>De.script), ee = ce.map((De)=>De.amount);
                let ae = !1, ye = s.pubSchnorr(E), Se = k.tapMerkleRoot || r.EMPTY;
                if (k.tapInternalKey) {
                    const { pubKey: De, privKey: Re } = A(E, ye, k.tapInternalKey, Se), [Ce, M] = s.taprootTweakPubkey(k.tapInternalKey, Se);
                    if ((0, a.equalBytes)(Ce, De)) {
                        const z = this.preimageWitnessV1(T, he, j, ee), de = (0, a.concatBytes)(s.signSchnorr(z, Re, P), j !== y.DEFAULT ? new Uint8Array([
                            j
                        ]) : r.EMPTY);
                        this.updateInput(T, {
                            tapKeySig: de
                        }, !0), ae = !0;
                    }
                }
                if (k.tapLeafScript) {
                    k.tapScriptSig = k.tapScriptSig || [];
                    for (const [De, Re] of k.tapLeafScript){
                        const Ce = Re.subarray(0, -1), M = o.Script.decode(Ce), z = Re[Re.length - 1], de = (0, n.tapLeafHash)(Ce, z);
                        if (M.findIndex((Ke)=>(0, a.isBytes)(Ke) && (0, a.equalBytes)(Ke, ye)) === -1) continue;
                        const Ie = this.preimageWitnessV1(T, he, j, ee, void 0, Ce, z), je = (0, a.concatBytes)(s.signSchnorr(Ie, E, P), j !== y.DEFAULT ? new Uint8Array([
                            j
                        ]) : r.EMPTY);
                        this.updateInput(T, {
                            tapScriptSig: [
                                [
                                    {
                                        pubKey: ye,
                                        leafHash: de
                                    },
                                    je
                                ]
                            ]
                        }, !0), ae = !0;
                    }
                }
                if (!ae) throw new Error("No taproot scripts signed");
                return !0;
            } else {
                const ce = s.pubECDSA(E);
                let he = !1;
                const ee = s.hash160(ce);
                for (const Se of o.Script.decode(L.lastScript))(0, a.isBytes)(Se) && ((0, a.equalBytes)(Se, ce) || (0, a.equalBytes)(Se, ee)) && (he = !0);
                if (!he) throw new Error(`Input script doesn't have pubKey: ${L.lastScript}`);
                let ae;
                if (L.txType === "legacy") ae = this.preimageLegacy(T, L.lastScript, j);
                else if (L.txType === "segwit") {
                    let Se = L.lastScript;
                    L.last.type === "wpkh" && (Se = n.OutScript.encode({
                        type: "pkh",
                        hash: L.last.hash
                    })), ae = this.preimageWitnessV0(T, Se, j, ue.amount);
                } else throw new Error(`Transaction/sign: unknown tx type: ${L.txType}`);
                const ye = s.signECDSA(ae, E, this.opts.lowR);
                this.updateInput(T, {
                    partialSig: [
                        [
                            ce,
                            (0, a.concatBytes)(ye, new Uint8Array([
                                j
                            ]))
                        ]
                    ]
                }, !0);
            }
            return !0;
        }
        // This is bad API. Will work if user creates and signs tx, but if
        // there is some complex workflow with exchanging PSBT and signing them,
        // then it is better to validate which output user signs. How could a better API look like?
        // Example: user adds input, sends to another party, then signs received input (mixer etc),
        // another user can add different input for same key and user will sign it.
        // Even worse: another user can add bip32 derivation, and spend money from different address.
        // Better api: signIdx
        sign(E, T, I) {
            let P = 0;
            for(let k = 0; k < this.inputs.length; k++)try {
                this.signIdx(E, k, T, I) && P++;
            } catch  {}
            if (!P) throw new Error("No inputs signed");
            return P;
        }
        finalizeIdx(E) {
            if (this.checkInputIdx(E), this.fee < 0n) throw new Error("Outputs spends more than inputs amount");
            const T = this.inputs[E], I = X(T, this.opts.allowLegacyWitnessUtxo);
            if (I.txType === "taproot") {
                if (T.tapKeySig) T.finalScriptWitness = [
                    T.tapKeySig
                ];
                else if (T.tapLeafScript && T.tapScriptSig) {
                    const ie = T.tapLeafScript.sort((ue, ce)=>i.TaprootControlBlock.encode(ue[0]).length - i.TaprootControlBlock.encode(ce[0]).length);
                    for (const [ue, ce] of ie){
                        const he = ce.slice(0, -1), ee = ce[ce.length - 1], ae = n.OutScript.decode(he), ye = (0, n.tapLeafHash)(he, ee), Se = T.tapScriptSig.filter((Re)=>(0, a.equalBytes)(Re[0].leafHash, ye));
                        let De = [];
                        if (ae.type === "tr_ms") {
                            const Re = ae.m, Ce = ae.pubkeys;
                            let M = 0;
                            for (const z of Ce){
                                const de = Se.findIndex((_e)=>(0, a.equalBytes)(_e[0].pubKey, z));
                                if (M === Re || de === -1) {
                                    De.push(r.EMPTY);
                                    continue;
                                }
                                De.push(Se[de][1]), M++;
                            }
                            if (M !== Re) continue;
                        } else if (ae.type === "tr_ns") {
                            for (const Re of ae.pubkeys){
                                const Ce = Se.findIndex((M)=>(0, a.equalBytes)(M[0].pubKey, Re));
                                Ce !== -1 && De.push(Se[Ce][1]);
                            }
                            if (De.length !== ae.pubkeys.length) continue;
                        } else if (ae.type === "unknown" && this.opts.allowUnknownInputs) {
                            const Re = o.Script.decode(he);
                            if (De = Se.map(([{ pubKey: Ce }, M])=>{
                                const z = Re.findIndex((de)=>(0, a.isBytes)(de) && (0, a.equalBytes)(de, Ce));
                                if (z === -1) throw new Error("finalize/taproot: cannot find position of pubkey in script");
                                return {
                                    signature: M,
                                    pos: z
                                };
                            }).sort((Ce, M)=>Ce.pos - M.pos).map((Ce)=>Ce.signature), !De.length) continue;
                        } else {
                            const Re = this.opts.customScripts;
                            if (Re) for (const Ce of Re){
                                if (!Ce.finalizeTaproot) continue;
                                const M = o.Script.decode(he), z = Ce.encode(M);
                                if (z === void 0) continue;
                                const de = Ce.finalizeTaproot(he, z, Se);
                                if (de) {
                                    T.finalScriptWitness = de.concat(i.TaprootControlBlock.encode(ue)), T.finalScriptSig = r.EMPTY, U(T);
                                    return;
                                }
                            }
                            throw new Error("Finalize: Unknown tapLeafScript");
                        }
                        T.finalScriptWitness = De.reverse().concat([
                            he,
                            i.TaprootControlBlock.encode(ue)
                        ]);
                        break;
                    }
                    if (!T.finalScriptWitness) throw new Error("finalize/taproot: empty witness");
                } else throw new Error("finalize/taproot: unknown input");
                T.finalScriptSig = r.EMPTY, U(T);
                return;
            }
            if (!T.partialSig || !T.partialSig.length) throw new Error("Not enough partial sign");
            let P = r.EMPTY, k = [];
            if (I.last.type === "ms") {
                const ie = I.last.m, ue = I.last.pubkeys;
                let ce = [];
                for (const he of ue){
                    const ee = T.partialSig.find((ae)=>(0, a.equalBytes)(he, ae[0]));
                    ee && ce.push(ee[1]);
                }
                if (ce = ce.slice(0, ie), ce.length !== ie) throw new Error(`Multisig: wrong signatures count, m=${ie} n=${ue.length} signatures=${ce.length}`);
                P = o.Script.encode([
                    0,
                    ...ce
                ]);
            } else if (I.last.type === "pk") P = o.Script.encode([
                T.partialSig[0][1]
            ]);
            else if (I.last.type === "pkh") P = o.Script.encode([
                T.partialSig[0][1],
                T.partialSig[0][0]
            ]);
            else if (I.last.type === "wpkh") P = r.EMPTY, k = [
                T.partialSig[0][1],
                T.partialSig[0][0]
            ];
            else if (I.last.type === "unknown" && !this.opts.allowUnknownInputs) throw new Error("Unknown inputs not allowed");
            let L, j;
            if (I.type.includes("wsh-") && (P.length && I.lastScript.length && (k = o.Script.decode(P).map((ie)=>{
                if (ie === 0) return r.EMPTY;
                if ((0, a.isBytes)(ie)) return ie;
                throw new Error(`Wrong witness op=${ie}`);
            })), k = k.concat(I.lastScript)), I.txType === "segwit" && (j = k), I.type.startsWith("sh-wsh-") ? L = o.Script.encode([
                o.Script.encode([
                    0,
                    s.sha256(I.lastScript)
                ])
            ]) : I.type.startsWith("sh-") ? L = o.Script.encode([
                ...o.Script.decode(P),
                I.lastScript
            ]) : I.type.startsWith("wsh-") || I.txType !== "segwit" && (L = P), !L && !j) throw new Error("Unknown error finalizing input");
            L && (T.finalScriptSig = L), j && (T.finalScriptWitness = j), U(T);
        }
        finalize() {
            for(let E = 0; E < this.inputs.length; E++)this.finalizeIdx(E);
        }
        extract() {
            if (!this.isFinal) throw new Error("Transaction has unfinalized inputs");
            if (!this.outputs.length) throw new Error("Transaction has no outputs");
            if (this.fee < 0n) throw new Error("Outputs spends more than inputs amount");
            return this.toBytes(!0, !0);
        }
        combine(E) {
            for (const P of [
                "PSBTVersion",
                "version",
                "lockTime"
            ])if (this.opts[P] !== E.opts[P]) throw new Error(`Transaction/combine: different ${P} this=${this.opts[P]} other=${E.opts[P]}`);
            for (const P of [
                "inputs",
                "outputs"
            ])if (this[P].length !== E[P].length) throw new Error(`Transaction/combine: different ${P} length this=${this[P].length} other=${E[P].length}`);
            const T = this.global.unsignedTx ? o.RawOldTx.encode(this.global.unsignedTx) : r.EMPTY, I = E.global.unsignedTx ? o.RawOldTx.encode(E.global.unsignedTx) : r.EMPTY;
            if (!(0, a.equalBytes)(T, I)) throw new Error("Transaction/combine: different unsigned tx");
            this.global = i.mergeKeyMap(i.PSBTGlobal, this.global, E.global, void 0, this.opts.allowUnknown);
            for(let P = 0; P < this.inputs.length; P++)this.updateInput(P, E.inputs[P], !0);
            for(let P = 0; P < this.outputs.length; P++)this.updateOutput(P, E.outputs[P], !0);
            return this;
        }
        clone() {
            return $.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
        }
    }
    e.Transaction = $;
    function S(m) {
        if (!m || !Array.isArray(m) || !m.length) throw new Error("PSBTCombine: wrong PSBT list");
        const E = $.fromPSBT(m[0]);
        for(let T = 1; T < m.length; T++)E.combine($.fromPSBT(m[T]));
        return E.toPSBT();
    }
    const w = 2147483648;
    function g(m) {
        const E = [];
        if (!/^[mM]'?/.test(m)) throw new Error('Path must start with "m" or "M"');
        if (/^[mM]'?$/.test(m)) return E;
        const T = m.replace(/^[mM]'?\//, "").split("/");
        for (const I of T){
            const P = /^(\d+)('?)$/.exec(I);
            if (!P || P.length !== 3) throw new Error(`Invalid child index: ${I}`);
            let k = +P[1];
            if (!Number.isSafeInteger(k) || k >= w) throw new Error("Invalid index");
            P[2] === "'" && (k += w), E.push(k);
        }
        return E;
    }
})(Em);
var px = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._Estimator = e._cmpBig = void 0, e.selectUTXO = _;
    const t = zd, r = jf, n = yp, i = v0, o = jd, s = Em, a = wa, u = (A)=>i.TaprootControlBlock.encode(A);
    function f(A, O, N) {
        if (!A || !A.length) throw new Error("no leafs");
        const U = ()=>new Uint8Array(O), D = A.sort((H, K)=>u(H[0]).length - u(K[0]).length);
        for (const [H, K] of D){
            const re = K.slice(0, -1), Q = K[K.length - 1], G = n.OutScript.decode(re);
            let R = [];
            if (G.type === "tr_ms") {
                const X = G.m, $ = G.pubkeys.length - X;
                for(let S = 0; S < X; S++)R.push(U());
                for(let S = 0; S < $; S++)R.push(r.EMPTY);
            } else if (G.type === "tr_ns") for (const X of G.pubkeys)R.push(U());
            else {
                if (!N) throw new Error("Finalize: Unknown tapLeafScript");
                const X = (0, n.tapLeafHash)(re, Q);
                for (const $ of N){
                    if (!$.finalizeTaproot) continue;
                    const S = o.Script.decode(re), w = $.encode(S);
                    if (w === void 0) continue;
                    const g = S.filter((E)=>{
                        if (!(0, a.isBytes)(E)) return !1;
                        try {
                            return (0, a.validatePubkey)(E, a.PubT.schnorr), !0;
                        } catch  {
                            return !1;
                        }
                    }), m = $.finalizeTaproot(re, w, g.map((E)=>[
                            {
                                pubKey: E,
                                leafHash: X
                            },
                            U()
                        ]));
                    if (m) return m.concat(u(H));
                }
            }
            return R.reverse().concat([
                re,
                u(H)
            ]);
        }
        throw new Error("there was no witness");
    }
    function c(A, O, N) {
        let U = r.EMPTY, D;
        if (A.txType === "taproot") {
            const re = A.sighash !== s.SignatureHash.DEFAULT ? 65 : 64;
            if (O.tapInternalKey && !(0, a.equalBytes)(O.tapInternalKey, a.TAPROOT_UNSPENDABLE_KEY)) D = [
                new Uint8Array(re)
            ];
            else if (O.tapLeafScript) D = f(O.tapLeafScript, re, N.customScripts);
            else throw new Error("estimateInput/taproot: unknown input");
        } else {
            const re = ()=>new Uint8Array(72), Q = ()=>new Uint8Array(33);
            let G = r.EMPTY, R = [];
            const X = A.last.type;
            if (X === "ms") {
                const $ = A.last.m, S = [
                    0
                ];
                for(let w = 0; w < $; w++)S.push(re());
                G = o.Script.encode(S);
            } else if (X === "pk") G = o.Script.encode([
                re()
            ]);
            else if (X === "pkh") G = o.Script.encode([
                re(),
                Q()
            ]);
            else if (X === "wpkh") G = r.EMPTY, R = [
                re(),
                Q()
            ];
            else if (X === "unknown" && !N.allowUnknownInputs) throw new Error("Unknown inputs are not allowed");
            A.type.includes("wsh-") && (G.length && A.lastScript.length && (R = o.Script.decode(G).map(($)=>{
                if ($ === 0) return r.EMPTY;
                if ((0, a.isBytes)($)) return $;
                throw new Error(`Wrong witness op=${$}`);
            })), R = R.concat(A.lastScript)), A.txType === "segwit" && (D = R), A.type.startsWith("sh-wsh-") ? U = o.Script.encode([
                o.Script.encode([
                    0,
                    new Uint8Array(a.sha256.outputLen)
                ])
            ]) : A.type.startsWith("sh-") ? U = o.Script.encode([
                ...o.Script.decode(G),
                A.lastScript
            ]) : A.type.startsWith("wsh-") || A.txType !== "segwit" && (U = G);
        }
        let H = 160 + 4 * o.VarBytes.encode(U).length, K = !1;
        return D && (H += o.RawWitness.encode(D).length, K = !0), {
            weight: H,
            hasWitnesses: K
        };
    }
    const l = (A, O)=>{
        const N = A - O;
        return N < 0n ? -1 : N > 0n ? 1 : 0;
    };
    e._cmpBig = l;
    function p(A, O = {}, N = a.NETWORK) {
        let U;
        if ("script" in A && (0, a.isBytes)(A.script) && (U = A.script), "address" in A) {
            if (typeof A.address != "string") throw new Error(`Estimator: wrong output address=${A.address}`);
            U = n.OutScript.encode((0, n.Address)(N).decode(A.address));
        }
        if (!U) throw new Error("Estimator: wrong output script");
        if (typeof A.amount != "bigint") throw new Error(`Estimator: wrong output amount=${A.amount}, should be of type bigint but got ${typeof A.amount}.`);
        if (U && !O.allowUnknownOutputs && n.OutScript.decode(U).type === "unknown") throw new Error("Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
        return O.disableScriptCheck || (0, n.checkScript)(U), U;
    }
    class y {
        constructor(O, N, U){
            if (this.requiredIndices = [], this.outputs = N, this.opts = U, typeof U.feePerByte != "bigint") throw new Error(`Estimator: wrong feePerByte=${U.feePerByte}, should be of type bigint but got ${typeof U.feePerByte}.`);
            const K = U.dust === void 0 ? BigInt(148 + 34) : U.dust;
            if (typeof K != "bigint") throw new Error(`Estimator: wrong dust=${U.dust}, should be of type bigint but got ${typeof U.dust}.`);
            const re = U.dustRelayFeeRate === void 0 ? 3n : U.dustRelayFeeRate;
            if (typeof re != "bigint") throw new Error(`Estimator: wrong dustRelayFeeRate=${U.dustRelayFeeRate}, should be of type bigint but got ${typeof U.dustRelayFeeRate}.`);
            if (this.dust = K * re, U.requiredInputs !== void 0 && !Array.isArray(U.requiredInputs)) throw new Error(`Estimator: wrong required inputs=${U.requiredInputs}`);
            const Q = U.network || a.NETWORK;
            let G = 0n, R = 32;
            for (const w of N){
                const g = p(w, U, U.network);
                R += 32 + 4 * o.VarBytes.encode(g).length, G += w.amount;
            }
            if (typeof U.changeAddress != "string") throw new Error(`Estimator: wrong change address=${U.changeAddress}`);
            let X = R + 32 + 4 * o.VarBytes.encode(n.OutScript.encode((0, n.Address)(Q).decode(U.changeAddress))).length;
            R += 4 * o.CompactSizeLen.encode(N.length).length, X += 4 * o.CompactSizeLen.encode(N.length + 1).length, this.baseWeight = R, this.changeWeight = X, this.amount = G;
            const $ = Array.from(O);
            if (U.requiredInputs) for(let w = 0; w < U.requiredInputs.length; w++)this.requiredIndices.push($.push(U.requiredInputs[w]) - 1);
            const S = /* @__PURE__ */ new Set();
            this.normalizedInputs = $.map((w)=>{
                const g = (0, s.normalizeInput)(w, void 0, void 0, U.disableScriptCheck, U.allowUnknown);
                (0, s.inputBeforeSign)(g);
                const m = `${t.hex.encode(g.txid)}:${g.index}`;
                if (!U.allowSameUtxo && S.has(m)) throw new Error(`Estimator: same input passed multiple times: ${m}`);
                S.add(m);
                const E = (0, s.getInputType)(g, U.allowLegacyWitnessUtxo), T = (0, s.getPrevOut)(g), I = c(E, g, this.opts), P = T.amount - U.feePerByte * BigInt((0, s.toVsize)(I.weight));
                return {
                    inputType: E,
                    normalized: g,
                    amount: T.amount,
                    value: P,
                    estimate: I
                };
            });
        }
        checkInputIdx(O) {
            if (!Number.isSafeInteger(O) || 0 > O || O >= this.normalizedInputs.length) throw new Error(`Wrong input index=${O}`);
            return O;
        }
        sortIndices(O) {
            return O.slice().sort((N, U)=>{
                const D = this.normalizedInputs[this.checkInputIdx(N)], H = this.normalizedInputs[this.checkInputIdx(U)], K = (0, a.compareBytes)(D.normalized.txid, H.normalized.txid);
                return K !== 0 ? K : D.normalized.index - H.normalized.index;
            });
        }
        sortOutputs(O) {
            const N = O.map((D)=>p(D, this.opts, this.opts.network));
            return O.map((D, H)=>H).sort((D, H)=>{
                const K = O[D].amount, re = O[H].amount, Q = (0, e._cmpBig)(K, re);
                return Q !== 0 ? Q : (0, a.compareBytes)(N[D], N[H]);
            });
        }
        getSatoshi(O) {
            return this.opts.feePerByte * BigInt((0, s.toVsize)(O));
        }
        // Sort by value instead of amount
        get biggest() {
            return this.normalizedInputs.map((O, N)=>N).sort((O, N)=>(0, e._cmpBig)(this.normalizedInputs[N].value, this.normalizedInputs[O].value));
        }
        get smallest() {
            return this.biggest.reverse();
        }
        // These assume that UTXO array has historical order.
        // Otherwise, we have no way to know which tx is oldest
        // Explorers usually give UTXO in this order.
        get oldest() {
            return this.normalizedInputs.map((O, N)=>N);
        }
        get newest() {
            return this.oldest.reverse();
        }
        // exact - like blackjack from coinselect.
        // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.
        // If not, it will accumulate largest utxo until value is close to targetValue+dust.
        accumulate(O, N = !1, U = !0, D = !1) {
            let H = this.opts.alwaysChange ? this.changeWeight : this.baseWeight, K = !1, re = 0, Q = 0n;
            const G = this.amount, R = /* @__PURE__ */ new Set();
            let X;
            for (const $ of this.requiredIndices){
                if (this.checkInputIdx($), R.has($)) throw new Error("required input encountered multiple times");
                const { estimate: S, amount: w } = this.normalizedInputs[$];
                let g = H + S.weight;
                !K && S.hasWitnesses && (g += 2);
                const m = g + 4 * o.CompactSizeLen.encode(re).length;
                if (X = this.getSatoshi(m), H = g, S.hasWitnesses && (K = !0), re++, Q += w, R.add($), !D && G + X <= Q && re >= this.requiredIndices.length) return {
                    indices: Array.from(R),
                    fee: X,
                    weight: m,
                    total: Q
                };
            }
            for (const $ of O){
                if (this.checkInputIdx($), R.has($)) continue;
                const { estimate: S, amount: w, value: g } = this.normalizedInputs[$];
                let m = H + S.weight;
                !K && S.hasWitnesses && (m += 2);
                const E = m + 4 * o.CompactSizeLen.encode(re).length;
                if (X = this.getSatoshi(E), !(N && w + Q > G + X + this.dust) && !(U && g <= 0n) && (H = m, S.hasWitnesses && (K = !0), re++, Q += w, R.add($), !D && G + X <= Q)) return {
                    indices: Array.from(R),
                    fee: X,
                    weight: E,
                    total: Q
                };
            }
            if (D) {
                const $ = H + 4 * o.CompactSizeLen.encode(re).length;
                return {
                    indices: Array.from(R),
                    fee: X,
                    weight: $,
                    total: Q
                };
            }
        }
        // Works like coinselect default method
        default() {
            const { biggest: O } = this, N = this.accumulate(O, !0, !1);
            return N || this.accumulate(O);
        }
        select(O) {
            if (O === "all") return this.accumulate(this.normalizedInputs.map((U, D)=>D), !1, !0, !0);
            if (O === "default") return this.default();
            const N = {
                Oldest: ()=>this.oldest,
                Newest: ()=>this.newest,
                Smallest: ()=>this.smallest,
                Biggest: ()=>this.biggest
            };
            if (O.startsWith("exact")) {
                const [U, D] = O.slice(5).split("/");
                if (!N[U]) throw new Error(`Estimator.select: wrong strategy=${O}`);
                O = D;
                const H = this.accumulate(N[U](), !0, !0);
                if (H) return H;
            }
            if (O.startsWith("accum")) {
                const U = O.slice(5);
                if (!N[U]) throw new Error(`Estimator.select: wrong strategy=${O}`);
                return this.accumulate(N[U]());
            }
            throw new Error(`Estimator.select: wrong strategy=${O}`);
        }
        result(O) {
            const N = this.select(O);
            if (!N) return;
            const { indices: U, weight: D, total: H } = N;
            let K = this.opts.alwaysChange;
            const re = this.opts.alwaysChange ? D : D + (this.changeWeight - this.baseWeight), Q = this.getSatoshi(re);
            let G = N.fee;
            const R = H - this.amount - Q;
            R > this.dust && (K = !0);
            let X = U, $ = Array.from(this.outputs);
            if (K) {
                if (G = Q, R < 0n) throw new Error(`Estimator.result: negative change=${R}`);
                $.push({
                    address: this.opts.changeAddress,
                    amount: R
                });
            }
            this.opts.bip69 && (X = this.sortIndices(X), $ = this.sortOutputs($).map((g)=>$[g]));
            const S = {
                inputs: X.map((g)=>this.normalizedInputs[g].normalized),
                outputs: $,
                fee: G,
                weight: this.opts.alwaysChange ? N.weight : re,
                change: !!K
            };
            let w;
            if (this.opts.createTx) {
                const { inputs: g, outputs: m } = S;
                w = new s.Transaction(this.opts);
                for (const E of g)w.addInput(E);
                for (const E of m)w.addOutput({
                    ...E,
                    script: p(E, this.opts, this.opts.network)
                });
            }
            return Object.assign(S, {
                tx: w
            });
        }
    }
    e._Estimator = y;
    function _(A, O, N, U) {
        const D = {
            createTx: !0,
            bip69: !0,
            ...U
        };
        return new y(A, O, D).result(N);
    }
})(px);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._Estimator = e._cmpBig = e.SigHash = e.PSBTCombine = e.DEFAULT_SEQUENCE = e.Decimal = e.bip32Path = e.TaprootControlBlock = e._DebugPSBT = e.WIF = e.taprootListToTree = e.sortedMultisig = e.OutScript = e.getAddress = e.combinations = e.Address = e._sortPubkeys = e.utils = e.selectUTXO = e.TEST_NETWORK = e.TAPROOT_UNSPENDABLE_KEY = e.NETWORK = e.Transaction = e.getInputType = e.ScriptNum = e.Script = e.RawWitness = e.RawTx = e.OP = e.MAX_SCRIPT_BYTE_LENGTH = e.CompactSize = e.p2wsh = e.p2wpkh = e.p2tr_pk = e.p2tr_ns = e.p2tr_ms = e.p2tr = e.p2sh = e.p2pkh = e.p2pk = e.p2ms = e.multisig = void 0;
    /*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = wa;
    var r = yp;
    Object.defineProperty(e, "multisig", {
        enumerable: !0,
        get: function() {
            return r.multisig;
        }
    }), Object.defineProperty(e, "p2ms", {
        enumerable: !0,
        get: function() {
            return r.p2ms;
        }
    }), Object.defineProperty(e, "p2pk", {
        enumerable: !0,
        get: function() {
            return r.p2pk;
        }
    }), Object.defineProperty(e, "p2pkh", {
        enumerable: !0,
        get: function() {
            return r.p2pkh;
        }
    }), Object.defineProperty(e, "p2sh", {
        enumerable: !0,
        get: function() {
            return r.p2sh;
        }
    }), Object.defineProperty(e, "p2tr", {
        enumerable: !0,
        get: function() {
            return r.p2tr;
        }
    }), Object.defineProperty(e, "p2tr_ms", {
        enumerable: !0,
        get: function() {
            return r.p2tr_ms;
        }
    }), Object.defineProperty(e, "p2tr_ns", {
        enumerable: !0,
        get: function() {
            return r.p2tr_ns;
        }
    }), Object.defineProperty(e, "p2tr_pk", {
        enumerable: !0,
        get: function() {
            return r.p2tr_pk;
        }
    }), Object.defineProperty(e, "p2wpkh", {
        enumerable: !0,
        get: function() {
            return r.p2wpkh;
        }
    }), Object.defineProperty(e, "p2wsh", {
        enumerable: !0,
        get: function() {
            return r.p2wsh;
        }
    });
    var n = jd;
    Object.defineProperty(e, "CompactSize", {
        enumerable: !0,
        get: function() {
            return n.CompactSize;
        }
    }), Object.defineProperty(e, "MAX_SCRIPT_BYTE_LENGTH", {
        enumerable: !0,
        get: function() {
            return n.MAX_SCRIPT_BYTE_LENGTH;
        }
    }), Object.defineProperty(e, "OP", {
        enumerable: !0,
        get: function() {
            return n.OP;
        }
    }), Object.defineProperty(e, "RawTx", {
        enumerable: !0,
        get: function() {
            return n.RawTx;
        }
    }), Object.defineProperty(e, "RawWitness", {
        enumerable: !0,
        get: function() {
            return n.RawWitness;
        }
    }), Object.defineProperty(e, "Script", {
        enumerable: !0,
        get: function() {
            return n.Script;
        }
    }), Object.defineProperty(e, "ScriptNum", {
        enumerable: !0,
        get: function() {
            return n.ScriptNum;
        }
    });
    var i = Em;
    Object.defineProperty(e, "getInputType", {
        enumerable: !0,
        get: function() {
            return i.getInputType;
        }
    }), Object.defineProperty(e, "Transaction", {
        enumerable: !0,
        get: function() {
            return i.Transaction;
        }
    });
    var o = wa;
    Object.defineProperty(e, "NETWORK", {
        enumerable: !0,
        get: function() {
            return o.NETWORK;
        }
    }), Object.defineProperty(e, "TAPROOT_UNSPENDABLE_KEY", {
        enumerable: !0,
        get: function() {
            return o.TAPROOT_UNSPENDABLE_KEY;
        }
    }), Object.defineProperty(e, "TEST_NETWORK", {
        enumerable: !0,
        get: function() {
            return o.TEST_NETWORK;
        }
    });
    var s = px;
    Object.defineProperty(e, "selectUTXO", {
        enumerable: !0,
        get: function() {
            return s.selectUTXO;
        }
    }), e.utils = {
        isBytes: t.isBytes,
        concatBytes: t.concatBytes,
        compareBytes: t.compareBytes,
        pubSchnorr: t.pubSchnorr,
        randomPrivateKeyBytes: t.randomPrivateKeyBytes,
        taprootTweakPubkey: t.taprootTweakPubkey
    };
    var a = yp;
    Object.defineProperty(e, "_sortPubkeys", {
        enumerable: !0,
        get: function() {
            return a._sortPubkeys;
        }
    }), Object.defineProperty(e, "Address", {
        enumerable: !0,
        get: function() {
            return a.Address;
        }
    }), Object.defineProperty(e, "combinations", {
        enumerable: !0,
        get: function() {
            return a.combinations;
        }
    }), Object.defineProperty(e, "getAddress", {
        enumerable: !0,
        get: function() {
            return a.getAddress;
        }
    }), Object.defineProperty(e, "OutScript", {
        enumerable: !0,
        get: function() {
            return a.OutScript;
        }
    }), Object.defineProperty(e, "sortedMultisig", {
        enumerable: !0,
        get: function() {
            return a.sortedMultisig;
        }
    }), Object.defineProperty(e, "taprootListToTree", {
        enumerable: !0,
        get: function() {
            return a.taprootListToTree;
        }
    }), Object.defineProperty(e, "WIF", {
        enumerable: !0,
        get: function() {
            return a.WIF;
        }
    });
    var u = v0;
    Object.defineProperty(e, "_DebugPSBT", {
        enumerable: !0,
        get: function() {
            return u._DebugPSBT;
        }
    }), Object.defineProperty(e, "TaprootControlBlock", {
        enumerable: !0,
        get: function() {
            return u.TaprootControlBlock;
        }
    });
    var f = Em;
    Object.defineProperty(e, "bip32Path", {
        enumerable: !0,
        get: function() {
            return f.bip32Path;
        }
    }), Object.defineProperty(e, "Decimal", {
        enumerable: !0,
        get: function() {
            return f.Decimal;
        }
    }), Object.defineProperty(e, "DEFAULT_SEQUENCE", {
        enumerable: !0,
        get: function() {
            return f.DEFAULT_SEQUENCE;
        }
    }), Object.defineProperty(e, "PSBTCombine", {
        enumerable: !0,
        get: function() {
            return f.PSBTCombine;
        }
    }), Object.defineProperty(e, "SigHash", {
        enumerable: !0,
        get: function() {
            return f.SigHash;
        }
    });
    var c = px;
    Object.defineProperty(e, "_cmpBig", {
        enumerable: !0,
        get: function() {
            return c._cmpBig;
        }
    }), Object.defineProperty(e, "_Estimator", {
        enumerable: !0,
        get: function() {
            return c._Estimator;
        }
    });
})(vS);
var s1 = {}, rce = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), nce = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), ice = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && rce(t, e, r);
    return nce(t, e), t;
};
Object.defineProperty(s1, "__esModule", {
    value: !0
});
s1.CBOR = void 0;
const xr = ice(wS), uy = vS, _S = (e)=>e === 0 && 1 / e < 0, SI = xr.wrap({
    encodeStream (e, t) {
        if (t === 1 / 0) return e.bytes(new Uint8Array([
            124,
            0
        ]));
        if (t === -1 / 0) return e.bytes(new Uint8Array([
            252,
            0
        ]));
        if (Number.isNaN(t)) return e.bytes(new Uint8Array([
            126,
            0
        ]));
        if (_S(t)) return e.bytes(new Uint8Array([
            128,
            0
        ]));
        throw e.err("f16: not implemented");
    },
    decodeStream: (e)=>{
        const t = xr.U16BE.decodeStream(e), r = (t & 31744) >> 10, n = t & 1023;
        let i;
        return r === 0 ? i = 6103515625e-14 * (n / 1024) : r !== 31 ? i = Math.pow(2, r - 15) * (1 + n / 1024) : i = n ? NaN : 1 / 0, t & 32768 ? -i : i;
    }
}), hi = xr.bits(5), oce = xr.apply(xr.U64BE, xr.coders.numberBigint), ic = {
    24: [
        2 ** 8 - 1,
        xr.U8,
        xr.U8
    ],
    25: [
        2 ** 16 - 1,
        xr.U16BE,
        xr.U16BE
    ],
    26: [
        2 ** 32 - 1,
        xr.U32BE,
        xr.U32BE
    ],
    27: [
        2n ** 64n - 1n,
        xr.U64BE,
        oce
    ]
}, xm = xr.wrap({
    encodeStream (e, t) {
        if (t < 24) return hi.encodeStream(e, typeof t == "bigint" ? Number(t) : t);
        for(const r in ic){
            const [n, i, o] = ic[r];
            if (!(t > n)) return hi.encodeStream(e, Number(r)), i.encodeStream(e, t);
        }
        throw e.err(`cbor/uint: wrong value=${t}`);
    },
    decodeStream (e) {
        const t = hi.decodeStream(e);
        if (t < 24) return t;
        const r = ic[t][1];
        if (!r) throw e.err(`cbor/uint wrong additional information=${t}`);
        return r.decodeStream(e);
    }
}), sce = xr.wrap({
    encodeStream: (e, t)=>xm.encodeStream(e, typeof t == "bigint" ? -(t + 1n) : -(t + 1)),
    decodeStream (e) {
        const t = xm.decodeStream(e);
        return typeof t == "bigint" ? -1n - t : -1 - t;
    }
}), AI = (e)=>xr.wrap({
        encodeStream (t, r) {
            if (r.length < 24) {
                hi.encodeStream(t, r.length), xr.array(r.length, e).encodeStream(t, r);
                return;
            }
            for(const n in ic){
                const [i, o, s] = ic[n];
                if (r.length < i) {
                    hi.encodeStream(t, Number(n)), xr.array(s, e).encodeStream(t, r);
                    return;
                }
            }
            throw t.err(`cbor/lengthArray: wrong value=${r}`);
        },
        decodeStream (t) {
            const r = hi.decodeStream(t);
            if (r < 24) return xr.array(r, e).decodeStream(t);
            if (r === 31) return xr.array(new Uint8Array([
                255
            ]), e).decodeStream(t);
            const n = ic[r][2];
            if (!n) throw t.err(`cbor/lengthArray wrong length=${r}`);
            return xr.array(n, e).decodeStream(t);
        }
    }), TI = (e, t)=>xr.wrap({
        encodeStream (r, n) {
            if (Array.isArray(n)) throw new Error("cbor/length: encoding indefinite-length strings not supported");
            const i = e(null).encode(n);
            if (i.length < 24) {
                hi.encodeStream(r, i.length), r.bytes(i);
                return;
            }
            for(const o in ic){
                const [s, a, u] = ic[o];
                if (i.length < s) {
                    hi.encodeStream(r, Number(o)), u.encodeStream(r, i.length), r.bytes(i);
                    return;
                }
            }
            throw r.err(`cbor/lengthArray: wrong value=${n}`);
        },
        decodeStream (r) {
            const n = hi.decodeStream(r);
            if (n < 24) return e(n).decodeStream(r);
            if (n === 31) return xr.array(new Uint8Array([
                255
            ]), t).decodeStream(r);
            const i = ic[n][2];
            if (!i) throw r.err(`cbor/length wrong length=${n}`);
            return e(i).decodeStream(r);
        }
    }), ace = xr.wrap({
    encodeStream (e, t) {
        if (t === !1) return hi.encodeStream(e, 20);
        if (t === !0) return hi.encodeStream(e, 21);
        if (t === null) return hi.encodeStream(e, 22);
        if (t === void 0) return hi.encodeStream(e, 23);
        if (typeof t != "number") throw e.err(`cbor/simple: wrong value type=${typeof t}`);
        return _S(t) || Number.isNaN(t) || t === 1 / 0 || t === -1 / 0 ? (hi.encodeStream(e, 25), SI.encodeStream(e, t)) : Math.fround(t) === t ? (hi.encodeStream(e, 26), xr.F32BE.encodeStream(e, t)) : (hi.encodeStream(e, 27), xr.F64BE.encodeStream(e, t));
    },
    decodeStream (e) {
        const t = hi.decodeStream(e);
        if (t === 20) return !1;
        if (t === 21) return !0;
        if (t === 22) return null;
        if (t !== 23) {
            if (t === 25) return SI.decodeStream(e);
            if (t === 26) return xr.F32BE.decodeStream(e);
            if (t === 27) return xr.F64BE.decodeStream(e);
            throw e.err("cbor/simple: unassigned");
        }
    }
}), Xu = xr.mappedTag(xr.bits(3), {
    uint: [
        0,
        xm
    ],
    // An unsigned integer in the range 0..264-1 inclusive.
    negint: [
        1,
        sce
    ],
    // A negative integer in the range -264..-1 inclusive
    bytes: [
        2,
        xr.lazy(()=>TI(xr.bytes, Xu))
    ],
    // A byte string.
    string: [
        3,
        xr.lazy(()=>TI(xr.string, Xu))
    ],
    // A text string (utf8)
    array: [
        4,
        AI(xr.lazy(()=>Xu))
    ],
    // An array of data items
    map: [
        5,
        xr.lazy(()=>AI(xr.tuple([
                Xu,
                Xu
            ])))
    ],
    // A map of pairs of data items
    tag: [
        6,
        xr.tuple([
            xm,
            xr.lazy(()=>Xu)
        ])
    ],
    // A tagged data item ("tag") whose tag number
    simple: [
        7,
        ace
    ]
});
s1.CBOR = xr.apply(Xu, {
    encode (e) {
        let t = e.data;
        if (e.TAG === "bytes") {
            if (uy.utils.isBytes(t)) return t;
            const r = [];
            if (!Array.isArray(t)) throw new Error(`CBOR: wrong indefinite-length bytestring=${t}`);
            for (const n of t){
                if (n.TAG !== "bytes" || !uy.utils.isBytes(n.data)) throw new Error(`CBOR: wrong indefinite-length bytestring=${n}`);
                r.push(n.data);
            }
            return uy.utils.concatBytes(...r);
        }
        if (e.TAG === "string") {
            if (typeof t == "string") return t;
            if (!Array.isArray(t)) throw new Error(`CBOR: wrong indefinite-length string=${t}`);
            let r = "";
            for (const n of t){
                if (n.TAG !== "string" || typeof n.data != "string") throw new Error(`CBOR: wrong indefinite-length string=${n}`);
                r += n.data;
            }
            return r;
        }
        if (e.TAG === "array" && Array.isArray(t) && (t = t.map((r)=>this.encode(r))), e.TAG === "map" && typeof t == "object" && t !== null) return Object.fromEntries(e.data.map(([r, n])=>[
                this.encode(r),
                this.encode(n)
            ]));
        if (e.TAG === "tag") throw new Error("not implemented");
        return t;
    },
    decode (e) {
        if (typeof e == "bigint") return e < 0n ? {
            TAG: "negint",
            data: e
        } : {
            TAG: "uint",
            data: e
        };
        if (typeof e == "string") return {
            TAG: "string",
            data: e
        };
        if (uy.utils.isBytes(e)) return {
            TAG: "bytes",
            data: e
        };
        if (Array.isArray(e)) return {
            TAG: "array",
            data: e.map((t)=>this.decode(t))
        };
        if (typeof e == "number" && Number.isSafeInteger(e) && !_S(e)) return e < 0 ? {
            TAG: "negint",
            data: e
        } : {
            TAG: "uint",
            data: e
        };
        if (typeof e == "boolean" || typeof e == "number" || e === null || e === void 0) return {
            TAG: "simple",
            data: e
        };
        if (typeof e == "object") return {
            TAG: "map",
            data: Object.entries(e).map((t)=>t.map((r)=>this.decode(r)))
        };
        throw new Error("unknown type");
    }
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(D, H, K, re) {
        re === void 0 && (re = K);
        var Q = Object.getOwnPropertyDescriptor(H, K);
        (!Q || ("get" in Q ? !H.__esModule : Q.writable || Q.configurable)) && (Q = {
            enumerable: !0,
            get: function() {
                return H[K];
            }
        }), Object.defineProperty(D, re, Q);
    } : function(D, H, K, re) {
        re === void 0 && (re = K), D[re] = H[K];
    }), r = Ge && Ge.__setModuleDefault || (Object.create ? function(D, H) {
        Object.defineProperty(D, "default", {
            enumerable: !0,
            value: H
        });
    } : function(D, H) {
        D.default = H;
    }), n = Ge && Ge.__importStar || function(D) {
        if (D && D.__esModule) return D;
        var H = {};
        if (D != null) for(var K in D)K !== "default" && Object.prototype.hasOwnProperty.call(D, K) && t(H, D, K);
        return r(H, D), H;
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.__test__ = e.OutOrdinalReveal = e.InscriptionId = void 0, e.parseInscriptions = O, e.parseWitness = N, e.p2tr_ord_reveal = U;
    const i = bS, o = n(wS), s = vS, a = s1, u = /* @__PURE__ */ i.utf8.decode("BIN");
    function f(D) {
        const H = [];
        for(let K = 0; K < D.length; K += s.MAX_SCRIPT_BYTE_LENGTH)H.push(D.subarray(K, K + s.MAX_SCRIPT_BYTE_LENGTH));
        return H;
    }
    const c = /* @__PURE__ */ o.tuple([
        o.bytes(32, !0),
        o.apply(o.bigint(4, !0, !1, !1), o.coders.numberBigint)
    ]);
    e.InscriptionId = {
        encode (D) {
            const [H, K] = D.split("i", 2);
            if (`${+K}` !== K) throw new Error(`InscriptionId wrong index: ${K}`);
            return c.encode([
                i.hex.decode(H),
                +K
            ]);
        },
        decode (D) {
            const [H, K] = c.decode(D);
            return `${i.hex.encode(H)}i${K}`;
        }
    };
    const l = {
        // Would be simpler to have body tag here,
        // but body chunks don't have body tag near them
        contentType: 1,
        pointer: 2,
        parent: 3,
        metadata: 5,
        metaprotocol: 7,
        contentEncoding: 9,
        delegate: 11,
        rune: 13,
        note: 15
    }, p = /* @__PURE__ */ o.map(o.U8, l), y = {
        pointer: o.bigint(8, !0, !1, !1),
        // U64
        contentType: o.string(null),
        parent: e.InscriptionId,
        metadata: a.CBOR,
        metaprotocol: o.string(null),
        contentEncoding: o.string(null),
        delegate: e.InscriptionId,
        rune: o.bigint(16, !0, !1, !1),
        // U128
        note: o.string(null)
    }, _ = {
        encode (D) {
            const H = {}, K = [];
            for (const { tag: Q, data: G } of D)try {
                const R = p.decode(Q);
                H[R] || (H[R] = []), H[R].push(G);
            } catch  {
                K.push([
                    Q,
                    G
                ]);
            }
            const re = {};
            K.length && (re.unknown = K);
            for(const Q in H){
                if (Q === "parent" && H[Q].length > 1) {
                    re[Q] = H[Q].map((G)=>y.parent.decode(G));
                    continue;
                }
                re[Q] = y[Q].decode(s.utils.concatBytes(...H[Q]));
            }
            return re;
        },
        decode (D) {
            const H = [];
            for(const K in D){
                if (K === "unknown") continue;
                const re = p.encode(K);
                if (K === "parent" && Array.isArray(D.parent)) {
                    for (const G of D.parent)H.push({
                        tag: re,
                        data: y.parent.encode(G)
                    });
                    continue;
                }
                const Q = y[K].encode(D[K]);
                for (const G of f(Q))H.push({
                    tag: re,
                    data: G
                });
            }
            if (D.unknown) {
                if (!Array.isArray(D.unknown)) throw new Error("ordinals/TagCoder: unknown should be array");
                for (const [K, re] of D.unknown)H.push({
                    tag: K,
                    data: re
                });
            }
            return H;
        }
    }, A = (D, H = 0)=>{
        if (!Number.isSafeInteger(H)) throw new Error(`parseInscription: wrong pos=${typeof H}`);
        const K = [];
        let re = !1;
        e: for(; H < D.length; H++){
            if (D[H] !== 0) continue;
            if (D[H + 1] !== "IF") {
                D[H + 1] === 0 && (re = !0);
                continue e;
            }
            if (!s.utils.isBytes(D[H + 2]) || !o.utils.equalBytes(D[H + 2], u)) {
                D[H + 2] === 0 && (re = !0);
                continue e;
            }
            let G = !1;
            const R = [];
            for(let X = H + 3; X < D.length; X++){
                const $ = D[X];
                if ($ === "ENDIF") {
                    K.push({
                        start: H + 3,
                        end: X,
                        pushnum: G,
                        payload: R,
                        stutter: re
                    }), H = X;
                    break;
                }
                if ($ === "1NEGATE") {
                    G = !0, R.push(new Uint8Array([
                        129
                    ]));
                    continue;
                }
                if (typeof $ == "number" && 1 <= $ && $ <= 16) {
                    G = !0, R.push(new Uint8Array([
                        $
                    ]));
                    continue;
                }
                if (s.utils.isBytes($) || $ === 0) {
                    R.push($);
                    continue;
                }
                re = !1;
                break;
            }
        }
        return K;
    };
    function O(D, H = !1) {
        if (H && (!s.utils.isBytes(D[0]) || D[0].length !== 32) || H && D[1] !== "CHECKSIG") return;
        const K = A(D), re = [];
        let Q = 5;
        for (const G of K){
            if (H && (G.stutter || G.pushnum) || H && G.start !== Q) return;
            const { payload: R } = G;
            let X = 0;
            const $ = [];
            for(; X < R.length && R[X] !== 0; X += 2){
                const w = R[X], g = R[X + 1];
                if (!s.utils.isBytes(w)) throw new Error("parseInscription: non-bytes tag");
                if (!s.utils.isBytes(g)) throw new Error("parseInscription: non-bytes tag data");
                $.push({
                    tag: w,
                    data: g
                });
            }
            for(; R[X] === 0 && X < R.length;)X++;
            const S = [];
            for(; X < R.length && s.utils.isBytes(R[X]); X++)S.push(R[X]);
            re.push({
                tags: _.encode($),
                body: s.utils.concatBytes(...S),
                cursed: G.pushnum || G.stutter
            }), Q = G.end + 4;
        }
        if (Q - 3 === D.length) return re;
    }
    function N(D) {
        if (D.length !== 3) throw new Error("Wrong witness");
        return O(s.Script.decode(D[1]));
    }
    e.OutOrdinalReveal = {
        encode (D) {
            const H = {
                type: "tr_ord_reveal"
            };
            try {
                H.inscriptions = O(D, !0), H.pubkey = D[0];
            } catch  {
                return;
            }
            return H;
        },
        decode: (D)=>{
            if (D.type !== "tr_ord_reveal") return;
            const H = [
                D.pubkey,
                "CHECKSIG"
            ];
            for (const { tags: K, body: re } of D.inscriptions){
                H.push(0, "IF", u);
                const Q = _.decode(K);
                for (const G of Q)H.push(G.tag, G.data);
                H.push(0);
                for (const G of f(re))H.push(G);
                H.push("ENDIF");
            }
            return H;
        },
        finalizeTaproot: (D, H, K)=>{
            if (K.length !== 1) throw new Error("tr_ord_reveal/finalize: wrong signatures array");
            const [{ pubKey: re }, Q] = K[0];
            if (o.utils.equalBytes(re, H.pubkey)) return [
                Q,
                D
            ];
        }
    };
    function U(D, H) {
        return {
            type: "tr_ord_reveal",
            script: o.apply(s.Script, o.coders.match([
                e.OutOrdinalReveal
            ])).encode({
                type: "tr_ord_reveal",
                pubkey: D,
                inscriptions: H
            })
        };
    }
    e.__test__ = {
        TagCoders: y,
        TagCoder: _,
        parseEnvelopes: A
    };
})(eM);
var uM = {}, _0 = {};
Object.defineProperty(_0, "__esModule", {
    value: !0
});
_0.AbstractProvider = void 0;
class cce {
}
_0.AbstractProvider = cce;
var E0 = {};
Object.defineProperty(E0, "__esModule", {
    value: !0
});
E0.AbstractSigner = void 0;
class uce {
}
E0.AbstractSigner = uce;
var a1 = {};
Object.defineProperty(a1, "__esModule", {
    value: !0
});
a1.Signer = void 0;
const fce = E0;
let lce = class extends fce.AbstractSigner {
    static from(t) {
        return new this(t, null);
    }
    connect(t) {
        return new this.constructor(this._target, t);
    }
    constructor(t, r){
        super(), this._target = t, this._provider = r;
    }
    get provider() {
        return this._provider;
    }
    async signPsbt(...t) {
        return await this._target.signPsbt(...t);
    }
    async signMessage(...t) {
        return await this._target.signMessage(...t);
    }
};
a1.Signer = lce;
var c1 = {}, Sm = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ Sm.exports;
(function(e, t) {
    (function() {
        var r, n = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", a = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", f = 500, c = "__lodash_placeholder__", l = 1, p = 2, y = 4, _ = 1, A = 2, O = 1, N = 2, U = 4, D = 8, H = 16, K = 32, re = 64, Q = 128, G = 256, R = 512, X = 30, $ = "...", S = 800, w = 16, g = 1, m = 2, E = 3, T = 1 / 0, I = 9007199254740991, P = 17976931348623157e292, k = NaN, L = 4294967295, j = L - 1, ie = L >>> 1, ue = [
            [
                "ary",
                Q
            ],
            [
                "bind",
                O
            ],
            [
                "bindKey",
                N
            ],
            [
                "curry",
                D
            ],
            [
                "curryRight",
                H
            ],
            [
                "flip",
                R
            ],
            [
                "partial",
                K
            ],
            [
                "partialRight",
                re
            ],
            [
                "rearg",
                G
            ]
        ], ce = "[object Arguments]", he = "[object Array]", ee = "[object AsyncFunction]", ae = "[object Boolean]", ye = "[object Date]", Se = "[object DOMException]", De = "[object Error]", Re = "[object Function]", Ce = "[object GeneratorFunction]", M = "[object Map]", z = "[object Number]", de = "[object Null]", _e = "[object Object]", Ie = "[object Promise]", je = "[object Proxy]", Ke = "[object RegExp]", Ue = "[object Set]", h = "[object String]", x = "[object Symbol]", q = "[object Undefined]", te = "[object WeakMap]", fe = "[object WeakSet]", ne = "[object ArrayBuffer]", W = "[object DataView]", J = "[object Float32Array]", V = "[object Float64Array]", C = "[object Int8Array]", Z = "[object Int16Array]", le = "[object Int32Array]", se = "[object Uint8Array]", Ne = "[object Uint8ClampedArray]", Le = "[object Uint16Array]", rt = "[object Uint32Array]", yt = /\b__p \+= '';/g, _t = /\b(__p \+=) '' \+/g, Qe = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Rt = /&(?:amp|lt|gt|quot|#39);/g, Lt = /[&<>"']/g, Ur = RegExp(Rt.source), jr = RegExp(Lt.source), Et = /<%-([\s\S]+?)%>/g, Xt = /<%([\s\S]+?)%>/g, wr = /<%=([\s\S]+?)%>/g, zt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ae = /^\w*$/, we = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xe = /[\\^$.*+?()[\]{}|]/g, Me = RegExp(xe.source), ze = /^\s+/, Ve = /\s/, at = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ct = /\{\n\/\* \[wrapped with (.+)\] \*/, lt = /,? & /, mt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, wt = /[()=,{}\[\]\/\s]/, bt = /\\(\\)?/g, Mt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ct = /\w*$/, Xe = /^[-+]0x[0-9a-f]+$/i, xt = /^0b[01]+$/i, St = /^\[object .+?Constructor\]$/, Pe = /^0o[0-7]+$/i, et = /^(?:0|[1-9]\d*)$/, vt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, be = /($^)/, $r = /['\n\r\u2028\u2029\\]/g, jt = "\\ud800-\\udfff", nr = "\\u0300-\\u036f", kt = "\\ufe20-\\ufe2f", Hn = "\\u20d0-\\u20ff", Zr = nr + kt + Hn, v = "\\u2700-\\u27bf", B = "a-z\\xdf-\\xf6\\xf8-\\xff", Y = "\\xac\\xb1\\xd7\\xf7", pe = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ke = "\\u2000-\\u206f", qe = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ut = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ft = "\\ufe0e\\ufe0f", pn = Y + pe + ke + qe, bs = "['’]", M0 = "[" + jt + "]", u8 = "[" + pn + "]", R0 = "[" + Zr + "]", f8 = "\\d+", CU = "[" + v + "]", l8 = "[" + B + "]", d8 = "[^" + jt + pn + f8 + v + B + ut + "]", O1 = "\\ud83c[\\udffb-\\udfff]", UU = "(?:" + R0 + "|" + O1 + ")", h8 = "[^" + jt + "]", P1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", N1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Vf = "[" + ut + "]", p8 = "\\u200d", g8 = "(?:" + l8 + "|" + d8 + ")", $U = "(?:" + Vf + "|" + d8 + ")", y8 = "(?:" + bs + "(?:d|ll|m|re|s|t|ve))?", m8 = "(?:" + bs + "(?:D|LL|M|RE|S|T|VE))?", b8 = UU + "?", w8 = "[" + Ft + "]?", LU = "(?:" + p8 + "(?:" + [
            h8,
            P1,
            N1
        ].join("|") + ")" + w8 + b8 + ")*", DU = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", FU = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", v8 = w8 + b8 + LU, zU = "(?:" + [
            CU,
            P1,
            N1
        ].join("|") + ")" + v8, jU = "(?:" + [
            h8 + R0 + "?",
            R0,
            P1,
            N1,
            M0
        ].join("|") + ")", HU = RegExp(bs, "g"), qU = RegExp(R0, "g"), M1 = RegExp(O1 + "(?=" + O1 + ")|" + jU + v8, "g"), KU = RegExp([
            Vf + "?" + l8 + "+" + y8 + "(?=" + [
                u8,
                Vf,
                "$"
            ].join("|") + ")",
            $U + "+" + m8 + "(?=" + [
                u8,
                Vf + g8,
                "$"
            ].join("|") + ")",
            Vf + "?" + g8 + "+" + y8,
            Vf + "+" + m8,
            FU,
            DU,
            f8,
            zU
        ].join("|"), "g"), WU = RegExp("[" + p8 + jt + Zr + Ft + "]"), VU = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, GU = [
            "Array",
            "Buffer",
            "DataView",
            "Date",
            "Error",
            "Float32Array",
            "Float64Array",
            "Function",
            "Int8Array",
            "Int16Array",
            "Int32Array",
            "Map",
            "Math",
            "Object",
            "Promise",
            "RegExp",
            "Set",
            "String",
            "Symbol",
            "TypeError",
            "Uint8Array",
            "Uint8ClampedArray",
            "Uint16Array",
            "Uint32Array",
            "WeakMap",
            "_",
            "clearTimeout",
            "isFinite",
            "parseInt",
            "setTimeout"
        ], ZU = -1, dn = {};
        dn[J] = dn[V] = dn[C] = dn[Z] = dn[le] = dn[se] = dn[Ne] = dn[Le] = dn[rt] = !0, dn[ce] = dn[he] = dn[ne] = dn[ae] = dn[W] = dn[ye] = dn[De] = dn[Re] = dn[M] = dn[z] = dn[_e] = dn[Ke] = dn[Ue] = dn[h] = dn[te] = !1;
        var cn = {};
        cn[ce] = cn[he] = cn[ne] = cn[W] = cn[ae] = cn[ye] = cn[J] = cn[V] = cn[C] = cn[Z] = cn[le] = cn[M] = cn[z] = cn[_e] = cn[Ke] = cn[Ue] = cn[h] = cn[x] = cn[se] = cn[Ne] = cn[Le] = cn[rt] = !0, cn[De] = cn[Re] = cn[te] = !1;
        var YU = {
            // Latin-1 Supplement block.
            À: "A",
            Á: "A",
            Â: "A",
            Ã: "A",
            Ä: "A",
            Å: "A",
            à: "a",
            á: "a",
            â: "a",
            ã: "a",
            ä: "a",
            å: "a",
            Ç: "C",
            ç: "c",
            Ð: "D",
            ð: "d",
            È: "E",
            É: "E",
            Ê: "E",
            Ë: "E",
            è: "e",
            é: "e",
            ê: "e",
            ë: "e",
            Ì: "I",
            Í: "I",
            Î: "I",
            Ï: "I",
            ì: "i",
            í: "i",
            î: "i",
            ï: "i",
            Ñ: "N",
            ñ: "n",
            Ò: "O",
            Ó: "O",
            Ô: "O",
            Õ: "O",
            Ö: "O",
            Ø: "O",
            ò: "o",
            ó: "o",
            ô: "o",
            õ: "o",
            ö: "o",
            ø: "o",
            Ù: "U",
            Ú: "U",
            Û: "U",
            Ü: "U",
            ù: "u",
            ú: "u",
            û: "u",
            ü: "u",
            Ý: "Y",
            ý: "y",
            ÿ: "y",
            Æ: "Ae",
            æ: "ae",
            Þ: "Th",
            þ: "th",
            ß: "ss",
            // Latin Extended-A block.
            Ā: "A",
            Ă: "A",
            Ą: "A",
            ā: "a",
            ă: "a",
            ą: "a",
            Ć: "C",
            Ĉ: "C",
            Ċ: "C",
            Č: "C",
            ć: "c",
            ĉ: "c",
            ċ: "c",
            č: "c",
            Ď: "D",
            Đ: "D",
            ď: "d",
            đ: "d",
            Ē: "E",
            Ĕ: "E",
            Ė: "E",
            Ę: "E",
            Ě: "E",
            ē: "e",
            ĕ: "e",
            ė: "e",
            ę: "e",
            ě: "e",
            Ĝ: "G",
            Ğ: "G",
            Ġ: "G",
            Ģ: "G",
            ĝ: "g",
            ğ: "g",
            ġ: "g",
            ģ: "g",
            Ĥ: "H",
            Ħ: "H",
            ĥ: "h",
            ħ: "h",
            Ĩ: "I",
            Ī: "I",
            Ĭ: "I",
            Į: "I",
            İ: "I",
            ĩ: "i",
            ī: "i",
            ĭ: "i",
            į: "i",
            ı: "i",
            Ĵ: "J",
            ĵ: "j",
            Ķ: "K",
            ķ: "k",
            ĸ: "k",
            Ĺ: "L",
            Ļ: "L",
            Ľ: "L",
            Ŀ: "L",
            Ł: "L",
            ĺ: "l",
            ļ: "l",
            ľ: "l",
            ŀ: "l",
            ł: "l",
            Ń: "N",
            Ņ: "N",
            Ň: "N",
            Ŋ: "N",
            ń: "n",
            ņ: "n",
            ň: "n",
            ŋ: "n",
            Ō: "O",
            Ŏ: "O",
            Ő: "O",
            ō: "o",
            ŏ: "o",
            ő: "o",
            Ŕ: "R",
            Ŗ: "R",
            Ř: "R",
            ŕ: "r",
            ŗ: "r",
            ř: "r",
            Ś: "S",
            Ŝ: "S",
            Ş: "S",
            Š: "S",
            ś: "s",
            ŝ: "s",
            ş: "s",
            š: "s",
            Ţ: "T",
            Ť: "T",
            Ŧ: "T",
            ţ: "t",
            ť: "t",
            ŧ: "t",
            Ũ: "U",
            Ū: "U",
            Ŭ: "U",
            Ů: "U",
            Ű: "U",
            Ų: "U",
            ũ: "u",
            ū: "u",
            ŭ: "u",
            ů: "u",
            ű: "u",
            ų: "u",
            Ŵ: "W",
            ŵ: "w",
            Ŷ: "Y",
            ŷ: "y",
            Ÿ: "Y",
            Ź: "Z",
            Ż: "Z",
            Ž: "Z",
            ź: "z",
            ż: "z",
            ž: "z",
            Ĳ: "IJ",
            ĳ: "ij",
            Œ: "Oe",
            œ: "oe",
            ŉ: "'n",
            ſ: "s"
        }, XU = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, JU = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        }, QU = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        }, e$ = parseFloat, t$ = parseInt, _8 = typeof Ge == "object" && Ge && Ge.Object === Object && Ge, r$ = typeof self == "object" && self && self.Object === Object && self, ci = _8 || r$ || Function("return this")(), R1 = t && !t.nodeType && t, Mu = R1 && !0 && e && !e.nodeType && e, E8 = Mu && Mu.exports === R1, C1 = E8 && _8.process, Fo = function() {
            try {
                var Fe = Mu && Mu.require && Mu.require("util").types;
                return Fe || C1 && C1.binding && C1.binding("util");
            } catch  {}
        }(), x8 = Fo && Fo.isArrayBuffer, S8 = Fo && Fo.isDate, A8 = Fo && Fo.isMap, T8 = Fo && Fo.isRegExp, k8 = Fo && Fo.isSet, I8 = Fo && Fo.isTypedArray;
        function bo(Fe, tt, Ye) {
            switch(Ye.length){
                case 0:
                    return Fe.call(tt);
                case 1:
                    return Fe.call(tt, Ye[0]);
                case 2:
                    return Fe.call(tt, Ye[0], Ye[1]);
                case 3:
                    return Fe.call(tt, Ye[0], Ye[1], Ye[2]);
            }
            return Fe.apply(tt, Ye);
        }
        function n$(Fe, tt, Ye, Pt) {
            for(var sr = -1, Wr = Fe == null ? 0 : Fe.length; ++sr < Wr;){
                var qn = Fe[sr];
                tt(Pt, qn, Ye(qn), Fe);
            }
            return Pt;
        }
        function zo(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length; ++Ye < Pt && tt(Fe[Ye], Ye, Fe) !== !1;);
            return Fe;
        }
        function i$(Fe, tt) {
            for(var Ye = Fe == null ? 0 : Fe.length; Ye-- && tt(Fe[Ye], Ye, Fe) !== !1;);
            return Fe;
        }
        function B8(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length; ++Ye < Pt;)if (!tt(Fe[Ye], Ye, Fe)) return !1;
            return !0;
        }
        function wc(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length, sr = 0, Wr = []; ++Ye < Pt;){
                var qn = Fe[Ye];
                tt(qn, Ye, Fe) && (Wr[sr++] = qn);
            }
            return Wr;
        }
        function C0(Fe, tt) {
            var Ye = Fe == null ? 0 : Fe.length;
            return !!Ye && Gf(Fe, tt, 0) > -1;
        }
        function U1(Fe, tt, Ye) {
            for(var Pt = -1, sr = Fe == null ? 0 : Fe.length; ++Pt < sr;)if (Ye(tt, Fe[Pt])) return !0;
            return !1;
        }
        function gn(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length, sr = Array(Pt); ++Ye < Pt;)sr[Ye] = tt(Fe[Ye], Ye, Fe);
            return sr;
        }
        function vc(Fe, tt) {
            for(var Ye = -1, Pt = tt.length, sr = Fe.length; ++Ye < Pt;)Fe[sr + Ye] = tt[Ye];
            return Fe;
        }
        function $1(Fe, tt, Ye, Pt) {
            var sr = -1, Wr = Fe == null ? 0 : Fe.length;
            for(Pt && Wr && (Ye = Fe[++sr]); ++sr < Wr;)Ye = tt(Ye, Fe[sr], sr, Fe);
            return Ye;
        }
        function o$(Fe, tt, Ye, Pt) {
            var sr = Fe == null ? 0 : Fe.length;
            for(Pt && sr && (Ye = Fe[--sr]); sr--;)Ye = tt(Ye, Fe[sr], sr, Fe);
            return Ye;
        }
        function L1(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length; ++Ye < Pt;)if (tt(Fe[Ye], Ye, Fe)) return !0;
            return !1;
        }
        var s$ = D1("length");
        function a$(Fe) {
            return Fe.split("");
        }
        function c$(Fe) {
            return Fe.match(mt) || [];
        }
        function O8(Fe, tt, Ye) {
            var Pt;
            return Ye(Fe, function(sr, Wr, qn) {
                if (tt(sr, Wr, qn)) return Pt = Wr, !1;
            }), Pt;
        }
        function U0(Fe, tt, Ye, Pt) {
            for(var sr = Fe.length, Wr = Ye + (Pt ? 1 : -1); Pt ? Wr-- : ++Wr < sr;)if (tt(Fe[Wr], Wr, Fe)) return Wr;
            return -1;
        }
        function Gf(Fe, tt, Ye) {
            return tt === tt ? v$(Fe, tt, Ye) : U0(Fe, P8, Ye);
        }
        function u$(Fe, tt, Ye, Pt) {
            for(var sr = Ye - 1, Wr = Fe.length; ++sr < Wr;)if (Pt(Fe[sr], tt)) return sr;
            return -1;
        }
        function P8(Fe) {
            return Fe !== Fe;
        }
        function N8(Fe, tt) {
            var Ye = Fe == null ? 0 : Fe.length;
            return Ye ? z1(Fe, tt) / Ye : k;
        }
        function D1(Fe) {
            return function(tt) {
                return tt == null ? r : tt[Fe];
            };
        }
        function F1(Fe) {
            return function(tt) {
                return Fe == null ? r : Fe[tt];
            };
        }
        function M8(Fe, tt, Ye, Pt, sr) {
            return sr(Fe, function(Wr, qn, an) {
                Ye = Pt ? (Pt = !1, Wr) : tt(Ye, Wr, qn, an);
            }), Ye;
        }
        function f$(Fe, tt) {
            var Ye = Fe.length;
            for(Fe.sort(tt); Ye--;)Fe[Ye] = Fe[Ye].value;
            return Fe;
        }
        function z1(Fe, tt) {
            for(var Ye, Pt = -1, sr = Fe.length; ++Pt < sr;){
                var Wr = tt(Fe[Pt]);
                Wr !== r && (Ye = Ye === r ? Wr : Ye + Wr);
            }
            return Ye;
        }
        function j1(Fe, tt) {
            for(var Ye = -1, Pt = Array(Fe); ++Ye < Fe;)Pt[Ye] = tt(Ye);
            return Pt;
        }
        function l$(Fe, tt) {
            return gn(tt, function(Ye) {
                return [
                    Ye,
                    Fe[Ye]
                ];
            });
        }
        function R8(Fe) {
            return Fe && Fe.slice(0, L8(Fe) + 1).replace(ze, "");
        }
        function wo(Fe) {
            return function(tt) {
                return Fe(tt);
            };
        }
        function H1(Fe, tt) {
            return gn(tt, function(Ye) {
                return Fe[Ye];
            });
        }
        function Gd(Fe, tt) {
            return Fe.has(tt);
        }
        function C8(Fe, tt) {
            for(var Ye = -1, Pt = Fe.length; ++Ye < Pt && Gf(tt, Fe[Ye], 0) > -1;);
            return Ye;
        }
        function U8(Fe, tt) {
            for(var Ye = Fe.length; Ye-- && Gf(tt, Fe[Ye], 0) > -1;);
            return Ye;
        }
        function d$(Fe, tt) {
            for(var Ye = Fe.length, Pt = 0; Ye--;)Fe[Ye] === tt && ++Pt;
            return Pt;
        }
        var h$ = F1(YU), p$ = F1(XU);
        function g$(Fe) {
            return "\\" + QU[Fe];
        }
        function y$(Fe, tt) {
            return Fe == null ? r : Fe[tt];
        }
        function Zf(Fe) {
            return WU.test(Fe);
        }
        function m$(Fe) {
            return VU.test(Fe);
        }
        function b$(Fe) {
            for(var tt, Ye = []; !(tt = Fe.next()).done;)Ye.push(tt.value);
            return Ye;
        }
        function q1(Fe) {
            var tt = -1, Ye = Array(Fe.size);
            return Fe.forEach(function(Pt, sr) {
                Ye[++tt] = [
                    sr,
                    Pt
                ];
            }), Ye;
        }
        function $8(Fe, tt) {
            return function(Ye) {
                return Fe(tt(Ye));
            };
        }
        function _c(Fe, tt) {
            for(var Ye = -1, Pt = Fe.length, sr = 0, Wr = []; ++Ye < Pt;){
                var qn = Fe[Ye];
                (qn === tt || qn === c) && (Fe[Ye] = c, Wr[sr++] = Ye);
            }
            return Wr;
        }
        function $0(Fe) {
            var tt = -1, Ye = Array(Fe.size);
            return Fe.forEach(function(Pt) {
                Ye[++tt] = Pt;
            }), Ye;
        }
        function w$(Fe) {
            var tt = -1, Ye = Array(Fe.size);
            return Fe.forEach(function(Pt) {
                Ye[++tt] = [
                    Pt,
                    Pt
                ];
            }), Ye;
        }
        function v$(Fe, tt, Ye) {
            for(var Pt = Ye - 1, sr = Fe.length; ++Pt < sr;)if (Fe[Pt] === tt) return Pt;
            return -1;
        }
        function _$(Fe, tt, Ye) {
            for(var Pt = Ye + 1; Pt--;)if (Fe[Pt] === tt) return Pt;
            return Pt;
        }
        function Yf(Fe) {
            return Zf(Fe) ? x$(Fe) : s$(Fe);
        }
        function ws(Fe) {
            return Zf(Fe) ? S$(Fe) : a$(Fe);
        }
        function L8(Fe) {
            for(var tt = Fe.length; tt-- && Ve.test(Fe.charAt(tt)););
            return tt;
        }
        var E$ = F1(JU);
        function x$(Fe) {
            for(var tt = M1.lastIndex = 0; M1.test(Fe);)++tt;
            return tt;
        }
        function S$(Fe) {
            return Fe.match(M1) || [];
        }
        function A$(Fe) {
            return Fe.match(KU) || [];
        }
        var T$ = function Fe(tt) {
            tt = tt == null ? ci : Xf.defaults(ci.Object(), tt, Xf.pick(ci, GU));
            var Ye = tt.Array, Pt = tt.Date, sr = tt.Error, Wr = tt.Function, qn = tt.Math, an = tt.Object, K1 = tt.RegExp, k$ = tt.String, jo = tt.TypeError, L0 = Ye.prototype, I$ = Wr.prototype, Jf = an.prototype, D0 = tt["__core-js_shared__"], F0 = I$.toString, Qr = Jf.hasOwnProperty, B$ = 0, D8 = function() {
                var d = /[^.]+$/.exec(D0 && D0.keys && D0.keys.IE_PROTO || "");
                return d ? "Symbol(src)_1." + d : "";
            }(), z0 = Jf.toString, O$ = F0.call(an), P$ = ci._, N$ = K1("^" + F0.call(Qr).replace(xe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), j0 = E8 ? tt.Buffer : r, Ec = tt.Symbol, H0 = tt.Uint8Array, F8 = j0 ? j0.allocUnsafe : r, q0 = $8(an.getPrototypeOf, an), z8 = an.create, j8 = Jf.propertyIsEnumerable, K0 = L0.splice, H8 = Ec ? Ec.isConcatSpreadable : r, Zd = Ec ? Ec.iterator : r, Ru = Ec ? Ec.toStringTag : r, W0 = function() {
                try {
                    var d = Du(an, "defineProperty");
                    return d({}, "", {}), d;
                } catch  {}
            }(), M$ = tt.clearTimeout !== ci.clearTimeout && tt.clearTimeout, R$ = Pt && Pt.now !== ci.Date.now && Pt.now, C$ = tt.setTimeout !== ci.setTimeout && tt.setTimeout, V0 = qn.ceil, G0 = qn.floor, W1 = an.getOwnPropertySymbols, U$ = j0 ? j0.isBuffer : r, q8 = tt.isFinite, $$ = L0.join, L$ = $8(an.keys, an), Kn = qn.max, vi = qn.min, D$ = Pt.now, F$ = tt.parseInt, K8 = qn.random, z$ = L0.reverse, V1 = Du(tt, "DataView"), Yd = Du(tt, "Map"), G1 = Du(tt, "Promise"), Qf = Du(tt, "Set"), Xd = Du(tt, "WeakMap"), Jd = Du(an, "create"), Z0 = Xd && new Xd(), el = {}, j$ = Fu(V1), H$ = Fu(Yd), q$ = Fu(G1), K$ = Fu(Qf), W$ = Fu(Xd), Y0 = Ec ? Ec.prototype : r, Qd = Y0 ? Y0.valueOf : r, W8 = Y0 ? Y0.toString : r;
            function me(d) {
                if (On(d) && !ur(d) && !(d instanceof Rr)) {
                    if (d instanceof Ho) return d;
                    if (Qr.call(d, "__wrapped__")) return V6(d);
                }
                return new Ho(d);
            }
            var tl = /* @__PURE__ */ function() {
                function d() {}
                return function(b) {
                    if (!wn(b)) return {};
                    if (z8) return z8(b);
                    d.prototype = b;
                    var F = new d();
                    return d.prototype = r, F;
                };
            }();
            function X0() {}
            function Ho(d, b) {
                this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!b, this.__index__ = 0, this.__values__ = r;
            }
            me.templateSettings = {
                /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ escape: Et,
                /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ evaluate: Xt,
                /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ interpolate: wr,
                /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */ variable: "",
                /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */ imports: {
                    /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */ _: me
                }
            }, me.prototype = X0.prototype, me.prototype.constructor = me, Ho.prototype = tl(X0.prototype), Ho.prototype.constructor = Ho;
            function Rr(d) {
                this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = L, this.__views__ = [];
            }
            function V$() {
                var d = new Rr(this.__wrapped__);
                return d.__actions__ = Yi(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = Yi(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = Yi(this.__views__), d;
            }
            function G$() {
                if (this.__filtered__) {
                    var d = new Rr(this);
                    d.__dir__ = -1, d.__filtered__ = !0;
                } else d = this.clone(), d.__dir__ *= -1;
                return d;
            }
            function Z$() {
                var d = this.__wrapped__.value(), b = this.__dir__, F = ur(d), oe = b < 0, ge = F ? d.length : 0, ve = aD(0, ge, this.__views__), Oe = ve.start, $e = ve.end, He = $e - Oe, it = oe ? $e : Oe - 1, st = this.__iteratees__, ft = st.length, At = 0, Ut = vi(He, this.__takeCount__);
                if (!F || !oe && ge == He && Ut == He) return y6(d, this.__actions__);
                var Vt = [];
                e: for(; He-- && At < Ut;){
                    it += b;
                    for(var vr = -1, Gt = d[it]; ++vr < ft;){
                        var Pr = st[vr], Lr = Pr.iteratee, Eo = Pr.type, Fi = Lr(Gt);
                        if (Eo == m) Gt = Fi;
                        else if (!Fi) {
                            if (Eo == g) continue e;
                            break e;
                        }
                    }
                    Vt[At++] = Gt;
                }
                return Vt;
            }
            Rr.prototype = tl(X0.prototype), Rr.prototype.constructor = Rr;
            function Cu(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++b < F;){
                    var oe = d[b];
                    this.set(oe[0], oe[1]);
                }
            }
            function Y$() {
                this.__data__ = Jd ? Jd(null) : {}, this.size = 0;
            }
            function X$(d) {
                var b = this.has(d) && delete this.__data__[d];
                return this.size -= b ? 1 : 0, b;
            }
            function J$(d) {
                var b = this.__data__;
                if (Jd) {
                    var F = b[d];
                    return F === u ? r : F;
                }
                return Qr.call(b, d) ? b[d] : r;
            }
            function Q$(d) {
                var b = this.__data__;
                return Jd ? b[d] !== r : Qr.call(b, d);
            }
            function eL(d, b) {
                var F = this.__data__;
                return this.size += this.has(d) ? 0 : 1, F[d] = Jd && b === r ? u : b, this;
            }
            Cu.prototype.clear = Y$, Cu.prototype.delete = X$, Cu.prototype.get = J$, Cu.prototype.has = Q$, Cu.prototype.set = eL;
            function Oa(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++b < F;){
                    var oe = d[b];
                    this.set(oe[0], oe[1]);
                }
            }
            function tL() {
                this.__data__ = [], this.size = 0;
            }
            function rL(d) {
                var b = this.__data__, F = J0(b, d);
                if (F < 0) return !1;
                var oe = b.length - 1;
                return F == oe ? b.pop() : K0.call(b, F, 1), --this.size, !0;
            }
            function nL(d) {
                var b = this.__data__, F = J0(b, d);
                return F < 0 ? r : b[F][1];
            }
            function iL(d) {
                return J0(this.__data__, d) > -1;
            }
            function oL(d, b) {
                var F = this.__data__, oe = J0(F, d);
                return oe < 0 ? (++this.size, F.push([
                    d,
                    b
                ])) : F[oe][1] = b, this;
            }
            Oa.prototype.clear = tL, Oa.prototype.delete = rL, Oa.prototype.get = nL, Oa.prototype.has = iL, Oa.prototype.set = oL;
            function Pa(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++b < F;){
                    var oe = d[b];
                    this.set(oe[0], oe[1]);
                }
            }
            function sL() {
                this.size = 0, this.__data__ = {
                    hash: new Cu(),
                    map: new (Yd || Oa)(),
                    string: new Cu()
                };
            }
            function aL(d) {
                var b = fg(this, d).delete(d);
                return this.size -= b ? 1 : 0, b;
            }
            function cL(d) {
                return fg(this, d).get(d);
            }
            function uL(d) {
                return fg(this, d).has(d);
            }
            function fL(d, b) {
                var F = fg(this, d), oe = F.size;
                return F.set(d, b), this.size += F.size == oe ? 0 : 1, this;
            }
            Pa.prototype.clear = sL, Pa.prototype.delete = aL, Pa.prototype.get = cL, Pa.prototype.has = uL, Pa.prototype.set = fL;
            function Uu(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.__data__ = new Pa(); ++b < F;)this.add(d[b]);
            }
            function lL(d) {
                return this.__data__.set(d, u), this;
            }
            function dL(d) {
                return this.__data__.has(d);
            }
            Uu.prototype.add = Uu.prototype.push = lL, Uu.prototype.has = dL;
            function vs(d) {
                var b = this.__data__ = new Oa(d);
                this.size = b.size;
            }
            function hL() {
                this.__data__ = new Oa(), this.size = 0;
            }
            function pL(d) {
                var b = this.__data__, F = b.delete(d);
                return this.size = b.size, F;
            }
            function gL(d) {
                return this.__data__.get(d);
            }
            function yL(d) {
                return this.__data__.has(d);
            }
            function mL(d, b) {
                var F = this.__data__;
                if (F instanceof Oa) {
                    var oe = F.__data__;
                    if (!Yd || oe.length < i - 1) return oe.push([
                        d,
                        b
                    ]), this.size = ++F.size, this;
                    F = this.__data__ = new Pa(oe);
                }
                return F.set(d, b), this.size = F.size, this;
            }
            vs.prototype.clear = hL, vs.prototype.delete = pL, vs.prototype.get = gL, vs.prototype.has = yL, vs.prototype.set = mL;
            function V8(d, b) {
                var F = ur(d), oe = !F && zu(d), ge = !F && !oe && kc(d), ve = !F && !oe && !ge && ol(d), Oe = F || oe || ge || ve, $e = Oe ? j1(d.length, k$) : [], He = $e.length;
                for(var it in d)(b || Qr.call(d, it)) && !(Oe && // Safari 9 has enumerable `arguments.length` in strict mode.
                (it == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                ge && (it == "offset" || it == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                ve && (it == "buffer" || it == "byteLength" || it == "byteOffset") || // Skip index properties.
                Ca(it, He))) && $e.push(it);
                return $e;
            }
            function G8(d) {
                var b = d.length;
                return b ? d[ow(0, b - 1)] : r;
            }
            function bL(d, b) {
                return lg(Yi(d), $u(b, 0, d.length));
            }
            function wL(d) {
                return lg(Yi(d));
            }
            function Z1(d, b, F) {
                (F !== r && !_s(d[b], F) || F === r && !(b in d)) && Na(d, b, F);
            }
            function eh(d, b, F) {
                var oe = d[b];
                (!(Qr.call(d, b) && _s(oe, F)) || F === r && !(b in d)) && Na(d, b, F);
            }
            function J0(d, b) {
                for(var F = d.length; F--;)if (_s(d[F][0], b)) return F;
                return -1;
            }
            function vL(d, b, F, oe) {
                return xc(d, function(ge, ve, Oe) {
                    b(oe, ge, F(ge), Oe);
                }), oe;
            }
            function Z8(d, b) {
                return d && Ks(b, ti(b), d);
            }
            function _L(d, b) {
                return d && Ks(b, Ji(b), d);
            }
            function Na(d, b, F) {
                b == "__proto__" && W0 ? W0(d, b, {
                    configurable: !0,
                    enumerable: !0,
                    value: F,
                    writable: !0
                }) : d[b] = F;
            }
            function Y1(d, b) {
                for(var F = -1, oe = b.length, ge = Ye(oe), ve = d == null; ++F < oe;)ge[F] = ve ? r : Ow(d, b[F]);
                return ge;
            }
            function $u(d, b, F) {
                return d === d && (F !== r && (d = d <= F ? d : F), b !== r && (d = d >= b ? d : b)), d;
            }
            function qo(d, b, F, oe, ge, ve) {
                var Oe, $e = b & l, He = b & p, it = b & y;
                if (F && (Oe = ge ? F(d, oe, ge, ve) : F(d)), Oe !== r) return Oe;
                if (!wn(d)) return d;
                var st = ur(d);
                if (st) {
                    if (Oe = uD(d), !$e) return Yi(d, Oe);
                } else {
                    var ft = _i(d), At = ft == Re || ft == Ce;
                    if (kc(d)) return w6(d, $e);
                    if (ft == _e || ft == ce || At && !ge) {
                        if (Oe = He || At ? {} : L6(d), !$e) return He ? JL(d, _L(Oe, d)) : XL(d, Z8(Oe, d));
                    } else {
                        if (!cn[ft]) return ge ? d : {};
                        Oe = fD(d, ft, $e);
                    }
                }
                ve || (ve = new vs());
                var Ut = ve.get(d);
                if (Ut) return Ut;
                ve.set(d, Oe), h4(d) ? d.forEach(function(Gt) {
                    Oe.add(qo(Gt, b, F, Gt, d, ve));
                }) : l4(d) && d.forEach(function(Gt, Pr) {
                    Oe.set(Pr, qo(Gt, b, F, Pr, d, ve));
                });
                var Vt = it ? He ? yw : gw : He ? Ji : ti, vr = st ? r : Vt(d);
                return zo(vr || d, function(Gt, Pr) {
                    vr && (Pr = Gt, Gt = d[Pr]), eh(Oe, Pr, qo(Gt, b, F, Pr, d, ve));
                }), Oe;
            }
            function EL(d) {
                var b = ti(d);
                return function(F) {
                    return Y8(F, d, b);
                };
            }
            function Y8(d, b, F) {
                var oe = F.length;
                if (d == null) return !oe;
                for(d = an(d); oe--;){
                    var ge = F[oe], ve = b[ge], Oe = d[ge];
                    if (Oe === r && !(ge in d) || !ve(Oe)) return !1;
                }
                return !0;
            }
            function X8(d, b, F) {
                if (typeof d != "function") throw new jo(s);
                return ah(function() {
                    d.apply(r, F);
                }, b);
            }
            function th(d, b, F, oe) {
                var ge = -1, ve = C0, Oe = !0, $e = d.length, He = [], it = b.length;
                if (!$e) return He;
                F && (b = gn(b, wo(F))), oe ? (ve = U1, Oe = !1) : b.length >= i && (ve = Gd, Oe = !1, b = new Uu(b));
                e: for(; ++ge < $e;){
                    var st = d[ge], ft = F == null ? st : F(st);
                    if (st = oe || st !== 0 ? st : 0, Oe && ft === ft) {
                        for(var At = it; At--;)if (b[At] === ft) continue e;
                        He.push(st);
                    } else ve(b, ft, oe) || He.push(st);
                }
                return He;
            }
            var xc = S6(qs), J8 = S6(J1, !0);
            function xL(d, b) {
                var F = !0;
                return xc(d, function(oe, ge, ve) {
                    return F = !!b(oe, ge, ve), F;
                }), F;
            }
            function Q0(d, b, F) {
                for(var oe = -1, ge = d.length; ++oe < ge;){
                    var ve = d[oe], Oe = b(ve);
                    if (Oe != null && ($e === r ? Oe === Oe && !_o(Oe) : F(Oe, $e))) var $e = Oe, He = ve;
                }
                return He;
            }
            function SL(d, b, F, oe) {
                var ge = d.length;
                for(F = pr(F), F < 0 && (F = -F > ge ? 0 : ge + F), oe = oe === r || oe > ge ? ge : pr(oe), oe < 0 && (oe += ge), oe = F > oe ? 0 : g4(oe); F < oe;)d[F++] = b;
                return d;
            }
            function Q8(d, b) {
                var F = [];
                return xc(d, function(oe, ge, ve) {
                    b(oe, ge, ve) && F.push(oe);
                }), F;
            }
            function ui(d, b, F, oe, ge) {
                var ve = -1, Oe = d.length;
                for(F || (F = dD), ge || (ge = []); ++ve < Oe;){
                    var $e = d[ve];
                    b > 0 && F($e) ? b > 1 ? ui($e, b - 1, F, oe, ge) : vc(ge, $e) : oe || (ge[ge.length] = $e);
                }
                return ge;
            }
            var X1 = A6(), e6 = A6(!0);
            function qs(d, b) {
                return d && X1(d, b, ti);
            }
            function J1(d, b) {
                return d && e6(d, b, ti);
            }
            function eg(d, b) {
                return wc(b, function(F) {
                    return Ua(d[F]);
                });
            }
            function Lu(d, b) {
                b = Ac(b, d);
                for(var F = 0, oe = b.length; d != null && F < oe;)d = d[Ws(b[F++])];
                return F && F == oe ? d : r;
            }
            function t6(d, b, F) {
                var oe = b(d);
                return ur(d) ? oe : vc(oe, F(d));
            }
            function Li(d) {
                return d == null ? d === r ? q : de : Ru && Ru in an(d) ? sD(d) : wD(d);
            }
            function Q1(d, b) {
                return d > b;
            }
            function AL(d, b) {
                return d != null && Qr.call(d, b);
            }
            function TL(d, b) {
                return d != null && b in an(d);
            }
            function kL(d, b, F) {
                return d >= vi(b, F) && d < Kn(b, F);
            }
            function ew(d, b, F) {
                for(var oe = F ? U1 : C0, ge = d[0].length, ve = d.length, Oe = ve, $e = Ye(ve), He = 1 / 0, it = []; Oe--;){
                    var st = d[Oe];
                    Oe && b && (st = gn(st, wo(b))), He = vi(st.length, He), $e[Oe] = !F && (b || ge >= 120 && st.length >= 120) ? new Uu(Oe && st) : r;
                }
                st = d[0];
                var ft = -1, At = $e[0];
                e: for(; ++ft < ge && it.length < He;){
                    var Ut = st[ft], Vt = b ? b(Ut) : Ut;
                    if (Ut = F || Ut !== 0 ? Ut : 0, !(At ? Gd(At, Vt) : oe(it, Vt, F))) {
                        for(Oe = ve; --Oe;){
                            var vr = $e[Oe];
                            if (!(vr ? Gd(vr, Vt) : oe(d[Oe], Vt, F))) continue e;
                        }
                        At && At.push(Vt), it.push(Ut);
                    }
                }
                return it;
            }
            function IL(d, b, F, oe) {
                return qs(d, function(ge, ve, Oe) {
                    b(oe, F(ge), ve, Oe);
                }), oe;
            }
            function rh(d, b, F) {
                b = Ac(b, d), d = j6(d, b);
                var oe = d == null ? d : d[Ws(Wo(b))];
                return oe == null ? r : bo(oe, d, F);
            }
            function r6(d) {
                return On(d) && Li(d) == ce;
            }
            function BL(d) {
                return On(d) && Li(d) == ne;
            }
            function OL(d) {
                return On(d) && Li(d) == ye;
            }
            function nh(d, b, F, oe, ge) {
                return d === b ? !0 : d == null || b == null || !On(d) && !On(b) ? d !== d && b !== b : PL(d, b, F, oe, nh, ge);
            }
            function PL(d, b, F, oe, ge, ve) {
                var Oe = ur(d), $e = ur(b), He = Oe ? he : _i(d), it = $e ? he : _i(b);
                He = He == ce ? _e : He, it = it == ce ? _e : it;
                var st = He == _e, ft = it == _e, At = He == it;
                if (At && kc(d)) {
                    if (!kc(b)) return !1;
                    Oe = !0, st = !1;
                }
                if (At && !st) return ve || (ve = new vs()), Oe || ol(d) ? C6(d, b, F, oe, ge, ve) : iD(d, b, He, F, oe, ge, ve);
                if (!(F & _)) {
                    var Ut = st && Qr.call(d, "__wrapped__"), Vt = ft && Qr.call(b, "__wrapped__");
                    if (Ut || Vt) {
                        var vr = Ut ? d.value() : d, Gt = Vt ? b.value() : b;
                        return ve || (ve = new vs()), ge(vr, Gt, F, oe, ve);
                    }
                }
                return At ? (ve || (ve = new vs()), oD(d, b, F, oe, ge, ve)) : !1;
            }
            function NL(d) {
                return On(d) && _i(d) == M;
            }
            function tw(d, b, F, oe) {
                var ge = F.length, ve = ge, Oe = !oe;
                if (d == null) return !ve;
                for(d = an(d); ge--;){
                    var $e = F[ge];
                    if (Oe && $e[2] ? $e[1] !== d[$e[0]] : !($e[0] in d)) return !1;
                }
                for(; ++ge < ve;){
                    $e = F[ge];
                    var He = $e[0], it = d[He], st = $e[1];
                    if (Oe && $e[2]) {
                        if (it === r && !(He in d)) return !1;
                    } else {
                        var ft = new vs();
                        if (oe) var At = oe(it, st, He, d, b, ft);
                        if (!(At === r ? nh(st, it, _ | A, oe, ft) : At)) return !1;
                    }
                }
                return !0;
            }
            function n6(d) {
                if (!wn(d) || pD(d)) return !1;
                var b = Ua(d) ? N$ : St;
                return b.test(Fu(d));
            }
            function ML(d) {
                return On(d) && Li(d) == Ke;
            }
            function RL(d) {
                return On(d) && _i(d) == Ue;
            }
            function CL(d) {
                return On(d) && mg(d.length) && !!dn[Li(d)];
            }
            function i6(d) {
                return typeof d == "function" ? d : d == null ? Qi : typeof d == "object" ? ur(d) ? a6(d[0], d[1]) : s6(d) : T4(d);
            }
            function rw(d) {
                if (!sh(d)) return L$(d);
                var b = [];
                for(var F in an(d))Qr.call(d, F) && F != "constructor" && b.push(F);
                return b;
            }
            function UL(d) {
                if (!wn(d)) return bD(d);
                var b = sh(d), F = [];
                for(var oe in d)oe == "constructor" && (b || !Qr.call(d, oe)) || F.push(oe);
                return F;
            }
            function nw(d, b) {
                return d < b;
            }
            function o6(d, b) {
                var F = -1, oe = Xi(d) ? Ye(d.length) : [];
                return xc(d, function(ge, ve, Oe) {
                    oe[++F] = b(ge, ve, Oe);
                }), oe;
            }
            function s6(d) {
                var b = bw(d);
                return b.length == 1 && b[0][2] ? F6(b[0][0], b[0][1]) : function(F) {
                    return F === d || tw(F, d, b);
                };
            }
            function a6(d, b) {
                return vw(d) && D6(b) ? F6(Ws(d), b) : function(F) {
                    var oe = Ow(F, d);
                    return oe === r && oe === b ? Pw(F, d) : nh(b, oe, _ | A);
                };
            }
            function tg(d, b, F, oe, ge) {
                d !== b && X1(b, function(ve, Oe) {
                    if (ge || (ge = new vs()), wn(ve)) $L(d, b, Oe, F, tg, oe, ge);
                    else {
                        var $e = oe ? oe(Ew(d, Oe), ve, Oe + "", d, b, ge) : r;
                        $e === r && ($e = ve), Z1(d, Oe, $e);
                    }
                }, Ji);
            }
            function $L(d, b, F, oe, ge, ve, Oe) {
                var $e = Ew(d, F), He = Ew(b, F), it = Oe.get(He);
                if (it) {
                    Z1(d, F, it);
                    return;
                }
                var st = ve ? ve($e, He, F + "", d, b, Oe) : r, ft = st === r;
                if (ft) {
                    var At = ur(He), Ut = !At && kc(He), Vt = !At && !Ut && ol(He);
                    st = He, At || Ut || Vt ? ur($e) ? st = $e : Rn($e) ? st = Yi($e) : Ut ? (ft = !1, st = w6(He, !0)) : Vt ? (ft = !1, st = v6(He, !0)) : st = [] : ch(He) || zu(He) ? (st = $e, zu($e) ? st = y4($e) : (!wn($e) || Ua($e)) && (st = L6(He))) : ft = !1;
                }
                ft && (Oe.set(He, st), ge(st, He, oe, ve, Oe), Oe.delete(He)), Z1(d, F, st);
            }
            function c6(d, b) {
                var F = d.length;
                if (F) return b += b < 0 ? F : 0, Ca(b, F) ? d[b] : r;
            }
            function u6(d, b, F) {
                b.length ? b = gn(b, function(ve) {
                    return ur(ve) ? function(Oe) {
                        return Lu(Oe, ve.length === 1 ? ve[0] : ve);
                    } : ve;
                }) : b = [
                    Qi
                ];
                var oe = -1;
                b = gn(b, wo(Wt()));
                var ge = o6(d, function(ve, Oe, $e) {
                    var He = gn(b, function(it) {
                        return it(ve);
                    });
                    return {
                        criteria: He,
                        index: ++oe,
                        value: ve
                    };
                });
                return f$(ge, function(ve, Oe) {
                    return YL(ve, Oe, F);
                });
            }
            function LL(d, b) {
                return f6(d, b, function(F, oe) {
                    return Pw(d, oe);
                });
            }
            function f6(d, b, F) {
                for(var oe = -1, ge = b.length, ve = {}; ++oe < ge;){
                    var Oe = b[oe], $e = Lu(d, Oe);
                    F($e, Oe) && ih(ve, Ac(Oe, d), $e);
                }
                return ve;
            }
            function DL(d) {
                return function(b) {
                    return Lu(b, d);
                };
            }
            function iw(d, b, F, oe) {
                var ge = oe ? u$ : Gf, ve = -1, Oe = b.length, $e = d;
                for(d === b && (b = Yi(b)), F && ($e = gn(d, wo(F))); ++ve < Oe;)for(var He = 0, it = b[ve], st = F ? F(it) : it; (He = ge($e, st, He, oe)) > -1;)$e !== d && K0.call($e, He, 1), K0.call(d, He, 1);
                return d;
            }
            function l6(d, b) {
                for(var F = d ? b.length : 0, oe = F - 1; F--;){
                    var ge = b[F];
                    if (F == oe || ge !== ve) {
                        var ve = ge;
                        Ca(ge) ? K0.call(d, ge, 1) : cw(d, ge);
                    }
                }
                return d;
            }
            function ow(d, b) {
                return d + G0(K8() * (b - d + 1));
            }
            function FL(d, b, F, oe) {
                for(var ge = -1, ve = Kn(V0((b - d) / (F || 1)), 0), Oe = Ye(ve); ve--;)Oe[oe ? ve : ++ge] = d, d += F;
                return Oe;
            }
            function sw(d, b) {
                var F = "";
                if (!d || b < 1 || b > I) return F;
                do b % 2 && (F += d), b = G0(b / 2), b && (d += d);
                while (b)
                return F;
            }
            function Tr(d, b) {
                return xw(z6(d, b, Qi), d + "");
            }
            function zL(d) {
                return G8(sl(d));
            }
            function jL(d, b) {
                var F = sl(d);
                return lg(F, $u(b, 0, F.length));
            }
            function ih(d, b, F, oe) {
                if (!wn(d)) return d;
                b = Ac(b, d);
                for(var ge = -1, ve = b.length, Oe = ve - 1, $e = d; $e != null && ++ge < ve;){
                    var He = Ws(b[ge]), it = F;
                    if (He === "__proto__" || He === "constructor" || He === "prototype") return d;
                    if (ge != Oe) {
                        var st = $e[He];
                        it = oe ? oe(st, He, $e) : r, it === r && (it = wn(st) ? st : Ca(b[ge + 1]) ? [] : {});
                    }
                    eh($e, He, it), $e = $e[He];
                }
                return d;
            }
            var d6 = Z0 ? function(d, b) {
                return Z0.set(d, b), d;
            } : Qi, HL = W0 ? function(d, b) {
                return W0(d, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: Mw(b),
                    writable: !0
                });
            } : Qi;
            function qL(d) {
                return lg(sl(d));
            }
            function Ko(d, b, F) {
                var oe = -1, ge = d.length;
                b < 0 && (b = -b > ge ? 0 : ge + b), F = F > ge ? ge : F, F < 0 && (F += ge), ge = b > F ? 0 : F - b >>> 0, b >>>= 0;
                for(var ve = Ye(ge); ++oe < ge;)ve[oe] = d[oe + b];
                return ve;
            }
            function KL(d, b) {
                var F;
                return xc(d, function(oe, ge, ve) {
                    return F = b(oe, ge, ve), !F;
                }), !!F;
            }
            function rg(d, b, F) {
                var oe = 0, ge = d == null ? oe : d.length;
                if (typeof b == "number" && b === b && ge <= ie) {
                    for(; oe < ge;){
                        var ve = oe + ge >>> 1, Oe = d[ve];
                        Oe !== null && !_o(Oe) && (F ? Oe <= b : Oe < b) ? oe = ve + 1 : ge = ve;
                    }
                    return ge;
                }
                return aw(d, b, Qi, F);
            }
            function aw(d, b, F, oe) {
                var ge = 0, ve = d == null ? 0 : d.length;
                if (ve === 0) return 0;
                b = F(b);
                for(var Oe = b !== b, $e = b === null, He = _o(b), it = b === r; ge < ve;){
                    var st = G0((ge + ve) / 2), ft = F(d[st]), At = ft !== r, Ut = ft === null, Vt = ft === ft, vr = _o(ft);
                    if (Oe) var Gt = oe || Vt;
                    else it ? Gt = Vt && (oe || At) : $e ? Gt = Vt && At && (oe || !Ut) : He ? Gt = Vt && At && !Ut && (oe || !vr) : Ut || vr ? Gt = !1 : Gt = oe ? ft <= b : ft < b;
                    Gt ? ge = st + 1 : ve = st;
                }
                return vi(ve, j);
            }
            function h6(d, b) {
                for(var F = -1, oe = d.length, ge = 0, ve = []; ++F < oe;){
                    var Oe = d[F], $e = b ? b(Oe) : Oe;
                    if (!F || !_s($e, He)) {
                        var He = $e;
                        ve[ge++] = Oe === 0 ? 0 : Oe;
                    }
                }
                return ve;
            }
            function p6(d) {
                return typeof d == "number" ? d : _o(d) ? k : +d;
            }
            function vo(d) {
                if (typeof d == "string") return d;
                if (ur(d)) return gn(d, vo) + "";
                if (_o(d)) return W8 ? W8.call(d) : "";
                var b = d + "";
                return b == "0" && 1 / d == -T ? "-0" : b;
            }
            function Sc(d, b, F) {
                var oe = -1, ge = C0, ve = d.length, Oe = !0, $e = [], He = $e;
                if (F) Oe = !1, ge = U1;
                else if (ve >= i) {
                    var it = b ? null : rD(d);
                    if (it) return $0(it);
                    Oe = !1, ge = Gd, He = new Uu();
                } else He = b ? [] : $e;
                e: for(; ++oe < ve;){
                    var st = d[oe], ft = b ? b(st) : st;
                    if (st = F || st !== 0 ? st : 0, Oe && ft === ft) {
                        for(var At = He.length; At--;)if (He[At] === ft) continue e;
                        b && He.push(ft), $e.push(st);
                    } else ge(He, ft, F) || (He !== $e && He.push(ft), $e.push(st));
                }
                return $e;
            }
            function cw(d, b) {
                return b = Ac(b, d), d = j6(d, b), d == null || delete d[Ws(Wo(b))];
            }
            function g6(d, b, F, oe) {
                return ih(d, b, F(Lu(d, b)), oe);
            }
            function ng(d, b, F, oe) {
                for(var ge = d.length, ve = oe ? ge : -1; (oe ? ve-- : ++ve < ge) && b(d[ve], ve, d););
                return F ? Ko(d, oe ? 0 : ve, oe ? ve + 1 : ge) : Ko(d, oe ? ve + 1 : 0, oe ? ge : ve);
            }
            function y6(d, b) {
                var F = d;
                return F instanceof Rr && (F = F.value()), $1(b, function(oe, ge) {
                    return ge.func.apply(ge.thisArg, vc([
                        oe
                    ], ge.args));
                }, F);
            }
            function uw(d, b, F) {
                var oe = d.length;
                if (oe < 2) return oe ? Sc(d[0]) : [];
                for(var ge = -1, ve = Ye(oe); ++ge < oe;)for(var Oe = d[ge], $e = -1; ++$e < oe;)$e != ge && (ve[ge] = th(ve[ge] || Oe, d[$e], b, F));
                return Sc(ui(ve, 1), b, F);
            }
            function m6(d, b, F) {
                for(var oe = -1, ge = d.length, ve = b.length, Oe = {}; ++oe < ge;){
                    var $e = oe < ve ? b[oe] : r;
                    F(Oe, d[oe], $e);
                }
                return Oe;
            }
            function fw(d) {
                return Rn(d) ? d : [];
            }
            function lw(d) {
                return typeof d == "function" ? d : Qi;
            }
            function Ac(d, b) {
                return ur(d) ? d : vw(d, b) ? [
                    d
                ] : W6(Yr(d));
            }
            var WL = Tr;
            function Tc(d, b, F) {
                var oe = d.length;
                return F = F === r ? oe : F, !b && F >= oe ? d : Ko(d, b, F);
            }
            var b6 = M$ || function(d) {
                return ci.clearTimeout(d);
            };
            function w6(d, b) {
                if (b) return d.slice();
                var F = d.length, oe = F8 ? F8(F) : new d.constructor(F);
                return d.copy(oe), oe;
            }
            function dw(d) {
                var b = new d.constructor(d.byteLength);
                return new H0(b).set(new H0(d)), b;
            }
            function VL(d, b) {
                var F = b ? dw(d.buffer) : d.buffer;
                return new d.constructor(F, d.byteOffset, d.byteLength);
            }
            function GL(d) {
                var b = new d.constructor(d.source, Ct.exec(d));
                return b.lastIndex = d.lastIndex, b;
            }
            function ZL(d) {
                return Qd ? an(Qd.call(d)) : {};
            }
            function v6(d, b) {
                var F = b ? dw(d.buffer) : d.buffer;
                return new d.constructor(F, d.byteOffset, d.length);
            }
            function _6(d, b) {
                if (d !== b) {
                    var F = d !== r, oe = d === null, ge = d === d, ve = _o(d), Oe = b !== r, $e = b === null, He = b === b, it = _o(b);
                    if (!$e && !it && !ve && d > b || ve && Oe && He && !$e && !it || oe && Oe && He || !F && He || !ge) return 1;
                    if (!oe && !ve && !it && d < b || it && F && ge && !oe && !ve || $e && F && ge || !Oe && ge || !He) return -1;
                }
                return 0;
            }
            function YL(d, b, F) {
                for(var oe = -1, ge = d.criteria, ve = b.criteria, Oe = ge.length, $e = F.length; ++oe < Oe;){
                    var He = _6(ge[oe], ve[oe]);
                    if (He) {
                        if (oe >= $e) return He;
                        var it = F[oe];
                        return He * (it == "desc" ? -1 : 1);
                    }
                }
                return d.index - b.index;
            }
            function E6(d, b, F, oe) {
                for(var ge = -1, ve = d.length, Oe = F.length, $e = -1, He = b.length, it = Kn(ve - Oe, 0), st = Ye(He + it), ft = !oe; ++$e < He;)st[$e] = b[$e];
                for(; ++ge < Oe;)(ft || ge < ve) && (st[F[ge]] = d[ge]);
                for(; it--;)st[$e++] = d[ge++];
                return st;
            }
            function x6(d, b, F, oe) {
                for(var ge = -1, ve = d.length, Oe = -1, $e = F.length, He = -1, it = b.length, st = Kn(ve - $e, 0), ft = Ye(st + it), At = !oe; ++ge < st;)ft[ge] = d[ge];
                for(var Ut = ge; ++He < it;)ft[Ut + He] = b[He];
                for(; ++Oe < $e;)(At || ge < ve) && (ft[Ut + F[Oe]] = d[ge++]);
                return ft;
            }
            function Yi(d, b) {
                var F = -1, oe = d.length;
                for(b || (b = Ye(oe)); ++F < oe;)b[F] = d[F];
                return b;
            }
            function Ks(d, b, F, oe) {
                var ge = !F;
                F || (F = {});
                for(var ve = -1, Oe = b.length; ++ve < Oe;){
                    var $e = b[ve], He = oe ? oe(F[$e], d[$e], $e, F, d) : r;
                    He === r && (He = d[$e]), ge ? Na(F, $e, He) : eh(F, $e, He);
                }
                return F;
            }
            function XL(d, b) {
                return Ks(d, ww(d), b);
            }
            function JL(d, b) {
                return Ks(d, U6(d), b);
            }
            function ig(d, b) {
                return function(F, oe) {
                    var ge = ur(F) ? n$ : vL, ve = b ? b() : {};
                    return ge(F, d, Wt(oe, 2), ve);
                };
            }
            function rl(d) {
                return Tr(function(b, F) {
                    var oe = -1, ge = F.length, ve = ge > 1 ? F[ge - 1] : r, Oe = ge > 2 ? F[2] : r;
                    for(ve = d.length > 3 && typeof ve == "function" ? (ge--, ve) : r, Oe && Di(F[0], F[1], Oe) && (ve = ge < 3 ? r : ve, ge = 1), b = an(b); ++oe < ge;){
                        var $e = F[oe];
                        $e && d(b, $e, oe, ve);
                    }
                    return b;
                });
            }
            function S6(d, b) {
                return function(F, oe) {
                    if (F == null) return F;
                    if (!Xi(F)) return d(F, oe);
                    for(var ge = F.length, ve = b ? ge : -1, Oe = an(F); (b ? ve-- : ++ve < ge) && oe(Oe[ve], ve, Oe) !== !1;);
                    return F;
                };
            }
            function A6(d) {
                return function(b, F, oe) {
                    for(var ge = -1, ve = an(b), Oe = oe(b), $e = Oe.length; $e--;){
                        var He = Oe[d ? $e : ++ge];
                        if (F(ve[He], He, ve) === !1) break;
                    }
                    return b;
                };
            }
            function QL(d, b, F) {
                var oe = b & O, ge = oh(d);
                function ve() {
                    var Oe = this && this !== ci && this instanceof ve ? ge : d;
                    return Oe.apply(oe ? F : this, arguments);
                }
                return ve;
            }
            function T6(d) {
                return function(b) {
                    b = Yr(b);
                    var F = Zf(b) ? ws(b) : r, oe = F ? F[0] : b.charAt(0), ge = F ? Tc(F, 1).join("") : b.slice(1);
                    return oe[d]() + ge;
                };
            }
            function nl(d) {
                return function(b) {
                    return $1(S4(x4(b).replace(HU, "")), d, "");
                };
            }
            function oh(d) {
                return function() {
                    var b = arguments;
                    switch(b.length){
                        case 0:
                            return new d();
                        case 1:
                            return new d(b[0]);
                        case 2:
                            return new d(b[0], b[1]);
                        case 3:
                            return new d(b[0], b[1], b[2]);
                        case 4:
                            return new d(b[0], b[1], b[2], b[3]);
                        case 5:
                            return new d(b[0], b[1], b[2], b[3], b[4]);
                        case 6:
                            return new d(b[0], b[1], b[2], b[3], b[4], b[5]);
                        case 7:
                            return new d(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);
                    }
                    var F = tl(d.prototype), oe = d.apply(F, b);
                    return wn(oe) ? oe : F;
                };
            }
            function eD(d, b, F) {
                var oe = oh(d);
                function ge() {
                    for(var ve = arguments.length, Oe = Ye(ve), $e = ve, He = il(ge); $e--;)Oe[$e] = arguments[$e];
                    var it = ve < 3 && Oe[0] !== He && Oe[ve - 1] !== He ? [] : _c(Oe, He);
                    if (ve -= it.length, ve < F) return P6(d, b, og, ge.placeholder, r, Oe, it, r, r, F - ve);
                    var st = this && this !== ci && this instanceof ge ? oe : d;
                    return bo(st, this, Oe);
                }
                return ge;
            }
            function k6(d) {
                return function(b, F, oe) {
                    var ge = an(b);
                    if (!Xi(b)) {
                        var ve = Wt(F, 3);
                        b = ti(b), F = function($e) {
                            return ve(ge[$e], $e, ge);
                        };
                    }
                    var Oe = d(b, F, oe);
                    return Oe > -1 ? ge[ve ? b[Oe] : Oe] : r;
                };
            }
            function I6(d) {
                return Ra(function(b) {
                    var F = b.length, oe = F, ge = Ho.prototype.thru;
                    for(d && b.reverse(); oe--;){
                        var ve = b[oe];
                        if (typeof ve != "function") throw new jo(s);
                        if (ge && !Oe && ug(ve) == "wrapper") var Oe = new Ho([], !0);
                    }
                    for(oe = Oe ? oe : F; ++oe < F;){
                        ve = b[oe];
                        var $e = ug(ve), He = $e == "wrapper" ? mw(ve) : r;
                        He && _w(He[0]) && He[1] == (Q | D | K | G) && !He[4].length && He[9] == 1 ? Oe = Oe[ug(He[0])].apply(Oe, He[3]) : Oe = ve.length == 1 && _w(ve) ? Oe[$e]() : Oe.thru(ve);
                    }
                    return function() {
                        var it = arguments, st = it[0];
                        if (Oe && it.length == 1 && ur(st)) return Oe.plant(st).value();
                        for(var ft = 0, At = F ? b[ft].apply(this, it) : st; ++ft < F;)At = b[ft].call(this, At);
                        return At;
                    };
                });
            }
            function og(d, b, F, oe, ge, ve, Oe, $e, He, it) {
                var st = b & Q, ft = b & O, At = b & N, Ut = b & (D | H), Vt = b & R, vr = At ? r : oh(d);
                function Gt() {
                    for(var Pr = arguments.length, Lr = Ye(Pr), Eo = Pr; Eo--;)Lr[Eo] = arguments[Eo];
                    if (Ut) var Fi = il(Gt), xo = d$(Lr, Fi);
                    if (oe && (Lr = E6(Lr, oe, ge, Ut)), ve && (Lr = x6(Lr, ve, Oe, Ut)), Pr -= xo, Ut && Pr < it) {
                        var Cn = _c(Lr, Fi);
                        return P6(d, b, og, Gt.placeholder, F, Lr, Cn, $e, He, it - Pr);
                    }
                    var Es = ft ? F : this, La = At ? Es[d] : d;
                    return Pr = Lr.length, $e ? Lr = vD(Lr, $e) : Vt && Pr > 1 && Lr.reverse(), st && He < Pr && (Lr.length = He), this && this !== ci && this instanceof Gt && (La = vr || oh(La)), La.apply(Es, Lr);
                }
                return Gt;
            }
            function B6(d, b) {
                return function(F, oe) {
                    return IL(F, d, b(oe), {});
                };
            }
            function sg(d, b) {
                return function(F, oe) {
                    var ge;
                    if (F === r && oe === r) return b;
                    if (F !== r && (ge = F), oe !== r) {
                        if (ge === r) return oe;
                        typeof F == "string" || typeof oe == "string" ? (F = vo(F), oe = vo(oe)) : (F = p6(F), oe = p6(oe)), ge = d(F, oe);
                    }
                    return ge;
                };
            }
            function hw(d) {
                return Ra(function(b) {
                    return b = gn(b, wo(Wt())), Tr(function(F) {
                        var oe = this;
                        return d(b, function(ge) {
                            return bo(ge, oe, F);
                        });
                    });
                });
            }
            function ag(d, b) {
                b = b === r ? " " : vo(b);
                var F = b.length;
                if (F < 2) return F ? sw(b, d) : b;
                var oe = sw(b, V0(d / Yf(b)));
                return Zf(b) ? Tc(ws(oe), 0, d).join("") : oe.slice(0, d);
            }
            function tD(d, b, F, oe) {
                var ge = b & O, ve = oh(d);
                function Oe() {
                    for(var $e = -1, He = arguments.length, it = -1, st = oe.length, ft = Ye(st + He), At = this && this !== ci && this instanceof Oe ? ve : d; ++it < st;)ft[it] = oe[it];
                    for(; He--;)ft[it++] = arguments[++$e];
                    return bo(At, ge ? F : this, ft);
                }
                return Oe;
            }
            function O6(d) {
                return function(b, F, oe) {
                    return oe && typeof oe != "number" && Di(b, F, oe) && (F = oe = r), b = $a(b), F === r ? (F = b, b = 0) : F = $a(F), oe = oe === r ? b < F ? 1 : -1 : $a(oe), FL(b, F, oe, d);
                };
            }
            function cg(d) {
                return function(b, F) {
                    return typeof b == "string" && typeof F == "string" || (b = Vo(b), F = Vo(F)), d(b, F);
                };
            }
            function P6(d, b, F, oe, ge, ve, Oe, $e, He, it) {
                var st = b & D, ft = st ? Oe : r, At = st ? r : Oe, Ut = st ? ve : r, Vt = st ? r : ve;
                b |= st ? K : re, b &= ~(st ? re : K), b & U || (b &= -4);
                var vr = [
                    d,
                    b,
                    ge,
                    Ut,
                    ft,
                    Vt,
                    At,
                    $e,
                    He,
                    it
                ], Gt = F.apply(r, vr);
                return _w(d) && H6(Gt, vr), Gt.placeholder = oe, q6(Gt, d, b);
            }
            function pw(d) {
                var b = qn[d];
                return function(F, oe) {
                    if (F = Vo(F), oe = oe == null ? 0 : vi(pr(oe), 292), oe && q8(F)) {
                        var ge = (Yr(F) + "e").split("e"), ve = b(ge[0] + "e" + (+ge[1] + oe));
                        return ge = (Yr(ve) + "e").split("e"), +(ge[0] + "e" + (+ge[1] - oe));
                    }
                    return b(F);
                };
            }
            var rD = Qf && 1 / $0(new Qf([
                ,
                -0
            ]))[1] == T ? function(d) {
                return new Qf(d);
            } : Uw;
            function N6(d) {
                return function(b) {
                    var F = _i(b);
                    return F == M ? q1(b) : F == Ue ? w$(b) : l$(b, d(b));
                };
            }
            function Ma(d, b, F, oe, ge, ve, Oe, $e) {
                var He = b & N;
                if (!He && typeof d != "function") throw new jo(s);
                var it = oe ? oe.length : 0;
                if (it || (b &= -97, oe = ge = r), Oe = Oe === r ? Oe : Kn(pr(Oe), 0), $e = $e === r ? $e : pr($e), it -= ge ? ge.length : 0, b & re) {
                    var st = oe, ft = ge;
                    oe = ge = r;
                }
                var At = He ? r : mw(d), Ut = [
                    d,
                    b,
                    F,
                    oe,
                    ge,
                    st,
                    ft,
                    ve,
                    Oe,
                    $e
                ];
                if (At && mD(Ut, At), d = Ut[0], b = Ut[1], F = Ut[2], oe = Ut[3], ge = Ut[4], $e = Ut[9] = Ut[9] === r ? He ? 0 : d.length : Kn(Ut[9] - it, 0), !$e && b & (D | H) && (b &= -25), !b || b == O) var Vt = QL(d, b, F);
                else b == D || b == H ? Vt = eD(d, b, $e) : (b == K || b == (O | K)) && !ge.length ? Vt = tD(d, b, F, oe) : Vt = og.apply(r, Ut);
                var vr = At ? d6 : H6;
                return q6(vr(Vt, Ut), d, b);
            }
            function M6(d, b, F, oe) {
                return d === r || _s(d, Jf[F]) && !Qr.call(oe, F) ? b : d;
            }
            function R6(d, b, F, oe, ge, ve) {
                return wn(d) && wn(b) && (ve.set(b, d), tg(d, b, r, R6, ve), ve.delete(b)), d;
            }
            function nD(d) {
                return ch(d) ? r : d;
            }
            function C6(d, b, F, oe, ge, ve) {
                var Oe = F & _, $e = d.length, He = b.length;
                if ($e != He && !(Oe && He > $e)) return !1;
                var it = ve.get(d), st = ve.get(b);
                if (it && st) return it == b && st == d;
                var ft = -1, At = !0, Ut = F & A ? new Uu() : r;
                for(ve.set(d, b), ve.set(b, d); ++ft < $e;){
                    var Vt = d[ft], vr = b[ft];
                    if (oe) var Gt = Oe ? oe(vr, Vt, ft, b, d, ve) : oe(Vt, vr, ft, d, b, ve);
                    if (Gt !== r) {
                        if (Gt) continue;
                        At = !1;
                        break;
                    }
                    if (Ut) {
                        if (!L1(b, function(Pr, Lr) {
                            if (!Gd(Ut, Lr) && (Vt === Pr || ge(Vt, Pr, F, oe, ve))) return Ut.push(Lr);
                        })) {
                            At = !1;
                            break;
                        }
                    } else if (!(Vt === vr || ge(Vt, vr, F, oe, ve))) {
                        At = !1;
                        break;
                    }
                }
                return ve.delete(d), ve.delete(b), At;
            }
            function iD(d, b, F, oe, ge, ve, Oe) {
                switch(F){
                    case W:
                        if (d.byteLength != b.byteLength || d.byteOffset != b.byteOffset) return !1;
                        d = d.buffer, b = b.buffer;
                    case ne:
                        return !(d.byteLength != b.byteLength || !ve(new H0(d), new H0(b)));
                    case ae:
                    case ye:
                    case z:
                        return _s(+d, +b);
                    case De:
                        return d.name == b.name && d.message == b.message;
                    case Ke:
                    case h:
                        return d == b + "";
                    case M:
                        var $e = q1;
                    case Ue:
                        var He = oe & _;
                        if ($e || ($e = $0), d.size != b.size && !He) return !1;
                        var it = Oe.get(d);
                        if (it) return it == b;
                        oe |= A, Oe.set(d, b);
                        var st = C6($e(d), $e(b), oe, ge, ve, Oe);
                        return Oe.delete(d), st;
                    case x:
                        if (Qd) return Qd.call(d) == Qd.call(b);
                }
                return !1;
            }
            function oD(d, b, F, oe, ge, ve) {
                var Oe = F & _, $e = gw(d), He = $e.length, it = gw(b), st = it.length;
                if (He != st && !Oe) return !1;
                for(var ft = He; ft--;){
                    var At = $e[ft];
                    if (!(Oe ? At in b : Qr.call(b, At))) return !1;
                }
                var Ut = ve.get(d), Vt = ve.get(b);
                if (Ut && Vt) return Ut == b && Vt == d;
                var vr = !0;
                ve.set(d, b), ve.set(b, d);
                for(var Gt = Oe; ++ft < He;){
                    At = $e[ft];
                    var Pr = d[At], Lr = b[At];
                    if (oe) var Eo = Oe ? oe(Lr, Pr, At, b, d, ve) : oe(Pr, Lr, At, d, b, ve);
                    if (!(Eo === r ? Pr === Lr || ge(Pr, Lr, F, oe, ve) : Eo)) {
                        vr = !1;
                        break;
                    }
                    Gt || (Gt = At == "constructor");
                }
                if (vr && !Gt) {
                    var Fi = d.constructor, xo = b.constructor;
                    Fi != xo && "constructor" in d && "constructor" in b && !(typeof Fi == "function" && Fi instanceof Fi && typeof xo == "function" && xo instanceof xo) && (vr = !1);
                }
                return ve.delete(d), ve.delete(b), vr;
            }
            function Ra(d) {
                return xw(z6(d, r, Y6), d + "");
            }
            function gw(d) {
                return t6(d, ti, ww);
            }
            function yw(d) {
                return t6(d, Ji, U6);
            }
            var mw = Z0 ? function(d) {
                return Z0.get(d);
            } : Uw;
            function ug(d) {
                for(var b = d.name + "", F = el[b], oe = Qr.call(el, b) ? F.length : 0; oe--;){
                    var ge = F[oe], ve = ge.func;
                    if (ve == null || ve == d) return ge.name;
                }
                return b;
            }
            function il(d) {
                var b = Qr.call(me, "placeholder") ? me : d;
                return b.placeholder;
            }
            function Wt() {
                var d = me.iteratee || Rw;
                return d = d === Rw ? i6 : d, arguments.length ? d(arguments[0], arguments[1]) : d;
            }
            function fg(d, b) {
                var F = d.__data__;
                return hD(b) ? F[typeof b == "string" ? "string" : "hash"] : F.map;
            }
            function bw(d) {
                for(var b = ti(d), F = b.length; F--;){
                    var oe = b[F], ge = d[oe];
                    b[F] = [
                        oe,
                        ge,
                        D6(ge)
                    ];
                }
                return b;
            }
            function Du(d, b) {
                var F = y$(d, b);
                return n6(F) ? F : r;
            }
            function sD(d) {
                var b = Qr.call(d, Ru), F = d[Ru];
                try {
                    d[Ru] = r;
                    var oe = !0;
                } catch  {}
                var ge = z0.call(d);
                return oe && (b ? d[Ru] = F : delete d[Ru]), ge;
            }
            var ww = W1 ? function(d) {
                return d == null ? [] : (d = an(d), wc(W1(d), function(b) {
                    return j8.call(d, b);
                }));
            } : $w, U6 = W1 ? function(d) {
                for(var b = []; d;)vc(b, ww(d)), d = q0(d);
                return b;
            } : $w, _i = Li;
            (V1 && _i(new V1(new ArrayBuffer(1))) != W || Yd && _i(new Yd()) != M || G1 && _i(G1.resolve()) != Ie || Qf && _i(new Qf()) != Ue || Xd && _i(new Xd()) != te) && (_i = function(d) {
                var b = Li(d), F = b == _e ? d.constructor : r, oe = F ? Fu(F) : "";
                if (oe) switch(oe){
                    case j$:
                        return W;
                    case H$:
                        return M;
                    case q$:
                        return Ie;
                    case K$:
                        return Ue;
                    case W$:
                        return te;
                }
                return b;
            });
            function aD(d, b, F) {
                for(var oe = -1, ge = F.length; ++oe < ge;){
                    var ve = F[oe], Oe = ve.size;
                    switch(ve.type){
                        case "drop":
                            d += Oe;
                            break;
                        case "dropRight":
                            b -= Oe;
                            break;
                        case "take":
                            b = vi(b, d + Oe);
                            break;
                        case "takeRight":
                            d = Kn(d, b - Oe);
                            break;
                    }
                }
                return {
                    start: d,
                    end: b
                };
            }
            function cD(d) {
                var b = d.match(ct);
                return b ? b[1].split(lt) : [];
            }
            function $6(d, b, F) {
                b = Ac(b, d);
                for(var oe = -1, ge = b.length, ve = !1; ++oe < ge;){
                    var Oe = Ws(b[oe]);
                    if (!(ve = d != null && F(d, Oe))) break;
                    d = d[Oe];
                }
                return ve || ++oe != ge ? ve : (ge = d == null ? 0 : d.length, !!ge && mg(ge) && Ca(Oe, ge) && (ur(d) || zu(d)));
            }
            function uD(d) {
                var b = d.length, F = new d.constructor(b);
                return b && typeof d[0] == "string" && Qr.call(d, "index") && (F.index = d.index, F.input = d.input), F;
            }
            function L6(d) {
                return typeof d.constructor == "function" && !sh(d) ? tl(q0(d)) : {};
            }
            function fD(d, b, F) {
                var oe = d.constructor;
                switch(b){
                    case ne:
                        return dw(d);
                    case ae:
                    case ye:
                        return new oe(+d);
                    case W:
                        return VL(d, F);
                    case J:
                    case V:
                    case C:
                    case Z:
                    case le:
                    case se:
                    case Ne:
                    case Le:
                    case rt:
                        return v6(d, F);
                    case M:
                        return new oe();
                    case z:
                    case h:
                        return new oe(d);
                    case Ke:
                        return GL(d);
                    case Ue:
                        return new oe();
                    case x:
                        return ZL(d);
                }
            }
            function lD(d, b) {
                var F = b.length;
                if (!F) return d;
                var oe = F - 1;
                return b[oe] = (F > 1 ? "& " : "") + b[oe], b = b.join(F > 2 ? ", " : " "), d.replace(at, `{
/* [wrapped with ` + b + `] */
`);
            }
            function dD(d) {
                return ur(d) || zu(d) || !!(H8 && d && d[H8]);
            }
            function Ca(d, b) {
                var F = typeof d;
                return b = b ?? I, !!b && (F == "number" || F != "symbol" && et.test(d)) && d > -1 && d % 1 == 0 && d < b;
            }
            function Di(d, b, F) {
                if (!wn(F)) return !1;
                var oe = typeof b;
                return (oe == "number" ? Xi(F) && Ca(b, F.length) : oe == "string" && b in F) ? _s(F[b], d) : !1;
            }
            function vw(d, b) {
                if (ur(d)) return !1;
                var F = typeof d;
                return F == "number" || F == "symbol" || F == "boolean" || d == null || _o(d) ? !0 : Ae.test(d) || !zt.test(d) || b != null && d in an(b);
            }
            function hD(d) {
                var b = typeof d;
                return b == "string" || b == "number" || b == "symbol" || b == "boolean" ? d !== "__proto__" : d === null;
            }
            function _w(d) {
                var b = ug(d), F = me[b];
                if (typeof F != "function" || !(b in Rr.prototype)) return !1;
                if (d === F) return !0;
                var oe = mw(F);
                return !!oe && d === oe[0];
            }
            function pD(d) {
                return !!D8 && D8 in d;
            }
            var gD = D0 ? Ua : Lw;
            function sh(d) {
                var b = d && d.constructor, F = typeof b == "function" && b.prototype || Jf;
                return d === F;
            }
            function D6(d) {
                return d === d && !wn(d);
            }
            function F6(d, b) {
                return function(F) {
                    return F == null ? !1 : F[d] === b && (b !== r || d in an(F));
                };
            }
            function yD(d) {
                var b = gg(d, function(oe) {
                    return F.size === f && F.clear(), oe;
                }), F = b.cache;
                return b;
            }
            function mD(d, b) {
                var F = d[1], oe = b[1], ge = F | oe, ve = ge < (O | N | Q), Oe = oe == Q && F == D || oe == Q && F == G && d[7].length <= b[8] || oe == (Q | G) && b[7].length <= b[8] && F == D;
                if (!(ve || Oe)) return d;
                oe & O && (d[2] = b[2], ge |= F & O ? 0 : U);
                var $e = b[3];
                if ($e) {
                    var He = d[3];
                    d[3] = He ? E6(He, $e, b[4]) : $e, d[4] = He ? _c(d[3], c) : b[4];
                }
                return $e = b[5], $e && (He = d[5], d[5] = He ? x6(He, $e, b[6]) : $e, d[6] = He ? _c(d[5], c) : b[6]), $e = b[7], $e && (d[7] = $e), oe & Q && (d[8] = d[8] == null ? b[8] : vi(d[8], b[8])), d[9] == null && (d[9] = b[9]), d[0] = b[0], d[1] = ge, d;
            }
            function bD(d) {
                var b = [];
                if (d != null) for(var F in an(d))b.push(F);
                return b;
            }
            function wD(d) {
                return z0.call(d);
            }
            function z6(d, b, F) {
                return b = Kn(b === r ? d.length - 1 : b, 0), function() {
                    for(var oe = arguments, ge = -1, ve = Kn(oe.length - b, 0), Oe = Ye(ve); ++ge < ve;)Oe[ge] = oe[b + ge];
                    ge = -1;
                    for(var $e = Ye(b + 1); ++ge < b;)$e[ge] = oe[ge];
                    return $e[b] = F(Oe), bo(d, this, $e);
                };
            }
            function j6(d, b) {
                return b.length < 2 ? d : Lu(d, Ko(b, 0, -1));
            }
            function vD(d, b) {
                for(var F = d.length, oe = vi(b.length, F), ge = Yi(d); oe--;){
                    var ve = b[oe];
                    d[oe] = Ca(ve, F) ? ge[ve] : r;
                }
                return d;
            }
            function Ew(d, b) {
                if (!(b === "constructor" && typeof d[b] == "function") && b != "__proto__") return d[b];
            }
            var H6 = K6(d6), ah = C$ || function(d, b) {
                return ci.setTimeout(d, b);
            }, xw = K6(HL);
            function q6(d, b, F) {
                var oe = b + "";
                return xw(d, lD(oe, _D(cD(oe), F)));
            }
            function K6(d) {
                var b = 0, F = 0;
                return function() {
                    var oe = D$(), ge = w - (oe - F);
                    if (F = oe, ge > 0) {
                        if (++b >= S) return arguments[0];
                    } else b = 0;
                    return d.apply(r, arguments);
                };
            }
            function lg(d, b) {
                var F = -1, oe = d.length, ge = oe - 1;
                for(b = b === r ? oe : b; ++F < b;){
                    var ve = ow(F, ge), Oe = d[ve];
                    d[ve] = d[F], d[F] = Oe;
                }
                return d.length = b, d;
            }
            var W6 = yD(function(d) {
                var b = [];
                return d.charCodeAt(0) === 46 && b.push(""), d.replace(we, function(F, oe, ge, ve) {
                    b.push(ge ? ve.replace(bt, "$1") : oe || F);
                }), b;
            });
            function Ws(d) {
                if (typeof d == "string" || _o(d)) return d;
                var b = d + "";
                return b == "0" && 1 / d == -T ? "-0" : b;
            }
            function Fu(d) {
                if (d != null) {
                    try {
                        return F0.call(d);
                    } catch  {}
                    try {
                        return d + "";
                    } catch  {}
                }
                return "";
            }
            function _D(d, b) {
                return zo(ue, function(F) {
                    var oe = "_." + F[0];
                    b & F[1] && !C0(d, oe) && d.push(oe);
                }), d.sort();
            }
            function V6(d) {
                if (d instanceof Rr) return d.clone();
                var b = new Ho(d.__wrapped__, d.__chain__);
                return b.__actions__ = Yi(d.__actions__), b.__index__ = d.__index__, b.__values__ = d.__values__, b;
            }
            function ED(d, b, F) {
                (F ? Di(d, b, F) : b === r) ? b = 1 : b = Kn(pr(b), 0);
                var oe = d == null ? 0 : d.length;
                if (!oe || b < 1) return [];
                for(var ge = 0, ve = 0, Oe = Ye(V0(oe / b)); ge < oe;)Oe[ve++] = Ko(d, ge, ge += b);
                return Oe;
            }
            function xD(d) {
                for(var b = -1, F = d == null ? 0 : d.length, oe = 0, ge = []; ++b < F;){
                    var ve = d[b];
                    ve && (ge[oe++] = ve);
                }
                return ge;
            }
            function SD() {
                var d = arguments.length;
                if (!d) return [];
                for(var b = Ye(d - 1), F = arguments[0], oe = d; oe--;)b[oe - 1] = arguments[oe];
                return vc(ur(F) ? Yi(F) : [
                    F
                ], ui(b, 1));
            }
            var AD = Tr(function(d, b) {
                return Rn(d) ? th(d, ui(b, 1, Rn, !0)) : [];
            }), TD = Tr(function(d, b) {
                var F = Wo(b);
                return Rn(F) && (F = r), Rn(d) ? th(d, ui(b, 1, Rn, !0), Wt(F, 2)) : [];
            }), kD = Tr(function(d, b) {
                var F = Wo(b);
                return Rn(F) && (F = r), Rn(d) ? th(d, ui(b, 1, Rn, !0), r, F) : [];
            });
            function ID(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (b = F || b === r ? 1 : pr(b), Ko(d, b < 0 ? 0 : b, oe)) : [];
            }
            function BD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (b = F || b === r ? 1 : pr(b), b = oe - b, Ko(d, 0, b < 0 ? 0 : b)) : [];
            }
            function OD(d, b) {
                return d && d.length ? ng(d, Wt(b, 3), !0, !0) : [];
            }
            function PD(d, b) {
                return d && d.length ? ng(d, Wt(b, 3), !0) : [];
            }
            function ND(d, b, F, oe) {
                var ge = d == null ? 0 : d.length;
                return ge ? (F && typeof F != "number" && Di(d, b, F) && (F = 0, oe = ge), SL(d, b, F, oe)) : [];
            }
            function G6(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = F == null ? 0 : pr(F);
                return ge < 0 && (ge = Kn(oe + ge, 0)), U0(d, Wt(b, 3), ge);
            }
            function Z6(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = oe - 1;
                return F !== r && (ge = pr(F), ge = F < 0 ? Kn(oe + ge, 0) : vi(ge, oe - 1)), U0(d, Wt(b, 3), ge, !0);
            }
            function Y6(d) {
                var b = d == null ? 0 : d.length;
                return b ? ui(d, 1) : [];
            }
            function MD(d) {
                var b = d == null ? 0 : d.length;
                return b ? ui(d, T) : [];
            }
            function RD(d, b) {
                var F = d == null ? 0 : d.length;
                return F ? (b = b === r ? 1 : pr(b), ui(d, b)) : [];
            }
            function CD(d) {
                for(var b = -1, F = d == null ? 0 : d.length, oe = {}; ++b < F;){
                    var ge = d[b];
                    oe[ge[0]] = ge[1];
                }
                return oe;
            }
            function X6(d) {
                return d && d.length ? d[0] : r;
            }
            function UD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = F == null ? 0 : pr(F);
                return ge < 0 && (ge = Kn(oe + ge, 0)), Gf(d, b, ge);
            }
            function $D(d) {
                var b = d == null ? 0 : d.length;
                return b ? Ko(d, 0, -1) : [];
            }
            var LD = Tr(function(d) {
                var b = gn(d, fw);
                return b.length && b[0] === d[0] ? ew(b) : [];
            }), DD = Tr(function(d) {
                var b = Wo(d), F = gn(d, fw);
                return b === Wo(F) ? b = r : F.pop(), F.length && F[0] === d[0] ? ew(F, Wt(b, 2)) : [];
            }), FD = Tr(function(d) {
                var b = Wo(d), F = gn(d, fw);
                return b = typeof b == "function" ? b : r, b && F.pop(), F.length && F[0] === d[0] ? ew(F, r, b) : [];
            });
            function zD(d, b) {
                return d == null ? "" : $$.call(d, b);
            }
            function Wo(d) {
                var b = d == null ? 0 : d.length;
                return b ? d[b - 1] : r;
            }
            function jD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = oe;
                return F !== r && (ge = pr(F), ge = ge < 0 ? Kn(oe + ge, 0) : vi(ge, oe - 1)), b === b ? _$(d, b, ge) : U0(d, P8, ge, !0);
            }
            function HD(d, b) {
                return d && d.length ? c6(d, pr(b)) : r;
            }
            var qD = Tr(J6);
            function J6(d, b) {
                return d && d.length && b && b.length ? iw(d, b) : d;
            }
            function KD(d, b, F) {
                return d && d.length && b && b.length ? iw(d, b, Wt(F, 2)) : d;
            }
            function WD(d, b, F) {
                return d && d.length && b && b.length ? iw(d, b, r, F) : d;
            }
            var VD = Ra(function(d, b) {
                var F = d == null ? 0 : d.length, oe = Y1(d, b);
                return l6(d, gn(b, function(ge) {
                    return Ca(ge, F) ? +ge : ge;
                }).sort(_6)), oe;
            });
            function GD(d, b) {
                var F = [];
                if (!(d && d.length)) return F;
                var oe = -1, ge = [], ve = d.length;
                for(b = Wt(b, 3); ++oe < ve;){
                    var Oe = d[oe];
                    b(Oe, oe, d) && (F.push(Oe), ge.push(oe));
                }
                return l6(d, ge), F;
            }
            function Sw(d) {
                return d == null ? d : z$.call(d);
            }
            function ZD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (F && typeof F != "number" && Di(d, b, F) ? (b = 0, F = oe) : (b = b == null ? 0 : pr(b), F = F === r ? oe : pr(F)), Ko(d, b, F)) : [];
            }
            function YD(d, b) {
                return rg(d, b);
            }
            function XD(d, b, F) {
                return aw(d, b, Wt(F, 2));
            }
            function JD(d, b) {
                var F = d == null ? 0 : d.length;
                if (F) {
                    var oe = rg(d, b);
                    if (oe < F && _s(d[oe], b)) return oe;
                }
                return -1;
            }
            function QD(d, b) {
                return rg(d, b, !0);
            }
            function eF(d, b, F) {
                return aw(d, b, Wt(F, 2), !0);
            }
            function tF(d, b) {
                var F = d == null ? 0 : d.length;
                if (F) {
                    var oe = rg(d, b, !0) - 1;
                    if (_s(d[oe], b)) return oe;
                }
                return -1;
            }
            function rF(d) {
                return d && d.length ? h6(d) : [];
            }
            function nF(d, b) {
                return d && d.length ? h6(d, Wt(b, 2)) : [];
            }
            function iF(d) {
                var b = d == null ? 0 : d.length;
                return b ? Ko(d, 1, b) : [];
            }
            function oF(d, b, F) {
                return d && d.length ? (b = F || b === r ? 1 : pr(b), Ko(d, 0, b < 0 ? 0 : b)) : [];
            }
            function sF(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (b = F || b === r ? 1 : pr(b), b = oe - b, Ko(d, b < 0 ? 0 : b, oe)) : [];
            }
            function aF(d, b) {
                return d && d.length ? ng(d, Wt(b, 3), !1, !0) : [];
            }
            function cF(d, b) {
                return d && d.length ? ng(d, Wt(b, 3)) : [];
            }
            var uF = Tr(function(d) {
                return Sc(ui(d, 1, Rn, !0));
            }), fF = Tr(function(d) {
                var b = Wo(d);
                return Rn(b) && (b = r), Sc(ui(d, 1, Rn, !0), Wt(b, 2));
            }), lF = Tr(function(d) {
                var b = Wo(d);
                return b = typeof b == "function" ? b : r, Sc(ui(d, 1, Rn, !0), r, b);
            });
            function dF(d) {
                return d && d.length ? Sc(d) : [];
            }
            function hF(d, b) {
                return d && d.length ? Sc(d, Wt(b, 2)) : [];
            }
            function pF(d, b) {
                return b = typeof b == "function" ? b : r, d && d.length ? Sc(d, r, b) : [];
            }
            function Aw(d) {
                if (!(d && d.length)) return [];
                var b = 0;
                return d = wc(d, function(F) {
                    if (Rn(F)) return b = Kn(F.length, b), !0;
                }), j1(b, function(F) {
                    return gn(d, D1(F));
                });
            }
            function Q6(d, b) {
                if (!(d && d.length)) return [];
                var F = Aw(d);
                return b == null ? F : gn(F, function(oe) {
                    return bo(b, r, oe);
                });
            }
            var gF = Tr(function(d, b) {
                return Rn(d) ? th(d, b) : [];
            }), yF = Tr(function(d) {
                return uw(wc(d, Rn));
            }), mF = Tr(function(d) {
                var b = Wo(d);
                return Rn(b) && (b = r), uw(wc(d, Rn), Wt(b, 2));
            }), bF = Tr(function(d) {
                var b = Wo(d);
                return b = typeof b == "function" ? b : r, uw(wc(d, Rn), r, b);
            }), wF = Tr(Aw);
            function vF(d, b) {
                return m6(d || [], b || [], eh);
            }
            function _F(d, b) {
                return m6(d || [], b || [], ih);
            }
            var EF = Tr(function(d) {
                var b = d.length, F = b > 1 ? d[b - 1] : r;
                return F = typeof F == "function" ? (d.pop(), F) : r, Q6(d, F);
            });
            function e4(d) {
                var b = me(d);
                return b.__chain__ = !0, b;
            }
            function xF(d, b) {
                return b(d), d;
            }
            function dg(d, b) {
                return b(d);
            }
            var SF = Ra(function(d) {
                var b = d.length, F = b ? d[0] : 0, oe = this.__wrapped__, ge = function(ve) {
                    return Y1(ve, d);
                };
                return b > 1 || this.__actions__.length || !(oe instanceof Rr) || !Ca(F) ? this.thru(ge) : (oe = oe.slice(F, +F + (b ? 1 : 0)), oe.__actions__.push({
                    func: dg,
                    args: [
                        ge
                    ],
                    thisArg: r
                }), new Ho(oe, this.__chain__).thru(function(ve) {
                    return b && !ve.length && ve.push(r), ve;
                }));
            });
            function AF() {
                return e4(this);
            }
            function TF() {
                return new Ho(this.value(), this.__chain__);
            }
            function kF() {
                this.__values__ === r && (this.__values__ = p4(this.value()));
                var d = this.__index__ >= this.__values__.length, b = d ? r : this.__values__[this.__index__++];
                return {
                    done: d,
                    value: b
                };
            }
            function IF() {
                return this;
            }
            function BF(d) {
                for(var b, F = this; F instanceof X0;){
                    var oe = V6(F);
                    oe.__index__ = 0, oe.__values__ = r, b ? ge.__wrapped__ = oe : b = oe;
                    var ge = oe;
                    F = F.__wrapped__;
                }
                return ge.__wrapped__ = d, b;
            }
            function OF() {
                var d = this.__wrapped__;
                if (d instanceof Rr) {
                    var b = d;
                    return this.__actions__.length && (b = new Rr(this)), b = b.reverse(), b.__actions__.push({
                        func: dg,
                        args: [
                            Sw
                        ],
                        thisArg: r
                    }), new Ho(b, this.__chain__);
                }
                return this.thru(Sw);
            }
            function PF() {
                return y6(this.__wrapped__, this.__actions__);
            }
            var NF = ig(function(d, b, F) {
                Qr.call(d, F) ? ++d[F] : Na(d, F, 1);
            });
            function MF(d, b, F) {
                var oe = ur(d) ? B8 : xL;
                return F && Di(d, b, F) && (b = r), oe(d, Wt(b, 3));
            }
            function RF(d, b) {
                var F = ur(d) ? wc : Q8;
                return F(d, Wt(b, 3));
            }
            var CF = k6(G6), UF = k6(Z6);
            function $F(d, b) {
                return ui(hg(d, b), 1);
            }
            function LF(d, b) {
                return ui(hg(d, b), T);
            }
            function DF(d, b, F) {
                return F = F === r ? 1 : pr(F), ui(hg(d, b), F);
            }
            function t4(d, b) {
                var F = ur(d) ? zo : xc;
                return F(d, Wt(b, 3));
            }
            function r4(d, b) {
                var F = ur(d) ? i$ : J8;
                return F(d, Wt(b, 3));
            }
            var FF = ig(function(d, b, F) {
                Qr.call(d, F) ? d[F].push(b) : Na(d, F, [
                    b
                ]);
            });
            function zF(d, b, F, oe) {
                d = Xi(d) ? d : sl(d), F = F && !oe ? pr(F) : 0;
                var ge = d.length;
                return F < 0 && (F = Kn(ge + F, 0)), bg(d) ? F <= ge && d.indexOf(b, F) > -1 : !!ge && Gf(d, b, F) > -1;
            }
            var jF = Tr(function(d, b, F) {
                var oe = -1, ge = typeof b == "function", ve = Xi(d) ? Ye(d.length) : [];
                return xc(d, function(Oe) {
                    ve[++oe] = ge ? bo(b, Oe, F) : rh(Oe, b, F);
                }), ve;
            }), HF = ig(function(d, b, F) {
                Na(d, F, b);
            });
            function hg(d, b) {
                var F = ur(d) ? gn : o6;
                return F(d, Wt(b, 3));
            }
            function qF(d, b, F, oe) {
                return d == null ? [] : (ur(b) || (b = b == null ? [] : [
                    b
                ]), F = oe ? r : F, ur(F) || (F = F == null ? [] : [
                    F
                ]), u6(d, b, F));
            }
            var KF = ig(function(d, b, F) {
                d[F ? 0 : 1].push(b);
            }, function() {
                return [
                    [],
                    []
                ];
            });
            function WF(d, b, F) {
                var oe = ur(d) ? $1 : M8, ge = arguments.length < 3;
                return oe(d, Wt(b, 4), F, ge, xc);
            }
            function VF(d, b, F) {
                var oe = ur(d) ? o$ : M8, ge = arguments.length < 3;
                return oe(d, Wt(b, 4), F, ge, J8);
            }
            function GF(d, b) {
                var F = ur(d) ? wc : Q8;
                return F(d, yg(Wt(b, 3)));
            }
            function ZF(d) {
                var b = ur(d) ? G8 : zL;
                return b(d);
            }
            function YF(d, b, F) {
                (F ? Di(d, b, F) : b === r) ? b = 1 : b = pr(b);
                var oe = ur(d) ? bL : jL;
                return oe(d, b);
            }
            function XF(d) {
                var b = ur(d) ? wL : qL;
                return b(d);
            }
            function JF(d) {
                if (d == null) return 0;
                if (Xi(d)) return bg(d) ? Yf(d) : d.length;
                var b = _i(d);
                return b == M || b == Ue ? d.size : rw(d).length;
            }
            function QF(d, b, F) {
                var oe = ur(d) ? L1 : KL;
                return F && Di(d, b, F) && (b = r), oe(d, Wt(b, 3));
            }
            var ez = Tr(function(d, b) {
                if (d == null) return [];
                var F = b.length;
                return F > 1 && Di(d, b[0], b[1]) ? b = [] : F > 2 && Di(b[0], b[1], b[2]) && (b = [
                    b[0]
                ]), u6(d, ui(b, 1), []);
            }), pg = R$ || function() {
                return ci.Date.now();
            };
            function tz(d, b) {
                if (typeof b != "function") throw new jo(s);
                return d = pr(d), function() {
                    if (--d < 1) return b.apply(this, arguments);
                };
            }
            function n4(d, b, F) {
                return b = F ? r : b, b = d && b == null ? d.length : b, Ma(d, Q, r, r, r, r, b);
            }
            function i4(d, b) {
                var F;
                if (typeof b != "function") throw new jo(s);
                return d = pr(d), function() {
                    return --d > 0 && (F = b.apply(this, arguments)), d <= 1 && (b = r), F;
                };
            }
            var Tw = Tr(function(d, b, F) {
                var oe = O;
                if (F.length) {
                    var ge = _c(F, il(Tw));
                    oe |= K;
                }
                return Ma(d, oe, b, F, ge);
            }), o4 = Tr(function(d, b, F) {
                var oe = O | N;
                if (F.length) {
                    var ge = _c(F, il(o4));
                    oe |= K;
                }
                return Ma(b, oe, d, F, ge);
            });
            function s4(d, b, F) {
                b = F ? r : b;
                var oe = Ma(d, D, r, r, r, r, r, b);
                return oe.placeholder = s4.placeholder, oe;
            }
            function a4(d, b, F) {
                b = F ? r : b;
                var oe = Ma(d, H, r, r, r, r, r, b);
                return oe.placeholder = a4.placeholder, oe;
            }
            function c4(d, b, F) {
                var oe, ge, ve, Oe, $e, He, it = 0, st = !1, ft = !1, At = !0;
                if (typeof d != "function") throw new jo(s);
                b = Vo(b) || 0, wn(F) && (st = !!F.leading, ft = "maxWait" in F, ve = ft ? Kn(Vo(F.maxWait) || 0, b) : ve, At = "trailing" in F ? !!F.trailing : At);
                function Ut(Cn) {
                    var Es = oe, La = ge;
                    return oe = ge = r, it = Cn, Oe = d.apply(La, Es), Oe;
                }
                function Vt(Cn) {
                    return it = Cn, $e = ah(Pr, b), st ? Ut(Cn) : Oe;
                }
                function vr(Cn) {
                    var Es = Cn - He, La = Cn - it, k4 = b - Es;
                    return ft ? vi(k4, ve - La) : k4;
                }
                function Gt(Cn) {
                    var Es = Cn - He, La = Cn - it;
                    return He === r || Es >= b || Es < 0 || ft && La >= ve;
                }
                function Pr() {
                    var Cn = pg();
                    if (Gt(Cn)) return Lr(Cn);
                    $e = ah(Pr, vr(Cn));
                }
                function Lr(Cn) {
                    return $e = r, At && oe ? Ut(Cn) : (oe = ge = r, Oe);
                }
                function Eo() {
                    $e !== r && b6($e), it = 0, oe = He = ge = $e = r;
                }
                function Fi() {
                    return $e === r ? Oe : Lr(pg());
                }
                function xo() {
                    var Cn = pg(), Es = Gt(Cn);
                    if (oe = arguments, ge = this, He = Cn, Es) {
                        if ($e === r) return Vt(He);
                        if (ft) return b6($e), $e = ah(Pr, b), Ut(He);
                    }
                    return $e === r && ($e = ah(Pr, b)), Oe;
                }
                return xo.cancel = Eo, xo.flush = Fi, xo;
            }
            var rz = Tr(function(d, b) {
                return X8(d, 1, b);
            }), nz = Tr(function(d, b, F) {
                return X8(d, Vo(b) || 0, F);
            });
            function iz(d) {
                return Ma(d, R);
            }
            function gg(d, b) {
                if (typeof d != "function" || b != null && typeof b != "function") throw new jo(s);
                var F = function() {
                    var oe = arguments, ge = b ? b.apply(this, oe) : oe[0], ve = F.cache;
                    if (ve.has(ge)) return ve.get(ge);
                    var Oe = d.apply(this, oe);
                    return F.cache = ve.set(ge, Oe) || ve, Oe;
                };
                return F.cache = new (gg.Cache || Pa)(), F;
            }
            gg.Cache = Pa;
            function yg(d) {
                if (typeof d != "function") throw new jo(s);
                return function() {
                    var b = arguments;
                    switch(b.length){
                        case 0:
                            return !d.call(this);
                        case 1:
                            return !d.call(this, b[0]);
                        case 2:
                            return !d.call(this, b[0], b[1]);
                        case 3:
                            return !d.call(this, b[0], b[1], b[2]);
                    }
                    return !d.apply(this, b);
                };
            }
            function oz(d) {
                return i4(2, d);
            }
            var sz = WL(function(d, b) {
                b = b.length == 1 && ur(b[0]) ? gn(b[0], wo(Wt())) : gn(ui(b, 1), wo(Wt()));
                var F = b.length;
                return Tr(function(oe) {
                    for(var ge = -1, ve = vi(oe.length, F); ++ge < ve;)oe[ge] = b[ge].call(this, oe[ge]);
                    return bo(d, this, oe);
                });
            }), kw = Tr(function(d, b) {
                var F = _c(b, il(kw));
                return Ma(d, K, r, b, F);
            }), u4 = Tr(function(d, b) {
                var F = _c(b, il(u4));
                return Ma(d, re, r, b, F);
            }), az = Ra(function(d, b) {
                return Ma(d, G, r, r, r, b);
            });
            function cz(d, b) {
                if (typeof d != "function") throw new jo(s);
                return b = b === r ? b : pr(b), Tr(d, b);
            }
            function uz(d, b) {
                if (typeof d != "function") throw new jo(s);
                return b = b == null ? 0 : Kn(pr(b), 0), Tr(function(F) {
                    var oe = F[b], ge = Tc(F, 0, b);
                    return oe && vc(ge, oe), bo(d, this, ge);
                });
            }
            function fz(d, b, F) {
                var oe = !0, ge = !0;
                if (typeof d != "function") throw new jo(s);
                return wn(F) && (oe = "leading" in F ? !!F.leading : oe, ge = "trailing" in F ? !!F.trailing : ge), c4(d, b, {
                    leading: oe,
                    maxWait: b,
                    trailing: ge
                });
            }
            function lz(d) {
                return n4(d, 1);
            }
            function dz(d, b) {
                return kw(lw(b), d);
            }
            function hz() {
                if (!arguments.length) return [];
                var d = arguments[0];
                return ur(d) ? d : [
                    d
                ];
            }
            function pz(d) {
                return qo(d, y);
            }
            function gz(d, b) {
                return b = typeof b == "function" ? b : r, qo(d, y, b);
            }
            function yz(d) {
                return qo(d, l | y);
            }
            function mz(d, b) {
                return b = typeof b == "function" ? b : r, qo(d, l | y, b);
            }
            function bz(d, b) {
                return b == null || Y8(d, b, ti(b));
            }
            function _s(d, b) {
                return d === b || d !== d && b !== b;
            }
            var wz = cg(Q1), vz = cg(function(d, b) {
                return d >= b;
            }), zu = r6(/* @__PURE__ */ function() {
                return arguments;
            }()) ? r6 : function(d) {
                return On(d) && Qr.call(d, "callee") && !j8.call(d, "callee");
            }, ur = Ye.isArray, _z = x8 ? wo(x8) : BL;
            function Xi(d) {
                return d != null && mg(d.length) && !Ua(d);
            }
            function Rn(d) {
                return On(d) && Xi(d);
            }
            function Ez(d) {
                return d === !0 || d === !1 || On(d) && Li(d) == ae;
            }
            var kc = U$ || Lw, xz = S8 ? wo(S8) : OL;
            function Sz(d) {
                return On(d) && d.nodeType === 1 && !ch(d);
            }
            function Az(d) {
                if (d == null) return !0;
                if (Xi(d) && (ur(d) || typeof d == "string" || typeof d.splice == "function" || kc(d) || ol(d) || zu(d))) return !d.length;
                var b = _i(d);
                if (b == M || b == Ue) return !d.size;
                if (sh(d)) return !rw(d).length;
                for(var F in d)if (Qr.call(d, F)) return !1;
                return !0;
            }
            function Tz(d, b) {
                return nh(d, b);
            }
            function kz(d, b, F) {
                F = typeof F == "function" ? F : r;
                var oe = F ? F(d, b) : r;
                return oe === r ? nh(d, b, r, F) : !!oe;
            }
            function Iw(d) {
                if (!On(d)) return !1;
                var b = Li(d);
                return b == De || b == Se || typeof d.message == "string" && typeof d.name == "string" && !ch(d);
            }
            function Iz(d) {
                return typeof d == "number" && q8(d);
            }
            function Ua(d) {
                if (!wn(d)) return !1;
                var b = Li(d);
                return b == Re || b == Ce || b == ee || b == je;
            }
            function f4(d) {
                return typeof d == "number" && d == pr(d);
            }
            function mg(d) {
                return typeof d == "number" && d > -1 && d % 1 == 0 && d <= I;
            }
            function wn(d) {
                var b = typeof d;
                return d != null && (b == "object" || b == "function");
            }
            function On(d) {
                return d != null && typeof d == "object";
            }
            var l4 = A8 ? wo(A8) : NL;
            function Bz(d, b) {
                return d === b || tw(d, b, bw(b));
            }
            function Oz(d, b, F) {
                return F = typeof F == "function" ? F : r, tw(d, b, bw(b), F);
            }
            function Pz(d) {
                return d4(d) && d != +d;
            }
            function Nz(d) {
                if (gD(d)) throw new sr(o);
                return n6(d);
            }
            function Mz(d) {
                return d === null;
            }
            function Rz(d) {
                return d == null;
            }
            function d4(d) {
                return typeof d == "number" || On(d) && Li(d) == z;
            }
            function ch(d) {
                if (!On(d) || Li(d) != _e) return !1;
                var b = q0(d);
                if (b === null) return !0;
                var F = Qr.call(b, "constructor") && b.constructor;
                return typeof F == "function" && F instanceof F && F0.call(F) == O$;
            }
            var Bw = T8 ? wo(T8) : ML;
            function Cz(d) {
                return f4(d) && d >= -I && d <= I;
            }
            var h4 = k8 ? wo(k8) : RL;
            function bg(d) {
                return typeof d == "string" || !ur(d) && On(d) && Li(d) == h;
            }
            function _o(d) {
                return typeof d == "symbol" || On(d) && Li(d) == x;
            }
            var ol = I8 ? wo(I8) : CL;
            function Uz(d) {
                return d === r;
            }
            function $z(d) {
                return On(d) && _i(d) == te;
            }
            function Lz(d) {
                return On(d) && Li(d) == fe;
            }
            var Dz = cg(nw), Fz = cg(function(d, b) {
                return d <= b;
            });
            function p4(d) {
                if (!d) return [];
                if (Xi(d)) return bg(d) ? ws(d) : Yi(d);
                if (Zd && d[Zd]) return b$(d[Zd]());
                var b = _i(d), F = b == M ? q1 : b == Ue ? $0 : sl;
                return F(d);
            }
            function $a(d) {
                if (!d) return d === 0 ? d : 0;
                if (d = Vo(d), d === T || d === -T) {
                    var b = d < 0 ? -1 : 1;
                    return b * P;
                }
                return d === d ? d : 0;
            }
            function pr(d) {
                var b = $a(d), F = b % 1;
                return b === b ? F ? b - F : b : 0;
            }
            function g4(d) {
                return d ? $u(pr(d), 0, L) : 0;
            }
            function Vo(d) {
                if (typeof d == "number") return d;
                if (_o(d)) return k;
                if (wn(d)) {
                    var b = typeof d.valueOf == "function" ? d.valueOf() : d;
                    d = wn(b) ? b + "" : b;
                }
                if (typeof d != "string") return d === 0 ? d : +d;
                d = R8(d);
                var F = xt.test(d);
                return F || Pe.test(d) ? t$(d.slice(2), F ? 2 : 8) : Xe.test(d) ? k : +d;
            }
            function y4(d) {
                return Ks(d, Ji(d));
            }
            function zz(d) {
                return d ? $u(pr(d), -I, I) : d === 0 ? d : 0;
            }
            function Yr(d) {
                return d == null ? "" : vo(d);
            }
            var jz = rl(function(d, b) {
                if (sh(b) || Xi(b)) {
                    Ks(b, ti(b), d);
                    return;
                }
                for(var F in b)Qr.call(b, F) && eh(d, F, b[F]);
            }), m4 = rl(function(d, b) {
                Ks(b, Ji(b), d);
            }), wg = rl(function(d, b, F, oe) {
                Ks(b, Ji(b), d, oe);
            }), Hz = rl(function(d, b, F, oe) {
                Ks(b, ti(b), d, oe);
            }), qz = Ra(Y1);
            function Kz(d, b) {
                var F = tl(d);
                return b == null ? F : Z8(F, b);
            }
            var Wz = Tr(function(d, b) {
                d = an(d);
                var F = -1, oe = b.length, ge = oe > 2 ? b[2] : r;
                for(ge && Di(b[0], b[1], ge) && (oe = 1); ++F < oe;)for(var ve = b[F], Oe = Ji(ve), $e = -1, He = Oe.length; ++$e < He;){
                    var it = Oe[$e], st = d[it];
                    (st === r || _s(st, Jf[it]) && !Qr.call(d, it)) && (d[it] = ve[it]);
                }
                return d;
            }), Vz = Tr(function(d) {
                return d.push(r, R6), bo(b4, r, d);
            });
            function Gz(d, b) {
                return O8(d, Wt(b, 3), qs);
            }
            function Zz(d, b) {
                return O8(d, Wt(b, 3), J1);
            }
            function Yz(d, b) {
                return d == null ? d : X1(d, Wt(b, 3), Ji);
            }
            function Xz(d, b) {
                return d == null ? d : e6(d, Wt(b, 3), Ji);
            }
            function Jz(d, b) {
                return d && qs(d, Wt(b, 3));
            }
            function Qz(d, b) {
                return d && J1(d, Wt(b, 3));
            }
            function ej(d) {
                return d == null ? [] : eg(d, ti(d));
            }
            function tj(d) {
                return d == null ? [] : eg(d, Ji(d));
            }
            function Ow(d, b, F) {
                var oe = d == null ? r : Lu(d, b);
                return oe === r ? F : oe;
            }
            function rj(d, b) {
                return d != null && $6(d, b, AL);
            }
            function Pw(d, b) {
                return d != null && $6(d, b, TL);
            }
            var nj = B6(function(d, b, F) {
                b != null && typeof b.toString != "function" && (b = z0.call(b)), d[b] = F;
            }, Mw(Qi)), ij = B6(function(d, b, F) {
                b != null && typeof b.toString != "function" && (b = z0.call(b)), Qr.call(d, b) ? d[b].push(F) : d[b] = [
                    F
                ];
            }, Wt), oj = Tr(rh);
            function ti(d) {
                return Xi(d) ? V8(d) : rw(d);
            }
            function Ji(d) {
                return Xi(d) ? V8(d, !0) : UL(d);
            }
            function sj(d, b) {
                var F = {};
                return b = Wt(b, 3), qs(d, function(oe, ge, ve) {
                    Na(F, b(oe, ge, ve), oe);
                }), F;
            }
            function aj(d, b) {
                var F = {};
                return b = Wt(b, 3), qs(d, function(oe, ge, ve) {
                    Na(F, ge, b(oe, ge, ve));
                }), F;
            }
            var cj = rl(function(d, b, F) {
                tg(d, b, F);
            }), b4 = rl(function(d, b, F, oe) {
                tg(d, b, F, oe);
            }), uj = Ra(function(d, b) {
                var F = {};
                if (d == null) return F;
                var oe = !1;
                b = gn(b, function(ve) {
                    return ve = Ac(ve, d), oe || (oe = ve.length > 1), ve;
                }), Ks(d, yw(d), F), oe && (F = qo(F, l | p | y, nD));
                for(var ge = b.length; ge--;)cw(F, b[ge]);
                return F;
            });
            function fj(d, b) {
                return w4(d, yg(Wt(b)));
            }
            var lj = Ra(function(d, b) {
                return d == null ? {} : LL(d, b);
            });
            function w4(d, b) {
                if (d == null) return {};
                var F = gn(yw(d), function(oe) {
                    return [
                        oe
                    ];
                });
                return b = Wt(b), f6(d, F, function(oe, ge) {
                    return b(oe, ge[0]);
                });
            }
            function dj(d, b, F) {
                b = Ac(b, d);
                var oe = -1, ge = b.length;
                for(ge || (ge = 1, d = r); ++oe < ge;){
                    var ve = d == null ? r : d[Ws(b[oe])];
                    ve === r && (oe = ge, ve = F), d = Ua(ve) ? ve.call(d) : ve;
                }
                return d;
            }
            function hj(d, b, F) {
                return d == null ? d : ih(d, b, F);
            }
            function pj(d, b, F, oe) {
                return oe = typeof oe == "function" ? oe : r, d == null ? d : ih(d, b, F, oe);
            }
            var v4 = N6(ti), _4 = N6(Ji);
            function gj(d, b, F) {
                var oe = ur(d), ge = oe || kc(d) || ol(d);
                if (b = Wt(b, 4), F == null) {
                    var ve = d && d.constructor;
                    ge ? F = oe ? new ve() : [] : wn(d) ? F = Ua(ve) ? tl(q0(d)) : {} : F = {};
                }
                return (ge ? zo : qs)(d, function(Oe, $e, He) {
                    return b(F, Oe, $e, He);
                }), F;
            }
            function yj(d, b) {
                return d == null ? !0 : cw(d, b);
            }
            function mj(d, b, F) {
                return d == null ? d : g6(d, b, lw(F));
            }
            function bj(d, b, F, oe) {
                return oe = typeof oe == "function" ? oe : r, d == null ? d : g6(d, b, lw(F), oe);
            }
            function sl(d) {
                return d == null ? [] : H1(d, ti(d));
            }
            function wj(d) {
                return d == null ? [] : H1(d, Ji(d));
            }
            function vj(d, b, F) {
                return F === r && (F = b, b = r), F !== r && (F = Vo(F), F = F === F ? F : 0), b !== r && (b = Vo(b), b = b === b ? b : 0), $u(Vo(d), b, F);
            }
            function _j(d, b, F) {
                return b = $a(b), F === r ? (F = b, b = 0) : F = $a(F), d = Vo(d), kL(d, b, F);
            }
            function Ej(d, b, F) {
                if (F && typeof F != "boolean" && Di(d, b, F) && (b = F = r), F === r && (typeof b == "boolean" ? (F = b, b = r) : typeof d == "boolean" && (F = d, d = r)), d === r && b === r ? (d = 0, b = 1) : (d = $a(d), b === r ? (b = d, d = 0) : b = $a(b)), d > b) {
                    var oe = d;
                    d = b, b = oe;
                }
                if (F || d % 1 || b % 1) {
                    var ge = K8();
                    return vi(d + ge * (b - d + e$("1e-" + ((ge + "").length - 1))), b);
                }
                return ow(d, b);
            }
            var xj = nl(function(d, b, F) {
                return b = b.toLowerCase(), d + (F ? E4(b) : b);
            });
            function E4(d) {
                return Nw(Yr(d).toLowerCase());
            }
            function x4(d) {
                return d = Yr(d), d && d.replace(vt, h$).replace(qU, "");
            }
            function Sj(d, b, F) {
                d = Yr(d), b = vo(b);
                var oe = d.length;
                F = F === r ? oe : $u(pr(F), 0, oe);
                var ge = F;
                return F -= b.length, F >= 0 && d.slice(F, ge) == b;
            }
            function Aj(d) {
                return d = Yr(d), d && jr.test(d) ? d.replace(Lt, p$) : d;
            }
            function Tj(d) {
                return d = Yr(d), d && Me.test(d) ? d.replace(xe, "\\$&") : d;
            }
            var kj = nl(function(d, b, F) {
                return d + (F ? "-" : "") + b.toLowerCase();
            }), Ij = nl(function(d, b, F) {
                return d + (F ? " " : "") + b.toLowerCase();
            }), Bj = T6("toLowerCase");
            function Oj(d, b, F) {
                d = Yr(d), b = pr(b);
                var oe = b ? Yf(d) : 0;
                if (!b || oe >= b) return d;
                var ge = (b - oe) / 2;
                return ag(G0(ge), F) + d + ag(V0(ge), F);
            }
            function Pj(d, b, F) {
                d = Yr(d), b = pr(b);
                var oe = b ? Yf(d) : 0;
                return b && oe < b ? d + ag(b - oe, F) : d;
            }
            function Nj(d, b, F) {
                d = Yr(d), b = pr(b);
                var oe = b ? Yf(d) : 0;
                return b && oe < b ? ag(b - oe, F) + d : d;
            }
            function Mj(d, b, F) {
                return F || b == null ? b = 0 : b && (b = +b), F$(Yr(d).replace(ze, ""), b || 0);
            }
            function Rj(d, b, F) {
                return (F ? Di(d, b, F) : b === r) ? b = 1 : b = pr(b), sw(Yr(d), b);
            }
            function Cj() {
                var d = arguments, b = Yr(d[0]);
                return d.length < 3 ? b : b.replace(d[1], d[2]);
            }
            var Uj = nl(function(d, b, F) {
                return d + (F ? "_" : "") + b.toLowerCase();
            });
            function $j(d, b, F) {
                return F && typeof F != "number" && Di(d, b, F) && (b = F = r), F = F === r ? L : F >>> 0, F ? (d = Yr(d), d && (typeof b == "string" || b != null && !Bw(b)) && (b = vo(b), !b && Zf(d)) ? Tc(ws(d), 0, F) : d.split(b, F)) : [];
            }
            var Lj = nl(function(d, b, F) {
                return d + (F ? " " : "") + Nw(b);
            });
            function Dj(d, b, F) {
                return d = Yr(d), F = F == null ? 0 : $u(pr(F), 0, d.length), b = vo(b), d.slice(F, F + b.length) == b;
            }
            function Fj(d, b, F) {
                var oe = me.templateSettings;
                F && Di(d, b, F) && (b = r), d = Yr(d), b = wg({}, b, oe, M6);
                var ge = wg({}, b.imports, oe.imports, M6), ve = ti(ge), Oe = H1(ge, ve), $e, He, it = 0, st = b.interpolate || be, ft = "__p += '", At = K1((b.escape || be).source + "|" + st.source + "|" + (st === wr ? Mt : be).source + "|" + (b.evaluate || be).source + "|$", "g"), Ut = "//# sourceURL=" + (Qr.call(b, "sourceURL") ? (b.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ZU + "]") + `
`;
                d.replace(At, function(Gt, Pr, Lr, Eo, Fi, xo) {
                    return Lr || (Lr = Eo), ft += d.slice(it, xo).replace($r, g$), Pr && ($e = !0, ft += `' +
__e(` + Pr + `) +
'`), Fi && (He = !0, ft += `';
` + Fi + `;
__p += '`), Lr && (ft += `' +
((__t = (` + Lr + `)) == null ? '' : __t) +
'`), it = xo + Gt.length, Gt;
                }), ft += `';
`;
                var Vt = Qr.call(b, "variable") && b.variable;
                if (!Vt) ft = `with (obj) {
` + ft + `
}
`;
                else if (wt.test(Vt)) throw new sr(a);
                ft = (He ? ft.replace(yt, "") : ft).replace(_t, "$1").replace(Qe, "$1;"), ft = "function(" + (Vt || "obj") + `) {
` + (Vt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + ($e ? ", __e = _.escape" : "") + (He ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ft + `return __p
}`;
                var vr = A4(function() {
                    return Wr(ve, Ut + "return " + ft).apply(r, Oe);
                });
                if (vr.source = ft, Iw(vr)) throw vr;
                return vr;
            }
            function zj(d) {
                return Yr(d).toLowerCase();
            }
            function jj(d) {
                return Yr(d).toUpperCase();
            }
            function Hj(d, b, F) {
                if (d = Yr(d), d && (F || b === r)) return R8(d);
                if (!d || !(b = vo(b))) return d;
                var oe = ws(d), ge = ws(b), ve = C8(oe, ge), Oe = U8(oe, ge) + 1;
                return Tc(oe, ve, Oe).join("");
            }
            function qj(d, b, F) {
                if (d = Yr(d), d && (F || b === r)) return d.slice(0, L8(d) + 1);
                if (!d || !(b = vo(b))) return d;
                var oe = ws(d), ge = U8(oe, ws(b)) + 1;
                return Tc(oe, 0, ge).join("");
            }
            function Kj(d, b, F) {
                if (d = Yr(d), d && (F || b === r)) return d.replace(ze, "");
                if (!d || !(b = vo(b))) return d;
                var oe = ws(d), ge = C8(oe, ws(b));
                return Tc(oe, ge).join("");
            }
            function Wj(d, b) {
                var F = X, oe = $;
                if (wn(b)) {
                    var ge = "separator" in b ? b.separator : ge;
                    F = "length" in b ? pr(b.length) : F, oe = "omission" in b ? vo(b.omission) : oe;
                }
                d = Yr(d);
                var ve = d.length;
                if (Zf(d)) {
                    var Oe = ws(d);
                    ve = Oe.length;
                }
                if (F >= ve) return d;
                var $e = F - Yf(oe);
                if ($e < 1) return oe;
                var He = Oe ? Tc(Oe, 0, $e).join("") : d.slice(0, $e);
                if (ge === r) return He + oe;
                if (Oe && ($e += He.length - $e), Bw(ge)) {
                    if (d.slice($e).search(ge)) {
                        var it, st = He;
                        for(ge.global || (ge = K1(ge.source, Yr(Ct.exec(ge)) + "g")), ge.lastIndex = 0; it = ge.exec(st);)var ft = it.index;
                        He = He.slice(0, ft === r ? $e : ft);
                    }
                } else if (d.indexOf(vo(ge), $e) != $e) {
                    var At = He.lastIndexOf(ge);
                    At > -1 && (He = He.slice(0, At));
                }
                return He + oe;
            }
            function Vj(d) {
                return d = Yr(d), d && Ur.test(d) ? d.replace(Rt, E$) : d;
            }
            var Gj = nl(function(d, b, F) {
                return d + (F ? " " : "") + b.toUpperCase();
            }), Nw = T6("toUpperCase");
            function S4(d, b, F) {
                return d = Yr(d), b = F ? r : b, b === r ? m$(d) ? A$(d) : c$(d) : d.match(b) || [];
            }
            var A4 = Tr(function(d, b) {
                try {
                    return bo(d, r, b);
                } catch (F) {
                    return Iw(F) ? F : new sr(F);
                }
            }), Zj = Ra(function(d, b) {
                return zo(b, function(F) {
                    F = Ws(F), Na(d, F, Tw(d[F], d));
                }), d;
            });
            function Yj(d) {
                var b = d == null ? 0 : d.length, F = Wt();
                return d = b ? gn(d, function(oe) {
                    if (typeof oe[1] != "function") throw new jo(s);
                    return [
                        F(oe[0]),
                        oe[1]
                    ];
                }) : [], Tr(function(oe) {
                    for(var ge = -1; ++ge < b;){
                        var ve = d[ge];
                        if (bo(ve[0], this, oe)) return bo(ve[1], this, oe);
                    }
                });
            }
            function Xj(d) {
                return EL(qo(d, l));
            }
            function Mw(d) {
                return function() {
                    return d;
                };
            }
            function Jj(d, b) {
                return d == null || d !== d ? b : d;
            }
            var Qj = I6(), eH = I6(!0);
            function Qi(d) {
                return d;
            }
            function Rw(d) {
                return i6(typeof d == "function" ? d : qo(d, l));
            }
            function tH(d) {
                return s6(qo(d, l));
            }
            function rH(d, b) {
                return a6(d, qo(b, l));
            }
            var nH = Tr(function(d, b) {
                return function(F) {
                    return rh(F, d, b);
                };
            }), iH = Tr(function(d, b) {
                return function(F) {
                    return rh(d, F, b);
                };
            });
            function Cw(d, b, F) {
                var oe = ti(b), ge = eg(b, oe);
                F == null && !(wn(b) && (ge.length || !oe.length)) && (F = b, b = d, d = this, ge = eg(b, ti(b)));
                var ve = !(wn(F) && "chain" in F) || !!F.chain, Oe = Ua(d);
                return zo(ge, function($e) {
                    var He = b[$e];
                    d[$e] = He, Oe && (d.prototype[$e] = function() {
                        var it = this.__chain__;
                        if (ve || it) {
                            var st = d(this.__wrapped__), ft = st.__actions__ = Yi(this.__actions__);
                            return ft.push({
                                func: He,
                                args: arguments,
                                thisArg: d
                            }), st.__chain__ = it, st;
                        }
                        return He.apply(d, vc([
                            this.value()
                        ], arguments));
                    });
                }), d;
            }
            function oH() {
                return ci._ === this && (ci._ = P$), this;
            }
            function Uw() {}
            function sH(d) {
                return d = pr(d), Tr(function(b) {
                    return c6(b, d);
                });
            }
            var aH = hw(gn), cH = hw(B8), uH = hw(L1);
            function T4(d) {
                return vw(d) ? D1(Ws(d)) : DL(d);
            }
            function fH(d) {
                return function(b) {
                    return d == null ? r : Lu(d, b);
                };
            }
            var lH = O6(), dH = O6(!0);
            function $w() {
                return [];
            }
            function Lw() {
                return !1;
            }
            function hH() {
                return {};
            }
            function pH() {
                return "";
            }
            function gH() {
                return !0;
            }
            function yH(d, b) {
                if (d = pr(d), d < 1 || d > I) return [];
                var F = L, oe = vi(d, L);
                b = Wt(b), d -= L;
                for(var ge = j1(oe, b); ++F < d;)b(F);
                return ge;
            }
            function mH(d) {
                return ur(d) ? gn(d, Ws) : _o(d) ? [
                    d
                ] : Yi(W6(Yr(d)));
            }
            function bH(d) {
                var b = ++B$;
                return Yr(d) + b;
            }
            var wH = sg(function(d, b) {
                return d + b;
            }, 0), vH = pw("ceil"), _H = sg(function(d, b) {
                return d / b;
            }, 1), EH = pw("floor");
            function xH(d) {
                return d && d.length ? Q0(d, Qi, Q1) : r;
            }
            function SH(d, b) {
                return d && d.length ? Q0(d, Wt(b, 2), Q1) : r;
            }
            function AH(d) {
                return N8(d, Qi);
            }
            function TH(d, b) {
                return N8(d, Wt(b, 2));
            }
            function kH(d) {
                return d && d.length ? Q0(d, Qi, nw) : r;
            }
            function IH(d, b) {
                return d && d.length ? Q0(d, Wt(b, 2), nw) : r;
            }
            var BH = sg(function(d, b) {
                return d * b;
            }, 1), OH = pw("round"), PH = sg(function(d, b) {
                return d - b;
            }, 0);
            function NH(d) {
                return d && d.length ? z1(d, Qi) : 0;
            }
            function MH(d, b) {
                return d && d.length ? z1(d, Wt(b, 2)) : 0;
            }
            return me.after = tz, me.ary = n4, me.assign = jz, me.assignIn = m4, me.assignInWith = wg, me.assignWith = Hz, me.at = qz, me.before = i4, me.bind = Tw, me.bindAll = Zj, me.bindKey = o4, me.castArray = hz, me.chain = e4, me.chunk = ED, me.compact = xD, me.concat = SD, me.cond = Yj, me.conforms = Xj, me.constant = Mw, me.countBy = NF, me.create = Kz, me.curry = s4, me.curryRight = a4, me.debounce = c4, me.defaults = Wz, me.defaultsDeep = Vz, me.defer = rz, me.delay = nz, me.difference = AD, me.differenceBy = TD, me.differenceWith = kD, me.drop = ID, me.dropRight = BD, me.dropRightWhile = OD, me.dropWhile = PD, me.fill = ND, me.filter = RF, me.flatMap = $F, me.flatMapDeep = LF, me.flatMapDepth = DF, me.flatten = Y6, me.flattenDeep = MD, me.flattenDepth = RD, me.flip = iz, me.flow = Qj, me.flowRight = eH, me.fromPairs = CD, me.functions = ej, me.functionsIn = tj, me.groupBy = FF, me.initial = $D, me.intersection = LD, me.intersectionBy = DD, me.intersectionWith = FD, me.invert = nj, me.invertBy = ij, me.invokeMap = jF, me.iteratee = Rw, me.keyBy = HF, me.keys = ti, me.keysIn = Ji, me.map = hg, me.mapKeys = sj, me.mapValues = aj, me.matches = tH, me.matchesProperty = rH, me.memoize = gg, me.merge = cj, me.mergeWith = b4, me.method = nH, me.methodOf = iH, me.mixin = Cw, me.negate = yg, me.nthArg = sH, me.omit = uj, me.omitBy = fj, me.once = oz, me.orderBy = qF, me.over = aH, me.overArgs = sz, me.overEvery = cH, me.overSome = uH, me.partial = kw, me.partialRight = u4, me.partition = KF, me.pick = lj, me.pickBy = w4, me.property = T4, me.propertyOf = fH, me.pull = qD, me.pullAll = J6, me.pullAllBy = KD, me.pullAllWith = WD, me.pullAt = VD, me.range = lH, me.rangeRight = dH, me.rearg = az, me.reject = GF, me.remove = GD, me.rest = cz, me.reverse = Sw, me.sampleSize = YF, me.set = hj, me.setWith = pj, me.shuffle = XF, me.slice = ZD, me.sortBy = ez, me.sortedUniq = rF, me.sortedUniqBy = nF, me.split = $j, me.spread = uz, me.tail = iF, me.take = oF, me.takeRight = sF, me.takeRightWhile = aF, me.takeWhile = cF, me.tap = xF, me.throttle = fz, me.thru = dg, me.toArray = p4, me.toPairs = v4, me.toPairsIn = _4, me.toPath = mH, me.toPlainObject = y4, me.transform = gj, me.unary = lz, me.union = uF, me.unionBy = fF, me.unionWith = lF, me.uniq = dF, me.uniqBy = hF, me.uniqWith = pF, me.unset = yj, me.unzip = Aw, me.unzipWith = Q6, me.update = mj, me.updateWith = bj, me.values = sl, me.valuesIn = wj, me.without = gF, me.words = S4, me.wrap = dz, me.xor = yF, me.xorBy = mF, me.xorWith = bF, me.zip = wF, me.zipObject = vF, me.zipObjectDeep = _F, me.zipWith = EF, me.entries = v4, me.entriesIn = _4, me.extend = m4, me.extendWith = wg, Cw(me, me), me.add = wH, me.attempt = A4, me.camelCase = xj, me.capitalize = E4, me.ceil = vH, me.clamp = vj, me.clone = pz, me.cloneDeep = yz, me.cloneDeepWith = mz, me.cloneWith = gz, me.conformsTo = bz, me.deburr = x4, me.defaultTo = Jj, me.divide = _H, me.endsWith = Sj, me.eq = _s, me.escape = Aj, me.escapeRegExp = Tj, me.every = MF, me.find = CF, me.findIndex = G6, me.findKey = Gz, me.findLast = UF, me.findLastIndex = Z6, me.findLastKey = Zz, me.floor = EH, me.forEach = t4, me.forEachRight = r4, me.forIn = Yz, me.forInRight = Xz, me.forOwn = Jz, me.forOwnRight = Qz, me.get = Ow, me.gt = wz, me.gte = vz, me.has = rj, me.hasIn = Pw, me.head = X6, me.identity = Qi, me.includes = zF, me.indexOf = UD, me.inRange = _j, me.invoke = oj, me.isArguments = zu, me.isArray = ur, me.isArrayBuffer = _z, me.isArrayLike = Xi, me.isArrayLikeObject = Rn, me.isBoolean = Ez, me.isBuffer = kc, me.isDate = xz, me.isElement = Sz, me.isEmpty = Az, me.isEqual = Tz, me.isEqualWith = kz, me.isError = Iw, me.isFinite = Iz, me.isFunction = Ua, me.isInteger = f4, me.isLength = mg, me.isMap = l4, me.isMatch = Bz, me.isMatchWith = Oz, me.isNaN = Pz, me.isNative = Nz, me.isNil = Rz, me.isNull = Mz, me.isNumber = d4, me.isObject = wn, me.isObjectLike = On, me.isPlainObject = ch, me.isRegExp = Bw, me.isSafeInteger = Cz, me.isSet = h4, me.isString = bg, me.isSymbol = _o, me.isTypedArray = ol, me.isUndefined = Uz, me.isWeakMap = $z, me.isWeakSet = Lz, me.join = zD, me.kebabCase = kj, me.last = Wo, me.lastIndexOf = jD, me.lowerCase = Ij, me.lowerFirst = Bj, me.lt = Dz, me.lte = Fz, me.max = xH, me.maxBy = SH, me.mean = AH, me.meanBy = TH, me.min = kH, me.minBy = IH, me.stubArray = $w, me.stubFalse = Lw, me.stubObject = hH, me.stubString = pH, me.stubTrue = gH, me.multiply = BH, me.nth = HD, me.noConflict = oH, me.noop = Uw, me.now = pg, me.pad = Oj, me.padEnd = Pj, me.padStart = Nj, me.parseInt = Mj, me.random = Ej, me.reduce = WF, me.reduceRight = VF, me.repeat = Rj, me.replace = Cj, me.result = dj, me.round = OH, me.runInContext = Fe, me.sample = ZF, me.size = JF, me.snakeCase = Uj, me.some = QF, me.sortedIndex = YD, me.sortedIndexBy = XD, me.sortedIndexOf = JD, me.sortedLastIndex = QD, me.sortedLastIndexBy = eF, me.sortedLastIndexOf = tF, me.startCase = Lj, me.startsWith = Dj, me.subtract = PH, me.sum = NH, me.sumBy = MH, me.template = Fj, me.times = yH, me.toFinite = $a, me.toInteger = pr, me.toLength = g4, me.toLower = zj, me.toNumber = Vo, me.toSafeInteger = zz, me.toString = Yr, me.toUpper = jj, me.trim = Hj, me.trimEnd = qj, me.trimStart = Kj, me.truncate = Wj, me.unescape = Vj, me.uniqueId = bH, me.upperCase = Gj, me.upperFirst = Nw, me.each = t4, me.eachRight = r4, me.first = X6, Cw(me, function() {
                var d = {};
                return qs(me, function(b, F) {
                    Qr.call(me.prototype, F) || (d[F] = b);
                }), d;
            }(), {
                chain: !1
            }), me.VERSION = n, zo([
                "bind",
                "bindKey",
                "curry",
                "curryRight",
                "partial",
                "partialRight"
            ], function(d) {
                me[d].placeholder = me;
            }), zo([
                "drop",
                "take"
            ], function(d, b) {
                Rr.prototype[d] = function(F) {
                    F = F === r ? 1 : Kn(pr(F), 0);
                    var oe = this.__filtered__ && !b ? new Rr(this) : this.clone();
                    return oe.__filtered__ ? oe.__takeCount__ = vi(F, oe.__takeCount__) : oe.__views__.push({
                        size: vi(F, L),
                        type: d + (oe.__dir__ < 0 ? "Right" : "")
                    }), oe;
                }, Rr.prototype[d + "Right"] = function(F) {
                    return this.reverse()[d](F).reverse();
                };
            }), zo([
                "filter",
                "map",
                "takeWhile"
            ], function(d, b) {
                var F = b + 1, oe = F == g || F == E;
                Rr.prototype[d] = function(ge) {
                    var ve = this.clone();
                    return ve.__iteratees__.push({
                        iteratee: Wt(ge, 3),
                        type: F
                    }), ve.__filtered__ = ve.__filtered__ || oe, ve;
                };
            }), zo([
                "head",
                "last"
            ], function(d, b) {
                var F = "take" + (b ? "Right" : "");
                Rr.prototype[d] = function() {
                    return this[F](1).value()[0];
                };
            }), zo([
                "initial",
                "tail"
            ], function(d, b) {
                var F = "drop" + (b ? "" : "Right");
                Rr.prototype[d] = function() {
                    return this.__filtered__ ? new Rr(this) : this[F](1);
                };
            }), Rr.prototype.compact = function() {
                return this.filter(Qi);
            }, Rr.prototype.find = function(d) {
                return this.filter(d).head();
            }, Rr.prototype.findLast = function(d) {
                return this.reverse().find(d);
            }, Rr.prototype.invokeMap = Tr(function(d, b) {
                return typeof d == "function" ? new Rr(this) : this.map(function(F) {
                    return rh(F, d, b);
                });
            }), Rr.prototype.reject = function(d) {
                return this.filter(yg(Wt(d)));
            }, Rr.prototype.slice = function(d, b) {
                d = pr(d);
                var F = this;
                return F.__filtered__ && (d > 0 || b < 0) ? new Rr(F) : (d < 0 ? F = F.takeRight(-d) : d && (F = F.drop(d)), b !== r && (b = pr(b), F = b < 0 ? F.dropRight(-b) : F.take(b - d)), F);
            }, Rr.prototype.takeRightWhile = function(d) {
                return this.reverse().takeWhile(d).reverse();
            }, Rr.prototype.toArray = function() {
                return this.take(L);
            }, qs(Rr.prototype, function(d, b) {
                var F = /^(?:filter|find|map|reject)|While$/.test(b), oe = /^(?:head|last)$/.test(b), ge = me[oe ? "take" + (b == "last" ? "Right" : "") : b], ve = oe || /^find/.test(b);
                ge && (me.prototype[b] = function() {
                    var Oe = this.__wrapped__, $e = oe ? [
                        1
                    ] : arguments, He = Oe instanceof Rr, it = $e[0], st = He || ur(Oe), ft = function(Pr) {
                        var Lr = ge.apply(me, vc([
                            Pr
                        ], $e));
                        return oe && At ? Lr[0] : Lr;
                    };
                    st && F && typeof it == "function" && it.length != 1 && (He = st = !1);
                    var At = this.__chain__, Ut = !!this.__actions__.length, Vt = ve && !At, vr = He && !Ut;
                    if (!ve && st) {
                        Oe = vr ? Oe : new Rr(this);
                        var Gt = d.apply(Oe, $e);
                        return Gt.__actions__.push({
                            func: dg,
                            args: [
                                ft
                            ],
                            thisArg: r
                        }), new Ho(Gt, At);
                    }
                    return Vt && vr ? d.apply(this, $e) : (Gt = this.thru(ft), Vt ? oe ? Gt.value()[0] : Gt.value() : Gt);
                });
            }), zo([
                "pop",
                "push",
                "shift",
                "sort",
                "splice",
                "unshift"
            ], function(d) {
                var b = L0[d], F = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru", oe = /^(?:pop|shift)$/.test(d);
                me.prototype[d] = function() {
                    var ge = arguments;
                    if (oe && !this.__chain__) {
                        var ve = this.value();
                        return b.apply(ur(ve) ? ve : [], ge);
                    }
                    return this[F](function(Oe) {
                        return b.apply(ur(Oe) ? Oe : [], ge);
                    });
                };
            }), qs(Rr.prototype, function(d, b) {
                var F = me[b];
                if (F) {
                    var oe = F.name + "";
                    Qr.call(el, oe) || (el[oe] = []), el[oe].push({
                        name: b,
                        func: F
                    });
                }
            }), el[og(r, N).name] = [
                {
                    name: "wrapper",
                    func: r
                }
            ], Rr.prototype.clone = V$, Rr.prototype.reverse = G$, Rr.prototype.value = Z$, me.prototype.at = SF, me.prototype.chain = AF, me.prototype.commit = TF, me.prototype.next = kF, me.prototype.plant = BF, me.prototype.reverse = OF, me.prototype.toJSON = me.prototype.valueOf = me.prototype.value = PF, me.prototype.first = me.prototype.head, Zd && (me.prototype[Zd] = IF), me;
        }, Xf = T$();
        Mu ? ((Mu.exports = Xf)._ = Xf, R1._ = Xf) : ci._ = Xf;
    }).call(Ge);
})(Sm, Sm.exports);
var dce = Sm.exports;
Object.defineProperty(c1, "__esModule", {
    value: !0
});
c1.SandshrewProvider = void 0;
const hce = _0, pce = dce;
let gce = 0;
class yce extends hce.AbstractProvider {
    constructor(t){
        super(), this.url = t;
    }
    async call(t, r) {
        const n = await (await fetch(this.url, {
            method: "POST",
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: gce++,
                params: r,
                method: t
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).text();
        return JSON.parse(n).result;
    }
    async enrichOutput({ vout: t, txid: r }) {
        return await this.call("ord_output", [
            `${r}:${t}`
        ]);
    }
    async getBTCOnlyUTXOs(t) {
        const r = await this.getUTXOs(t), { inscriptions: n } = await this.call("ord_address", [
            t
        ]), i = (0, pce.zipObject)(n, n);
        return r.filter((o)=>!i[`${o.outpoint.txid}:${o.outpoint.vout}`] && o.runes.length === 0);
    }
    async getUTXOs(t) {
        return (await this.call("alkanes_protorunesbyaddress", [
            {
                address: t,
                protocolTag: "1"
            }
        ])).outpoints;
    }
}
c1.SandshrewProvider = yce;
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(_0, e), r(E0, e), r(a1, e), r(c1, e);
})(uM);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(h0, e), r(eM, e), r(Jr, e), r(uo, e), r(w0, e), r(uM, e);
})(ec);
const kI = BigInt(546), mce = 77;
function gx(e, t, r) {
    const a = e * 64 + t * 42, u = r * 40;
    return 10 + a + u;
}
const iu = 546n, Jo = {
    mainnet: {
        p2pkh: /^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(bc1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(bc1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    },
    testnet: {
        p2pkh: /^[mn][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[2][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(tb1[qp]|bcrt1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(tb1p|bcrt1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    },
    regtest: {
        p2pkh: /^[mn][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[2][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(tb1[qp]|bcrt1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(tb1p|bcrt1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    }
};
function bce(e) {
    return Jo.mainnet.p2pkh.test(e) || Jo.testnet.p2pkh.test(e) || Jo.regtest.p2pkh.test(e) ? 0 : Jo.mainnet.p2tr.test(e) || Jo.testnet.p2tr.test(e) || Jo.regtest.p2tr.test(e) ? 1 : Jo.mainnet.p2sh.test(e) || Jo.testnet.p2sh.test(e) || Jo.regtest.p2sh.test(e) ? 2 : Jo.mainnet.p2wpkh.test(e) || Jo.testnet.p2wpkh.test(e) || Jo.regtest.p2wpkh.test(e) ? 3 : null;
}
function Am(e, t) {
    let r = 0;
    const n = [];
    for (const i of e){
        if (r >= t) break;
        n.push(i), r += i.btcValue;
    }
    return {
        utxos: n,
        totalAmount: r
    };
}
const fM = async ({ _psbt: e, senderPublicKey: t, network: r })=>{
    let n = 0;
    for await (const i of e.data.inputs){
        const o = i.finalScriptSig || i.finalScriptWitness, s = !i.tapInternalKey;
        if (!o || s) {
            const a = Mo(We.from(t, "hex")), u = xd({
                internalPubkey: a,
                network: r
            });
            (i.witnessUtxo && We.from(i.witnessUtxo.script).toString("hex")) === (u.output && We.from(u.output).toString("hex")) && e.updateInput(n, {
                tapInternalKey: a
            });
        }
        n++;
    }
    return e;
}, wce = async ({ address: e, greatestToLeast: t, client: r, alkaneId: n, targetNumberOfAlkanes: i })=>{
    const a = (await r.dataSourceManager.getAlkanesByAddress(e)).flatMap((l)=>l.runes.filter((p)=>Number(p.rune.id.block) === Number(n.block) && Number(p.rune.id.tx) === Number(n.tx)).map((p)=>({
                rune: p,
                outpoint: l
            }))).sort((l, p)=>t ? Number(p.rune.balance) - Number(l.rune.balance) : Number(l.rune.balance) - Number(p.rune.balance));
    let u = 0, f = 0;
    const c = [];
    for (const l of a)if (f < i && Number(l.rune.balance) > 0) {
        const p = Number(l.outpoint.output.value);
        c.push({
            txId: l.outpoint.outpoint.txid,
            txIndex: l.outpoint.outpoint.vout,
            script: l.outpoint.output.script,
            address: e,
            amountOfAlkanes: l.rune.balance,
            satoshis: p,
            ...l.rune.rune
        }), u += p, f += Number(l.rune.balance) / (l.rune.rune.divisibility === 1 ? 1 : 10 ** l.rune.rune.divisibility);
    }
    if (f < i) throw new Error("Insuffiecient balance of alkanes.");
    return {
        alkaneUtxos: c,
        totalSatoshis: u,
        totalBalanceBeingSent: f
    };
};
async function Tm(e, t, { pubkey: r } = {}) {
    switch(bce(t.address)){
        case 0:
            {
                e.addInput({
                    hash: t.txHash,
                    index: +t.txOutputIndex
                });
                break;
            }
        case 2:
            {
                if (!r) throw new Error("Pubkey is required for nested SegWit");
                const i = Ri([
                    Kr.OP_0,
                    Rs(We.from(r, "hex"))
                ]);
                e.addInput({
                    hash: t.txHash,
                    index: +t.txOutputIndex,
                    redeemScript: i,
                    witnessUtxo: {
                        value: BigInt(t.btcValue),
                        script: Ri([
                            Kr.OP_HASH160,
                            Rs(i),
                            Kr.OP_EQUAL
                        ])
                    }
                });
                break;
            }
        case 1:
        case 3:
        default:
            e.addInput({
                hash: t.txHash,
                index: +t.txOutputIndex,
                witnessUtxo: {
                    value: BigInt(t.btcValue),
                    script: We.from(t.scriptPubKey, "hex")
                }
            });
    }
}
const vce = async ({ utxos: e, account: t, alkaneId: r, client: n, toAddress: i, amount: o, feeRate: s, fee: a })=>{
    const u = {
        utxos: e,
        totalAmount: e.reduce((R, X)=>R + X.btcValue, 0)
    }, f = gx(2, 0, 4), c = BigInt(Math.max(f * s, 250));
    let l = a ? BigInt(a) : c, p = Am(u.utxos, Number(l) + Number(iu) * 4);
    const y = [
        BigInt(2),
        BigInt(100),
        BigInt(77)
    ], _ = ec.encodeRunestoneProtostone({
        protostones: [
            ec.ProtoStone.message({
                protocolTag: 1n,
                pointer: 0,
                refundPointer: 0,
                calldata: ec.encipher(y),
                edicts: []
            })
        ]
    }).encodedRunestone;
    if (console.log("protostone23", _.toString("hex")), p.totalAmount < l + iu) throw console.log("gatheredUtxos.totalAmount", p.totalAmount), new Error("Insufficient Balanceeeee");
    if (p.utxos.length > 1) {
        const R = gx(p.utxos.length, 0, 4);
        l = BigInt(Math.max(R * s, 250)), p = Am(u.utxos, Number(l) + Number(iu));
    }
    const A = l + iu * 2n, O = n.$network.get(), N = new Cr({
        network: Dr(O)
    }), { alkaneUtxos: U } = await wce({
        address: t.taproot.address,
        greatestToLeast: t.spendStrategy.utxoSortGreatestToLeast,
        alkaneId: r,
        client: n,
        targetNumberOfAlkanes: o
    });
    if (U.length === 0) throw new Error("No Alkane Utxos Found");
    let D = 0n;
    const H = /* @__PURE__ */ new Set();
    for await (const R of U)Tm(N, {
        txHash: R.txId,
        txOutputIndex: R.txIndex,
        btcValue: R.satoshis,
        scriptPubKey: R.script,
        address: R.address
    }), D += BigInt(R.satoshis), H.add(`${R.txId}:${R.txIndex.toString()}`);
    if (p.totalAmount < A) throw new Error("Insufficient Balance");
    for (const R of p.utxos){
        if (D > A) break;
        H.has(`${R.txHash}:${R.txOutputIndex.toString()}`) || (Tm(N, R), D += BigInt(R.btcValue), H.add(`${R.txHash}:${R.txOutputIndex.toString()}`));
    }
    const K = ec.encodeRunestoneProtostone({
        protostones: [
            ec.ProtoStone.message({
                protocolTag: 1n,
                edicts: [
                    {
                        id: new YN(qh.u128(BigInt(r.block)), qh.u128(BigInt(r.tx))),
                        amount: qh.u128(BigInt(o)),
                        output: Qn.u32(1n)
                    }
                ],
                pointer: 0,
                refundPointer: 0,
                calldata: We.from([])
            })
        ]
    }).encodedRunestone;
    N.addOutput({
        value: iu,
        address: t.taproot.address
    }), N.addOutput({
        value: iu,
        address: i
    }), N.addOutput({
        script: K,
        value: 0n
    });
    const re = N.txOutputs.reduce((R, X)=>R + X.value, 0n), Q = D - re - l;
    return N.addOutput({
        address: t[t.spendStrategy.changeAddress].address,
        value: Q
    }), {
        psbt: (await fM({
            _psbt: N,
            senderPublicKey: t.taproot.pubkey,
            network: Dr(O)
        })).toBase64()
    };
}, _ce = async ({ toAddress: e, network: t, alkaneId: r, changeAddress: n, frontendFeeAddress: i, frontendFeeAmount: o, feeRate: s = 1, spendableUtxos: a, inputAlkaneUtxos: u, senderPublicKey: f, inputData: c })=>{
    const l = [
        r.block,
        r.tx,
        BigInt(mce),
        ...c ?? []
    ], p = ec.encodeRunestoneProtostone({
        protostones: [
            ec.ProtoStone.message({
                protocolTag: 1n,
                calldata: ec.encipher(l),
                pointer: 0,
                refundPointer: 0
            })
        ]
    }).encodedRunestone, y = Dr(t), _ = new Cr({
        network: y
    }), A = i && o && o >= kI ? o : 0n, O = A + BigInt(iu);
    function N(g) {
        return gx(g, 0, 2 + (A > 0 ? 1 : 0)) + p.byteLength;
    }
    const U = N(2), D = BigInt(Math.ceil(Math.max(U * s, 250)));
    let H = {
        utxos: a,
        totalAmount: a.reduce((g, m)=>g + m.btcValue, 0)
    };
    if (H = Am(H.utxos, Number(D) + Number(O)), H.utxos.length < 1) throw new Error("Insufficient balance");
    const K = N(H.utxos.length), re = BigInt(Math.ceil(Math.max(K * s, 250)));
    H.totalAmount < re && (H = Am(H.utxos, Number(re) + Number(O)));
    const Q = N(H.utxos.length), G = BigInt(Math.ceil(Math.max(Q * s, 250)));
    if (H.totalAmount < G) throw new Error("Insufficient balance");
    for (const g of u)Tm(_, g);
    for (const g of H.utxos)Tm(_, g);
    console.log("protostone byte length", p.length), _.addOutput({
        value: BigInt(iu),
        address: e
    }), _.addOutput({
        script: p,
        value: 0n
    }), i && o && o > 0 && _.addOutput({
        value: o,
        address: i
    });
    const R = u ? u.reduce((g, m)=>g + BigInt(m.btcValue), 0n) : 0n, X = BigInt(H.totalAmount) + R, $ = _.txOutputs.reduce((g, m)=>g + m.value, 0n), S = X - $ - G;
    if (S < 0) throw new Error("Insufficient balance");
    S >= kI && _.addOutput({
        address: n,
        value: S
    });
    const w = await fM({
        _psbt: _,
        senderPublicKey: f,
        network: y
    });
    return {
        psbtBase64: w.toBase64(),
        psbtHex: w.toHex()
    };
};
class lM {
    constructor(t){
        this.client = t;
    }
    async send(t, r, n) {
        const { connected: i, address: o, publicKey: s } = this.client.$store.get();
        if (!i) throw new Error("Client is not connected");
        const a = {
            block: t.split(":")[0],
            tx: t.split(":")[1]
        };
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const u = this.client.$network.get(), c = {
            network: Dr(u),
            spendStrategy: {
                utxoSortGreatestToLeast: !0,
                changeAddress: "taproot",
                addressOrder: [
                    "taproot",
                    "nestedSegwit",
                    "legacy",
                    "nativeSegwit"
                ]
            },
            taproot: {
                address: o,
                pubkey: s,
                pubKeyXOnly: Mo(We.from(s, "hex")).toString(),
                hdPath: "m/84'/1'/0'/0/0"
            },
            nestedSegwit: {
                address: o,
                pubkey: s,
                hdPath: "m/84'/1'/0'/0/0"
            },
            legacy: {
                address: o,
                pubkey: s,
                hdPath: "m/49'/1'/0'/0/0"
            },
            nativeSegwit: {
                address: o,
                pubkey: s,
                hdPath: "m/84'/1'/0'/0/0"
            }
        }, { fastFee: l } = await this.client.dataSourceManager.getRecommendedFees(), p = await this.client.dataSourceManager.getFormattedUTXOs(o), { psbt: y } = await vce({
            utxos: p,
            account: c,
            alkaneId: a,
            client: this.client,
            toAddress: n,
            amount: r,
            feeRate: l
        }), _ = await this.client.signPsbt({
            tx: y,
            broadcast: !0,
            finalize: !0
        });
        if (!_) throw new Error("Failed to sign transaction");
        if (_.txId) return _.txId;
        const A = await this.client.pushPsbt(_.signedPsbtHex ?? _.signedPsbtBase64);
        if (A) return A;
        throw new Error("Failed to broadcast transaction");
    }
    async getAlkanes({ limit: t = 10, offset: r }) {
        return (await this.client.dataSourceManager.getSource("sandshrew").alkanesRpc.getAlkanes({
            limit: t,
            offset: r
        })).flatMap((i)=>({
                ...i
            }));
    }
    async getAlkaneById(t) {
        return await this.client.dataSourceManager.getSource("sandshrew").alkanesRpc.getAlkaneById(t);
    }
    async mintAlkane({ toAddress: t, id: r, changeAddress: n, feeRate: i, inputData: o }) {
        const s = this.client.$network.get(), { connected: a, address: u, publicKey: f } = this.client.$store.get();
        if (!a) throw new Error("Client is not connected");
        const c = await this.client.dataSourceManager.getFormattedUTXOs(u), { utxos: l } = Vae(c), p = c.filter((N)=>N.hasAlkanes && !1), { fastFee: y } = await this.client.dataSourceManager.getRecommendedFees(), { psbtBase64: _ } = await _ce({
            alkaneId: r,
            network: s,
            toAddress: t ?? u,
            changeAddress: n ?? u,
            senderPublicKey: f,
            inputAlkaneUtxos: p,
            spendableUtxos: l,
            feeRate: i ?? y,
            inputData: o
        }), A = await this.client.signPsbt({
            tx: _,
            broadcast: !0,
            finalize: !0
        });
        if (!A) throw new Error("Failed to sign transaction");
        if (A.txId) return A.txId;
        const O = await this.client.pushPsbt(A.signedPsbtHex ?? A.signedPsbtBase64);
        if (O) return O;
        throw new Error("Failed to broadcast transaction");
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ES = /* @__PURE__ */ BigInt(0), yx = /* @__PURE__ */ BigInt(1);
function km(e, t) {
    if (typeof t != "boolean") throw new Error(e + " boolean expected, got " + t);
}
function fy(e) {
    const t = e.toString(16);
    return t.length & 1 ? "0" + t : t;
}
function dM(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return e === "" ? ES : BigInt("0x" + e);
}
function u1(e) {
    return dM(Hr.bytesToHex(e));
}
function hM(e) {
    return Hr.abytes(e), dM(Hr.bytesToHex(Uint8Array.from(e).reverse()));
}
function xS(e, t) {
    return Hr.hexToBytes(e.toString(16).padStart(t * 2, "0"));
}
function pM(e, t) {
    return xS(e, t).reverse();
}
function ss(e, t, r) {
    let n;
    if (typeof t == "string") try {
        n = Hr.hexToBytes(t);
    } catch (o) {
        throw new Error(e + " must be hex string or Uint8Array, cause: " + o);
    }
    else if (Hr.isBytes(t)) n = Uint8Array.from(t);
    else throw new Error(e + " must be hex string or Uint8Array");
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(e + " of length " + r + " expected, got " + i);
    return n;
}
const K_ = (e)=>typeof e == "bigint" && ES <= e;
function Ece(e, t, r) {
    return K_(e) && K_(t) && K_(r) && t <= e && e < r;
}
function xce(e, t, r, n) {
    if (!Ece(t, r, n)) throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Sce(e) {
    let t;
    for(t = 0; e > ES; e >>= yx, t += 1);
    return t;
}
const f1 = (e)=>(yx << BigInt(e)) - yx;
function Ace(e, t, r) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    const n = (y)=>new Uint8Array(y), i = (y)=>Uint8Array.of(y);
    let o = n(e), s = n(e), a = 0;
    const u = ()=>{
        o.fill(1), s.fill(0), a = 0;
    }, f = (...y)=>r(s, o, ...y), c = (y = n(0))=>{
        s = f(i(0), y), o = f(), y.length !== 0 && (s = f(i(1), y), o = f());
    }, l = ()=>{
        if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let y = 0;
        const _ = [];
        for(; y < t;){
            o = f();
            const A = o.slice();
            _.push(A), y += o.length;
        }
        return Hr.concatBytes(..._);
    };
    return (y, _)=>{
        u(), c(y);
        let A;
        for(; !(A = _(l()));)c();
        return u(), A;
    };
}
function SS(e, t, r = {}) {
    if (!e || typeof e != "object") throw new Error("expected valid options object");
    function n(i, o, s) {
        const a = e[i];
        if (s && a === void 0) return;
        const u = typeof a;
        if (u !== o || a === null) throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`);
    }
    Object.entries(t).forEach(([i, o])=>n(i, o, !1)), Object.entries(r).forEach(([i, o])=>n(i, o, !0));
}
function II(e) {
    const t = /* @__PURE__ */ new WeakMap();
    return (r, ...n)=>{
        const i = t.get(r);
        if (i !== void 0) return i;
        const o = e(r, ...n);
        return t.set(r, o), o;
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const fo = BigInt(0), Hi = BigInt(1), af = /* @__PURE__ */ BigInt(2), Tce = /* @__PURE__ */ BigInt(3), gM = /* @__PURE__ */ BigInt(4), yM = /* @__PURE__ */ BigInt(5), mM = /* @__PURE__ */ BigInt(8);
function Bo(e, t) {
    const r = e % t;
    return r >= fo ? r : t + r;
}
function Qo(e, t, r) {
    let n = e;
    for(; t-- > fo;)n *= n, n %= r;
    return n;
}
function BI(e, t) {
    if (e === fo) throw new Error("invert: expected non-zero number");
    if (t <= fo) throw new Error("invert: expected positive modulus, got " + t);
    let r = Bo(e, t), n = t, i = fo, o = Hi;
    for(; r !== fo;){
        const a = n / r, u = n % r, f = i - o * a;
        n = r, r = u, i = o, o = f;
    }
    if (n !== Hi) throw new Error("invert: does not exist");
    return Bo(i, t);
}
function bM(e, t) {
    const r = (e.ORDER + Hi) / gM, n = e.pow(t, r);
    if (!e.eql(e.sqr(n), t)) throw new Error("Cannot find square root");
    return n;
}
function kce(e, t) {
    const r = (e.ORDER - yM) / mM, n = e.mul(t, af), i = e.pow(n, r), o = e.mul(t, i), s = e.mul(e.mul(o, af), i), a = e.mul(o, e.sub(s, e.ONE));
    if (!e.eql(e.sqr(a), t)) throw new Error("Cannot find square root");
    return a;
}
function Ice(e) {
    if (e < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let t = e - Hi, r = 0;
    for(; t % af === fo;)t /= af, r++;
    let n = af;
    const i = x0(e);
    for(; OI(i, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return bM;
    let o = i.pow(n, t);
    const s = (t + Hi) / af;
    return function(u, f) {
        if (u.is0(f)) return f;
        if (OI(u, f) !== 1) throw new Error("Cannot find square root");
        let c = r, l = u.mul(u.ONE, o), p = u.pow(f, t), y = u.pow(f, s);
        for(; !u.eql(p, u.ONE);){
            if (u.is0(p)) return u.ZERO;
            let _ = 1, A = u.sqr(p);
            for(; !u.eql(A, u.ONE);)if (_++, A = u.sqr(A), _ === c) throw new Error("Cannot find square root");
            const O = Hi << BigInt(c - _ - 1), N = u.pow(l, O);
            c = _, l = u.sqr(N), p = u.mul(p, l), y = u.mul(y, N);
        }
        return y;
    };
}
function Bce(e) {
    return e % gM === Tce ? bM : e % mM === yM ? kce : Ice(e);
}
const Oce = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function Pce(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, r = Oce.reduce((n, i)=>(n[i] = "function", n), t);
    return SS(e, r), e;
}
function Nce(e, t, r) {
    if (r < fo) throw new Error("invalid exponent, negatives unsupported");
    if (r === fo) return e.ONE;
    if (r === Hi) return t;
    let n = e.ONE, i = t;
    for(; r > fo;)r & Hi && (n = e.mul(n, i)), i = e.sqr(i), r >>= Hi;
    return n;
}
function wM(e, t, r = !1) {
    const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, a, u)=>e.is0(a) ? s : (n[u] = s, e.mul(s, a)), e.ONE), o = e.inv(i);
    return t.reduceRight((s, a, u)=>e.is0(a) ? s : (n[u] = e.mul(s, n[u]), e.mul(s, a)), o), n;
}
function OI(e, t) {
    const r = (e.ORDER - Hi) / af, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), s = e.eql(n, e.neg(e.ONE));
    if (!i && !o && !s) throw new Error("invalid Legendre symbol result");
    return i ? 1 : o ? 0 : -1;
}
function Mce(e, t) {
    t !== void 0 && Hr.anumber(t);
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function x0(e, t, r = !1, n = {}) {
    if (e <= fo) throw new Error("invalid field: expected ORDER > 0, got " + e);
    let i, o;
    if (typeof t == "object" && t != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const c = t;
        c.BITS && (i = c.BITS), c.sqrt && (o = c.sqrt), typeof c.isLE == "boolean" && (r = c.isLE);
    } else typeof t == "number" && (i = t), n.sqrt && (o = n.sqrt);
    const { nBitLength: s, nByteLength: a } = Mce(e, i);
    if (a > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const f = Object.freeze({
        ORDER: e,
        isLE: r,
        BITS: s,
        BYTES: a,
        MASK: f1(s),
        ZERO: fo,
        ONE: Hi,
        create: (c)=>Bo(c, e),
        isValid: (c)=>{
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return fo <= c && c < e;
        },
        is0: (c)=>c === fo,
        // is valid and invertible
        isValidNot0: (c)=>!f.is0(c) && f.isValid(c),
        isOdd: (c)=>(c & Hi) === Hi,
        neg: (c)=>Bo(-c, e),
        eql: (c, l)=>c === l,
        sqr: (c)=>Bo(c * c, e),
        add: (c, l)=>Bo(c + l, e),
        sub: (c, l)=>Bo(c - l, e),
        mul: (c, l)=>Bo(c * l, e),
        pow: (c, l)=>Nce(f, c, l),
        div: (c, l)=>Bo(c * BI(l, e), e),
        // Same as above, but doesn't normalize
        sqrN: (c)=>c * c,
        addN: (c, l)=>c + l,
        subN: (c, l)=>c - l,
        mulN: (c, l)=>c * l,
        inv: (c)=>BI(c, e),
        sqrt: o || ((c)=>(u || (u = Bce(e)), u(f, c))),
        toBytes: (c)=>r ? pM(c, a) : xS(c, a),
        fromBytes: (c)=>{
            if (c.length !== a) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + c.length);
            return r ? hM(c) : u1(c);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (c)=>wM(f, c),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (c, l, p)=>p ? l : c
    });
    return Object.freeze(f);
}
function vM(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function _M(e) {
    const t = vM(e);
    return t + Math.ceil(t / 2);
}
function Rce(e, t, r = !1) {
    const n = e.length, i = vM(t), o = _M(t);
    if (n < 16 || n < o || n > 1024) throw new Error("expected " + o + "-1024 bytes of input, got " + n);
    const s = r ? hM(e) : u1(e), a = Bo(s, t - Hi) + Hi;
    return r ? pM(a, i) : xS(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ad = BigInt(0), cf = BigInt(1);
function Gh(e, t) {
    const r = t.negate();
    return e ? r : t;
}
function Cce(e, t, r) {
    const n = (s)=>s.pz, i = wM(e.Fp, r.map(n));
    return r.map((s, a)=>s.toAffine(i[a])).map(e.fromAffine);
}
function EM(e, t) {
    if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function W_(e, t) {
    EM(e, t);
    const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = f1(e), s = BigInt(e);
    return {
        windows: r,
        windowSize: n,
        mask: o,
        maxNumber: i,
        shiftBy: s
    };
}
function PI(e, t, r) {
    const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = r;
    let a = Number(e & i), u = e >> s;
    a > n && (a -= o, u += cf);
    const f = t * n, c = f + Math.abs(a) - 1, l = a === 0, p = a < 0, y = t % 2 !== 0;
    return {
        nextN: u,
        offset: c,
        isZero: l,
        isNeg: p,
        isNegF: y,
        offsetF: f
    };
}
function Uce(e, t) {
    if (!Array.isArray(e)) throw new Error("array expected");
    e.forEach((r, n)=>{
        if (!(r instanceof t)) throw new Error("invalid point at index " + n);
    });
}
function $ce(e, t) {
    if (!Array.isArray(e)) throw new Error("array of scalars expected");
    e.forEach((r, n)=>{
        if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
    });
}
const V_ = /* @__PURE__ */ new WeakMap(), xM = /* @__PURE__ */ new WeakMap();
function G_(e) {
    return xM.get(e) || 1;
}
function NI(e) {
    if (e !== ad) throw new Error("invalid wNAF");
}
function Lce(e, t) {
    return {
        constTimeNegate: Gh,
        hasPrecomputes (r) {
            return G_(r) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (r, n, i = e.ZERO) {
            let o = r;
            for(; n > ad;)n & cf && (i = i.add(o)), o = o.double(), n >>= cf;
            return i;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (r, n) {
            const { windows: i, windowSize: o } = W_(n, t), s = [];
            let a = r, u = a;
            for(let f = 0; f < i; f++){
                u = a, s.push(u);
                for(let c = 1; c < o; c++)u = u.add(a), s.push(u);
                a = u.double();
            }
            return s;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (r, n, i) {
            let o = e.ZERO, s = e.BASE;
            const a = W_(r, t);
            for(let u = 0; u < a.windows; u++){
                const { nextN: f, offset: c, isZero: l, isNeg: p, isNegF: y, offsetF: _ } = PI(i, u, a);
                i = f, l ? s = s.add(Gh(y, n[_])) : o = o.add(Gh(p, n[c]));
            }
            return NI(i), {
                p: o,
                f: s
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (r, n, i, o = e.ZERO) {
            const s = W_(r, t);
            for(let a = 0; a < s.windows && i !== ad; a++){
                const { nextN: u, offset: f, isZero: c, isNeg: l } = PI(i, a, s);
                if (i = u, !c) {
                    const p = n[f];
                    o = o.add(l ? p.negate() : p);
                }
            }
            return NI(i), o;
        },
        getPrecomputes (r, n, i) {
            let o = V_.get(n);
            return o || (o = this.precomputeWindow(n, r), r !== 1 && (typeof i == "function" && (o = i(o)), V_.set(n, o))), o;
        },
        wNAFCached (r, n, i) {
            const o = G_(r);
            return this.wNAF(o, this.getPrecomputes(o, r, i), n);
        },
        wNAFCachedUnsafe (r, n, i, o) {
            const s = G_(r);
            return s === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, r, i), n, o);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (r, n) {
            EM(n, t), xM.set(r, n), V_.delete(r);
        }
    };
}
function Dce(e, t, r, n) {
    let i = t, o = e.ZERO, s = e.ZERO;
    for(; r > ad || n > ad;)r & cf && (o = o.add(i)), n & cf && (s = s.add(i)), i = i.double(), r >>= cf, n >>= cf;
    return {
        p1: o,
        p2: s
    };
}
function Fce(e, t, r, n) {
    Uce(r, e), $ce(n, t);
    const i = r.length, o = n.length;
    if (i !== o) throw new Error("arrays of points and scalars must have equal length");
    const s = e.ZERO, a = Sce(BigInt(i));
    let u = 1;
    a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
    const f = f1(u), c = new Array(Number(f) + 1).fill(s), l = Math.floor((t.BITS - 1) / u) * u;
    let p = s;
    for(let y = l; y >= 0; y -= u){
        c.fill(s);
        for(let A = 0; A < o; A++){
            const O = n[A], N = Number(O >> BigInt(y) & f);
            c[N] = c[N].add(r[A]);
        }
        let _ = s;
        for(let A = c.length - 1, O = s; A > 0; A--)O = O.add(c[A]), _ = _.add(O);
        if (p = p.add(_), y !== 0) for(let A = 0; A < u; A++)p = p.double();
    }
    return p;
}
function MI(e, t) {
    if (t) {
        if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return Pce(t), t;
    } else return x0(e);
}
function zce(e, t, r = {}) {
    if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const u = t[a];
        if (!(typeof u == "bigint" && u > ad)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const n = MI(t.p, r.Fp), i = MI(t.n, r.Fn), s = [
        "Gx",
        "Gy",
        "a",
        "b"
    ];
    for (const a of s)if (!n.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function RI(e) {
    e.lowS !== void 0 && km("lowS", e.lowS), e.prehash !== void 0 && km("prehash", e.prehash);
}
class jce extends Error {
    constructor(t = ""){
        super(t);
    }
}
const Ja = {
    // asn.1 DER encoding utils
    Err: jce,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (e, t)=>{
            const { Err: r } = Ja;
            if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
            if (t.length & 1) throw new r("tlv.encode: unpadded data");
            const n = t.length / 2, i = fy(n);
            if (i.length / 2 & 128) throw new r("tlv.encode: long form length too big");
            const o = n > 127 ? fy(i.length / 2 | 128) : "";
            return fy(e) + o + i + t;
        },
        // v - value, l - left bytes (unparsed)
        decode (e, t) {
            const { Err: r } = Ja;
            let n = 0;
            if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
            if (t.length < 2 || t[n++] !== e) throw new r("tlv.decode: wrong tlv");
            const i = t[n++], o = !!(i & 128);
            let s = 0;
            if (!o) s = i;
            else {
                const u = i & 127;
                if (!u) throw new r("tlv.decode(long): indefinite length not supported");
                if (u > 4) throw new r("tlv.decode(long): byte length is too big");
                const f = t.subarray(n, n + u);
                if (f.length !== u) throw new r("tlv.decode: length bytes not complete");
                if (f[0] === 0) throw new r("tlv.decode(long): zero leftmost byte");
                for (const c of f)s = s << 8 | c;
                if (n += u, s < 128) throw new r("tlv.decode(long): not minimal encoding");
            }
            const a = t.subarray(n, n + s);
            if (a.length !== s) throw new r("tlv.decode: wrong value length");
            return {
                v: a,
                l: t.subarray(n + s)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (e) {
            const { Err: t } = Ja;
            if (e < Zh) throw new t("integer: negative integers are not allowed");
            let r = fy(e);
            if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1) throw new t("unexpected DER parsing assertion: unpadded hex");
            return r;
        },
        decode (e) {
            const { Err: t } = Ja;
            if (e[0] & 128) throw new t("invalid signature integer: negative");
            if (e[0] === 0 && !(e[1] & 128)) throw new t("invalid signature integer: unnecessary leading zero");
            return u1(e);
        }
    },
    toSig (e) {
        const { Err: t, _int: r, _tlv: n } = Ja, i = ss("signature", e), { v: o, l: s } = n.decode(48, i);
        if (s.length) throw new t("invalid signature: left bytes after parsing");
        const { v: a, l: u } = n.decode(2, o), { v: f, l: c } = n.decode(2, u);
        if (c.length) throw new t("invalid signature: left bytes after parsing");
        return {
            r: r.decode(a),
            s: r.decode(f)
        };
    },
    hexFromSig (e) {
        const { _tlv: t, _int: r } = Ja, n = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = n + i;
        return t.encode(48, o);
    }
}, Zh = BigInt(0), Yh = BigInt(1), Hce = BigInt(2), ly = BigInt(3), qce = BigInt(4);
function Kce(e, t, r) {
    function n(i) {
        const o = e.sqr(i), s = e.mul(o, i);
        return e.add(e.add(s, e.mul(i, t)), r);
    }
    return n;
}
function SM(e, t, r) {
    const { BYTES: n } = e;
    function i(o) {
        let s;
        if (typeof o == "bigint") s = o;
        else {
            let a = ss("private key", o);
            if (t) {
                if (!t.includes(a.length * 2)) throw new Error("invalid private key");
                const u = new Uint8Array(n);
                u.set(a, u.length - a.length), a = u;
            }
            try {
                s = e.fromBytes(a);
            } catch  {
                throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof o}`);
            }
        }
        if (r && (s = e.create(s)), !e.isValidNot0(s)) throw new Error("invalid private key: out of range [1..N-1]");
        return s;
    }
    return i;
}
function Wce(e, t = {}) {
    const { Fp: r, Fn: n } = zce("weierstrass", e, t), { h: i, n: o } = e;
    SS(t, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const { endo: s } = t;
    if (s && (!r.is0(e.a) || typeof s.beta != "bigint" || typeof s.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    function a() {
        if (!r.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function u(G, R, X) {
        const { x: $, y: S } = R.toAffine(), w = r.toBytes($);
        if (km("isCompressed", X), X) {
            a();
            const g = !r.isOdd(S);
            return Hr.concatBytes(AM(g), w);
        } else return Hr.concatBytes(Uint8Array.of(4), w, r.toBytes(S));
    }
    function f(G) {
        Hr.abytes(G);
        const R = r.BYTES, X = R + 1, $ = 2 * R + 1, S = G.length, w = G[0], g = G.subarray(1);
        if (S === X && (w === 2 || w === 3)) {
            const m = r.fromBytes(g);
            if (!r.isValid(m)) throw new Error("bad point: is not on curve, wrong x");
            const E = p(m);
            let T;
            try {
                T = r.sqrt(E);
            } catch (k) {
                const L = k instanceof Error ? ": " + k.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + L);
            }
            a();
            const I = r.isOdd(T);
            return (w & 1) === 1 !== I && (T = r.neg(T)), {
                x: m,
                y: T
            };
        } else if (S === $ && w === 4) {
            const m = r.fromBytes(g.subarray(R * 0, R * 1)), E = r.fromBytes(g.subarray(R * 1, R * 2));
            if (!y(m, E)) throw new Error("bad point: is not on curve");
            return {
                x: m,
                y: E
            };
        } else throw new Error(`bad point: got length ${S}, expected compressed=${X} or uncompressed=${$}`);
    }
    const c = t.toBytes || u, l = t.fromBytes || f, p = Kce(r, e.a, e.b);
    function y(G, R) {
        const X = r.sqr(R), $ = p(G);
        return r.eql(X, $);
    }
    if (!y(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
    const _ = r.mul(r.pow(e.a, ly), qce), A = r.mul(r.sqr(e.b), BigInt(27));
    if (r.is0(r.add(_, A))) throw new Error("bad curve params: a or b");
    function O(G, R, X = !1) {
        if (!r.isValid(R) || X && r.is0(R)) throw new Error(`bad point coordinate ${G}`);
        return R;
    }
    function N(G) {
        if (!(G instanceof K)) throw new Error("ProjectivePoint expected");
    }
    const U = II((G, R)=>{
        const { px: X, py: $, pz: S } = G;
        if (r.eql(S, r.ONE)) return {
            x: X,
            y: $
        };
        const w = G.is0();
        R == null && (R = w ? r.ONE : r.inv(S));
        const g = r.mul(X, R), m = r.mul($, R), E = r.mul(S, R);
        if (w) return {
            x: r.ZERO,
            y: r.ZERO
        };
        if (!r.eql(E, r.ONE)) throw new Error("invZ was invalid");
        return {
            x: g,
            y: m
        };
    }), D = II((G)=>{
        if (G.is0()) {
            if (t.allowInfinityPoint && !r.is0(G.py)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: R, y: X } = G.toAffine();
        if (!r.isValid(R) || !r.isValid(X)) throw new Error("bad point: x or y not field elements");
        if (!y(R, X)) throw new Error("bad point: equation left != right");
        if (!G.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    function H(G, R, X, $, S) {
        return X = new K(r.mul(X.px, G), X.py, X.pz), R = Gh($, R), X = Gh(S, X), R.add(X);
    }
    class K {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(R, X, $){
            this.px = O("x", R), this.py = O("y", X, !0), this.pz = O("z", $), Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(R) {
            const { x: X, y: $ } = R || {};
            if (!R || !r.isValid(X) || !r.isValid($)) throw new Error("invalid affine point");
            if (R instanceof K) throw new Error("projective point not allowed");
            return r.is0(X) && r.is0($) ? K.ZERO : new K(X, $, r.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(R) {
            return Cce(K, "pz", R);
        }
        static fromBytes(R) {
            return Hr.abytes(R), K.fromHex(R);
        }
        /** Converts hash string or Uint8Array to Point. */ static fromHex(R) {
            const X = K.fromAffine(l(ss("pointHex", R)));
            return X.assertValidity(), X;
        }
        /** Multiplies generator point by privateKey. */ static fromPrivateKey(R) {
            const X = SM(n, t.allowedPrivateKeyLengths, t.wrapPrivateKey);
            return K.BASE.multiply(X(R));
        }
        /** Multiscalar Multiplication */ static msm(R, X) {
            return Fce(K, n, R, X);
        }
        /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */ precompute(R = 8, X = !0) {
            return Q.setWindowSize(this, R), X || this.multiply(ly), this;
        }
        /** "Private method", don't use it directly */ _setWindowSize(R) {
            this.precompute(R);
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */ assertValidity() {
            D(this);
        }
        hasEvenY() {
            const { y: R } = this.toAffine();
            if (!r.isOdd) throw new Error("Field doesn't support isOdd");
            return !r.isOdd(R);
        }
        /** Compare one point to another. */ equals(R) {
            N(R);
            const { px: X, py: $, pz: S } = this, { px: w, py: g, pz: m } = R, E = r.eql(r.mul(X, m), r.mul(w, S)), T = r.eql(r.mul($, m), r.mul(g, S));
            return E && T;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
            return new K(this.px, r.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: R, b: X } = e, $ = r.mul(X, ly), { px: S, py: w, pz: g } = this;
            let m = r.ZERO, E = r.ZERO, T = r.ZERO, I = r.mul(S, S), P = r.mul(w, w), k = r.mul(g, g), L = r.mul(S, w);
            return L = r.add(L, L), T = r.mul(S, g), T = r.add(T, T), m = r.mul(R, T), E = r.mul($, k), E = r.add(m, E), m = r.sub(P, E), E = r.add(P, E), E = r.mul(m, E), m = r.mul(L, m), T = r.mul($, T), k = r.mul(R, k), L = r.sub(I, k), L = r.mul(R, L), L = r.add(L, T), T = r.add(I, I), I = r.add(T, I), I = r.add(I, k), I = r.mul(I, L), E = r.add(E, I), k = r.mul(w, g), k = r.add(k, k), I = r.mul(k, L), m = r.sub(m, I), T = r.mul(k, P), T = r.add(T, T), T = r.add(T, T), new K(m, E, T);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(R) {
            N(R);
            const { px: X, py: $, pz: S } = this, { px: w, py: g, pz: m } = R;
            let E = r.ZERO, T = r.ZERO, I = r.ZERO;
            const P = e.a, k = r.mul(e.b, ly);
            let L = r.mul(X, w), j = r.mul($, g), ie = r.mul(S, m), ue = r.add(X, $), ce = r.add(w, g);
            ue = r.mul(ue, ce), ce = r.add(L, j), ue = r.sub(ue, ce), ce = r.add(X, S);
            let he = r.add(w, m);
            return ce = r.mul(ce, he), he = r.add(L, ie), ce = r.sub(ce, he), he = r.add($, S), E = r.add(g, m), he = r.mul(he, E), E = r.add(j, ie), he = r.sub(he, E), I = r.mul(P, ce), E = r.mul(k, ie), I = r.add(E, I), E = r.sub(j, I), I = r.add(j, I), T = r.mul(E, I), j = r.add(L, L), j = r.add(j, L), ie = r.mul(P, ie), ce = r.mul(k, ce), j = r.add(j, ie), ie = r.sub(L, ie), ie = r.mul(P, ie), ce = r.add(ce, ie), L = r.mul(j, ce), T = r.add(T, L), L = r.mul(he, ce), E = r.mul(ue, E), E = r.sub(E, L), L = r.mul(ue, j), I = r.mul(he, I), I = r.add(I, L), new K(E, T, I);
        }
        subtract(R) {
            return this.add(R.negate());
        }
        is0() {
            return this.equals(K.ZERO);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(R) {
            const { endo: X } = t;
            if (!n.isValidNot0(R)) throw new Error("invalid scalar: out of range");
            let $, S;
            const w = (g)=>Q.wNAFCached(this, g, K.normalizeZ);
            if (X) {
                const { k1neg: g, k1: m, k2neg: E, k2: T } = X.splitScalar(R), { p: I, f: P } = w(m), { p: k, f: L } = w(T);
                S = P.add(L), $ = H(X.beta, I, k, g, E);
            } else {
                const { p: g, f: m } = w(R);
                $ = g, S = m;
            }
            return K.normalizeZ([
                $,
                S
            ])[0];
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(R) {
            const { endo: X } = t, $ = this;
            if (!n.isValid(R)) throw new Error("invalid scalar: out of range");
            if (R === Zh || $.is0()) return K.ZERO;
            if (R === Yh) return $;
            if (Q.hasPrecomputes(this)) return this.multiply(R);
            if (X) {
                const { k1neg: S, k1: w, k2neg: g, k2: m } = X.splitScalar(R), { p1: E, p2: T } = Dce(K, $, w, m);
                return H(X.beta, E, T, S, g);
            } else return Q.wNAFCachedUnsafe($, R);
        }
        multiplyAndAddUnsafe(R, X, $) {
            const S = this.multiplyUnsafe(X).add(R.multiplyUnsafe($));
            return S.is0() ? void 0 : S;
        }
        /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */ toAffine(R) {
            return U(this, R);
        }
        /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */ isTorsionFree() {
            const { isTorsionFree: R } = t;
            return i === Yh ? !0 : R ? R(K, this) : Q.wNAFCachedUnsafe(this, o).is0();
        }
        clearCofactor() {
            const { clearCofactor: R } = t;
            return i === Yh ? this : R ? R(K, this) : this.multiplyUnsafe(i);
        }
        toBytes(R = !0) {
            return km("isCompressed", R), this.assertValidity(), c(K, this, R);
        }
        /** @deprecated use `toBytes` */ toRawBytes(R = !0) {
            return this.toBytes(R);
        }
        toHex(R = !0) {
            return Hr.bytesToHex(this.toBytes(R));
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
    }
    K.BASE = new K(e.Gx, e.Gy, r.ONE), K.ZERO = new K(r.ZERO, r.ONE, r.ZERO), K.Fp = r, K.Fn = n;
    const re = n.BITS, Q = Lce(K, t.endo ? Math.ceil(re / 2) : re);
    return K;
}
function AM(e) {
    return Uint8Array.of(e ? 2 : 3);
}
function Vce(e, t, r = {}) {
    SS(t, {
        hash: "function"
    }, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const n = t.randomBytes || Hr.randomBytes, i = t.hmac || (($, ...S)=>Qp.hmac(t.hash, $, Hr.concatBytes(...S))), { Fp: o, Fn: s } = e, { ORDER: a, BITS: u } = s;
    function f($) {
        const S = a >> Yh;
        return $ > S;
    }
    function c($) {
        return f($) ? s.neg($) : $;
    }
    function l($, S) {
        if (!s.isValidNot0(S)) throw new Error(`invalid signature ${$}: out of range 1..CURVE.n`);
    }
    class p {
        constructor(S, w, g){
            l("r", S), l("s", w), this.r = S, this.s = w, g != null && (this.recovery = g), Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(S) {
            const w = s.BYTES, g = ss("compactSignature", S, w * 2);
            return new p(s.fromBytes(g.subarray(0, w)), s.fromBytes(g.subarray(w, w * 2)));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(S) {
            const { r: w, s: g } = Ja.toSig(ss("DER", S));
            return new p(w, g);
        }
        /**
     * @todo remove
     * @deprecated
     */ assertValidity() {}
        addRecoveryBit(S) {
            return new p(this.r, this.s, S);
        }
        // ProjPointType<bigint>
        recoverPublicKey(S) {
            const w = o.ORDER, { r: g, s: m, recovery: E } = this;
            if (E == null || ![
                0,
                1,
                2,
                3
            ].includes(E)) throw new Error("recovery id invalid");
            if (a * Hce < w && E > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const I = E === 2 || E === 3 ? g + a : g;
            if (!o.isValid(I)) throw new Error("recovery id 2 or 3 invalid");
            const P = o.toBytes(I), k = e.fromHex(Hr.concatBytes(AM((E & 1) === 0), P)), L = s.inv(I), j = D(ss("msgHash", S)), ie = s.create(-j * L), ue = s.create(m * L), ce = e.BASE.multiplyUnsafe(ie).add(k.multiplyUnsafe(ue));
            if (ce.is0()) throw new Error("point at infinify");
            return ce.assertValidity(), ce;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return f(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new p(this.r, s.neg(this.s), this.recovery) : this;
        }
        toBytes(S) {
            if (S === "compact") return Hr.concatBytes(s.toBytes(this.r), s.toBytes(this.s));
            if (S === "der") return Hr.hexToBytes(Ja.hexFromSig(this));
            throw new Error("invalid format");
        }
        // DER-encoded
        toDERRawBytes() {
            return this.toBytes("der");
        }
        toDERHex() {
            return Hr.bytesToHex(this.toBytes("der"));
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return this.toBytes("compact");
        }
        toCompactHex() {
            return Hr.bytesToHex(this.toBytes("compact"));
        }
    }
    const y = SM(s, r.allowedPrivateKeyLengths, r.wrapPrivateKey), _ = {
        isValidPrivateKey ($) {
            try {
                return y($), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: y,
        /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */ randomPrivateKey: ()=>{
            const $ = a;
            return Rce(n(_M($)), $);
        },
        precompute ($ = 8, S = e.BASE) {
            return S.precompute($, !1);
        }
    };
    function A($, S = !0) {
        return e.fromPrivateKey($).toBytes(S);
    }
    function O($) {
        if (typeof $ == "bigint") return !1;
        if ($ instanceof e) return !0;
        const w = ss("key", $).length, g = o.BYTES, m = g + 1, E = 2 * g + 1;
        if (!(r.allowedPrivateKeyLengths || s.BYTES === m)) return w === m || w === E;
    }
    function N($, S, w = !0) {
        if (O($) === !0) throw new Error("first arg must be private key");
        if (O(S) === !1) throw new Error("second arg must be public key");
        return e.fromHex(S).multiply(y($)).toBytes(w);
    }
    const U = t.bits2int || function($) {
        if ($.length > 8192) throw new Error("input is too large");
        const S = u1($), w = $.length * 8 - u;
        return w > 0 ? S >> BigInt(w) : S;
    }, D = t.bits2int_modN || function($) {
        return s.create(U($));
    }, H = f1(u);
    function K($) {
        return xce("num < 2^" + u, $, Zh, H), s.toBytes($);
    }
    function re($, S, w = Q) {
        if ([
            "recovered",
            "canonical"
        ].some((ue)=>ue in w)) throw new Error("sign() legacy options not supported");
        const { hash: g } = t;
        let { lowS: m, prehash: E, extraEntropy: T } = w;
        m == null && (m = !0), $ = ss("msgHash", $), RI(w), E && ($ = ss("prehashed msgHash", g($)));
        const I = D($), P = y(S), k = [
            K(P),
            K(I)
        ];
        if (T != null && T !== !1) {
            const ue = T === !0 ? n(o.BYTES) : T;
            k.push(ss("extraEntropy", ue));
        }
        const L = Hr.concatBytes(...k), j = I;
        function ie(ue) {
            const ce = U(ue);
            if (!s.isValidNot0(ce)) return;
            const he = s.inv(ce), ee = e.BASE.multiply(ce).toAffine(), ae = s.create(ee.x);
            if (ae === Zh) return;
            const ye = s.create(he * s.create(j + ae * P));
            if (ye === Zh) return;
            let Se = (ee.x === ae ? 0 : 2) | Number(ee.y & Yh), De = ye;
            return m && f(ye) && (De = c(ye), Se ^= 1), new p(ae, De, Se);
        }
        return {
            seed: L,
            k2sig: ie
        };
    }
    const Q = {
        lowS: t.lowS,
        prehash: !1
    }, G = {
        lowS: t.lowS,
        prehash: !1
    };
    function R($, S, w = Q) {
        const { seed: g, k2sig: m } = re($, S, w);
        return Ace(t.hash.outputLen, s.BYTES, i)(g, m);
    }
    e.BASE.precompute(8);
    function X($, S, w, g = G) {
        const m = $;
        S = ss("msgHash", S), w = ss("publicKey", w), RI(g);
        const { lowS: E, prehash: T, format: I } = g;
        if ("strict" in g) throw new Error("options.strict was renamed to lowS");
        if (I !== void 0 && ![
            "compact",
            "der",
            "js"
        ].includes(I)) throw new Error('format must be "compact", "der" or "js"');
        const P = typeof m == "string" || Hr.isBytes(m), k = !P && !I && typeof m == "object" && m !== null && typeof m.r == "bigint" && typeof m.s == "bigint";
        if (!P && !k) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let L, j;
        try {
            if (k) if (I === void 0 || I === "js") L = new p(m.r, m.s);
            else throw new Error("invalid format");
            if (P) {
                try {
                    I !== "compact" && (L = p.fromDER(m));
                } catch (De) {
                    if (!(De instanceof Ja.Err)) throw De;
                }
                !L && I !== "der" && (L = p.fromCompact(m));
            }
            j = e.fromHex(w);
        } catch  {
            return !1;
        }
        if (!L || E && L.hasHighS()) return !1;
        T && (S = t.hash(S));
        const { r: ie, s: ue } = L, ce = D(S), he = s.inv(ue), ee = s.create(ce * he), ae = s.create(ie * he), ye = e.BASE.multiplyUnsafe(ee).add(j.multiplyUnsafe(ae));
        return ye.is0() ? !1 : s.create(ye.x) === ie;
    }
    return Object.freeze({
        getPublicKey: A,
        getSharedSecret: N,
        sign: R,
        verify: X,
        utils: _,
        Point: e,
        Signature: p
    });
}
function Gce(e) {
    const t = {
        a: e.a,
        b: e.b,
        p: e.Fp.ORDER,
        n: e.n,
        h: e.h,
        Gx: e.Gx,
        Gy: e.Gy
    }, r = e.Fp, n = x0(t.n, e.nBitLength), i = {
        Fp: r,
        Fn: n,
        allowedPrivateKeyLengths: e.allowedPrivateKeyLengths,
        allowInfinityPoint: e.allowInfinityPoint,
        endo: e.endo,
        wrapPrivateKey: e.wrapPrivateKey,
        isTorsionFree: e.isTorsionFree,
        clearCofactor: e.clearCofactor,
        fromBytes: e.fromBytes,
        toBytes: e.toBytes
    };
    return {
        CURVE: t,
        curveOpts: i
    };
}
function Zce(e) {
    const { CURVE: t, curveOpts: r } = Gce(e), n = {
        hash: e.hash,
        hmac: e.hmac,
        randomBytes: e.randomBytes,
        lowS: e.lowS,
        bits2int: e.bits2int,
        bits2int_modN: e.bits2int_modN
    };
    return {
        CURVE: t,
        curveOpts: r,
        ecdsaOpts: n
    };
}
function Yce(e, t) {
    return Object.assign({}, t, {
        ProjectivePoint: t.Point,
        CURVE: e
    });
}
function Xce(e) {
    const { CURVE: t, curveOpts: r, ecdsaOpts: n } = Zce(e), i = Wce(t, r), o = Vce(i, n, r);
    return Yce(e, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Jce(e, t) {
    const r = (n)=>Xce({
            ...e,
            hash: n
        });
    return {
        ...r(t),
        create: r
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Im = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const Qce = BigInt(1), mx = BigInt(2), CI = (e, t)=>(e + t / mx) / t;
function eue(e) {
    const t = Im.p, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), u = BigInt(88), f = e * e * e % t, c = f * f * e % t, l = Qo(c, r, t) * c % t, p = Qo(l, r, t) * c % t, y = Qo(p, mx, t) * f % t, _ = Qo(y, i, t) * y % t, A = Qo(_, o, t) * _ % t, O = Qo(A, a, t) * A % t, N = Qo(O, u, t) * O % t, U = Qo(N, a, t) * A % t, D = Qo(U, r, t) * c % t, H = Qo(D, s, t) * _ % t, K = Qo(H, n, t) * f % t, re = Qo(K, mx, t);
    if (!bx.eql(bx.sqr(re), e)) throw new Error("Cannot find square root");
    return re;
}
const bx = x0(Im.p, void 0, void 0, {
    sqrt: eue
}), mp = Jce({
    ...Im,
    Fp: bx,
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (e)=>{
            const t = Im.n, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Qce * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = BigInt("0x100000000000000000000000000000000"), a = CI(o * e, t), u = CI(-n * e, t);
            let f = Bo(e - a * r - u * i, t), c = Bo(-a * n - u * o, t);
            const l = f > s, p = c > s;
            if (l && (f = t - f), p && (c = t - c), f > s || c > s) throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: l,
                k1: f,
                k2neg: p,
                k2: c
            };
        }
    }
}, B9);
function tue(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function UI(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function rue(e, t) {
    tue(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const nue = (e)=>e instanceof Uint8Array, Z_ = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ta = (e, t)=>e << 32 - t | e >>> t, iue = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!iue) throw new Error("Non little-endian hardware is not supported");
function oue(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
}
function TM(e) {
    if (typeof e == "string" && (e = oue(e)), !nue(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e;
}
let sue = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function aue(e) {
    const t = (n)=>e().update(TM(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function cue(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let uue = class extends sue {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Z_(this.buffer);
    }
    update(t) {
        UI(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = TM(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = Z_(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        UI(this), rue(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        cue(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = Z_(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const fue = (e, t, r)=>e & t ^ ~e & r, lue = (e, t, r)=>e & t ^ e & r ^ t & r, due = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Lc = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Dc = /* @__PURE__ */ new Uint32Array(64);
let hue = class extends uue {
    constructor(){
        super(64, 32, 8, !1), this.A = Lc[0] | 0, this.B = Lc[1] | 0, this.C = Lc[2] | 0, this.D = Lc[3] | 0, this.E = Lc[4] | 0, this.F = Lc[5] | 0, this.G = Lc[6] | 0, this.H = Lc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Dc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Dc[l - 15], y = Dc[l - 2], _ = ta(p, 7) ^ ta(p, 18) ^ p >>> 3, A = ta(y, 17) ^ ta(y, 19) ^ y >>> 10;
            Dc[l] = A + Dc[l - 7] + _ + Dc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = ta(a, 6) ^ ta(a, 11) ^ ta(a, 25), y = c + p + fue(a, u, f) + due[l] + Dc[l] | 0, A = (ta(n, 2) ^ ta(n, 13) ^ ta(n, 22)) + lue(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Dc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
};
const wx = /* @__PURE__ */ aue(()=>new hue());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // @__NO_SIDE_EFFECTS__
function S0(...e) {
    const t = (i, o)=>(s)=>i(o(s)), r = Array.from(e).reverse().reduce((i, o)=>i ? t(i, o.encode) : o.encode, void 0), n = e.reduce((i, o)=>i ? t(i, o.decode) : o.decode, void 0);
    return {
        encode: r,
        decode: n
    };
}
// @__NO_SIDE_EFFECTS__
function l1(e) {
    return {
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
            return t.map((r)=>{
                if (r < 0 || r >= e.length) throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
                return e[r];
            });
        },
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("alphabet.decode input should be array of strings");
            return t.map((r)=>{
                if (typeof r != "string") throw new Error(`alphabet.decode: not string element=${r}`);
                const n = e.indexOf(r);
                if (n === -1) throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
                return n;
            });
        }
    };
}
// @__NO_SIDE_EFFECTS__
function d1(e = "") {
    if (typeof e != "string") throw new Error("join separator should be string");
    return {
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("join.encode input should be array of strings");
            for (let r of t)if (typeof r != "string") throw new Error(`join.encode: non-string input=${r}`);
            return t.join(e);
        },
        decode: (t)=>{
            if (typeof t != "string") throw new Error("join.decode input should be string");
            return t.split(e);
        }
    };
}
// @__NO_SIDE_EFFECTS__
function kM(e, t = "=") {
    if (typeof t != "string") throw new Error("padding chr should be string");
    return {
        encode (r) {
            if (!Array.isArray(r) || r.length && typeof r[0] != "string") throw new Error("padding.encode input should be array of strings");
            for (let n of r)if (typeof n != "string") throw new Error(`padding.encode: non-string input=${n}`);
            for(; r.length * e % 8;)r.push(t);
            return r;
        },
        decode (r) {
            if (!Array.isArray(r) || r.length && typeof r[0] != "string") throw new Error("padding.encode input should be array of strings");
            for (let i of r)if (typeof i != "string") throw new Error(`padding.decode: non-string input=${i}`);
            let n = r.length;
            if (n * e % 8) throw new Error("Invalid padding: string should have whole number of bytes");
            for(; n > 0 && r[n - 1] === t; n--)if (!((n - 1) * e % 8)) throw new Error("Invalid padding: string has too much padding");
            return r.slice(0, n);
        }
    };
}
// @__NO_SIDE_EFFECTS__
function $I(e, t, r) {
    if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
    if (!Array.isArray(e)) throw new Error("convertRadix: data should be array");
    if (!e.length) return [];
    let n = 0;
    const i = [], o = Array.from(e);
    for(o.forEach((s)=>{
        if (s < 0 || s >= t) throw new Error(`Wrong integer: ${s}`);
    });;){
        let s = 0, a = !0;
        for(let u = n; u < o.length; u++){
            const f = o[u], c = t * s + f;
            if (!Number.isSafeInteger(c) || t * s / t !== s || c - f !== t * s) throw new Error("convertRadix: carry overflow");
            s = c % r;
            const l = Math.floor(c / r);
            if (o[u] = l, !Number.isSafeInteger(l) || l * r + s !== c) throw new Error("convertRadix: carry overflow");
            if (a) l ? a = !1 : n = u;
            else continue;
        }
        if (i.push(s), a) break;
    }
    for(let s = 0; s < e.length - 1 && e[s] === 0; s++)i.push(0);
    return i.reverse();
}
const IM = /* @__NO_SIDE_EFFECTS__ */ (e, t)=>t ? /* @__PURE__ */ IM(t, e % t) : e, Bm = /* @__NO_SIDE_EFFECTS__ */ (e, t)=>e + (t - /* @__PURE__ */ IM(e, t));
// @__NO_SIDE_EFFECTS__
function vx(e, t, r, n) {
    if (!Array.isArray(e)) throw new Error("convertRadix2: data should be array");
    if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);
    if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
    if (/* @__PURE__ */ Bm(t, r) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ Bm(t, r)}`);
    let i = 0, o = 0;
    const s = 2 ** r - 1, a = [];
    for (const u of e){
        if (u >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);
        if (i = i << t | u, o + t > 32) throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);
        for(o += t; o >= r; o -= r)a.push((i >> o - r & s) >>> 0);
        i &= 2 ** o - 1;
    }
    if (i = i << r - o & s, !n && o >= t) throw new Error("Excess padding");
    if (!n && i) throw new Error(`Non-zero padding: ${i}`);
    return n && o > 0 && a.push(i >>> 0), a;
}
// @__NO_SIDE_EFFECTS__
function pue(e) {
    return {
        encode: (t)=>{
            if (!(t instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
            return /* @__PURE__ */ $I(Array.from(t), 2 ** 8, e);
        },
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("radix.decode input should be array of strings");
            return Uint8Array.from(/* @__PURE__ */ $I(t, e, 2 ** 8));
        }
    };
}
// @__NO_SIDE_EFFECTS__
function AS(e, t = !1) {
    if (e <= 0 || e > 32) throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ Bm(8, e) > 32 || /* @__PURE__ */ Bm(e, 8) > 32) throw new Error("radix2: carry overflow");
    return {
        encode: (r)=>{
            if (!(r instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
            return /* @__PURE__ */ vx(Array.from(r), 8, e, !t);
        },
        decode: (r)=>{
            if (!Array.isArray(r) || r.length && typeof r[0] != "number") throw new Error("radix2.decode input should be array of strings");
            return Uint8Array.from(/* @__PURE__ */ vx(r, e, 8, t));
        }
    };
}
// @__NO_SIDE_EFFECTS__
function LI(e) {
    if (typeof e != "function") throw new Error("unsafeWrapper fn should be function");
    return function(...t) {
        try {
            return e.apply(null, t);
        } catch  {}
    };
}
// @__NO_SIDE_EFFECTS__
function gue(e, t) {
    if (typeof t != "function") throw new Error("checksum fn should be function");
    return {
        encode (r) {
            if (!(r instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
            const n = t(r).slice(0, e), i = new Uint8Array(r.length + e);
            return i.set(r), i.set(n, r.length), i;
        },
        decode (r) {
            if (!(r instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
            const n = r.slice(0, -e), i = t(n).slice(0, e), o = r.slice(-e);
            for(let s = 0; s < e; s++)if (i[s] !== o[s]) throw new Error("Invalid checksum");
            return n;
        }
    };
}
const DI = /* @__PURE__ */ S0(/* @__PURE__ */ AS(6), /* @__PURE__ */ l1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ kM(6), /* @__PURE__ */ d1("")), FI = /* @__PURE__ */ S0(/* @__PURE__ */ AS(6), /* @__PURE__ */ l1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ kM(6), /* @__PURE__ */ d1("")), yue = (e)=>/* @__PURE__ */ S0(/* @__PURE__ */ pue(58), /* @__PURE__ */ l1(e), /* @__PURE__ */ d1("")), mue = /* @__PURE__ */ yue("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), zI = (e)=>/* @__PURE__ */ S0(/* @__PURE__ */ gue(4, (t)=>e(e(t))), mue), _x = /* @__PURE__ */ S0(/* @__PURE__ */ l1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ d1("")), jI = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
];
// @__NO_SIDE_EFFECTS__
function yh(e) {
    const t = e >> 25;
    let r = (e & 33554431) << 5;
    for(let n = 0; n < jI.length; n++)(t >> n & 1) === 1 && (r ^= jI[n]);
    return r;
}
// @__NO_SIDE_EFFECTS__
function HI(e, t, r = 1) {
    const n = e.length;
    let i = 1;
    for(let o = 0; o < n; o++){
        const s = e.charCodeAt(o);
        if (s < 33 || s > 126) throw new Error(`Invalid prefix (${e})`);
        i = /* @__PURE__ */ yh(i) ^ s >> 5;
    }
    i = /* @__PURE__ */ yh(i);
    for(let o = 0; o < n; o++)i = /* @__PURE__ */ yh(i) ^ e.charCodeAt(o) & 31;
    for (let o of t)i = /* @__PURE__ */ yh(i) ^ o;
    for(let o = 0; o < 6; o++)i = /* @__PURE__ */ yh(i);
    return i ^= r, _x.encode(/* @__PURE__ */ vx([
        i % 2 ** 30
    ], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function BM(e) {
    const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ AS(5), n = r.decode, i = r.encode, o = /* @__PURE__ */ LI(n);
    function s(c, l, p = 90) {
        if (typeof c != "string") throw new Error(`bech32.encode prefix should be string, not ${typeof c}`);
        if (!Array.isArray(l) || l.length && typeof l[0] != "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof l}`);
        const y = c.length + 7 + l.length;
        if (p !== !1 && y > p) throw new TypeError(`Length ${y} exceeds limit ${p}`);
        const _ = c.toLowerCase(), A = /* @__PURE__ */ HI(_, l, t);
        return `${_}1${_x.encode(l)}${A}`;
    }
    function a(c, l = 90) {
        if (typeof c != "string") throw new Error(`bech32.decode input should be string, not ${typeof c}`);
        if (c.length < 8 || l !== !1 && c.length > l) throw new TypeError(`Wrong string length: ${c.length} (${c}). Expected (8..${l})`);
        const p = c.toLowerCase();
        if (c !== p && c !== c.toUpperCase()) throw new Error("String must be lowercase or uppercase");
        c = p;
        const y = c.lastIndexOf("1");
        if (y === 0 || y === -1) throw new Error('Letter "1" must be present between prefix and data only');
        const _ = c.slice(0, y), A = c.slice(y + 1);
        if (A.length < 6) throw new Error("Data must be at least 6 characters long");
        const O = _x.decode(A).slice(0, -6), N = /* @__PURE__ */ HI(_, O, t);
        if (!A.endsWith(N)) throw new Error(`Invalid checksum in ${c}: expected "${N}"`);
        return {
            prefix: _,
            words: O
        };
    }
    const u = /* @__PURE__ */ LI(a);
    function f(c) {
        const { prefix: l, words: p } = a(c, !1);
        return {
            prefix: l,
            words: p,
            bytes: n(p)
        };
    }
    return {
        encode: s,
        decode: a,
        decodeToBytes: f,
        decodeUnsafe: u,
        fromWords: n,
        fromWordsUnsafe: o,
        toWords: i
    };
}
const dy = /* @__PURE__ */ BM("bech32"), hy = /* @__PURE__ */ BM("bech32m"), ga = {
    b58chk: {
        encode: (e)=>zI(wx).encode(e),
        decode: (e)=>zI(wx).decode(e)
    },
    base64: {
        encode: (e)=>DI.encode(e),
        decode: (e)=>DI.decode(e)
    },
    b64url: {
        encode: (e)=>FI.encode(e),
        decode: (e)=>FI.decode(e)
    },
    bech32: {
        to_words: dy.toWords,
        to_bytes: dy.fromWords,
        encode: (e, t, r = !1)=>dy.encode(e, t, r),
        decode: (e, t = !1)=>{
            const { prefix: r, words: n } = dy.decode(e, t);
            return {
                prefix: r,
                words: n
            };
        }
    },
    bech32m: {
        to_words: hy.toWords,
        to_bytes: hy.fromWords,
        encode: (e, t, r = !1)=>hy.encode(e, t, r),
        decode: (e, t = !1)=>{
            const { prefix: r, words: n } = hy.decode(e, t);
            return {
                prefix: r,
                words: n
            };
        }
    }
};
function bue(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function wue(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function vue(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
function OM(e, t) {
    if (e !== t) throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
const _ue = BigInt(0), Eue = BigInt(255), PM = BigInt(256);
function xue(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Sue(e, t, r = "be") {
    t === void 0 && (t = xue(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > _ue;){
        const a = e & Eue, u = Number(a);
        n ? o.setUint8(s++, u) : o.setUint8(s--, u), e = (e - a) / PM;
    }
    return new Uint8Array(i);
}
function Aue(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * PM + BigInt(e[r]);
    return BigInt(t);
}
function Tue(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i = 0; n < t.length; n += 8, i++){
        let o = 0;
        for(let s = 0; s < 8; s++)o |= t[n + s] << 7 - s;
        r[i] = o;
    }
    return r;
}
function kue(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i = 7; i >= 0; i--, r++)t[r] = n >> i & 1;
    }
    return t.join("");
}
function Iue(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Bue(e, t, r = "be") {
    t === void 0 && (t = Iue(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > 0;){
        const a = e & 255;
        n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
    }
    return new Uint8Array(i);
}
function Oue(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], vue(t);
    return t;
}
const Pue = new TextEncoder(), Nue = new TextDecoder();
function TS(e) {
    return Pue.encode(e);
}
function Y_(e) {
    return Nue.decode(e);
}
function Mue(e, t) {
    wue(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function Rue(e, t, r = "le") {
    t = Mue(e, t);
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(let a = 0; a < e.length; a += 2){
        const u = e.substring(a, a + 2), f = parseInt(u, 16);
        n ? o.setUint8(s++, f) : o.setUint8(s--, f);
    }
    return new Uint8Array(i);
}
function Cue(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
const { getRandomValues: Uue } = crypto ?? globalThis.crypto ?? window.crypto;
function $ue(e = 32) {
    if (typeof Uue == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function NM(e) {
    return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function Lue(e) {
    return typeof e == "string" && NM(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? !0 : !!(Array.isArray(e) && e.every((t)=>typeof t == "number"));
}
function Due(e, t, r = "be") {
    t === void 0 && (t = e.length), bue(e, t);
    const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
    return n.set(e, i), n;
}
function MM(e) {
    let t, r = 0;
    const n = e.reduce((o, s)=>o + s.length, 0), i = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i.set(o, r), r += o.length;
    }
    return i;
}
function Fue(e, t) {
    return typeof t == "bigint" ? `${t}n` : t;
}
function zue(e, t) {
    return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function jue(e, t, r) {
    const n = e.length, i = r / t;
    if (r % t !== 0) throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
    if (n !== r) throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
    if (n % t !== 0) throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
    const o = new Array(i);
    for(let s = 0; s < i; s++){
        const a = s * t;
        o[s] = e.subarray(a, a + t);
    }
    return o;
}
function kS(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return Due(e, t, r);
    if (Array.isArray(e)) {
        const n = e.map((i)=>kS(i, t, r));
        return MM(n);
    } else {
        if (typeof e == "string") return Rue(e, t, r);
        if (typeof e == "bigint") return Sue(e, t, r);
        if (typeof e == "number") return Bue(e, t, r);
        if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    }
    throw new TypeError("Unsupported format:" + typeof e);
}
var Jt;
let on = (Jt = class extends Uint8Array {
    static random(t = 32) {
        const r = $ue(t);
        return new Jt(r, t);
    }
    static now(t = 4) {
        const r = Math.floor(Date.now() / 1e3);
        return new Jt(r, t);
    }
    constructor(t, r, n){
        if (t instanceof Jt && r === void 0) return t;
        const i = kS(t, r, n);
        super(i);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.to_num();
    }
    get big() {
        return this.to_big();
    }
    get str() {
        return this.to_str();
    }
    get hex() {
        return this.to_hex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.to_bin();
    }
    get b58chk() {
        return this.to_b58chk();
    }
    get base64() {
        return this.to_base64();
    }
    get b64url() {
        return this.to_b64url();
    }
    get digest() {
        return this.to_hash();
    }
    get id() {
        return this.to_hash().hex;
    }
    get stream() {
        return new rfe(this);
    }
    to_num(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Oue(r);
    }
    to_big(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Aue(r);
    }
    to_bin() {
        return kue(this);
    }
    to_hash() {
        const t = wx(this);
        return new Jt(t);
    }
    to_json(t) {
        t === void 0 && (t = zue);
        const r = Y_(this);
        return JSON.parse(r, t);
    }
    to_bech32(t, r) {
        const { encode: n, to_words: i } = ga.bech32, o = i(this);
        return n(t, o, r);
    }
    to_bech32m(t, r) {
        const { encode: n, to_words: i } = ga.bech32m, o = i(this);
        return n(t, o, r);
    }
    to_str() {
        return Y_(this);
    }
    to_hex() {
        return Cue(this);
    }
    to_bytes() {
        return new Uint8Array(this);
    }
    to_b58chk() {
        return ga.b58chk.encode(this);
    }
    to_base64() {
        return ga.base64.encode(this);
    }
    to_b64url() {
        return ga.b64url.encode(this);
    }
    append(t) {
        return Jt.join([
            this,
            Jt.bytes(t)
        ]);
    }
    prepend(t) {
        return Jt.join([
            Jt.bytes(t),
            this
        ]);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new Jt(t);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new Jt(n);
    }
    set(t, r) {
        this.set(t, r);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new Jt(n);
    }
    write(t, r) {
        const n = Jt.bytes(t);
        this.set(n, r);
    }
    add_varint(t) {
        const r = Jt.calc_varint(this.length, t);
        return Jt.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new Jt(Uint8Array.from(t));
    }
    static of(...t) {
        return new Jt(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i)=>Jt.bytes(i)), n = MM(r);
        return new Jt(n);
    }
    static sort(t, r) {
        const n = t.map((i)=>qI(i, r).hex);
        return n.sort(), n.map((i)=>Jt.hex(i, r));
    }
    static calc_varint(t, r) {
        if (t < 253) return Jt.num(t, 1);
        if (t < 65536) return Jt.of(253, ...Jt.num(t, 2, r));
        if (t < 4294967296) return Jt.of(254, ...Jt.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return Jt.of(255, ...Jt.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
}, Jt.num = Hue, Jt.big = Kue, Jt.bin = que, Jt.raw = Wue, Jt.str = Vue, Jt.hex = Gue, Jt.bytes = qI, Jt.json = Zue, Jt.base64 = Yue, Jt.b64url = Xue, Jt.bech32 = Jue, Jt.bech32m = Que, Jt.b58chk = efe, Jt.encode = TS, Jt.decode = Y_, Jt.parse = tfe, Jt.is_bytes = Lue, Jt.is_hex = NM, Jt);
function Hue(e, t, r) {
    return new on(e, t, r);
}
function que(e, t, r) {
    return new on(Tue(e), t, r);
}
function Kue(e, t, r) {
    return new on(e, t, r);
}
function Wue(e, t, r) {
    return new on(e, t, r);
}
function Vue(e, t, r) {
    return new on(TS(e), t, r);
}
function Gue(e, t, r) {
    return new on(e, t, r);
}
function Zue(e, t) {
    t === void 0 && (t = Fue);
    const r = JSON.stringify(e, t);
    return new on(TS(r));
}
function Yue(e) {
    return new on(ga.base64.decode(e));
}
function Xue(e) {
    return new on(ga.b64url.decode(e));
}
function Jue(e, t, r) {
    const { decode: n, to_bytes: i } = ga.bech32, { prefix: o, words: s } = n(e, t), a = i(s);
    return typeof r == "string" && OM(o, r), new on(a);
}
function Que(e, t, r) {
    const { decode: n, to_bytes: i } = ga.bech32m, { prefix: o, words: s } = n(e, t), a = i(s);
    return typeof r == "string" && OM(o, r), new on(a);
}
function efe(e) {
    return new on(ga.b58chk.decode(e));
}
function tfe(e, t, r) {
    const n = kS(e);
    return jue(n, t, r).map((o)=>on.bytes(o));
}
let rfe = class {
    constructor(t){
        this.data = on.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new on(this.data.slice(0, t));
    }
    read(t) {
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    read_varint(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).to_num(t);
            case r === 254:
                return this.read(4).to_num(t);
            case r === 255:
                return this.read(8).to_num(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
};
function qI(e, t, r) {
    return new on(e, t, r);
}
const Om = mp.CURVE, h1 = Om.n, nfe = Om.p, KI = {
    x: Om.Gx,
    y: Om.Gy
}, ife = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const ofe = (e)=>Bo(e, h1);
function RM(e, t = !1) {
    if (!t) return !1;
    throw new Error(e);
}
function sfe(e, t, r) {
    const n = on.bytes(e);
    return n.length !== t ? RM(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function afe(e, t) {
    return typeof e == "bigint" && ife < e && e < h1 || RM("x value is not in the field!", t), !0;
}
const cfe = x0(h1, 32, !0), WI = mp.ProjectivePoint, mh = cfe;
var un;
let cd = (un = class extends Uint8Array {
    static add(t) {
        return t.map((r)=>un.mod(r)).reduce((r, n)=>r.add(n));
    }
    static mod(t) {
        return new un(t);
    }
    static mul(t) {
        return t.map((r)=>un.mod(r)).reduce((r, n)=>r.mul(n));
    }
    static is_valid(t, r) {
        const n = on.bytes(t, 32).big;
        return afe(n, r);
    }
    constructor(t){
        const r = ofe(ufe(t));
        un.is_valid(r, !0), super(on.big(r, 32), 32);
    }
    get buff() {
        return new on(this);
    }
    get raw() {
        return this.buff.raw;
    }
    get big() {
        return this.buff.big;
    }
    get hex() {
        return this.buff.hex;
    }
    get point() {
        return this.generate();
    }
    get hasOddY() {
        return this.point.hasOddY;
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    gt(t) {
        return new un(t).big > this.big;
    }
    lt(t) {
        return new un(t).big < this.big;
    }
    eq(t) {
        return new un(t).big === this.big;
    }
    ne(t) {
        return new un(t).big !== this.big;
    }
    add(t) {
        const r = un.mod(t), n = mh.add(this.big, r.big);
        return new un(n);
    }
    sub(t) {
        const r = un.mod(t), n = mh.sub(this.big, r.big);
        return new un(n);
    }
    mul(t) {
        const r = un.mod(t), n = mh.mul(this.big, r.big);
        return new un(n);
    }
    pow(t) {
        const r = un.mod(t), n = mh.pow(this.big, r.big);
        return new un(n);
    }
    div(t) {
        const r = un.mod(t), n = mh.div(this.big, r.big);
        return new un(n);
    }
    negate() {
        return new un(un.N - this.big);
    }
    generate() {
        const r = mp.ProjectivePoint.BASE.multiply(this.big);
        return IS.import(r);
    }
}, un.N = h1, un);
var Vr;
let IS = (Vr = class {
    static from_x(t, r = !1) {
        let n = ffe(t);
        n.length === 32 ? n = n.prepend(2) : r && (n[0] = 2), sfe(n, 33);
        const i = WI.fromHex(n.hex);
        return i.assertValidity(), new Vr(i.x, i.y);
    }
    static generate(t) {
        const r = cd.mod(t), n = Vr.base.multiply(r.big);
        return Vr.import(n);
    }
    static import(t) {
        const r = t instanceof Vr ? {
            x: t.x.big,
            y: t.y.big
        } : {
            x: t.x,
            y: t.y
        };
        return new Vr(r.x, r.y);
    }
    constructor(t, r){
        this._p = new WI(t, r, 1n), this.p.assertValidity();
    }
    get p() {
        return this._p;
    }
    get x() {
        return on.big(this.p.x, 32);
    }
    get y() {
        return on.big(this.p.y, 32);
    }
    get buff() {
        return on.raw(this.p.toRawBytes(!0));
    }
    get raw() {
        return this.buff.raw;
    }
    get hex() {
        return this.buff.hex;
    }
    get hasEvenY() {
        return this.p.hasEvenY();
    }
    get hasOddY() {
        return !this.p.hasEvenY();
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    eq(t) {
        const r = t instanceof Vr ? t : Vr.from_x(t);
        return this.x.big === r.x.big && this.y.big === r.y.big;
    }
    add(t) {
        return t instanceof Vr ? Vr.import(this.p.add(t.p)) : Vr.import(this.p.add(Vr.generate(t).p));
    }
    sub(t) {
        return t instanceof Vr ? Vr.import(this.p.subtract(t.p)) : Vr.import(this.p.subtract(Vr.generate(t).p));
    }
    mul(t) {
        return t instanceof Vr ? Vr.import(this.p.multiply(t.x.big)) : Vr.import(this.p.multiply(cd.mod(t).big));
    }
    negate() {
        return Vr.import(this.p.negate());
    }
}, Vr.P = nfe, Vr.G = new Vr(KI.x, KI.y), Vr.curve = mp.CURVE, Vr.base = mp.ProjectivePoint.BASE, Vr.mul = Vr.generate, Vr);
function ufe(e) {
    if (e instanceof cd) return e.big;
    if (e instanceof IS) return e.x.big;
    if (e instanceof Uint8Array) return on.raw(e).big;
    if (typeof e == "string") return on.hex(e).big;
    if (typeof e == "number") return on.num(e).big;
    if (typeof e == "bigint") return BigInt(e);
    throw TypeError("Invalid input type:" + typeof e);
}
function ffe(e) {
    if (e instanceof cd) return e.point.buff;
    if (e instanceof IS) return e.buff;
    if (e instanceof Uint8Array || typeof e == "string") return on.bytes(e);
    if (typeof e == "number" || typeof e == "bigint") return on.bytes(e, 32);
    throw new TypeError(`Unknown type: ${typeof e}`);
}
function lfe(e, t = !1) {
    const r = cd.mod(e);
    return t ? r.negated.buff : r.buff;
}
function CM(e, t = !1) {
    const r = cd.mod(e).point;
    return t ? r.x : r.buff;
}
function Ex(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function dfe(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function UM(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function hfe(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Ex(e.outputLen), Ex(e.blockLen);
}
function pfe(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function gfe(e, t) {
    UM(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const yfe = {
    number: Ex,
    bool: dfe,
    bytes: UM,
    hash: hfe,
    exists: pfe,
    output: gfe
};
var X_ = yfe;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const J_ = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ra = (e, t)=>e << 32 - t | e >>> t, mfe = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!mfe) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function bfe(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function $M(e) {
    if (typeof e == "string" && (e = bfe(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
let wfe = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function LM(e) {
    const t = (n)=>e().update($M(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function vfe(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let _fe = class extends wfe {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = J_(this.buffer);
    }
    update(t) {
        X_.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = $M(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = J_(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        X_.exists(this), X_.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        vfe(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = J_(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const Efe = (e, t, r)=>e & t ^ ~e & r, xfe = (e, t, r)=>e & t ^ e & r ^ t & r, Sfe = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Fc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), zc = new Uint32Array(64);
let DM = class extends _fe {
    constructor(){
        super(64, 32, 8, !1), this.A = Fc[0] | 0, this.B = Fc[1] | 0, this.C = Fc[2] | 0, this.D = Fc[3] | 0, this.E = Fc[4] | 0, this.F = Fc[5] | 0, this.G = Fc[6] | 0, this.H = Fc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)zc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = zc[l - 15], y = zc[l - 2], _ = ra(p, 7) ^ ra(p, 18) ^ p >>> 3, A = ra(y, 17) ^ ra(y, 19) ^ y >>> 10;
            zc[l] = A + zc[l - 7] + _ + zc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = ra(a, 6) ^ ra(a, 11) ^ ra(a, 25), y = c + p + Efe(a, u, f) + Sfe[l] + zc[l] | 0, A = (ra(n, 2) ^ ra(n, 13) ^ ra(n, 22)) + xfe(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        zc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Afe = class extends DM {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const xx = LM(()=>new DM());
LM(()=>new Afe());
function Tfe(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function kfe(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Ife(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Bfe } = crypto ?? globalThis.crypto ?? window.crypto;
function Ofe(e = 32) {
    if (typeof Bfe == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function Pfe(e, t, r = "be") {
    t === void 0 && (t = e.length), Tfe(e, t);
    const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
    return n.set(e, i), n;
}
function FM(e) {
    let t, r = 0;
    const n = e.reduce((o, s)=>o + s.length, 0), i = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i.set(o, r), r += o.length;
    }
    return i;
}
const Nfe = new TextEncoder(), Mfe = [
    {
        name: "base58",
        charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }
];
function zM(e) {
    for (const t of Mfe)if (t.name === e) return t.charset;
    throw TypeError("Charset does not exist: " + e);
}
function Rfe(e, t, r = !1) {
    typeof e == "string" && (e = Nfe.encode(e));
    const n = zM(t), i = n.length, o = [];
    let s = "", a, u = 0, f, c;
    for(a = 0; a < e.length; a++)for(u = 0, f = e[a], s += f > 0 || (s.length ^ a) > 0 ? "" : "1"; u in o || f > 0;)c = o[u], c = c > 0 ? c * 256 + f : f, f = c / i | 0, o[u] = c % i, u++;
    for(; u-- > 0;)s += n[o[u]];
    return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function Cfe(e, t) {
    const r = zM(t), n = r.length, i = [], o = [];
    e = e.replace("=", "");
    let s, a = 0, u, f;
    for(s = 0; s < e.length; s++){
        if (a = 0, u = r.indexOf(e[s]), u < 0) throw new Error(`Character range out of bounds: ${u}`);
        for(u > 0 || (o.length ^ s) > 0 || o.push(0); a in i || u > 0;)f = i[a], f = f > 0 ? f * n + u : u, u = f >> 8, i[a] = f % 256, a++;
    }
    for(; a-- > 0;)o.push(i[a]);
    return new Uint8Array(o);
}
function jM(e) {
    return xx(xx(e));
}
function Ufe(e) {
    const t = jM(e);
    return FM([
        e,
        t.slice(0, 4)
    ]);
}
function $fe(e) {
    const t = e.slice(0, -4), r = e.slice(-4);
    if (jM(t).slice(0, 4).toString() !== r.toString()) throw new Error("Invalid checksum!");
    return t;
}
const VI = {
    encode: Rfe,
    decode: Cfe
}, HM = {
    encode: (e)=>{
        const t = Ufe(e);
        return VI.encode(t, "base58");
    },
    decode: (e)=>{
        const t = VI.decode(e, "base58");
        return $fe(t);
    }
}, qM = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Lfe = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
], Pm = [
    {
        version: 0,
        name: "bech32",
        const: 1
    },
    {
        version: 1,
        name: "bech32m",
        const: 734539939
    }
];
function KM(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = t >> 25;
        t = (t & 33554431) << 5 ^ e[r];
        for(let i = 0; i < 5; ++i)n >> i & 1 && (t ^= Lfe[i]);
    }
    return t;
}
function WM(e) {
    const t = [];
    let r;
    for(r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) >> 5);
    for(t.push(0), r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) & 31);
    return t;
}
function Dfe(e, t, r) {
    const n = WM(e).concat(t);
    return KM(n) === r.const;
}
function Ffe(e, t, r) {
    const n = WM(e).concat(t).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ]), i = KM(n) ^ r.const, o = [];
    for(let s = 0; s < 6; ++s)o.push(i >> 5 * (5 - s) & 31);
    return o;
}
function VM(e, t, r, n = !0) {
    const i = [];
    let o = 0, s = 0;
    const a = (1 << r) - 1, u = (1 << t + r - 1) - 1;
    for (const f of e){
        if (f < 0 || f >> t > 0) throw new Error("Failed to perform base conversion. Invalid value: " + String(f));
        for(o = (o << t | f) & u, s += t; s >= r;)s -= r, i.push(o >> s & a);
    }
    if (n) s > 0 && i.push(o << r - s & a);
    else if (s >= t || (o << r - s & a) > 0) throw new Error("Failed to perform base conversion. Invalid Size!");
    return i;
}
function zfe(e, t, r) {
    const n = t.concat(Ffe(e, t, r));
    let i = e + "1";
    for(let o = 0; o < n.length; ++o)i += qM.charAt(n[o]);
    return i;
}
function GM(e) {
    if (!jfe(e)) throw new Error("Encoded string goes out of bounds!");
    if (e = e.toLowerCase(), !Hfe(e)) throw new Error("Encoded string has invalid separator!");
    const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
    for(let o = r + 1; o < e.length; ++o){
        const s = qM.indexOf(e.charAt(o));
        if (s === -1) throw new Error("Character idx out of bounds: " + String(o));
        t.push(s);
    }
    const i = Pm.find((o)=>o.version === t[0]) ?? Pm[0];
    if (!Dfe(n, t, i)) throw new Error("Checksum verification failed!");
    return [
        n,
        t.slice(0, t.length - 6)
    ];
}
function jfe(e) {
    let t, r, n = !1, i = !1;
    for(t = 0; t < e.length; ++t){
        if (r = e.charCodeAt(t), r < 33 || r > 126) return !1;
        r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i = !0);
    }
    return !(n && i);
}
function Hfe(e) {
    const t = e.lastIndexOf("1");
    return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function qfe(e, t = "bc", r = 0) {
    const n = [
        r,
        ...VM([
            ...e
        ], 8, 5)
    ], i = Pm.find((s)=>s.version === r) ?? Pm[0], o = zfe(t, n, i);
    return ZM(o), o;
}
function ZM(e) {
    e = e.toLowerCase();
    const t = e.split("1", 1)[0], [r, n] = GM(e), i = VM(n.slice(1), 5, 8, !1), o = i.length;
    switch(!0){
        case t !== r:
            throw new Error("Returned hrp string is invalid.");
        case i === null || o < 2 || o > 40:
            throw new Error("Decoded string is invalid or out of spec.");
        case n[0] > 16:
            throw new Error("Returned version bit is out of range.");
        default:
            return Uint8Array.from(i);
    }
}
function Kfe(e) {
    e = e.toLowerCase();
    const [t, r] = GM(e);
    return r[0];
}
const YM = {
    encode: qfe,
    decode: ZM,
    version: Kfe
}, XM = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", JM = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", Wfe = new TextEncoder();
function QM(e, t = !1, r = !0) {
    typeof e == "string" && (e = Wfe.encode(e));
    const n = t ? JM : XM;
    let i = "", o = 0, s = 0;
    for(let a = 0; a < e.length; a++)for(s = s << 8 | e[a], o += 8; o >= 6;)o -= 6, i += n[s >> o & 63];
    if (o > 0) for(s <<= 6 - o, i += n[s & 63]; o < 6;)i += r ? "=" : "", o += 2;
    return i;
}
function eR(e, t = !1) {
    const r = t || e.includes("-") || e.includes("_") ? JM.split("") : XM.split("");
    e = e.replace(/=+$/, "");
    const n = e.split("");
    let i = 0, o = 0;
    const s = [];
    for(let a = 0; a < n.length; a++){
        const u = n[a], f = r.indexOf(u);
        if (f === -1) throw new Error("Invalid character: " + u);
        i += 6, o <<= 6, o |= f, i >= 8 && (i -= 8, s.push(o >>> i & 255));
    }
    return new Uint8Array(s);
}
const tR = {
    encode: QM,
    decode: eR
}, rR = {
    encode: (e)=>QM(e, !0, !1),
    decode: (e)=>eR(e, !0)
}, Vfe = BigInt(0), Gfe = BigInt(255), nR = BigInt(256);
function Zfe(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Yfe(e, t, r = "be") {
    t === void 0 && (t = Zfe(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > Vfe;){
        const a = e & Gfe, u = Number(a);
        n ? o.setUint8(s++, u) : o.setUint8(s--, u), e = (e - a) / nR;
    }
    return new Uint8Array(i);
}
function Xfe(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * nR + BigInt(e[r]);
    return BigInt(t);
}
function Jfe(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i = 0; n < t.length; n += 8, i++){
        let o = 0;
        for(let s = 0; s < 8; s++)o |= t[n + s] << 7 - s;
        r[i] = o;
    }
    return r;
}
function Qfe(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i = 7; i >= 0; i--, r++)t[r] = n >> i & 1;
    }
    return t.join("");
}
function ele(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function tle(e, t, r = "be") {
    t === void 0 && (t = ele(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > 0;){
        const a = e & 255;
        n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
    }
    return new Uint8Array(i);
}
function rle(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], Ife(t);
    return t;
}
const nle = new TextEncoder(), ile = new TextDecoder();
function BS(e) {
    return nle.encode(e);
}
function Q_(e) {
    return ile.decode(e);
}
function ole(e, t) {
    kfe(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function sle(e, t, r = "le") {
    t = ole(e, t);
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(let a = 0; a < e.length; a += 2){
        const u = e.substring(a, a + 2), f = parseInt(u, 16);
        n ? o.setUint8(s++, f) : o.setUint8(s--, f);
    }
    return new Uint8Array(i);
}
function ale(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
function cle(e) {
    const t = JSON.stringify(e, (r, n)=>typeof n == "bigint" ? `${n}n` : n);
    return BS(t);
}
function ule(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return Pfe(e, t, r);
    if (typeof e == "string") return sle(e, t, r);
    if (typeof e == "bigint") return Yfe(e, t, r);
    if (typeof e == "number") return tle(e, t, r);
    if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    throw TypeError("Unsupported format:" + typeof e);
}
var lr;
let Ze = (lr = class extends Uint8Array {
    static random(t = 32) {
        const r = Ofe(t);
        return new lr(r, t);
    }
    constructor(t, r, n){
        const i = ule(t, r, n);
        super(i);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new Hd(this);
    }
    toNum(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return rle(r);
    }
    toBin() {
        return Qfe(this);
    }
    toBig(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Xfe(r);
    }
    toHash() {
        const t = xx(this);
        return new lr(t);
    }
    toJson() {
        const t = Q_(this);
        return JSON.parse(t);
    }
    toBech32(t, r = 0) {
        return YM.encode(this, t, r);
    }
    toStr() {
        return Q_(this);
    }
    toHex() {
        return ale(this);
    }
    toBytes() {
        return new Uint8Array(this);
    }
    tob58chk() {
        return HM.encode(this);
    }
    toBase64() {
        return tR.encode(this);
    }
    toB64url() {
        return rR.encode(this);
    }
    prepend(t) {
        return lr.join([
            lr.bytes(t),
            this
        ]);
    }
    append(t) {
        return lr.join([
            this,
            lr.bytes(t)
        ]);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new lr(n);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new lr(n);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new lr(t);
    }
    write(t, r) {
        const n = lr.bytes(t);
        this.set(n, r);
    }
    prefixSize(t) {
        const r = lr.varInt(this.length, t);
        return lr.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new lr(Uint8Array.from(t));
    }
    static of(...t) {
        return new lr(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i)=>lr.bytes(i)), n = FM(r);
        return new lr(n);
    }
    static varInt(t, r) {
        if (t < 253) return lr.num(t, 1);
        if (t < 65536) return lr.of(253, ...lr.num(t, 2, r));
        if (t < 4294967296) return lr.of(254, ...lr.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return lr.of(255, ...lr.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
}, lr.num = fle, lr.big = dle, lr.bin = lle, lr.raw = hle, lr.str = ple, lr.hex = gle, lr.bytes = yle, lr.json = mle, lr.base64 = ble, lr.b64url = wle, lr.bech32 = vle, lr.b58chk = _le, lr.encode = BS, lr.decode = Q_, lr);
function fle(e, t, r) {
    return new Ze(e, t, r);
}
function lle(e, t, r) {
    return new Ze(Jfe(e), t, r);
}
function dle(e, t, r) {
    return new Ze(e, t, r);
}
function hle(e, t, r) {
    return new Ze(e, t, r);
}
function ple(e, t, r) {
    return new Ze(BS(e), t, r);
}
function gle(e, t, r) {
    return new Ze(e, t, r);
}
function yle(e, t, r) {
    return new Ze(e, t, r);
}
function mle(e) {
    return new Ze(cle(e));
}
function ble(e) {
    return new Ze(tR.decode(e));
}
function wle(e) {
    return new Ze(rR.decode(e));
}
function vle(e) {
    return new Ze(YM.decode(e));
}
function _le(e) {
    return new Ze(HM.decode(e));
}
let Hd = class {
    constructor(t){
        this.data = Ze.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new Ze(this.data.slice(0, t));
    }
    read(t) {
        t = t ?? this.readSize();
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    readSize(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).toNum(t);
            case r === 254:
                return this.read(4).toNum(t);
            case r === 255:
                return this.read(8).toNum(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
};
function Ia(e, t) {
    const r = Ze.bytes(e);
    if (r.length !== t) throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function Oo(e, t) {
    if (t) throw new Error(e);
    return !1;
}
function $y(e, ...t) {
    const r = Ze.str(e).digest.raw, n = t.map((i)=>Ze.bytes(i));
    return Ze.join([
        r,
        r,
        Ze.join(n)
    ]).digest;
}
const iR = {
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_SUCCESS80: 80,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_SUCCESS98: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_SUCCESS126: 126,
    OP_SUCCESS127: 127,
    OP_SUCCESS128: 128,
    OP_SUCCESS129: 129,
    OP_SIZE: 130,
    OP_SUCCESS131: 131,
    OP_SUCCESS132: 132,
    OP_SUCCESS133: 133,
    OP_SUCCESS134: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_SUCCESS137: 137,
    OP_SUCCESS138: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_SUCCESS141: 141,
    OP_SUCCESS142: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_SUCCESS149: 149,
    OP_SUCCESS150: 150,
    OP_SUCCESS151: 151,
    OP_SUCCESS152: 152,
    OP_SUCCESS153: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_SUCCESS187: 187,
    OP_SUCCESS188: 188,
    OP_SUCCESS189: 189,
    OP_SUCCESS190: 190,
    OP_SUCCESS191: 191,
    OP_SUCCESS192: 192,
    OP_SUCCESS193: 193,
    OP_SUCCESS194: 194,
    OP_SUCCESS195: 195,
    OP_SUCCESS196: 196,
    OP_SUCCESS197: 197,
    OP_SUCCESS198: 198,
    OP_SUCCESS199: 199,
    OP_SUCCESS200: 200,
    OP_SUCCESS201: 201,
    OP_SUCCESS202: 202,
    OP_SUCCESS203: 203,
    OP_SUCCESS204: 204,
    OP_SUCCESS205: 205,
    OP_SUCCESS206: 206,
    OP_SUCCESS207: 207,
    OP_SUCCESS208: 208,
    OP_SUCCESS209: 209,
    OP_SUCCESS210: 210,
    OP_SUCCESS211: 211,
    OP_SUCCESS212: 212,
    OP_SUCCESS213: 213,
    OP_SUCCESS214: 214,
    OP_SUCCESS215: 215,
    OP_SUCCESS216: 216,
    OP_SUCCESS217: 217,
    OP_SUCCESS218: 218,
    OP_SUCCESS219: 219,
    OP_SUCCESS220: 220,
    OP_SUCCESS221: 221,
    OP_SUCCESS222: 222,
    OP_SUCCESS223: 223,
    OP_SUCCESS224: 224,
    OP_SUCCESS225: 225,
    OP_SUCCESS226: 226,
    OP_SUCCESS227: 227,
    OP_SUCCESS228: 228,
    OP_SUCCESS229: 229,
    OP_SUCCESS230: 230,
    OP_SUCCESS231: 231,
    OP_SUCCESS232: 232,
    OP_SUCCESS233: 233,
    OP_SUCCESS234: 234,
    OP_SUCCESS235: 235,
    OP_SUCCESS236: 236,
    OP_SUCCESS237: 237,
    OP_SUCCESS238: 238,
    OP_SUCCESS239: 239,
    OP_SUCCESS240: 240,
    OP_SUCCESS241: 241,
    OP_SUCCESS242: 242,
    OP_SUCCESS243: 243,
    OP_SUCCESS244: 244,
    OP_SUCCESS245: 245,
    OP_SUCCESS246: 246,
    OP_SUCCESS247: 247,
    OP_SUCCESS248: 248,
    OP_SUCCESS249: 249,
    OP_SUCCESS250: 250,
    OP_SUCCESS251: 251,
    OP_SUCCESS252: 252,
    OP_SUCCESS253: 253,
    OP_SUCCESS254: 254
};
function Ele(e) {
    if (e > 186 && e < 255) return "OP_SUCCESS" + String(e);
    for (const [t, r] of Object.entries(iR))if (r === e) return t;
    throw new Error("OPCODE not found:" + String(e));
}
function xle(e) {
    for (const [t, r] of Object.entries(iR))if (t === e) return Number(r);
    throw new Error("OPCODE not found:" + e);
}
function Sle(e) {
    switch(!0){
        case e === 0:
            return "opcode";
        case e >= 1 && e <= 75:
            return "varint";
        case e === 76:
            return "pushdata1";
        case e === 77:
            return "pushdata2";
        case e === 78:
            return "pushdata4";
        case e <= 254:
            return "opcode";
        default:
            throw new Error(`Invalid word range: ${e}`);
    }
}
function Ale(e) {
    const n = [];
    switch(!0){
        case typeof e != "number":
            return !1;
        case e === 0:
            return !0;
        case n.includes(e):
            return !1;
        case 75 < e && e < 254:
            return !0;
        default:
            return !1;
    }
}
function bc(e) {
    return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function oR(e) {
    return bc(e) || e instanceof Uint8Array;
}
const Nm = 520;
function Hf(e = [], t = !0) {
    let r = Ze.num(0);
    return Array.isArray(e) && (r = Ze.raw(sR(e))), bc(e) && (r = Ze.hex(e)), e instanceof Uint8Array && (r = Ze.raw(e)), t && (r = r.prefixSize("le")), r;
}
function sR(e) {
    const t = [];
    for (const r of e)t.push(Tle(r));
    return t.length > 0 ? Ze.join(t) : new Uint8Array();
}
function Tle(e) {
    let t = new Uint8Array();
    if (typeof e == "string") {
        if (e.startsWith("OP_")) return Ze.num(xle(e), 1);
        bc(e) ? t = Ze.hex(e) : t = Ze.str(e);
    } else t = Ze.bytes(e);
    if (t.length === 1) return t[0] !== 0 && t[0] <= 16 ? (t[0] += 80, t) : (t[0] > 128 && t[0] <= 255 && (t = new Uint8Array([
        t[0],
        0
    ])), Ze.join([
        GI(t.length),
        t
    ]));
    if (t.length > Nm) {
        const r = kle(t);
        return sR(r);
    } else return Ze.join([
        GI(t.length),
        t
    ]);
}
function GI(e) {
    const t = Ze.num(76, 1), r = Ze.num(77, 1);
    switch(!0){
        case e <= 75:
            return Ze.num(e);
        case e > 75 && e < 256:
            return Ze.join([
                t,
                Ze.num(e, 1, "le")
            ]);
        case e >= 256 && e <= Nm:
            return Ze.join([
                r,
                Ze.num(e, 2, "le")
            ]);
        default:
            throw new Error("Invalid word size:" + e.toString());
    }
}
function kle(e) {
    const t = [], r = new Hd(e);
    for(; r.size > Nm;)t.push(r.read(Nm));
    return t.push(r.read(r.size)), t;
}
function OS(e, t = !1) {
    let r = Ze.bytes(e);
    if (t) {
        const i = r.stream.readSize("le");
        if (r = r.slice(1), r.length !== i) throw new Error(`Varint does not match stream size: ${i} !== ${r.length}`);
    }
    return Ile(r);
}
function Ile(e) {
    const t = new Hd(e), r = [], n = t.size;
    let i, o, s, a = 0;
    for(; a < n;)switch(i = t.read(1).num, o = Sle(i), a++, o){
        case "varint":
            r.push(t.read(i).hex), a += i;
            break;
        case "pushdata1":
            s = t.read(1).reverse().num, r.push(t.read(s).hex), a += s + 1;
            break;
        case "pushdata2":
            s = t.read(2).reverse().num, r.push(t.read(s).hex), a += s + 2;
            break;
        case "pushdata4":
            s = t.read(4).reverse().num, r.push(t.read(s).hex), a += s + 4;
            break;
        case "opcode":
            if (!Ale(i)) throw new Error(`Invalid OPCODE: ${i}`);
            r.push(Ele(i));
            break;
        default:
            throw new Error(`Word type undefined: ${i}`);
    }
    return r;
}
function Ble(e, t) {
    if (Array.isArray(e) && (e = Hf(e, t)), e instanceof Uint8Array || bc(e)) return OS(e, t);
    throw new Error("Invalid format: " + typeof e);
}
function Ole(e, t) {
    if ((e instanceof Uint8Array || bc(e)) && (e = OS(e, t)), Array.isArray(e)) return Hf(e, t);
    throw new Error("Invalid format: " + typeof e);
}
function Ple(e) {
    if (!Array.isArray(e)) return Ze.bytes(e);
    throw new Error("Invalid format: " + typeof e);
}
const Nle = {
    toAsm: Ble,
    toBytes: Ole,
    toParam: Ple
}, Ba = {
    encode: Hf,
    decode: OS,
    fmt: Nle
};
function Sx(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Mle(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function aR(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Rle(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Sx(e.outputLen), Sx(e.blockLen);
}
function Cle(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function Ule(e, t) {
    aR(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const $le = {
    number: Sx,
    bool: Mle,
    bytes: aR,
    hash: Rle,
    exists: Cle,
    output: Ule
};
var uf = $le;
const eE = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const tE = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), na = (e, t)=>e << 32 - t | e >>> t, Lle = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!Lle) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function Dle(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function PS(e) {
    if (typeof e == "string" && (e = Dle(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
function Fle(...e) {
    if (!e.every((n)=>n instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (e.length === 1) return e[0];
    const t = e.reduce((n, i)=>n + i.length, 0), r = new Uint8Array(t);
    for(let n = 0, i = 0; n < e.length; n++){
        const o = e[n];
        r.set(o, i), i += o.length;
    }
    return r;
}
let cR = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function uR(e) {
    const t = (n)=>e().update(PS(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function zle(e = 32) {
    if (eE && typeof eE.getRandomValues == "function") return eE.getRandomValues(new Uint8Array(e));
    throw new Error("crypto.getRandomValues must be defined");
}
function jle(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let Hle = class extends cR {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = tE(this.buffer);
    }
    update(t) {
        uf.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = PS(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = tE(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        uf.exists(this), uf.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        jle(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = tE(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const qle = (e, t, r)=>e & t ^ ~e & r, Kle = (e, t, r)=>e & t ^ e & r ^ t & r, Wle = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), jc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Hc = new Uint32Array(64);
let fR = class extends Hle {
    constructor(){
        super(64, 32, 8, !1), this.A = jc[0] | 0, this.B = jc[1] | 0, this.C = jc[2] | 0, this.D = jc[3] | 0, this.E = jc[4] | 0, this.F = jc[5] | 0, this.G = jc[6] | 0, this.H = jc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Hc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Hc[l - 15], y = Hc[l - 2], _ = na(p, 7) ^ na(p, 18) ^ p >>> 3, A = na(y, 17) ^ na(y, 19) ^ y >>> 10;
            Hc[l] = A + Hc[l - 7] + _ + Hc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = na(a, 6) ^ na(a, 11) ^ na(a, 25), y = c + p + qle(a, u, f) + Wle[l] + Hc[l] | 0, A = (na(n, 2) ^ na(n, 13) ^ na(n, 22)) + Kle(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Hc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Vle = class extends fR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const lR = uR(()=>new fR());
uR(()=>new Vle());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Gle = BigInt(0), NS = BigInt(1), Zle = BigInt(2), p1 = (e)=>e instanceof Uint8Array, Yle = Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function ud(e) {
    if (!p1(e)) throw new Error("Uint8Array expected");
    let t = "";
    for(let r = 0; r < e.length; r++)t += Yle[e[r]];
    return t;
}
function dR(e) {
    const t = e.toString(16);
    return t.length & 1 ? `0${t}` : t;
}
function MS(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return BigInt(e === "" ? "0" : `0x${e}`);
}
function fd(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    if (e.length % 2) throw new Error("hex string is invalid: unpadded " + e.length);
    const t = new Uint8Array(e.length / 2);
    for(let r = 0; r < t.length; r++){
        const n = r * 2, i = e.slice(n, n + 2), o = Number.parseInt(i, 16);
        if (Number.isNaN(o) || o < 0) throw new Error("invalid byte sequence");
        t[r] = o;
    }
    return t;
}
function fu(e) {
    return MS(ud(e));
}
function RS(e) {
    if (!p1(e)) throw new Error("Uint8Array expected");
    return MS(ud(Uint8Array.from(e).reverse()));
}
const Zl = (e, t)=>fd(e.toString(16).padStart(t * 2, "0")), hR = (e, t)=>Zl(e, t).reverse(), Xle = (e)=>fd(dR(e));
function cs(e, t, r) {
    let n;
    if (typeof t == "string") try {
        n = fd(t);
    } catch (o) {
        throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
    else if (p1(t)) n = Uint8Array.from(t);
    else throw new Error(`${e} must be hex string or Uint8Array`);
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(`${e} expected ${r} bytes, got ${i}`);
    return n;
}
function Os(...e) {
    const t = new Uint8Array(e.reduce((n, i)=>n + i.length, 0));
    let r = 0;
    return e.forEach((n)=>{
        if (!p1(n)) throw new Error("Uint8Array expected");
        t.set(n, r), r += n.length;
    }), t;
}
function Jle(e, t) {
    if (e.length !== t.length) return !1;
    for(let r = 0; r < e.length; r++)if (e[r] !== t[r]) return !1;
    return !0;
}
function g1(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function Qle(e) {
    let t;
    for(t = 0; e > 0n; e >>= NS, t += 1);
    return t;
}
const ede = (e, t)=>e >> BigInt(t) & 1n, tde = (e, t, r)=>e | (r ? NS : Gle) << BigInt(t), CS = (e)=>(Zle << BigInt(e - 1)) - NS, rE = (e)=>new Uint8Array(e), ZI = (e)=>Uint8Array.from(e);
function pR(e, t, r) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    let n = rE(e), i = rE(e), o = 0;
    const s = ()=>{
        n.fill(1), i.fill(0), o = 0;
    }, a = (...l)=>r(i, n, ...l), u = (l = rE())=>{
        i = a(ZI([
            0
        ]), l), n = a(), l.length !== 0 && (i = a(ZI([
            1
        ]), l), n = a());
    }, f = ()=>{
        if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let l = 0;
        const p = [];
        for(; l < t;){
            n = a();
            const y = n.slice();
            p.push(y), l += n.length;
        }
        return Os(...p);
    };
    return (l, p)=>{
        s(), u(l);
        let y;
        for(; !(y = p(f()));)u();
        return s(), y;
    };
}
const rde = {
    bigint: (e)=>typeof e == "bigint",
    function: (e)=>typeof e == "function",
    boolean: (e)=>typeof e == "boolean",
    string: (e)=>typeof e == "string",
    isSafeInteger: (e)=>Number.isSafeInteger(e),
    array: (e)=>Array.isArray(e),
    field: (e, t)=>t.Fp.isValid(e),
    hash: (e)=>typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function qd(e, t, r = {}) {
    const n = (i, o, s)=>{
        const a = rde[o];
        if (typeof a != "function") throw new Error(`Invalid validator "${o}", expected function`);
        const u = e[i];
        if (!(s && u === void 0) && !a(u, e)) throw new Error(`Invalid param ${String(i)}=${u} (${typeof u}), expected ${o}`);
    };
    for (const [i, o] of Object.entries(t))n(i, o, !1);
    for (const [i, o] of Object.entries(r))n(i, o, !0);
    return e;
}
var nde = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    bitGet: ede,
    bitLen: Qle,
    bitMask: CS,
    bitSet: tde,
    bytesToHex: ud,
    bytesToNumberBE: fu,
    bytesToNumberLE: RS,
    concatBytes: Os,
    createHmacDrbg: pR,
    ensureBytes: cs,
    equalBytes: Jle,
    hexToBytes: fd,
    hexToNumber: MS,
    numberToBytesBE: Zl,
    numberToBytesLE: hR,
    numberToHexUnpadded: dR,
    numberToVarBytesBE: Xle,
    utf8ToBytes: g1,
    validateObject: qd
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const si = BigInt(0), Ln = BigInt(1), tf = BigInt(2), ide = BigInt(3), Ax = BigInt(4), YI = BigInt(5), XI = BigInt(8);
BigInt(9);
BigInt(16);
function Oi(e, t) {
    const r = e % t;
    return r >= si ? r : t + r;
}
function ode(e, t, r) {
    if (r <= si || t < si) throw new Error("Expected power/modulo > 0");
    if (r === Ln) return si;
    let n = Ln;
    for(; t > si;)t & Ln && (n = n * e % r), e = e * e % r, t >>= Ln;
    return n;
}
function es(e, t, r) {
    let n = e;
    for(; t-- > si;)n *= n, n %= r;
    return n;
}
function Tx(e, t) {
    if (e === si || t <= si) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
    let r = Oi(e, t), n = t, i = si, o = Ln;
    for(; r !== si;){
        const a = n / r, u = n % r, f = i - o * a;
        n = r, r = u, i = o, o = f;
    }
    if (n !== Ln) throw new Error("invert: does not exist");
    return Oi(i, t);
}
function sde(e) {
    const t = (e - Ln) / tf;
    let r, n, i;
    for(r = e - Ln, n = 0; r % tf === si; r /= tf, n++);
    for(i = tf; i < e && ode(i, t, e) !== e - Ln; i++);
    if (n === 1) {
        const s = (e + Ln) / Ax;
        return function(u, f) {
            const c = u.pow(f, s);
            if (!u.eql(u.sqr(c), f)) throw new Error("Cannot find square root");
            return c;
        };
    }
    const o = (r + Ln) / tf;
    return function(a, u) {
        if (a.pow(u, t) === a.neg(a.ONE)) throw new Error("Cannot find square root");
        let f = n, c = a.pow(a.mul(a.ONE, i), r), l = a.pow(u, o), p = a.pow(u, r);
        for(; !a.eql(p, a.ONE);){
            if (a.eql(p, a.ZERO)) return a.ZERO;
            let y = 1;
            for(let A = a.sqr(p); y < f && !a.eql(A, a.ONE); y++)A = a.sqr(A);
            const _ = a.pow(c, Ln << BigInt(f - y - 1));
            c = a.sqr(_), l = a.mul(l, _), p = a.mul(p, c), f = y;
        }
        return l;
    };
}
function ade(e) {
    if (e % Ax === ide) {
        const t = (e + Ln) / Ax;
        return function(n, i) {
            const o = n.pow(i, t);
            if (!n.eql(n.sqr(o), i)) throw new Error("Cannot find square root");
            return o;
        };
    }
    if (e % XI === YI) {
        const t = (e - YI) / XI;
        return function(n, i) {
            const o = n.mul(i, tf), s = n.pow(o, t), a = n.mul(i, s), u = n.mul(n.mul(a, tf), s), f = n.mul(a, n.sub(u, n.ONE));
            if (!n.eql(n.sqr(f), i)) throw new Error("Cannot find square root");
            return f;
        };
    }
    return sde(e);
}
const cde = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function gR(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }, r = cde.reduce((n, i)=>(n[i] = "function", n), t);
    return qd(e, r);
}
function ude(e, t, r) {
    if (r < si) throw new Error("Expected power > 0");
    if (r === si) return e.ONE;
    if (r === Ln) return t;
    let n = e.ONE, i = t;
    for(; r > si;)r & Ln && (n = e.mul(n, i)), i = e.sqr(i), r >>= Ln;
    return n;
}
function fde(e, t) {
    const r = new Array(t.length), n = t.reduce((o, s, a)=>e.is0(s) ? o : (r[a] = o, e.mul(o, s)), e.ONE), i = e.inv(n);
    return t.reduceRight((o, s, a)=>e.is0(s) ? o : (r[a] = e.mul(o, r[a]), e.mul(o, s)), i), r;
}
function US(e, t) {
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function yR(e, t, r = !1, n = {}) {
    if (e <= si) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
    const { nBitLength: i, nByteLength: o } = US(e, t);
    if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const s = ade(e), a = Object.freeze({
        ORDER: e,
        BITS: i,
        BYTES: o,
        MASK: CS(i),
        ZERO: si,
        ONE: Ln,
        create: (u)=>Oi(u, e),
        isValid: (u)=>{
            if (typeof u != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
            return si <= u && u < e;
        },
        is0: (u)=>u === si,
        isOdd: (u)=>(u & Ln) === Ln,
        neg: (u)=>Oi(-u, e),
        eql: (u, f)=>u === f,
        sqr: (u)=>Oi(u * u, e),
        add: (u, f)=>Oi(u + f, e),
        sub: (u, f)=>Oi(u - f, e),
        mul: (u, f)=>Oi(u * f, e),
        pow: (u, f)=>ude(a, u, f),
        div: (u, f)=>Oi(u * Tx(f, e), e),
        // Same as above, but doesn't normalize
        sqrN: (u)=>u * u,
        addN: (u, f)=>u + f,
        subN: (u, f)=>u - f,
        mulN: (u, f)=>u * f,
        inv: (u)=>Tx(u, e),
        sqrt: n.sqrt || ((u)=>s(a, u)),
        invertBatch: (u)=>fde(a, u),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (u, f, c)=>c ? f : u,
        toBytes: (u)=>r ? hR(u, o) : Zl(u, o),
        fromBytes: (u)=>{
            if (u.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${u.length}`);
            return r ? RS(u) : fu(u);
        }
    });
    return Object.freeze(a);
}
function lde(e, t, r = !1) {
    e = cs("privateHash", e);
    const n = e.length, i = US(t).nByteLength + 8;
    if (i < 24 || n < i || n > 1024) throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);
    const o = r ? RS(e) : fu(e);
    return Oi(o, t - Ln) + Ln;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const dde = BigInt(0), nE = BigInt(1);
function hde(e, t) {
    const r = (i, o)=>{
        const s = o.negate();
        return i ? s : o;
    }, n = (i)=>{
        const o = Math.ceil(t / i) + 1, s = 2 ** (i - 1);
        return {
            windows: o,
            windowSize: s
        };
    };
    return {
        constTimeNegate: r,
        // non-const time multiplication ladder
        unsafeLadder (i, o) {
            let s = e.ZERO, a = i;
            for(; o > dde;)o & nE && (s = s.add(a)), a = a.double(), o >>= nE;
            return s;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (i, o) {
            const { windows: s, windowSize: a } = n(o), u = [];
            let f = i, c = f;
            for(let l = 0; l < s; l++){
                c = f, u.push(c);
                for(let p = 1; p < a; p++)c = c.add(f), u.push(c);
                f = c.double();
            }
            return u;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (i, o, s) {
            const { windows: a, windowSize: u } = n(i);
            let f = e.ZERO, c = e.BASE;
            const l = BigInt(2 ** i - 1), p = 2 ** i, y = BigInt(i);
            for(let _ = 0; _ < a; _++){
                const A = _ * u;
                let O = Number(s & l);
                s >>= y, O > u && (O -= p, s += nE);
                const N = A, U = A + Math.abs(O) - 1, D = _ % 2 !== 0, H = O < 0;
                O === 0 ? c = c.add(r(D, o[N])) : f = f.add(r(H, o[U]));
            }
            return {
                p: f,
                f: c
            };
        },
        wNAFCached (i, o, s, a) {
            const u = i._WINDOW_SIZE || 1;
            let f = o.get(i);
            return f || (f = this.precomputeWindow(i, u), u !== 1 && o.set(i, a(f))), this.wNAF(u, f, s);
        }
    };
}
function mR(e) {
    return gR(e.Fp), qd(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...US(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function pde(e) {
    const t = mR(e);
    qd(t, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const { endo: r, Fp: n, a: i } = t;
    if (r) {
        if (!n.eql(i, n.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...t
    });
}
const { bytesToNumberBE: gde, hexToBytes: yde } = nde, ff = {
    // asn.1 DER encoding utils
    Err: class extends Error {
        constructor(t = ""){
            super(t);
        }
    },
    _parseInt (e) {
        const { Err: t } = ff;
        if (e.length < 2 || e[0] !== 2) throw new t("Invalid signature integer tag");
        const r = e[1], n = e.subarray(2, r + 2);
        if (!r || n.length !== r) throw new t("Invalid signature integer: wrong length");
        if (n[0] === 0 && n[1] <= 127) throw new t("Invalid signature integer: trailing length");
        return {
            d: gde(n),
            l: e.subarray(r + 2)
        };
    },
    toSig (e) {
        const { Err: t } = ff, r = typeof e == "string" ? yde(e) : e;
        if (!(r instanceof Uint8Array)) throw new Error("ui8a expected");
        let n = r.length;
        if (n < 2 || r[0] != 48) throw new t("Invalid signature tag");
        if (r[1] !== n - 2) throw new t("Invalid signature: incorrect length");
        const { d: i, l: o } = ff._parseInt(r.subarray(2)), { d: s, l: a } = ff._parseInt(o);
        if (a.length) throw new t("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s
        };
    },
    hexFromSig (e) {
        const t = (f)=>Number.parseInt(f[0], 16) >= 8 ? "00" + f : f, r = (f)=>{
            const c = f.toString(16);
            return c.length & 1 ? `0${c}` : c;
        }, n = t(r(e.s)), i = t(r(e.r)), o = n.length / 2, s = i.length / 2, a = r(o), u = r(s);
        return `30${r(s + o + 4)}02${u}${i}02${a}${n}`;
    }
}, Ps = BigInt(0), Zn = BigInt(1), Ka = BigInt(2), Mm = BigInt(3), JI = BigInt(4);
function mde(e) {
    const t = pde(e), { Fp: r } = t, n = t.toBytes || ((_, A, O)=>{
        const N = A.toAffine();
        return Os(Uint8Array.from([
            4
        ]), r.toBytes(N.x), r.toBytes(N.y));
    }), i = t.fromBytes || ((_)=>{
        const A = _.subarray(1), O = r.fromBytes(A.subarray(0, r.BYTES)), N = r.fromBytes(A.subarray(r.BYTES, 2 * r.BYTES));
        return {
            x: O,
            y: N
        };
    });
    function o(_) {
        const { a: A, b: O } = t, N = r.sqr(_), U = r.mul(N, _);
        return r.add(r.add(U, r.mul(_, A)), O);
    }
    function s(_) {
        return typeof _ == "bigint" && Ps < _ && _ < t.n;
    }
    function a(_) {
        if (!s(_)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function u(_) {
        const { allowedPrivateKeyLengths: A, nByteLength: O, wrapPrivateKey: N, n: U } = t;
        if (A && typeof _ != "bigint") {
            if (_ instanceof Uint8Array && (_ = ud(_)), typeof _ != "string" || !A.includes(_.length)) throw new Error("Invalid key");
            _ = _.padStart(O * 2, "0");
        }
        let D;
        try {
            D = typeof _ == "bigint" ? _ : fu(cs("private key", _, O));
        } catch  {
            throw new Error(`private key must be ${O} bytes, hex or bigint, not ${typeof _}`);
        }
        return N && (D = Oi(D, U)), a(D), D;
    }
    const f = /* @__PURE__ */ new Map();
    function c(_) {
        if (!(_ instanceof l)) throw new Error("ProjectivePoint expected");
    }
    class l {
        constructor(A, O, N){
            if (this.px = A, this.py = O, this.pz = N, A == null || !r.isValid(A)) throw new Error("x required");
            if (O == null || !r.isValid(O)) throw new Error("y required");
            if (N == null || !r.isValid(N)) throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(A) {
            const { x: O, y: N } = A || {};
            if (!A || !r.isValid(O) || !r.isValid(N)) throw new Error("invalid affine point");
            if (A instanceof l) throw new Error("projective point not allowed");
            const U = (D)=>r.eql(D, r.ZERO);
            return U(O) && U(N) ? l.ZERO : new l(O, N, r.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */ static normalizeZ(A) {
            const O = r.invertBatch(A.map((N)=>N.pz));
            return A.map((N, U)=>N.toAffine(O[U])).map(l.fromAffine);
        }
        /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */ static fromHex(A) {
            const O = l.fromAffine(i(cs("pointHex", A)));
            return O.assertValidity(), O;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(A) {
            return l.BASE.multiply(u(A));
        }
        // "Private method", don't use it directly
        _setWindowSize(A) {
            this._WINDOW_SIZE = A, f.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                if (t.allowInfinityPoint) return;
                throw new Error("bad point: ZERO");
            }
            const { x: A, y: O } = this.toAffine();
            if (!r.isValid(A) || !r.isValid(O)) throw new Error("bad point: x or y not FE");
            const N = r.sqr(O), U = o(A);
            if (!r.eql(N, U)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
            const { y: A } = this.toAffine();
            if (r.isOdd) return !r.isOdd(A);
            throw new Error("Field doesn't support isOdd");
        }
        /**
     * Compare one point to another.
     */ equals(A) {
            c(A);
            const { px: O, py: N, pz: U } = this, { px: D, py: H, pz: K } = A, re = r.eql(r.mul(O, K), r.mul(D, U)), Q = r.eql(r.mul(N, K), r.mul(H, U));
            return re && Q;
        }
        /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */ negate() {
            return new l(this.px, r.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: A, b: O } = t, N = r.mul(O, Mm), { px: U, py: D, pz: H } = this;
            let K = r.ZERO, re = r.ZERO, Q = r.ZERO, G = r.mul(U, U), R = r.mul(D, D), X = r.mul(H, H), $ = r.mul(U, D);
            return $ = r.add($, $), Q = r.mul(U, H), Q = r.add(Q, Q), K = r.mul(A, Q), re = r.mul(N, X), re = r.add(K, re), K = r.sub(R, re), re = r.add(R, re), re = r.mul(K, re), K = r.mul($, K), Q = r.mul(N, Q), X = r.mul(A, X), $ = r.sub(G, X), $ = r.mul(A, $), $ = r.add($, Q), Q = r.add(G, G), G = r.add(Q, G), G = r.add(G, X), G = r.mul(G, $), re = r.add(re, G), X = r.mul(D, H), X = r.add(X, X), G = r.mul(X, $), K = r.sub(K, G), Q = r.mul(X, R), Q = r.add(Q, Q), Q = r.add(Q, Q), new l(K, re, Q);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(A) {
            c(A);
            const { px: O, py: N, pz: U } = this, { px: D, py: H, pz: K } = A;
            let re = r.ZERO, Q = r.ZERO, G = r.ZERO;
            const R = t.a, X = r.mul(t.b, Mm);
            let $ = r.mul(O, D), S = r.mul(N, H), w = r.mul(U, K), g = r.add(O, N), m = r.add(D, H);
            g = r.mul(g, m), m = r.add($, S), g = r.sub(g, m), m = r.add(O, U);
            let E = r.add(D, K);
            return m = r.mul(m, E), E = r.add($, w), m = r.sub(m, E), E = r.add(N, U), re = r.add(H, K), E = r.mul(E, re), re = r.add(S, w), E = r.sub(E, re), G = r.mul(R, m), re = r.mul(X, w), G = r.add(re, G), re = r.sub(S, G), G = r.add(S, G), Q = r.mul(re, G), S = r.add($, $), S = r.add(S, $), w = r.mul(R, w), m = r.mul(X, m), S = r.add(S, w), w = r.sub($, w), w = r.mul(R, w), m = r.add(m, w), $ = r.mul(S, m), Q = r.add(Q, $), $ = r.mul(E, m), re = r.mul(g, re), re = r.sub(re, $), $ = r.mul(g, S), G = r.mul(E, G), G = r.add(G, $), new l(re, Q, G);
        }
        subtract(A) {
            return this.add(A.negate());
        }
        is0() {
            return this.equals(l.ZERO);
        }
        wNAF(A) {
            return y.wNAFCached(this, f, A, (O)=>{
                const N = r.invertBatch(O.map((U)=>U.pz));
                return O.map((U, D)=>U.toAffine(N[D])).map(l.fromAffine);
            });
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(A) {
            const O = l.ZERO;
            if (A === Ps) return O;
            if (a(A), A === Zn) return this;
            const { endo: N } = t;
            if (!N) return y.unsafeLadder(this, A);
            let { k1neg: U, k1: D, k2neg: H, k2: K } = N.splitScalar(A), re = O, Q = O, G = this;
            for(; D > Ps || K > Ps;)D & Zn && (re = re.add(G)), K & Zn && (Q = Q.add(G)), G = G.double(), D >>= Zn, K >>= Zn;
            return U && (re = re.negate()), H && (Q = Q.negate()), Q = new l(r.mul(Q.px, N.beta), Q.py, Q.pz), re.add(Q);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(A) {
            a(A);
            let O = A, N, U;
            const { endo: D } = t;
            if (D) {
                const { k1neg: H, k1: K, k2neg: re, k2: Q } = D.splitScalar(O);
                let { p: G, f: R } = this.wNAF(K), { p: X, f: $ } = this.wNAF(Q);
                G = y.constTimeNegate(H, G), X = y.constTimeNegate(re, X), X = new l(r.mul(X.px, D.beta), X.py, X.pz), N = G.add(X), U = R.add($);
            } else {
                const { p: H, f: K } = this.wNAF(O);
                N = H, U = K;
            }
            return l.normalizeZ([
                N,
                U
            ])[0];
        }
        /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */ multiplyAndAddUnsafe(A, O, N) {
            const U = l.BASE, D = (K, re)=>re === Ps || re === Zn || !K.equals(U) ? K.multiplyUnsafe(re) : K.multiply(re), H = D(this, O).add(D(A, N));
            return H.is0() ? void 0 : H;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(A) {
            const { px: O, py: N, pz: U } = this, D = this.is0();
            A == null && (A = D ? r.ONE : r.inv(U));
            const H = r.mul(O, A), K = r.mul(N, A), re = r.mul(U, A);
            if (D) return {
                x: r.ZERO,
                y: r.ZERO
            };
            if (!r.eql(re, r.ONE)) throw new Error("invZ was invalid");
            return {
                x: H,
                y: K
            };
        }
        isTorsionFree() {
            const { h: A, isTorsionFree: O } = t;
            if (A === Zn) return !0;
            if (O) return O(l, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: A, clearCofactor: O } = t;
            return A === Zn ? this : O ? O(l, this) : this.multiplyUnsafe(t.h);
        }
        toRawBytes(A = !0) {
            return this.assertValidity(), n(l, this, A);
        }
        toHex(A = !0) {
            return ud(this.toRawBytes(A));
        }
    }
    l.BASE = new l(t.Gx, t.Gy, r.ONE), l.ZERO = new l(r.ZERO, r.ONE, r.ZERO);
    const p = t.nBitLength, y = hde(l, t.endo ? Math.ceil(p / 2) : p);
    return {
        CURVE: t,
        ProjectivePoint: l,
        normPrivateKeyToScalar: u,
        weierstrassEquation: o,
        isWithinCurveOrder: s
    };
}
function bde(e) {
    const t = mR(e);
    return qd(t, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...t
    });
}
function wde(e) {
    const t = bde(e), { Fp: r, n } = t, i = r.BYTES + 1, o = 2 * r.BYTES + 1;
    function s(m) {
        return Ps < m && m < r.ORDER;
    }
    function a(m) {
        return Oi(m, n);
    }
    function u(m) {
        return Tx(m, n);
    }
    const { ProjectivePoint: f, normPrivateKeyToScalar: c, weierstrassEquation: l, isWithinCurveOrder: p } = mde({
        ...t,
        toBytes (m, E, T) {
            const I = E.toAffine(), P = r.toBytes(I.x), k = Os;
            return T ? k(Uint8Array.from([
                E.hasEvenY() ? 2 : 3
            ]), P) : k(Uint8Array.from([
                4
            ]), P, r.toBytes(I.y));
        },
        fromBytes (m) {
            const E = m.length, T = m[0], I = m.subarray(1);
            if (E === i && (T === 2 || T === 3)) {
                const P = fu(I);
                if (!s(P)) throw new Error("Point is not on curve");
                const k = l(P);
                let L = r.sqrt(k);
                const j = (L & Zn) === Zn;
                return (T & 1) === 1 !== j && (L = r.neg(L)), {
                    x: P,
                    y: L
                };
            } else if (E === o && T === 4) {
                const P = r.fromBytes(I.subarray(0, r.BYTES)), k = r.fromBytes(I.subarray(r.BYTES, 2 * r.BYTES));
                return {
                    x: P,
                    y: k
                };
            } else throw new Error(`Point of length ${E} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
        }
    }), y = (m)=>ud(Zl(m, t.nByteLength));
    function _(m) {
        const E = n >> Zn;
        return m > E;
    }
    function A(m) {
        return _(m) ? a(-m) : m;
    }
    const O = (m, E, T)=>fu(m.slice(E, T));
    class N {
        constructor(E, T, I){
            this.r = E, this.s = T, this.recovery = I, this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(E) {
            const T = t.nByteLength;
            return E = cs("compactSignature", E, T * 2), new N(O(E, 0, T), O(E, T, 2 * T));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(E) {
            const { r: T, s: I } = ff.toSig(cs("DER", E));
            return new N(T, I);
        }
        assertValidity() {
            if (!p(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!p(this.s)) throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(E) {
            return new N(this.r, this.s, E);
        }
        recoverPublicKey(E) {
            const { r: T, s: I, recovery: P } = this, k = Q(cs("msgHash", E));
            if (P == null || ![
                0,
                1,
                2,
                3
            ].includes(P)) throw new Error("recovery id invalid");
            const L = P === 2 || P === 3 ? T + t.n : T;
            if (L >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const j = P & 1 ? "03" : "02", ie = f.fromHex(j + y(L)), ue = u(L), ce = a(-k * ue), he = a(I * ue), ee = f.BASE.multiplyAndAddUnsafe(ie, ce, he);
            if (!ee) throw new Error("point at infinify");
            return ee.assertValidity(), ee;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return _(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new N(this.r, a(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return fd(this.toDERHex());
        }
        toDERHex() {
            return ff.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return fd(this.toCompactHex());
        }
        toCompactHex() {
            return y(this.r) + y(this.s);
        }
    }
    const U = {
        isValidPrivateKey (m) {
            try {
                return c(m), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: c,
        /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */ randomPrivateKey: ()=>{
            const m = t.randomBytes(r.BYTES + 8), E = lde(m, n);
            return Zl(E, t.nByteLength);
        },
        /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */ precompute (m = 8, E = f.BASE) {
            return E._setWindowSize(m), E.multiply(BigInt(3)), E;
        }
    };
    function D(m, E = !0) {
        return f.fromPrivateKey(m).toRawBytes(E);
    }
    function H(m) {
        const E = m instanceof Uint8Array, T = typeof m == "string", I = (E || T) && m.length;
        return E ? I === i || I === o : T ? I === 2 * i || I === 2 * o : m instanceof f;
    }
    function K(m, E, T = !0) {
        if (H(m)) throw new Error("first arg must be private key");
        if (!H(E)) throw new Error("second arg must be public key");
        return f.fromHex(E).multiply(c(m)).toRawBytes(T);
    }
    const re = t.bits2int || function(m) {
        const E = fu(m), T = m.length * 8 - t.nBitLength;
        return T > 0 ? E >> BigInt(T) : E;
    }, Q = t.bits2int_modN || function(m) {
        return a(re(m));
    }, G = CS(t.nBitLength);
    function R(m) {
        if (typeof m != "bigint") throw new Error("bigint expected");
        if (!(Ps <= m && m < G)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
        return Zl(m, t.nByteLength);
    }
    function X(m, E, T = $) {
        if ([
            "recovered",
            "canonical"
        ].some((ye)=>ye in T)) throw new Error("sign() legacy options not supported");
        const { hash: I, randomBytes: P } = t;
        let { lowS: k, prehash: L, extraEntropy: j } = T;
        k == null && (k = !0), m = cs("msgHash", m), L && (m = cs("prehashed msgHash", I(m)));
        const ie = Q(m), ue = c(E), ce = [
            R(ue),
            R(ie)
        ];
        if (j != null) {
            const ye = j === !0 ? P(r.BYTES) : j;
            ce.push(cs("extraEntropy", ye, r.BYTES));
        }
        const he = Os(...ce), ee = ie;
        function ae(ye) {
            const Se = re(ye);
            if (!p(Se)) return;
            const De = u(Se), Re = f.BASE.multiply(Se).toAffine(), Ce = a(Re.x);
            if (Ce === Ps) return;
            const M = a(De * a(ee + Ce * ue));
            if (M === Ps) return;
            let z = (Re.x === Ce ? 0 : 2) | Number(Re.y & Zn), de = M;
            return k && _(M) && (de = A(M), z ^= 1), new N(Ce, de, z);
        }
        return {
            seed: he,
            k2sig: ae
        };
    }
    const $ = {
        lowS: t.lowS,
        prehash: !1
    }, S = {
        lowS: t.lowS,
        prehash: !1
    };
    function w(m, E, T = $) {
        const { seed: I, k2sig: P } = X(m, E, T);
        return pR(t.hash.outputLen, t.nByteLength, t.hmac)(I, P);
    }
    f.BASE._setWindowSize(8);
    function g(m, E, T, I = S) {
        var Re;
        const P = m;
        if (E = cs("msgHash", E), T = cs("publicKey", T), "strict" in I) throw new Error("options.strict was renamed to lowS");
        const { lowS: k, prehash: L } = I;
        let j, ie;
        try {
            if (typeof P == "string" || P instanceof Uint8Array) try {
                j = N.fromDER(P);
            } catch (Ce) {
                if (!(Ce instanceof ff.Err)) throw Ce;
                j = N.fromCompact(P);
            }
            else if (typeof P == "object" && typeof P.r == "bigint" && typeof P.s == "bigint") {
                const { r: Ce, s: M } = P;
                j = new N(Ce, M);
            } else throw new Error("PARSE");
            ie = f.fromHex(T);
        } catch (Ce) {
            if (Ce.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1;
        }
        if (k && j.hasHighS()) return !1;
        L && (E = t.hash(E));
        const { r: ue, s: ce } = j, he = Q(E), ee = u(ce), ae = a(he * ee), ye = a(ue * ee), Se = (Re = f.BASE.multiplyAndAddUnsafe(ie, ae, ye)) == null ? void 0 : Re.toAffine();
        return Se ? a(Se.x) === ue : !1;
    }
    return {
        CURVE: t,
        getPublicKey: D,
        getSharedSecret: K,
        sign: w,
        verify: g,
        ProjectivePoint: f,
        Signature: N,
        utils: U
    };
}
function vde(e, t) {
    const r = e.ORDER;
    let n = Ps;
    for(let p = r - Zn; p % Ka === Ps; p /= Ka)n += Zn;
    const i = n, o = (r - Zn) / Ka ** i, s = (o - Zn) / Ka, a = Ka ** i - Zn, u = Ka ** (i - Zn), f = e.pow(t, o), c = e.pow(t, (o + Zn) / Ka);
    let l = (p, y)=>{
        let _ = f, A = e.pow(y, a), O = e.sqr(A);
        O = e.mul(O, y);
        let N = e.mul(p, O);
        N = e.pow(N, s), N = e.mul(N, A), A = e.mul(N, y), O = e.mul(N, p);
        let U = e.mul(O, A);
        N = e.pow(U, u);
        let D = e.eql(N, e.ONE);
        A = e.mul(O, c), N = e.mul(U, _), O = e.cmov(A, O, D), U = e.cmov(N, U, D);
        for(let H = i; H > 1; H--){
            let K = Ka ** (H - Ka), re = e.pow(U, K);
            const Q = e.eql(re, e.ONE);
            A = e.mul(O, _), _ = e.mul(_, _), re = e.mul(U, _), O = e.cmov(A, O, Q), U = e.cmov(re, U, Q);
        }
        return {
            isValid: D,
            value: O
        };
    };
    if (e.ORDER % JI === Mm) {
        const p = (e.ORDER - Mm) / JI, y = e.sqrt(e.neg(t));
        l = (_, A)=>{
            let O = e.sqr(A);
            const N = e.mul(_, A);
            O = e.mul(O, N);
            let U = e.pow(O, p);
            U = e.mul(U, N);
            const D = e.mul(U, y), H = e.mul(e.sqr(U), A), K = e.eql(H, _);
            let re = e.cmov(D, U, K);
            return {
                isValid: K,
                value: re
            };
        };
    }
    return l;
}
function _de(e, t) {
    if (gR(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r = vde(e, t.Z);
    if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n)=>{
        let i, o, s, a, u, f, c, l;
        i = e.sqr(n), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), s = e.add(o, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), a = e.mul(a, t.A), o = e.sqr(s), f = e.sqr(a), u = e.mul(f, t.A), o = e.add(o, u), o = e.mul(o, s), f = e.mul(f, a), u = e.mul(f, t.B), o = e.add(o, u), c = e.mul(i, s);
        const { isValid: p, value: y } = r(o, f);
        l = e.mul(i, n), l = e.mul(l, y), c = e.cmov(c, s, p), l = e.cmov(l, y, p);
        const _ = e.isOdd(n) === e.isOdd(l);
        return l = e.cmov(e.neg(l), l, _), c = e.div(c, a), {
            x: c,
            y: l
        };
    };
}
function Ede(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return g1(e);
    throw new Error("DST must be Uint8Array or string");
}
const xde = fu;
function ou(e, t) {
    if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
    const r = Array.from({
        length: t
    }).fill(0);
    for(let n = t - 1; n >= 0; n--)r[n] = e & 255, e >>>= 8;
    return new Uint8Array(r);
}
function Sde(e, t) {
    const r = new Uint8Array(e.length);
    for(let n = 0; n < e.length; n++)r[n] = e[n] ^ t[n];
    return r;
}
function bp(e) {
    if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
function $S(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function Ade(e, t, r, n) {
    bp(e), bp(t), $S(r), t.length > 255 && (t = n(Os(g1("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i, blockLen: o } = n, s = Math.ceil(r / i);
    if (s > 255) throw new Error("Invalid xmd length");
    const a = Os(t, ou(t.length, 1)), u = ou(0, o), f = ou(r, 2), c = new Array(s), l = n(Os(u, e, f, ou(0, 1), a));
    c[0] = n(Os(l, ou(1, 1), a));
    for(let y = 1; y <= s; y++){
        const _ = [
            Sde(l, c[y - 1]),
            ou(y + 1, 1),
            a
        ];
        c[y] = n(Os(..._));
    }
    return Os(...c).slice(0, r);
}
function Tde(e, t, r, n, i) {
    if (bp(e), bp(t), $S(r), t.length > 255) {
        const o = Math.ceil(2 * n / 8);
        t = i.create({
            dkLen: o
        }).update(g1("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (r > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i.create({
        dkLen: r
    }).update(e).update(ou(r, 2)).update(t).update(ou(t.length, 1)).digest();
}
function QI(e, t, r) {
    qd(r, {
        DST: "string",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p: n, k: i, m: o, hash: s, expand: a, DST: u } = r;
    bp(e), $S(t);
    const f = Ede(u), c = n.toString(2).length, l = Math.ceil((c + i) / 8), p = t * o * l;
    let y;
    if (a === "xmd") y = Ade(e, f, p, s);
    else if (a === "xof") y = Tde(e, f, p, i, s);
    else if (a === void 0) y = e;
    else throw new Error('expand must be "xmd", "xof" or undefined');
    const _ = new Array(t);
    for(let A = 0; A < t; A++){
        const O = new Array(o);
        for(let N = 0; N < o; N++){
            const U = l * (N + A * o), D = y.subarray(U, U + l);
            O[N] = Oi(xde(D), n);
        }
        _[A] = O;
    }
    return _;
}
function kde(e, t) {
    const r = t.map((n)=>Array.from(n).reverse());
    return (n, i)=>{
        const [o, s, a, u] = r.map((f)=>f.reduce((c, l)=>e.add(e.mul(c, n), l)));
        return n = e.div(o, s), i = e.mul(i, e.div(a, u)), {
            x: n,
            y: i
        };
    };
}
function Ide(e, t, r) {
    if (typeof t != "function") throw new Error("mapToCurve() must be defined");
    return {
        // Encodes byte string to elliptic curve
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        hashToCurve (n, i) {
            const o = QI(n, 2, {
                ...r,
                DST: r.DST,
                ...i
            }), s = e.fromAffine(t(o[0])), a = e.fromAffine(t(o[1])), u = s.add(a).clearCofactor();
            return u.assertValidity(), u;
        },
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        encodeToCurve (n, i) {
            const o = QI(n, 1, {
                ...r,
                DST: r.encodeDST,
                ...i
            }), s = e.fromAffine(t(o[0])).clearCofactor();
            return s.assertValidity(), s;
        }
    };
}
let bR = class extends cR {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, uf.hash(t);
        const n = PS(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen, o = new Uint8Array(i);
        o.set(n.length > i ? t.create().update(n).digest() : n);
        for(let s = 0; s < o.length; s++)o[s] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let s = 0; s < o.length; s++)o[s] ^= 106;
        this.oHash.update(o), o.fill(0);
    }
    update(t) {
        return uf.exists(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        uf.exists(this), uf.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const wR = (e, t, r)=>new bR(e, t).update(r).digest();
wR.create = (e, t)=>new bR(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Bde(e) {
    return {
        hash: e,
        hmac: (t, ...r)=>wR(e, t, Fle(...r)),
        randomBytes: zle
    };
}
function Ode(e, t) {
    const r = (n)=>wde({
            ...e,
            ...Bde(n)
        });
    return Object.freeze({
        ...r(t),
        create: r
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const vR = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), eB = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Pde = BigInt(1), kx = BigInt(2), tB = (e, t)=>(e + t / kx) / t;
function Nde(e) {
    const t = vR, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), u = BigInt(88), f = e * e * e % t, c = f * f * e % t, l = es(c, r, t) * c % t, p = es(l, r, t) * c % t, y = es(p, kx, t) * f % t, _ = es(y, i, t) * y % t, A = es(_, o, t) * _ % t, O = es(A, a, t) * A % t, N = es(O, u, t) * O % t, U = es(N, a, t) * A % t, D = es(U, r, t) * c % t, H = es(D, s, t) * _ % t, K = es(H, n, t) * f % t, re = es(K, kx, t);
    if (!bu.eql(bu.sqr(re), e)) throw new Error("Cannot find square root");
    return re;
}
const bu = yR(vR, void 0, void 0, {
    sqrt: Nde
}), wu = Ode({
    a: BigInt(0),
    b: BigInt(7),
    Fp: bu,
    n: eB,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */ endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (e)=>{
            const t = eB, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Pde * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = BigInt("0x100000000000000000000000000000000"), a = tB(o * e, t), u = tB(-n * e, t);
            let f = Oi(e - a * r - u * i, t), c = Oi(-a * n - u * o, t);
            const l = f > s, p = c > s;
            if (l && (f = t - f), p && (c = t - c), f > s || c > s) throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: l,
                k1: f,
                k2neg: p,
                k2: c
            };
        }
    }
}, lR);
BigInt(0);
wu.ProjectivePoint;
wu.utils.randomPrivateKey;
const Mde = kde(bu, [
    // xNum
    [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    // yNum
    [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
].map((e)=>e.map((t)=>BigInt(t)))), Rde = _de(bu, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: bu.create(BigInt("-11"))
});
Ide(wu.ProjectivePoint, (e)=>{
    const { x: t, y: r } = Rde(bu.create(e[0]));
    return Mde(t, r);
}, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: bu.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: lR
});
function Ix(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Cde(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function _R(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Ude(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Ix(e.outputLen), Ix(e.blockLen);
}
function $de(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function Lde(e, t) {
    _R(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Dde = {
    number: Ix,
    bool: Cde,
    bytes: _R,
    hash: Ude,
    exists: $de,
    output: Lde
};
var iE = Dde;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const oE = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ia = (e, t)=>e << 32 - t | e >>> t, Fde = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!Fde) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function zde(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function ER(e) {
    if (typeof e == "string" && (e = zde(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
let jde = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function xR(e) {
    const t = (n)=>e().update(ER(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function Hde(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let qde = class extends jde {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = oE(this.buffer);
    }
    update(t) {
        iE.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = ER(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = oE(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        iE.exists(this), iE.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        Hde(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = oE(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const Kde = (e, t, r)=>e & t ^ ~e & r, Wde = (e, t, r)=>e & t ^ e & r ^ t & r, Vde = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), qc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Kc = new Uint32Array(64);
let SR = class extends qde {
    constructor(){
        super(64, 32, 8, !1), this.A = qc[0] | 0, this.B = qc[1] | 0, this.C = qc[2] | 0, this.D = qc[3] | 0, this.E = qc[4] | 0, this.F = qc[5] | 0, this.G = qc[6] | 0, this.H = qc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Kc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Kc[l - 15], y = Kc[l - 2], _ = ia(p, 7) ^ ia(p, 18) ^ p >>> 3, A = ia(y, 17) ^ ia(y, 19) ^ y >>> 10;
            Kc[l] = A + Kc[l - 7] + _ + Kc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = ia(a, 6) ^ ia(a, 11) ^ ia(a, 25), y = c + p + Kde(a, u, f) + Vde[l] + Kc[l] | 0, A = (ia(n, 2) ^ ia(n, 13) ^ ia(n, 22)) + Wde(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Kc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Gde = class extends SR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const Bx = xR(()=>new SR());
xR(()=>new Gde());
function Zde(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Yde(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Xde(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Jde } = crypto ?? globalThis.crypto ?? window.crypto;
function Qde(e = 32) {
    if (typeof Jde == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function ehe(e, t, r = "be") {
    t === void 0 && (t = e.length), Zde(e, t);
    const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
    return n.set(e, i), n;
}
function AR(e) {
    let t, r = 0;
    const n = e.reduce((o, s)=>o + s.length, 0), i = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i.set(o, r), r += o.length;
    }
    return i;
}
const the = new TextEncoder(), rhe = [
    {
        name: "base58",
        charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }
];
function TR(e) {
    for (const t of rhe)if (t.name === e) return t.charset;
    throw TypeError("Charset does not exist: " + e);
}
function nhe(e, t, r = !1) {
    typeof e == "string" && (e = the.encode(e));
    const n = TR(t), i = n.length, o = [];
    let s = "", a, u = 0, f, c;
    for(a = 0; a < e.length; a++)for(u = 0, f = e[a], s += f > 0 || (s.length ^ a) > 0 ? "" : "1"; u in o || f > 0;)c = o[u], c = c > 0 ? c * 256 + f : f, f = c / i | 0, o[u] = c % i, u++;
    for(; u-- > 0;)s += n[o[u]];
    return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function ihe(e, t) {
    const r = TR(t), n = r.length, i = [], o = [];
    e = e.replace("=", "");
    let s, a = 0, u, f;
    for(s = 0; s < e.length; s++){
        if (a = 0, u = r.indexOf(e[s]), u < 0) throw new Error(`Character range out of bounds: ${u}`);
        for(u > 0 || (o.length ^ s) > 0 || o.push(0); a in i || u > 0;)f = i[a], f = f > 0 ? f * n + u : u, u = f >> 8, i[a] = f % 256, a++;
    }
    for(; a-- > 0;)o.push(i[a]);
    return new Uint8Array(o);
}
function kR(e) {
    return Bx(Bx(e));
}
function ohe(e) {
    const t = kR(e);
    return AR([
        e,
        t.slice(0, 4)
    ]);
}
function she(e) {
    const t = e.slice(0, -4), r = e.slice(-4);
    if (kR(t).slice(0, 4).toString() !== r.toString()) throw new Error("Invalid checksum!");
    return t;
}
const rB = {
    encode: nhe,
    decode: ihe
}, IR = {
    encode: (e)=>{
        const t = ohe(e);
        return rB.encode(t, "base58");
    },
    decode: (e)=>{
        const t = rB.decode(e, "base58");
        return she(t);
    }
}, BR = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ahe = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
], Rm = [
    {
        version: 0,
        name: "bech32",
        const: 1
    },
    {
        version: 1,
        name: "bech32m",
        const: 734539939
    }
];
function OR(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = t >> 25;
        t = (t & 33554431) << 5 ^ e[r];
        for(let i = 0; i < 5; ++i)n >> i & 1 && (t ^= ahe[i]);
    }
    return t;
}
function PR(e) {
    const t = [];
    let r;
    for(r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) >> 5);
    for(t.push(0), r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) & 31);
    return t;
}
function che(e, t, r) {
    const n = PR(e).concat(t);
    return OR(n) === r.const;
}
function uhe(e, t, r) {
    const n = PR(e).concat(t).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ]), i = OR(n) ^ r.const, o = [];
    for(let s = 0; s < 6; ++s)o.push(i >> 5 * (5 - s) & 31);
    return o;
}
function NR(e, t, r, n = !0) {
    const i = [];
    let o = 0, s = 0;
    const a = (1 << r) - 1, u = (1 << t + r - 1) - 1;
    for (const f of e){
        if (f < 0 || f >> t > 0) throw new Error("Failed to perform base conversion. Invalid value: " + String(f));
        for(o = (o << t | f) & u, s += t; s >= r;)s -= r, i.push(o >> s & a);
    }
    if (n) s > 0 && i.push(o << r - s & a);
    else if (s >= t || (o << r - s & a) > 0) throw new Error("Failed to perform base conversion. Invalid Size!");
    return i;
}
function fhe(e, t, r) {
    const n = t.concat(uhe(e, t, r));
    let i = e + "1";
    for(let o = 0; o < n.length; ++o)i += BR.charAt(n[o]);
    return i;
}
function MR(e) {
    if (!lhe(e)) throw new Error("Encoded string goes out of bounds!");
    if (e = e.toLowerCase(), !dhe(e)) throw new Error("Encoded string has invalid separator!");
    const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
    for(let o = r + 1; o < e.length; ++o){
        const s = BR.indexOf(e.charAt(o));
        if (s === -1) throw new Error("Character idx out of bounds: " + String(o));
        t.push(s);
    }
    const i = Rm.find((o)=>o.version === t[0]) ?? Rm[0];
    if (!che(n, t, i)) throw new Error("Checksum verification failed!");
    return [
        n,
        t.slice(0, t.length - 6)
    ];
}
function lhe(e) {
    let t, r, n = !1, i = !1;
    for(t = 0; t < e.length; ++t){
        if (r = e.charCodeAt(t), r < 33 || r > 126) return !1;
        r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i = !0);
    }
    return !(n && i);
}
function dhe(e) {
    const t = e.lastIndexOf("1");
    return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function hhe(e, t = "bc", r = 0) {
    const n = [
        r,
        ...NR([
            ...e
        ], 8, 5)
    ], i = Rm.find((s)=>s.version === r) ?? Rm[0], o = fhe(t, n, i);
    return RR(o), o;
}
function RR(e) {
    e = e.toLowerCase();
    const t = e.split("1", 1)[0], [r, n] = MR(e), i = NR(n.slice(1), 5, 8, !1), o = i.length;
    switch(!0){
        case t !== r:
            throw new Error("Returned hrp string is invalid.");
        case i === null || o < 2 || o > 40:
            throw new Error("Decoded string is invalid or out of spec.");
        case n[0] > 16:
            throw new Error("Returned version bit is out of range.");
        default:
            return Uint8Array.from(i);
    }
}
function phe(e) {
    e = e.toLowerCase();
    const [t, r] = MR(e);
    return r[0];
}
const CR = {
    encode: hhe,
    decode: RR,
    version: phe
}, UR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $R = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", ghe = new TextEncoder();
function LR(e, t = !1, r = !0) {
    typeof e == "string" && (e = ghe.encode(e));
    const n = t ? $R : UR;
    let i = "", o = 0, s = 0;
    for(let a = 0; a < e.length; a++)for(s = s << 8 | e[a], o += 8; o >= 6;)o -= 6, i += n[s >> o & 63];
    if (o > 0) for(s <<= 6 - o, i += n[s & 63]; o < 6;)i += r ? "=" : "", o += 2;
    return i;
}
function DR(e, t = !1) {
    const r = t || e.includes("-") || e.includes("_") ? $R.split("") : UR.split("");
    e = e.replace(/=+$/, "");
    const n = e.split("");
    let i = 0, o = 0;
    const s = [];
    for(let a = 0; a < n.length; a++){
        const u = n[a], f = r.indexOf(u);
        if (f === -1) throw new Error("Invalid character: " + u);
        i += 6, o <<= 6, o |= f, i >= 8 && (i -= 8, s.push(o >>> i & 255));
    }
    return new Uint8Array(s);
}
const FR = {
    encode: LR,
    decode: DR
}, zR = {
    encode: (e)=>LR(e, !0, !1),
    decode: (e)=>DR(e, !0)
}, yhe = BigInt(0), mhe = BigInt(255), jR = BigInt(256);
function bhe(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function whe(e, t, r = "be") {
    t === void 0 && (t = bhe(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > yhe;){
        const a = e & mhe, u = Number(a);
        n ? o.setUint8(s++, u) : o.setUint8(s--, u), e = (e - a) / jR;
    }
    return new Uint8Array(i);
}
function vhe(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * jR + BigInt(e[r]);
    return BigInt(t);
}
function _he(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i = 0; n < t.length; n += 8, i++){
        let o = 0;
        for(let s = 0; s < 8; s++)o |= t[n + s] << 7 - s;
        r[i] = o;
    }
    return r;
}
function Ehe(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i = 7; i >= 0; i--, r++)t[r] = n >> i & 1;
    }
    return t.join("");
}
function xhe(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function She(e, t, r = "be") {
    t === void 0 && (t = xhe(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > 0;){
        const a = e & 255;
        n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
    }
    return new Uint8Array(i);
}
function Ahe(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], Xde(t);
    return t;
}
const The = new TextEncoder(), khe = new TextDecoder();
function LS(e) {
    return The.encode(e);
}
function sE(e) {
    return khe.decode(e);
}
function Ihe(e, t) {
    Yde(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function Bhe(e, t, r = "le") {
    t = Ihe(e, t);
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(let a = 0; a < e.length; a += 2){
        const u = e.substring(a, a + 2), f = parseInt(u, 16);
        n ? o.setUint8(s++, f) : o.setUint8(s--, f);
    }
    return new Uint8Array(i);
}
function Ohe(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
function Phe(e) {
    const t = JSON.stringify(e, (r, n)=>typeof n == "bigint" ? `${n}n` : n);
    return LS(t);
}
function Nhe(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return ehe(e, t, r);
    if (typeof e == "string") return Bhe(e, t, r);
    if (typeof e == "bigint") return whe(e, t, r);
    if (typeof e == "number") return She(e, t, r);
    if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    throw TypeError("Unsupported format:" + typeof e);
}
const kr = class kr extends Uint8Array {
    static random(t = 32) {
        const r = Qde(t);
        return new kr(r, t);
    }
    constructor(t, r, n){
        const i = Nhe(t, r, n);
        super(i);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new Khe(this);
    }
    toNum(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Ahe(r);
    }
    toBin() {
        return Ehe(this);
    }
    toBig(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return vhe(r);
    }
    toHash() {
        const t = Bx(this);
        return new kr(t);
    }
    toJson() {
        const t = sE(this);
        return JSON.parse(t);
    }
    toBech32(t, r = 0) {
        return CR.encode(this, t, r);
    }
    toStr() {
        return sE(this);
    }
    toHex() {
        return Ohe(this);
    }
    toBytes() {
        return new Uint8Array(this);
    }
    tob58chk() {
        return IR.encode(this);
    }
    toBase64() {
        return FR.encode(this);
    }
    toB64url() {
        return zR.encode(this);
    }
    prepend(t) {
        return kr.join([
            kr.bytes(t),
            this
        ]);
    }
    append(t) {
        return kr.join([
            this,
            kr.bytes(t)
        ]);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new kr(n);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new kr(n);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new kr(t);
    }
    write(t, r) {
        const n = kr.bytes(t);
        this.set(n, r);
    }
    prefixSize(t) {
        const r = kr.varInt(this.length, t);
        return kr.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new kr(Uint8Array.from(t));
    }
    static of(...t) {
        return new kr(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i)=>kr.bytes(i)), n = AR(r);
        return new kr(n);
    }
    static varInt(t, r) {
        if (t < 253) return kr.num(t, 1);
        if (t < 65536) return kr.of(253, ...kr.num(t, 2, r));
        if (t < 4294967296) return kr.of(254, ...kr.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return kr.of(255, ...kr.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
};
kr.num = Mhe, kr.big = Che, kr.bin = Rhe, kr.raw = Uhe, kr.str = $he, kr.hex = Lhe, kr.bytes = Dhe, kr.json = Fhe, kr.base64 = zhe, kr.b64url = jhe, kr.bech32 = Hhe, kr.b58chk = qhe, kr.encode = LS, kr.decode = sE;
let ir = kr;
function Mhe(e, t, r) {
    return new ir(e, t, r);
}
function Rhe(e, t, r) {
    return new ir(_he(e), t, r);
}
function Che(e, t, r) {
    return new ir(e, t, r);
}
function Uhe(e, t, r) {
    return new ir(e, t, r);
}
function $he(e, t, r) {
    return new ir(LS(e), t, r);
}
function Lhe(e, t, r) {
    return new ir(e, t, r);
}
function Dhe(e, t, r) {
    return new ir(e, t, r);
}
function Fhe(e) {
    return new ir(Phe(e));
}
function zhe(e) {
    return new ir(FR.decode(e));
}
function jhe(e) {
    return new ir(zR.decode(e));
}
function Hhe(e) {
    return new ir(CR.decode(e));
}
function qhe(e) {
    return new ir(IR.decode(e));
}
class Khe {
    constructor(t){
        this.data = ir.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new ir(this.data.slice(0, t));
    }
    read(t) {
        t = t ?? this.readSize();
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    readSize(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).toNum(t);
            case r === 254:
                return this.read(4).toNum(t);
            case r === 255:
                return this.read(8).toNum(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
}
const Cm = wu.CURVE, DS = Cm.n, Whe = Cm.p, Vhe = {
    x: Cm.Gx,
    y: Cm.Gy
}, Ghe = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const Ox = {
    N: DS,
    P: Whe,
    G: Vhe,
    _0n: Ghe
}, bh = yR(DS, 32, !0), HR = (e)=>Oi(e, DS);
function FS(e, t = !1) {
    if (t) throw new Error(e);
    return !1;
}
function qR(e) {
    return ir.random(e);
}
function Zhe(e) {
    const t = ir.bytes(e).big;
    return ir.big(HR(t), 32);
}
var Yhe = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fail: FS,
    mod_bytes: Zhe,
    random: qR
});
const { N: Xhe, _0n: Jhe } = Ox;
function Qhe(e, t, r) {
    const n = ir.bytes(e);
    return n.length !== t ? FS(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function epe(e, t) {
    return typeof e == "bigint" && Jhe < e && e < Xhe || FS("x value is not in the field!", t), !0;
}
const nB = wu.ProjectivePoint, Un = class Un extends Uint8Array {
    static mod(t) {
        return new Un(t);
    }
    static is_valid(t, r) {
        const n = ir.bytes(t, 32).big;
        return epe(n, r);
    }
    constructor(t){
        let r = tpe(t);
        r = HR(r), Un.is_valid(r, !0), super(ir.big(r, 32), 32);
    }
    get buff() {
        return new ir(this);
    }
    get raw() {
        return this.buff.raw;
    }
    get big() {
        return this.buff.big;
    }
    get hex() {
        return this.buff.hex;
    }
    get point() {
        return this.generate();
    }
    get hasOddY() {
        return this.point.hasOddY;
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    gt(t) {
        return new Un(t).big > this.big;
    }
    lt(t) {
        return new Un(t).big < this.big;
    }
    eq(t) {
        return new Un(t).big === this.big;
    }
    ne(t) {
        return new Un(t).big !== this.big;
    }
    add(t) {
        const r = Un.mod(t), n = bh.add(this.big, r.big);
        return new Un(n);
    }
    sub(t) {
        const r = Un.mod(t), n = bh.sub(this.big, r.big);
        return new Un(n);
    }
    mul(t) {
        const r = Un.mod(t), n = bh.mul(this.big, r.big);
        return new Un(n);
    }
    pow(t) {
        const r = Un.mod(t), n = bh.pow(this.big, r.big);
        return new Un(n);
    }
    div(t) {
        const r = Un.mod(t), n = bh.div(this.big, r.big);
        return new Un(n);
    }
    negate() {
        return new Un(Un.N - this.big);
    }
    generate() {
        const r = wu.ProjectivePoint.BASE.multiply(this.big);
        return fc.import(r);
    }
};
Un.N = wu.CURVE.n;
let yi = Un;
const mn = class mn {
    static from_x(t) {
        let r = rpe(t);
        r.length === 32 && (r = r.prepend(2)), Qhe(r, 33);
        const n = nB.fromHex(r.hex);
        return n.assertValidity(), new mn(n.x, n.y);
    }
    static generate(t) {
        const r = yi.mod(t), n = mn.base.multiply(r.big);
        return mn.import(n);
    }
    static import(t) {
        const r = t instanceof mn ? {
            x: t.x.big,
            y: t.y.big
        } : {
            x: t.x,
            y: t.y
        };
        return new mn(r.x, r.y);
    }
    constructor(t, r){
        this._p = new nB(t, r, 1n), this.p.assertValidity();
    }
    get p() {
        return this._p;
    }
    get x() {
        return ir.big(this.p.x, 32);
    }
    get y() {
        return ir.big(this.p.y, 32);
    }
    get buff() {
        return ir.raw(this.p.toRawBytes(!0));
    }
    get raw() {
        return this.buff.raw;
    }
    get hex() {
        return this.buff.hex;
    }
    get hasEvenY() {
        return this.p.hasEvenY();
    }
    get hasOddY() {
        return !this.p.hasEvenY();
    }
    eq(t) {
        const r = t instanceof mn ? t : mn.from_x(t);
        return this.x.big === r.x.big && this.y.big === r.y.big;
    }
    add(t) {
        return t instanceof mn ? mn.import(this.p.add(t.p)) : mn.import(this.p.add(mn.generate(t).p));
    }
    sub(t) {
        return t instanceof mn ? mn.import(this.p.subtract(t.p)) : mn.import(this.p.subtract(mn.generate(t).p));
    }
    mul(t) {
        return t instanceof mn ? mn.import(this.p.multiply(t.x.big)) : mn.import(this.p.multiply(yi.mod(t).big));
    }
    negate() {
        return mn.import(this.p.negate());
    }
};
mn.P = Ox.P, mn.G = Ox.G, mn.base = wu.ProjectivePoint.BASE;
let fc = mn;
function tpe(e) {
    if (e instanceof yi) return e.big;
    if (e instanceof fc) return e.x.big;
    if (e instanceof Uint8Array) return ir.raw(e).big;
    if (typeof e == "string") return ir.hex(e).big;
    if (typeof e == "number") return ir.num(e).big;
    if (typeof e == "bigint") return BigInt(e);
    throw TypeError("Invalid input type:" + typeof e);
}
function rpe(e) {
    if (e instanceof yi) return e.point.buff;
    if (e instanceof fc) return e.buff;
    if (e instanceof Uint8Array || typeof e == "string") return ir.bytes(e);
    if (typeof e == "number" || typeof e == "bigint") return ir.bytes(e, 32);
    throw new TypeError(`Unknown type: ${typeof e}`);
}
function Px(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function npe(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function KR(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function ipe(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Px(e.outputLen), Px(e.blockLen);
}
function ope(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function spe(e, t) {
    KR(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const ape = {
    number: Px,
    bool: npe,
    bytes: KR,
    hash: ipe,
    exists: ope,
    output: spe
};
var lf = ape;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const cpe = (e)=>e instanceof Uint8Array, aE = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), oa = (e, t)=>e << 32 - t | e >>> t, upe = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!upe) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function fpe(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
}
function zS(e) {
    if (typeof e == "string" && (e = fpe(e)), !cpe(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e;
}
class WR {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function qf(e) {
    const t = (n)=>e().update(zS(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function lpe(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
class jS extends WR {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = aE(this.buffer);
    }
    update(t) {
        lf.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = zS(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = aE(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        lf.exists(this), lf.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        lpe(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = aE(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
}
const dpe = (e, t, r)=>e & t ^ ~e & r, hpe = (e, t, r)=>e & t ^ e & r ^ t & r, ppe = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Wc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Vc = new Uint32Array(64);
class VR extends jS {
    constructor(){
        super(64, 32, 8, !1), this.A = Wc[0] | 0, this.B = Wc[1] | 0, this.C = Wc[2] | 0, this.D = Wc[3] | 0, this.E = Wc[4] | 0, this.F = Wc[5] | 0, this.G = Wc[6] | 0, this.H = Wc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Vc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Vc[l - 15], y = Vc[l - 2], _ = oa(p, 7) ^ oa(p, 18) ^ p >>> 3, A = oa(y, 17) ^ oa(y, 19) ^ y >>> 10;
            Vc[l] = A + Vc[l - 7] + _ + Vc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = oa(a, 6) ^ oa(a, 11) ^ oa(a, 25), y = c + p + dpe(a, u, f) + ppe[l] + Vc[l] | 0, A = (oa(n, 2) ^ oa(n, 13) ^ oa(n, 22)) + hpe(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Vc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}
class gpe extends VR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
}
const Um = qf(()=>new VR());
qf(()=>new gpe());
const py = BigInt(2 ** 32 - 1), Nx = BigInt(32);
function GR(e, t = !1) {
    return t ? {
        h: Number(e & py),
        l: Number(e >> Nx & py)
    } : {
        h: Number(e >> Nx & py) | 0,
        l: Number(e & py) | 0
    };
}
function ype(e, t = !1) {
    let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
    for(let i = 0; i < e.length; i++){
        const { h: o, l: s } = GR(e[i], t);
        [r[i], n[i]] = [
            o,
            s
        ];
    }
    return [
        r,
        n
    ];
}
const mpe = (e, t)=>BigInt(e >>> 0) << Nx | BigInt(t >>> 0), bpe = (e, t, r)=>e >>> r, wpe = (e, t, r)=>e << 32 - r | t >>> r, vpe = (e, t, r)=>e >>> r | t << 32 - r, _pe = (e, t, r)=>e << 32 - r | t >>> r, Epe = (e, t, r)=>e << 64 - r | t >>> r - 32, xpe = (e, t, r)=>e >>> r - 32 | t << 64 - r, Spe = (e, t)=>t, Ape = (e, t)=>e, Tpe = (e, t, r)=>e << r | t >>> 32 - r, kpe = (e, t, r)=>t << r | e >>> 32 - r, Ipe = (e, t, r)=>t << r - 32 | e >>> 64 - r, Bpe = (e, t, r)=>e << r - 32 | t >>> 64 - r;
function Ope(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    };
}
const Ppe = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0), Npe = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0, Mpe = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), Rpe = (e, t, r, n, i)=>t + r + n + i + (e / 2 ** 32 | 0) | 0, Cpe = (e, t, r, n, i)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Upe = (e, t, r, n, i, o)=>t + r + n + i + o + (e / 2 ** 32 | 0) | 0, $pe = {
    fromBig: GR,
    split: ype,
    toBig: mpe,
    shrSH: bpe,
    shrSL: wpe,
    rotrSH: vpe,
    rotrSL: _pe,
    rotrBH: Epe,
    rotrBL: xpe,
    rotr32H: Spe,
    rotr32L: Ape,
    rotlSH: Tpe,
    rotlSL: kpe,
    rotlBH: Ipe,
    rotlBL: Bpe,
    add: Ope,
    add3L: Ppe,
    add3H: Npe,
    add4L: Mpe,
    add4H: Rpe,
    add5H: Upe,
    add5L: Cpe
};
var Er = $pe;
const [Lpe, Dpe] = Er.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), Gc = new Uint32Array(80), Zc = new Uint32Array(80);
class y1 extends jS {
    constructor(){
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: u, Eh: f, El: c, Fh: l, Fl: p, Gh: y, Gl: _, Hh: A, Hl: O } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u,
            f,
            c,
            l,
            p,
            y,
            _,
            A,
            O
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = f | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = A | 0, this.Hl = O | 0;
    }
    process(t, r) {
        for(let D = 0; D < 16; D++, r += 4)Gc[D] = t.getUint32(r), Zc[D] = t.getUint32(r += 4);
        for(let D = 16; D < 80; D++){
            const H = Gc[D - 15] | 0, K = Zc[D - 15] | 0, re = Er.rotrSH(H, K, 1) ^ Er.rotrSH(H, K, 8) ^ Er.shrSH(H, K, 7), Q = Er.rotrSL(H, K, 1) ^ Er.rotrSL(H, K, 8) ^ Er.shrSL(H, K, 7), G = Gc[D - 2] | 0, R = Zc[D - 2] | 0, X = Er.rotrSH(G, R, 19) ^ Er.rotrBH(G, R, 61) ^ Er.shrSH(G, R, 6), $ = Er.rotrSL(G, R, 19) ^ Er.rotrBL(G, R, 61) ^ Er.shrSL(G, R, 6), S = Er.add4L(Q, $, Zc[D - 7], Zc[D - 16]), w = Er.add4H(S, re, X, Gc[D - 7], Gc[D - 16]);
            Gc[D] = w | 0, Zc[D] = S | 0;
        }
        let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: u, Dh: f, Dl: c, Eh: l, El: p, Fh: y, Fl: _, Gh: A, Gl: O, Hh: N, Hl: U } = this;
        for(let D = 0; D < 80; D++){
            const H = Er.rotrSH(l, p, 14) ^ Er.rotrSH(l, p, 18) ^ Er.rotrBH(l, p, 41), K = Er.rotrSL(l, p, 14) ^ Er.rotrSL(l, p, 18) ^ Er.rotrBL(l, p, 41), re = l & y ^ ~l & A, Q = p & _ ^ ~p & O, G = Er.add5L(U, K, Q, Dpe[D], Zc[D]), R = Er.add5H(G, N, H, re, Lpe[D], Gc[D]), X = G | 0, $ = Er.rotrSH(n, i, 28) ^ Er.rotrBH(n, i, 34) ^ Er.rotrBH(n, i, 39), S = Er.rotrSL(n, i, 28) ^ Er.rotrBL(n, i, 34) ^ Er.rotrBL(n, i, 39), w = n & o ^ n & a ^ o & a, g = i & s ^ i & u ^ s & u;
            N = A | 0, U = O | 0, A = y | 0, O = _ | 0, y = l | 0, _ = p | 0, ({ h: l, l: p } = Er.add(f | 0, c | 0, R | 0, X | 0)), f = a | 0, c = u | 0, a = o | 0, u = s | 0, o = n | 0, s = i | 0;
            const m = Er.add3L(X, S, g);
            n = Er.add3H(m, R, $, w), i = m | 0;
        }
        ({ h: n, l: i } = Er.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), ({ h: o, l: s } = Er.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0)), ({ h: a, l: u } = Er.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: f, l: c } = Er.add(this.Dh | 0, this.Dl | 0, f | 0, c | 0)), ({ h: l, l: p } = Er.add(this.Eh | 0, this.El | 0, l | 0, p | 0)), ({ h: y, l: _ } = Er.add(this.Fh | 0, this.Fl | 0, y | 0, _ | 0)), ({ h: A, l: O } = Er.add(this.Gh | 0, this.Gl | 0, A | 0, O | 0)), ({ h: N, l: U } = Er.add(this.Hh | 0, this.Hl | 0, N | 0, U | 0)), this.set(n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U);
    }
    roundClean() {
        Gc.fill(0), Zc.fill(0);
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class Fpe extends y1 {
    constructor(){
        super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
    }
}
class zpe extends y1 {
    constructor(){
        super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
    }
}
class jpe extends y1 {
    constructor(){
        super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
    }
}
const Hpe = qf(()=>new y1());
qf(()=>new Fpe());
qf(()=>new zpe());
qf(()=>new jpe());
const qpe = new Uint8Array([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), ZR = Uint8Array.from({
    length: 16
}, (e, t)=>t), Kpe = ZR.map((e)=>(9 * e + 5) % 16);
let HS = [
    ZR
], qS = [
    Kpe
];
for(let e = 0; e < 4; e++)for (let t of [
    HS,
    qS
])t.push(t[e].map((r)=>qpe[r]));
const YR = [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>new Uint8Array(e)), Wpe = HS.map((e, t)=>e.map((r)=>YR[t][r])), Vpe = qS.map((e, t)=>e.map((r)=>YR[t][r])), Gpe = new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), Zpe = new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]), gy = (e, t)=>e << t | e >>> 32 - t;
function iB(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const yy = new Uint32Array(16);
class Ype extends jS {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)yy[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, u = a, f = this.h3 | 0, c = f, l = this.h4 | 0, p = l;
        for(let y = 0; y < 5; y++){
            const _ = 4 - y, A = Gpe[y], O = Zpe[y], N = HS[y], U = qS[y], D = Wpe[y], H = Vpe[y];
            for(let K = 0; K < 16; K++){
                const re = gy(n + iB(y, o, a, f) + yy[N[K]] + A, D[K]) + l | 0;
                n = l, l = f, f = gy(a, 10) | 0, a = o, o = re;
            }
            for(let K = 0; K < 16; K++){
                const re = gy(i + iB(_, s, u, c) + yy[U[K]] + O, H[K]) + p | 0;
                i = p, p = c, c = gy(u, 10) | 0, u = s, s = re;
            }
        }
        this.set(this.h1 + a + c | 0, this.h2 + f + p | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + u | 0);
    }
    roundClean() {
        yy.fill(0);
    }
    destroy() {
        this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
    }
}
const Xpe = qf(()=>new Ype());
class XR extends WR {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, lf.hash(t);
        const n = zS(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen, o = new Uint8Array(i);
        o.set(n.length > i ? t.create().update(n).digest() : n);
        for(let s = 0; s < o.length; s++)o[s] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let s = 0; s < o.length; s++)o[s] ^= 106;
        this.oHash.update(o), o.fill(0);
    }
    update(t) {
        return lf.exists(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        lf.exists(this), lf.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
}
const JR = (e, t, r)=>new XR(e, t).update(r).digest();
JR.create = (e, t)=>new XR(e, t);
function Jpe(e) {
    const t = ir.bytes(e);
    return ir.raw(Um(t));
}
function Qpe(e) {
    const t = ir.bytes(e);
    return ir.raw(Um(Um(t)));
}
function QR(e) {
    const t = ir.bytes(e);
    return ir.raw(Xpe(Um(t)));
}
function e0e(e, t) {
    const r = ir.bytes(e), n = ir.bytes(t);
    return ir.raw(JR(Hpe, r, n));
}
function t0e(e) {
    const t = ir.str(e).digest;
    return ir.join([
        t,
        t
    ]);
}
function r0e(e = 32) {
    return KS(qR(e));
}
function KS(e) {
    return yi.mod(e).buff;
}
function eC(e, t = !1) {
    const r = yi.mod(e).point;
    return t ? r.x : r.buff;
}
function tC(e, t) {
    const r = fc.from_x(t), n = yi.mod(e);
    return r.mul(n).buff;
}
function n0e(e, t, r = "ecdh/code") {
    const n = t0e(r), i = KS(e), o = eC(i), s = ir.bytes(t), a = tC(i, s), u = [
        o.hex,
        s.hex
    ];
    return u.sort(), e0e(a, ir.join([
        n,
        ...u
    ]));
}
function i0e(e) {
    const t = ir.bytes(e);
    switch(!0){
        case t.length === 32:
            return !0;
        case t.length === 33 && t[0] === 2:
            return !0;
        case t.length === 33 && t[0] === 3:
            return !1;
        default:
            throw new TypeError(`Invalid public key: ${t.hex}`);
    }
}
function o0e(e) {
    const t = ir.bytes(e);
    switch(t.length){
        case 32:
            return t;
        case 33:
            return t.slice(1, 33);
        default:
            throw new Error(`Invalid key length: ${t.length}`);
    }
}
var s0e = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    genSecretKey: r0e,
    getPublicKey: eC,
    getSecretKey: KS,
    getSharedCode: n0e,
    getSharedKey: tC,
    is_even_pub: i0e,
    xonly_pub: o0e
});
ir.random(32);
const Mx = {
    ...s0e,
    ...Yhe
};
function m1(e) {
    const t = Ze.bytes(e);
    return Ia(t, 33), QR(t);
}
function rC(e) {
    const t = Ba.fmt.toBytes(e, !1);
    return QR(t);
}
function nC(e) {
    const t = Ba.fmt.toBytes(e, !1);
    return Jpe(t);
}
function iC(e, t = "main") {
    const r = t === "main" ? [
        "1"
    ] : [
        "m",
        "n"
    ];
    for (const n of r)if (e.startsWith(n)) return !0;
    return !1;
}
function oC(e, t = "main") {
    const r = Ze.bytes(e), n = t === "main" ? Ze.num(0) : Ze.num(111);
    return Ia(e, 20), r.prepend(n).tob58chk();
}
function a0e(e, t = "main") {
    if (!iC(e, t)) throw new TypeError("Invalid p2pkh address!");
    return Ze.b58chk(e).slice(1);
}
function c0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 20), [
        "OP_DUP",
        "OP_HASH160",
        t.hex,
        "OP_EQUALVERIFY",
        "OP_CHECKSIG"
    ];
}
function u0e(e, t) {
    const r = m1(e);
    return oC(r, t);
}
const sC = {
    check: iC,
    encode: oC,
    decode: a0e,
    hash: m1,
    scriptPubKey: c0e,
    fromPubKey: u0e
};
function aC(e, t = "main") {
    const r = t === "main" ? [
        "3"
    ] : [
        "2"
    ];
    for (const n of r)if (e.startsWith(n)) return !0;
    return !1;
}
function cC(e, t = "main") {
    const r = t === "main" ? Ze.num(5) : Ze.num(196), n = Ze.bytes(e);
    return Ia(n, 20), n.prepend(r).tob58chk();
}
function f0e(e, t = "main") {
    if (!aC(e, t)) throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
    return Ze.b58chk(e).slice(1);
}
function l0e(e) {
    return [
        "OP_HASH160",
        Ze.bytes(e).hex,
        "OP_EQUAL"
    ];
}
function d0e(e, t) {
    const r = rC(e);
    return cC(r, t);
}
const uC = {
    check: aC,
    encode: cC,
    decode: f0e,
    hash: rC,
    scriptPubKey: l0e,
    fromScript: d0e
}, WS = {
    main: "bc",
    testnet: "tb",
    signet: "tb",
    regtest: "bcrt"
}, h0e = [
    "bc1q",
    "tb1q",
    "bcrt1q"
];
function fC(e) {
    for (const t of h0e)if (e.startsWith(t)) return !0;
    return !1;
}
function lC(e, t = "main") {
    const r = WS[t], n = Ze.bytes(e);
    return Ia(n, 20), n.toBech32(r, 0);
}
function p0e(e) {
    if (!fC(e)) throw new TypeError("Invalid segwit address!");
    return Ze.bech32(e);
}
function g0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 20), [
        "OP_0",
        t.hex
    ];
}
function y0e(e, t) {
    const r = m1(e);
    return lC(r, t);
}
const dC = {
    check: fC,
    encode: lC,
    decode: p0e,
    hash: m1,
    scriptPubKey: g0e,
    fromPubKey: y0e
}, m0e = [
    "bc1q",
    "tb1q",
    "bcrt1q"
];
function hC(e) {
    for (const t of m0e)if (e.startsWith(t)) return !0;
    return !1;
}
function pC(e, t = "main") {
    const r = WS[t], n = Ze.bytes(e);
    return Ia(n, 32), n.toBech32(r, 0);
}
function b0e(e) {
    if (!hC(e)) throw new TypeError("Invalid segwit address!");
    return Ze.bech32(e);
}
function w0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 32), [
        "OP_0",
        t.hex
    ];
}
function v0e(e, t) {
    const r = nC(e);
    return pC(r, t);
}
const gC = {
    check: hC,
    encode: pC,
    decode: b0e,
    hash: nC,
    scriptPubKey: w0e,
    fromScript: v0e
};
function Af(e) {
    const t = Ze.bytes(e);
    return t.length > 32 ? t.slice(1, 33) : t;
}
const _0e = [
    "bc1p",
    "tb1p",
    "bcrt1p"
];
function yC(e) {
    for (const t of _0e)if (e.startsWith(t)) return !0;
    return !1;
}
function mC(e, t = "main") {
    const r = WS[t], n = Ze.bytes(e);
    return Ia(n, 32), n.toBech32(r, 1);
}
function E0e(e) {
    if (!yC(e)) throw new TypeError("Invalid taproot address!");
    return Ze.bech32(e);
}
function x0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 32), [
        "OP_1",
        t.hex
    ];
}
function S0e(e, t) {
    const r = Af(e);
    return mC(r, t);
}
const bC = {
    check: yC,
    encode: mC,
    decode: E0e,
    scriptPubKey: x0e,
    fromPubKey: S0e
}, A0e = {
    version: 2,
    vin: [],
    vout: [],
    locktime: 0
}, T0e = {
    scriptSig: [],
    sequence: 4294967293,
    witness: []
}, k0e = {
    value: 0n,
    scriptPubKey: []
};
function VS(e) {
    const t = {
        ...A0e,
        ...e
    };
    return t.vin = t.vin.map((r)=>({
            ...T0e,
            ...r
        })), t.vout = t.vout.map((r)=>({
            ...k0e,
            ...r
        })), t;
}
function ld(e, t) {
    const { version: r, vin: n, vout: i, locktime: o } = VS(e), s = t !== !0 && I0e(n), a = [
        wC(r)
    ];
    s && a.push(Ze.hex("0001")), a.push(B0e(n)), a.push(O0e(i));
    for (const u of n)s && a.push(N0e(u.witness));
    return a.push(vC(o)), Ze.join(a);
}
function I0e(e) {
    for (const t of e){
        const { witness: r } = t;
        if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0) return !0;
    }
    return !1;
}
function wC(e) {
    return Ze.num(e, 4).reverse();
}
function GS(e) {
    return Ze.hex(e, 32).reverse();
}
function ZS(e) {
    return Ze.num(e, 4).reverse();
}
function YS(e) {
    if (typeof e == "string") return Ze.hex(e, 4).reverse();
    if (typeof e == "number") return Ze.num(e, 4).reverse();
    throw new Error("Unrecognized format: " + String(e));
}
function B0e(e) {
    const t = [
        Ze.varInt(e.length, "le")
    ];
    for (const r of e){
        const { txid: n, vout: i, scriptSig: o, sequence: s } = r;
        t.push(GS(n)), t.push(ZS(i)), t.push(Hf(o, !0)), t.push(YS(s));
    }
    return Ze.join(t);
}
function A0(e) {
    if (typeof e == "number") {
        if (e % 1 !== 0) throw new Error("Value must be an integer:" + String(e));
        return Ze.num(e, 8).reverse();
    }
    return Ze.big(e, 8).reverse();
}
function O0e(e) {
    const t = [
        Ze.varInt(e.length, "le")
    ];
    for (const r of e)t.push(P0e(r));
    return Ze.join(t);
}
function P0e(e) {
    const { value: t, scriptPubKey: r } = e, n = [];
    return n.push(A0(t)), n.push(Hf(r, !0)), Ze.join(n);
}
function N0e(e = []) {
    const t = [];
    if (Array.isArray(e)) {
        const r = Ze.varInt(e.length);
        t.push(r);
        for (const n of e)t.push(M0e(n));
        return Ze.join(t);
    } else return Ze.bytes(e);
}
function M0e(e) {
    return R0e(e) ? new Ze(0) : Hf(e, !0);
}
function R0e(e) {
    if (Array.isArray(e)) return e.length === 0;
    if (typeof e == "string" && e === "") return !0;
    const t = Ze.bytes(e);
    return t.length === 1 && t[0] === 0;
}
function vC(e) {
    if (typeof e == "string") return Ze.hex(e, 4);
    if (typeof e == "number") return Ze.num(e, 4).reverse();
    throw new Error("Unrecognized format: " + String(e));
}
function XS(e) {
    typeof e == "string" && (e = Ze.hex(e).raw);
    const t = new Hd(e), r = C0e(t), n = U0e(t), i = $0e(t), o = D0e(t);
    if (n) for (const a of i)a.witness = z0e(t);
    const s = j0e(t);
    return {
        version: r,
        vin: i,
        vout: o,
        locktime: s
    };
}
function C0e(e) {
    return e.read(4).reverse().toNum();
}
function U0e(e) {
    const [t, r] = [
        ...e.peek(2)
    ];
    if (t === 0) {
        if (e.read(2), r === 1) return !0;
        throw new Error(`Invalid witness flag: ${r}`);
    }
    return !1;
}
function $0e(e) {
    const t = [], r = e.readSize("le");
    for(let n = 0; n < r; n++)t.push(L0e(e));
    return t;
}
function L0e(e) {
    return {
        txid: e.read(32).reverse().toHex(),
        vout: e.read(4).reverse().toNum(),
        scriptSig: EC(e),
        sequence: e.read(4).reverse().toHex(),
        witness: []
    };
}
function D0e(e) {
    const t = [], r = e.readSize("le");
    for(let n = 0; n < r; n++)t.push(F0e(e));
    return t;
}
function F0e(e) {
    return {
        value: e.read(8).reverse().big,
        scriptPubKey: EC(e)
    };
}
function z0e(e) {
    const t = [], r = e.readSize();
    for(let n = 0; n < r; n++){
        const i = _C(e);
        t.push(i ?? "");
    }
    return t;
}
function _C(e, t) {
    const r = e.readSize("le");
    return r > 0 ? e.read(r).hex : null;
}
function EC(e, t) {
    const r = _C(e);
    return r !== null ? r : [];
}
function j0e(e) {
    return e.read(4).reverse().toNum();
}
function H0e(e) {
    if (oR(e)) return XS(e);
    if (typeof e == "object" && !(e instanceof Uint8Array)) return ld(e), VS(e);
    throw new Error("Invalid format: " + typeof e);
}
function q0e(e) {
    if (oR(e)) return XS(e), Ze.bytes(e);
    if (typeof e == "object") return ld(e);
    throw new Error("Invalid format: " + typeof e);
}
const JS = {
    toBytes: q0e,
    toJson: H0e
}, K0e = [
    [
        "p2pkh",
        /^76a914(?<hash>\w{40})88ac$/
    ],
    [
        "p2sh",
        /^a914(?<hash>\w{40})87$/
    ],
    [
        "p2w-pkh",
        /^0014(?<hash>\w{40})$/
    ],
    [
        "p2w-sh",
        /^0020(?<hash>\w{64})$/
    ],
    [
        "p2tr",
        /^5120(?<hash>\w{64})$/
    ]
], W0e = [
    192,
    194,
    196,
    198,
    200,
    202,
    204,
    206,
    208,
    210,
    212,
    214,
    216,
    218,
    220,
    222,
    224,
    226,
    228,
    230,
    232,
    234,
    236,
    238,
    240,
    242,
    244,
    246,
    248,
    250,
    252,
    254,
    102,
    126,
    128,
    132,
    150,
    152,
    186,
    188,
    190
];
function V0e(e) {
    let t = e.at(-1);
    return bc(t) && (t = Ze.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), Ze.raw(t)) : null;
}
function G0e(e) {
    let t = e.at(-1);
    return bc(t) && (t = Ze.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && W0e.includes(t[0] & 254) ? (e.pop(), Ze.raw(t)) : null;
}
function Z0e(e) {
    if (e.length > 1) {
        const t = e.at(-1);
        try {
            const r = Ba.fmt.toBytes(t);
            return e.pop(), r;
        } catch  {
            return null;
        }
    }
    return null;
}
function Y0e(e) {
    const t = [];
    for (const r of e)if (bc(r) || r instanceof Uint8Array || typeof r == "number") t.push(Ze.bytes(r));
    else throw new Error("unrecognized value: " + String(r));
    return t;
}
function X0e(e = []) {
    const t = [
        ...e
    ], r = V0e(t), n = G0e(t), i = Z0e(t), o = Y0e(t);
    return {
        annex: r,
        cblock: n,
        script: i,
        params: o
    };
}
function J0e(e) {
    const t = Ba.fmt.toBytes(e, !1).hex;
    for (const [r, n] of K0e){
        const i = r, { groups: o } = n.exec(t) ?? {}, { hash: s } = o ?? {};
        if (bc(s)) return {
            type: i,
            data: Ze.hex(s)
        };
    }
    return {
        type: "raw",
        data: Ze.hex(t)
    };
}
function Q0e(e) {
    const t = JS.toJson(e), r = ld(t, !0);
    return Qpe(r).reverse().hex;
}
function ege(e) {
    const t = JS.toJson(e), r = ld(t, !0).length, n = ld(t, !1).length, i = r * 3 + n, o = i % 4 > 0 ? 1 : 0, s = Math.floor(i / 4) + o;
    return {
        size: n,
        bsize: r,
        vsize: s,
        weight: i
    };
}
const lu = {
    create: VS,
    encode: ld,
    decode: XS,
    fmt: JS,
    util: {
        getTxSize: ege,
        getTxid: Q0e,
        readScriptPubKey: J0e,
        readWitness: X0e
    }
}, tge = [
    [
        "1",
        "p2pkh",
        "main",
        20,
        "base58"
    ],
    [
        "3",
        "p2sh",
        "main",
        20,
        "base58"
    ],
    [
        "m",
        "p2pkh",
        "testnet",
        20,
        "base58"
    ],
    [
        "n",
        "p2pkh",
        "testnet",
        20,
        "base58"
    ],
    [
        "2",
        "p2sh",
        "testnet",
        20,
        "base58"
    ],
    [
        "bc1q",
        "p2w-pkh",
        "main",
        20,
        "bech32"
    ],
    [
        "tb1q",
        "p2w-pkh",
        "testnet",
        20,
        "bech32"
    ],
    [
        "bcrt1q",
        "p2w-pkh",
        "regtest",
        20,
        "bech32"
    ],
    [
        "bc1q",
        "p2w-sh",
        "main",
        32,
        "bech32"
    ],
    [
        "tb1q",
        "p2w-sh",
        "testnet",
        32,
        "bech32"
    ],
    [
        "bcrt1q",
        "p2w-sh",
        "regtest",
        32,
        "bech32"
    ],
    [
        "bc1p",
        "p2tr",
        "main",
        32,
        "bech32m"
    ],
    [
        "tb1p",
        "p2tr",
        "testnet",
        32,
        "bech32m"
    ],
    [
        "bcrt1p",
        "p2tr",
        "regtest",
        32,
        "bech32m"
    ]
];
function rge(e, t) {
    switch(t){
        case "base58":
            return Ze.b58chk(e).slice(1);
        case "bech32":
            return Ze.bech32(e);
        case "bech32m":
            return Ze.bech32(e);
        default:
            throw new Error("Invalid address format: " + t);
    }
}
function nge(e) {
    for (const t of tge){
        const [r, n, i, o, s] = t;
        if (e.startsWith(r) && rge(e, s).length === o) return t;
    }
    throw new Error("Invalid address: " + e);
}
function xC(e) {
    switch(e){
        case "p2pkh":
            return sC;
        case "p2sh":
            return uC;
        case "p2w-pkh":
            return dC;
        case "p2w-sh":
            return gC;
        case "p2tr":
            return bC;
        default:
            throw new Error("Invalid address type: " + e);
    }
}
function SC(e) {
    const [t, r, n] = nge(e), i = xC(r), o = i.decode(e, n), s = i.scriptPubKey(o);
    return {
        prefix: t,
        type: r,
        network: n,
        data: o,
        script: s
    };
}
function ige(e, t) {
    const { type: r, data: n } = lu.util.readScriptPubKey(e);
    return xC(r).encode(n, t);
}
function oge(e) {
    const { script: t } = SC(e);
    return Ba.fmt.toAsm(t, !1);
}
const AC = {
    p2pkh: sC,
    p2sh: uC,
    p2wpkh: dC,
    p2wsh: gC,
    p2tr: bC,
    decode: SC,
    fromScriptPubKey: ige,
    toScriptPubKey: oge
}, sge = [
    0,
    1,
    2,
    3,
    129,
    130,
    131
];
function QS(e, t, r = {}) {
    const { extension: n, sigflag: i = 0, extflag: o = 0, key_version: s = 0, separator_pos: a = 4294967295 } = r, u = lu.fmt.toJson(e), { version: f, vin: c, vout: l, locktime: p } = u;
    if (t >= c.length) throw new Error("Index out of bounds: " + String(t));
    if (!sge.includes(i)) throw new Error("Invalid hash type: " + String(i));
    if (o < 0 || o > 127) throw new Error("Extention flag out of range: " + String(o));
    const { txid: y, vout: _, sequence: A, witness: O = [] } = c[t], N = (i & 128) === 128, U = hge(O), D = U !== void 0 ? 1 : 0, K = (o + (n !== void 0 ? 1 : 0)) * 2 + D, re = Ze.str("TapSighash").digest, Q = [
        re,
        re,
        Ze.num(0, 1),
        Ze.num(i, 1),
        wC(f),
        vC(p)
    ];
    if (!N) {
        const G = c.map((R)=>oB(R));
        Q.push(age(c), uge(G), fge(G), cge(c));
    }
    if (((i & 3) < 2 || (i & 3) > 3) && Q.push(lge(l)), Q.push(Ze.num(K, 1)), N) {
        const { value: G, scriptPubKey: R } = oB(c[t]);
        Q.push(GS(y), ZS(_), A0(G), Ba.encode(R, !0), YS(A));
    } else Q.push(Ze.num(t, 4).reverse());
    return U !== void 0 && Q.push(U), (i & 3) === 3 && Q.push(dge(l[t])), n !== void 0 && Q.push(Ze.bytes(n), Ze.num(s), Ze.num(a, 4, "le")), Ze.join(Q).digest;
}
function age(e) {
    const t = [];
    for (const { txid: r, vout: n } of e)t.push(GS(r)), t.push(ZS(n));
    return Ze.join(t).digest;
}
function cge(e) {
    const t = [];
    for (const { sequence: r } of e)t.push(YS(r));
    return Ze.join(t).digest;
}
function uge(e) {
    const t = [];
    for (const { value: r } of e)t.push(A0(r));
    return Ze.join(t).digest;
}
function fge(e) {
    const t = [];
    for (const { scriptPubKey: r } of e)t.push(Hf(r, !0));
    return Ze.join(t).digest;
}
function lge(e) {
    const t = [];
    for (const { value: r, scriptPubKey: n } of e)t.push(A0(r)), t.push(Ba.encode(n, !0));
    return Ze.join(t).digest;
}
function dge(e) {
    return Ze.join([
        A0(e.value),
        Ba.encode(e.scriptPubKey, !0)
    ]).digest;
}
function hge(e) {
    if (e === void 0 || e.length < 2) return;
    let t = e.at(-1);
    if (typeof t == "string" && (t = Ze.hex(t)), t instanceof Uint8Array && t[0] === 80) return Ze.raw(t).prefixSize("be").digest;
}
function oB(e) {
    if (e.prevout === void 0) throw new Error("Prevout data missing for input: " + String(e.txid));
    return e.prevout;
}
const pge = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, gge = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function yge(e, t, r, n = {}) {
    const { sigflag: i = 0 } = n, o = QS(t, r, n), s = mge(e, o);
    return i === 0 ? Ze.raw(s) : Ze.join([
        s,
        i
    ]);
}
function mge(e, t, r = Ze.random(32)) {
    const n = Ze.bytes(t), i = new yi(e), o = i.point, s = o.hasEvenY ? i.big : i.negated.big, a = $y("BIP0340/aux", Ze.bytes(r)), u = s ^ a.big, f = $y("BIP0340/nonce", u, o.x.raw, n), c = new yi(f), l = c.point, p = l.hasEvenY ? c.big : c.negated.big, y = new yi($y("BIP0340/challenge", l.x.raw, o.x.raw, n)), _ = new yi(p + y.big * s);
    return Ze.join([
        l.x.raw,
        _.raw
    ]);
}
function bge(e, t, r, n = !1) {
    const i = fc.from_x(Af(r)), o = Ze.bytes(t), s = Ze.bytes(e).stream;
    s.size < 64 && Oo("Signature length is too small: " + String(s.size), n);
    const a = s.read(32);
    a.big > pge && Oo("Signature r value greater than field size!", n);
    const u = s.read(32);
    u.big > gge && Oo("Signature s value greater than curve order!", n);
    const f = new yi($y("BIP0340/challenge", a.raw, i.x.raw, o)), c = new yi(u).point, l = i.mul(f.big), p = c.sub(l);
    return p.hasOddY && Oo("Signature R value has odd Y coordinate!", n), p.x.big === 0n && Oo("Signature R value is infinite!", n), p.x.big === a.big;
}
const wge = 192;
function b1(e) {
    const t = Ze.str(e).digest;
    return Ze.join([
        t,
        t
    ]);
}
function e8(e, t = wge) {
    return Ze.join([
        b1("TapLeaf"),
        Ege(t),
        Ze.bytes(e)
    ]).digest.hex;
}
function vge(e, t) {
    return e8(Ba.fmt.toBytes(e), t);
}
function t8(e, t) {
    return t < e && ([e, t] = [
        t,
        e
    ]), Ze.join([
        b1("TapBranch"),
        Ze.hex(e).raw,
        Ze.hex(t).raw
    ]).digest.hex;
}
function _ge(e) {
    return Ze.hex($m(e)[0]);
}
function $m(e, t, r = []) {
    const n = [], i = [];
    if (e.length < 1) throw new Error("Tree is empty!");
    for(let o = 0; o < e.length; o++){
        const s = e[o];
        if (Array.isArray(s)) {
            const [a, u, f] = $m(s, t);
            t = u, n.push(a);
            for (const c of f)r.push(c);
        } else n.push(s);
    }
    if (n.length === 1) return [
        n[0],
        t,
        r
    ];
    n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
    for(let o = 0; o < n.length - 1; o += 2){
        const s = t8(n[o], n[o + 1]);
        i.push(s), typeof t == "string" && (t === n[o] ? (r.push(n[o + 1]), t = s) : t === n[o + 1] && (r.push(n[o]), t = s));
    }
    return $m(i, t, r);
}
function Ege(e = 192) {
    return e & 254;
}
function TC(e, t = new Uint8Array(), r = !1) {
    const n = r ? new yi(e).point.x.raw : Af(e);
    return Ze.join([
        b1("TapTweak"),
        n,
        Ze.bytes(t)
    ]).digest;
}
function Yl(e, t, r = !1) {
    t === void 0 && (t = new Uint8Array());
    const n = Ze.bytes(e), i = TC(e, t, r);
    return r ? kC(n, i) : IC(n, i);
}
function xge(e, t) {
    return Yl(e, t);
}
function Sge(e, t) {
    return Yl(e, t, !0);
}
function kC(e, t) {
    let r = new yi(e);
    return r.point.hasOddY && (r = r.negate()), Ze.raw(r.add(t).raw);
}
function IC(e, t) {
    e = Af(e);
    const n = fc.from_x(e).add(t);
    return Ze.raw(n.raw);
}
function Age() {
    const e = Ze.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
    return fc.from_x(e.digest).x;
}
const Tge = Age(), kge = 192;
function Ige(e, t = {}) {
    return BC(e, {
        ...t,
        isPrivate: !0
    });
}
function Bge(e, t = {}) {
    return BC(e, {
        ...t,
        isPrivate: !1
    });
}
function BC(e, t = {}) {
    const { isPrivate: r = !1, tree: n = [], version: i = kge } = t, o = r ? Mx.getPublicKey(e, !0) : Af(e);
    let { target: s } = t;
    s !== void 0 && (s = Ze.bytes(s).hex);
    let a, u = [];
    if (n.length > 0) {
        const [y, _, A] = $m(n, s);
        u = A, a = Yl(e, y, r);
    } else s !== void 0 ? a = Yl(e, s, r) : a = Yl(e, void 0, r);
    const f = r ? Mx.getPublicKey(a)[0] : a[0], l = [
        Ze.num(i + PC(f)),
        o
    ];
    u.length > 0 && u.forEach((y)=>l.push(Ze.hex(y)));
    const p = Ze.join(l);
    if (s !== void 0 && !r8(a, s, p, t)) throw new Error("Path checking failed! Unable to generate path.");
    return [
        Af(a).hex,
        p.hex
    ];
}
function r8(e, t, r, n = {}) {
    const { isPrivate: i = !1, throws: o = !1 } = n, { parity: s, paths: a, intkey: u } = OC(r), f = i ? Mx.getPublicKey(e, !0) : Af(e), c = Ze.join([
        s,
        f
    ]);
    if (c.length !== 33) return Oo("Invalid tapkey: " + c.hex, o);
    let l = Ze.bytes(t).hex;
    for (const y of a)l = t8(l, y);
    const p = Yl(u, l);
    return Ze.raw(p).hex === Ze.raw(c).hex;
}
function OC(e) {
    const t = new Hd(Ze.bytes(e)), r = t.read(1).num, n = t.read(32), [i, o] = r % 2 === 0 ? [
        r,
        2
    ] : [
        r - 1,
        3
    ], s = [];
    for(; t.size >= 32;)s.push(t.read(32).hex);
    if (t.size !== 0) throw new Error("Non-empty buffer on control block: " + String(t));
    return {
        intkey: n,
        paths: s,
        parity: o,
        version: i
    };
}
function PC(e = 2) {
    if (e === 0 || e === 1) return e;
    if (e === 2 || e === "02") return 0;
    if (e === 3 || e === "03") return 1;
    throw new Error("Invalid parity bit: " + String(e));
}
function Oge(e, t, r = {}) {
    const n = lu.fmt.toJson(e), { throws: i = !1 } = r, { prevout: o, witness: s = [] } = n.vin[t], a = lu.util.readWitness(s), { cblock: u, script: f, params: c } = a;
    let l;
    if (c.length < 1) return Oo("Invalid witness data: " + String(s), i);
    const { scriptPubKey: p } = o ?? {};
    if (p === void 0) return Oo("Prevout scriptPubKey is empty!", i);
    const { type: y, data: _ } = lu.util.readScriptPubKey(p);
    if (y !== "p2tr") return Oo("Prevout script is not a valid taproot output:" + _.hex, i);
    if (_.length !== 32) return Oo("Invalid tapkey length: " + String(_.length), i);
    if (u !== null && f !== null) {
        const D = u[0] & 254, H = e8(f, D);
        if (r.extension = H, !r8(_, H, u, {
            throws: i
        })) return Oo("cblock verification failed!", i);
    }
    r.pubkey !== void 0 ? l = Ze.bytes(r.pubkey) : c.length > 1 && c[1].length === 32 ? l = Ze.bytes(c[1]) : l = Ze.bytes(_);
    const A = Ba.fmt.toParam(c[0]), O = new Hd(A), N = O.read(64).raw;
    if (O.size === 1 && (r.sigflag = O.read(1).num, r.sigflag === 0)) return Oo("0x00 is not a valid appended sigflag!", i);
    const U = QS(n, t, r);
    return bge(N, U, l, i) ? !0 : Oo("Invalid signature!", i);
}
const Pge = {
    hash: QS,
    sign: yge,
    verify: Oge
}, Nge = {
    taproot: Pge
}, Mge = {
    getTag: b1,
    getLeaf: e8,
    getBranch: t8,
    getRoot: _ge
}, Rge = {
    readCtrlBlock: OC,
    readParityBit: PC
}, Cge = {
    getPubKey: xge,
    getSecKey: Sge,
    getTweak: TC,
    tweakSecKey: kC,
    tweakPubKey: IC
}, Lm = {
    getPubKey: Bge,
    getSecKey: Ige,
    encodeScript: vge,
    checkPath: r8,
    tree: Mge,
    tweak: Cge,
    util: Rge,
    SCRIPT_PUBKEY: Tge
};
var qr;
(function(e) {
    e.assertEqual = (i)=>i;
    function t(i) {}
    e.assertIs = t;
    function r(i) {
        throw new Error();
    }
    e.assertNever = r, e.arrayToEnum = (i)=>{
        const o = {};
        for (const s of i)o[s] = s;
        return o;
    }, e.getValidEnumValues = (i)=>{
        const o = e.objectKeys(i).filter((a)=>typeof i[i[a]] != "number"), s = {};
        for (const a of o)s[a] = i[a];
        return e.objectValues(s);
    }, e.objectValues = (i)=>e.objectKeys(i).map(function(o) {
            return i[o];
        }), e.objectKeys = typeof Object.keys == "function" ? (i)=>Object.keys(i) : (i)=>{
        const o = [];
        for(const s in i)Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
        return o;
    }, e.find = (i, o)=>{
        for (const s of i)if (o(s)) return s;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i)=>Number.isInteger(i) : (i)=>typeof i == "number" && isFinite(i) && Math.floor(i) === i;
    function n(i, o = " | ") {
        return i.map((s)=>typeof s == "string" ? `'${s}'` : s).join(o);
    }
    e.joinValues = n, e.jsonStringifyReplacer = (i, o)=>typeof o == "bigint" ? o.toString() : o;
})(qr || (qr = {}));
var Rx;
(function(e) {
    e.mergeShapes = (t, r)=>({
            ...t,
            ...r
        });
})(Rx || (Rx = {}));
const Bt = qr.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), au = (e)=>{
    switch(typeof e){
        case "undefined":
            return Bt.undefined;
        case "string":
            return Bt.string;
        case "number":
            return isNaN(e) ? Bt.nan : Bt.number;
        case "boolean":
            return Bt.boolean;
        case "function":
            return Bt.function;
        case "bigint":
            return Bt.bigint;
        case "symbol":
            return Bt.symbol;
        case "object":
            return Array.isArray(e) ? Bt.array : e === null ? Bt.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Bt.promise : typeof Map < "u" && e instanceof Map ? Bt.map : typeof Set < "u" && e instanceof Set ? Bt.set : typeof Date < "u" && e instanceof Date ? Bt.date : Bt.object;
        default:
            return Bt.unknown;
    }
}, gt = qr.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]), Uge = (e)=>JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let Us = class extends Error {
    constructor(t){
        super(), this.issues = [], this.addIssue = (n)=>{
            this.issues = [
                ...this.issues,
                n
            ];
        }, this.addIssues = (n = [])=>{
            this.issues = [
                ...this.issues,
                ...n
            ];
        };
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    get errors() {
        return this.issues;
    }
    format(t) {
        const r = t || function(o) {
            return o.message;
        }, n = {
            _errors: []
        }, i = (o)=>{
            for (const s of o.issues)if (s.code === "invalid_union") s.unionErrors.map(i);
            else if (s.code === "invalid_return_type") i(s.returnTypeError);
            else if (s.code === "invalid_arguments") i(s.argumentsError);
            else if (s.path.length === 0) n._errors.push(r(s));
            else {
                let a = n, u = 0;
                for(; u < s.path.length;){
                    const f = s.path[u];
                    u === s.path.length - 1 ? (a[f] = a[f] || {
                        _errors: []
                    }, a[f]._errors.push(r(s))) : a[f] = a[f] || {
                        _errors: []
                    }, a = a[f], u++;
                }
            }
        };
        return i(this), n;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, qr.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(t = (r)=>r.message) {
        const r = {}, n = [];
        for (const i of this.issues)i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
        return {
            formErrors: n,
            fieldErrors: r
        };
    }
    get formErrors() {
        return this.flatten();
    }
};
Us.create = (e)=>new Us(e);
const wp = (e, t)=>{
    let r;
    switch(e.code){
        case gt.invalid_type:
            e.received === Bt.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
            break;
        case gt.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(e.expected, qr.jsonStringifyReplacer)}`;
            break;
        case gt.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${qr.joinValues(e.keys, ", ")}`;
            break;
        case gt.invalid_union:
            r = "Invalid input";
            break;
        case gt.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${qr.joinValues(e.options)}`;
            break;
        case gt.invalid_enum_value:
            r = `Invalid enum value. Expected ${qr.joinValues(e.options)}, received '${e.received}'`;
            break;
        case gt.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case gt.invalid_return_type:
            r = "Invalid function return type";
            break;
        case gt.invalid_date:
            r = "Invalid date";
            break;
        case gt.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : qr.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
            break;
        case gt.too_small:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
            break;
        case gt.too_big:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
            break;
        case gt.custom:
            r = "Invalid input";
            break;
        case gt.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case gt.not_multiple_of:
            r = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case gt.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = t.defaultError, qr.assertNever(e);
    }
    return {
        message: r
    };
};
let NC = wp;
function $ge(e) {
    NC = e;
}
function Dm() {
    return NC;
}
const Fm = (e)=>{
    const { data: t, path: r, errorMaps: n, issueData: i } = e, o = [
        ...r,
        ...i.path || []
    ], s = {
        ...i,
        path: o
    };
    let a = "";
    const u = n.filter((f)=>!!f).slice().reverse();
    for (const f of u)a = f(s, {
        data: t,
        defaultError: a
    }).message;
    return {
        ...i,
        path: o,
        message: i.message || a
    };
}, Lge = [];
function Nt(e, t) {
    const r = Fm({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            Dm(),
            wp
        ].filter((n)=>!!n)
    });
    e.common.issues.push(r);
}
let yo = class MC {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
        const n = [];
        for (const i of r){
            if (i.status === "aborted") return cr;
            i.status === "dirty" && t.dirty(), n.push(i.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const i of r)n.push({
            key: await i.key,
            value: await i.value
        });
        return MC.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const i of r){
            const { key: o, value: s } = i;
            if (o.status === "aborted" || s.status === "aborted") return cr;
            o.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), (typeof s.value < "u" || i.alwaysSet) && (n[o.value] = s.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
};
const cr = Object.freeze({
    status: "aborted"
}), RC = (e)=>({
        status: "dirty",
        value: e
    }), Ki = (e)=>({
        status: "valid",
        value: e
    }), Cx = (e)=>e.status === "aborted", Ux = (e)=>e.status === "dirty", zm = (e)=>e.status === "valid", jm = (e)=>typeof Promise < "u" && e instanceof Promise;
var qt;
(function(e) {
    e.errToObj = (t)=>typeof t == "string" ? {
            message: t
        } : t || {}, e.toString = (t)=>typeof t == "string" ? t : t == null ? void 0 : t.message;
})(qt || (qt = {}));
let va = class {
    constructor(t, r, n, i){
        this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
};
const sB = (e, t)=>{
    if (zm(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const r = new Us(e.common.issues);
            return this._error = r, this._error;
        }
    };
};
function br(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
    if (t && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i
    } : {
        errorMap: (s, a)=>s.code !== "invalid_type" ? {
                message: a.defaultError
            } : typeof a.data > "u" ? {
                message: n ?? a.defaultError
            } : {
                message: r ?? a.defaultError
            },
        description: i
    };
}
let Ir = class {
    constructor(t){
        this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(t) {
        return au(t.data);
    }
    _getOrReturnCtx(t, r) {
        return r || {
            common: t.parent.common,
            data: t.data,
            parsedType: au(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        };
    }
    _processInputParams(t) {
        return {
            status: new yo(),
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: au(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        };
    }
    _parseSync(t) {
        const r = this._parse(t);
        if (jm(r)) throw new Error("Synchronous parse encountered promise.");
        return r;
    }
    _parseAsync(t) {
        const r = this._parse(t);
        return Promise.resolve(r);
    }
    parse(t, r) {
        const n = this.safeParse(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    safeParse(t, r) {
        var n;
        const i = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: au(t)
        }, o = this._parseSync({
            data: t,
            path: i.path,
            parent: i
        });
        return sB(i, o);
    }
    async parseAsync(t, r) {
        const n = await this.safeParseAsync(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    async safeParseAsync(t, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: au(t)
        }, i = this._parse({
            data: t,
            path: n.path,
            parent: n
        }), o = await (jm(i) ? i : Promise.resolve(i));
        return sB(n, o);
    }
    refine(t, r) {
        const n = (i)=>typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(i) : r;
        return this._refinement((i, o)=>{
            const s = t(i), a = ()=>o.addIssue({
                    code: gt.custom,
                    ...n(i)
                });
            return typeof Promise < "u" && s instanceof Promise ? s.then((u)=>u ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
        });
    }
    refinement(t, r) {
        return this._refinement((n, i)=>t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
    }
    _refinement(t) {
        return new Ds({
            schema: this,
            typeName: tr.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        });
    }
    superRefine(t) {
        return this._refinement(t);
    }
    optional() {
        return oc.create(this, this._def);
    }
    nullable() {
        return kf.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return Tf.create(this, this._def);
    }
    promise() {
        return pd.create(this, this._def);
    }
    or(t) {
        return Tp.create([
            this,
            t
        ], this._def);
    }
    and(t) {
        return kp.create(this, t, this._def);
    }
    transform(t) {
        return new Ds({
            ...br(this._def),
            schema: this,
            typeName: tr.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        });
    }
    default(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Pp({
            ...br(this._def),
            innerType: this,
            defaultValue: r,
            typeName: tr.ZodDefault
        });
    }
    brand() {
        return new jC({
            typeName: tr.ZodBranded,
            type: this,
            ...br(this._def)
        });
    }
    catch(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Vm({
            ...br(this._def),
            innerType: this,
            catchValue: r,
            typeName: tr.ZodCatch
        });
    }
    describe(t) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: t
        });
    }
    pipe(t) {
        return n8.create(this, t);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
};
const Dge = /^c[^\s-]{8,}$/i, Fge = /^[a-z][a-z0-9]*$/, zge = /[0-9A-HJKMNP-TV-Z]{26}/, jge = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Hge = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, qge = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), Kge = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Wge = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Vge = (e)=>e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Gge(e, t) {
    return !!((t === "v4" || !t) && Kge.test(e) || (t === "v6" || !t) && Wge.test(e));
}
let dd = class Ih extends Ir {
    constructor(){
        super(...arguments), this._regex = (t, r, n)=>this.refinement((i)=>t.test(i), {
                validation: r,
                code: gt.invalid_string,
                ...qt.errToObj(n)
            }), this.nonempty = (t)=>this.min(1, qt.errToObj(t)), this.trim = ()=>new Ih({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "trim"
                    }
                ]
            }), this.toLowerCase = ()=>new Ih({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toLowerCase"
                    }
                ]
            }), this.toUpperCase = ()=>new Ih({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toUpperCase"
                    }
                ]
            });
    }
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Bt.string) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.string,
                received: o.parsedType
            }), cr;
        }
        const n = new yo();
        let i;
        for (const o of this._def.checks)if (o.kind === "min") t.data.length < o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "max") t.data.length > o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "length") {
            const s = t.data.length > o.value, a = t.data.length < o.value;
            (s || a) && (i = this._getOrReturnCtx(t, i), s ? Nt(i, {
                code: gt.too_big,
                maximum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }) : a && Nt(i, {
                code: gt.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }), n.dirty());
        } else if (o.kind === "email") Hge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "email",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "emoji") qge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "emoji",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "uuid") jge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "uuid",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid") Dge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "cuid",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid2") Fge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "cuid2",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "ulid") zge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "ulid",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "url") try {
            new URL(t.data);
        } catch  {
            i = this._getOrReturnCtx(t, i), Nt(i, {
                validation: "url",
                code: gt.invalid_string,
                message: o.message
            }), n.dirty();
        }
        else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "regex",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: {
                includes: o.value,
                position: o.position
            },
            message: o.message
        }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: {
                startsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: {
                endsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "datetime" ? Vge(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: "datetime",
            message: o.message
        }), n.dirty()) : o.kind === "ip" ? Gge(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "ip",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty()) : qr.assertNever(o);
        return {
            status: n.value,
            value: t.data
        };
    }
    _addCheck(t) {
        return new Ih({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...qt.errToObj(t)
        });
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...qt.errToObj(t)
        });
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...qt.errToObj(t)
        });
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...qt.errToObj(t)
        });
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...qt.errToObj(t)
        });
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...qt.errToObj(t)
        });
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...qt.errToObj(t)
        });
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...qt.errToObj(t)
        });
    }
    datetime(t) {
        var r;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            ...qt.errToObj(t == null ? void 0 : t.message)
        });
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...qt.errToObj(r)
        });
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...qt.errToObj(r == null ? void 0 : r.message)
        });
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...qt.errToObj(r)
        });
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...qt.errToObj(r)
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...qt.errToObj(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...qt.errToObj(r)
        });
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...qt.errToObj(r)
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((t)=>t.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((t)=>t.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((t)=>t.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((t)=>t.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((t)=>t.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((t)=>t.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((t)=>t.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((t)=>t.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((t)=>t.kind === "ip");
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
};
dd.create = (e)=>{
    var t;
    return new dd({
        checks: [],
        typeName: tr.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...br(e)
    });
};
function Zge(e, t) {
    const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, o = parseInt(e.toFixed(i).replace(".", "")), s = parseInt(t.toFixed(i).replace(".", ""));
    return o % s / Math.pow(10, i);
}
let vp = class $x extends Ir {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Bt.number) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.number,
                received: o.parsedType
            }), cr;
        }
        let n;
        const i = new yo();
        for (const o of this._def.checks)o.kind === "int" ? qr.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.invalid_type,
            expected: "integer",
            received: "float",
            message: o.message
        }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_small,
            minimum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_big,
            maximum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? Zge(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.not_finite,
            message: o.message
        }), i.dirty()) : qr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, qt.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, qt.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, qt.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, qt.toString(r));
    }
    setLimit(t, r, n, i) {
        return new $x({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: qt.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new $x({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: qt.toString(t)
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: qt.toString(r)
        });
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: qt.toString(t)
        });
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: qt.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: qt.toString(t)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
    get isInt() {
        return !!this._def.checks.find((t)=>t.kind === "int" || t.kind === "multipleOf" && qr.isInteger(t.value));
    }
    get isFinite() {
        let t = null, r = null;
        for (const n of this._def.checks){
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        }
        return Number.isFinite(r) && Number.isFinite(t);
    }
};
vp.create = (e)=>new vp({
        checks: [],
        typeName: tr.ZodNumber,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...br(e)
    });
let _p = class Lx extends Ir {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Bt.bigint) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.bigint,
                received: o.parsedType
            }), cr;
        }
        let n;
        const i = new yo();
        for (const o of this._def.checks)o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_small,
            type: "bigint",
            minimum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_big,
            type: "bigint",
            maximum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : qr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, qt.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, qt.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, qt.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, qt.toString(r));
    }
    setLimit(t, r, n, i) {
        return new Lx({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: qt.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new Lx({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: qt.toString(r)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
};
_p.create = (e)=>{
    var t;
    return new _p({
        checks: [],
        typeName: tr.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...br(e)
    });
};
let Ep = class extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Bt.boolean) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.boolean,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Ep.create = (e)=>new Ep({
        typeName: tr.ZodBoolean,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...br(e)
    });
let xp = class CC extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Bt.date) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.date,
                received: o.parsedType
            }), cr;
        }
        if (isNaN(t.data.getTime())) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_date
            }), cr;
        }
        const n = new yo();
        let i;
        for (const o of this._def.checks)o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_small,
            message: o.message,
            inclusive: !0,
            exact: !1,
            minimum: o.value,
            type: "date"
        }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_big,
            message: o.message,
            inclusive: !0,
            exact: !1,
            maximum: o.value,
            type: "date"
        }), n.dirty()) : qr.assertNever(o);
        return {
            status: n.value,
            value: new Date(t.data.getTime())
        };
    }
    _addCheck(t) {
        return new CC({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: qt.toString(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: qt.toString(r)
        });
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
};
xp.create = (e)=>new xp({
        checks: [],
        coerce: (e == null ? void 0 : e.coerce) || !1,
        typeName: tr.ZodDate,
        ...br(e)
    });
let Hm = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.symbol) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.symbol,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Hm.create = (e)=>new Hm({
        typeName: tr.ZodSymbol,
        ...br(e)
    });
let Sp = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.undefined) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.undefined,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Sp.create = (e)=>new Sp({
        typeName: tr.ZodUndefined,
        ...br(e)
    });
let Ap = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.null) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.null,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Ap.create = (e)=>new Ap({
        typeName: tr.ZodNull,
        ...br(e)
    });
let hd = class extends Ir {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(t) {
        return Ki(t.data);
    }
};
hd.create = (e)=>new hd({
        typeName: tr.ZodAny,
        ...br(e)
    });
let mf = class extends Ir {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(t) {
        return Ki(t.data);
    }
};
mf.create = (e)=>new mf({
        typeName: tr.ZodUnknown,
        ...br(e)
    });
let lc = class extends Ir {
    _parse(t) {
        const r = this._getOrReturnCtx(t);
        return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.never,
            received: r.parsedType
        }), cr;
    }
};
lc.create = (e)=>new lc({
        typeName: tr.ZodNever,
        ...br(e)
    });
let qm = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.undefined) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.void,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
qm.create = (e)=>new qm({
        typeName: tr.ZodVoid,
        ...br(e)
    });
let Tf = class Ly extends Ir {
    _parse(t) {
        const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
        if (r.parsedType !== Bt.array) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.array,
            received: r.parsedType
        }), cr;
        if (i.exactLength !== null) {
            const s = r.data.length > i.exactLength.value, a = r.data.length < i.exactLength.value;
            (s || a) && (Nt(r, {
                code: s ? gt.too_big : gt.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: s ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), n.dirty());
        }
        if (i.minLength !== null && r.data.length < i.minLength.value && (Nt(r, {
            code: gt.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Nt(r, {
            code: gt.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([
            ...r.data
        ].map((s, a)=>i.type._parseAsync(new va(r, s, r.path, a)))).then((s)=>yo.mergeArray(n, s));
        const o = [
            ...r.data
        ].map((s, a)=>i.type._parseSync(new va(r, s, r.path, a)));
        return yo.mergeArray(n, o);
    }
    get element() {
        return this._def.type;
    }
    min(t, r) {
        return new Ly({
            ...this._def,
            minLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    max(t, r) {
        return new Ly({
            ...this._def,
            maxLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    length(t, r) {
        return new Ly({
            ...this._def,
            exactLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    nonempty(t) {
        return this.min(1, t);
    }
};
Tf.create = (e, t)=>new Tf({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: tr.ZodArray,
        ...br(t)
    });
function Tl(e) {
    if (e instanceof ps) {
        const t = {};
        for(const r in e.shape){
            const n = e.shape[r];
            t[r] = oc.create(Tl(n));
        }
        return new ps({
            ...e._def,
            shape: ()=>t
        });
    } else return e instanceof Tf ? new Tf({
        ...e._def,
        type: Tl(e.element)
    }) : e instanceof oc ? oc.create(Tl(e.unwrap())) : e instanceof kf ? kf.create(Tl(e.unwrap())) : e instanceof vu ? vu.create(e.items.map((t)=>Tl(t))) : e;
}
let ps = class As extends Ir {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(), r = qr.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        };
    }
    _parse(t) {
        if (this._getType(t) !== Bt.object) {
            const f = this._getOrReturnCtx(t);
            return Nt(f, {
                code: gt.invalid_type,
                expected: Bt.object,
                received: f.parsedType
            }), cr;
        }
        const { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: s } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof lc && this._def.unknownKeys === "strip")) for(const f in i.data)s.includes(f) || a.push(f);
        const u = [];
        for (const f of s){
            const c = o[f], l = i.data[f];
            u.push({
                key: {
                    status: "valid",
                    value: f
                },
                value: c._parse(new va(i, l, i.path, f)),
                alwaysSet: f in i.data
            });
        }
        if (this._def.catchall instanceof lc) {
            const f = this._def.unknownKeys;
            if (f === "passthrough") for (const c of a)u.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: {
                    status: "valid",
                    value: i.data[c]
                }
            });
            else if (f === "strict") a.length > 0 && (Nt(i, {
                code: gt.unrecognized_keys,
                keys: a
            }), n.dirty());
            else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const f = this._def.catchall;
            for (const c of a){
                const l = i.data[c];
                u.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: f._parse(new va(i, l, i.path, c)),
                    alwaysSet: c in i.data
                });
            }
        }
        return i.common.async ? Promise.resolve().then(async ()=>{
            const f = [];
            for (const c of u){
                const l = await c.key;
                f.push({
                    key: l,
                    value: await c.value,
                    alwaysSet: c.alwaysSet
                });
            }
            return f;
        }).then((f)=>yo.mergeObjectSync(n, f)) : yo.mergeObjectSync(n, u);
    }
    get shape() {
        return this._def.shape();
    }
    strict(t) {
        return new As({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n)=>{
                    var i, o, s, a;
                    const u = (s = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (a = qt.errToObj(t).message) !== null && a !== void 0 ? a : u
                    } : {
                        message: u
                    };
                }
            } : {}
        });
    }
    strip() {
        return new As({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new As({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
        return new As({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(t) {
        return new As({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
            typeName: tr.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
        return this.augment({
            [t]: r
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
        return new As({
            ...this._def,
            catchall: t
        });
    }
    pick(t) {
        const r = {};
        return qr.objectKeys(t).forEach((n)=>{
            t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    omit(t) {
        const r = {};
        return qr.objectKeys(this.shape).forEach((n)=>{
            t[n] || (r[n] = this.shape[n]);
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return Tl(this);
    }
    partial(t) {
        const r = {};
        return qr.objectKeys(this.shape).forEach((n)=>{
            const i = this.shape[n];
            t && !t[n] ? r[n] = i : r[n] = i.optional();
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    required(t) {
        const r = {};
        return qr.objectKeys(this.shape).forEach((n)=>{
            if (t && !t[n]) r[n] = this.shape[n];
            else {
                let o = this.shape[n];
                for(; o instanceof oc;)o = o._def.innerType;
                r[n] = o;
            }
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    keyof() {
        return zC(qr.objectKeys(this.shape));
    }
};
ps.create = (e, t)=>new ps({
        shape: ()=>e,
        unknownKeys: "strip",
        catchall: lc.create(),
        typeName: tr.ZodObject,
        ...br(t)
    });
ps.strictCreate = (e, t)=>new ps({
        shape: ()=>e,
        unknownKeys: "strict",
        catchall: lc.create(),
        typeName: tr.ZodObject,
        ...br(t)
    });
ps.lazycreate = (e, t)=>new ps({
        shape: e,
        unknownKeys: "strip",
        catchall: lc.create(),
        typeName: tr.ZodObject,
        ...br(t)
    });
let Tp = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = this._def.options;
        function i(o) {
            for (const a of o)if (a.result.status === "valid") return a.result;
            for (const a of o)if (a.result.status === "dirty") return r.common.issues.push(...a.ctx.common.issues), a.result;
            const s = o.map((a)=>new Us(a.ctx.common.issues));
            return Nt(r, {
                code: gt.invalid_union,
                unionErrors: s
            }), cr;
        }
        if (r.common.async) return Promise.all(n.map(async (o)=>{
            const s = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await o._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: s
                }),
                ctx: s
            };
        })).then(i);
        {
            let o;
            const s = [];
            for (const u of n){
                const f = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }, c = u._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: f
                });
                if (c.status === "valid") return c;
                c.status === "dirty" && !o && (o = {
                    result: c,
                    ctx: f
                }), f.common.issues.length && s.push(f.common.issues);
            }
            if (o) return r.common.issues.push(...o.ctx.common.issues), o.result;
            const a = s.map((u)=>new Us(u));
            return Nt(r, {
                code: gt.invalid_union,
                unionErrors: a
            }), cr;
        }
    }
    get options() {
        return this._def.options;
    }
};
Tp.create = (e, t)=>new Tp({
        options: e,
        typeName: tr.ZodUnion,
        ...br(t)
    });
const Dy = (e)=>e instanceof Ip ? Dy(e.schema) : e instanceof Ds ? Dy(e.innerType()) : e instanceof Bp ? [
        e.value
    ] : e instanceof T0 ? e.options : e instanceof Op ? Object.keys(e.enum) : e instanceof Pp ? Dy(e._def.innerType) : e instanceof Sp ? [
        void 0
    ] : e instanceof Ap ? [
        null
    ] : null;
let UC = class $C extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.object) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.object,
            received: r.parsedType
        }), cr;
        const n = this.discriminator, i = r.data[n], o = this.optionsMap.get(i);
        return o ? r.common.async ? o._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : o._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (Nt(r, {
            code: gt.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                n
            ]
        }), cr);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(t, r, n) {
        const i = /* @__PURE__ */ new Map();
        for (const o of r){
            const s = Dy(o.shape[t]);
            if (!s) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const a of s){
                if (i.has(a)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
                i.set(a, o);
            }
        }
        return new $C({
            typeName: tr.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: i,
            ...br(n)
        });
    }
};
function Dx(e, t) {
    const r = au(e), n = au(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (r === Bt.object && n === Bt.object) {
        const i = qr.objectKeys(t), o = qr.objectKeys(e).filter((a)=>i.indexOf(a) !== -1), s = {
            ...e,
            ...t
        };
        for (const a of o){
            const u = Dx(e[a], t[a]);
            if (!u.valid) return {
                valid: !1
            };
            s[a] = u.data;
        }
        return {
            valid: !0,
            data: s
        };
    } else if (r === Bt.array && n === Bt.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i = [];
        for(let o = 0; o < e.length; o++){
            const s = e[o], a = t[o], u = Dx(s, a);
            if (!u.valid) return {
                valid: !1
            };
            i.push(u.data);
        }
        return {
            valid: !0,
            data: i
        };
    } else return r === Bt.date && n === Bt.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    };
}
let kp = class extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = (o, s)=>{
            if (Cx(o) || Cx(s)) return cr;
            const a = Dx(o.value, s.value);
            return a.valid ? ((Ux(o) || Ux(s)) && r.dirty(), {
                status: r.value,
                value: a.data
            }) : (Nt(n, {
                code: gt.invalid_intersection_types
            }), cr);
        };
        return n.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }),
            this._def.right._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            })
        ]).then(([o, s])=>i(o, s)) : i(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }));
    }
};
kp.create = (e, t, r)=>new kp({
        left: e,
        right: t,
        typeName: tr.ZodIntersection,
        ...br(r)
    });
let vu = class LC extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.array) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.array,
            received: n.parsedType
        }), cr;
        if (n.data.length < this._def.items.length) return Nt(n, {
            code: gt.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), cr;
        !this._def.rest && n.data.length > this._def.items.length && (Nt(n, {
            code: gt.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const o = [
            ...n.data
        ].map((s, a)=>{
            const u = this._def.items[a] || this._def.rest;
            return u ? u._parse(new va(n, s, n.path, a)) : null;
        }).filter((s)=>!!s);
        return n.common.async ? Promise.all(o).then((s)=>yo.mergeArray(r, s)) : yo.mergeArray(r, o);
    }
    get items() {
        return this._def.items;
    }
    rest(t) {
        return new LC({
            ...this._def,
            rest: t
        });
    }
};
vu.create = (e, t)=>{
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new vu({
        items: e,
        typeName: tr.ZodTuple,
        rest: null,
        ...br(t)
    });
};
let DC = class Fx extends Ir {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.object) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.object,
            received: n.parsedType
        }), cr;
        const i = [], o = this._def.keyType, s = this._def.valueType;
        for(const a in n.data)i.push({
            key: o._parse(new va(n, a, n.path, a)),
            value: s._parse(new va(n, n.data[a], n.path, a))
        });
        return n.common.async ? yo.mergeObjectAsync(r, i) : yo.mergeObjectSync(r, i);
    }
    get element() {
        return this._def.valueType;
    }
    static create(t, r, n) {
        return r instanceof Ir ? new Fx({
            keyType: t,
            valueType: r,
            typeName: tr.ZodRecord,
            ...br(n)
        }) : new Fx({
            keyType: dd.create(),
            valueType: t,
            typeName: tr.ZodRecord,
            ...br(r)
        });
    }
}, Km = class extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.map) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.map,
            received: n.parsedType
        }), cr;
        const i = this._def.keyType, o = this._def.valueType, s = [
            ...n.data.entries()
        ].map(([a, u], f)=>({
                key: i._parse(new va(n, a, n.path, [
                    f,
                    "key"
                ])),
                value: o._parse(new va(n, u, n.path, [
                    f,
                    "value"
                ]))
            }));
        if (n.common.async) {
            const a = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const u of s){
                    const f = await u.key, c = await u.value;
                    if (f.status === "aborted" || c.status === "aborted") return cr;
                    (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
                }
                return {
                    status: r.value,
                    value: a
                };
            });
        } else {
            const a = /* @__PURE__ */ new Map();
            for (const u of s){
                const f = u.key, c = u.value;
                if (f.status === "aborted" || c.status === "aborted") return cr;
                (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
            }
            return {
                status: r.value,
                value: a
            };
        }
    }
};
Km.create = (e, t, r)=>new Km({
        valueType: t,
        keyType: e,
        typeName: tr.ZodMap,
        ...br(r)
    });
let Wm = class zx extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.set) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.set,
            received: n.parsedType
        }), cr;
        const i = this._def;
        i.minSize !== null && n.data.size < i.minSize.value && (Nt(n, {
            code: gt.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Nt(n, {
            code: gt.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), r.dirty());
        const o = this._def.valueType;
        function s(u) {
            const f = /* @__PURE__ */ new Set();
            for (const c of u){
                if (c.status === "aborted") return cr;
                c.status === "dirty" && r.dirty(), f.add(c.value);
            }
            return {
                status: r.value,
                value: f
            };
        }
        const a = [
            ...n.data.values()
        ].map((u, f)=>o._parse(new va(n, u, n.path, f)));
        return n.common.async ? Promise.all(a).then((u)=>s(u)) : s(a);
    }
    min(t, r) {
        return new zx({
            ...this._def,
            minSize: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    max(t, r) {
        return new zx({
            ...this._def,
            maxSize: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    size(t, r) {
        return this.min(t, r).max(t, r);
    }
    nonempty(t) {
        return this.min(1, t);
    }
};
Wm.create = (e, t)=>new Wm({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: tr.ZodSet,
        ...br(t)
    });
let FC = class Fy extends Ir {
    constructor(){
        super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.function) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.function,
            received: r.parsedType
        }), cr;
        function n(a, u) {
            return Fm({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Dm(),
                    wp
                ].filter((f)=>!!f),
                issueData: {
                    code: gt.invalid_arguments,
                    argumentsError: u
                }
            });
        }
        function i(a, u) {
            return Fm({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Dm(),
                    wp
                ].filter((f)=>!!f),
                issueData: {
                    code: gt.invalid_return_type,
                    returnTypeError: u
                }
            });
        }
        const o = {
            errorMap: r.common.contextualErrorMap
        }, s = r.data;
        return this._def.returns instanceof pd ? Ki(async (...a)=>{
            const u = new Us([]), f = await this._def.args.parseAsync(a, o).catch((p)=>{
                throw u.addIssue(n(a, p)), u;
            }), c = await s(...f);
            return await this._def.returns._def.type.parseAsync(c, o).catch((p)=>{
                throw u.addIssue(i(c, p)), u;
            });
        }) : Ki((...a)=>{
            const u = this._def.args.safeParse(a, o);
            if (!u.success) throw new Us([
                n(a, u.error)
            ]);
            const f = s(...u.data), c = this._def.returns.safeParse(f, o);
            if (!c.success) throw new Us([
                i(f, c.error)
            ]);
            return c.data;
        });
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...t) {
        return new Fy({
            ...this._def,
            args: vu.create(t).rest(mf.create())
        });
    }
    returns(t) {
        return new Fy({
            ...this._def,
            returns: t
        });
    }
    implement(t) {
        return this.parse(t);
    }
    strictImplement(t) {
        return this.parse(t);
    }
    static create(t, r, n) {
        return new Fy({
            args: t || vu.create([]).rest(mf.create()),
            returns: r || mf.create(),
            typeName: tr.ZodFunction,
            ...br(n)
        });
    }
}, Ip = class extends Ir {
    get schema() {
        return this._def.getter();
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        });
    }
};
Ip.create = (e, t)=>new Ip({
        getter: e,
        typeName: tr.ZodLazy,
        ...br(t)
    });
let Bp = class extends Ir {
    _parse(t) {
        if (t.data !== this._def.value) {
            const r = this._getOrReturnCtx(t);
            return Nt(r, {
                received: r.data,
                code: gt.invalid_literal,
                expected: this._def.value
            }), cr;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
    get value() {
        return this._def.value;
    }
};
Bp.create = (e, t)=>new Bp({
        value: e,
        typeName: tr.ZodLiteral,
        ...br(t)
    });
function zC(e, t) {
    return new T0({
        values: e,
        typeName: tr.ZodEnum,
        ...br(t)
    });
}
let T0 = class jx extends Ir {
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Nt(r, {
                expected: qr.joinValues(n),
                received: r.parsedType,
                code: gt.invalid_type
            }), cr;
        }
        if (this._def.values.indexOf(t.data) === -1) {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Nt(r, {
                received: r.data,
                code: gt.invalid_enum_value,
                options: n
            }), cr;
        }
        return Ki(t.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    extract(t) {
        return jx.create(t);
    }
    exclude(t) {
        return jx.create(this.options.filter((r)=>!t.includes(r)));
    }
};
T0.create = zC;
let Op = class extends Ir {
    _parse(t) {
        const r = qr.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
        if (n.parsedType !== Bt.string && n.parsedType !== Bt.number) {
            const i = qr.objectValues(r);
            return Nt(n, {
                expected: qr.joinValues(i),
                received: n.parsedType,
                code: gt.invalid_type
            }), cr;
        }
        if (r.indexOf(t.data) === -1) {
            const i = qr.objectValues(r);
            return Nt(n, {
                received: n.data,
                code: gt.invalid_enum_value,
                options: i
            }), cr;
        }
        return Ki(t.data);
    }
    get enum() {
        return this._def.values;
    }
};
Op.create = (e, t)=>new Op({
        values: e,
        typeName: tr.ZodNativeEnum,
        ...br(t)
    });
let pd = class extends Ir {
    unwrap() {
        return this._def.type;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.promise && r.common.async === !1) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.promise,
            received: r.parsedType
        }), cr;
        const n = r.parsedType === Bt.promise ? r.data : Promise.resolve(r.data);
        return Ki(n.then((i)=>this._def.type.parseAsync(i, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })));
    }
};
pd.create = (e, t)=>new pd({
        type: e,
        typeName: tr.ZodPromise,
        ...br(t)
    });
let Ds = class extends Ir {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === tr.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null;
        if (i.type === "preprocess") {
            const s = i.transform(n.data);
            return n.common.async ? Promise.resolve(s).then((a)=>this._def.schema._parseAsync({
                    data: a,
                    path: n.path,
                    parent: n
                })) : this._def.schema._parseSync({
                data: s,
                path: n.path,
                parent: n
            });
        }
        const o = {
            addIssue: (s)=>{
                Nt(n, s), s.fatal ? r.abort() : r.dirty();
            },
            get path () {
                return n.path;
            }
        };
        if (o.addIssue = o.addIssue.bind(o), i.type === "refinement") {
            const s = (a)=>{
                const u = i.refinement(a, o);
                if (n.common.async) return Promise.resolve(u);
                if (u instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a;
            };
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? cr : (a.status === "dirty" && r.dirty(), s(a.value), {
                    status: r.value,
                    value: a.value
                });
            } else return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then((a)=>a.status === "aborted" ? cr : (a.status === "dirty" && r.dirty(), s(a.value).then(()=>({
                        status: r.value,
                        value: a.value
                    }))));
        }
        if (i.type === "transform") if (n.common.async === !1) {
            const s = this._def.schema._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            if (!zm(s)) return s;
            const a = i.transform(s.value, o);
            if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: r.value,
                value: a
            };
        } else return this._def.schema._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }).then((s)=>zm(s) ? Promise.resolve(i.transform(s.value, o)).then((a)=>({
                    status: r.value,
                    value: a
                })) : s);
        qr.assertNever(i);
    }
};
Ds.create = (e, t, r)=>new Ds({
        schema: e,
        typeName: tr.ZodEffects,
        effect: t,
        ...br(r)
    });
Ds.createWithPreprocess = (e, t, r)=>new Ds({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: tr.ZodEffects,
        ...br(r)
    });
let oc = class extends Ir {
    _parse(t) {
        return this._getType(t) === Bt.undefined ? Ki(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
};
oc.create = (e, t)=>new oc({
        innerType: e,
        typeName: tr.ZodOptional,
        ...br(t)
    });
let kf = class extends Ir {
    _parse(t) {
        return this._getType(t) === Bt.null ? Ki(null) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
};
kf.create = (e, t)=>new kf({
        innerType: e,
        typeName: tr.ZodNullable,
        ...br(t)
    });
let Pp = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        let n = r.data;
        return r.parsedType === Bt.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
};
Pp.create = (e, t)=>new Pp({
        innerType: e,
        typeName: tr.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : ()=>t.default,
        ...br(t)
    });
let Vm = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }, i = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return jm(i) ? i.then((o)=>({
                status: "valid",
                value: o.status === "valid" ? o.value : this._def.catchValue({
                    get error () {
                        return new Us(n.common.issues);
                    },
                    input: n.data
                })
            })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error () {
                    return new Us(n.common.issues);
                },
                input: n.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
};
Vm.create = (e, t)=>new Vm({
        innerType: e,
        typeName: tr.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : ()=>t.catch,
        ...br(t)
    });
let Gm = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.nan) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.nan,
                received: n.parsedType
            }), cr;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
};
Gm.create = (e)=>new Gm({
        typeName: tr.ZodNaN,
        ...br(e)
    });
const Yge = Symbol("zod_brand");
let jC = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    unwrap() {
        return this._def.type;
    }
}, n8 = class HC extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.common.async) return (async ()=>{
            const o = await this._def.in._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return o.status === "aborted" ? cr : o.status === "dirty" ? (r.dirty(), RC(o.value)) : this._def.out._parseAsync({
                data: o.value,
                path: n.path,
                parent: n
            });
        })();
        {
            const i = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i.status === "aborted" ? cr : i.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: n.path,
                parent: n
            });
        }
    }
    static create(t, r) {
        return new HC({
            in: t,
            out: r,
            typeName: tr.ZodPipeline
        });
    }
};
const qC = (e, t = {}, r)=>e ? hd.create().superRefine((n, i)=>{
        var o, s;
        if (!e(n)) {
            const a = typeof t == "function" ? t(n) : typeof t == "string" ? {
                message: t
            } : t, u = (s = (o = a.fatal) !== null && o !== void 0 ? o : r) !== null && s !== void 0 ? s : !0, f = typeof a == "string" ? {
                message: a
            } : a;
            i.addIssue({
                code: "custom",
                ...f,
                fatal: u
            });
        }
    }) : hd.create(), Xge = {
    object: ps.lazycreate
};
var tr;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(tr || (tr = {}));
const Jge = (e, t = {
    message: `Input not instance of ${e.name}`
})=>qC((r)=>r instanceof e, t), KC = dd.create, WC = vp.create, Qge = Gm.create, eye = _p.create, VC = Ep.create, tye = xp.create, rye = Hm.create, nye = Sp.create, iye = Ap.create, oye = hd.create, sye = mf.create, aye = lc.create, cye = qm.create, uye = Tf.create, fye = ps.create, lye = ps.strictCreate, dye = Tp.create, hye = UC.create, pye = kp.create, gye = vu.create, yye = DC.create, mye = Km.create, bye = Wm.create, wye = FC.create, vye = Ip.create, _ye = Bp.create, Eye = T0.create, xye = Op.create, Sye = pd.create, aB = Ds.create, Aye = oc.create, Tye = kf.create, kye = Ds.createWithPreprocess, Iye = n8.create, Bye = ()=>KC().optional(), Oye = ()=>WC().optional(), Pye = ()=>VC().optional(), Nye = {
    string: (e)=>dd.create({
            ...e,
            coerce: !0
        }),
    number: (e)=>vp.create({
            ...e,
            coerce: !0
        }),
    boolean: (e)=>Ep.create({
            ...e,
            coerce: !0
        }),
    bigint: (e)=>_p.create({
            ...e,
            coerce: !0
        }),
    date: (e)=>xp.create({
            ...e,
            coerce: !0
        })
}, Mye = cr;
var qi = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: wp,
    setErrorMap: $ge,
    getErrorMap: Dm,
    makeIssue: Fm,
    EMPTY_PATH: Lge,
    addIssueToContext: Nt,
    ParseStatus: yo,
    INVALID: cr,
    DIRTY: RC,
    OK: Ki,
    isAborted: Cx,
    isDirty: Ux,
    isValid: zm,
    isAsync: jm,
    get util () {
        return qr;
    },
    get objectUtil () {
        return Rx;
    },
    ZodParsedType: Bt,
    getParsedType: au,
    ZodType: Ir,
    ZodString: dd,
    ZodNumber: vp,
    ZodBigInt: _p,
    ZodBoolean: Ep,
    ZodDate: xp,
    ZodSymbol: Hm,
    ZodUndefined: Sp,
    ZodNull: Ap,
    ZodAny: hd,
    ZodUnknown: mf,
    ZodNever: lc,
    ZodVoid: qm,
    ZodArray: Tf,
    ZodObject: ps,
    ZodUnion: Tp,
    ZodDiscriminatedUnion: UC,
    ZodIntersection: kp,
    ZodTuple: vu,
    ZodRecord: DC,
    ZodMap: Km,
    ZodSet: Wm,
    ZodFunction: FC,
    ZodLazy: Ip,
    ZodLiteral: Bp,
    ZodEnum: T0,
    ZodNativeEnum: Op,
    ZodPromise: pd,
    ZodEffects: Ds,
    ZodTransformer: Ds,
    ZodOptional: oc,
    ZodNullable: kf,
    ZodDefault: Pp,
    ZodCatch: Vm,
    ZodNaN: Gm,
    BRAND: Yge,
    ZodBranded: jC,
    ZodPipeline: n8,
    custom: qC,
    Schema: Ir,
    ZodSchema: Ir,
    late: Xge,
    get ZodFirstPartyTypeKind () {
        return tr;
    },
    coerce: Nye,
    any: oye,
    array: uye,
    bigint: eye,
    boolean: VC,
    date: tye,
    discriminatedUnion: hye,
    effect: aB,
    enum: Eye,
    function: wye,
    instanceof: Jge,
    intersection: pye,
    lazy: vye,
    literal: _ye,
    map: mye,
    nan: Qge,
    nativeEnum: xye,
    never: aye,
    null: iye,
    nullable: Tye,
    number: WC,
    object: fye,
    oboolean: Pye,
    onumber: Oye,
    optional: Aye,
    ostring: Bye,
    pipeline: Iye,
    preprocess: kye,
    promise: Sye,
    record: yye,
    set: bye,
    strictObject: lye,
    string: KC,
    symbol: rye,
    transformer: aB,
    tuple: gye,
    undefined: nye,
    union: dye,
    unknown: sye,
    void: cye,
    NEVER: Mye,
    ZodIssueCode: gt,
    quotelessJson: Uge,
    ZodError: Us
});
const GC = qi.string().regex(/^[a-fA-F0-9]$/), Rye = qi.string().regex(/^[a-fA-F0-9]{64}$/), gd = qi.number().min(0).max(4294967295), Cye = qi.bigint(), ZC = qi.instanceof(Uint8Array), Uye = qi.union([
    GC,
    gd,
    qi.string(),
    ZC
]).array(), i8 = qi.union([
    Uye,
    GC,
    ZC
]), $ye = qi.array(i8), YC = qi.object({
    value: qi.union([
        gd,
        Cye
    ]),
    scriptPubKey: i8
}), Lye = qi.object({
    txid: Rye,
    vout: gd,
    scriptSig: i8,
    sequence: gd,
    prevout: YC.optional(),
    witness: $ye
});
qi.object({
    version: gd,
    vin: qi.array(Lye),
    vout: qi.array(YC),
    locktime: gd
});
o3(bb);
const XC = async ({ contentBase64: e, mimeType: t, quantity: r = 1, inscriptions: n, ordinalAddress: i, paymentAddress: o, paymentPublicKey: s, signPsbt: a, dataSourceManager: u, opReturn: f, network: c = ln })=>{
    if (!e && !n) throw new Error("contentBase64 or inscriptions is required");
    if (!u) throw new Error("missing data source");
    if (!u.broadcastTransaction) throw new Error("missing broadcastTransaction");
    const l = await Vre(c), p = We.from(l).toString("hex"), y = n || Array(r).fill({
        content: e,
        mimeType: t
    }), _ = await Dye({
        inscriptions: y,
        paymentAddress: o,
        paymentPublicKey: s,
        privKey: p,
        dataSourceManager: u,
        network: c
    });
    if (!_ || !(_ != null && _.psbtHex)) throw new Error("couldn't get commit tx");
    const A = String(_ == null ? void 0 : _.psbtHex), O = String(_ == null ? void 0 : _.psbtBase64), N = await a({
        tx: A,
        psbtHex: A,
        psbtBase64: O,
        finalize: !0,
        broadcast: !1,
        network: c
    });
    if (!N) throw new Error("sign psbt failed");
    const D = Cr.fromHex((N == null ? void 0 : N.signedPsbtHex) || "").extractTransaction(), H = await u.broadcastTransaction(D.toHex());
    if (!H) throw new Error("commit tx failed");
    return await Fye({
        inscriptions: y,
        ordinalAddress: i,
        privKey: p,
        commitTxId: H,
        dataSourceManager: u,
        opReturn: f
    });
}, Dye = async ({ inscriptions: e, paymentAddress: t, paymentPublicKey: r, privKey: n, dataSourceManager: i, network: o })=>{
    const s = e.length, a = e.reduce((Q, G)=>Q + We.from(G.content).length, 0);
    if (a > 39e4) throw new Error("Content size is too large, must be less than 390kb");
    if (!i) throw new Error("missing data source");
    if (!i.getRecommendedFees) throw new Error("missing getRecommendedFees");
    if (!i.getAddressUtxos) throw new Error("missing getAddressUtxos");
    const { fastFee: u } = await i.getRecommendedFees(), f = CM(String(n), !0), c = new Cr({
        network: Dr(o)
    }), { inscriberAddress: l } = zye(f, e, o), p = 5 * 34 * s, y = Math.floor(p * u * s), _ = Math.floor(a * u / 3) + 1e3 + 546 * s, A = Math.floor(y + _), N = (await i.getAddressUtxos(t)).filter((Q)=>Q.value > 3e3).sort((Q, G)=>G.value - Q.value), U = jb(N);
    if (U === 0) throw new Error("insufficient funds");
    if (U < A) throw new Error("insufficient funds");
    let D = 0;
    const H = hs(t, Dr(o));
    let K = 0;
    for await (const Q of N){
        const G = Jb(t, o);
        if (c.addInput({
            hash: Q.txid,
            index: Q.vout,
            witnessUtxo: {
                value: BigInt(Q.value),
                script: H
            }
        }), G === df && c.updateInput(K, {
            // biome-ignore lint/style/noNonNullAssertion: <explanation>
            tapInternalKey: Mo(We.from(r, "hex"))
        }), G === Xp) {
            const R = d0(r, o);
            c.updateInput(K, {
                redeemScript: R
            });
        }
        if (K++, D += Q.value, D > A) break;
    }
    const re = D - A;
    return c.addOutput({
        value: BigInt(_),
        address: l
    }), re > 546 && c.addOutput({
        value: BigInt(re),
        address: t
    }), {
        psbtHex: c.toHex(),
        psbtBase64: c.toBase64()
    };
}, Fye = async ({ inscriptions: e, ordinalAddress: t, commitTxId: r, privKey: n, dataSourceManager: i, opReturn: o, isDry: s })=>{
    const a = lfe(n), u = CM(n, !0), f = JC(u, e), c = Lm.encodeScript(f), [l, p] = Lm.getPubKey(u, {
        target: c
    });
    if (!i) throw new Error("missing data source");
    if (!i.waitForTransaction) throw new Error("missing waitForTransaction");
    if (!i.getOutputValueByVOutIndex) throw new Error("missing waitForTransaction");
    if (!i.broadcastTransaction) throw new Error("missing broadcastTransaction");
    if (!await i.waitForTransaction(String(r))) throw new Error("ERROR WAITING FOR COMMIT TX");
    const _ = await i.getOutputValueByVOutIndex(r, 0);
    if (_ === 0 || !_) throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const A = lu.create({
        vin: [
            {
                txid: r,
                vout: 0,
                prevout: {
                    value: _,
                    scriptPubKey: [
                        "OP_1",
                        l
                    ]
                }
            }
        ],
        vout: [
            ...Array(e.length).fill({
                value: 546,
                scriptPubKey: AC.toScriptPubKey(t)
            })
        ],
        ...o ? {
            vout: [
                {
                    value: 0,
                    scriptPubKey: [
                        "OP_RETURN",
                        o
                    ]
                }
            ]
        } : {}
    }), O = Nge.taproot.sign(a, A, 0, {
        extension: c
    });
    return A.vin[0].witness = [
        O,
        f,
        p
    ], s ? lu.util.getTxid(A) : await i.broadcastTransaction(lu.encode(A).hex);
}, JC = (e, t)=>{
    const r = new TextEncoder(), n = r.encode("ord"), i = 546, o = (a, u)=>{
        let f;
        if (u === Kre) {
            const l = We.from(a, "base64").toString("utf-8");
            f = We.from(l, "utf-8");
        } else f = We.from(a, "base64");
        const c = [];
        for(let l = 0; l < f.length; l += 520)c.push(f.slice(l, l + 520));
        return c;
    }, s = [
        e,
        "OP_CHECKSIG"
    ];
    return t.forEach((a, u)=>{
        const { content: f, mimeType: c } = a, l = o(f, c);
        if (s.push("OP_0", "OP_IF", n, "01", r.encode(c), "OP_0"), u > 0) {
            const p = i * (u + 1), y = We.from([
                p
            ]);
            s.push(We.from([
                2
            ])), s.push(y);
        }
        s.push(...l.map((p)=>p), "OP_ENDIF");
    }), s;
}, zye = (e, t, r = ln)=>{
    const n = JC(e, t), i = Lm.encodeScript(n), [o] = Lm.getPubKey(e, {
        target: i
    });
    return {
        inscriberAddress: AC.p2tr.fromPubKey(o, VQ(r)),
        tpubkey: o,
        tapleaf: i
    };
};
var jye = {}, k0 = {};
Object.defineProperty(k0, "__esModule", {
    value: !0
});
k0.isRunestone = void 0;
function Hye(e) {
    return !("flaws" in e);
}
k0.isRunestone = Hye;
var Kd = {};
Object.defineProperty(Kd, "__esModule", {
    value: !0
});
Kd.Flaw = void 0;
var cB;
(function(e) {
    e[e.EDICT_OUTPUT = 0] = "EDICT_OUTPUT", e[e.EDICT_RUNE_ID = 1] = "EDICT_RUNE_ID", e[e.INVALID_SCRIPT = 2] = "INVALID_SCRIPT", e[e.OPCODE = 3] = "OPCODE", e[e.SUPPLY_OVERFLOW = 4] = "SUPPLY_OVERFLOW", e[e.TRAILING_INTEGERS = 5] = "TRAILING_INTEGERS", e[e.TRUNCATED_FIELD = 6] = "TRUNCATED_FIELD", e[e.UNRECOGNIZED_EVEN_TAG = 7] = "UNRECOGNIZED_EVEN_TAG", e[e.UNRECOGNIZED_FLAG = 8] = "UNRECOGNIZED_FLAG", e[e.VARINT = 9] = "VARINT";
})(cB || (Kd.Flaw = cB = {}));
var Wd = {};
Object.defineProperty(Wd, "__esModule", {
    value: !0
});
Wd.RuneId = void 0;
const Yc = wi, sa = Qn;
class Xh {
    constructor(t, r){
        this.block = t, this.tx = r;
    }
    static new(t, r) {
        const n = new Xh(t, r);
        return n.block === 0n && n.tx > 0 ? Yc.None : (0, Yc.Some)(n);
    }
    static sort(t) {
        return [
            ...t
        ].sort((r, n)=>Number(r.block - n.block || r.tx - n.tx));
    }
    delta(t) {
        const r = sa.u64.checkedSub(t.block, this.block);
        if (r.isNone()) return Yc.None;
        const n = r.unwrap();
        let i;
        if (n === 0n) {
            const o = sa.u32.checkedSub(t.tx, this.tx);
            if (o.isNone()) return Yc.None;
            i = o.unwrap();
        } else i = t.tx;
        return (0, Yc.Some)([
            (0, sa.u128)(n),
            (0, sa.u128)(i)
        ]);
    }
    next(t, r) {
        const n = sa.u128.tryIntoU64(t), i = sa.u128.tryIntoU32(r);
        if (n.isNone() || i.isNone()) return Yc.None;
        const o = n.unwrap(), s = i.unwrap(), a = sa.u64.checkedAdd(this.block, o);
        if (a.isNone()) return Yc.None;
        let u;
        if (o === 0n) {
            const f = sa.u32.checkedAdd(this.tx, s);
            if (f.isNone()) return Yc.None;
            u = f.unwrap();
        } else u = s;
        return Xh.new(a.unwrap(), u);
    }
    toString() {
        return `${this.block}:${this.tx}`;
    }
    static fromString(t) {
        const r = t.split(":");
        if (r.length !== 2) throw new Error(`invalid rune ID: ${t}`);
        const [n, i] = r;
        if (!/^\d+$/.test(n) || !/^\d+$/.test(i)) throw new Error(`invalid rune ID: ${t}`);
        return new Xh((0, sa.u64)(BigInt(n)), (0, sa.u32)(BigInt(i)));
    }
}
Wd.RuneId = Xh;
var o8 = {}, w1 = {};
Object.defineProperty(w1, "__esModule", {
    value: !0
});
w1.Instruction = void 0;
var uB;
(function(e) {
    function t(n) {
        return typeof n == "number";
    }
    e.isNumber = t;
    function r(n) {
        return typeof n != "number";
    }
    e.isBuffer = r;
})(uB || (w1.Instruction = uB = {}));
var v1 = {}, _1 = {};
Object.defineProperty(_1, "__esModule", {
    value: !0
});
_1.Edict = void 0;
const my = wi, qye = Qn;
var fB;
(function(e) {
    function t(r, n, i, o) {
        if (n.block === 0n && n.tx > 0n) return my.None;
        const s = qye.u128.tryIntoU32(o);
        if (s.isNone()) return my.None;
        const a = s.unwrap();
        return a > r ? my.None : (0, my.Some)({
            id: n,
            amount: i,
            output: a
        });
    }
    e.fromIntegers = t;
})(fB || (_1.Edict = fB = {}));
Object.defineProperty(v1, "__esModule", {
    value: !0
});
v1.Message = void 0;
const Kye = _1, by = Kd, cE = Qn, Wye = Wd, Vye = Ff;
class s8 {
    constructor(t, r, n){
        this.flaws = t, this.edicts = r, this.fields = n;
    }
    static fromIntegers(t, r) {
        const n = [], i = /* @__PURE__ */ new Map(), o = [];
        for (const s of [
            ...Array(Math.ceil(r.length / 2)).keys()
        ].map((a)=>a * 2)){
            const a = r[s];
            if ((0, cE.u128)(Vye.Tag.BODY) === a) {
                let c = new Wye.RuneId((0, cE.u64)(0), (0, cE.u32)(0));
                const l = 4, p = r.slice(s + 1);
                for(let y = 0; y < p.length; y += l){
                    const _ = p.slice(y, y + l);
                    if (_.length !== l) {
                        o.push(by.Flaw.TRAILING_INTEGERS);
                        break;
                    }
                    const A = c.next(_[0], _[1]);
                    if (A.isNone()) {
                        o.push(by.Flaw.EDICT_RUNE_ID);
                        break;
                    }
                    const O = A.unwrap(), N = Kye.Edict.fromIntegers(t, O, _[2], _[3]);
                    if (N.isNone()) {
                        o.push(by.Flaw.EDICT_OUTPUT);
                        break;
                    }
                    const U = N.unwrap();
                    c = O, n.push(U);
                }
                break;
            }
            const u = r[s + 1];
            if (u === void 0) {
                o.push(by.Flaw.TRUNCATED_FIELD);
                break;
            }
            const f = i.get(a) ?? [];
            f.push(u), i.set(a, f);
        }
        return new s8(o, n, i);
    }
}
v1.Message = s8;
var E1 = {};
Object.defineProperty(E1, "__esModule", {
    value: !0
});
E1.Cenotaph = void 0;
const lB = wi;
class Gye {
    constructor(t, r = lB.None, n = lB.None){
        this.flaws = t, this.etching = r, this.mint = n;
    }
}
E1.Cenotaph = Gye;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Runestone = e.isValidPayload = e.MAX_SPACERS = void 0;
    const t = hn, r = Ud, n = b0, i = Ff, o = Qn, s = wi, a = Fd, u = Ld, f = w1, c = Wd, l = uc, p = v1, y = Kd, _ = E1;
    e.MAX_SPACERS = 134217727;
    function A(N) {
        return We.isBuffer(N);
    }
    e.isValidPayload = A;
    class O {
        constructor(U, D, H, K){
            this.mint = U, this.pointer = D, this.edicts = H, this.etching = K;
        }
        static decipher(U) {
            const D = O.payload(U);
            if (D.isNone()) return s.None;
            const H = D.unwrap();
            if (!A(H)) return (0, s.Some)(new _.Cenotaph([
                H
            ]));
            const K = O.integers(H);
            if (K.isNone()) return (0, s.Some)(new _.Cenotaph([
                y.Flaw.VARINT
            ]));
            const { flaws: re, edicts: Q, fields: G } = p.Message.fromIntegers(U.vout.length, K.unwrap());
            let R = i.Tag.take(i.Tag.FLAGS, G, 1, ([m])=>(0, s.Some)(m)).unwrapOr((0, o.u128)(0));
            const X = u.Flag.take(R, u.Flag.ETCHING), $ = X.set;
            R = X.flags;
            const S = $ ? (()=>{
                const m = i.Tag.take(i.Tag.DIVISIBILITY, G, 1, ([ce])=>o.u128.tryIntoU8(ce).andThen((he)=>he <= t.MAX_DIVISIBILITY ? (0, s.Some)(he) : s.None)), E = i.Tag.take(i.Tag.RUNE, G, 1, ([ce])=>(0, s.Some)(new a.Rune(ce))), T = i.Tag.take(i.Tag.SPACERS, G, 1, ([ce])=>o.u128.tryIntoU32(ce).andThen((he)=>he <= e.MAX_SPACERS ? (0, s.Some)(he) : s.None)), I = i.Tag.take(i.Tag.SYMBOL, G, 1, ([ce])=>o.u128.tryIntoU32(ce).andThen((he)=>{
                        try {
                            return (0, s.Some)(String.fromCodePoint(Number(he)));
                        } catch  {
                            return s.None;
                        }
                    })), P = u.Flag.take(R, u.Flag.TERMS), k = P.set;
                R = P.flags;
                const L = k ? (()=>{
                    const ce = i.Tag.take(i.Tag.AMOUNT, G, 1, ([ye])=>(0, s.Some)(ye)), he = i.Tag.take(i.Tag.CAP, G, 1, ([ye])=>(0, s.Some)(ye)), ee = [
                        i.Tag.take(i.Tag.OFFSET_START, G, 1, ([ye])=>o.u128.tryIntoU64(ye)),
                        i.Tag.take(i.Tag.OFFSET_END, G, 1, ([ye])=>o.u128.tryIntoU64(ye))
                    ], ae = [
                        i.Tag.take(i.Tag.HEIGHT_START, G, 1, ([ye])=>o.u128.tryIntoU64(ye)),
                        i.Tag.take(i.Tag.HEIGHT_END, G, 1, ([ye])=>o.u128.tryIntoU64(ye))
                    ];
                    return (0, s.Some)({
                        amount: ce,
                        cap: he,
                        offset: ee,
                        height: ae
                    });
                })() : s.None, j = i.Tag.take(i.Tag.PREMINE, G, 1, ([ce])=>(0, s.Some)(ce)), ie = u.Flag.take(R, u.Flag.TURBO), ue = X.set;
                return R = ie.flags, (0, s.Some)(new r.Etching(m, E, T, I, L, j, ue));
            })() : s.None, w = i.Tag.take(i.Tag.MINT, G, 2, ([m, E])=>{
                const T = o.u128.tryIntoU64(m), I = o.u128.tryIntoU32(E);
                return T.isNone() || I.isNone() ? s.None : c.RuneId.new(T.unwrap(), I.unwrap());
            }), g = i.Tag.take(i.Tag.POINTER, G, 1, ([m])=>o.u128.tryIntoU32(m).andThen((E)=>E < U.vout.length ? (0, s.Some)(E) : s.None));
            return S.map((m)=>m.supply.isNone()).unwrapOr(!1) && re.push(y.Flaw.SUPPLY_OVERFLOW), R !== 0n && re.push(y.Flaw.UNRECOGNIZED_FLAG), [
                ...G.keys()
            ].find((m)=>m % 2n === 0n) !== void 0 && re.push(y.Flaw.UNRECOGNIZED_EVEN_TAG), re.length !== 0 ? (0, s.Some)(new _.Cenotaph(re, S.andThen((m)=>m.rune), w)) : (0, s.Some)(new O(w, g, Q, S));
        }
        encipher() {
            const U = [];
            if (this.etching.isSome()) {
                const K = this.etching.unwrap();
                let re = (0, o.u128)(0);
                if (re = u.Flag.set(re, u.Flag.ETCHING), K.terms.isSome() && (re = u.Flag.set(re, u.Flag.TERMS)), K.turbo && (re = u.Flag.set(re, u.Flag.TURBO)), U.push(i.Tag.encode(i.Tag.FLAGS, [
                    re
                ])), U.push(i.Tag.encodeOptionInt(i.Tag.RUNE, K.rune.map((Q)=>Q.value))), U.push(i.Tag.encodeOptionInt(i.Tag.DIVISIBILITY, K.divisibility.map(o.u128))), U.push(i.Tag.encodeOptionInt(i.Tag.SPACERS, K.spacers.map(o.u128))), U.push(i.Tag.encodeOptionInt(i.Tag.SYMBOL, K.symbol.map((Q)=>(0, o.u128)(Q.codePointAt(0))))), U.push(i.Tag.encodeOptionInt(i.Tag.PREMINE, K.premine)), K.terms.isSome()) {
                    const Q = K.terms.unwrap();
                    U.push(i.Tag.encodeOptionInt(i.Tag.AMOUNT, Q.amount)), U.push(i.Tag.encodeOptionInt(i.Tag.CAP, Q.cap)), U.push(i.Tag.encodeOptionInt(i.Tag.HEIGHT_START, Q.height[0])), U.push(i.Tag.encodeOptionInt(i.Tag.HEIGHT_END, Q.height[1])), U.push(i.Tag.encodeOptionInt(i.Tag.OFFSET_START, Q.offset[0])), U.push(i.Tag.encodeOptionInt(i.Tag.OFFSET_END, Q.offset[1]));
                }
            }
            if (this.mint.isSome()) {
                const K = this.mint.unwrap();
                U.push(i.Tag.encode(i.Tag.MINT, [
                    K.block,
                    K.tx
                ].map(o.u128)));
            }
            if (U.push(i.Tag.encodeOptionInt(i.Tag.POINTER, this.pointer.map(o.u128))), this.edicts.length) {
                U.push(o.u128.encodeVarInt((0, o.u128)(i.Tag.BODY)));
                const K = [
                    ...this.edicts
                ].sort((Q, G)=>Number(Q.id.block - G.id.block || Q.id.tx - G.id.tx));
                let re = new c.RuneId((0, o.u64)(0), (0, o.u32)(0));
                for (const Q of K){
                    const [G, R] = re.delta(Q.id).unwrap();
                    U.push(o.u128.encodeVarInt(G)), U.push(o.u128.encodeVarInt(R)), U.push(o.u128.encodeVarInt(Q.amount)), U.push(o.u128.encodeVarInt((0, o.u128)(Q.output))), re = Q.id;
                }
            }
            const D = [];
            D.push(t.OP_RETURN), D.push(t.MAGIC_NUMBER);
            const H = We.concat(U);
            for(let K = 0; K < H.length; K += t.MAX_SCRIPT_ELEMENT_SIZE)D.push(H.subarray(K, K + t.MAX_SCRIPT_ELEMENT_SIZE));
            return l.script.compile(D);
        }
        static payload(U) {
            for (const D of U.vout){
                const H = l.script.decompile(We.from(D.scriptPubKey.hex, "hex"));
                if (H === null) throw new Error("unable to decompile");
                let K = H.next();
                if (K.done || K.value !== t.OP_RETURN || (K = H.next(), K.done || f.Instruction.isBuffer(K.value) || K.value !== t.MAGIC_NUMBER)) continue;
                let re = [];
                do {
                    if (K = H.next(), K.done) {
                        if (!K.value) return (0, s.Some)(y.Flaw.INVALID_SCRIPT);
                        break;
                    }
                    const Q = K.value;
                    if (f.Instruction.isBuffer(Q)) re.push(Q);
                    else return (0, s.Some)(y.Flaw.OPCODE);
                }while (!0)
                return (0, s.Some)(We.concat(re));
            }
            return s.None;
        }
        static integers(U) {
            const D = [], H = new n.SeekBuffer(U);
            for(; !H.isFinished();){
                const K = o.u128.decodeVarInt(H);
                if (K.isNone()) return s.None;
                D.push(K.unwrap());
            }
            return (0, s.Some)(D);
        }
    }
    e.Runestone = O;
})(o8);
var QC = {}, Np = {}, I0 = {};
Object.defineProperty(I0, "__esModule", {
    value: !0
});
I0.RuneLocation = void 0;
var dB;
(function(e) {
    function t(r) {
        return `${r.block}:${r.tx}`;
    }
    e.toString = t;
})(dB || (I0.RuneLocation = dB = {}));
Object.defineProperty(Np, "__esModule", {
    value: !0
});
Np.RuneUpdater = void 0;
const wh = k0, zy = hn, mr = Qn, ki = wi, hB = Fd, Zye = o8, Yye = uc, pB = Dd, Wa = I0;
function uE(e) {
    return e && We.from(e, "hex")[0] === zy.OP_RETURN;
}
class Xye {
    constructor(t, r, n, i, o){
        this.reorg = n, this._storage = i, this._rpc = o, this.etchings = [], this.utxoBalances = [], this.spentBalances = [], this._mintCountsByRuneLocation = /* @__PURE__ */ new Map(), this._burnedBalancesByRuneLocation = /* @__PURE__ */ new Map(), this.block = {
            height: r.height,
            hash: r.hash,
            previousblockhash: r.previousblockhash,
            time: r.time
        }, this._minimum = hB.Rune.getMinimumAtHeight(t, (0, mr.u128)(r.height));
    }
    get mintCounts() {
        return [
            ...this._mintCountsByRuneLocation.values()
        ];
    }
    get burnedBalances() {
        return [
            ...this._burnedBalancesByRuneLocation.values()
        ];
    }
    async indexRunes(t, r) {
        const n = Zye.Runestone.decipher(t), i = await this.unallocated(t), o = [
            ...new Array(t.vout.length)
        ].map(()=>/* @__PURE__ */ new Map());
        function s(c) {
            const l = Wa.RuneLocation.toString(c), p = i.get(l) ?? {
                runeId: c,
                amount: 0n
            };
            return i.set(l, p), p;
        }
        function a(c, l) {
            const p = Wa.RuneLocation.toString(l), y = o[c].get(p) ?? {
                runeId: l,
                amount: 0n
            };
            return o[c].set(p, y), y;
        }
        if (n.isSome()) {
            const c = n.unwrap(), l = c.mint;
            if (l.isSome()) {
                const y = l.unwrap(), _ = {
                    block: Number(y.block),
                    tx: Number(y.tx)
                }, A = await this.mint(_, t.txid);
                if (A.isSome()) {
                    const O = A.unwrap(), N = s(_);
                    N.amount = mr.u128.checkedAddThrow((0, mr.u128)(N.amount), (0, mr.u128)(O));
                }
            }
            const p = await this.etched(r, t, c);
            if ((0, wh.isRunestone)(c)) {
                const y = c;
                if (p.isSome()) {
                    const _ = p.unwrap(), A = s(_.runeId);
                    A.amount = mr.u128.checkedAddThrow((0, mr.u128)(A.amount), y.etching.unwrap().premine.unwrapOr((0, mr.u128)(0)));
                }
                for (const { id: _, amount: A, output: O } of [
                    ...y.edicts
                ]){
                    if (O > t.vout.length) throw new Error("Runestone edict output should never exceed transaction output size");
                    if (_.block === 0n && _.tx === 0n && p.isNone()) continue;
                    const N = _.block === 0n && _.tx === 0n ? p.unwrap().runeId : {
                        block: Number(_.block),
                        tx: Number(_.tx)
                    }, U = Wa.RuneLocation.toString(N), D = i.get(U);
                    if (D === void 0) continue;
                    let H = (K, re)=>{
                        if (K > 0n) {
                            const Q = a(re, N);
                            D.amount = mr.u128.checkedSubThrow((0, mr.u128)(D.amount), K), Q.amount = mr.u128.checkedAddThrow((0, mr.u128)(Q.amount), K);
                        }
                    };
                    if (Number(O) === t.vout.length) {
                        const K = [
                            ...t.vout.entries()
                        ].filter(([re, Q])=>!uE(Q.scriptPubKey.hex)).map(([re])=>re);
                        if (K.length !== 0) if (A === 0n) {
                            const re = (0, mr.u128)((0, mr.u128)(D.amount) / (0, mr.u128)(K.length)), Q = (0, mr.u128)(D.amount) % (0, mr.u128)(K.length);
                            for (const [G, R] of K.entries())H(G < Q ? mr.u128.checkedAddThrow(re, (0, mr.u128)(1)) : re, R);
                        } else for (const re of K)H(A < D.amount ? A : (0, mr.u128)(D.amount), re);
                    } else H(A !== 0n && A < (0, mr.u128)(D.amount) ? A : (0, mr.u128)(D.amount), Number(O));
                }
            }
            if (p.isSome()) {
                const { runeId: y, rune: _ } = p.unwrap();
                this.createEtching(t.txid, c, y, _);
            }
        }
        const u = /* @__PURE__ */ new Map();
        function f(c) {
            const l = Wa.RuneLocation.toString(c), p = u.get(l) ?? {
                runeId: c,
                amount: 0n
            };
            return u.set(l, p), p;
        }
        if (n.isSome() && !(0, wh.isRunestone)(n.unwrap())) for (const c of i.values()){
            const l = f(c.runeId);
            l.amount = mr.u128.checkedAddThrow((0, mr.u128)(l.amount), (0, mr.u128)(c.amount));
        }
        else {
            const l = n.map((p)=>{
                if (!(0, wh.isRunestone)(p)) throw new Error("unreachable");
                return p.pointer;
            }).unwrapOr(ki.None).map((p)=>Number(p)).inspect((p)=>{
                if (p < 0 || p >= o.length) throw new Error("Pointer is invalid");
            }).orElse(()=>{
                const p = [
                    ...t.vout.entries()
                ].find(([y, _])=>!uE(_.scriptPubKey.hex));
                return p !== void 0 ? (0, ki.Some)(p[0]) : ki.None;
            });
            if (l.isSome()) {
                const p = l.unwrap();
                for (const y of i.values())if (y.amount > 0) {
                    const _ = a(p, y.runeId);
                    _.amount = mr.u128.checkedAddThrow((0, mr.u128)(_.amount), (0, mr.u128)(y.amount));
                }
            } else for (const [p, y] of i)if (y.amount > 0) {
                const _ = f(y.runeId);
                u.set(p, {
                    runeId: y.runeId,
                    amount: mr.u128.checkedAddThrow((0, mr.u128)(_.amount), (0, mr.u128)(y.amount))
                });
            }
        }
        for (const [c, l] of o.entries()){
            if (l.size === 0) continue;
            const p = t.vout[c];
            if (uE(p.scriptPubKey.hex)) {
                for (const [_, A] of l){
                    const O = f(A.runeId);
                    O.amount = mr.u128.checkedAddThrow((0, mr.u128)(O.amount), (0, mr.u128)(A.amount));
                }
                continue;
            }
            const y = new Map(this.etchings.map((_)=>[
                    Wa.RuneLocation.toString(_.runeId),
                    _
                ]));
            for (const _ of l.values()){
                const A = Wa.RuneLocation.toString(_.runeId), O = y.get(A) ?? await this._storage.getEtching(A);
                if (O === null) throw new Error("Rune should exist at this point");
                this.utxoBalances.push({
                    runeId: _.runeId,
                    runeTicker: O.runeTicker,
                    amount: _.amount,
                    scriptPubKey: We.from(p.scriptPubKey.hex),
                    txid: t.txid,
                    vout: c,
                    address: p.scriptPubKey.address
                });
            }
        }
        for (const [c, l] of u)this._burnedBalancesByRuneLocation.set(c, l);
    }
    async etched(t, r, n) {
        let i;
        if ((0, wh.isRunestone)(n)) {
            const s = n;
            if (s.etching.isNone()) return ki.None;
            i = s.etching.unwrap().rune;
        } else {
            const s = n;
            if (s.etching.isNone()) return ki.None;
            i = s.etching;
        }
        let o;
        if (i.isSome()) {
            if (o = i.unwrap(), o.value < this._minimum.value || o.reserved || this.etchings.find((u)=>pB.SpacedRune.fromString(u.runeName).rune.toString() === o.toString())) return ki.None;
            const s = await this._storage.getRuneLocation(o.toString());
            if (s && s.block < this.block.height || !await this.txCommitsToRune(r, o)) return ki.None;
        } else o = hB.Rune.getReserved((0, mr.u64)(this.block.height), (0, mr.u32)(t));
        return (0, ki.Some)({
            runeId: {
                block: this.block.height,
                tx: t
            },
            rune: o
        });
    }
    async mint(t, r) {
        var N, U, D, H;
        const n = Wa.RuneLocation.toString(t), o = new Map(this.etchings.map((K)=>[
                Wa.RuneLocation.toString(K.runeId),
                K
            ])).get(n) ?? await this._storage.getEtching(n);
        if (o === null || !o.valid || !o.terms) return ki.None;
        const s = o.terms, a = ((N = s.offset) == null ? void 0 : N.start) !== void 0 ? o.runeId.block + Number(s.offset.start) : null, u = ((U = s.height) == null ? void 0 : U.start) !== void 0 ? Number(s.height.start) : null, f = a !== null || u !== null ? Math.max(a ?? -1 / 0, u ?? -1 / 0) : null;
        if (f !== null && this.block.height < f) return ki.None;
        const c = ((D = s.offset) == null ? void 0 : D.end) !== void 0 ? o.runeId.block + Number(s.offset.end) : null, l = ((H = s.height) == null ? void 0 : H.end) !== void 0 ? Number(s.height.end) : null, p = c !== null || l !== null ? Math.max(c ?? -1 / 0, l ?? -1 / 0) : null;
        if (p !== null && this.block.height >= p) return ki.None;
        const y = s.cap ?? 0n, _ = this._mintCountsByRuneLocation.get(n) ?? {
            mint: t,
            count: 0
        };
        if (this._mintCountsByRuneLocation.set(n, _), _.count + await this._storage.getValidMintCount(n, this.block.height - 1) >= y) return ki.None;
        const O = s.amount ?? 0n;
        return _.count++, (0, ki.Some)(O);
    }
    async unallocated(t) {
        const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
        for (const i of this.utxoBalances){
            const o = `${i.txid}:${i.vout}`, s = n.get(o) ?? [];
            s.push(i), n.set(o, s);
        }
        for (const i of t.vin){
            if ("coinbase" in i) continue;
            const o = n.get(`${i.txid}:${i.vout}`) ?? await this._storage.getUtxoBalance(i.txid, i.vout);
            for (const s of o){
                const a = s.runeId, u = Wa.RuneLocation.toString(a), f = r.get(u) ?? {
                    runeId: a,
                    amount: 0n
                };
                r.set(u, f), f.amount = mr.u128.checkedAddThrow((0, mr.u128)(f.amount), (0, mr.u128)(s.amount)), this.spentBalances.push({
                    txid: i.txid,
                    vout: i.vout,
                    address: s.address,
                    scriptPubKey: s.scriptPubKey,
                    runeId: s.runeId,
                    runeTicker: s.runeTicker,
                    amount: s.amount,
                    spentTxid: t.txid
                });
            }
        }
        return r;
    }
    async txCommitsToRune(t, r) {
        const n = r.commitment;
        for (const i of t.vin){
            if ("coinbase" in i) continue;
            const o = i.txinwitness.map((c)=>We.from(c, "hex")), s = o[o.length - 1], a = o.length >= 2 && s[0] === zy.TAPROOT_ANNEX_PREFIX ? 3 : 2;
            if (a > o.length) continue;
            const u = o[o.length - a];
            if (u === void 0) continue;
            const f = Yye.script.decompile(u);
            for (const c of f){
                if (!We.isBuffer(c) || We.compare(c, n) !== 0) continue;
                const l = await this._rpc.getrawtransaction({
                    txid: i.txid,
                    verbose: !0
                });
                if (l.error !== null) throw l.error;
                const p = l.result;
                if (!(p.vout[i.vout].scriptPubKey.type === zy.TAPROOT_SCRIPT_PUBKEY_TYPE)) continue;
                const _ = await this._rpc.getblock({
                    blockhash: p.blockhash
                });
                if (_.error !== null) throw _.error;
                const A = _.result.height;
                if (mr.u128.checkedSubThrow((0, mr.u128)(this.block.height), (0, mr.u128)(A)) + 1n >= zy.COMMIT_CONFIRMATIONS) return !0;
            }
        }
        return !1;
    }
    createEtching(t, r, n, i) {
        if ((0, wh.isRunestone)(r)) {
            const { divisibility: o, terms: s, premine: a, spacers: u, symbol: f } = r.etching.unwrap();
            this.etchings.push({
                valid: !0,
                runeTicker: i.toString(),
                runeName: new pB.SpacedRune(i, Number(u.map(Number).unwrapOr(0))).toString(),
                runeId: n,
                txid: t,
                ...o.isSome() ? {
                    divisibility: o.map(Number).unwrap()
                } : {},
                ...a.isSome() ? {
                    premine: a.unwrap()
                } : {},
                ...f.isSome() ? {
                    symbol: f.unwrap()
                } : {},
                ...s.isSome() ? {
                    terms: (()=>{
                        const c = s.unwrap();
                        return {
                            ...c.amount.isSome() ? {
                                amount: c.amount.unwrap()
                            } : {},
                            ...c.cap.isSome() ? {
                                cap: c.cap.unwrap()
                            } : {},
                            ...c.height.filter((l)=>l.isSome()).length ? {
                                height: {
                                    ...c.height[0].isSome() ? {
                                        start: c.height[0].unwrap()
                                    } : {},
                                    ...c.height[1].isSome() ? {
                                        end: c.height[1].unwrap()
                                    } : {}
                                }
                            } : {},
                            ...c.offset.filter((l)=>l.isSome()).length ? {
                                offset: {
                                    ...c.offset[0].isSome() ? {
                                        start: c.offset[0].unwrap()
                                    } : {},
                                    ...c.offset[1].isSome() ? {
                                        end: c.offset[1].unwrap()
                                    } : {}
                                }
                            } : {}
                        };
                    })()
                } : {}
            });
        } else this.etchings.push({
            valid: !1,
            runeId: n,
            txid: t,
            runeTicker: i.toString(),
            runeName: i.toString()
        });
    }
}
Np.RuneUpdater = Xye;
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(u, f, c, l) {
        l === void 0 && (l = c);
        var p = Object.getOwnPropertyDescriptor(f, c);
        (!p || ("get" in p ? !f.__esModule : p.writable || p.configurable)) && (p = {
            enumerable: !0,
            get: function() {
                return f[c];
            }
        }), Object.defineProperty(u, l, p);
    } : function(u, f, c, l) {
        l === void 0 && (l = c), u[l] = f[c];
    }), r = Ge && Ge.__exportStar || function(u, f) {
        for(var c in u)c !== "default" && !Object.prototype.hasOwnProperty.call(f, c) && t(f, u, c);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RunestoneIndexer = e.RuneUpdater = void 0;
    const n = zf, i = Np, o = Qn;
    r(I0, e);
    var s = Np;
    Object.defineProperty(e, "RuneUpdater", {
        enumerable: !0,
        get: function() {
            return s.RuneUpdater;
        }
    });
    class a {
        constructor(f){
            this._started = !1, this._updateInProgress = !1, this._rpc = f.bitcoinRpcClient, this._storage = f.storage, this._network = f.network;
        }
        async start() {
            this._started || (await this._storage.connect(), this._started = !0, this._network === n.Network.MAINNET && this._storage.seedEtchings([
                {
                    runeTicker: "UNCOMMONGOODS",
                    runeName: "UNCOMMON•GOODS",
                    runeId: {
                        block: 1,
                        tx: 0
                    },
                    txid: "0000000000000000000000000000000000000000000000000000000000000000",
                    valid: !0,
                    symbol: "⧉",
                    terms: {
                        amount: 1n,
                        cap: o.u128.MAX,
                        height: {
                            start: 840000n,
                            end: 1050000n
                        }
                    }
                }
            ]));
        }
        async stop() {
            this._started && (await this._storage.disconnect(), this._started = !1);
        }
        async updateRuneUtxoBalances() {
            if (!this._started) throw new Error("Runestone indexer is not started");
            if (!this._updateInProgress) {
                this._updateInProgress = !0;
                try {
                    await this.updateRuneUtxoBalancesImpl();
                } finally{
                    this._updateInProgress = !1;
                }
            }
        }
        async updateRuneUtxoBalancesImpl() {
            const f = await this._storage.getCurrentBlock();
            if (f) {
                const p = [];
                let y = f.height, _ = (await this._rpc.getblockhash({
                    height: y
                })).result, A = f.hash;
                for(; A !== _;)_ && p.push(_), y--, _ = (await this._rpc.getblockhash({
                    height: y
                })).result, A = await this._storage.getBlockhash(y);
                p.reverse();
                for (const O of p){
                    const N = await this._rpc.getblock({
                        blockhash: O,
                        verbosity: 2
                    });
                    if (N.error !== null) throw N.error;
                    const U = N.result, D = new i.RuneUpdater(this._network, U, !0, this._storage, this._rpc);
                    for (const [H, K] of U.tx.entries())await D.indexRunes(K, H);
                    await this._storage.saveBlockIndex(D);
                }
            }
            let c = Math.max(n.Network.getFirstRuneHeight(this._network), f ? f.height + 1 : 0), l = (await this._rpc.getblockhash({
                height: c
            })).result;
            for(; l !== null;){
                const p = await this._rpc.getblock({
                    blockhash: l,
                    verbosity: 2
                });
                if (p.error !== null) throw p.error;
                const y = p.result, _ = new i.RuneUpdater(this._network, y, !1, this._storage, this._rpc);
                for (const [A, O] of y.tx.entries())await _.indexRunes(O, A);
                await this._storage.saveBlockIndex(_), c++, l = (await this._rpc.getblockhash({
                    height: c
                })).result;
            }
        }
    }
    e.RunestoneIndexer = a;
})(QC);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.tryDecodeRunestone = e.isRunestone = e.encodeRunestone = e.Network = e.RunestoneIndexer = e.RuneUpdater = e.RuneLocation = void 0;
    const t = k0, r = hn, n = Ud, i = Kd, o = Qn, s = wi, a = Wd, u = o8, f = Dd;
    var c = QC;
    Object.defineProperty(e, "RuneLocation", {
        enumerable: !0,
        get: function() {
            return c.RuneLocation;
        }
    }), Object.defineProperty(e, "RuneUpdater", {
        enumerable: !0,
        get: function() {
            return c.RuneUpdater;
        }
    }), Object.defineProperty(e, "RunestoneIndexer", {
        enumerable: !0,
        get: function() {
            return c.RunestoneIndexer;
        }
    });
    var l = zf;
    Object.defineProperty(e, "Network", {
        enumerable: !0,
        get: function() {
            return l.Network;
        }
    });
    function p(H) {
        switch(H){
            case i.Flaw.EDICT_OUTPUT:
                return "edict_output";
            case i.Flaw.EDICT_RUNE_ID:
                return "edict_rune_id";
            case i.Flaw.INVALID_SCRIPT:
                return "invalid_script";
            case i.Flaw.OPCODE:
                return "opcode";
            case i.Flaw.SUPPLY_OVERFLOW:
                return "supply_overflow";
            case i.Flaw.TRAILING_INTEGERS:
                return "trailing_integers";
            case i.Flaw.TRUNCATED_FIELD:
                return "truncated_field";
            case i.Flaw.UNRECOGNIZED_EVEN_TAG:
                return "unrecognized_even_tag";
            case i.Flaw.UNRECOGNIZED_FLAG:
                return "unrecognized_flag";
            case i.Flaw.VARINT:
                return "varint";
        }
    }
    const y = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u8.MAX) throw Error("u8 overflow");
        return (0, o.u8)(K);
    }, _ = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u32.MAX) throw Error("u32 overflow");
        return (0, o.u32)(K);
    }, A = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u64.MAX) throw Error("u64 overflow");
        return (0, o.u64)(K);
    }, O = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u128.MAX) throw Error("u128 overflow");
        return (0, o.u128)(K);
    };
    function N(H) {
        const K = H.mint ? (0, s.Some)(new a.RuneId(A(H.mint.block), _(H.mint.tx))) : s.None, re = H.pointer !== void 0 ? (0, s.Some)(H.pointer).map(_) : s.None, Q = (H.edicts ?? []).map((X)=>({
                id: new a.RuneId(A(X.id.block), _(X.id.tx)),
                amount: O(X.amount),
                output: _(X.output)
            }));
        let G = s.None, R;
        if (H.etching) {
            const X = H.etching, $ = X.runeName ? f.SpacedRune.fromString(X.runeName) : void 0, S = ($ == null ? void 0 : $.rune) !== void 0 ? (0, s.Some)($.rune) : s.None;
            if (X.symbol && !(X.symbol.length === 1 || X.symbol.length === 2 && X.symbol.codePointAt(0) >= 65536)) throw Error("Symbol must be one code point");
            const w = X.divisibility !== void 0 ? (0, s.Some)(X.divisibility).map(y) : s.None, g = X.premine !== void 0 ? (0, s.Some)(X.premine).map(O) : s.None, m = ($ == null ? void 0 : $.spacers) !== void 0 && $.spacers !== 0 ? (0, s.Some)(_($.spacers)) : s.None, E = X.symbol ? (0, s.Some)(X.symbol) : s.None;
            if (w.isSome() && w.unwrap() > r.MAX_DIVISIBILITY) throw Error(`Divisibility is greater than protocol max ${r.MAX_DIVISIBILITY}`);
            let T = s.None;
            if (X.terms) {
                const P = X.terms, k = P.amount !== void 0 ? (0, s.Some)(P.amount).map(O) : s.None, L = P.cap !== void 0 ? (0, s.Some)(P.cap).map(O) : s.None, j = P.height ? [
                    P.height.start !== void 0 ? (0, s.Some)(P.height.start).map(A) : s.None,
                    P.height.end !== void 0 ? (0, s.Some)(P.height.end).map(A) : s.None
                ] : [
                    s.None,
                    s.None
                ], ie = P.offset ? [
                    P.offset.start !== void 0 ? (0, s.Some)(P.offset.start).map(A) : s.None,
                    P.offset.end !== void 0 ? (0, s.Some)(P.offset.end).map(A) : s.None
                ] : [
                    s.None,
                    s.None
                ];
                if (k.isSome() && L.isSome() && k.unwrap() * L.unwrap() > o.u128.MAX) throw Error("Terms overflow with amount times cap");
                T = (0, s.Some)({
                    amount: k,
                    cap: L,
                    height: j,
                    offset: ie
                });
            }
            const I = X.turbo ?? !1;
            G = (0, s.Some)(new n.Etching(w, S, m, E, T, g, I)), R = S.isSome() ? S.unwrap().commitment : void 0;
        }
        return {
            encodedRunestone: new u.Runestone(K, re, Q, G).encipher(),
            etchingCommitment: R
        };
    }
    e.encodeRunestone = N;
    function U(H) {
        return !("flaws" in H);
    }
    e.isRunestone = U;
    function D(H) {
        const K = u.Runestone.decipher(H);
        if (K.isNone()) return null;
        const re = K.unwrap();
        if ((0, t.isRunestone)(re)) {
            const Q = re, G = ()=>Q.etching.unwrap(), R = ()=>G().terms.unwrap();
            return {
                ...Q.etching.isSome() ? {
                    etching: {
                        ...G().divisibility.isSome() ? {
                            divisibility: G().divisibility.map(Number).unwrap()
                        } : {},
                        ...G().premine.isSome() ? {
                            premine: G().premine.unwrap()
                        } : {},
                        ...G().rune.isSome() ? {
                            runeName: new f.SpacedRune(G().rune.unwrap(), G().spacers.map(Number).unwrapOr(0)).toString()
                        } : {},
                        ...G().symbol.isSome() ? {
                            symbol: G().symbol.unwrap()
                        } : {},
                        ...G().terms.isSome() ? {
                            terms: {
                                ...R().amount.isSome() ? {
                                    amount: R().amount.unwrap()
                                } : {},
                                ...R().cap.isSome() ? {
                                    cap: R().cap.unwrap()
                                } : {},
                                ...R().height.find((X)=>X.isSome()) ? {
                                    height: {
                                        ...R().height[0].isSome() ? {
                                            start: R().height[0].unwrap()
                                        } : {},
                                        ...R().height[1].isSome() ? {
                                            end: R().height[1].unwrap()
                                        } : {}
                                    }
                                } : {},
                                ...R().offset.find((X)=>X.isSome()) ? {
                                    offset: {
                                        ...R().offset[0].isSome() ? {
                                            start: R().offset[0].unwrap()
                                        } : {},
                                        ...R().offset[1].isSome() ? {
                                            end: R().offset[1].unwrap()
                                        } : {}
                                    }
                                } : {}
                            }
                        } : {},
                        turbo: G().turbo
                    }
                } : {},
                ...Q.mint.isSome() ? {
                    mint: {
                        block: Q.mint.unwrap().block,
                        tx: Number(Q.mint.unwrap().tx)
                    }
                } : {},
                ...Q.pointer.isSome() ? {
                    pointer: Number(Q.pointer.unwrap())
                } : {},
                ...Q.edicts.length ? {
                    edicts: Q.edicts.map((X)=>({
                            id: {
                                block: X.id.block,
                                tx: Number(X.id.tx)
                            },
                            amount: X.amount,
                            output: Number(X.output)
                        }))
                } : {}
            };
        } else {
            const Q = re;
            return {
                flaws: Q.flaws.map(p),
                ...Q.etching.isSome() ? {
                    etching: Q.etching.unwrap().toString()
                } : {},
                ...Q.mint.isSome() ? {
                    mint: {
                        block: Q.mint.unwrap().block,
                        tx: Number(Q.mint.unwrap().tx)
                    }
                } : {}
            };
        }
    }
    e.tryDecodeRunestone = D;
})(jye);
const Jye = ({ runeId: e, amount: t, divisibility: r = 0, sendOutputIndex: n = 1, pointer: i = 0 })=>{
    r === 0 && (t = Math.floor(t));
    const o = Vu(BigInt(22)).varint, s = Vu(BigInt(i)).varint, a = Vu(BigInt(0)).varint, u = Vu(BigInt(t * 10 ** r)).varint, f = Vu(BigInt(n)).varint, c = e.split(":"), l = Number(c[0]), p = Number(c[1]), y = Vu(BigInt(l)).varint, _ = Vu(BigInt(p)).varint, A = We.concat([
        o,
        s,
        a,
        y,
        _,
        u,
        f
    ]);
    let O = A.byteLength.toString(16);
    return O.length % 2 !== 0 && (O = "0" + A.byteLength.toString(16)), We.concat([
        We.from("6a", "hex"),
        We.from("5d", "hex"),
        We.from(O, "hex"),
        A
    ]);
}, x1 = async (e, t)=>{
    const r = JSON.stringify({
        jsonrpc: "2.0",
        id: e,
        method: e,
        params: t
    });
    return await rn.post(`${UP}/${ql}`, r, {
        headers: {
            "content-type": "application/json"
        }
    }).then((n)=>n.data).catch((n)=>{
        throw n;
    });
}, Qye = async (e)=>(await x1("ord_address", [
        e
    ])).result, eU = async (e)=>(await x1("ord_rune", [
        e
    ])).result, eme = async (e)=>(await x1("ord_rune", [
        e
    ])).result, tme = async ({ outpoints: e, rune_name: t })=>{
    const n = [];
    for(let i = 0; i < e.length; i += 1e3){
        const o = e.slice(i, i + 1e3), s = o.map((f)=>[
                "ord_output",
                [
                    f
                ]
            ]), { result: a } = await x1("sandshrew_multicall", s);
        for(let f = 0; f < a.length; f++)a[f].result.output = o[f];
        const u = a.filter((f)=>Object.keys(f.result.runes).includes(t));
        n.push(...u);
    }
    return n;
}, rme = async ({ ordOutputs: e })=>{
    var r;
    const t = [];
    for(let n = 0; n < e.length; n++){
        const i = e[n], { result: o } = i;
        if (!((r = o.output) != null && r.split(":"))) throw new Error("No output found");
        const { output: s, address: a, runes: u } = o, f = {
            output: s,
            wallet_addr: a,
            script: "",
            balances: [],
            decimals: [],
            rune_ids: [],
            value: o.value
        }, [c, l] = s.split(":");
        if (console.log(c, l, s), f.script = We.from(oN(a, ln)).toString("hex"), typeof u == "object" && !Array.isArray(u)) for(const p in u)f.balances.push(u[p].amount), f.decimals.push(u[p].divisibility), f.rune_ids.push((await eme(p)).id);
        t.push(f);
    }
    return t;
}, nme = async ({ address: e, runeId: t })=>{
    const r = await Qye(e), { entry: n } = await eU(t), i = n.spaced_rune, o = await tme({
        outpoints: r.outputs,
        rune_name: i
    });
    return await rme({
        ordOutputs: o
    });
}, ime = async ({ runeId: e, amount: t, ordinalAddress: r, ordinalPublicKey: n, paymentAddress: i, paymentPublicKey: o, toAddress: s, signPsbt: a, network: u = ln })=>{
    try {
        const f = await ome({
            fromAddress: r,
            fromAddressPublicKey: n,
            fromPaymentAddress: i,
            fromPaymentPublicKey: o,
            toAddress: s,
            runeId: e,
            amount: t,
            network: u
        });
        if (!f || !(f != null && f.psbtHex)) throw new Error("couldn't get commit tx");
        const c = String(f == null ? void 0 : f.psbtHex), l = String(f == null ? void 0 : f.psbtBase64), p = await a({
            tx: c,
            psbtHex: c,
            psbtBase64: l,
            finalize: !0,
            broadcast: !1,
            network: u
        });
        if (!p) throw new Error("sign psbt failed");
        const _ = Cr.fromHex((p == null ? void 0 : p.signedPsbtHex) || "").extractTransaction();
        return await Hb(_.toHex(), u);
    } catch (f) {
        throw f;
    }
}, ome = async ({ fromAddress: e, fromAddressPublicKey: t, fromPaymentAddress: r, fromPaymentPublicKey: n, toAddress: i, runeId: o, amount: s, network: a })=>{
    try {
        const { fastestFee: u } = await iN(a);
        let c = (await J3(r, a)).sort((R, X)=>X.value - R.value).filter((R)=>R.value > 3e3);
        if (c.length === 0) throw new Error("No utxos found");
        let l = new Cr({
            network: Dr(a)
        }), p = 0;
        const y = await eU(o), _ = await nme({
            runeId: o,
            address: e
        }), A = jb(c), O = X3(_.length, 2, 4);
        let U = O * u < 250 ? 250 : O * u, D = 0;
        for await (const R of _){
            const { output: X, value: $, script: S } = R, w = X.split(":"), g = w[0], m = w[1];
            l.addInput({
                hash: g,
                index: parseInt(m),
                witnessUtxo: {
                    value: BigInt($),
                    script: We.from(S, "hex")
                },
                tapInternalKey: Mo(We.from(t, "hex"))
            }), D++, p += $;
        }
        const H = Jb(r, a);
        for(let R = 0; R < c.length; R++){
            const X = hs(r, Dr(ln)), $ = c[R];
            if (H === df && l.addInput({
                hash: $.txid,
                index: $.vout,
                witnessUtxo: {
                    value: BigInt($.value),
                    script: X
                },
                tapInternalKey: Mo(We.from(n, "hex"))
            }), H === Xp) {
                let S = d0(n, a);
                l.addInput({
                    hash: $.txid,
                    index: $.vout,
                    witnessUtxo: {
                        value: BigInt($.value),
                        script: X
                    },
                    redeemScript: S
                });
            }
            H === "p2wpkh" && l.addInput({
                hash: $.txid,
                index: $.vout,
                witnessUtxo: {
                    value: BigInt($.value),
                    script: X
                }
            });
        }
        const re = {
            script: Jye({
                runeId: y.id,
                amount: s,
                divisibility: y.entry.divisibility,
                sendOutputIndex: 2,
                pointer: 1
            }),
            value: BigInt(0)
        };
        l.addOutput(re);
        const Q = 546, G = A - (U + Q * 2);
        return l.addOutput({
            value: BigInt(Q),
            address: e
        }), l.addOutput({
            value: BigInt(Q),
            address: i
        }), l.addOutput({
            address: r,
            value: BigInt(G)
        }), {
            psbtBase64: l.toBase64(),
            psbtHex: l.toHex()
        };
    } catch (u) {
        throw u;
    }
}, sme = (e, t)=>`{"p":"brc-20","op":"transfer","tick":"${e}","amt":"${t}"}`, ame = async ({ ticker: e, amount: t, ordinalAddress: r, ordinalPublicKey: n, paymentAddress: i, paymentPublicKey: o, toAddress: s, signPsbt: a, dataSourceManager: u, network: f = ln })=>{
    let c;
    if (u ? c = u : c = nc.getInstance(), !c) throw new Error("Data source not found");
    if (!(c != null && c.getAddressBrc20Balances)) throw new Error("Data source not found");
    if (!await (c == null ? void 0 : c.getAddressBrc20Balances(r))) throw new Error("Address balance not found");
    const p = sme(e, t), y = await XC({
        contentBase64: btoa(p),
        mimeType: "text/plain",
        ordinalAddress: r,
        paymentAddress: i,
        paymentPublicKey: o,
        signPsbt: a,
        dataSourceManager: c,
        network: f
    });
    await c.waitForTransaction(y);
    const { fastFee: _ } = await c.getRecommendedFees(), A = 5 * 34 * 1, O = Math.floor(A * _ * 1);
    await new Promise((g)=>setTimeout(g, 1e4));
    const U = (await c.getAddressUtxos(i)).filter((g)=>g.value > 3e3).sort((g, m)=>m.value - g.value);
    if (jb(U) < O) throw new Error("insufficient funds");
    console.log("inscriptionTxId", y);
    const H = new Cr({
        network: Dr(f)
    }), K = hs(r, Dr(f));
    H.addInput({
        hash: y,
        index: 0,
        witnessUtxo: {
            script: K,
            value: BigInt(546)
        },
        tapInternalKey: Mo(We.from(n, "hex"))
    }), H.addOutput({
        address: s,
        value: BigInt(546)
    });
    let re = 0, Q = 0;
    for await (const g of U){
        const m = hs(i, Dr(f)), E = Jb(i, f);
        if (H.addInput({
            hash: g.txid,
            index: g.vout,
            witnessUtxo: {
                value: BigInt(g.value),
                script: m
            },
            tapInternalKey: Mo(We.from(o, "hex"))
        }), E === Xp) {
            const T = d0(o, f);
            H.updateInput(re, {
                redeemScript: T
            });
        }
        if (re++, Q += g.value, Q > O) {
            console.log("BREAKING");
            break;
        }
    }
    const G = Q - O;
    G > 546 && H.addOutput({
        value: BigInt(G),
        address: i
    });
    const R = H == null ? void 0 : H.toHex(), X = H == null ? void 0 : H.toBase64(), $ = await a({
        tx: "",
        psbtHex: R,
        psbtBase64: X,
        finalize: !0,
        broadcast: !0,
        network: f
    });
    if (!$) throw new Error("sign psbt failed");
    const w = Cr.fromHex(($ == null ? void 0 : $.signedPsbtHex) || "").extractTransaction();
    return await Hb(w.toHex(), f);
}, cme = async ({ inscriptionIds: e, ordinalAddress: t, ordinalPublicKey: r, paymentAddress: n, paymentPublicKey: i, toAddress: o, signPsbt: s, dataSourceManager: a, network: u = ln })=>{
    try {
        const f = await ume({
            inscriptionIds: e,
            fromAddress: t,
            fromAddressPublicKey: r,
            fromPaymentAddress: n,
            fromPaymentPublicKey: i,
            dataSourceManager: a,
            toAddress: o,
            network: u
        });
        if (!f || !(f != null && f.psbtHex)) throw new Error("couldn't get commit tx");
        const c = String(f == null ? void 0 : f.psbtHex), l = String(f == null ? void 0 : f.psbtBase64), p = await s({
            tx: "",
            psbtHex: c,
            psbtBase64: l,
            finalize: !0,
            broadcast: !1,
            network: u
        });
        if (!p) throw new Error("sign psbt failed");
        const _ = Cr.fromHex((p == null ? void 0 : p.signedPsbtHex) || "").extractTransaction();
        return await Hb(_.toHex(), u);
    } catch (f) {
        throw f;
    }
}, ume = async ({ fromAddress: e, fromAddressPublicKey: t, fromPaymentAddress: r, fromPaymentPublicKey: n, toAddress: i, inscriptionIds: o, dataSourceManager: s, network: a })=>{
    try {
        const { fastestFee: u } = await iN(a);
        let c = (await s.getAddressUtxos(r)).sort((K, re)=>re.value - K.value).filter((K)=>K.value > 3e3);
        if (c.length === 0) throw new Error("No utxos found");
        const l = s.getSource("sandshrew");
        if (!l || !l.batchOrdInscriptionInfo) throw new Error("Sandshrew data source not found");
        const p = await (l == null ? void 0 : l.batchOrdInscriptionInfo(o));
        console.log(p);
        let y = new Cr({
            network: Dr(a)
        });
        const _ = jb(c), A = X3(p.length, 2, 4);
        let N = A * u < 250 ? 250 : A * u, U = 0;
        for await (const K of p){
            const { value: re, satpoint: Q } = K, [G, R] = Q.split(":");
            if (!re || !G || !R) throw new Error("Invalid satpoint or value");
            const X = hs(e, Dr(ln));
            y.addInput({
                hash: G,
                index: parseInt(R),
                witnessUtxo: {
                    value: BigInt(re),
                    script: X
                },
                tapInternalKey: Mo(We.from(t, "hex"))
            }), y.addOutput({
                value: BigInt(re),
                address: i
            }), U++;
        }
        const D = Jb(r, a);
        for(let K = 0; K < c.length; K++){
            const re = hs(r, Dr(ln)), Q = c[K];
            if (D === df && y.addInput({
                hash: Q.txid,
                index: Q.vout,
                witnessUtxo: {
                    value: BigInt(Q.value),
                    script: re
                },
                tapInternalKey: Mo(We.from(n, "hex"))
            }), D === Xp) {
                let G = d0(n, a);
                y.addInput({
                    hash: Q.txid,
                    index: Q.vout,
                    witnessUtxo: {
                        value: BigInt(Q.value),
                        script: re
                    },
                    redeemScript: G
                });
            }
            D === "p2wpkh" && y.addInput({
                hash: Q.txid,
                index: Q.vout,
                witnessUtxo: {
                    value: BigInt(Q.value),
                    script: re
                }
            });
        }
        const H = _ - N;
        return y.addOutput({
            address: e,
            value: BigInt(H)
        }), {
            psbtBase64: y.toBase64(),
            psbtHex: y.toHex()
        };
    } catch (u) {
        throw u;
    }
}, gB = new Error("The connected wallet doesn't support this method..."), fme = new Error("Wallet is not installed");
class Do {
    constructor(t, r, n){
        pt(this, "$store");
        pt(this, "$network");
        pt(this, "dataSourceManager");
        pt(this, "send", async (t, r)=>{
            switch(t){
                case Pk:
                    {
                        const n = r;
                        return await this.sendBTC(n.toAddress, n.amount);
                    }
                case Mk:
                    {
                        if (this.$network.get() !== ln) throw new Error("Unsupported network");
                        const n = r;
                        if (!n.runeId || !n.amount || !n.toAddress) throw new Error("Missing required parameters");
                        return await ime({
                            runeId: n.runeId,
                            amount: n.amount,
                            ordinalAddress: this.$store.get().address,
                            ordinalPublicKey: this.$store.get().publicKey,
                            paymentAddress: this.$store.get().paymentAddress,
                            paymentPublicKey: this.$store.get().paymentPublicKey,
                            toAddress: n.toAddress,
                            signPsbt: this.signPsbt.bind(this),
                            network: this.$network.get()
                        });
                    }
                case Nk:
                    {
                        if (this.$network.get() !== ln) throw new Error("Unsupported network");
                        const n = r;
                        if (!n.ticker || !n.amount || !n.toAddress) throw new Error("Missing required parameters");
                        return await ame({
                            ticker: n.ticker,
                            amount: n.amount,
                            ordinalAddress: this.$store.get().address,
                            ordinalPublicKey: this.$store.get().publicKey,
                            paymentAddress: this.$store.get().paymentAddress,
                            paymentPublicKey: this.$store.get().paymentPublicKey,
                            signPsbt: this.signPsbt.bind(this),
                            toAddress: n.toAddress,
                            dataSourceManager: this.dataSourceManager,
                            network: this.$network.get()
                        });
                    }
                case Rk:
                    {
                        const n = r;
                        if (!n.id || !n.amount || !n.toAddress) throw new Error("Missing required parameters");
                        return await new lM(this.parent).send(n.id, n.amount, n.toAddress);
                    }
                default:
                    throw new Error("Unsupported protocol");
            }
        });
        this.parent = r, this.config = n, this.$store = t.$store, this.$network = t.$network, this.config = n;
        try {
            this.dataSourceManager = nc.getInstance();
        } catch  {
            nc.init(n), this.dataSourceManager = nc.getInstance();
        }
        this.initialize();
    }
    disconnect() {}
    async requestAccounts() {
        return this.$store.get().accounts;
    }
    async switchNetwork(t) {
        throw this.parent.disconnect(), gB;
    }
    async getNetwork() {
        const { address: t } = this.$store.get();
        return t.slice(0, 1) === "t" && [
            Ni,
            ao,
            Ro,
            co
        ].includes(this.$network.get()) ? this.$network.get() : ln;
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async getBalance() {
        if (!this.dataSourceManager.getAddressBtcBalance) throw new Error("Method not found on data source");
        return await this.dataSourceManager.getAddressBtcBalance(this.$store.get().paymentAddress);
    }
    async getMetaBalances(t) {
        switch(t){
            case Pk:
                return await this.getBalance();
            case Mk:
                {
                    if (this.$network.get() !== ln) throw new Error("Unsupported network");
                    if (!this.dataSourceManager.getAddressRunesBalances) throw new Error("Method not found on data source");
                    return await this.dataSourceManager.getAddressRunesBalances(this.$store.get().address);
                }
            case Nk:
                if (!this.dataSourceManager.getAddressBrc20Balances) throw new Error("Method not found on data source");
                return await this.dataSourceManager.getAddressBrc20Balances(this.$store.get().address);
            case Rk:
                if (!this.dataSourceManager.getAddressAlkanesBalances) throw new Error("Method not found on data source");
                return await this.dataSourceManager.getAddressAlkanesBalances(this.$store.get().address);
            default:
                throw new Error("Unsupported protocol");
        }
    }
    async getInscriptions(t, r) {
        if (!this.dataSourceManager.getAddressInscriptions) throw new Error("Method not found on data source");
        return await this.dataSourceManager.getAddressInscriptions(this.$store.get().address, t, r);
    }
    async signPsbts(t) {
        throw gB;
    }
    async pushPsbt(t) {
        let r = t;
        return r.startsWith("02") || (r = Cr.fromHex(r).extractTransaction().toHex()), await Hb(r, this.$network.get());
    }
    async inscribe(t, r, n, i) {
        return await XC({
            contentBase64: t,
            mimeType: r,
            ordinalAddress: this.$store.get().address,
            paymentAddress: this.$store.get().paymentAddress,
            paymentPublicKey: this.$store.get().paymentPublicKey,
            signPsbt: this.signPsbt.bind(this),
            dataSourceManager: n || this.dataSourceManager,
            opReturn: i,
            network: this.$network.get()
        });
    }
    async sendInscriptions(t, r) {
        if ((await this.getInscriptions()).filter((o)=>t.includes(o.id)).length !== t.length) throw new Error("Missing inscriptions");
        return await cme({
            inscriptionIds: t,
            ordinalAddress: this.$store.get().address,
            ordinalPublicKey: this.$store.get().publicKey,
            paymentAddress: this.$store.get().paymentAddress,
            paymentPublicKey: this.$store.get().paymentPublicKey,
            toAddress: r,
            signPsbt: this.signPsbt.bind(this),
            dataSourceManager: this.dataSourceManager,
            network: this.$network.get()
        });
    }
    getDeviceInfo() {
        const t = navigator.userAgent.toLowerCase(), n = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(t), o = /ipad|android(?!.*mobile)|tablet/i.test(t), s = "ontouchstart" in window || navigator.maxTouchPoints > 0, a = window.innerWidth <= 768;
        let u;
        return o ? u = "tablet" : n || s && a ? u = "mobile" : u = "desktop", {
            isMobile: u === "mobile" || u === "tablet",
            isDesktop: u === "desktop",
            deviceType: u,
            userAgent: navigator.userAgent
        };
    }
    isMobile() {
        return this.getDeviceInfo().isMobile;
    }
    isDesktop() {
        return this.getDeviceInfo().isDesktop;
    }
    getSuggestedConnectionMethod() {
        const t = this.getDeviceInfo();
        return t.deviceType === "mobile" ? "deep-link" : t.deviceType === "tablet" ? "qr-code" : "browser-extension";
    }
}
class lme extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "handleNetworkChanged", (r)=>{
            const n = r === "mainnet" ? dt.MAINNET : r === "testnet" ? dt.TESTNET : dt.SIGNET;
            this.network !== n && this.connect(Rl);
        });
    }
    get library() {
        var r;
        return ((r = window.keplr) == null ? void 0 : r.bitcoin) ?? window.bitcoin_keplr;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Rl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            var n;
            if (r.provider !== Rl) {
                this == null || this.removeListeners();
                return;
            }
            (n = this.library) == null || n.getAccounts().then((i)=>{
                this.handleAccountsChanged(i);
            }), this.addListeners();
        });
    }
    addListeners() {
        var r, n;
        (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var r, n;
        (r = this.library) == null || r.off("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.off("networkChanged", this.handleNetworkChanged.bind(this));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Rl) : this.parent.disconnect());
    }
    async connect(r) {
        if (!this.library) if (this.isMobile()) {
            const s = `https://deeplink.keplr.app/web-browser?url=${window.location.href}`, a = window.open(s);
            if (!a) throw new Error("Keplr wallet not found");
            return a.focus(), !1;
        } else throw new Error("Keplr wallet not found");
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        const i = await this.library.getPublicKey();
        if (!i) throw new Error("No public key found");
        this.$store.setKey("accounts", n), this.$store.setKey("address", n[0]), this.$store.setKey("paymentAddress", n[0]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i);
        const o = await this.getNetwork();
        this.$network.set(o);
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getChain());
        return r ? GQ(r.enum) : this.network;
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (!i) throw new Error("Transaction failed");
        return i;
    }
    async signMessage(r, n) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await this.library.signMessage(r, i);
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const s = await this.library.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        })), a = Cr.fromHex(s);
        if (i && n) {
            const u = await this.pushPsbt(s);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: u
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        if (!this.library) throw new Error("Keplr isn't installed");
        return (await this.library.getBalance()).total;
    }
    async requestAccounts() {
        if (!this.library) throw new Error("Keplr isn't installed");
        return await this.library.requestAccounts();
    }
    async switchNetwork(r) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const n = [
            dt.MAINNET,
            dt.TESTNET,
            dt.SIGNET
        ];
        if (!n.includes(r)) throw new Error(`Invalid network: ${r}. Keplr supports ${n.join(", ")}`);
        const i = WQ(r);
        await this.library.switchChain(i);
    }
}
var zr;
(function(e) {
    e.assertEqual = (i)=>i;
    function t(i) {}
    e.assertIs = t;
    function r(i) {
        throw new Error();
    }
    e.assertNever = r, e.arrayToEnum = (i)=>{
        const o = {};
        for (const s of i)o[s] = s;
        return o;
    }, e.getValidEnumValues = (i)=>{
        const o = e.objectKeys(i).filter((a)=>typeof i[i[a]] != "number"), s = {};
        for (const a of o)s[a] = i[a];
        return e.objectValues(s);
    }, e.objectValues = (i)=>e.objectKeys(i).map(function(o) {
            return i[o];
        }), e.objectKeys = typeof Object.keys == "function" ? (i)=>Object.keys(i) : (i)=>{
        const o = [];
        for(const s in i)Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
        return o;
    }, e.find = (i, o)=>{
        for (const s of i)if (o(s)) return s;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i)=>Number.isInteger(i) : (i)=>typeof i == "number" && isFinite(i) && Math.floor(i) === i;
    function n(i, o = " | ") {
        return i.map((s)=>typeof s == "string" ? `'${s}'` : s).join(o);
    }
    e.joinValues = n, e.jsonStringifyReplacer = (i, o)=>typeof o == "bigint" ? o.toString() : o;
})(zr || (zr = {}));
var Hx;
(function(e) {
    e.mergeShapes = (t, r)=>({
            ...t,
            ...r
        });
})(Hx || (Hx = {}));
const Ot = zr.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), Qa = (e)=>{
    switch(typeof e){
        case "undefined":
            return Ot.undefined;
        case "string":
            return Ot.string;
        case "number":
            return isNaN(e) ? Ot.nan : Ot.number;
        case "boolean":
            return Ot.boolean;
        case "function":
            return Ot.function;
        case "bigint":
            return Ot.bigint;
        case "symbol":
            return Ot.symbol;
        case "object":
            return Array.isArray(e) ? Ot.array : e === null ? Ot.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ot.promise : typeof Map < "u" && e instanceof Map ? Ot.map : typeof Set < "u" && e instanceof Set ? Ot.set : typeof Date < "u" && e instanceof Date ? Ot.date : Ot.object;
        default:
            return Ot.unknown;
    }
}, ht = zr.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]), dme = (e)=>JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Co extends Error {
    get errors() {
        return this.issues;
    }
    constructor(t){
        super(), this.issues = [], this.addIssue = (n)=>{
            this.issues = [
                ...this.issues,
                n
            ];
        }, this.addIssues = (n = [])=>{
            this.issues = [
                ...this.issues,
                ...n
            ];
        };
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    format(t) {
        const r = t || function(o) {
            return o.message;
        }, n = {
            _errors: []
        }, i = (o)=>{
            for (const s of o.issues)if (s.code === "invalid_union") s.unionErrors.map(i);
            else if (s.code === "invalid_return_type") i(s.returnTypeError);
            else if (s.code === "invalid_arguments") i(s.argumentsError);
            else if (s.path.length === 0) n._errors.push(r(s));
            else {
                let a = n, u = 0;
                for(; u < s.path.length;){
                    const f = s.path[u];
                    u === s.path.length - 1 ? (a[f] = a[f] || {
                        _errors: []
                    }, a[f]._errors.push(r(s))) : a[f] = a[f] || {
                        _errors: []
                    }, a = a[f], u++;
                }
            }
        };
        return i(this), n;
    }
    static assert(t) {
        if (!(t instanceof Co)) throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, zr.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(t = (r)=>r.message) {
        const r = {}, n = [];
        for (const i of this.issues)i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
        return {
            formErrors: n,
            fieldErrors: r
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
Co.create = (e)=>new Co(e);
const yd = (e, t)=>{
    let r;
    switch(e.code){
        case ht.invalid_type:
            e.received === Ot.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
            break;
        case ht.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(e.expected, zr.jsonStringifyReplacer)}`;
            break;
        case ht.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${zr.joinValues(e.keys, ", ")}`;
            break;
        case ht.invalid_union:
            r = "Invalid input";
            break;
        case ht.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${zr.joinValues(e.options)}`;
            break;
        case ht.invalid_enum_value:
            r = `Invalid enum value. Expected ${zr.joinValues(e.options)}, received '${e.received}'`;
            break;
        case ht.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case ht.invalid_return_type:
            r = "Invalid function return type";
            break;
        case ht.invalid_date:
            r = "Invalid date";
            break;
        case ht.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : zr.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
            break;
        case ht.too_small:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
            break;
        case ht.too_big:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
            break;
        case ht.custom:
            r = "Invalid input";
            break;
        case ht.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case ht.not_multiple_of:
            r = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case ht.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = t.defaultError, zr.assertNever(e);
    }
    return {
        message: r
    };
};
let tU = yd;
function hme(e) {
    tU = e;
}
function Zm() {
    return tU;
}
const Ym = (e)=>{
    const { data: t, path: r, errorMaps: n, issueData: i } = e, o = [
        ...r,
        ...i.path || []
    ], s = {
        ...i,
        path: o
    };
    if (i.message !== void 0) return {
        ...i,
        path: o,
        message: i.message
    };
    let a = "";
    const u = n.filter((f)=>!!f).slice().reverse();
    for (const f of u)a = f(s, {
        data: t,
        defaultError: a
    }).message;
    return {
        ...i,
        path: o,
        message: a
    };
}, pme = [];
function Tt(e, t) {
    const r = Zm(), n = Ym({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
            e.common.contextualErrorMap,
            // contextual error map is first priority
            e.schemaErrorMap,
            // then schema-bound map if available
            r,
            // then global override map
            r === yd ? void 0 : yd
        ].filter((i)=>!!i)
    });
    e.common.issues.push(n);
}
class Ui {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
        const n = [];
        for (const i of r){
            if (i.status === "aborted") return er;
            i.status === "dirty" && t.dirty(), n.push(i.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const i of r){
            const o = await i.key, s = await i.value;
            n.push({
                key: o,
                value: s
            });
        }
        return Ui.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const i of r){
            const { key: o, value: s } = i;
            if (o.status === "aborted" || s.status === "aborted") return er;
            o.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof s.value < "u" || i.alwaysSet) && (n[o.value] = s.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
}
const er = Object.freeze({
    status: "aborted"
}), Dl = (e)=>({
        status: "dirty",
        value: e
    }), Wi = (e)=>({
        status: "valid",
        value: e
    }), qx = (e)=>e.status === "aborted", Kx = (e)=>e.status === "dirty", If = (e)=>e.status === "valid", Mp = (e)=>typeof Promise < "u" && e instanceof Promise;
function Xm(e, t, r, n) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t.get(e);
}
function rU(e, t, r, n, i) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, r), r;
}
var $t;
(function(e) {
    e.errToObj = (t)=>typeof t == "string" ? {
            message: t
        } : t || {}, e.toString = (t)=>typeof t == "string" ? t : t == null ? void 0 : t.message;
})($t || ($t = {}));
var Bh, Oh;
class _a {
    constructor(t, r, n, i){
        this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
}
const yB = (e, t)=>{
    if (If(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const r = new Co(e.common.issues);
            return this._error = r, this._error;
        }
    };
};
function hr(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
    if (t && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i
    } : {
        errorMap: (s, a)=>{
            var u, f;
            const { message: c } = e;
            return s.code === "invalid_enum_value" ? {
                message: c ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: (u = c ?? n) !== null && u !== void 0 ? u : a.defaultError
            } : s.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: (f = c ?? r) !== null && f !== void 0 ? f : a.defaultError
            };
        },
        description: i
    };
}
class Sr {
    get description() {
        return this._def.description;
    }
    _getType(t) {
        return Qa(t.data);
    }
    _getOrReturnCtx(t, r) {
        return r || {
            common: t.parent.common,
            data: t.data,
            parsedType: Qa(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        };
    }
    _processInputParams(t) {
        return {
            status: new Ui(),
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: Qa(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        };
    }
    _parseSync(t) {
        const r = this._parse(t);
        if (Mp(r)) throw new Error("Synchronous parse encountered promise.");
        return r;
    }
    _parseAsync(t) {
        const r = this._parse(t);
        return Promise.resolve(r);
    }
    parse(t, r) {
        const n = this.safeParse(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    safeParse(t, r) {
        var n;
        const i = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Qa(t)
        }, o = this._parseSync({
            data: t,
            path: i.path,
            parent: i
        });
        return yB(i, o);
    }
    "~validate"(t) {
        var r, n;
        const i = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Qa(t)
        };
        if (!this["~standard"].async) try {
            const o = this._parseSync({
                data: t,
                path: [],
                parent: i
            });
            return If(o) ? {
                value: o.value
            } : {
                issues: i.common.issues
            };
        } catch (o) {
            !((n = (r = o == null ? void 0 : o.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0), i.common = {
                issues: [],
                async: !0
            };
        }
        return this._parseAsync({
            data: t,
            path: [],
            parent: i
        }).then((o)=>If(o) ? {
                value: o.value
            } : {
                issues: i.common.issues
            });
    }
    async parseAsync(t, r) {
        const n = await this.safeParseAsync(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    async safeParseAsync(t, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Qa(t)
        }, i = this._parse({
            data: t,
            path: n.path,
            parent: n
        }), o = await (Mp(i) ? i : Promise.resolve(i));
        return yB(n, o);
    }
    refine(t, r) {
        const n = (i)=>typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(i) : r;
        return this._refinement((i, o)=>{
            const s = t(i), a = ()=>o.addIssue({
                    code: ht.custom,
                    ...n(i)
                });
            return typeof Promise < "u" && s instanceof Promise ? s.then((u)=>u ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
        });
    }
    refinement(t, r) {
        return this._refinement((n, i)=>t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
    }
    _refinement(t) {
        return new Fs({
            schema: this,
            typeName: Qt.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        });
    }
    superRefine(t) {
        return this._refinement(t);
    }
    constructor(t){
        this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (r)=>this["~validate"](r)
        };
    }
    optional() {
        return ma.create(this, this._def);
    }
    nullable() {
        return Su.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return $s.create(this);
    }
    promise() {
        return bd.create(this, this._def);
    }
    or(t) {
        return $p.create([
            this,
            t
        ], this._def);
    }
    and(t) {
        return Lp.create(this, t, this._def);
    }
    transform(t) {
        return new Fs({
            ...hr(this._def),
            schema: this,
            typeName: Qt.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        });
    }
    default(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Hp({
            ...hr(this._def),
            innerType: this,
            defaultValue: r,
            typeName: Qt.ZodDefault
        });
    }
    brand() {
        return new a8({
            typeName: Qt.ZodBranded,
            type: this,
            ...hr(this._def)
        });
    }
    catch(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new qp({
            ...hr(this._def),
            innerType: this,
            catchValue: r,
            typeName: Qt.ZodCatch
        });
    }
    describe(t) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: t
        });
    }
    pipe(t) {
        return B0.create(this, t);
    }
    readonly() {
        return Kp.create(this);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const gme = /^c[^\s-]{8,}$/i, yme = /^[0-9a-z]+$/, mme = /^[0-9A-HJKMNP-TV-Z]{26}$/i, bme = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, wme = /^[a-z0-9_-]{21}$/i, vme = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, _me = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Eme = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, xme = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let fE;
const Sme = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ame = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Tme = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, kme = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Ime = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Bme = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, nU = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Ome = new RegExp(`^${nU}$`);
function iU(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function Pme(e) {
    return new RegExp(`^${iU(e)}$`);
}
function oU(e) {
    let t = `${nU}T${iU(e)}`;
    const r = [];
    return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
}
function Nme(e, t) {
    return !!((t === "v4" || !t) && Sme.test(e) || (t === "v6" || !t) && Tme.test(e));
}
function Mme(e, t) {
    if (!vme.test(e)) return !1;
    try {
        const [r] = e.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), i = JSON.parse(atob(n));
        return !(typeof i != "object" || i === null || !i.typ || !i.alg || t && i.alg !== t);
    } catch  {
        return !1;
    }
}
function Rme(e, t) {
    return !!((t === "v4" || !t) && Ame.test(e) || (t === "v6" || !t) && kme.test(e));
}
class Ns extends Sr {
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ot.string) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_type,
                expected: Ot.string,
                received: o.parsedType
            }), er;
        }
        const n = new Ui();
        let i;
        for (const o of this._def.checks)if (o.kind === "min") t.data.length < o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "max") t.data.length > o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "length") {
            const s = t.data.length > o.value, a = t.data.length < o.value;
            (s || a) && (i = this._getOrReturnCtx(t, i), s ? Tt(i, {
                code: ht.too_big,
                maximum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }) : a && Tt(i, {
                code: ht.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }), n.dirty());
        } else if (o.kind === "email") Eme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "email",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "emoji") fE || (fE = new RegExp(xme, "u")), fE.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "emoji",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "uuid") bme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "uuid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "nanoid") wme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "nanoid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid") gme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "cuid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid2") yme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "cuid2",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "ulid") mme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "ulid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "url") try {
            new URL(t.data);
        } catch  {
            i = this._getOrReturnCtx(t, i), Tt(i, {
                validation: "url",
                code: ht.invalid_string,
                message: o.message
            }), n.dirty();
        }
        else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "regex",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: {
                includes: o.value,
                position: o.position
            },
            message: o.message
        }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: {
                startsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: {
                endsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "datetime" ? oU(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: "datetime",
            message: o.message
        }), n.dirty()) : o.kind === "date" ? Ome.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: "date",
            message: o.message
        }), n.dirty()) : o.kind === "time" ? Pme(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: "time",
            message: o.message
        }), n.dirty()) : o.kind === "duration" ? _me.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "duration",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "ip" ? Nme(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "ip",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "jwt" ? Mme(t.data, o.alg) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "jwt",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "cidr" ? Rme(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "cidr",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "base64" ? Ime.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "base64",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "base64url" ? Bme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "base64url",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : zr.assertNever(o);
        return {
            status: n.value,
            value: t.data
        };
    }
    _regex(t, r, n) {
        return this.refinement((i)=>t.test(i), {
            validation: r,
            code: ht.invalid_string,
            ...$t.errToObj(n)
        });
    }
    _addCheck(t) {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...$t.errToObj(t)
        });
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...$t.errToObj(t)
        });
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...$t.errToObj(t)
        });
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...$t.errToObj(t)
        });
    }
    nanoid(t) {
        return this._addCheck({
            kind: "nanoid",
            ...$t.errToObj(t)
        });
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...$t.errToObj(t)
        });
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...$t.errToObj(t)
        });
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...$t.errToObj(t)
        });
    }
    base64(t) {
        return this._addCheck({
            kind: "base64",
            ...$t.errToObj(t)
        });
    }
    base64url(t) {
        return this._addCheck({
            kind: "base64url",
            ...$t.errToObj(t)
        });
    }
    jwt(t) {
        return this._addCheck({
            kind: "jwt",
            ...$t.errToObj(t)
        });
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...$t.errToObj(t)
        });
    }
    cidr(t) {
        return this._addCheck({
            kind: "cidr",
            ...$t.errToObj(t)
        });
    }
    datetime(t) {
        var r, n;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            local: (n = t == null ? void 0 : t.local) !== null && n !== void 0 ? n : !1,
            ...$t.errToObj(t == null ? void 0 : t.message)
        });
    }
    date(t) {
        return this._addCheck({
            kind: "date",
            message: t
        });
    }
    time(t) {
        return typeof t == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: t
        }) : this._addCheck({
            kind: "time",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            ...$t.errToObj(t == null ? void 0 : t.message)
        });
    }
    duration(t) {
        return this._addCheck({
            kind: "duration",
            ...$t.errToObj(t)
        });
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...$t.errToObj(r)
        });
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...$t.errToObj(r == null ? void 0 : r.message)
        });
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...$t.errToObj(r)
        });
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...$t.errToObj(r)
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...$t.errToObj(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...$t.errToObj(r)
        });
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...$t.errToObj(r)
        });
    }
    /**
   * Equivalent to `.min(1)`
   */ nonempty(t) {
        return this.min(1, $t.errToObj(t));
    }
    trim() {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((t)=>t.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((t)=>t.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((t)=>t.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((t)=>t.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((t)=>t.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((t)=>t.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((t)=>t.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((t)=>t.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((t)=>t.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((t)=>t.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((t)=>t.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((t)=>t.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((t)=>t.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((t)=>t.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((t)=>t.kind === "base64");
    }
    get isBase64url() {
        return !!this._def.checks.find((t)=>t.kind === "base64url");
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
}
Ns.create = (e)=>{
    var t;
    return new Ns({
        checks: [],
        typeName: Qt.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...hr(e)
    });
};
function Cme(e, t) {
    const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, o = parseInt(e.toFixed(i).replace(".", "")), s = parseInt(t.toFixed(i).replace(".", ""));
    return o % s / Math.pow(10, i);
}
class _u extends Sr {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ot.number) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_type,
                expected: Ot.number,
                received: o.parsedType
            }), er;
        }
        let n;
        const i = new Ui();
        for (const o of this._def.checks)o.kind === "int" ? zr.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.invalid_type,
            expected: "integer",
            received: "float",
            message: o.message
        }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_small,
            minimum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_big,
            maximum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? Cme(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.not_finite,
            message: o.message
        }), i.dirty()) : zr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, $t.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, $t.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, $t.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, $t.toString(r));
    }
    setLimit(t, r, n, i) {
        return new _u({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: $t.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new _u({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: $t.toString(t)
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: $t.toString(r)
        });
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: $t.toString(t)
        });
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: $t.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: $t.toString(t)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
    get isInt() {
        return !!this._def.checks.find((t)=>t.kind === "int" || t.kind === "multipleOf" && zr.isInteger(t.value));
    }
    get isFinite() {
        let t = null, r = null;
        for (const n of this._def.checks){
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        }
        return Number.isFinite(r) && Number.isFinite(t);
    }
}
_u.create = (e)=>new _u({
        checks: [],
        typeName: Qt.ZodNumber,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...hr(e)
    });
class Eu extends Sr {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
        if (this._def.coerce) try {
            t.data = BigInt(t.data);
        } catch  {
            return this._getInvalidInput(t);
        }
        if (this._getType(t) !== Ot.bigint) return this._getInvalidInput(t);
        let n;
        const i = new Ui();
        for (const o of this._def.checks)o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_small,
            type: "bigint",
            minimum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_big,
            type: "bigint",
            maximum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : zr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    _getInvalidInput(t) {
        const r = this._getOrReturnCtx(t);
        return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.bigint,
            received: r.parsedType
        }), er;
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, $t.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, $t.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, $t.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, $t.toString(r));
    }
    setLimit(t, r, n, i) {
        return new Eu({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: $t.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new Eu({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: $t.toString(r)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
}
Eu.create = (e)=>{
    var t;
    return new Eu({
        checks: [],
        typeName: Qt.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...hr(e)
    });
};
class Rp extends Sr {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ot.boolean) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.boolean,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Rp.create = (e)=>new Rp({
        typeName: Qt.ZodBoolean,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...hr(e)
    });
class Bf extends Sr {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ot.date) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_type,
                expected: Ot.date,
                received: o.parsedType
            }), er;
        }
        if (isNaN(t.data.getTime())) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_date
            }), er;
        }
        const n = new Ui();
        let i;
        for (const o of this._def.checks)o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_small,
            message: o.message,
            inclusive: !0,
            exact: !1,
            minimum: o.value,
            type: "date"
        }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_big,
            message: o.message,
            inclusive: !0,
            exact: !1,
            maximum: o.value,
            type: "date"
        }), n.dirty()) : zr.assertNever(o);
        return {
            status: n.value,
            value: new Date(t.data.getTime())
        };
    }
    _addCheck(t) {
        return new Bf({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: $t.toString(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: $t.toString(r)
        });
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
}
Bf.create = (e)=>new Bf({
        checks: [],
        coerce: (e == null ? void 0 : e.coerce) || !1,
        typeName: Qt.ZodDate,
        ...hr(e)
    });
class Jm extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.symbol) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.symbol,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Jm.create = (e)=>new Jm({
        typeName: Qt.ZodSymbol,
        ...hr(e)
    });
class Cp extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.undefined) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.undefined,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Cp.create = (e)=>new Cp({
        typeName: Qt.ZodUndefined,
        ...hr(e)
    });
class Up extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.null) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.null,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Up.create = (e)=>new Up({
        typeName: Qt.ZodNull,
        ...hr(e)
    });
class md extends Sr {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(t) {
        return Wi(t.data);
    }
}
md.create = (e)=>new md({
        typeName: Qt.ZodAny,
        ...hr(e)
    });
class bf extends Sr {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(t) {
        return Wi(t.data);
    }
}
bf.create = (e)=>new bf({
        typeName: Qt.ZodUnknown,
        ...hr(e)
    });
class dc extends Sr {
    _parse(t) {
        const r = this._getOrReturnCtx(t);
        return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.never,
            received: r.parsedType
        }), er;
    }
}
dc.create = (e)=>new dc({
        typeName: Qt.ZodNever,
        ...hr(e)
    });
class Qm extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.undefined) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.void,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Qm.create = (e)=>new Qm({
        typeName: Qt.ZodVoid,
        ...hr(e)
    });
class $s extends Sr {
    _parse(t) {
        const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
        if (r.parsedType !== Ot.array) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.array,
            received: r.parsedType
        }), er;
        if (i.exactLength !== null) {
            const s = r.data.length > i.exactLength.value, a = r.data.length < i.exactLength.value;
            (s || a) && (Tt(r, {
                code: s ? ht.too_big : ht.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: s ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), n.dirty());
        }
        if (i.minLength !== null && r.data.length < i.minLength.value && (Tt(r, {
            code: ht.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Tt(r, {
            code: ht.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([
            ...r.data
        ].map((s, a)=>i.type._parseAsync(new _a(r, s, r.path, a)))).then((s)=>Ui.mergeArray(n, s));
        const o = [
            ...r.data
        ].map((s, a)=>i.type._parseSync(new _a(r, s, r.path, a)));
        return Ui.mergeArray(n, o);
    }
    get element() {
        return this._def.type;
    }
    min(t, r) {
        return new $s({
            ...this._def,
            minLength: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    max(t, r) {
        return new $s({
            ...this._def,
            maxLength: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    length(t, r) {
        return new $s({
            ...this._def,
            exactLength: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    nonempty(t) {
        return this.min(1, t);
    }
}
$s.create = (e, t)=>new $s({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: Qt.ZodArray,
        ...hr(t)
    });
function kl(e) {
    if (e instanceof _n) {
        const t = {};
        for(const r in e.shape){
            const n = e.shape[r];
            t[r] = ma.create(kl(n));
        }
        return new _n({
            ...e._def,
            shape: ()=>t
        });
    } else return e instanceof $s ? new $s({
        ...e._def,
        type: kl(e.element)
    }) : e instanceof ma ? ma.create(kl(e.unwrap())) : e instanceof Su ? Su.create(kl(e.unwrap())) : e instanceof Ea ? Ea.create(e.items.map((t)=>kl(t))) : e;
}
class _n extends Sr {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(), r = zr.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        };
    }
    _parse(t) {
        if (this._getType(t) !== Ot.object) {
            const f = this._getOrReturnCtx(t);
            return Tt(f, {
                code: ht.invalid_type,
                expected: Ot.object,
                received: f.parsedType
            }), er;
        }
        const { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: s } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof dc && this._def.unknownKeys === "strip")) for(const f in i.data)s.includes(f) || a.push(f);
        const u = [];
        for (const f of s){
            const c = o[f], l = i.data[f];
            u.push({
                key: {
                    status: "valid",
                    value: f
                },
                value: c._parse(new _a(i, l, i.path, f)),
                alwaysSet: f in i.data
            });
        }
        if (this._def.catchall instanceof dc) {
            const f = this._def.unknownKeys;
            if (f === "passthrough") for (const c of a)u.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: {
                    status: "valid",
                    value: i.data[c]
                }
            });
            else if (f === "strict") a.length > 0 && (Tt(i, {
                code: ht.unrecognized_keys,
                keys: a
            }), n.dirty());
            else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const f = this._def.catchall;
            for (const c of a){
                const l = i.data[c];
                u.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: f._parse(new _a(i, l, i.path, c)),
                    alwaysSet: c in i.data
                });
            }
        }
        return i.common.async ? Promise.resolve().then(async ()=>{
            const f = [];
            for (const c of u){
                const l = await c.key, p = await c.value;
                f.push({
                    key: l,
                    value: p,
                    alwaysSet: c.alwaysSet
                });
            }
            return f;
        }).then((f)=>Ui.mergeObjectSync(n, f)) : Ui.mergeObjectSync(n, u);
    }
    get shape() {
        return this._def.shape();
    }
    strict(t) {
        return $t.errToObj, new _n({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n)=>{
                    var i, o, s, a;
                    const u = (s = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (a = $t.errToObj(t).message) !== null && a !== void 0 ? a : u
                    } : {
                        message: u
                    };
                }
            } : {}
        });
    }
    strip() {
        return new _n({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new _n({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
        return new _n({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(t) {
        return new _n({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
            typeName: Qt.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
        return this.augment({
            [t]: r
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
        return new _n({
            ...this._def,
            catchall: t
        });
    }
    pick(t) {
        const r = {};
        return zr.objectKeys(t).forEach((n)=>{
            t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    omit(t) {
        const r = {};
        return zr.objectKeys(this.shape).forEach((n)=>{
            t[n] || (r[n] = this.shape[n]);
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return kl(this);
    }
    partial(t) {
        const r = {};
        return zr.objectKeys(this.shape).forEach((n)=>{
            const i = this.shape[n];
            t && !t[n] ? r[n] = i : r[n] = i.optional();
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    required(t) {
        const r = {};
        return zr.objectKeys(this.shape).forEach((n)=>{
            if (t && !t[n]) r[n] = this.shape[n];
            else {
                let o = this.shape[n];
                for(; o instanceof ma;)o = o._def.innerType;
                r[n] = o;
            }
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    keyof() {
        return sU(zr.objectKeys(this.shape));
    }
}
_n.create = (e, t)=>new _n({
        shape: ()=>e,
        unknownKeys: "strip",
        catchall: dc.create(),
        typeName: Qt.ZodObject,
        ...hr(t)
    });
_n.strictCreate = (e, t)=>new _n({
        shape: ()=>e,
        unknownKeys: "strict",
        catchall: dc.create(),
        typeName: Qt.ZodObject,
        ...hr(t)
    });
_n.lazycreate = (e, t)=>new _n({
        shape: e,
        unknownKeys: "strip",
        catchall: dc.create(),
        typeName: Qt.ZodObject,
        ...hr(t)
    });
class $p extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = this._def.options;
        function i(o) {
            for (const a of o)if (a.result.status === "valid") return a.result;
            for (const a of o)if (a.result.status === "dirty") return r.common.issues.push(...a.ctx.common.issues), a.result;
            const s = o.map((a)=>new Co(a.ctx.common.issues));
            return Tt(r, {
                code: ht.invalid_union,
                unionErrors: s
            }), er;
        }
        if (r.common.async) return Promise.all(n.map(async (o)=>{
            const s = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await o._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: s
                }),
                ctx: s
            };
        })).then(i);
        {
            let o;
            const s = [];
            for (const u of n){
                const f = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }, c = u._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: f
                });
                if (c.status === "valid") return c;
                c.status === "dirty" && !o && (o = {
                    result: c,
                    ctx: f
                }), f.common.issues.length && s.push(f.common.issues);
            }
            if (o) return r.common.issues.push(...o.ctx.common.issues), o.result;
            const a = s.map((u)=>new Co(u));
            return Tt(r, {
                code: ht.invalid_union,
                unionErrors: a
            }), er;
        }
    }
    get options() {
        return this._def.options;
    }
}
$p.create = (e, t)=>new $p({
        options: e,
        typeName: Qt.ZodUnion,
        ...hr(t)
    });
const Ga = (e)=>e instanceof Fp ? Ga(e.schema) : e instanceof Fs ? Ga(e.innerType()) : e instanceof zp ? [
        e.value
    ] : e instanceof xu ? e.options : e instanceof jp ? zr.objectValues(e.enum) : e instanceof Hp ? Ga(e._def.innerType) : e instanceof Cp ? [
        void 0
    ] : e instanceof Up ? [
        null
    ] : e instanceof ma ? [
        void 0,
        ...Ga(e.unwrap())
    ] : e instanceof Su ? [
        null,
        ...Ga(e.unwrap())
    ] : e instanceof a8 || e instanceof Kp ? Ga(e.unwrap()) : e instanceof qp ? Ga(e._def.innerType) : [];
class S1 extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Ot.object) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.object,
            received: r.parsedType
        }), er;
        const n = this.discriminator, i = r.data[n], o = this.optionsMap.get(i);
        return o ? r.common.async ? o._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : o._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (Tt(r, {
            code: ht.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                n
            ]
        }), er);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(t, r, n) {
        const i = /* @__PURE__ */ new Map();
        for (const o of r){
            const s = Ga(o.shape[t]);
            if (!s.length) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const a of s){
                if (i.has(a)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
                i.set(a, o);
            }
        }
        return new S1({
            typeName: Qt.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: i,
            ...hr(n)
        });
    }
}
function Wx(e, t) {
    const r = Qa(e), n = Qa(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (r === Ot.object && n === Ot.object) {
        const i = zr.objectKeys(t), o = zr.objectKeys(e).filter((a)=>i.indexOf(a) !== -1), s = {
            ...e,
            ...t
        };
        for (const a of o){
            const u = Wx(e[a], t[a]);
            if (!u.valid) return {
                valid: !1
            };
            s[a] = u.data;
        }
        return {
            valid: !0,
            data: s
        };
    } else if (r === Ot.array && n === Ot.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i = [];
        for(let o = 0; o < e.length; o++){
            const s = e[o], a = t[o], u = Wx(s, a);
            if (!u.valid) return {
                valid: !1
            };
            i.push(u.data);
        }
        return {
            valid: !0,
            data: i
        };
    } else return r === Ot.date && n === Ot.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    };
}
class Lp extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = (o, s)=>{
            if (qx(o) || qx(s)) return er;
            const a = Wx(o.value, s.value);
            return a.valid ? ((Kx(o) || Kx(s)) && r.dirty(), {
                status: r.value,
                value: a.data
            }) : (Tt(n, {
                code: ht.invalid_intersection_types
            }), er);
        };
        return n.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }),
            this._def.right._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            })
        ]).then(([o, s])=>i(o, s)) : i(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }));
    }
}
Lp.create = (e, t, r)=>new Lp({
        left: e,
        right: t,
        typeName: Qt.ZodIntersection,
        ...hr(r)
    });
class Ea extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.array) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.array,
            received: n.parsedType
        }), er;
        if (n.data.length < this._def.items.length) return Tt(n, {
            code: ht.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), er;
        !this._def.rest && n.data.length > this._def.items.length && (Tt(n, {
            code: ht.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const o = [
            ...n.data
        ].map((s, a)=>{
            const u = this._def.items[a] || this._def.rest;
            return u ? u._parse(new _a(n, s, n.path, a)) : null;
        }).filter((s)=>!!s);
        return n.common.async ? Promise.all(o).then((s)=>Ui.mergeArray(r, s)) : Ui.mergeArray(r, o);
    }
    get items() {
        return this._def.items;
    }
    rest(t) {
        return new Ea({
            ...this._def,
            rest: t
        });
    }
}
Ea.create = (e, t)=>{
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Ea({
        items: e,
        typeName: Qt.ZodTuple,
        rest: null,
        ...hr(t)
    });
};
class Dp extends Sr {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.object) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.object,
            received: n.parsedType
        }), er;
        const i = [], o = this._def.keyType, s = this._def.valueType;
        for(const a in n.data)i.push({
            key: o._parse(new _a(n, a, n.path, a)),
            value: s._parse(new _a(n, n.data[a], n.path, a)),
            alwaysSet: a in n.data
        });
        return n.common.async ? Ui.mergeObjectAsync(r, i) : Ui.mergeObjectSync(r, i);
    }
    get element() {
        return this._def.valueType;
    }
    static create(t, r, n) {
        return r instanceof Sr ? new Dp({
            keyType: t,
            valueType: r,
            typeName: Qt.ZodRecord,
            ...hr(n)
        }) : new Dp({
            keyType: Ns.create(),
            valueType: t,
            typeName: Qt.ZodRecord,
            ...hr(r)
        });
    }
}
class eb extends Sr {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.map) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.map,
            received: n.parsedType
        }), er;
        const i = this._def.keyType, o = this._def.valueType, s = [
            ...n.data.entries()
        ].map(([a, u], f)=>({
                key: i._parse(new _a(n, a, n.path, [
                    f,
                    "key"
                ])),
                value: o._parse(new _a(n, u, n.path, [
                    f,
                    "value"
                ]))
            }));
        if (n.common.async) {
            const a = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const u of s){
                    const f = await u.key, c = await u.value;
                    if (f.status === "aborted" || c.status === "aborted") return er;
                    (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
                }
                return {
                    status: r.value,
                    value: a
                };
            });
        } else {
            const a = /* @__PURE__ */ new Map();
            for (const u of s){
                const f = u.key, c = u.value;
                if (f.status === "aborted" || c.status === "aborted") return er;
                (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
            }
            return {
                status: r.value,
                value: a
            };
        }
    }
}
eb.create = (e, t, r)=>new eb({
        valueType: t,
        keyType: e,
        typeName: Qt.ZodMap,
        ...hr(r)
    });
class Of extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.set) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.set,
            received: n.parsedType
        }), er;
        const i = this._def;
        i.minSize !== null && n.data.size < i.minSize.value && (Tt(n, {
            code: ht.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Tt(n, {
            code: ht.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), r.dirty());
        const o = this._def.valueType;
        function s(u) {
            const f = /* @__PURE__ */ new Set();
            for (const c of u){
                if (c.status === "aborted") return er;
                c.status === "dirty" && r.dirty(), f.add(c.value);
            }
            return {
                status: r.value,
                value: f
            };
        }
        const a = [
            ...n.data.values()
        ].map((u, f)=>o._parse(new _a(n, u, n.path, f)));
        return n.common.async ? Promise.all(a).then((u)=>s(u)) : s(a);
    }
    min(t, r) {
        return new Of({
            ...this._def,
            minSize: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    max(t, r) {
        return new Of({
            ...this._def,
            maxSize: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    size(t, r) {
        return this.min(t, r).max(t, r);
    }
    nonempty(t) {
        return this.min(1, t);
    }
}
Of.create = (e, t)=>new Of({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: Qt.ZodSet,
        ...hr(t)
    });
class Xl extends Sr {
    constructor(){
        super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Ot.function) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.function,
            received: r.parsedType
        }), er;
        function n(a, u) {
            return Ym({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Zm(),
                    yd
                ].filter((f)=>!!f),
                issueData: {
                    code: ht.invalid_arguments,
                    argumentsError: u
                }
            });
        }
        function i(a, u) {
            return Ym({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Zm(),
                    yd
                ].filter((f)=>!!f),
                issueData: {
                    code: ht.invalid_return_type,
                    returnTypeError: u
                }
            });
        }
        const o = {
            errorMap: r.common.contextualErrorMap
        }, s = r.data;
        if (this._def.returns instanceof bd) {
            const a = this;
            return Wi(async function(...u) {
                const f = new Co([]), c = await a._def.args.parseAsync(u, o).catch((y)=>{
                    throw f.addIssue(n(u, y)), f;
                }), l = await Reflect.apply(s, this, c);
                return await a._def.returns._def.type.parseAsync(l, o).catch((y)=>{
                    throw f.addIssue(i(l, y)), f;
                });
            });
        } else {
            const a = this;
            return Wi(function(...u) {
                const f = a._def.args.safeParse(u, o);
                if (!f.success) throw new Co([
                    n(u, f.error)
                ]);
                const c = Reflect.apply(s, this, f.data), l = a._def.returns.safeParse(c, o);
                if (!l.success) throw new Co([
                    i(c, l.error)
                ]);
                return l.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...t) {
        return new Xl({
            ...this._def,
            args: Ea.create(t).rest(bf.create())
        });
    }
    returns(t) {
        return new Xl({
            ...this._def,
            returns: t
        });
    }
    implement(t) {
        return this.parse(t);
    }
    strictImplement(t) {
        return this.parse(t);
    }
    static create(t, r, n) {
        return new Xl({
            args: t || Ea.create([]).rest(bf.create()),
            returns: r || bf.create(),
            typeName: Qt.ZodFunction,
            ...hr(n)
        });
    }
}
class Fp extends Sr {
    get schema() {
        return this._def.getter();
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        });
    }
}
Fp.create = (e, t)=>new Fp({
        getter: e,
        typeName: Qt.ZodLazy,
        ...hr(t)
    });
class zp extends Sr {
    _parse(t) {
        if (t.data !== this._def.value) {
            const r = this._getOrReturnCtx(t);
            return Tt(r, {
                received: r.data,
                code: ht.invalid_literal,
                expected: this._def.value
            }), er;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
    get value() {
        return this._def.value;
    }
}
zp.create = (e, t)=>new zp({
        value: e,
        typeName: Qt.ZodLiteral,
        ...hr(t)
    });
function sU(e, t) {
    return new xu({
        values: e,
        typeName: Qt.ZodEnum,
        ...hr(t)
    });
}
class xu extends Sr {
    constructor(){
        super(...arguments), Bh.set(this, void 0);
    }
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Tt(r, {
                expected: zr.joinValues(n),
                received: r.parsedType,
                code: ht.invalid_type
            }), er;
        }
        if (Xm(this, Bh) || rU(this, Bh, new Set(this._def.values)), !Xm(this, Bh).has(t.data)) {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Tt(r, {
                received: r.data,
                code: ht.invalid_enum_value,
                options: n
            }), er;
        }
        return Wi(t.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    extract(t, r = this._def) {
        return xu.create(t, {
            ...this._def,
            ...r
        });
    }
    exclude(t, r = this._def) {
        return xu.create(this.options.filter((n)=>!t.includes(n)), {
            ...this._def,
            ...r
        });
    }
}
Bh = /* @__PURE__ */ new WeakMap();
xu.create = sU;
class jp extends Sr {
    constructor(){
        super(...arguments), Oh.set(this, void 0);
    }
    _parse(t) {
        const r = zr.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
        if (n.parsedType !== Ot.string && n.parsedType !== Ot.number) {
            const i = zr.objectValues(r);
            return Tt(n, {
                expected: zr.joinValues(i),
                received: n.parsedType,
                code: ht.invalid_type
            }), er;
        }
        if (Xm(this, Oh) || rU(this, Oh, new Set(zr.getValidEnumValues(this._def.values))), !Xm(this, Oh).has(t.data)) {
            const i = zr.objectValues(r);
            return Tt(n, {
                received: n.data,
                code: ht.invalid_enum_value,
                options: i
            }), er;
        }
        return Wi(t.data);
    }
    get enum() {
        return this._def.values;
    }
}
Oh = /* @__PURE__ */ new WeakMap();
jp.create = (e, t)=>new jp({
        values: e,
        typeName: Qt.ZodNativeEnum,
        ...hr(t)
    });
class bd extends Sr {
    unwrap() {
        return this._def.type;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Ot.promise && r.common.async === !1) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.promise,
            received: r.parsedType
        }), er;
        const n = r.parsedType === Ot.promise ? r.data : Promise.resolve(r.data);
        return Wi(n.then((i)=>this._def.type.parseAsync(i, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })));
    }
}
bd.create = (e, t)=>new bd({
        type: e,
        typeName: Qt.ZodPromise,
        ...hr(t)
    });
class Fs extends Sr {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === Qt.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null, o = {
            addIssue: (s)=>{
                Tt(n, s), s.fatal ? r.abort() : r.dirty();
            },
            get path () {
                return n.path;
            }
        };
        if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
            const s = i.transform(n.data, o);
            if (n.common.async) return Promise.resolve(s).then(async (a)=>{
                if (r.value === "aborted") return er;
                const u = await this._def.schema._parseAsync({
                    data: a,
                    path: n.path,
                    parent: n
                });
                return u.status === "aborted" ? er : u.status === "dirty" || r.value === "dirty" ? Dl(u.value) : u;
            });
            {
                if (r.value === "aborted") return er;
                const a = this._def.schema._parseSync({
                    data: s,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? er : a.status === "dirty" || r.value === "dirty" ? Dl(a.value) : a;
            }
        }
        if (i.type === "refinement") {
            const s = (a)=>{
                const u = i.refinement(a, o);
                if (n.common.async) return Promise.resolve(u);
                if (u instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a;
            };
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? er : (a.status === "dirty" && r.dirty(), s(a.value), {
                    status: r.value,
                    value: a.value
                });
            } else return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then((a)=>a.status === "aborted" ? er : (a.status === "dirty" && r.dirty(), s(a.value).then(()=>({
                        status: r.value,
                        value: a.value
                    }))));
        }
        if (i.type === "transform") if (n.common.async === !1) {
            const s = this._def.schema._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            if (!If(s)) return s;
            const a = i.transform(s.value, o);
            if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: r.value,
                value: a
            };
        } else return this._def.schema._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }).then((s)=>If(s) ? Promise.resolve(i.transform(s.value, o)).then((a)=>({
                    status: r.value,
                    value: a
                })) : s);
        zr.assertNever(i);
    }
}
Fs.create = (e, t, r)=>new Fs({
        schema: e,
        typeName: Qt.ZodEffects,
        effect: t,
        ...hr(r)
    });
Fs.createWithPreprocess = (e, t, r)=>new Fs({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: Qt.ZodEffects,
        ...hr(r)
    });
class ma extends Sr {
    _parse(t) {
        return this._getType(t) === Ot.undefined ? Wi(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ma.create = (e, t)=>new ma({
        innerType: e,
        typeName: Qt.ZodOptional,
        ...hr(t)
    });
class Su extends Sr {
    _parse(t) {
        return this._getType(t) === Ot.null ? Wi(null) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Su.create = (e, t)=>new Su({
        innerType: e,
        typeName: Qt.ZodNullable,
        ...hr(t)
    });
class Hp extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        let n = r.data;
        return r.parsedType === Ot.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
Hp.create = (e, t)=>new Hp({
        innerType: e,
        typeName: Qt.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : ()=>t.default,
        ...hr(t)
    });
class qp extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }, i = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return Mp(i) ? i.then((o)=>({
                status: "valid",
                value: o.status === "valid" ? o.value : this._def.catchValue({
                    get error () {
                        return new Co(n.common.issues);
                    },
                    input: n.data
                })
            })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error () {
                    return new Co(n.common.issues);
                },
                input: n.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
qp.create = (e, t)=>new qp({
        innerType: e,
        typeName: Qt.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : ()=>t.catch,
        ...hr(t)
    });
class tb extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.nan) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.nan,
                received: n.parsedType
            }), er;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
}
tb.create = (e)=>new tb({
        typeName: Qt.ZodNaN,
        ...hr(e)
    });
const Ume = Symbol("zod_brand");
class a8 extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class B0 extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.common.async) return (async ()=>{
            const o = await this._def.in._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return o.status === "aborted" ? er : o.status === "dirty" ? (r.dirty(), Dl(o.value)) : this._def.out._parseAsync({
                data: o.value,
                path: n.path,
                parent: n
            });
        })();
        {
            const i = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i.status === "aborted" ? er : i.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: n.path,
                parent: n
            });
        }
    }
    static create(t, r) {
        return new B0({
            in: t,
            out: r,
            typeName: Qt.ZodPipeline
        });
    }
}
class Kp extends Sr {
    _parse(t) {
        const r = this._def.innerType._parse(t), n = (i)=>(If(i) && (i.value = Object.freeze(i.value)), i);
        return Mp(r) ? r.then((i)=>n(i)) : n(r);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Kp.create = (e, t)=>new Kp({
        innerType: e,
        typeName: Qt.ZodReadonly,
        ...hr(t)
    });
function mB(e, t) {
    const r = typeof e == "function" ? e(t) : typeof e == "string" ? {
        message: e
    } : e;
    return typeof r == "string" ? {
        message: r
    } : r;
}
function aU(e, t = {}, r) {
    return e ? md.create().superRefine((n, i)=>{
        var o, s;
        const a = e(n);
        if (a instanceof Promise) return a.then((u)=>{
            var f, c;
            if (!u) {
                const l = mB(t, n), p = (c = (f = l.fatal) !== null && f !== void 0 ? f : r) !== null && c !== void 0 ? c : !0;
                i.addIssue({
                    code: "custom",
                    ...l,
                    fatal: p
                });
            }
        });
        if (!a) {
            const u = mB(t, n), f = (s = (o = u.fatal) !== null && o !== void 0 ? o : r) !== null && s !== void 0 ? s : !0;
            i.addIssue({
                code: "custom",
                ...u,
                fatal: f
            });
        }
    }) : md.create();
}
const $me = {
    object: _n.lazycreate
};
var Qt;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Qt || (Qt = {}));
const Lme = (e, t = {
    message: `Input not instance of ${e.name}`
})=>aU((r)=>r instanceof e, t), cU = Ns.create, uU = _u.create, Dme = tb.create, Fme = Eu.create, fU = Rp.create, zme = Bf.create, jme = Jm.create, Hme = Cp.create, qme = Up.create, Kme = md.create, Wme = bf.create, Vme = dc.create, Gme = Qm.create, Zme = $s.create, Yme = _n.create, Xme = _n.strictCreate, Jme = $p.create, Qme = S1.create, ebe = Lp.create, tbe = Ea.create, rbe = Dp.create, nbe = eb.create, ibe = Of.create, obe = Xl.create, sbe = Fp.create, abe = zp.create, cbe = xu.create, ube = jp.create, fbe = bd.create, bB = Fs.create, lbe = ma.create, dbe = Su.create, hbe = Fs.createWithPreprocess, pbe = B0.create, gbe = ()=>cU().optional(), ybe = ()=>uU().optional(), mbe = ()=>fU().optional(), bbe = {
    string: (e)=>Ns.create({
            ...e,
            coerce: !0
        }),
    number: (e)=>_u.create({
            ...e,
            coerce: !0
        }),
    boolean: (e)=>Rp.create({
            ...e,
            coerce: !0
        }),
    bigint: (e)=>Eu.create({
            ...e,
            coerce: !0
        }),
    date: (e)=>Bf.create({
            ...e,
            coerce: !0
        })
}, wbe = er;
var Te = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: yd,
    setErrorMap: hme,
    getErrorMap: Zm,
    makeIssue: Ym,
    EMPTY_PATH: pme,
    addIssueToContext: Tt,
    ParseStatus: Ui,
    INVALID: er,
    DIRTY: Dl,
    OK: Wi,
    isAborted: qx,
    isDirty: Kx,
    isValid: If,
    isAsync: Mp,
    get util () {
        return zr;
    },
    get objectUtil () {
        return Hx;
    },
    ZodParsedType: Ot,
    getParsedType: Qa,
    ZodType: Sr,
    datetimeRegex: oU,
    ZodString: Ns,
    ZodNumber: _u,
    ZodBigInt: Eu,
    ZodBoolean: Rp,
    ZodDate: Bf,
    ZodSymbol: Jm,
    ZodUndefined: Cp,
    ZodNull: Up,
    ZodAny: md,
    ZodUnknown: bf,
    ZodNever: dc,
    ZodVoid: Qm,
    ZodArray: $s,
    ZodObject: _n,
    ZodUnion: $p,
    ZodDiscriminatedUnion: S1,
    ZodIntersection: Lp,
    ZodTuple: Ea,
    ZodRecord: Dp,
    ZodMap: eb,
    ZodSet: Of,
    ZodFunction: Xl,
    ZodLazy: Fp,
    ZodLiteral: zp,
    ZodEnum: xu,
    ZodNativeEnum: jp,
    ZodPromise: bd,
    ZodEffects: Fs,
    ZodTransformer: Fs,
    ZodOptional: ma,
    ZodNullable: Su,
    ZodDefault: Hp,
    ZodCatch: qp,
    ZodNaN: tb,
    BRAND: Ume,
    ZodBranded: a8,
    ZodPipeline: B0,
    ZodReadonly: Kp,
    custom: aU,
    Schema: Sr,
    ZodSchema: Sr,
    late: $me,
    get ZodFirstPartyTypeKind () {
        return Qt;
    },
    coerce: bbe,
    any: Kme,
    array: Zme,
    bigint: Fme,
    boolean: fU,
    date: zme,
    discriminatedUnion: Qme,
    effect: bB,
    enum: cbe,
    function: obe,
    instanceof: Lme,
    intersection: ebe,
    lazy: sbe,
    literal: abe,
    map: nbe,
    nan: Dme,
    nativeEnum: ube,
    never: Vme,
    null: qme,
    nullable: dbe,
    number: uU,
    object: Yme,
    oboolean: mbe,
    onumber: ybe,
    optional: lbe,
    ostring: gbe,
    pipeline: pbe,
    preprocess: hbe,
    promise: fbe,
    record: rbe,
    set: ibe,
    strictObject: Xme,
    string: cU,
    symbol: jme,
    transformer: bB,
    tuple: tbe,
    undefined: Hme,
    union: Jme,
    unknown: Wme,
    void: Gme,
    NEVER: wbe,
    ZodIssueCode: ht,
    quotelessJson: dme,
    ZodError: Co
}), vbe = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, lE = Math.ceil, rs = Math.floor, to = "[BigNumber Error] ", wB = to + "Number primitive has more than 15 significant digits: ", Ss = 1e14, fr = 14, dE = 9007199254740991, hE = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8,
    1e9,
    1e10,
    1e11,
    1e12,
    1e13
], Xc = 1e7, ri = 1e9;
function lU(e) {
    var t, r, n, i = U.prototype = {
        constructor: U,
        toString: null,
        valueOf: null
    }, o = new U(1), s = 20, a = 4, u = -7, f = 21, c = -1e7, l = 1e7, p = !1, y = 1, _ = 0, A = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: " ",
        // non-breaking space
        suffix: ""
    }, O = "0123456789abcdefghijklmnopqrstuvwxyz", N = !0;
    function U(G, R) {
        var X, $, S, w, g, m, E, T, I = this;
        if (!(I instanceof U)) return new U(G, R);
        if (R == null) {
            if (G && G._isBigNumber === !0) {
                I.s = G.s, !G.c || G.e > l ? I.c = I.e = null : G.e < c ? I.c = [
                    I.e = 0
                ] : (I.e = G.e, I.c = G.c.slice());
                return;
            }
            if ((m = typeof G == "number") && G * 0 == 0) {
                if (I.s = 1 / G < 0 ? (G = -G, -1) : 1, G === ~~G) {
                    for(w = 0, g = G; g >= 10; g /= 10, w++);
                    w > l ? I.c = I.e = null : (I.e = w, I.c = [
                        G
                    ]);
                    return;
                }
                T = String(G);
            } else {
                if (!vbe.test(T = String(G))) return n(I, T, m);
                I.s = T.charCodeAt(0) == 45 ? (T = T.slice(1), -1) : 1;
            }
            (w = T.indexOf(".")) > -1 && (T = T.replace(".", "")), (g = T.search(/e/i)) > 0 ? (w < 0 && (w = g), w += +T.slice(g + 1), T = T.substring(0, g)) : w < 0 && (w = T.length);
        } else {
            if (vn(R, 2, O.length, "Base"), R == 10 && N) return I = new U(G), re(I, s + I.e + 1, a);
            if (T = String(G), m = typeof G == "number") {
                if (G * 0 != 0) return n(I, T, m, R);
                if (I.s = 1 / G < 0 ? (T = T.slice(1), -1) : 1, U.DEBUG && T.replace(/^0\.0*|\./, "").length > 15) throw Error(wB + G);
            } else I.s = T.charCodeAt(0) === 45 ? (T = T.slice(1), -1) : 1;
            for(X = O.slice(0, R), w = g = 0, E = T.length; g < E; g++)if (X.indexOf($ = T.charAt(g)) < 0) {
                if ($ == ".") {
                    if (g > w) {
                        w = E;
                        continue;
                    }
                } else if (!S && (T == T.toUpperCase() && (T = T.toLowerCase()) || T == T.toLowerCase() && (T = T.toUpperCase()))) {
                    S = !0, g = -1, w = 0;
                    continue;
                }
                return n(I, String(G), m, R);
            }
            m = !1, T = r(T, R, 10, I.s), (w = T.indexOf(".")) > -1 ? T = T.replace(".", "") : w = T.length;
        }
        for(g = 0; T.charCodeAt(g) === 48; g++);
        for(E = T.length; T.charCodeAt(--E) === 48;);
        if (T = T.slice(g, ++E)) {
            if (E -= g, m && U.DEBUG && E > 15 && (G > dE || G !== rs(G))) throw Error(wB + I.s * G);
            if ((w = w - g - 1) > l) I.c = I.e = null;
            else if (w < c) I.c = [
                I.e = 0
            ];
            else {
                if (I.e = w, I.c = [], g = (w + 1) % fr, w < 0 && (g += fr), g < E) {
                    for(g && I.c.push(+T.slice(0, g)), E -= fr; g < E;)I.c.push(+T.slice(g, g += fr));
                    g = fr - (T = T.slice(g)).length;
                } else g -= E;
                for(; g--; T += "0");
                I.c.push(+T);
            }
        } else I.c = [
            I.e = 0
        ];
    }
    U.clone = lU, U.ROUND_UP = 0, U.ROUND_DOWN = 1, U.ROUND_CEIL = 2, U.ROUND_FLOOR = 3, U.ROUND_HALF_UP = 4, U.ROUND_HALF_DOWN = 5, U.ROUND_HALF_EVEN = 6, U.ROUND_HALF_CEIL = 7, U.ROUND_HALF_FLOOR = 8, U.EUCLID = 9, U.config = U.set = function(G) {
        var R, X;
        if (G != null) if (typeof G == "object") {
            if (G.hasOwnProperty(R = "DECIMAL_PLACES") && (X = G[R], vn(X, 0, ri, R), s = X), G.hasOwnProperty(R = "ROUNDING_MODE") && (X = G[R], vn(X, 0, 8, R), a = X), G.hasOwnProperty(R = "EXPONENTIAL_AT") && (X = G[R], X && X.pop ? (vn(X[0], -ri, 0, R), vn(X[1], 0, ri, R), u = X[0], f = X[1]) : (vn(X, -ri, ri, R), u = -(f = X < 0 ? -X : X))), G.hasOwnProperty(R = "RANGE")) if (X = G[R], X && X.pop) vn(X[0], -ri, -1, R), vn(X[1], 1, ri, R), c = X[0], l = X[1];
            else if (vn(X, -ri, ri, R), X) c = -(l = X < 0 ? -X : X);
            else throw Error(to + R + " cannot be zero: " + X);
            if (G.hasOwnProperty(R = "CRYPTO")) if (X = G[R], X === !!X) if (X) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) p = X;
            else throw p = !X, Error(to + "crypto unavailable");
            else p = X;
            else throw Error(to + R + " not true or false: " + X);
            if (G.hasOwnProperty(R = "MODULO_MODE") && (X = G[R], vn(X, 0, 9, R), y = X), G.hasOwnProperty(R = "POW_PRECISION") && (X = G[R], vn(X, 0, ri, R), _ = X), G.hasOwnProperty(R = "FORMAT")) if (X = G[R], typeof X == "object") A = X;
            else throw Error(to + R + " not an object: " + X);
            if (G.hasOwnProperty(R = "ALPHABET")) if (X = G[R], typeof X == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(X)) N = X.slice(0, 10) == "0123456789", O = X;
            else throw Error(to + R + " invalid: " + X);
        } else throw Error(to + "Object expected: " + G);
        return {
            DECIMAL_PLACES: s,
            ROUNDING_MODE: a,
            EXPONENTIAL_AT: [
                u,
                f
            ],
            RANGE: [
                c,
                l
            ],
            CRYPTO: p,
            MODULO_MODE: y,
            POW_PRECISION: _,
            FORMAT: A,
            ALPHABET: O
        };
    }, U.isBigNumber = function(G) {
        if (!G || G._isBigNumber !== !0) return !1;
        if (!U.DEBUG) return !0;
        var R, X, $ = G.c, S = G.e, w = G.s;
        e: if (({}).toString.call($) == "[object Array]") {
            if ((w === 1 || w === -1) && S >= -ri && S <= ri && S === rs(S)) {
                if ($[0] === 0) {
                    if (S === 0 && $.length === 1) return !0;
                    break e;
                }
                if (R = (S + 1) % fr, R < 1 && (R += fr), String($[0]).length == R) {
                    for(R = 0; R < $.length; R++)if (X = $[R], X < 0 || X >= Ss || X !== rs(X)) break e;
                    if (X !== 0) return !0;
                }
            }
        } else if ($ === null && S === null && (w === null || w === 1 || w === -1)) return !0;
        throw Error(to + "Invalid BigNumber: " + G);
    }, U.maximum = U.max = function() {
        return H(arguments, -1);
    }, U.minimum = U.min = function() {
        return H(arguments, 1);
    }, U.random = function() {
        var G = 9007199254740992, R = Math.random() * G & 2097151 ? function() {
            return rs(Math.random() * G);
        } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(X) {
            var $, S, w, g, m, E = 0, T = [], I = new U(o);
            if (X == null ? X = s : vn(X, 0, ri), g = lE(X / fr), p) if (crypto.getRandomValues) {
                for($ = crypto.getRandomValues(new Uint32Array(g *= 2)); E < g;)m = $[E] * 131072 + ($[E + 1] >>> 11), m >= 9e15 ? (S = crypto.getRandomValues(new Uint32Array(2)), $[E] = S[0], $[E + 1] = S[1]) : (T.push(m % 1e14), E += 2);
                E = g / 2;
            } else if (crypto.randomBytes) {
                for($ = crypto.randomBytes(g *= 7); E < g;)m = ($[E] & 31) * 281474976710656 + $[E + 1] * 1099511627776 + $[E + 2] * 4294967296 + $[E + 3] * 16777216 + ($[E + 4] << 16) + ($[E + 5] << 8) + $[E + 6], m >= 9e15 ? crypto.randomBytes(7).copy($, E) : (T.push(m % 1e14), E += 7);
                E = g / 7;
            } else throw p = !1, Error(to + "crypto unavailable");
            if (!p) for(; E < g;)m = R(), m < 9e15 && (T[E++] = m % 1e14);
            for(g = T[--E], X %= fr, g && X && (m = hE[fr - X], T[E] = rs(g / m) * m); T[E] === 0; T.pop(), E--);
            if (E < 0) T = [
                w = 0
            ];
            else {
                for(w = -1; T[0] === 0; T.splice(0, 1), w -= fr);
                for(E = 1, m = T[0]; m >= 10; m /= 10, E++);
                E < fr && (w -= fr - E);
            }
            return I.e = w, I.c = T, I;
        };
    }(), U.sum = function() {
        for(var G = 1, R = arguments, X = new U(R[0]); G < R.length;)X = X.plus(R[G++]);
        return X;
    }, r = /* @__PURE__ */ function() {
        var G = "0123456789";
        function R(X, $, S, w) {
            for(var g, m = [
                0
            ], E, T = 0, I = X.length; T < I;){
                for(E = m.length; E--; m[E] *= $);
                for(m[0] += w.indexOf(X.charAt(T++)), g = 0; g < m.length; g++)m[g] > S - 1 && (m[g + 1] == null && (m[g + 1] = 0), m[g + 1] += m[g] / S | 0, m[g] %= S);
            }
            return m.reverse();
        }
        return function(X, $, S, w, g) {
            var m, E, T, I, P, k, L, j, ie = X.indexOf("."), ue = s, ce = a;
            for(ie >= 0 && (I = _, _ = 0, X = X.replace(".", ""), j = new U($), k = j.pow(X.length - ie), _ = I, j.c = R(Va(ts(k.c), k.e, "0"), 10, S, G), j.e = j.c.length), L = R(X, $, S, g ? (m = O, G) : (m = G, O)), T = I = L.length; L[--I] == 0; L.pop());
            if (!L[0]) return m.charAt(0);
            if (ie < 0 ? --T : (k.c = L, k.e = T, k.s = w, k = t(k, j, ue, ce, S), L = k.c, P = k.r, T = k.e), E = T + ue + 1, ie = L[E], I = S / 2, P = P || E < 0 || L[E + 1] != null, P = ce < 4 ? (ie != null || P) && (ce == 0 || ce == (k.s < 0 ? 3 : 2)) : ie > I || ie == I && (ce == 4 || P || ce == 6 && L[E - 1] & 1 || ce == (k.s < 0 ? 8 : 7)), E < 1 || !L[0]) X = P ? Va(m.charAt(1), -ue, m.charAt(0)) : m.charAt(0);
            else {
                if (L.length = E, P) for(--S; ++L[--E] > S;)L[E] = 0, E || (++T, L = [
                    1
                ].concat(L));
                for(I = L.length; !L[--I];);
                for(ie = 0, X = ""; ie <= I; X += m.charAt(L[ie++]));
                X = Va(X, T, m.charAt(0));
            }
            return X;
        };
    }(), t = /* @__PURE__ */ function() {
        function G($, S, w) {
            var g, m, E, T, I = 0, P = $.length, k = S % Xc, L = S / Xc | 0;
            for($ = $.slice(); P--;)E = $[P] % Xc, T = $[P] / Xc | 0, g = L * E + T * k, m = k * E + g % Xc * Xc + I, I = (m / w | 0) + (g / Xc | 0) + L * T, $[P] = m % w;
            return I && ($ = [
                I
            ].concat($)), $;
        }
        function R($, S, w, g) {
            var m, E;
            if (w != g) E = w > g ? 1 : -1;
            else for(m = E = 0; m < w; m++)if ($[m] != S[m]) {
                E = $[m] > S[m] ? 1 : -1;
                break;
            }
            return E;
        }
        function X($, S, w, g) {
            for(var m = 0; w--;)$[w] -= m, m = $[w] < S[w] ? 1 : 0, $[w] = m * g + $[w] - S[w];
            for(; !$[0] && $.length > 1; $.splice(0, 1));
        }
        return function($, S, w, g, m) {
            var E, T, I, P, k, L, j, ie, ue, ce, he, ee, ae, ye, Se, De, Re, Ce = $.s == S.s ? 1 : -1, M = $.c, z = S.c;
            if (!M || !M[0] || !z || !z[0]) return new U(// Return NaN if either NaN, or both Infinity or 0.
            !$.s || !S.s || (M ? z && M[0] == z[0] : !z) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            M && M[0] == 0 || !z ? Ce * 0 : Ce / 0);
            for(ie = new U(Ce), ue = ie.c = [], T = $.e - S.e, Ce = w + T + 1, m || (m = Ss, T = ns($.e / fr) - ns(S.e / fr), Ce = Ce / fr | 0), I = 0; z[I] == (M[I] || 0); I++);
            if (z[I] > (M[I] || 0) && T--, Ce < 0) ue.push(1), P = !0;
            else {
                for(ye = M.length, De = z.length, I = 0, Ce += 2, k = rs(m / (z[0] + 1)), k > 1 && (z = G(z, k, m), M = G(M, k, m), De = z.length, ye = M.length), ae = De, ce = M.slice(0, De), he = ce.length; he < De; ce[he++] = 0);
                Re = z.slice(), Re = [
                    0
                ].concat(Re), Se = z[0], z[1] >= m / 2 && Se++;
                do {
                    if (k = 0, E = R(z, ce, De, he), E < 0) {
                        if (ee = ce[0], De != he && (ee = ee * m + (ce[1] || 0)), k = rs(ee / Se), k > 1) for(k >= m && (k = m - 1), L = G(z, k, m), j = L.length, he = ce.length; R(L, ce, j, he) == 1;)k--, X(L, De < j ? Re : z, j, m), j = L.length, E = 1;
                        else k == 0 && (E = k = 1), L = z.slice(), j = L.length;
                        if (j < he && (L = [
                            0
                        ].concat(L)), X(ce, L, he, m), he = ce.length, E == -1) for(; R(z, ce, De, he) < 1;)k++, X(ce, De < he ? Re : z, he, m), he = ce.length;
                    } else E === 0 && (k++, ce = [
                        0
                    ]);
                    ue[I++] = k, ce[0] ? ce[he++] = M[ae] || 0 : (ce = [
                        M[ae]
                    ], he = 1);
                }while ((ae++ < ye || ce[0] != null) && Ce--)
                P = ce[0] != null, ue[0] || ue.splice(0, 1);
            }
            if (m == Ss) {
                for(I = 1, Ce = ue[0]; Ce >= 10; Ce /= 10, I++);
                re(ie, w + (ie.e = I + T * fr - 1) + 1, g, P);
            } else ie.e = T, ie.r = +P;
            return ie;
        };
    }();
    function D(G, R, X, $) {
        var S, w, g, m, E;
        if (X == null ? X = a : vn(X, 0, 8), !G.c) return G.toString();
        if (S = G.c[0], g = G.e, R == null) E = ts(G.c), E = $ == 1 || $ == 2 && (g <= u || g >= f) ? vy(E, g) : Va(E, g, "0");
        else if (G = re(new U(G), R, X), w = G.e, E = ts(G.c), m = E.length, $ == 1 || $ == 2 && (R <= w || w <= u)) {
            for(; m < R; E += "0", m++);
            E = vy(E, w);
        } else if (R -= g, E = Va(E, w, "0"), w + 1 > m) {
            if (--R > 0) for(E += "."; R--; E += "0");
        } else if (R += w - m, R > 0) for(w + 1 == m && (E += "."); R--; E += "0");
        return G.s < 0 && S ? "-" + E : E;
    }
    function H(G, R) {
        for(var X, $, S = 1, w = new U(G[0]); S < G.length; S++)$ = new U(G[S]), (!$.s || (X = Gu(w, $)) === R || X === 0 && w.s === R) && (w = $);
        return w;
    }
    function K(G, R, X) {
        for(var $ = 1, S = R.length; !R[--S]; R.pop());
        for(S = R[0]; S >= 10; S /= 10, $++);
        return (X = $ + X * fr - 1) > l ? G.c = G.e = null : X < c ? G.c = [
            G.e = 0
        ] : (G.e = X, G.c = R), G;
    }
    n = /* @__PURE__ */ function() {
        var G = /^(-?)0([xbo])(?=\w[\w.]*$)/i, R = /^([^.]+)\.$/, X = /^\.([^.]+)$/, $ = /^-?(Infinity|NaN)$/, S = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(w, g, m, E) {
            var T, I = m ? g : g.replace(S, "");
            if ($.test(I)) w.s = isNaN(I) ? null : I < 0 ? -1 : 1;
            else {
                if (!m && (I = I.replace(G, function(P, k, L) {
                    return T = (L = L.toLowerCase()) == "x" ? 16 : L == "b" ? 2 : 8, !E || E == T ? k : P;
                }), E && (T = E, I = I.replace(R, "$1").replace(X, "0.$1")), g != I)) return new U(I, T);
                if (U.DEBUG) throw Error(to + "Not a" + (E ? " base " + E : "") + " number: " + g);
                w.s = null;
            }
            w.c = w.e = null;
        };
    }();
    function re(G, R, X, $) {
        var S, w, g, m, E, T, I, P = G.c, k = hE;
        if (P) {
            e: {
                for(S = 1, m = P[0]; m >= 10; m /= 10, S++);
                if (w = R - S, w < 0) w += fr, g = R, E = P[T = 0], I = rs(E / k[S - g - 1] % 10);
                else if (T = lE((w + 1) / fr), T >= P.length) if ($) {
                    for(; P.length <= T; P.push(0));
                    E = I = 0, S = 1, w %= fr, g = w - fr + 1;
                } else break e;
                else {
                    for(E = m = P[T], S = 1; m >= 10; m /= 10, S++);
                    w %= fr, g = w - fr + S, I = g < 0 ? 0 : rs(E / k[S - g - 1] % 10);
                }
                if ($ = $ || R < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                P[T + 1] != null || (g < 0 ? E : E % k[S - g - 1]), $ = X < 4 ? (I || $) && (X == 0 || X == (G.s < 0 ? 3 : 2)) : I > 5 || I == 5 && (X == 4 || $ || X == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (w > 0 ? g > 0 ? E / k[S - g] : 0 : P[T - 1]) % 10 & 1 || X == (G.s < 0 ? 8 : 7)), R < 1 || !P[0]) return P.length = 0, $ ? (R -= G.e + 1, P[0] = k[(fr - R % fr) % fr], G.e = -R || 0) : P[0] = G.e = 0, G;
                if (w == 0 ? (P.length = T, m = 1, T--) : (P.length = T + 1, m = k[fr - w], P[T] = g > 0 ? rs(E / k[S - g] % k[g]) * m : 0), $) for(;;)if (T == 0) {
                    for(w = 1, g = P[0]; g >= 10; g /= 10, w++);
                    for(g = P[0] += m, m = 1; g >= 10; g /= 10, m++);
                    w != m && (G.e++, P[0] == Ss && (P[0] = 1));
                    break;
                } else {
                    if (P[T] += m, P[T] != Ss) break;
                    P[T--] = 0, m = 1;
                }
                for(w = P.length; P[--w] === 0; P.pop());
            }
            G.e > l ? G.c = G.e = null : G.e < c && (G.c = [
                G.e = 0
            ]);
        }
        return G;
    }
    function Q(G) {
        var R, X = G.e;
        return X === null ? G.toString() : (R = ts(G.c), R = X <= u || X >= f ? vy(R, X) : Va(R, X, "0"), G.s < 0 ? "-" + R : R);
    }
    return i.absoluteValue = i.abs = function() {
        var G = new U(this);
        return G.s < 0 && (G.s = 1), G;
    }, i.comparedTo = function(G, R) {
        return Gu(this, new U(G, R));
    }, i.decimalPlaces = i.dp = function(G, R) {
        var X, $, S, w = this;
        if (G != null) return vn(G, 0, ri), R == null ? R = a : vn(R, 0, 8), re(new U(w), G + w.e + 1, R);
        if (!(X = w.c)) return null;
        if ($ = ((S = X.length - 1) - ns(this.e / fr)) * fr, S = X[S]) for(; S % 10 == 0; S /= 10, $--);
        return $ < 0 && ($ = 0), $;
    }, i.dividedBy = i.div = function(G, R) {
        return t(this, new U(G, R), s, a);
    }, i.dividedToIntegerBy = i.idiv = function(G, R) {
        return t(this, new U(G, R), 0, 1);
    }, i.exponentiatedBy = i.pow = function(G, R) {
        var X, $, S, w, g, m, E, T, I, P = this;
        if (G = new U(G), G.c && !G.isInteger()) throw Error(to + "Exponent not an integer: " + Q(G));
        if (R != null && (R = new U(R)), m = G.e > 14, !P.c || !P.c[0] || P.c[0] == 1 && !P.e && P.c.length == 1 || !G.c || !G.c[0]) return I = new U(Math.pow(+Q(P), m ? G.s * (2 - wy(G)) : +Q(G))), R ? I.mod(R) : I;
        if (E = G.s < 0, R) {
            if (R.c ? !R.c[0] : !R.s) return new U(NaN);
            $ = !E && P.isInteger() && R.isInteger(), $ && (P = P.mod(R));
        } else {
            if (G.e > 9 && (P.e > 0 || P.e < -1 || (P.e == 0 ? P.c[0] > 1 || m && P.c[1] >= 24e7 : P.c[0] < 8e13 || m && P.c[0] <= 9999975e7))) return w = P.s < 0 && wy(G) ? -0 : 0, P.e > -1 && (w = 1 / w), new U(E ? 1 / w : w);
            _ && (w = lE(_ / fr + 2));
        }
        for(m ? (X = new U(0.5), E && (G.s = 1), T = wy(G)) : (S = Math.abs(+Q(G)), T = S % 2), I = new U(o);;){
            if (T) {
                if (I = I.times(P), !I.c) break;
                w ? I.c.length > w && (I.c.length = w) : $ && (I = I.mod(R));
            }
            if (S) {
                if (S = rs(S / 2), S === 0) break;
                T = S % 2;
            } else if (G = G.times(X), re(G, G.e + 1, 1), G.e > 14) T = wy(G);
            else {
                if (S = +Q(G), S === 0) break;
                T = S % 2;
            }
            P = P.times(P), w ? P.c && P.c.length > w && (P.c.length = w) : $ && (P = P.mod(R));
        }
        return $ ? I : (E && (I = o.div(I)), R ? I.mod(R) : w ? re(I, _, a, g) : I);
    }, i.integerValue = function(G) {
        var R = new U(this);
        return G == null ? G = a : vn(G, 0, 8), re(R, R.e + 1, G);
    }, i.isEqualTo = i.eq = function(G, R) {
        return Gu(this, new U(G, R)) === 0;
    }, i.isFinite = function() {
        return !!this.c;
    }, i.isGreaterThan = i.gt = function(G, R) {
        return Gu(this, new U(G, R)) > 0;
    }, i.isGreaterThanOrEqualTo = i.gte = function(G, R) {
        return (R = Gu(this, new U(G, R))) === 1 || R === 0;
    }, i.isInteger = function() {
        return !!this.c && ns(this.e / fr) > this.c.length - 2;
    }, i.isLessThan = i.lt = function(G, R) {
        return Gu(this, new U(G, R)) < 0;
    }, i.isLessThanOrEqualTo = i.lte = function(G, R) {
        return (R = Gu(this, new U(G, R))) === -1 || R === 0;
    }, i.isNaN = function() {
        return !this.s;
    }, i.isNegative = function() {
        return this.s < 0;
    }, i.isPositive = function() {
        return this.s > 0;
    }, i.isZero = function() {
        return !!this.c && this.c[0] == 0;
    }, i.minus = function(G, R) {
        var X, $, S, w, g = this, m = g.s;
        if (G = new U(G, R), R = G.s, !m || !R) return new U(NaN);
        if (m != R) return G.s = -R, g.plus(G);
        var E = g.e / fr, T = G.e / fr, I = g.c, P = G.c;
        if (!E || !T) {
            if (!I || !P) return I ? (G.s = -R, G) : new U(P ? g : NaN);
            if (!I[0] || !P[0]) return P[0] ? (G.s = -R, G) : new U(I[0] ? g : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            a == 3 ? -0 : 0);
        }
        if (E = ns(E), T = ns(T), I = I.slice(), m = E - T) {
            for((w = m < 0) ? (m = -m, S = I) : (T = E, S = P), S.reverse(), R = m; R--; S.push(0));
            S.reverse();
        } else for($ = (w = (m = I.length) < (R = P.length)) ? m : R, m = R = 0; R < $; R++)if (I[R] != P[R]) {
            w = I[R] < P[R];
            break;
        }
        if (w && (S = I, I = P, P = S, G.s = -G.s), R = ($ = P.length) - (X = I.length), R > 0) for(; R--; I[X++] = 0);
        for(R = Ss - 1; $ > m;){
            if (I[--$] < P[$]) {
                for(X = $; X && !I[--X]; I[X] = R);
                --I[X], I[$] += Ss;
            }
            I[$] -= P[$];
        }
        for(; I[0] == 0; I.splice(0, 1), --T);
        return I[0] ? K(G, I, T) : (G.s = a == 3 ? -1 : 1, G.c = [
            G.e = 0
        ], G);
    }, i.modulo = i.mod = function(G, R) {
        var X, $, S = this;
        return G = new U(G, R), !S.c || !G.s || G.c && !G.c[0] ? new U(NaN) : !G.c || S.c && !S.c[0] ? new U(S) : (y == 9 ? ($ = G.s, G.s = 1, X = t(S, G, 0, 3), G.s = $, X.s *= $) : X = t(S, G, 0, y), G = S.minus(X.times(G)), !G.c[0] && y == 1 && (G.s = S.s), G);
    }, i.multipliedBy = i.times = function(G, R) {
        var X, $, S, w, g, m, E, T, I, P, k, L, j, ie, ue, ce = this, he = ce.c, ee = (G = new U(G, R)).c;
        if (!he || !ee || !he[0] || !ee[0]) return !ce.s || !G.s || he && !he[0] && !ee || ee && !ee[0] && !he ? G.c = G.e = G.s = null : (G.s *= ce.s, !he || !ee ? G.c = G.e = null : (G.c = [
            0
        ], G.e = 0)), G;
        for($ = ns(ce.e / fr) + ns(G.e / fr), G.s *= ce.s, E = he.length, P = ee.length, E < P && (j = he, he = ee, ee = j, S = E, E = P, P = S), S = E + P, j = []; S--; j.push(0));
        for(ie = Ss, ue = Xc, S = P; --S >= 0;){
            for(X = 0, k = ee[S] % ue, L = ee[S] / ue | 0, g = E, w = S + g; w > S;)T = he[--g] % ue, I = he[g] / ue | 0, m = L * T + I * k, T = k * T + m % ue * ue + j[w] + X, X = (T / ie | 0) + (m / ue | 0) + L * I, j[w--] = T % ie;
            j[w] = X;
        }
        return X ? ++$ : j.splice(0, 1), K(G, j, $);
    }, i.negated = function() {
        var G = new U(this);
        return G.s = -G.s || null, G;
    }, i.plus = function(G, R) {
        var X, $ = this, S = $.s;
        if (G = new U(G, R), R = G.s, !S || !R) return new U(NaN);
        if (S != R) return G.s = -R, $.minus(G);
        var w = $.e / fr, g = G.e / fr, m = $.c, E = G.c;
        if (!w || !g) {
            if (!m || !E) return new U(S / 0);
            if (!m[0] || !E[0]) return E[0] ? G : new U(m[0] ? $ : S * 0);
        }
        if (w = ns(w), g = ns(g), m = m.slice(), S = w - g) {
            for(S > 0 ? (g = w, X = E) : (S = -S, X = m), X.reverse(); S--; X.push(0));
            X.reverse();
        }
        for(S = m.length, R = E.length, S - R < 0 && (X = E, E = m, m = X, R = S), S = 0; R;)S = (m[--R] = m[R] + E[R] + S) / Ss | 0, m[R] = Ss === m[R] ? 0 : m[R] % Ss;
        return S && (m = [
            S
        ].concat(m), ++g), K(G, m, g);
    }, i.precision = i.sd = function(G, R) {
        var X, $, S, w = this;
        if (G != null && G !== !!G) return vn(G, 1, ri), R == null ? R = a : vn(R, 0, 8), re(new U(w), G, R);
        if (!(X = w.c)) return null;
        if (S = X.length - 1, $ = S * fr + 1, S = X[S]) {
            for(; S % 10 == 0; S /= 10, $--);
            for(S = X[0]; S >= 10; S /= 10, $++);
        }
        return G && w.e + 1 > $ && ($ = w.e + 1), $;
    }, i.shiftedBy = function(G) {
        return vn(G, -dE, dE), this.times("1e" + G);
    }, i.squareRoot = i.sqrt = function() {
        var G, R, X, $, S, w = this, g = w.c, m = w.s, E = w.e, T = s + 4, I = new U("0.5");
        if (m !== 1 || !g || !g[0]) return new U(!m || m < 0 && (!g || g[0]) ? NaN : g ? w : 1 / 0);
        if (m = Math.sqrt(+Q(w)), m == 0 || m == 1 / 0 ? (R = ts(g), (R.length + E) % 2 == 0 && (R += "0"), m = Math.sqrt(+R), E = ns((E + 1) / 2) - (E < 0 || E % 2), m == 1 / 0 ? R = "5e" + E : (R = m.toExponential(), R = R.slice(0, R.indexOf("e") + 1) + E), X = new U(R)) : X = new U(m + ""), X.c[0]) {
            for(E = X.e, m = E + T, m < 3 && (m = 0);;)if (S = X, X = I.times(S.plus(t(w, S, T, 1))), ts(S.c).slice(0, m) === (R = ts(X.c)).slice(0, m)) if (X.e < E && --m, R = R.slice(m - 3, m + 1), R == "9999" || !$ && R == "4999") {
                if (!$ && (re(S, S.e + s + 2, 0), S.times(S).eq(w))) {
                    X = S;
                    break;
                }
                T += 4, m += 4, $ = 1;
            } else {
                (!+R || !+R.slice(1) && R.charAt(0) == "5") && (re(X, X.e + s + 2, 1), G = !X.times(X).eq(w));
                break;
            }
        }
        return re(X, X.e + s + 1, a, G);
    }, i.toExponential = function(G, R) {
        return G != null && (vn(G, 0, ri), G++), D(this, G, R, 1);
    }, i.toFixed = function(G, R) {
        return G != null && (vn(G, 0, ri), G = G + this.e + 1), D(this, G, R);
    }, i.toFormat = function(G, R, X) {
        var $, S = this;
        if (X == null) G != null && R && typeof R == "object" ? (X = R, R = null) : G && typeof G == "object" ? (X = G, G = R = null) : X = A;
        else if (typeof X != "object") throw Error(to + "Argument not an object: " + X);
        if ($ = S.toFixed(G, R), S.c) {
            var w, g = $.split("."), m = +X.groupSize, E = +X.secondaryGroupSize, T = X.groupSeparator || "", I = g[0], P = g[1], k = S.s < 0, L = k ? I.slice(1) : I, j = L.length;
            if (E && (w = m, m = E, E = w, j -= w), m > 0 && j > 0) {
                for(w = j % m || m, I = L.substr(0, w); w < j; w += m)I += T + L.substr(w, m);
                E > 0 && (I += T + L.slice(w)), k && (I = "-" + I);
            }
            $ = P ? I + (X.decimalSeparator || "") + ((E = +X.fractionGroupSize) ? P.replace(new RegExp("\\d{" + E + "}\\B", "g"), "$&" + (X.fractionGroupSeparator || "")) : P) : I;
        }
        return (X.prefix || "") + $ + (X.suffix || "");
    }, i.toFraction = function(G) {
        var R, X, $, S, w, g, m, E, T, I, P, k, L = this, j = L.c;
        if (G != null && (m = new U(G), !m.isInteger() && (m.c || m.s !== 1) || m.lt(o))) throw Error(to + "Argument " + (m.isInteger() ? "out of range: " : "not an integer: ") + Q(m));
        if (!j) return new U(L);
        for(R = new U(o), T = X = new U(o), $ = E = new U(o), k = ts(j), w = R.e = k.length - L.e - 1, R.c[0] = hE[(g = w % fr) < 0 ? fr + g : g], G = !G || m.comparedTo(R) > 0 ? w > 0 ? R : T : m, g = l, l = 1 / 0, m = new U(k), E.c[0] = 0; I = t(m, R, 0, 1), S = X.plus(I.times($)), S.comparedTo(G) != 1;)X = $, $ = S, T = E.plus(I.times(S = T)), E = S, R = m.minus(I.times(S = R)), m = S;
        return S = t(G.minus(X), $, 0, 1), E = E.plus(S.times(T)), X = X.plus(S.times($)), E.s = T.s = L.s, w = w * 2, P = t(T, $, w, a).minus(L).abs().comparedTo(t(E, X, w, a).minus(L).abs()) < 1 ? [
            T,
            $
        ] : [
            E,
            X
        ], l = g, P;
    }, i.toNumber = function() {
        return +Q(this);
    }, i.toPrecision = function(G, R) {
        return G != null && vn(G, 1, ri), D(this, G, R, 2);
    }, i.toString = function(G) {
        var R, X = this, $ = X.s, S = X.e;
        return S === null ? $ ? (R = "Infinity", $ < 0 && (R = "-" + R)) : R = "NaN" : (G == null ? R = S <= u || S >= f ? vy(ts(X.c), S) : Va(ts(X.c), S, "0") : G === 10 && N ? (X = re(new U(X), s + S + 1, a), R = Va(ts(X.c), X.e, "0")) : (vn(G, 2, O.length, "Base"), R = r(Va(ts(X.c), S, "0"), 10, G, $, !0)), $ < 0 && X.c[0] && (R = "-" + R)), R;
    }, i.valueOf = i.toJSON = function() {
        return Q(this);
    }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, e != null && U.set(e), U;
}
function ns(e) {
    var t = e | 0;
    return e > 0 || e === t ? t : t - 1;
}
function ts(e) {
    for(var t, r, n = 1, i = e.length, o = e[0] + ""; n < i;){
        for(t = e[n++] + "", r = fr - t.length; r--; t = "0" + t);
        o += t;
    }
    for(i = o.length; o.charCodeAt(--i) === 48;);
    return o.slice(0, i + 1 || 1);
}
function Gu(e, t) {
    var r, n, i = e.c, o = t.c, s = e.s, a = t.s, u = e.e, f = t.e;
    if (!s || !a) return null;
    if (r = i && !i[0], n = o && !o[0], r || n) return r ? n ? 0 : -a : s;
    if (s != a) return s;
    if (r = s < 0, n = u == f, !i || !o) return n ? 0 : !i ^ r ? 1 : -1;
    if (!n) return u > f ^ r ? 1 : -1;
    for(a = (u = i.length) < (f = o.length) ? u : f, s = 0; s < a; s++)if (i[s] != o[s]) return i[s] > o[s] ^ r ? 1 : -1;
    return u == f ? 0 : u > f ^ r ? 1 : -1;
}
function vn(e, t, r, n) {
    if (e < t || e > r || e !== rs(e)) throw Error(to + (n || "Argument") + (typeof e == "number" ? e < t || e > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function wy(e) {
    var t = e.c.length - 1;
    return ns(e.e / fr) == t && e.c[t] % 2 != 0;
}
function vy(e, t) {
    return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function Va(e, t, r) {
    var n, i;
    if (t < 0) {
        for(i = r + "."; ++t; i += r);
        e = i + e;
    } else if (n = e.length, ++t > n) {
        for(i = r, t -= n; --t; i += r);
        e += i;
    } else t < n && (e = e.slice(0, t) + "." + e.slice(t));
    return e;
}
lU();
var _be = [
    "mainnet",
    "testnet"
], Ebe = [
    "testnet",
    "regtest",
    "signet"
], xbe = [
    "mainnet",
    "testnet3",
    "testnet4",
    "regtest",
    "signet"
], Sbe = Te.enum([
    ..._be,
    ...Ebe
]), Abe = Te.enum([
    ...xbe
]);
Te.object({
    name: Te.string(),
    id: Te.string(),
    chain: Te.object({
        bitcoin: Te.object({
            blockchain: Te.literal("bitcoin"),
            bitcoinUrl: Te.string(),
            bitcoinNetwork: Abe,
            mode: Sbe
        }),
        stacks: Te.object({
            blockchain: Te.literal("stacks"),
            url: Te.string(),
            chainId: Te.number(),
            subnetChainId: Te.number().optional()
        })
    })
});
Te.string().email({
    message: "Invalid email address"
});
var Tbe = Te.object({
    fingerprint: Te.string()
}), kbe = Tbe.merge(Te.object({
    accountIndex: Te.number()
})), Ibe = Te.object({
    taprootDescriptor: Te.string(),
    nativeSegwitDescriptor: Te.string()
}), Bbe = Te.object({
    stxAddress: Te.string()
});
Te.object({
    id: kbe,
    bitcoin: Ibe.optional(),
    stacks: Bbe.optional()
});
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */ const { entries: dU, setPrototypeOf: vB, isFrozen: Obe, getPrototypeOf: Pbe, getOwnPropertyDescriptor: Nbe } = Object;
let { freeze: Vi, seal: gs, create: hU } = Object, { apply: Vx, construct: Gx } = typeof Reflect < "u" && Reflect;
Vi || (Vi = function(t) {
    return t;
});
gs || (gs = function(t) {
    return t;
});
Vx || (Vx = function(t, r, n) {
    return t.apply(r, n);
});
Gx || (Gx = function(t, r) {
    return new t(...r);
});
const _y = Gi(Array.prototype.forEach), Mbe = Gi(Array.prototype.lastIndexOf), _B = Gi(Array.prototype.pop), vh = Gi(Array.prototype.push), Rbe = Gi(Array.prototype.splice), jy = Gi(String.prototype.toLowerCase), pE = Gi(String.prototype.toString), EB = Gi(String.prototype.match), _h = Gi(String.prototype.replace), Cbe = Gi(String.prototype.indexOf), Ube = Gi(String.prototype.trim), Ts = Gi(Object.prototype.hasOwnProperty), zi = Gi(RegExp.prototype.test), Eh = $be(TypeError);
function Gi(e) {
    return function(t) {
        for(var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)n[i - 1] = arguments[i];
        return Vx(e, t, n);
    };
}
function $be(e) {
    return function() {
        for(var t = arguments.length, r = new Array(t), n = 0; n < t; n++)r[n] = arguments[n];
        return Gx(e, r);
    };
}
function Nr(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : jy;
    vB && vB(e, null);
    let n = t.length;
    for(; n--;){
        let i = t[n];
        if (typeof i == "string") {
            const o = r(i);
            o !== i && (Obe(t) || (t[n] = o), i = o);
        }
        e[i] = !0;
    }
    return e;
}
function Lbe(e) {
    for(let t = 0; t < e.length; t++)Ts(e, t) || (e[t] = null);
    return e;
}
function Ju(e) {
    const t = hU(null);
    for (const [r, n] of dU(e))Ts(e, r) && (Array.isArray(n) ? t[r] = Lbe(n) : n && typeof n == "object" && n.constructor === Object ? t[r] = Ju(n) : t[r] = n);
    return t;
}
function xh(e, t) {
    for(; e !== null;){
        const n = Nbe(e, t);
        if (n) {
            if (n.get) return Gi(n.get);
            if (typeof n.value == "function") return Gi(n.value);
        }
        e = Pbe(e);
    }
    function r() {
        return null;
    }
    return r;
}
const xB = Vi([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
]), gE = Vi([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
]), yE = Vi([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
]), Dbe = Vi([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
]), mE = Vi([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts"
]), Fbe = Vi([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
]), SB = Vi([
    "#text"
]), AB = Vi([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "wrap",
    "xmlns",
    "slot"
]), bE = Vi([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "amplitude",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "exponent",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "intercept",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "slope",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "tablevalues",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
]), TB = Vi([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
]), Ey = Vi([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
]), zbe = gs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), jbe = gs(/<%[\w\W]*|[\w\W]*%>/gm), Hbe = gs(/\$\{[\w\W]*/gm), qbe = gs(/^data-[\-\w.\u00B7-\uFFFF]+$/), Kbe = gs(/^aria-[\-\w]+$/), pU = gs(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Wbe = gs(/^(?:\w+script|data):/i), Vbe = gs(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), gU = gs(/^html$/i), Gbe = gs(/^[a-z][.\w]*(-[.\w]+)+$/i);
var kB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR: Kbe,
    ATTR_WHITESPACE: Vbe,
    CUSTOM_ELEMENT: Gbe,
    DATA_ATTR: qbe,
    DOCTYPE_NAME: gU,
    ERB_EXPR: jbe,
    IS_ALLOWED_URI: pU,
    IS_SCRIPT_OR_DATA: Wbe,
    MUSTACHE_EXPR: zbe,
    TMPLIT_EXPR: Hbe
});
const Sh = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
}, Zbe = function() {
    return ("TURBOPACK compile-time value", "undefined") > "u" ? null : window;
}, Ybe = function(t, r) {
    if (typeof t != "object" || typeof t.createPolicy != "function") return null;
    let n = null;
    const i = "data-tt-policy-suffix";
    r && r.hasAttribute(i) && (n = r.getAttribute(i));
    const o = "dompurify" + (n ? "#" + n : "");
    try {
        return t.createPolicy(o, {
            createHTML (s) {
                return s;
            },
            createScriptURL (s) {
                return s;
            }
        });
    } catch  {
        return console.warn("TrustedTypes policy " + o + " could not be created."), null;
    }
}, IB = function() {
    return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
    };
};
function yU() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Zbe();
    const t = (St)=>yU(St);
    if (t.version = "3.2.4", t.removed = [], !e || !e.document || e.document.nodeType !== Sh.document || !e.Element) return t.isSupported = !1, t;
    let { document: r } = e;
    const n = r, i = n.currentScript, { DocumentFragment: o, HTMLTemplateElement: s, Node: a, Element: u, NodeFilter: f, NamedNodeMap: c = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: l, DOMParser: p, trustedTypes: y } = e, _ = u.prototype, A = xh(_, "cloneNode"), O = xh(_, "remove"), N = xh(_, "nextSibling"), U = xh(_, "childNodes"), D = xh(_, "parentNode");
    if (typeof s == "function") {
        const St = r.createElement("template");
        St.content && St.content.ownerDocument && (r = St.content.ownerDocument);
    }
    let H, K = "";
    const { implementation: re, createNodeIterator: Q, createDocumentFragment: G, getElementsByTagName: R } = r, { importNode: X } = n;
    let $ = IB();
    t.isSupported = typeof dU == "function" && typeof D == "function" && re && re.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: S, ERB_EXPR: w, TMPLIT_EXPR: g, DATA_ATTR: m, ARIA_ATTR: E, IS_SCRIPT_OR_DATA: T, ATTR_WHITESPACE: I, CUSTOM_ELEMENT: P } = kB;
    let { IS_ALLOWED_URI: k } = kB, L = null;
    const j = Nr({}, [
        ...xB,
        ...gE,
        ...yE,
        ...mE,
        ...SB
    ]);
    let ie = null;
    const ue = Nr({}, [
        ...AB,
        ...bE,
        ...TB,
        ...Ey
    ]);
    let ce = Object.seal(hU(null, {
        tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
        }
    })), he = null, ee = null, ae = !0, ye = !0, Se = !1, De = !0, Re = !1, Ce = !0, M = !1, z = !1, de = !1, _e = !1, Ie = !1, je = !1, Ke = !0, Ue = !1;
    const h = "user-content-";
    let x = !0, q = !1, te = {}, fe = null;
    const ne = Nr({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
    ]);
    let W = null;
    const J = Nr({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
    ]);
    let V = null;
    const C = Nr({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
    ]), Z = "http://www.w3.org/1998/Math/MathML", le = "http://www.w3.org/2000/svg", se = "http://www.w3.org/1999/xhtml";
    let Ne = se, Le = !1, rt = null;
    const yt = Nr({}, [
        Z,
        le,
        se
    ], pE);
    let _t = Nr({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
    ]), Qe = Nr({}, [
        "annotation-xml"
    ]);
    const Rt = Nr({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
    ]);
    let Lt = null;
    const Ur = [
        "application/xhtml+xml",
        "text/html"
    ], jr = "text/html";
    let Et = null, Xt = null;
    const wr = r.createElement("form"), zt = function(Pe) {
        return Pe instanceof RegExp || Pe instanceof Function;
    }, Ae = function() {
        let Pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(Xt && Xt === Pe)) {
            if ((!Pe || typeof Pe != "object") && (Pe = {}), Pe = Ju(Pe), Lt = Ur.indexOf(Pe.PARSER_MEDIA_TYPE) === -1 ? jr : Pe.PARSER_MEDIA_TYPE, Et = Lt === "application/xhtml+xml" ? pE : jy, L = Ts(Pe, "ALLOWED_TAGS") ? Nr({}, Pe.ALLOWED_TAGS, Et) : j, ie = Ts(Pe, "ALLOWED_ATTR") ? Nr({}, Pe.ALLOWED_ATTR, Et) : ue, rt = Ts(Pe, "ALLOWED_NAMESPACES") ? Nr({}, Pe.ALLOWED_NAMESPACES, pE) : yt, V = Ts(Pe, "ADD_URI_SAFE_ATTR") ? Nr(Ju(C), Pe.ADD_URI_SAFE_ATTR, Et) : C, W = Ts(Pe, "ADD_DATA_URI_TAGS") ? Nr(Ju(J), Pe.ADD_DATA_URI_TAGS, Et) : J, fe = Ts(Pe, "FORBID_CONTENTS") ? Nr({}, Pe.FORBID_CONTENTS, Et) : ne, he = Ts(Pe, "FORBID_TAGS") ? Nr({}, Pe.FORBID_TAGS, Et) : {}, ee = Ts(Pe, "FORBID_ATTR") ? Nr({}, Pe.FORBID_ATTR, Et) : {}, te = Ts(Pe, "USE_PROFILES") ? Pe.USE_PROFILES : !1, ae = Pe.ALLOW_ARIA_ATTR !== !1, ye = Pe.ALLOW_DATA_ATTR !== !1, Se = Pe.ALLOW_UNKNOWN_PROTOCOLS || !1, De = Pe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Re = Pe.SAFE_FOR_TEMPLATES || !1, Ce = Pe.SAFE_FOR_XML !== !1, M = Pe.WHOLE_DOCUMENT || !1, _e = Pe.RETURN_DOM || !1, Ie = Pe.RETURN_DOM_FRAGMENT || !1, je = Pe.RETURN_TRUSTED_TYPE || !1, de = Pe.FORCE_BODY || !1, Ke = Pe.SANITIZE_DOM !== !1, Ue = Pe.SANITIZE_NAMED_PROPS || !1, x = Pe.KEEP_CONTENT !== !1, q = Pe.IN_PLACE || !1, k = Pe.ALLOWED_URI_REGEXP || pU, Ne = Pe.NAMESPACE || se, _t = Pe.MATHML_TEXT_INTEGRATION_POINTS || _t, Qe = Pe.HTML_INTEGRATION_POINTS || Qe, ce = Pe.CUSTOM_ELEMENT_HANDLING || {}, Pe.CUSTOM_ELEMENT_HANDLING && zt(Pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ce.tagNameCheck = Pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Pe.CUSTOM_ELEMENT_HANDLING && zt(Pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ce.attributeNameCheck = Pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Pe.CUSTOM_ELEMENT_HANDLING && typeof Pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ce.allowCustomizedBuiltInElements = Pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Re && (ye = !1), Ie && (_e = !0), te && (L = Nr({}, SB), ie = [], te.html === !0 && (Nr(L, xB), Nr(ie, AB)), te.svg === !0 && (Nr(L, gE), Nr(ie, bE), Nr(ie, Ey)), te.svgFilters === !0 && (Nr(L, yE), Nr(ie, bE), Nr(ie, Ey)), te.mathMl === !0 && (Nr(L, mE), Nr(ie, TB), Nr(ie, Ey))), Pe.ADD_TAGS && (L === j && (L = Ju(L)), Nr(L, Pe.ADD_TAGS, Et)), Pe.ADD_ATTR && (ie === ue && (ie = Ju(ie)), Nr(ie, Pe.ADD_ATTR, Et)), Pe.ADD_URI_SAFE_ATTR && Nr(V, Pe.ADD_URI_SAFE_ATTR, Et), Pe.FORBID_CONTENTS && (fe === ne && (fe = Ju(fe)), Nr(fe, Pe.FORBID_CONTENTS, Et)), x && (L["#text"] = !0), M && Nr(L, [
                "html",
                "head",
                "body"
            ]), L.table && (Nr(L, [
                "tbody"
            ]), delete he.tbody), Pe.TRUSTED_TYPES_POLICY) {
                if (typeof Pe.TRUSTED_TYPES_POLICY.createHTML != "function") throw Eh('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
                if (typeof Pe.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw Eh('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
                H = Pe.TRUSTED_TYPES_POLICY, K = H.createHTML("");
            } else H === void 0 && (H = Ybe(y, i)), H !== null && typeof K == "string" && (K = H.createHTML(""));
            Vi && Vi(Pe), Xt = Pe;
        }
    }, we = Nr({}, [
        ...gE,
        ...yE,
        ...Dbe
    ]), xe = Nr({}, [
        ...mE,
        ...Fbe
    ]), Me = function(Pe) {
        let et = D(Pe);
        (!et || !et.tagName) && (et = {
            namespaceURI: Ne,
            tagName: "template"
        });
        const vt = jy(Pe.tagName), be = jy(et.tagName);
        return rt[Pe.namespaceURI] ? Pe.namespaceURI === le ? et.namespaceURI === se ? vt === "svg" : et.namespaceURI === Z ? vt === "svg" && (be === "annotation-xml" || _t[be]) : !!we[vt] : Pe.namespaceURI === Z ? et.namespaceURI === se ? vt === "math" : et.namespaceURI === le ? vt === "math" && Qe[be] : !!xe[vt] : Pe.namespaceURI === se ? et.namespaceURI === le && !Qe[be] || et.namespaceURI === Z && !_t[be] ? !1 : !xe[vt] && (Rt[vt] || !we[vt]) : !!(Lt === "application/xhtml+xml" && rt[Pe.namespaceURI]) : !1;
    }, ze = function(Pe) {
        vh(t.removed, {
            element: Pe
        });
        try {
            D(Pe).removeChild(Pe);
        } catch  {
            O(Pe);
        }
    }, Ve = function(Pe, et) {
        try {
            vh(t.removed, {
                attribute: et.getAttributeNode(Pe),
                from: et
            });
        } catch  {
            vh(t.removed, {
                attribute: null,
                from: et
            });
        }
        if (et.removeAttribute(Pe), Pe === "is") if (_e || Ie) try {
            ze(et);
        } catch  {}
        else try {
            et.setAttribute(Pe, "");
        } catch  {}
    }, at = function(Pe) {
        let et = null, vt = null;
        if (de) Pe = "<remove></remove>" + Pe;
        else {
            const jt = EB(Pe, /^[\r\n\t ]+/);
            vt = jt && jt[0];
        }
        Lt === "application/xhtml+xml" && Ne === se && (Pe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Pe + "</body></html>");
        const be = H ? H.createHTML(Pe) : Pe;
        if (Ne === se) try {
            et = new p().parseFromString(be, Lt);
        } catch  {}
        if (!et || !et.documentElement) {
            et = re.createDocument(Ne, "template", null);
            try {
                et.documentElement.innerHTML = Le ? K : be;
            } catch  {}
        }
        const $r = et.body || et.documentElement;
        return Pe && vt && $r.insertBefore(r.createTextNode(vt), $r.childNodes[0] || null), Ne === se ? R.call(et, M ? "html" : "body")[0] : M ? et.documentElement : $r;
    }, ct = function(Pe) {
        return Q.call(Pe.ownerDocument || Pe, Pe, // eslint-disable-next-line no-bitwise
        f.SHOW_ELEMENT | f.SHOW_COMMENT | f.SHOW_TEXT | f.SHOW_PROCESSING_INSTRUCTION | f.SHOW_CDATA_SECTION, null);
    }, lt = function(Pe) {
        return Pe instanceof l && (typeof Pe.nodeName != "string" || typeof Pe.textContent != "string" || typeof Pe.removeChild != "function" || !(Pe.attributes instanceof c) || typeof Pe.removeAttribute != "function" || typeof Pe.setAttribute != "function" || typeof Pe.namespaceURI != "string" || typeof Pe.insertBefore != "function" || typeof Pe.hasChildNodes != "function");
    }, mt = function(Pe) {
        return typeof a == "function" && Pe instanceof a;
    };
    function wt(St, Pe, et) {
        _y(St, (vt)=>{
            vt.call(t, Pe, et, Xt);
        });
    }
    const bt = function(Pe) {
        let et = null;
        if (wt($.beforeSanitizeElements, Pe, null), lt(Pe)) return ze(Pe), !0;
        const vt = Et(Pe.nodeName);
        if (wt($.uponSanitizeElement, Pe, {
            tagName: vt,
            allowedTags: L
        }), Pe.hasChildNodes() && !mt(Pe.firstElementChild) && zi(/<[/\w]/g, Pe.innerHTML) && zi(/<[/\w]/g, Pe.textContent) || Pe.nodeType === Sh.progressingInstruction || Ce && Pe.nodeType === Sh.comment && zi(/<[/\w]/g, Pe.data)) return ze(Pe), !0;
        if (!L[vt] || he[vt]) {
            if (!he[vt] && Ct(vt) && (ce.tagNameCheck instanceof RegExp && zi(ce.tagNameCheck, vt) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(vt))) return !1;
            if (x && !fe[vt]) {
                const be = D(Pe) || Pe.parentNode, $r = U(Pe) || Pe.childNodes;
                if ($r && be) {
                    const jt = $r.length;
                    for(let nr = jt - 1; nr >= 0; --nr){
                        const kt = A($r[nr], !0);
                        kt.__removalCount = (Pe.__removalCount || 0) + 1, be.insertBefore(kt, N(Pe));
                    }
                }
            }
            return ze(Pe), !0;
        }
        return Pe instanceof u && !Me(Pe) || (vt === "noscript" || vt === "noembed" || vt === "noframes") && zi(/<\/no(script|embed|frames)/i, Pe.innerHTML) ? (ze(Pe), !0) : (Re && Pe.nodeType === Sh.text && (et = Pe.textContent, _y([
            S,
            w,
            g
        ], (be)=>{
            et = _h(et, be, " ");
        }), Pe.textContent !== et && (vh(t.removed, {
            element: Pe.cloneNode()
        }), Pe.textContent = et)), wt($.afterSanitizeElements, Pe, null), !1);
    }, Mt = function(Pe, et, vt) {
        if (Ke && (et === "id" || et === "name") && (vt in r || vt in wr)) return !1;
        if (!(ye && !ee[et] && zi(m, et))) {
            if (!(ae && zi(E, et))) {
                if (!ie[et] || ee[et]) {
                    if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND
                    // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                    // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                    !(Ct(Pe) && (ce.tagNameCheck instanceof RegExp && zi(ce.tagNameCheck, Pe) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(Pe)) && (ce.attributeNameCheck instanceof RegExp && zi(ce.attributeNameCheck, et) || ce.attributeNameCheck instanceof Function && ce.attributeNameCheck(et)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                    // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                    et === "is" && ce.allowCustomizedBuiltInElements && (ce.tagNameCheck instanceof RegExp && zi(ce.tagNameCheck, vt) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(vt)))) return !1;
                } else if (!V[et]) {
                    if (!zi(k, _h(vt, I, ""))) {
                        if (!((et === "src" || et === "xlink:href" || et === "href") && Pe !== "script" && Cbe(vt, "data:") === 0 && W[Pe])) {
                            if (!(Se && !zi(T, _h(vt, I, "")))) {
                                if (vt) return !1;
                            }
                        }
                    }
                }
            }
        }
        return !0;
    }, Ct = function(Pe) {
        return Pe !== "annotation-xml" && EB(Pe, P);
    }, Xe = function(Pe) {
        wt($.beforeSanitizeAttributes, Pe, null);
        const { attributes: et } = Pe;
        if (!et || lt(Pe)) return;
        const vt = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: ie,
            forceKeepAttr: void 0
        };
        let be = et.length;
        for(; be--;){
            const $r = et[be], { name: jt, namespaceURI: nr, value: kt } = $r, Hn = Et(jt);
            let Zr = jt === "value" ? kt : Ube(kt);
            if (vt.attrName = Hn, vt.attrValue = Zr, vt.keepAttr = !0, vt.forceKeepAttr = void 0, wt($.uponSanitizeAttribute, Pe, vt), Zr = vt.attrValue, Ue && (Hn === "id" || Hn === "name") && (Ve(jt, Pe), Zr = h + Zr), Ce && zi(/((--!?|])>)|<\/(style|title)/i, Zr)) {
                Ve(jt, Pe);
                continue;
            }
            if (vt.forceKeepAttr || (Ve(jt, Pe), !vt.keepAttr)) continue;
            if (!De && zi(/\/>/i, Zr)) {
                Ve(jt, Pe);
                continue;
            }
            Re && _y([
                S,
                w,
                g
            ], (B)=>{
                Zr = _h(Zr, B, " ");
            });
            const v = Et(Pe.nodeName);
            if (Mt(v, Hn, Zr)) {
                if (H && typeof y == "object" && typeof y.getAttributeType == "function" && !nr) switch(y.getAttributeType(v, Hn)){
                    case "TrustedHTML":
                        {
                            Zr = H.createHTML(Zr);
                            break;
                        }
                    case "TrustedScriptURL":
                        {
                            Zr = H.createScriptURL(Zr);
                            break;
                        }
                }
                try {
                    nr ? Pe.setAttributeNS(nr, jt, Zr) : Pe.setAttribute(jt, Zr), lt(Pe) ? ze(Pe) : _B(t.removed);
                } catch  {}
            }
        }
        wt($.afterSanitizeAttributes, Pe, null);
    }, xt = function St(Pe) {
        let et = null;
        const vt = ct(Pe);
        for(wt($.beforeSanitizeShadowDOM, Pe, null); et = vt.nextNode();)wt($.uponSanitizeShadowNode, et, null), bt(et), Xe(et), et.content instanceof o && St(et.content);
        wt($.afterSanitizeShadowDOM, Pe, null);
    };
    return t.sanitize = function(St) {
        let Pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, et = null, vt = null, be = null, $r = null;
        if (Le = !St, Le && (St = "<!-->"), typeof St != "string" && !mt(St)) if (typeof St.toString == "function") {
            if (St = St.toString(), typeof St != "string") throw Eh("dirty is not a string, aborting");
        } else throw Eh("toString is not a function");
        if (!t.isSupported) return St;
        if (z || Ae(Pe), t.removed = [], typeof St == "string" && (q = !1), q) {
            if (St.nodeName) {
                const kt = Et(St.nodeName);
                if (!L[kt] || he[kt]) throw Eh("root node is forbidden and cannot be sanitized in-place");
            }
        } else if (St instanceof a) et = at("<!---->"), vt = et.ownerDocument.importNode(St, !0), vt.nodeType === Sh.element && vt.nodeName === "BODY" || vt.nodeName === "HTML" ? et = vt : et.appendChild(vt);
        else {
            if (!_e && !Re && !M && // eslint-disable-next-line unicorn/prefer-includes
            St.indexOf("<") === -1) return H && je ? H.createHTML(St) : St;
            if (et = at(St), !et) return _e ? null : je ? K : "";
        }
        et && de && ze(et.firstChild);
        const jt = ct(q ? St : et);
        for(; be = jt.nextNode();)bt(be), Xe(be), be.content instanceof o && xt(be.content);
        if (q) return St;
        if (_e) {
            if (Ie) for($r = G.call(et.ownerDocument); et.firstChild;)$r.appendChild(et.firstChild);
            else $r = et;
            return (ie.shadowroot || ie.shadowrootmode) && ($r = X.call(n, $r, !0)), $r;
        }
        let nr = M ? et.outerHTML : et.innerHTML;
        return M && L["!doctype"] && et.ownerDocument && et.ownerDocument.doctype && et.ownerDocument.doctype.name && zi(gU, et.ownerDocument.doctype.name) && (nr = "<!DOCTYPE " + et.ownerDocument.doctype.name + `>
` + nr), Re && _y([
            S,
            w,
            g
        ], (kt)=>{
            nr = _h(nr, kt, " ");
        }), H && je ? H.createHTML(nr) : nr;
    }, t.setConfig = function() {
        let St = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Ae(St), z = !0;
    }, t.clearConfig = function() {
        Xt = null, z = !1;
    }, t.isValidAttribute = function(St, Pe, et) {
        Xt || Ae({});
        const vt = Et(St), be = Et(Pe);
        return Mt(vt, be, et);
    }, t.addHook = function(St, Pe) {
        typeof Pe == "function" && vh($[St], Pe);
    }, t.removeHook = function(St, Pe) {
        if (Pe !== void 0) {
            const et = Mbe($[St], Pe);
            return et === -1 ? void 0 : Rbe($[St], et, 1)[0];
        }
        return _B($[St]);
    }, t.removeHooks = function(St) {
        $[St] = [];
    }, t.removeAllHooks = function() {
        $ = IB();
    }, t;
}
yU();
var Xbe = [
    {
        name: "US Dollar",
        symbol: "$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "USD",
        namePlural: "US dollars"
    },
    {
        name: "Canadian Dollar",
        symbol: "CA$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "CAD",
        namePlural: "Canadian dollars"
    },
    {
        name: "Euro",
        symbol: "€",
        symbolNative: "€",
        decimalDigits: 2,
        rounding: 0,
        code: "EUR",
        namePlural: "euros"
    },
    {
        name: "United Arab Emirates Dirham",
        symbol: "AED",
        symbolNative: "د.إ.‏",
        decimalDigits: 2,
        rounding: 0,
        code: "AED",
        namePlural: "UAE dirhams"
    },
    {
        name: "Afghan Afghani",
        symbol: "Af",
        symbolNative: "؋",
        decimalDigits: 0,
        rounding: 0,
        code: "AFN",
        namePlural: "Afghan Afghanis"
    },
    {
        name: "Albanian Lek",
        symbol: "ALL",
        symbolNative: "Lek",
        decimalDigits: 0,
        rounding: 0,
        code: "ALL",
        namePlural: "Albanian lekë"
    },
    {
        name: "Armenian Dram",
        symbol: "AMD",
        symbolNative: "դր.",
        decimalDigits: 0,
        rounding: 0,
        code: "AMD",
        namePlural: "Armenian drams"
    },
    {
        name: "Argentine Peso",
        symbol: "AR$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "ARS",
        namePlural: "Argentine pesos"
    },
    {
        name: "Australian Dollar",
        symbol: "AU$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "AUD",
        namePlural: "Australian dollars"
    },
    {
        name: "Azerbaijani Manat",
        symbol: "man.",
        symbolNative: "ман.",
        decimalDigits: 2,
        rounding: 0,
        code: "AZN",
        namePlural: "Azerbaijani manats"
    },
    {
        name: "Bosnia-Herzegovina Convertible Mark",
        symbol: "KM",
        symbolNative: "KM",
        decimalDigits: 2,
        rounding: 0,
        code: "BAM",
        namePlural: "Bosnia-Herzegovina convertible marks"
    },
    {
        name: "Bangladeshi Taka",
        symbol: "Tk",
        symbolNative: "৳",
        decimalDigits: 2,
        rounding: 0,
        code: "BDT",
        namePlural: "Bangladeshi takas"
    },
    {
        name: "Bulgarian Lev",
        symbol: "BGN",
        symbolNative: "лв.",
        decimalDigits: 2,
        rounding: 0,
        code: "BGN",
        namePlural: "Bulgarian leva"
    },
    {
        name: "Bahraini Dinar",
        symbol: "BD",
        symbolNative: "د.ب.‏",
        decimalDigits: 3,
        rounding: 0,
        code: "BHD",
        namePlural: "Bahraini dinars"
    },
    {
        name: "Burundian Franc",
        symbol: "FBu",
        symbolNative: "FBu",
        decimalDigits: 0,
        rounding: 0,
        code: "BIF",
        namePlural: "Burundian francs"
    },
    {
        name: "Brunei Dollar",
        symbol: "BN$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "BND",
        namePlural: "Brunei dollars"
    },
    {
        name: "Bolivian Boliviano",
        symbol: "Bs",
        symbolNative: "Bs",
        decimalDigits: 2,
        rounding: 0,
        code: "BOB",
        namePlural: "Bolivian bolivianos"
    },
    {
        name: "Brazilian Real",
        symbol: "R$",
        symbolNative: "R$",
        decimalDigits: 2,
        rounding: 0,
        code: "BRL",
        namePlural: "Brazilian reals"
    },
    {
        name: "Botswanan Pula",
        symbol: "BWP",
        symbolNative: "P",
        decimalDigits: 2,
        rounding: 0,
        code: "BWP",
        namePlural: "Botswanan pulas"
    },
    {
        name: "Belarusian Ruble",
        symbol: "Br",
        symbolNative: "руб.",
        decimalDigits: 2,
        rounding: 0,
        code: "BYN",
        namePlural: "Belarusian rubles"
    },
    {
        name: "Belize Dollar",
        symbol: "BZ$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "BZD",
        namePlural: "Belize dollars"
    },
    {
        name: "Congolese Franc",
        symbol: "CDF",
        symbolNative: "FrCD",
        decimalDigits: 2,
        rounding: 0,
        code: "CDF",
        namePlural: "Congolese francs"
    },
    {
        name: "Swiss Franc",
        symbol: "CHF",
        symbolNative: "CHF",
        decimalDigits: 2,
        rounding: 0.05,
        code: "CHF",
        namePlural: "Swiss francs"
    },
    {
        name: "Chilean Peso",
        symbol: "CL$",
        symbolNative: "$",
        decimalDigits: 0,
        rounding: 0,
        code: "CLP",
        namePlural: "Chilean pesos"
    },
    {
        name: "Chinese Yuan",
        symbol: "CN¥",
        symbolNative: "CN¥",
        decimalDigits: 2,
        rounding: 0,
        code: "CNY",
        namePlural: "Chinese yuan"
    },
    {
        name: "Colombian Peso",
        symbol: "CO$",
        symbolNative: "$",
        decimalDigits: 0,
        rounding: 0,
        code: "COP",
        namePlural: "Colombian pesos"
    },
    {
        name: "Costa Rican Colón",
        symbol: "₡",
        symbolNative: "₡",
        decimalDigits: 0,
        rounding: 0,
        code: "CRC",
        namePlural: "Costa Rican colóns"
    },
    {
        name: "Cape Verdean Escudo",
        symbol: "CV$",
        symbolNative: "CV$",
        decimalDigits: 2,
        rounding: 0,
        code: "CVE",
        namePlural: "Cape Verdean escudos"
    },
    {
        name: "Czech Republic Koruna",
        symbol: "Kč",
        symbolNative: "Kč",
        decimalDigits: 2,
        rounding: 0,
        code: "CZK",
        namePlural: "Czech Republic korunas"
    },
    {
        name: "Djiboutian Franc",
        symbol: "Fdj",
        symbolNative: "Fdj",
        decimalDigits: 0,
        rounding: 0,
        code: "DJF",
        namePlural: "Djiboutian francs"
    },
    {
        name: "Danish Krone",
        symbol: "Dkr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "DKK",
        namePlural: "Danish kroner"
    },
    {
        name: "Dominican Peso",
        symbol: "RD$",
        symbolNative: "RD$",
        decimalDigits: 2,
        rounding: 0,
        code: "DOP",
        namePlural: "Dominican pesos"
    },
    {
        name: "Algerian Dinar",
        symbol: "DA",
        symbolNative: "د.ج.‏",
        decimalDigits: 2,
        rounding: 0,
        code: "DZD",
        namePlural: "Algerian dinars"
    },
    {
        name: "Estonian Kroon",
        symbol: "Ekr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "EEK",
        namePlural: "Estonian kroons"
    },
    {
        name: "Egyptian Pound",
        symbol: "EGP",
        symbolNative: "ج.م.‏",
        decimalDigits: 2,
        rounding: 0,
        code: "EGP",
        namePlural: "Egyptian pounds"
    },
    {
        name: "Eritrean Nakfa",
        symbol: "Nfk",
        symbolNative: "Nfk",
        decimalDigits: 2,
        rounding: 0,
        code: "ERN",
        namePlural: "Eritrean nakfas"
    },
    {
        name: "Ethiopian Birr",
        symbol: "Br",
        symbolNative: "Br",
        decimalDigits: 2,
        rounding: 0,
        code: "ETB",
        namePlural: "Ethiopian birrs"
    },
    {
        name: "British Pound Sterling",
        symbol: "£",
        symbolNative: "£",
        decimalDigits: 2,
        rounding: 0,
        code: "GBP",
        namePlural: "British pounds sterling"
    },
    {
        name: "Georgian Lari",
        symbol: "GEL",
        symbolNative: "GEL",
        decimalDigits: 2,
        rounding: 0,
        code: "GEL",
        namePlural: "Georgian laris"
    },
    {
        name: "Ghanaian Cedi",
        symbol: "GH₵",
        symbolNative: "GH₵",
        decimalDigits: 2,
        rounding: 0,
        code: "GHS",
        namePlural: "Ghanaian cedis"
    },
    {
        name: "Guinean Franc",
        symbol: "FG",
        symbolNative: "FG",
        decimalDigits: 0,
        rounding: 0,
        code: "GNF",
        namePlural: "Guinean francs"
    },
    {
        name: "Guatemalan Quetzal",
        symbol: "GTQ",
        symbolNative: "Q",
        decimalDigits: 2,
        rounding: 0,
        code: "GTQ",
        namePlural: "Guatemalan quetzals"
    },
    {
        name: "Hong Kong Dollar",
        symbol: "HK$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "HKD",
        namePlural: "Hong Kong dollars"
    },
    {
        name: "Honduran Lempira",
        symbol: "HNL",
        symbolNative: "L",
        decimalDigits: 2,
        rounding: 0,
        code: "HNL",
        namePlural: "Honduran lempiras"
    },
    {
        name: "Croatian Kuna",
        symbol: "kn",
        symbolNative: "kn",
        decimalDigits: 2,
        rounding: 0,
        code: "HRK",
        namePlural: "Croatian kunas"
    },
    {
        name: "Hungarian Forint",
        symbol: "Ft",
        symbolNative: "Ft",
        decimalDigits: 0,
        rounding: 0,
        code: "HUF",
        namePlural: "Hungarian forints"
    },
    {
        name: "Indonesian Rupiah",
        symbol: "Rp",
        symbolNative: "Rp",
        decimalDigits: 0,
        rounding: 0,
        code: "IDR",
        namePlural: "Indonesian rupiahs"
    },
    {
        name: "Israeli New Sheqel",
        symbol: "₪",
        symbolNative: "₪",
        decimalDigits: 2,
        rounding: 0,
        code: "ILS",
        namePlural: "Israeli new sheqels"
    },
    {
        name: "Indian Rupee",
        symbol: "₹",
        symbolNative: "টকা",
        decimalDigits: 2,
        rounding: 0,
        code: "INR",
        namePlural: "Indian rupees"
    },
    {
        name: "Iraqi Dinar",
        symbol: "IQD",
        symbolNative: "د.ع.‏",
        decimalDigits: 0,
        rounding: 0,
        code: "IQD",
        namePlural: "Iraqi dinars"
    },
    {
        name: "Iranian Rial",
        symbol: "IRR",
        symbolNative: "﷼",
        decimalDigits: 0,
        rounding: 0,
        code: "IRR",
        namePlural: "Iranian rials"
    },
    {
        name: "Icelandic Króna",
        symbol: "Ikr",
        symbolNative: "kr",
        decimalDigits: 0,
        rounding: 0,
        code: "ISK",
        namePlural: "Icelandic krónur"
    },
    {
        name: "Jamaican Dollar",
        symbol: "J$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "JMD",
        namePlural: "Jamaican dollars"
    },
    {
        name: "Jordanian Dinar",
        symbol: "JD",
        symbolNative: "د.أ.‏",
        decimalDigits: 3,
        rounding: 0,
        code: "JOD",
        namePlural: "Jordanian dinars"
    },
    {
        name: "Japanese Yen",
        symbol: "¥",
        symbolNative: "￥",
        decimalDigits: 0,
        rounding: 0,
        code: "JPY",
        namePlural: "Japanese yen"
    },
    {
        name: "Kenyan Shilling",
        symbol: "Ksh",
        symbolNative: "Ksh",
        decimalDigits: 2,
        rounding: 0,
        code: "KES",
        namePlural: "Kenyan shillings"
    },
    {
        name: "Cambodian Riel",
        symbol: "KHR",
        symbolNative: "៛",
        decimalDigits: 2,
        rounding: 0,
        code: "KHR",
        namePlural: "Cambodian riels"
    },
    {
        name: "Comorian Franc",
        symbol: "CF",
        symbolNative: "FC",
        decimalDigits: 0,
        rounding: 0,
        code: "KMF",
        namePlural: "Comorian francs"
    },
    {
        name: "South Korean Won",
        symbol: "₩",
        symbolNative: "₩",
        decimalDigits: 0,
        rounding: 0,
        code: "KRW",
        namePlural: "South Korean won"
    },
    {
        name: "Kuwaiti Dinar",
        symbol: "KD",
        symbolNative: "د.ك.‏",
        decimalDigits: 3,
        rounding: 0,
        code: "KWD",
        namePlural: "Kuwaiti dinars"
    },
    {
        name: "Kazakhstani Tenge",
        symbol: "KZT",
        symbolNative: "тңг.",
        decimalDigits: 2,
        rounding: 0,
        code: "KZT",
        namePlural: "Kazakhstani tenges"
    },
    {
        name: "Lebanese Pound",
        symbol: "LB£",
        symbolNative: "ل.ل.‏",
        decimalDigits: 0,
        rounding: 0,
        code: "LBP",
        namePlural: "Lebanese pounds"
    },
    {
        name: "Sri Lankan Rupee",
        symbol: "SLRs",
        symbolNative: "SL Re",
        decimalDigits: 2,
        rounding: 0,
        code: "LKR",
        namePlural: "Sri Lankan rupees"
    },
    {
        name: "Lithuanian Litas",
        symbol: "Lt",
        symbolNative: "Lt",
        decimalDigits: 2,
        rounding: 0,
        code: "LTL",
        namePlural: "Lithuanian litai"
    },
    {
        name: "Latvian Lats",
        symbol: "Ls",
        symbolNative: "Ls",
        decimalDigits: 2,
        rounding: 0,
        code: "LVL",
        namePlural: "Latvian lati"
    },
    {
        name: "Libyan Dinar",
        symbol: "LD",
        symbolNative: "د.ل.‏",
        decimalDigits: 3,
        rounding: 0,
        code: "LYD",
        namePlural: "Libyan dinars"
    },
    {
        name: "Moroccan Dirham",
        symbol: "MAD",
        symbolNative: "د.م.‏",
        decimalDigits: 2,
        rounding: 0,
        code: "MAD",
        namePlural: "Moroccan dirhams"
    },
    {
        name: "Moldovan Leu",
        symbol: "MDL",
        symbolNative: "MDL",
        decimalDigits: 2,
        rounding: 0,
        code: "MDL",
        namePlural: "Moldovan lei"
    },
    {
        name: "Malagasy Ariary",
        symbol: "MGA",
        symbolNative: "MGA",
        decimalDigits: 0,
        rounding: 0,
        code: "MGA",
        namePlural: "Malagasy Ariaries"
    },
    {
        name: "Macedonian Denar",
        symbol: "MKD",
        symbolNative: "MKD",
        decimalDigits: 2,
        rounding: 0,
        code: "MKD",
        namePlural: "Macedonian denari"
    },
    {
        name: "Myanma Kyat",
        symbol: "MMK",
        symbolNative: "K",
        decimalDigits: 0,
        rounding: 0,
        code: "MMK",
        namePlural: "Myanma kyats"
    },
    {
        name: "Macanese Pataca",
        symbol: "MOP$",
        symbolNative: "MOP$",
        decimalDigits: 2,
        rounding: 0,
        code: "MOP",
        namePlural: "Macanese patacas"
    },
    {
        name: "Mauritian Rupee",
        symbol: "MURs",
        symbolNative: "MURs",
        decimalDigits: 0,
        rounding: 0,
        code: "MUR",
        namePlural: "Mauritian rupees"
    },
    {
        name: "Mexican Peso",
        symbol: "MX$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "MXN",
        namePlural: "Mexican pesos"
    },
    {
        name: "Malaysian Ringgit",
        symbol: "RM",
        symbolNative: "RM",
        decimalDigits: 2,
        rounding: 0,
        code: "MYR",
        namePlural: "Malaysian ringgits"
    },
    {
        name: "Mozambican Metical",
        symbol: "MTn",
        symbolNative: "MTn",
        decimalDigits: 2,
        rounding: 0,
        code: "MZN",
        namePlural: "Mozambican meticals"
    },
    {
        name: "Namibian Dollar",
        symbol: "N$",
        symbolNative: "N$",
        decimalDigits: 2,
        rounding: 0,
        code: "NAD",
        namePlural: "Namibian dollars"
    },
    {
        name: "Nigerian Naira",
        symbol: "₦",
        symbolNative: "₦",
        decimalDigits: 2,
        rounding: 0,
        code: "NGN",
        namePlural: "Nigerian nairas"
    },
    {
        name: "Nicaraguan Córdoba",
        symbol: "C$",
        symbolNative: "C$",
        decimalDigits: 2,
        rounding: 0,
        code: "NIO",
        namePlural: "Nicaraguan córdobas"
    },
    {
        name: "Norwegian Krone",
        symbol: "Nkr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "NOK",
        namePlural: "Norwegian kroner"
    },
    {
        name: "Nepalese Rupee",
        symbol: "NPRs",
        symbolNative: "नेरू",
        decimalDigits: 2,
        rounding: 0,
        code: "NPR",
        namePlural: "Nepalese rupees"
    },
    {
        name: "New Zealand Dollar",
        symbol: "NZ$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "NZD",
        namePlural: "New Zealand dollars"
    },
    {
        name: "Omani Rial",
        symbol: "OMR",
        symbolNative: "ر.ع.‏",
        decimalDigits: 3,
        rounding: 0,
        code: "OMR",
        namePlural: "Omani rials"
    },
    {
        name: "Panamanian Balboa",
        symbol: "B/.",
        symbolNative: "B/.",
        decimalDigits: 2,
        rounding: 0,
        code: "PAB",
        namePlural: "Panamanian balboas"
    },
    {
        name: "Peruvian Nuevo Sol",
        symbol: "S/.",
        symbolNative: "S/.",
        decimalDigits: 2,
        rounding: 0,
        code: "PEN",
        namePlural: "Peruvian nuevos soles"
    },
    {
        name: "Philippine Peso",
        symbol: "₱",
        symbolNative: "₱",
        decimalDigits: 2,
        rounding: 0,
        code: "PHP",
        namePlural: "Philippine pesos"
    },
    {
        name: "Pakistani Rupee",
        symbol: "PKRs",
        symbolNative: "₨",
        decimalDigits: 0,
        rounding: 0,
        code: "PKR",
        namePlural: "Pakistani rupees"
    },
    {
        name: "Polish Zloty",
        symbol: "zł",
        symbolNative: "zł",
        decimalDigits: 2,
        rounding: 0,
        code: "PLN",
        namePlural: "Polish zlotys"
    },
    {
        name: "Paraguayan Guarani",
        symbol: "₲",
        symbolNative: "₲",
        decimalDigits: 0,
        rounding: 0,
        code: "PYG",
        namePlural: "Paraguayan guaranis"
    },
    {
        name: "Qatari Rial",
        symbol: "QR",
        symbolNative: "ر.ق.‏",
        decimalDigits: 2,
        rounding: 0,
        code: "QAR",
        namePlural: "Qatari rials"
    },
    {
        name: "Romanian Leu",
        symbol: "RON",
        symbolNative: "RON",
        decimalDigits: 2,
        rounding: 0,
        code: "RON",
        namePlural: "Romanian lei"
    },
    {
        name: "Serbian Dinar",
        symbol: "din.",
        symbolNative: "дин.",
        decimalDigits: 0,
        rounding: 0,
        code: "RSD",
        namePlural: "Serbian dinars"
    },
    {
        name: "Russian Ruble",
        symbol: "RUB",
        symbolNative: "₽.",
        decimalDigits: 2,
        rounding: 0,
        code: "RUB",
        namePlural: "Russian rubles"
    },
    {
        name: "Rwandan Franc",
        symbol: "RWF",
        symbolNative: "FR",
        decimalDigits: 0,
        rounding: 0,
        code: "RWF",
        namePlural: "Rwandan francs"
    },
    {
        name: "Saudi Riyal",
        symbol: "SR",
        symbolNative: "ر.س.‏",
        decimalDigits: 2,
        rounding: 0,
        code: "SAR",
        namePlural: "Saudi riyals"
    },
    {
        name: "Sudanese Pound",
        symbol: "SDG",
        symbolNative: "SDG",
        decimalDigits: 2,
        rounding: 0,
        code: "SDG",
        namePlural: "Sudanese pounds"
    },
    {
        name: "Swedish Krona",
        symbol: "Skr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "SEK",
        namePlural: "Swedish kronor"
    },
    {
        name: "Singapore Dollar",
        symbol: "S$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "SGD",
        namePlural: "Singapore dollars"
    },
    {
        name: "Somali Shilling",
        symbol: "Ssh",
        symbolNative: "Ssh",
        decimalDigits: 0,
        rounding: 0,
        code: "SOS",
        namePlural: "Somali shillings"
    },
    {
        name: "Syrian Pound",
        symbol: "SY£",
        symbolNative: "ل.س.‏",
        decimalDigits: 0,
        rounding: 0,
        code: "SYP",
        namePlural: "Syrian pounds"
    },
    {
        name: "Thai Baht",
        symbol: "฿",
        symbolNative: "฿",
        decimalDigits: 2,
        rounding: 0,
        code: "THB",
        namePlural: "Thai baht"
    },
    {
        name: "Tunisian Dinar",
        symbol: "DT",
        symbolNative: "د.ت.‏",
        decimalDigits: 3,
        rounding: 0,
        code: "TND",
        namePlural: "Tunisian dinars"
    },
    {
        name: "Tongan Paʻanga",
        symbol: "T$",
        symbolNative: "T$",
        decimalDigits: 2,
        rounding: 0,
        code: "TOP",
        namePlural: "Tongan paʻanga"
    },
    {
        name: "Turkish Lira",
        symbol: "TL",
        symbolNative: "TL",
        decimalDigits: 2,
        rounding: 0,
        code: "TRY",
        namePlural: "Turkish Lira"
    },
    {
        name: "Trinidad and Tobago Dollar",
        symbol: "TT$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "TTD",
        namePlural: "Trinidad and Tobago dollars"
    },
    {
        name: "New Taiwan Dollar",
        symbol: "NT$",
        symbolNative: "NT$",
        decimalDigits: 2,
        rounding: 0,
        code: "TWD",
        namePlural: "New Taiwan dollars"
    },
    {
        name: "Tanzanian Shilling",
        symbol: "TSh",
        symbolNative: "TSh",
        decimalDigits: 0,
        rounding: 0,
        code: "TZS",
        namePlural: "Tanzanian shillings"
    },
    {
        name: "Ukrainian Hryvnia",
        symbol: "₴",
        symbolNative: "₴",
        decimalDigits: 2,
        rounding: 0,
        code: "UAH",
        namePlural: "Ukrainian hryvnias"
    },
    {
        name: "Ugandan Shilling",
        symbol: "USh",
        symbolNative: "USh",
        decimalDigits: 0,
        rounding: 0,
        code: "UGX",
        namePlural: "Ugandan shillings"
    },
    {
        name: "Uruguayan Peso",
        symbol: "$U",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "UYU",
        namePlural: "Uruguayan pesos"
    },
    {
        name: "Uzbekistan Som",
        symbol: "UZS",
        symbolNative: "UZS",
        decimalDigits: 0,
        rounding: 0,
        code: "UZS",
        namePlural: "Uzbekistan som"
    },
    {
        name: "Venezuelan Bolívar",
        symbol: "Bs.F.",
        symbolNative: "Bs.F.",
        decimalDigits: 2,
        rounding: 0,
        code: "VEF",
        namePlural: "Venezuelan bolívars"
    },
    {
        name: "Vietnamese Dong",
        symbol: "₫",
        symbolNative: "₫",
        decimalDigits: 0,
        rounding: 0,
        code: "VND",
        namePlural: "Vietnamese dong"
    },
    {
        name: "CFA Franc BEAC",
        symbol: "FCFA",
        symbolNative: "FCFA",
        decimalDigits: 0,
        rounding: 0,
        code: "XAF",
        namePlural: "CFA francs BEAC"
    },
    {
        name: "CFA Franc BCEAO",
        symbol: "CFA",
        symbolNative: "CFA",
        decimalDigits: 0,
        rounding: 0,
        code: "XOF",
        namePlural: "CFA francs BCEAO"
    },
    {
        name: "Yemeni Rial",
        symbol: "YR",
        symbolNative: "ر.ي.‏",
        decimalDigits: 0,
        rounding: 0,
        code: "YER",
        namePlural: "Yemeni rials"
    },
    {
        name: "South African Rand",
        symbol: "R",
        symbolNative: "R",
        decimalDigits: 2,
        rounding: 0,
        code: "ZAR",
        namePlural: "South African rand"
    },
    {
        name: "Zambian Kwacha",
        symbol: "ZK",
        symbolNative: "ZK",
        decimalDigits: 0,
        rounding: 0,
        code: "ZMK",
        namePlural: "Zambian kwachas"
    },
    {
        name: "Zimbabwean Dollar",
        symbol: "ZWL$",
        symbolNative: "ZWL$",
        decimalDigits: 0,
        rounding: 0,
        code: "ZWL",
        namePlural: "Zimbabwean Dollar"
    }
];
new Set(Xbe.map((e)=>e.code));
function BB(e) {
    return typeof e == "number";
}
function Jbe(e) {
    return typeof e > "u";
}
function Qbe(e) {
    return Array.isArray(e) ? e.every((t)=>BB(t)) : BB(e);
}
var e1e = Te.string().array(), t1e = Te.record(Te.string(), Te.unknown());
Te.union([
    e1e,
    t1e,
    Te.undefined()
]);
var rb = Te.object({
    jsonrpc: Te.literal("2.0"),
    id: Te.string()
});
function OB(e, t) {
    return t ? rb.extend({
        method: Te.literal(e),
        params: t
    }) : rb.extend({
        method: Te.literal(e)
    });
}
var c8 = /* @__PURE__ */ ((e)=>(e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.SERVER_ERROR = -32e3] = "SERVER_ERROR", e[e.USER_REJECTION = 4001] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = 4002] = "METHOD_NOT_SUPPORTED", e[e.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", e[e.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", e))(c8 || {}), r1e = Te.nativeEnum(c8);
function n1e(e) {
    return Te.object({
        code: Te.union([
            Te.number(),
            r1e
        ]),
        message: Te.string(),
        data: e.optional()
    });
}
function i1e(e) {
    return rb.extend({
        error: e
    });
}
var o1e = n1e(Te.any());
function s1e(e) {
    return rb.extend({
        result: e
    });
}
function PB(e, t) {
    return Te.union([
        s1e(e),
        i1e(t)
    ]);
}
function ei(e) {
    const t = e.error ?? o1e;
    return "params" in e ? {
        method: e.method,
        params: e.params,
        result: e.result,
        error: t,
        request: OB(e.method, e.params),
        response: PB(e.result, t)
    } : {
        method: e.method,
        result: e.result,
        error: t,
        request: OB(e.method),
        response: PB(e.result, t)
    };
}
var a1e = Te.object({
    account: Te.number().optional(),
    address: Te.string(),
    amount: Te.coerce.string(),
    network: Te.string()
}), c1e = Te.object({
    address: Te.string(),
    amount: Te.coerce.string()
}), u1e = Te.object({
    account: Te.number().optional(),
    recipients: Te.array(c1e),
    network: Te.string()
}), f1e = Te.union([
    a1e,
    u1e
]);
ei({
    method: "sendTransfer",
    params: f1e,
    result: Te.object({
        txid: Te.string()
    })
});
var l1e = Te.enum([
    "legacy",
    "bip322"
]), d1e = Te.enum([
    "p2tr",
    "p2wpkh"
]), h1e = Te.object({
    type: l1e.optional(),
    account: Te.number().optional(),
    message: Te.string(),
    paymentType: d1e
}).passthrough();
ei({
    method: "signMessage",
    params: h1e,
    result: Te.object({
        signature: Te.string(),
        address: Te.string()
    }).passthrough()
});
function p1e(e) {
    return Jbe(e) ? !0 : Qbe(e);
}
var g1e = Te.object({
    account: Te.number().optional(),
    allowedSighash: Te.array(Te.any()).optional(),
    broadcast: Te.boolean().optional(),
    hex: Te.string(),
    network: Te.string().optional(),
    signAtIndex: Te.union([
        Te.number(),
        Te.array(Te.number())
    ]).optional().refine(p1e)
}), y1e = Te.object({
    hex: Te.string(),
    txid: Te.string().optional()
});
ei({
    method: "signPsbt",
    params: g1e,
    result: y1e
});
var m1e = Te.enum([
    "p2pkh",
    "p2sh",
    "p2wpkh-p2sh",
    "p2wpkh",
    "p2tr"
]), mU = Te.object({
    symbol: Te.literal("BTC"),
    type: m1e,
    address: Te.string(),
    publicKey: Te.string(),
    derivationPath: Te.string()
}), b1e = mU.extend({
    type: Te.literal("p2wpkh")
}).passthrough(), w1e = mU.extend({
    type: Te.literal("p2tr"),
    tweakedPublicKey: Te.string()
}).passthrough(), v1e = Te.discriminatedUnion("type", [
    b1e,
    w1e
]), _1e = Te.object({
    symbol: Te.literal("STX"),
    address: Te.string(),
    publicKey: Te.string()
}).passthrough(), E1e = Te.union([
    v1e,
    _1e
]), x1e = Te.object({
    addresses: Te.array(E1e)
}).passthrough();
ei({
    method: "getAddresses",
    params: Te.object({
        network: Te.string().optional()
    }).optional(),
    result: x1e
});
var S1e = Te.object({
    version: Te.string(),
    supportedMethods: Te.array(Te.string()).optional(),
    platform: Te.union([
        Te.literal("mobile"),
        Te.literal("extension")
    ])
});
ei({
    method: "getInfo",
    result: S1e
});
ei({
    method: "open",
    params: Te.object({
        mode: Te.enum([
            "fullpage",
            "popup"
        ])
    }).default({
        mode: "popup"
    }),
    result: Te.object({
        success: Te.literal(!0)
    })
});
var A1e = Te.object({
    base: Te.string(),
    quote: Te.string()
}), T1e = Te.object({
    message: Te.string()
});
ei({
    method: "openSwap",
    params: A1e,
    result: T1e
});
var Vd = Te.object({
    txid: Te.string(),
    transaction: Te.string()
}), O0 = Te.object({
    address: Te.string().optional(),
    network: Te.union([
        Te.literal("mainnet"),
        Te.literal("testnet"),
        Te.literal("regtest"),
        Te.literal("devnet"),
        Te.literal("mocknet"),
        Te.string()
    ]).optional(),
    fee: Te.coerce.number().optional(),
    nonce: Te.coerce.number().optional(),
    // add pc later when imported from stacks.js
    postConditions: Te.array(Te.string()).optional(),
    postConditionMode: Te.union([
        Te.literal("allow"),
        Te.literal("deny")
    ]).optional(),
    sponsored: Te.boolean().optional()
});
ei({
    method: "stx_callContract",
    params: Te.intersection(Te.object({
        contract: Te.string(),
        functionName: Te.string(),
        functionArgs: Te.array(Te.string()).optional()
    }), O0),
    result: Vd
});
var k1e = Vd;
ei({
    method: "stx_deployContract",
    params: Te.intersection(Te.object({
        name: Te.string(),
        clarityCode: Te.string(),
        clarityVersion: Te.coerce.number().optional()
    }), O0),
    result: k1e
});
var I1e = Te.object({
    address: Te.string(),
    publicKey: Te.string(),
    derivationPath: Te.string()
}), B1e = Te.array(I1e);
ei({
    method: "stx_getAddresses",
    params: Te.object({
        network: Te.string().optional()
    }).optional(),
    result: B1e
});
ei({
    method: "stx_getNetworks",
    result: Te.object({
        active: Te.string(),
        networks: Te.array(Te.object({
            id: Te.string(),
            chainId: Te.string(),
            transactionVersion: Te.string()
        }).passthrough())
    })
});
var O1e = Te.enum([
    "utf8",
    "structured"
]), bU = Te.object({
    messageType: O1e.optional().default("utf8"),
    network: Te.optional(Te.enum([
        "mainnet",
        "testnet",
        "devnet",
        "mocknet"
    ]))
}), P1e = bU.merge(Te.object({
    messageType: Te.literal("utf8").default("utf8"),
    message: Te.string()
})), N1e = bU.merge(Te.object({
    messageType: Te.literal("structured"),
    domain: Te.string(),
    message: Te.string()
}));
ei({
    method: "stx_signMessage",
    params: Te.union([
        P1e,
        N1e
    ]),
    result: Te.object({
        signature: Te.string(),
        publicKey: Te.string()
    })
});
ei({
    method: "stx_signStructuredMessage",
    params: Te.object({
        domain: Te.string(),
        message: Te.string()
    }),
    result: Te.object({
        signature: Te.string(),
        publicKey: Te.string()
    })
});
var M1e = Te.object({
    txHex: Te.string(),
    stxAddress: Te.string().optional(),
    attachment: Te.string().optional(),
    accountIndex: Te.string().optional(),
    network: Te.string().optional()
}), R1e = Te.object({
    transaction: Te.string(),
    network: Te.string().optional()
});
ei({
    method: "stx_signTransaction",
    params: Te.union([
        M1e,
        R1e
    ]),
    result: Te.object({
        transaction: Te.string(),
        txHex: Te.string()
    })
});
ei({
    method: "stx_transferSip9Nft",
    params: Te.intersection(Te.object({
        recipient: Te.string(),
        asset: Te.string(),
        assetId: Te.string()
    }).passthrough(), O0),
    result: Vd
});
ei({
    method: "stx_transferSip10Ft",
    params: Te.intersection(Te.object({
        recipient: Te.string(),
        asset: Te.string(),
        amount: Te.coerce.number()
    }).passthrough(), O0),
    result: Vd
});
ei({
    method: "stx_transferStx",
    params: Te.intersection(Te.object({
        recipient: Te.string(),
        amount: Te.coerce.number().int("Amount must be an integer describing µSTX"),
        memo: Te.string().optional()
    }).passthrough(), O0),
    result: Vd
});
var C1e = Te.object({
    // schema.org/Person
    person: Te.object({}).passthrough()
}), U1e = Vd;
ei({
    method: "stx_updateProfile",
    params: C1e,
    result: U1e
});
var $1e = Te.object({
    name: Te.string(),
    docsUrl: Te.union([
        Te.string(),
        Te.array(Te.string())
    ])
});
ei({
    method: "supportedMethods",
    result: Te.object({
        documentation: Te.string(),
        methods: Te.array($1e)
    })
});
var L1e = Te.object({
    type: Te.literal("int"),
    value: Te.coerce.string()
}), D1e = Te.object({
    type: Te.literal("uint"),
    value: Te.coerce.string()
}), F1e = Te.object({
    type: Te.literal("buffer"),
    value: Te.string()
}), z1e = Te.object({
    type: Te.literal("true")
}), j1e = Te.object({
    type: Te.literal("false")
}), H1e = Te.object({
    type: Te.literal("address"),
    value: Te.string()
}), q1e = Te.object({
    type: Te.literal("contract"),
    value: Te.string().refine((e)=>e.includes("."), {
        message: "Stacks contract principals are denoted with a dot"
    })
}), K1e = Te.object({
    type: Te.literal("ascii"),
    value: Te.string()
}), W1e = Te.object({
    type: Te.literal("utf8"),
    value: Te.string()
}), V1e = Te.object({
    type: Te.literal("ok"),
    value: Te.lazy(()=>P0)
}).transform((e)=>e), G1e = Te.object({
    type: Te.literal("err"),
    value: Te.lazy(()=>P0)
}), Z1e = Te.object({
    type: Te.literal("none")
}), Y1e = Te.object({
    type: Te.literal("some"),
    value: Te.lazy(()=>P0)
}), X1e = Te.object({
    type: Te.literal("list"),
    value: Te.array(Te.lazy(()=>P0))
}), J1e = Te.object({
    type: Te.literal("tuple"),
    value: Te.record(Te.lazy(()=>P0))
}), P0 = Te.union([
    L1e,
    D1e,
    F1e,
    z1e,
    j1e,
    H1e,
    q1e,
    V1e,
    G1e,
    Z1e,
    Y1e,
    X1e,
    J1e,
    K1e,
    W1e
]);
let NB = (e)=>e, Ph = {}, tu = {
    addEventListener () {},
    removeEventListener () {}
};
function Q1e() {
    try {
        return typeof localStorage < "u";
    } catch  {
        return !1;
    }
}
Q1e() && (Ph = localStorage);
let ewe = {
    addEventListener (e, t, r) {
        window.addEventListener("storage", t), window.addEventListener("pageshow", r);
    },
    removeEventListener (e, t, r) {
        window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
    }
};
("TURBOPACK compile-time value", "undefined") < "u" && (tu = ewe);
function Kf(e, t = {}, r = {}) {
    let n = r.encode || NB, i = r.decode || NB, o = J7(), s = o.setKey, a = (l, p)=>{
        typeof p > "u" ? (r.listen !== !1 && tu.perKey && tu.removeEventListener(e + l, f, c), delete Ph[e + l]) : (r.listen !== !1 && tu.perKey && !(l in o.value) && tu.addEventListener(e + l, f, c), Ph[e + l] = n(p));
    };
    o.setKey = (l, p)=>{
        a(l, p), s(l, p);
    };
    let u = o.set;
    o.set = function(l) {
        for(let p in l)a(p, l[p]);
        for(let p in o.value)p in l || a(p, void 0);
        u(l);
    };
    function f(l) {
        l.key ? l.key.startsWith(e) && (l.newValue === null ? s(l.key.slice(e.length), void 0) : s(l.key.slice(e.length), i(l.newValue))) : u({});
    }
    function c() {
        let l = {
            ...t
        };
        for(let p in Ph)p.startsWith(e) && (l[p.slice(e.length)] = i(Ph[p]));
        for(let p in l)o.setKey(p, l[p]);
    }
    return aG(o, ()=>{
        if (c(), r.listen !== !1) return tu.addEventListener(e, f, c), ()=>{
            tu.removeEventListener(e, f, c);
            for(let l in o.value)tu.removeEventListener(e + l, f, c);
        };
    }), o;
}
function twe(e) {
    ("TURBOPACK compile-time value", "undefined") < "u" && typeof localStorage < "u" && setTimeout(()=>{
        const t = document.createTextNode(" ");
        document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
    }, 1500);
}
function a_e() {
    return {
        $store: J7({
            provider: void 0,
            address: "",
            paymentAddress: "",
            publicKey: "",
            paymentPublicKey: "",
            connected: !1,
            isConnecting: !1,
            isInitializing: !0,
            accounts: [],
            balance: void 0,
            hasProvider: {
                [Rh]: !1,
                [Bl]: !1,
                [ru]: !1,
                [Ch]: !1,
                [Nl]: !1,
                [Qu]: !1,
                [Il]: !1,
                [Ml]: !0,
                [$h]: !1,
                [Pl]: !1,
                [Uh]: !1,
                [Ol]: !1,
                [Rl]: !1
            }
        }),
        $network: NE(ln),
        $library: NE(void 0)
    };
}
function c_e(e) {
    if (e) return {
        ...e
    };
}
const Nu = [
    "address",
    "paymentAddress",
    "publicKey",
    "paymentPublicKey",
    "balance"
];
function Wf(e, t, r, n) {
    var i, o, s;
    t.provider === e && (r ? r === "balance" ? n.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : Nu.includes(r) && n.setKey(r, ((o = t[r]) == null ? void 0 : o.toString()) ?? "") : n.set({
        address: t.address,
        paymentAddress: t.paymentAddress,
        paymentPublicKey: t.paymentPublicKey,
        publicKey: t.publicKey,
        balance: ((s = t.balance) == null ? void 0 : s.toString()) ?? ""
    }));
}
const rwe = (e)=>{
    const t = e.match(/.{1,2}/g);
    if (!t) throw new Error("Invalid hex string");
    return Uint8Array.from(t.map((r)=>Number.parseInt(r, 16)));
}, nwe = "LEATHER_CONNECTED_WALLET_STATE";
class iwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(nwe, {
            address: "",
            publicKey: "",
            paymentAddress: "",
            paymentPublicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        return window == null ? void 0 : window.LeatherProvider;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Rh, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n;
            (window == null ? void 0 : window.LeatherProvider) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Rh]: !0
            }), (n = this.observer) == null || n.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Rh ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        var f;
        const { address: n, paymentAddress: i } = this.$valueStore.get();
        if (n) if (n.startsWith("tb1") && qb(this.network)) this.disconnect();
        else {
            this.restorePersistedValues(), id(i, this.network).then((c)=>{
                this.$store.setKey("balance", c);
            });
            return;
        }
        if (!this.library) throw new Error("Leather isn't installed");
        const o = (await this.library.request("getAddresses", {
            network: ((f = this.config) == null ? void 0 : f.network) ?? this.network
        })).result.addresses;
        if (!o) throw new Error("No accounts found");
        const s = o.map((c)=>c.address), a = o.find((c)=>c.type === df), u = o.find((c)=>c.type === Ay);
        if (!(a != null && a.publicKey) || !(u != null && u.publicKey)) throw new Error("No accounts found");
        this.$store.setKey("accounts", s), this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", u.address), this.$store.setKey("publicKey", a.publicKey), this.$store.setKey("paymentPublicKey", u.publicKey);
    }
    async getNetwork() {
        return this.network;
    }
    async switchNetwork(r) {
        if (r !== this.network) {
            if (!this.library) throw new Error("Leather isn't installed");
            const n = (await this.library.request("getAddresses", {
                network: r
            })).result.addresses;
            if (!n) throw new Error("Failed to get new network details");
            const i = n.map((a)=>a.address), o = n.find((a)=>a.type === df), s = n.find((a)=>a.type === Ay);
            if (!(o != null && o.publicKey) || !(s != null && s.publicKey)) throw new Error("Failed to get new network details");
            this.$store.setKey("accounts", i), this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", s.address), this.$store.setKey("publicKey", o.publicKey), this.$store.setKey("paymentPublicKey", s.publicKey), this.$network.set(r);
        }
    }
    async sendBTC(r, n) {
        var i, o;
        try {
            const s = await ((i = this.library) == null ? void 0 : i.request("sendTransfer", {
                recipients: [
                    {
                        address: r,
                        amount: String(n)
                    }
                ],
                network: this.network
            }));
            if (s != null && s.result.txid) return s == null ? void 0 : s.result.txid;
            throw new Error("Error sending BTC");
        } catch (s) {
            if ((o = s.error) != null && o.code) {
                const a = s.error;
                throw a.code === c8.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error sending BTC: ${a.message}`);
            }
            throw new Error("Error sending BTC");
        }
    }
    async signMessage(r, n) {
        var u, f;
        const i = n == null ? void 0 : n.toSignAddress;
        if ((n == null ? void 0 : n.protocol) === f0) throw new Error("Leather doesn't support ECDSA message signing");
        const s = i === this.$store.get().address ? df : Ay;
        if (i !== this.$store.get().address && i !== this.$store.get().paymentAddress) throw new Error("Invalid address to sign message");
        const a = await ((u = this.library) == null ? void 0 : u.request("signMessage", {
            message: r,
            paymentType: s
        }));
        return ((f = a == null ? void 0 : a.result) == null ? void 0 : f.signature) ?? "";
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var l;
        const s = {
            hex: r,
            broadcast: !1,
            network: this.network,
            signAtIndex: o == null ? void 0 : o.map((p)=>p.index)
        }, a = await ((l = this.library) == null ? void 0 : l.request("signPsbt", s));
        if (!a) throw new Error("No response from Leather");
        const f = a.result.hex, c = Cr.fromHex(String(f));
        if (i && n) {
            const p = c.finalizeAllInputs(), y = await this.pushPsbt(p.toHex());
            return {
                signedPsbtHex: c.toHex(),
                signedPsbtBase64: c.toBase64(),
                txId: y
            };
        }
        if (i) {
            const p = c.finalizeAllInputs();
            return {
                signedPsbtHex: p.toHex(),
                signedPsbtBase64: p.toBase64(),
                txId: void 0
            };
        }
        return {
            signedPsbtHex: c.toHex(),
            signedPsbtBase64: c.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async getBalance() {
        const r = await id(this.$store.get().paymentAddress, this.network);
        return this.$store.setKey("balance", r), r.toString();
    }
    async requestAccounts() {
        var a;
        const { accounts: r } = this.$store.get();
        if (r.length > 0) return r;
        const n = await ((a = this.library) == null ? void 0 : a.request("getAddresses", {
            network: this.network
        }));
        if (!n) throw new Error("No accounts found");
        const s = n.result.addresses.map((u)=>u.address);
        return this.$store.setKey("accounts", s), s;
    }
}
const owe = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
class swe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(owe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.magicEden) == null ? void 0 : r.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu){
            if (n === "balance") {
                this.$store.setKey(n, BigInt(r[n]));
                continue;
            }
            this.$store.setKey(n, r[n]);
        }
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(ru, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n, i;
            ((n = window == null ? void 0 : window.magicEden) == null ? void 0 : n.bitcoin) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [ru]: !0
            }), (i = this.observer) == null || i.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== ru ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect() {
        const { address: r, paymentAddress: n } = this.$valueStore.get();
        if (r) if (r.startsWith("tb1") && qb(this.network)) this.disconnect();
        else {
            id(n, this.network).then((s)=>{
                this.$store.setKey("balance", s);
            }), this.restorePersistedValues();
            return;
        }
        if (LP(this.network)) throw new Error(`${this.network} is not supported by ${ru}`);
        const i = d_(this.network || ln);
        await AJ({
            getProvider: async ()=>this.library,
            payload: {
                purposes: [
                    "ordinals",
                    "payment"
                ],
                message: "Connecting with lasereyes",
                network: {
                    type: i
                }
            },
            onFinish: (s)=>{
                const a = um(s.addresses), u = fm(s.addresses);
                if (!a || !u) throw new Error("No address found");
                a && u && (this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", u.address), this.$store.setKey("accounts", s.addresses.map((f)=>f.address))), this.$store.setKey("publicKey", String(s.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(s.addresses[1].publicKey));
            },
            onCancel: ()=>{
                throw new Error(`User canceled lasereyes to ${ru} wallet`);
            },
            onError: ()=>{
                throw new Error(`Can't lasereyes to ${ru} wallet`);
            }
        });
    }
    async sendBTC(r, n) {
        let i;
        if (await qQ({
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: d_(this.network)
                },
                recipients: [
                    {
                        address: r,
                        amountSats: BigInt(n)
                    }
                ],
                senderAddress: this.$store.get().paymentAddress
            },
            onFinish: (o)=>{
                i = o;
            },
            onCancel: ()=>{
                throw console.error("Request canceled"), new Error("User canceled the request");
            }
        }), !i || !i.txid) throw new Error("Error sending BTC");
        return i.txid;
    }
    async signMessage(r, n) {
        const i = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress;
        let o = "";
        return await jQ({
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: Mn.Mainnet
                },
                address: i,
                message: r,
                protocol: (n == null ? void 0 : n.protocol) === f0 ? _f.ECDSA : _f.BIP322
            },
            onFinish: (s)=>{
                o = s;
            },
            onCancel: ()=>{
                throw console.error("Request canceled"), new Error("User canceled the request");
            }
        }), o;
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const s = Cr.fromBase64(String(r), {
            network: Dr(this.network)
        }), a = s.data.inputs;
        let u = [];
        if (o) {
            const A = o.reduce((O, N)=>({
                    ...O,
                    [N.address]: [
                        ...O[N.address] || [],
                        N.index
                    ]
                }), {});
            u = Object.entries(A).map(([O, N])=>({
                    address: O,
                    signingIndexes: N
                }));
        } else {
            const { address: A, paymentAddress: O } = this.$store.get(), N = {
                address: A,
                signingIndexes: []
            }, U = {
                address: O,
                signingIndexes: []
            };
            for (const D of a.keys()){
                const H = a[D];
                if (H.witnessUtxo === void 0) {
                    U.signingIndexes.push(Number(D));
                    continue;
                }
                const { script: K } = H.witnessUtxo, re = Yp(K, Dr(this.network));
                re === O ? (U.signingIndexes.push(Number(D)), H.sighashType && (console.log("Updating sigHash for paymentsAddressData"), U.sigHash = H.sighashType)) : re === A && (N.signingIndexes.push(Number(D)), H.sighashType && (console.log("Updating sigHash for ordinalAddressData"), N.sigHash = H.sighashType));
            }
            N.signingIndexes.length > 0 && u.push(N), U.signingIndexes.length > 0 && u.push(U);
        }
        let f, c, l, p;
        const y = d_(this.network), _ = {
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: y
                },
                message: "Sign Transaction",
                psbtBase64: s.toBase64(),
                broadcast: n,
                inputsToSign: u
            },
            onFinish: async (A)=>{
                A.psbtBase64 && (p = Cr.fromBase64(String(A.psbtBase64), {
                    network: Dr(this.network)
                }), c = p.toHex(), l = p.toBase64());
            },
            onCancel: ()=>{
                throw console.log("Canceled"), new Error("User canceled the request");
            },
            onError: (A)=>{
                throw console.log("error", A), A;
            }
        };
        if (await KQ(_), !p) throw new Error("signature failed");
        return i || n ? (p.finalizeAllInputs(), {
            signedPsbtHex: p.toHex(),
            signedPsbtBase64: l,
            txId: f
        }) : {
            signedPsbtHex: c,
            signedPsbtBase64: l,
            txId: f
        };
    }
}
const awe = "OKX_CONNECTED_WALLET_STATE";
class cwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(awe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var n, i;
        let r;
        return this.network === Ni || this.network === ao || this.network === Ro || this.network === co ? r = (n = window == null ? void 0 : window.okxwallet) == null ? void 0 : n.bitcoinTestnet : (this.network === ln || this.network === yc) && (r = (i = window == null ? void 0 : window.okxwallet) == null ? void 0 : i.bitcoin), r;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Ch, r, i, this.$valueStore);
    }
    initialize() {
        var r;
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var i;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ch]: !0
            }), (i = this.observer) == null || i.disconnect());
        }), (r = this.observer) == null || r.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (n)=>{
            n.provider !== Ch ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        const { address: n, paymentAddress: i } = this.$valueStore.get();
        if (n) if (n.startsWith("tb1") && qb(this.network)) this.disconnect();
        else {
            this.restorePersistedValues(), id(i, this.network).then((o)=>{
                this.$store.setKey("balance", o);
            });
            return;
        }
        try {
            const o = await this.library.connect();
            if (!o) throw new Error("No accounts found");
            this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", o.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("accounts", [
                o.address
            ]);
        } catch (o) {
            throw o;
        }
    }
    async requestAccounts() {
        const r = this.library, n = this.network;
        return n === Ni || n === ao || n === co ? await r.connect() : await r.requestAccounts();
    }
    async getNetwork() {
        const { address: r } = this.$store.get(), n = this.network;
        if (r.slice(0, 1) === "t") return n === Ni ? Ni : n === ao ? ao : n === Ro ? Ro : n === co ? co : Ni;
        const i = await this.library.getNetwork();
        return ZQ(i);
    }
    async getPublicKey() {
        const r = this.library;
        return await (r == null ? void 0 : r.getPublicKey());
    }
    async getInscriptions(r, n) {
        const i = r || 0, o = n || 10;
        return (await this.library.getInscriptions(i, o)).list.map((u)=>Kl(u, void 0, this.network));
    }
    async sendBTC(r, n) {
        const o = await this.library.sendBitcoin(r, n);
        if (!o) throw new Error("Transaction failed");
        return o;
    }
    async signMessage(r, n) {
        const i = this.library, o = (n == null ? void 0 : n.protocol) === f0 ? l0 : n == null ? void 0 : n.protocol;
        return await (i == null ? void 0 : i.signMessage(r, o));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const a = await this.library.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        })), u = Cr.fromHex(a);
        if (i && n) {
            const f = await this.pushPsbt(a);
            return {
                signedPsbtHex: u.toHex(),
                signedPsbtBase64: u.toBase64(),
                txId: f
            };
        }
        return {
            signedPsbtHex: u.toHex(),
            signedPsbtBase64: u.toBase64(),
            txId: void 0
        };
    }
}
class uwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        return window == null ? void 0 : window.opnet;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Nl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            if (r.provider !== Nl) {
                this.removeListeners();
                return;
            }
            this.library.getAccounts().then((n)=>{
                this.handleAccountsChanged(n);
            }), this.addListeners();
        });
    }
    addListeners() {
        var r, n;
        (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var r, n;
        !this.library || !this.library.removeListener || ((r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Nl) : this.parent.disconnect());
    }
    handleNetworkChanged(r) {
        const n = om(r);
        this.network !== n && this.switchNetwork(n), this.parent.connect(Nl);
    }
    async connect(r) {
        if (!this.library) throw new Error("OP_NET isn't installed");
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        const i = await this.library.getPublicKey();
        if (!i) throw new Error("No public key found");
        this.$store.setKey("accounts", n), this.$store.setKey("address", n[0]), this.$store.setKey("paymentAddress", n[0]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i), await this.getNetwork().then((o)=>{
            var s;
            ((s = this.config) == null ? void 0 : s.network) !== o && this.switchNetwork(o);
        });
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getChain());
        return r ? om(r.enum) : this.network;
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (!i) throw new Error("Transaction failed");
        return i;
    }
    async signMessage(r, n) {
        var o;
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await ((o = this.library) == null ? void 0 : o.signMessage(r, i));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var u;
        const s = await ((u = this.library) == null ? void 0 : u.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        }))), a = Cr.fromHex(s);
        if (i && n) {
            const f = await this.pushPsbt(s);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: f
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(r, n) {
        return await this.library.getInscriptions(r, n);
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async switchNetwork(r) {
        var i;
        const n = fP(r);
        await ((i = this.library) == null ? void 0 : i.switchChain(n)), this.$network.set(r);
    }
}
var Jh = {}, wU = {}, Hs = {}, vU = {};
Object.defineProperty(vU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
    async function n(s) {
        var u, f;
        if (s) {
            const c = await s();
            if (c) return c;
        }
        const a = window.OrangeBitcoinProvider || ((u = window.OrangecryptoProviders) == null ? void 0 : u.BitcoinProvider) || ((f = window.OrangeWalletProviders) == null ? void 0 : f.OrangeBitcoinProvider);
        if (!a) throw new Error("No Orange Bitcoin wallet installed");
        return a;
    }
    e.getProviderOrThrow = n;
    function i() {
        return window.btc_providers || (window.btc_providers = []), window.btc_providers;
    }
    e.getProviders = i;
    function o(s) {
        var a;
        if (Array.isArray(window.btc_providers)) {
            const u = window.btc_providers.find((f)=>f.id === s);
            return (a = u == null ? void 0 : u.id) == null ? void 0 : a.split(".").reduce((f, c)=>f == null ? void 0 : f[c], window);
        } else {
            console.log("window.btc_providers is not defined or not an array");
            return;
        }
    }
    e.getProviderById = o, r(vU, e);
})(Hs);
var _U = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.AddressType = e.AddressPurpose = void 0, function(t) {
        t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
    }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
        t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
    }(e.AddressType || (e.AddressType = {}));
})(_U);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getAddress = void 0;
    const n = Lo, i = Hs, o = async (s)=>{
        var f, c;
        const a = await (0, i.getProviderOrThrow)(s.getProvider), { purposes: u } = s.payload;
        if (!u) throw new Error("Address purposes are required");
        try {
            const l = (0, n.createUnsecuredToken)(s.payload), p = await a.connect(l);
            (f = s.onFinish) == null || f.call(s, p);
        } catch (l) {
            console.error("[Connect] Error during address request", l), (c = s.onCancel) == null || c.call(s);
        }
    };
    e.getAddress = o, r(_U, e);
})(wU);
var EU = {}, xU = {}, SU = {};
Object.defineProperty(SU, "__esModule", {
    value: !0
});
var AU = {};
Object.defineProperty(AU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(SU, e), r(AU, e);
})(xU);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.request = void 0;
    const n = Hs, i = async (s, a, u)=>{
        var l;
        let f = ((l = window.OrangecryptoProviders) == null ? void 0 : l.BitcoinProvider) || window.OrangeBitcoinProvider;
        if (u && (f = await (0, n.getProviderById)(u)), !f) throw new Error("no wallet provider was found");
        if (!s) throw new Error("A wallet method is required");
        const c = await f.request(s, a);
        return o(c) ? {
            status: "success",
            result: c.result
        } : {
            status: "error",
            error: c.error
        };
    };
    e.request = i;
    const o = (s)=>Object.hasOwn(s, "result") && !!s.result;
    r(xU, e);
})(EU);
var TU = {}, kU = {};
Object.defineProperty(kU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(a, u, f, c) {
        c === void 0 && (c = f);
        var l = Object.getOwnPropertyDescriptor(u, f);
        (!l || ("get" in l ? !u.__esModule : l.writable || l.configurable)) && (l = {
            enumerable: !0,
            get: function() {
                return u[f];
            }
        }), Object.defineProperty(a, c, l);
    } : function(a, u, f, c) {
        c === void 0 && (c = f), a[c] = u[f];
    }), r = Ge && Ge.__exportStar || function(a, u) {
        for(var f in a)f !== "default" && !Object.prototype.hasOwnProperty.call(u, f) && t(u, a, f);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getCapabilities = void 0;
    const n = Lo, i = Hs, o = (a, u)=>{
        const f = (l)=>!(!a[l] || u && !u.has(l)), c = {
            request: f("request"),
            connect: f("connect"),
            signMessage: f("signMessage"),
            signTransaction: f("signTransaction"),
            sendBtcTransaction: f("sendBtcTransaction"),
            signMultipleTransactions: f("signMultipleTransactions")
        };
        return Object.entries(c).reduce((l, [p, y])=>y ? [
                ...l,
                p
            ] : l, []);
    }, s = async (a)=>{
        var c, l, p;
        const u = await (0, i.getProviderOrThrow)(a.getProvider), f = (0, n.createUnsecuredToken)(a.payload);
        if (u.getCapabilities) try {
            const y = await u.getCapabilities(f);
            (c = a.onFinish) == null || c.call(a, o(u, new Set(y)));
        } catch (y) {
            console.error("[Connect] Error during capabilities request", y);
        }
        try {
            const y = o(u);
            (l = a.onFinish) == null || l.call(a, y);
        } catch (y) {
            console.error("[Connect] Error during capabilities request", y), (p = a.onCancel) == null || p.call(a);
        }
    };
    e.getCapabilities = s, r(kU, e);
})(TU);
var IU = {}, A1 = {}, N0 = {};
Object.defineProperty(N0, "__esModule", {
    value: !0
});
N0.validateInscriptionPayload = void 0;
const fwe = 4e5, lwe = 6e4, dwe = (e)=>{
    const { contentType: t, content: r, payloadType: n, network: i, appFeeAddress: o, appFee: s } = e;
    if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t)) throw new Error("Invalid content type detected");
    if (!r || r.length === 0) throw new Error("Empty content not allowed");
    if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT") throw new Error("Empty invalid payloadType specified");
    if (r.length > (i.type === "Mainnet" ? fwe : lwe)) throw new Error("Content too large");
    if (((o == null ? void 0 : o.length) ?? 0) > 0 && (s ?? 0) <= 0) throw new Error("Invalid combination of app fee address and fee provided");
};
N0.validateInscriptionPayload = dwe;
Object.defineProperty(A1, "__esModule", {
    value: !0
});
A1.createInscription = void 0;
const hwe = Lo, pwe = Hs, gwe = N0, ywe = async (e)=>{
    var n, i;
    const { getProvider: t } = e, r = await (0, pwe.getProviderOrThrow)(t);
    (0, gwe.validateInscriptionPayload)(e.payload);
    try {
        const o = (0, hwe.createUnsecuredToken)(e.payload);
        if (r.createInscription) {
            const s = await r.createInscription(o);
            (n = e.onFinish) == null || n.call(e, s);
        }
    } catch (o) {
        console.error("[Connect] Error during create inscription", o), (i = e.onCancel) == null || i.call(e);
    }
};
A1.createInscription = ywe;
var T1 = {};
Object.defineProperty(T1, "__esModule", {
    value: !0
});
T1.createRepeatInscriptions = void 0;
const mwe = Hs, bwe = Lo, wwe = N0, vwe = async (e)=>{
    var n, i;
    const { getProvider: t } = e, r = await (0, mwe.getProviderOrThrow)(t);
    (0, wwe.validateInscriptionPayload)(e.payload);
    try {
        const o = (0, bwe.createUnsecuredToken)(e.payload);
        if (r.createRepeatInscriptions) {
            const s = await r.createRepeatInscriptions(o);
            (n = e.onFinish) == null || n.call(e, s);
        }
    } catch (o) {
        console.error("[Connect] Error during create repeat inscriptions", o), (i = e.onCancel) == null || i.call(e);
    }
};
T1.createRepeatInscriptions = vwe;
var BU = {};
Object.defineProperty(BU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(A1, e), r(T1, e), r(BU, e);
})(IU);
var OU = {}, PU = {};
Object.defineProperty(PU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.signMessage = void 0;
    const n = Lo, i = Hs, o = async (s)=>{
        var c, l;
        const a = await (0, i.getProviderOrThrow)(s.getProvider), { address: u, message: f } = s.payload;
        if (!u) throw new Error("An address is required to sign a message");
        if (!f) throw new Error("A message to be signed is required");
        try {
            const p = (0, n.createUnsecuredToken)(s.payload), y = await a.signMessage(p);
            (c = s.onFinish) == null || c.call(s, y);
        } catch (p) {
            console.error("[Connect] Error during sign message request", p), (l = s.onCancel) == null || l.call(s);
        }
    };
    e.signMessage = o, r(PU, e);
})(OU);
var NU = {}, k1 = {};
Object.defineProperty(k1, "__esModule", {
    value: !0
});
k1.sendBtcTransaction = void 0;
const _we = Lo, Ewe = Hs, xwe = (e)=>e.map((t)=>{
        const { address: r, amountSats: n } = t;
        return {
            address: r,
            amountSats: n.toString()
        };
    }), Swe = async (e)=>{
    var s, a;
    const t = await (0, Ewe.getProviderOrThrow)(e.getProvider), { recipients: r, senderAddress: n, network: i, message: o } = e.payload;
    if (!r || r.length === 0) throw new Error("At least one recipient is required");
    if (r.some((u)=>typeof u.address != "string" || typeof u.amountSats != "bigint")) throw new Error("Incorrect recipient format");
    if (!n) throw new Error("The sender address is required");
    try {
        const u = xwe(r), f = {
            network: i,
            senderAddress: n,
            message: o,
            recipients: u
        }, c = (0, _we.createUnsecuredToken)(f), l = await t.sendBtcTransaction(c);
        (s = e.onFinish) == null || s.call(e, l);
    } catch (u) {
        console.error("[Connect] Error during send BTC transaction request", u), (a = e.onCancel) == null || a.call(e);
    }
};
k1.sendBtcTransaction = Swe;
var I1 = {};
Object.defineProperty(I1, "__esModule", {
    value: !0
});
I1.signTransaction = void 0;
const Awe = Lo, Twe = Hs, kwe = async (e)=>{
    var i, o;
    const t = await (0, Twe.getProviderOrThrow)(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
    if (!r) throw new Error("A value for psbtBase64 representing the tx hash is required");
    if (!n) throw new Error("An array specifying the inputs to be signed by the wallet is required");
    try {
        const s = (0, Awe.createUnsecuredToken)(e.payload), a = await t.signTransaction(s);
        (i = e.onFinish) == null || i.call(e, a);
    } catch (s) {
        console.error("[Connect] Error during sign transaction request", s), (o = e.onCancel) == null || o.call(e);
    }
};
I1.signTransaction = kwe;
var B1 = {};
Object.defineProperty(B1, "__esModule", {
    value: !0
});
B1.signMultipleTransactions = void 0;
const Iwe = Lo, Bwe = Hs, Owe = async (e)=>{
    var n, i;
    const t = await (0, Bwe.getProviderOrThrow)(e.getProvider), { psbts: r } = e.payload;
    if (!r || !r.length) throw new Error("psbts array is required");
    if (r.length > 100) throw new Error("psbts array must contain less than 100 psbts");
    try {
        const o = (0, Iwe.createUnsecuredToken)(e.payload), s = await t.signMultipleTransactions(o);
        (n = e.onFinish) == null || n.call(e, s);
    } catch (o) {
        console.error("[Connect] Error during sign Multiple transactions request", o), (i = e.onCancel) == null || i.call(e);
    }
};
B1.signMultipleTransactions = Owe;
var MU = {};
Object.defineProperty(MU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(k1, e), r(I1, e), r(B1, e), r(MU, e);
})(NU);
var RU = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
        t.Mainnet = "Mainnet", t.Testnet = "Testnet";
    }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
        t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
    }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(RU);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(wU, e), r(EU, e), r(TU, e), r(IU, e), r(OU, e), r(Hs, e), r(NU, e), r(RU, e);
})(Jh);
const Jl = /* @__PURE__ */ c7(Jh), Pwe = Jl == null ? void 0 : Jl.signMessage, Nwe = Jl == null ? void 0 : Jl.sendBtcTransaction, Mwe = "ORANGE_CONNECTED_WALLET_STATE";
class Rwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(Mwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : r.OrangeBitcoinProvider;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Qu, r, i, this.$valueStore);
    }
    initialize() {
        var r;
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n;
            window.OrangeBitcoinProvider && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Qu]: !0
            }), (n = this.observer) == null || n.disconnect());
        }), (r = this.observer) == null || r.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (n)=>{
            n.provider !== Qu ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        const { address: n, paymentAddress: i } = this.$valueStore.get();
        if (n) {
            this.restorePersistedValues(), id(i, this.network).then((a)=>{
                this.$store.setKey("balance", a);
            });
            return;
        }
        const o = h_(this.network || ln), s = {
            payload: {
                purposes: [
                    "ordinals",
                    "payment"
                ],
                message: "Address for receiving Ordinals and payments",
                network: {
                    type: o
                }
            },
            onFinish: (a)=>{
                const u = um(a.addresses), f = fm(a.addresses);
                if (!u || !(f != null && f.address)) throw new Error("Could not find addresses");
                u && f && (this.$store.setKey("provider", Qu), this.$store.setKey("address", u.address), this.$store.setKey("paymentAddress", f.address)), this.$store.setKey("publicKey", String(u.publicKey)), this.$store.setKey("paymentPublicKey", String(f.publicKey)), this.$store.setKey("accounts", a.addresses.map((c)=>c.address));
            },
            onCancel: ()=>{
                throw new Error(`User canceled lasereyes to ${Qu} wallet`);
            }
        };
        await Jh.getAddress(s), this.$store.setKey("connected", !0);
    }
    async getNetwork() {
        const { address: r } = this.$store.get();
        return r.slice(0, 1) === "t" && [
            Ni,
            ao,
            Ro,
            co
        ].includes(this.network) ? this.network : ln;
    }
    async sendBTC(r, n) {
        let i = "";
        const o = {
            payload: {
                network: {
                    type: h_(this.network)
                },
                recipients: [
                    {
                        address: r,
                        amountSats: BigInt(n)
                    }
                ],
                senderAddress: this.$store.get().paymentAddress
            },
            onFinish: (s)=>{
                i = s;
            },
            onCancel: ()=>{
                throw new Error("User canceled the request");
            }
        };
        return await Nwe(o), i;
    }
    async signMessage(r, n) {
        let i = "";
        const o = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress, s = {
            payload: {
                network: {
                    type: h_(this.network)
                },
                address: o,
                message: r
            },
            onFinish: (a)=>{
                i = a;
            },
            onCancel: ()=>{
                throw new Error("User canceled the request");
            }
        };
        return await Pwe(s), i;
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        try {
            const a = Cr.fromBase64(String(r), {
                network: Dr(this.network)
            }).data.inputs;
            let u = {};
            if (o) u = o.reduce((_, A)=>(_[A.address] = [
                    ..._[A.address] || [],
                    A.index
                ], _), {});
            else {
                const { address: _, paymentAddress: A } = this.$store.get(), O = {
                    [_]: []
                }, N = {
                    [A]: []
                };
                for (const U of a.keys()){
                    const D = a[U];
                    if (D.witnessUtxo === void 0) {
                        N[A].push(Number(U));
                        continue;
                    }
                    const { script: H } = D.witnessUtxo, K = Yp(H, Dr(this.network));
                    K === A ? N[A].push(Number(U)) : K === _ && O[_].push(Number(U));
                }
                O[_].length > 0 && (u = {
                    ...u,
                    ...O
                }), N[A].length > 0 && (u = {
                    ...u,
                    ...N
                });
            }
            let f, c, l, p;
            const y = await Jh.request("signPsbt", {
                psbt: r,
                broadcast: !!n,
                signInputs: u
            });
            if (y.status === "success") p = Cr.fromBase64(y.result.psbt, {
                network: Dr(this.network)
            }), f = y.result.txid;
            else throw y.error.code === Jh.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
            if (!p) throw new Error("Error signing psbt");
            return i && !f ? (p.finalizeAllInputs(), c = p.toHex(), l = p.toBase64()) : (c = p.toHex(), l = p.toBase64()), {
                signedPsbtHex: c,
                signedPsbtBase64: l,
                txId: f
            };
        } catch (s) {
            throw console.error(s), s;
        }
    }
}
const Cwe = "OYL_CONNECTED_WALLET_STATE";
class Uwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(Cwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        return window.oyl;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Il, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n;
            (window == null ? void 0 : window.oyl) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Il]: !0
            }), (n = this.observer) == null || n.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Il ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { nativeSegwit: n, taproot: i, nestedSegwit: o, legacy: s } = await this.library.getAddresses();
        if (!n || !i) throw new Error("No accounts found");
        this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", n.address), this.$store.setKey("publicKey", i.publicKey), this.$store.setKey("paymentPublicKey", n.publicKey), this.$store.setKey("accounts", [
            i.address,
            n.address,
            o.address,
            s.address
        ]);
    }
    async getNetwork() {
        var r;
        return (r = this.library) == null ? void 0 : r.getNetwork();
    }
    async sendBTC(r, n) {
        const { psbtHex: i, psbtBase64: o } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), s = await this.signPsbt({
            psbtBase64: o,
            psbtHex: i,
            tx: i,
            broadcast: !0,
            finalize: !0
        });
        if (!s || !s.txId) throw new Error("Error sending BTC");
        return s.txId;
    }
    async signMessage(r, n) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const i = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress;
        return (await this.library.signMessage({
            address: i,
            message: r,
            protocol: n == null ? void 0 : n.protocol
        })).signature;
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i }) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { psbt: o, txid: s } = await this.library.signPsbt({
            psbt: r,
            finalize: i,
            broadcast: n
        }), a = Cr.fromHex(o);
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: s
        };
    }
    async signPsbts(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { psbts: n, finalize: i, broadcast: o } = r, s = n.map((f)=>({
                psbt: f,
                finalize: i,
                broadcast: o
            })), a = await this.library.signPsbts(s);
        return {
            signedPsbts: a.map((f, c)=>{
                const l = Cr.fromHex(f.psbt);
                return {
                    signedPsbtHex: l.toHex(),
                    signedPsbtBase64: l.toBase64(),
                    txId: a[c].txid
                };
            }) || []
        };
    }
    async pushPsbt(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        return (await this.library.pushPsbt({
            psbt: r
        })).txid;
    }
    async getPublicKey() {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { nativeSegwit: r, taproot: n } = await this.library.getAddresses();
        if (!r || !n) throw new Error("No accounts found");
        return this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), n.publicKey;
    }
    async getBalance() {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { total: r } = await this.library.getBalance();
        return this.$store.setKey("balance", BigInt(r)), r;
    }
    async requestAccounts() {
        return [
            this.$store.get().address,
            this.$store.get().paymentAddress
        ];
    }
    async switchNetwork(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        await this.library.switchNetwork(r), this.$network.set(r), await this.parent.connect(Il);
    }
}
class $we extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.phantom) == null ? void 0 : r.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Pl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider === Pl && this.library.requestAccounts().then((n)=>{
                this.handleAccountsChanged(n);
            });
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Pl) : this.parent.disconnect());
    }
    async connect(r) {
        if (!this.library) throw new Error("Phantom isn't installed");
        if (LP(this.network)) throw new Error(`${this.network} is not supported by ${Pl}`);
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        this.$store.setKey("accounts", n);
        const i = n.find((s)=>s.purpose === "ordinals"), o = n.find((s)=>s.purpose === "payment");
        this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", i.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("accounts", n.map((s)=>s.address));
    }
    async getNetwork() {
        return this.$store.get().address.slice(0, 1) === "t" ? Ni : ln;
    }
    async sendBTC(r, n) {
        const { psbtHex: i, psbtBase64: o } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), s = await this.signPsbt({
            psbtBase64: o,
            psbtHex: i,
            tx: i,
            broadcast: !0,
            finalize: !0
        });
        if (!s || !s.txId) throw new Error("Error sending BTC");
        return s.txId;
    }
    async signMessage(r, n) {
        var f;
        if ((n == null ? void 0 : n.protocol) === f0) throw new Error("ECDSA signing is not supported by Phantom");
        const i = new TextEncoder().encode(r), o = new Uint8Array(i), s = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress, a = await ((f = this.library) == null ? void 0 : f.signMessage(s, o)), u = String.fromCharCode(...a.signature);
        return btoa(u);
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const a = Cr.fromHex(String(r), {
            network: Dr(this.network)
        }).data.inputs;
        let u = [];
        if (o) {
            const l = o.reduce((p, y)=>({
                    ...p,
                    [y.address]: [
                        ...p[y.address] || [],
                        y.index
                    ]
                }), {});
            u = Object.entries(l).map(([p, y])=>({
                    address: p,
                    signingIndexes: y
                }));
        } else {
            const { address: l, paymentAddress: p } = this.$store.get(), y = {
                address: l,
                signingIndexes: []
            }, _ = {
                address: p,
                signingIndexes: []
            };
            for (let A of a.keys()){
                const O = a[A];
                if (O.witnessUtxo === void 0) {
                    _.signingIndexes.push(Number(A));
                    continue;
                }
                const { script: N } = O.witnessUtxo, U = Yp(N, Dr(this.network));
                U === p ? _.signingIndexes.push(Number(A)) : U === l && y.signingIndexes.push(Number(A));
            }
            y.signingIndexes.length > 0 && u.push(y), _.signingIndexes.length > 0 && u.push(_);
        }
        const f = await this.library.signPSBT(rwe(r), {
            inputsToSign: u
        }), c = Cr.fromBuffer(f);
        if (i && u.forEach((l)=>{
            l.signingIndexes.forEach((p)=>{
                c.finalizeInput(p);
            });
        }), n) {
            const l = await this.pushPsbt(c.toHex());
            return {
                signedPsbtHex: c.toHex(),
                signedPsbtBase64: c.toBase64(),
                txId: l
            };
        }
        return {
            signedPsbtHex: c.toHex(),
            signedPsbtBase64: c.toBase64(),
            txId: void 0
        };
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
}
const Ah = {}, wE = console.log;
function Th(e) {
    if (Ah[e]) return console.warn(`Multiple requests for "${e}" detected`), Ah[e];
    const t = new Promise((r, n)=>{
        const i = setTimeout(()=>{
            console.log = wE, Ah[e] = void 0, n(new Error(`Timeout waiting for "${e}" value`));
        }, 6e4);
        console.log = (...o)=>{
            o.length > 0 && typeof o[0] == "string" && (clearTimeout(i), console.log = wE, Ah[e] = void 0, r(o[0]));
        }, wE(`Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`);
    });
    return Ah[e] = t, t;
}
class Lwe {
    async requestAccounts(t) {
        const r = await Th(`address_${t || "mainnet"}`);
        if (!r) throw new Error("No address provided");
        const n = await Th(`paymentAddress_${t || "mainnet"}`);
        if (!n) throw new Error("No payment address provided");
        return [
            r,
            n
        ];
    }
    async signMessage(t) {
        return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Th("message to sign");
    }
    async signPsbt(t) {
        return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Th("signed psbt hex");
    }
    async getPublicKey(t) {
        const r = await Th(`publicKey_${t || "mainnet"}`);
        if (!r) throw new Error("No public key provided");
        return r;
    }
    // TODO: Implement network switching between mainnet and testnet
    async getNetwork() {
        return "mainnet";
    }
    async switchNetwork(t) {
        const [r, n] = await this.requestAccounts(), i = await this.getPublicKey();
        return {
            address: r,
            paymentAddress: n,
            publicKey: i
        };
    }
}
const Dwe = "SPARROW_CONNECTED_WALLET_STATE";
class Fwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(Dwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        return window == null ? void 0 : window.SparrowWalletProvider;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library || (window.SparrowWalletProvider = new Lwe()), this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ml]: !0
            }), (r = this.observer) == null || r.disconnect();
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Ml ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    watchStateChange(r, n, i) {
        Wf(Ml, r, i, this.$valueStore);
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        try {
            const { address: n, paymentAddress: i } = this.$valueStore.get();
            if (n && i) if (n.startsWith("tb1") && qb(this.network)) this.disconnect();
            else {
                this.restorePersistedValues();
                return;
            }
            if (!this.library) throw new Error("Sparrow wallet isn't supported");
            const o = await this.library.requestAccounts();
            if (!o) throw new Error("No accounts found");
            await this.getNetwork().then((a)=>{
                this.network !== a && this.switchNetwork(this.network);
            });
            const s = await this.library.getPublicKey();
            if (!s) throw new Error("No public key found");
            this.$store.setKey("accounts", o), this.$store.setKey("address", o[0]), this.$store.setKey("paymentAddress", o[1]), this.$store.setKey("publicKey", s), this.$store.setKey("paymentPublicKey", s);
        } catch (n) {
            throw console.error("Error during sparrow connect:", n), n;
        }
    }
    async getNetwork() {
        return this.network;
    }
    async switchNetwork(r) {
        if (!this.library) throw new Error("Sparrow wallet isn't supported");
        try {
            const n = await this.library.switchNetwork(r);
            if (!n) throw new Error("No result returned from switchNetwork");
            const { address: i, paymentAddress: o, publicKey: s } = n;
            this.$store.setKey("address", i), this.$store.setKey("paymentAddress", o), this.$store.setKey("publicKey", s), this.$store.setKey("paymentPublicKey", s), this.$network.set(r);
        } catch (n) {
            throw console.error("Error during sparrow switchNetwork:", n), n;
        }
    }
    async sendBTC(r, n) {
        const { psbtBase64: i } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), o = await this.library.signPsbt(i);
        if (!o) throw new Error("No signed PSBT provided");
        const s = await this.pushPsbt(o);
        if (!s) throw new Error("send failed, no txid returned");
        return s;
    }
    async signMessage(r) {
        return await this.library.signMessage(r);
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i }) {
        const o = Cr.fromBase64(r), s = await this.library.signPsbt(r);
        if (i && n) {
            const a = await this.pushPsbt(s);
            return {
                signedPsbtHex: s,
                signedPsbtBase64: o.toBase64(),
                txId: a
            };
        }
        return {
            signedPsbtHex: s,
            signedPsbtBase64: o.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        const r = await this.library.getPublicKey();
        return this.$store.setKey("publicKey", r), r;
    }
    async getBalance() {
        const r = await id(this.$store.get().paymentAddress, this.network);
        return this.$store.setKey("balance", r), r.toString();
    }
    async requestAccounts() {
        return await this.connect(Ml), this.$store.get().accounts;
    }
}
const zwe = "TOKEO_CONNECTED_WALLET_STATE";
class jwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(zwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var r;
        return (r = window.tokeo) == null ? void 0 : r.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf($h, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [$h]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== $h ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        try {
            if (!this.library) if (this.isMobile()) {
                const s = `tokeo://open-url?url=${encodeURIComponent(window.location.href)}`, a = window.open(s);
                if (!a) throw new Error("Tokeo wallet not found");
                return a.focus(), !1;
            } else throw new Error("Tokeo wallet not found");
            await this.library.requestAccounts();
            const n = (await this.library.getAccounts()).accounts;
            if (!n || n.length === 0) throw new Error("No accounts found");
            const i = n.find((s)=>s.type === "p2tr"), o = n.find((s)=>s.type === "p2wpkh");
            if (!i) throw new Error("No p2tr address found");
            this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", (o == null ? void 0 : o.address) ?? i.address), this.$store.setKey("publicKey", i.publicKey), this.$store.setKey("paymentPublicKey", (o == null ? void 0 : o.publicKey) ?? i.publicKey), this.$store.setKey("accounts", n.map((s)=>s.address));
        } catch (n) {
            throw console.error(n), n;
        }
    }
    async getNetwork() {
        return ln;
    }
    async sendBTC(r, n) {
        const { psbtHex: i, psbtBase64: o } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), s = await this.signPsbt({
            psbtBase64: o,
            psbtHex: i,
            tx: i,
            broadcast: !0,
            finalize: !0
        });
        if (!s || !s.txId) throw new Error("Error sending BTC");
        return s.txId;
    }
    async signMessage(r, n) {
        return await this.library.signMessage(r, n == null ? void 0 : n.protocol);
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const s = {
            autoFinalize: i,
            inputs: o == null ? void 0 : o.map((c)=>({
                    index: c.index,
                    address: c.address
                }))
        }, a = await this.library.signPsbt(r, Sf(s)), u = Cr.fromBase64(a);
        let f;
        return n && (f = await this.pushPsbt(a)), {
            signedPsbtHex: u.toHex(),
            signedPsbtBase64: u.toBase64(),
            txId: f
        };
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async requestAccounts() {
        return await this.library.requestAccounts(), (await this.library.getAccounts()).accounts.map((n)=>n.address);
    }
}
class Hwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        return window.unisat;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Bl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            var n;
            if (r.provider !== Bl) {
                this == null || this.removeListeners();
                return;
            }
            (n = this.library) == null || n.getAccounts().then((i)=>{
                this.handleAccountsChanged(i);
            }), this.addListeners();
        });
    }
    addListeners() {
        var r, n;
        (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var r, n;
        !this.library || !this.library.removeListener || ((r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Bl) : this.parent.disconnect());
    }
    handleNetworkChanged(r) {
        const n = om(r);
        this.network !== n && this.switchNetwork(n), this.parent.connect(Bl);
    }
    async connect(r) {
        if (!this.library) throw new Error("Unisat isn't installed");
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        const i = await this.library.getPublicKey();
        if (!i) throw new Error("No public key found");
        this.$store.setKey("accounts", n), this.$store.setKey("address", n[0]), this.$store.setKey("paymentAddress", n[0]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i);
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getChain());
        return r ? om(r.enum) : this.network;
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (!i) throw new Error("Transaction failed");
        return i;
    }
    async signMessage(r, n) {
        var o;
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await ((o = this.library) == null ? void 0 : o.signMessage(r, i));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var u;
        const s = await ((u = this.library) == null ? void 0 : u.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        }))), a = Cr.fromHex(s);
        if (i && n) {
            const f = await this.pushPsbt(s);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: f
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async signPsbts(r) {
        const { psbts: n, finalize: i, broadcast: o, inputsToSign: s } = r, a = await this.library.signPsbts(n, Sf({
            autoFinalized: i,
            toSignInputs: s
        }));
        return {
            signedPsbts: await Promise.all(a.map(async (f)=>{
                const c = Cr.fromHex(f);
                let l;
                return i && o && (l = await this.pushPsbt(f)), {
                    signedPsbtHex: c.toHex(),
                    signedPsbtBase64: c.toBase64(),
                    txId: l
                };
            }))
        };
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(r, n) {
        const i = r || 0, o = n || 10;
        return (await this.library.getInscriptions(i, o)).list.map((u)=>Kl(u, void 0, this.network));
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async switchNetwork(r) {
        var i;
        const n = fP(r);
        await ((i = this.library) == null ? void 0 : i.switchChain(n)), this.$network.set(r);
    }
}
class qwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        return window.wizz;
    }
    get network() {
        return this.$network.get();
    }
    handleNetworkChanged(r) {
        this.parent.connect(Uh);
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && this.$store.setKey("accounts", r);
    }
    initialize() {
        $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider === Uh ? this.addLibraryListeners() : this.removeLibraryListeners();
        }), ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Uh]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        }));
    }
    removeLibraryListeners() {
        var r, n;
        !this.library || !this.library.removeListener || ((r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)), (n = this.library) == null || n.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)));
    }
    addLibraryListeners() {
        var r, n;
        (r = this.library) == null || r.on("networkChanged", this.handleNetworkChanged.bind(this)), (n = this.library) == null || n.on("accountsChanged", this.handleAccountsChanged.bind(this));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeLibraryListeners();
    }
    async connect() {
        if (!this.library) throw fme;
        const r = await this.library.requestAccounts();
        if (!r) throw new Error("No accounts found");
        const n = await this.library.getPublicKey();
        if (!n) throw new Error("No public key found");
        this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), await this.getNetwork().then((i)=>{
            var o;
            i && ((o = this.config) == null ? void 0 : o.network) !== i && this.parent.switchNetwork(i);
        });
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getNetwork());
        return r ? fk(r) : void 0;
    }
    async switchNetwork(r) {
        var i;
        if (r === co || r === yc) return await this.library.switchNetwork(ko.MAINNET);
        const n = fk(r);
        await ((i = this.library) == null ? void 0 : i.switchNetwork(n)), this.$network.set(r), await this.parent.getBalance();
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(r, n) {
        const i = r || 0, o = n || 10;
        return (await this.library.getInscriptions(i, o)).list.map((u)=>Kl(u, void 0, this.network));
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (i) return i;
        throw new Error("Error sending BTC");
    }
    async signMessage(r, n) {
        var o;
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await ((o = this.library) == null ? void 0 : o.signMessage(r, i));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var f;
        const s = await ((f = this.library) == null ? void 0 : f.signPsbt(r, Sf({
            autoFinalized: i,
            broadcast: !1,
            toSignInputs: o
        }))), a = Cr.fromHex(s);
        let u;
        return i && n && (u = await this.pushPsbt(s)), {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: u
        };
    }
}
const Kwe = (e)=>e === ln ? Mn.Mainnet : e === Ni ? Mn.Testnet : e === Ro ? Mn.Signet : e === co ? Mn.Testnet : e === yc ? Mn.Mainnet : e === ao ? Mn.Testnet4 : Mn.Mainnet;
class Wwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
    }
    get network() {
        return this.$network.get();
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.XverseProviders) == null ? void 0 : r.BitcoinProvider;
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ol]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        }));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    addListeners() {
        uk("accountChange", ()=>{}), uk("networkChange", (r)=>{
            r.type === "networkChange" && this.handleNetworkChanged(r.bitcoin.name);
        });
    }
    removeListeners() {
        console.log("removeListeners");
    }
    // private handleAccountsChanged(accounts: string[]) {
    //   console.log('handleAccountsChanged', accounts)
    //   if (!accounts.length) {
    //     this.parent.disconnect()
    //     return
    //   }
    //   // if (this.$store.get().accounts[0] === accounts[0]) {
    //   //   return
    //   // }
    //   // this.$store.setKey('accounts', accounts)
    //   // if (accounts.length > 0) {
    //   //   this.parent.connect(XVERSE)
    //   // } else {
    //   //   this.parent.disconnect()
    //   // }
    // }
    handleNetworkChanged(r) {
        const n = p_(r);
        this.$network.set(n), this.parent.connect(Ol);
    }
    async connect(r) {
        if (this.isMobile() && !this.library) {
            const a = `xverse://browser?url=${encodeURIComponent(window.location.href)}`;
            window.location.href = a;
            return;
        }
        let n, i, o, s = [];
        try {
            const a = await Wu("wallet_getAccount", null);
            if (a.status === "success") n = um(a.result.addresses), i = fm(a.result.addresses), o = a.result.network.bitcoin.name, s = a.result.addresses.map((u)=>u.address);
            else throw new Error(`Error getting account: ${a.error.message}`);
        } catch (a) {
            if (a instanceof Error && (a.message.toLowerCase().includes("failed to get") || a.message.toLowerCase().includes("access denied"))) {
                const u = await Wu("wallet_connect", {
                    addresses: [
                        vf.Ordinals,
                        vf.Payment
                    ],
                    message: "Connecting with lasereyes"
                });
                if (u.status === "success") n = um(u.result.addresses), i = fm(u.result.addresses), o = u.result.network.bitcoin.name, s = u.result.addresses.map((f)=>f.address);
                else throw u.error.code === kh.USER_REJECTION ? new Error(`User canceled lasereyes to ${Ol} wallet`) : new Error(u.error.message);
            } else throw console.error(a), new Error(`Error connecting to ${Ol} wallet`);
        }
        if (!n || !i) throw new Error("Could not find the addresses");
        this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", i.address), this.$store.setKey("publicKey", String(n.publicKey)), this.$store.setKey("paymentPublicKey", String(i.publicKey)), this.$store.setKey("accounts", s), o && this.$network.set(p_(o));
    }
    async getNetwork() {
        try {
            const r = await Wu("wallet_getNetwork", null);
            if (r.status === "success") return p_(r.result.bitcoin.name);
            throw new Error("Error getting network");
        } catch (r) {
            return console.error(r), this.network;
        }
    }
    async switchNetwork(r) {
        if ((await Wu("wallet_changeNetwork", {
            name: Kwe(r)
        })).status === "success") this.handleNetworkChanged(r);
        else throw new Error("Error switching network");
    }
    async sendBTC(r, n) {
        const i = await Wu("sendTransfer", {
            recipients: [
                {
                    address: r,
                    amount: n
                }
            ]
        });
        if (i.status === "success") return i.result.txid;
        throw i.error.code === kh.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error sending BTC: ${i.error.message}`);
    }
    async signMessage(r, { toSignAddress: n, protocol: i }) {
        const o = n || this.$store.get().paymentAddress, s = await Wu("signMessage", {
            address: o,
            message: r,
            protocol: i === f0 ? _f.ECDSA : _f.BIP322
        });
        if (s.status === "success") return s.result.signature;
        throw s.error.code === kh.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error signing message: ${s.error.message}`);
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        try {
            const a = Cr.fromBase64(String(r), {
                network: Dr(this.network)
            }).data.inputs;
            let u = {};
            if (o) u = o.reduce((_, A)=>(_[A.address] = [
                    ..._[A.address] || [],
                    A.index
                ], _), {});
            else {
                const { address: _, paymentAddress: A } = this.$store.get(), O = {
                    [_]: []
                }, N = {
                    [A]: []
                };
                for (const U of a.keys()){
                    const D = a[U];
                    if (D.witnessUtxo === void 0) {
                        N[A].push(Number(U));
                        continue;
                    }
                    const { script: H } = D.witnessUtxo, K = Yp(H, Dr(this.network));
                    K === A ? N[A].push(Number(U)) : K === _ && O[_].push(Number(U));
                }
                O[_].length > 0 && (u = {
                    ...u,
                    ...O
                }), N[A].length > 0 && (u = {
                    ...u,
                    ...N
                });
            }
            let f, c, l, p;
            const y = await Wu("signPsbt", {
                psbt: r,
                broadcast: !!n,
                signInputs: u
            });
            if (y.status === "success") p = Cr.fromBase64(y.result.psbt, {
                network: Dr(this.network)
            }), f = y.result.txid;
            else throw y.error.code === kh.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
            if (!p) throw new Error("Error signing psbt");
            return i && !f ? (p.finalizeAllInputs(), c = p.toHex(), l = p.toBase64()) : (c = p.toHex(), l = p.toBase64()), {
                signedPsbtHex: c,
                signedPsbtBase64: l,
                txId: f
            };
        } catch (s) {
            throw console.error(s), s;
        }
    }
}
class u_e {
    constructor(t, r){
        pt(this, "$store");
        pt(this, "$network");
        pt(this, "$providerMap");
        pt(this, "disposed", !1);
        pt(this, "dataSourceManager");
        pt(this, "modules");
        this.config = r, this.$store = t.$store, this.$network = t.$network, cG(this.$store), this.$providerMap = {
            [Rh]: new iwe(t, this, r),
            [ru]: new swe(t, this, r),
            [Ch]: new cwe(t, this, r),
            [Nl]: new uwe(t, this, r),
            [Qu]: new Rwe(t, this, r),
            [Il]: new Uwe(t, this, r),
            [Pl]: new $we(t, this, r),
            [Ml]: new Fwe(t, this, r),
            [$h]: new jwe(t, this, r),
            [Bl]: new Hwe(t, this, r),
            [Ol]: new Wwe(t, this, r),
            [Uh]: new qwe(t, this, r),
            [Rl]: new lme(t, this, r)
        }, this.modules = {
            alkanes: new lM(this)
        };
        try {
            this.dataSourceManager = nc.getInstance();
        } catch  {
            nc.init(r), this.dataSourceManager = nc.getInstance();
        }
    }
    dispose() {
        this.disposed = !0;
        for (const t of Object.values(this.$providerMap))t.dispose();
    }
    initialize() {
        this.$network.listen(this.watchNetworkChange.bind(this)), $o(this.$store, [
            "isInitializing"
        ], (t, r)=>{
            if (!this.disposed && t.isInitializing !== r.isInitializing) return this.handleIsInitializingChanged(t.isInitializing);
        }), twe(()=>{
            this.$store.setKey("isInitializing", !1), this.checkNetwork();
        });
    }
    async checkNetwork() {
        var i;
        const { provider: t, isInitializing: r } = this.$store.get();
        if (!t || r) return;
        const n = await this.getNetwork();
        n && (this.dataSourceManager.updateNetwork(n), this.$network.set(n));
        try {
            (i = this.config) != null && i.network && this.config.network !== n && await this.switchNetwork(this.config.network);
        } catch (o) {
            console.error("Couldn't enforce config network", o), this.disconnect();
        }
    }
    handleIsInitializingChanged(t) {
        if (("TURBOPACK compile-time value", "undefined") < "u" && typeof localStorage < "u" && !t) {
            const r = localStorage == null ? void 0 : localStorage.getItem(ev);
            r && this.connect(r);
        }
    }
    async connect(t) {
        if (this.disposed) {
            console.warn("Client disposed, cannot connect");
            return;
        }
        this.$store.setKey("isConnecting", !0);
        try {
            if (localStorage == null || localStorage.setItem(ev, t), !this.$providerMap[t]) throw new Error("Unsupported wallet provider");
            const r = this.$providerMap[t];
            if (await (r == null ? void 0 : r.connect(t)) === !1) {
                this.$store.setKey("isConnecting", !1), this.disconnect();
                return;
            }
            this.$store.setKey("provider", t), await this.checkNetwork(), this.$store.setKey("connected", !0);
        } catch (r) {
            throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", !1), this.disconnect(), r;
        } finally{
            this.$store.setKey("isConnecting", !1);
        }
    }
    async requestAccounts() {
        var r;
        const t = this.$store.get().provider;
        if (!t) throw new Error("No wallet provider connected");
        try {
            return await ((r = this.$providerMap[t]) == null ? void 0 : r.requestAccounts());
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : n;
        }
    }
    disconnect() {
        this.$store.set({
            provider: void 0,
            address: "",
            paymentAddress: "",
            publicKey: "",
            paymentPublicKey: "",
            balance: void 0,
            accounts: [],
            connected: !1,
            isConnecting: !1,
            isInitializing: !1,
            hasProvider: this.$store.get().hasProvider
        }), localStorage == null || localStorage.removeItem(ev);
    }
    async switchNetwork(t) {
        var r;
        try {
            const n = this.$store.get().provider;
            n && (console.log("switchNetwork", t), await ((r = this.$providerMap[n]) == null ? void 0 : r.switchNetwork(t)), this.dataSourceManager.updateNetwork(t));
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error("The connected wallet doesn't support programmatic network changes..")) : n;
        }
    }
    watchNetworkChange() {
        this.$store.setKey("balance", void 0), this.getBalance();
    }
    async getNetwork() {
        var r;
        const t = this.$store.get().provider;
        return t && this.$providerMap[t] ? await ((r = this.$providerMap[t]) == null ? void 0 : r.getNetwork()) : this.$network.get();
    }
    async sendBTC(t, r) {
        var i;
        if (r <= 0) throw new Error("Amount must be greater than 0");
        if (!Number.isInteger(r)) throw new Error("Amount must be an integer");
        const n = this.$store.get().provider;
        if (!n) throw new Error("No wallet connected");
        if (n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.sendBTC(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending BTC...") : o;
        }
        throw new Error("Something went wrong");
    }
    async signMessage(t, r) {
        let n = {};
        typeof r == "string" ? n = {
            toSignAddress: r
        } : r && (n = r);
        const i = this.$store.get().provider;
        if (!i) throw new Error("No wallet connected");
        if (i && this.$providerMap[i]) try {
            return await this.$providerMap[i].signMessage(t, n);
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support message signing...") : o;
        }
        throw new Error("Something went wrong");
    }
    async signPsbt(t, r, n) {
        var l;
        let i, o, s, a;
        typeof t == "string" ? (i = t, o = r ?? !1, s = n ?? !1) : (i = t.tx, o = t.finalize ?? !1, s = t.broadcast ?? !1, a = t.inputsToSign);
        let u, f;
        if (!i) throw new Error("No PSBT provided");
        if (Wae(i)) f = Cr.fromHex(i).toBase64(), u = i;
        else if (Kae(i)) f = i, u = Cr.fromBase64(i).toHex();
        else throw new Error("Invalid PSBT format");
        const c = this.$store.get().provider;
        if (c && this.$providerMap[c]) try {
            return await ((l = this.$providerMap[c]) == null ? void 0 : l.signPsbt({
                psbtHex: u,
                psbtBase64: f,
                tx: i,
                broadcast: s,
                finalize: o,
                inputsToSign: a
            }));
        } catch (p) {
            throw p instanceof Error && p.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : p;
        }
        else throw new Error("No wallet provider connected");
    }
    async signPsbts(t) {
        var a;
        const { psbts: r, finalize: n = !1, broadcast: i = !1, inputsToSign: o } = t;
        if (!r || r.length === 0) throw new Error("No PSBTs provided");
        const s = this.$store.get().provider;
        if (s && this.$providerMap[s]) try {
            return await ((a = this.$providerMap[s]) == null ? void 0 : a.signPsbts({
                psbts: r,
                finalize: n,
                broadcast: i,
                inputsToSign: o
            }));
        } catch (u) {
            throw u instanceof Error && u.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : u;
        }
        else throw new Error("No wallet provider connected");
    }
    async pushPsbt(t) {
        var n;
        const r = this.$store.get().provider;
        if (r && r && this.$providerMap[r]) try {
            return await ((n = this.$providerMap[r]) == null ? void 0 : n.pushPsbt(t));
        } catch (i) {
            throw i instanceof Error && i.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : i;
        }
    }
    async inscribe(t, r, n) {
        var o;
        const i = this.$store.get().provider;
        if (i && i && this.$providerMap[i]) try {
            return await ((o = this.$providerMap[i]) == null ? void 0 : o.inscribe(t, r, this.dataSourceManager, n));
        } catch (s) {
            throw s instanceof Error && s.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support inscribing...") : s;
        }
    }
    async send(t, r) {
        var i;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.send(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending stuff...") : o;
        }
    }
    async getPublicKey() {
        var r;
        const t = this.$store.get().provider;
        if (t && t && this.$providerMap[t]) try {
            return await ((r = this.$providerMap[t]) == null ? void 0 : r.getPublicKey());
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : n;
        }
    }
    async getBalance() {
        const t = this.$store.get().provider;
        if (t && t && this.$providerMap[t]) try {
            const r = await this.$providerMap[t].getBalance();
            return this.$store.setKey("balance", BigInt(r)), r;
        } catch (r) {
            throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : r;
        }
    }
    async getMetaBalances(t) {
        const r = this.$store.get().provider;
        if (r && r && this.$providerMap[r]) try {
            if (!t) throw new Error("No protocol provided");
            return await this.$providerMap[r].getMetaBalances(t);
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : n;
        }
    }
    async getInscriptions(t, r) {
        var i;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.getInscriptions(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
        }
    }
    async sendInscriptions(t, r) {
        var i;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.sendInscriptions(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
        }
    }
}
;
}),
];

//# sourceMappingURL=node_modules_%40omnisat_lasereyes-core_dist_index_70036980.js.map