module.exports = [
"[project]/node_modules/@omnisat/lasereyes-core/dist/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ALKANES",
    ()=>Rk,
    "APPLICATION_ATOM_XML",
    ()=>Wve,
    "APPLICATION_FORM_URLENCODED",
    ()=>Vve,
    "APPLICATION_GZIP",
    ()=>Hve,
    "APPLICATION_JAVASCRIPT",
    ()=>Dve,
    "APPLICATION_JSON",
    ()=>Lve,
    "APPLICATION_OCTET_STREAM",
    ()=>Gve,
    "APPLICATION_PDF",
    ()=>zve,
    "APPLICATION_RSS_XML",
    ()=>Kve,
    "APPLICATION_XHTML_XML",
    ()=>qve,
    "APPLICATION_XML",
    ()=>Fve,
    "APPLICATION_ZIP",
    ()=>jve,
    "AUDIO_MP3",
    ()=>i2e,
    "AUDIO_OGG",
    ()=>s2e,
    "AUDIO_WAV",
    ()=>o2e,
    "BIP322",
    ()=>Xb,
    "BIP322_SIMPLE",
    ()=>l0,
    "BRC20",
    ()=>Nk,
    "BTC",
    ()=>Pk,
    "BaseNetwork",
    ()=>dt,
    "CmdruidNetwork",
    ()=>Qc,
    "DataSourceManager",
    ()=>nc,
    "ECDSA",
    ()=>f0,
    "FRACTAL_MAINNET",
    ()=>yc,
    "FRACTAL_TESTNET",
    ()=>co,
    "FractalNetwork",
    ()=>ME,
    "IMAGE_GIF",
    ()=>Xve,
    "IMAGE_ICON",
    ()=>e2e,
    "IMAGE_JPEG",
    ()=>Zve,
    "IMAGE_PNG",
    ()=>Yve,
    "IMAGE_SVG_XML",
    ()=>Jve,
    "IMAGE_WEBP",
    ()=>Qve,
    "KEPLR",
    ()=>Rl,
    "KeplrChain",
    ()=>cu,
    "LEATHER",
    ()=>Rh,
    "LOCAL_STORAGE_DEFAULT_WALLET",
    ()=>ev,
    "LaserEyesClient",
    ()=>u_e,
    "LeatherNetwork",
    ()=>Hl,
    "MAGIC_EDEN",
    ()=>ru,
    "MAINNET",
    ()=>ln,
    "MULTIPART_FORM_DATA",
    ()=>a2e,
    "MaestroDataSource",
    ()=>Yre,
    "MempoolSpaceDataSource",
    ()=>Xre,
    "OKX",
    ()=>Ch,
    "OP_NET",
    ()=>Nl,
    "ORANGE",
    ()=>Qu,
    "OYL",
    ()=>Il,
    "OYLNET",
    ()=>uP,
    "OkxNetwork",
    ()=>RE,
    "OpNetwork",
    ()=>EG,
    "OrangeNetwork",
    ()=>eu,
    "P2PKH",
    ()=>uG,
    "P2PSH",
    ()=>tve,
    "P2SH",
    ()=>Xp,
    "P2SH_P2WPKH",
    ()=>fG,
    "P2TR",
    ()=>df,
    "P2WPKH",
    ()=>Ay,
    "P2WSH",
    ()=>lG,
    "PHANTOM",
    ()=>Pl,
    "REGTEST",
    ()=>lve,
    "RUNES",
    ()=>Mk,
    "SIGNET",
    ()=>Ro,
    "SPARROW",
    ()=>Ml,
    "SUPPORTED_WALLETS",
    ()=>rve,
    "SandshrewDataSource",
    ()=>qae,
    "TESTNET",
    ()=>Ni,
    "TESTNET4",
    ()=>ao,
    "TEXT_CSS",
    ()=>Cve,
    "TEXT_HTML",
    ()=>Rve,
    "TEXT_JAVASCRIPT",
    ()=>Uve,
    "TEXT_MARKDOWN",
    ()=>$ve,
    "TEXT_PLAIN",
    ()=>Kre,
    "TOKEO",
    ()=>$h,
    "UNISAT",
    ()=>Bl,
    "UNSUPPORTED_PROVIDER_METHOD_ERROR",
    ()=>gB,
    "UnisatNetwork",
    ()=>ro,
    "VIDEO_MP4",
    ()=>t2e,
    "VIDEO_OGG",
    ()=>n2e,
    "VIDEO_WEBM",
    ()=>r2e,
    "WALLET_NOT_INSTALLED_ERROR",
    ()=>fme,
    "WIZZ",
    ()=>Uh,
    "WalletProvider",
    ()=>Do,
    "WizzNetwork",
    ()=>ko,
    "XVERSE",
    ()=>Ol,
    "XverseNetwork",
    ()=>Yu,
    "createConfig",
    ()=>c_e,
    "createStores",
    ()=>a_e,
    "getCmDruidNetwork",
    ()=>VQ,
    "getKeplrChainFromNetwork",
    ()=>WQ,
    "getLeatherNetwork",
    ()=>dve,
    "getNetworkForLeather",
    ()=>pve,
    "getNetworkForOkx",
    ()=>ZQ,
    "getNetworkForUnisat",
    ()=>om,
    "getNetworkForWizz",
    ()=>fk,
    "getNetworkForXverse",
    ()=>p_,
    "getNetworkFromKeplrChain",
    ()=>GQ,
    "getOrangeNetwork",
    ()=>h_,
    "getSatsConnectNetwork",
    ()=>d_,
    "getUnisatNetwork",
    ()=>fP,
    "getWizzNetwork",
    ()=>hve
]);
var RH = Object.defineProperty;
var CH = (e, t, r)=>t in e ? RH(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r;
var pt = (e, t, r)=>CH(e, typeof t != "symbol" ? t + "" : t, r);
function UH(e, t) {
    for(var r = 0; r < t.length; r++){
        const n = t[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for(const i in n)if (i !== "default" && !(i in e)) {
                const o = Object.getOwnPropertyDescriptor(n, i);
                o && Object.defineProperty(e, i, o.get ? o : {
                    enumerable: !0,
                    get: ()=>n[i]
                });
            }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }));
}
const zs = {
    /**
   * The message prefix used for signing Bitcoin messages.
   */ messagePrefix: `Bitcoin Signed Message:
`,
    /**
   * The Bech32 prefix used for Bitcoin addresses.
   */ bech32: "bc",
    /**
   * The BIP32 key prefixes for Bitcoin.
   */ bip32: {
        /**
     * The public key prefix for BIP32 extended public keys.
     */ public: 76067358,
        /**
     * The private key prefix for BIP32 extended private keys.
     */ private: 76066276
    },
    /**
   * The prefix for Bitcoin public key hashes.
   */ pubKeyHash: 0,
    /**
   * The prefix for Bitcoin script hashes.
   */ scriptHash: 5,
    /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */ wif: 128
}, $H = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
        public: 70617039,
        private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
};
function LH(e) {
    if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
    const t = e[3];
    if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
    const r = e[5 + t];
    return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function DH(e) {
    if (e.length < 8) throw new Error("DER sequence length is too short");
    if (e.length > 72) throw new Error("DER sequence length is too long");
    if (e[0] !== 48) throw new Error("Expected DER sequence");
    if (e[1] !== e.length - 2) throw new Error("DER sequence length is invalid");
    if (e[2] !== 2) throw new Error("Expected DER integer");
    const t = e[3];
    if (t === 0) throw new Error("R length is zero");
    if (5 + t >= e.length) throw new Error("R length is too long");
    if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
    const r = e[5 + t];
    if (r === 0) throw new Error("S length is zero");
    if (6 + t + r !== e.length) throw new Error("S length is invalid");
    if (e[4] & 128) throw new Error("R value is negative");
    if (t > 1 && e[4] === 0 && !(e[5] & 128)) throw new Error("R value excessively padded");
    if (e[t + 6] & 128) throw new Error("S value is negative");
    if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) throw new Error("S value excessively padded");
    return {
        r: e.slice(4, 4 + t),
        s: e.slice(6 + t)
    };
}
function FH(e, t) {
    const r = e.length, n = t.length;
    if (r === 0) throw new Error("R length is zero");
    if (n === 0) throw new Error("S length is zero");
    if (r > 33) throw new Error("R length is too long");
    if (n > 33) throw new Error("S length is too long");
    if (e[0] & 128) throw new Error("R value is negative");
    if (t[0] & 128) throw new Error("S value is negative");
    if (r > 1 && e[0] === 0 && !(e[1] & 128)) throw new Error("R value excessively padded");
    if (n > 1 && t[0] === 0 && !(t[1] & 128)) throw new Error("S value excessively padded");
    const i = new Uint8Array(6 + r + n);
    return i[0] = 48, i[1] = i.length - 2, i[2] = 2, i[3] = e.length, i.set(e, 4), i[4 + r] = 2, i[5 + r] = t.length, i.set(t, 6 + r), i;
}
const Kr = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
}, MB = {};
for (const e of Object.keys(Kr)){
    const t = Kr[e];
    MB[t] = e;
}
const Hy = "0123456789abcdefABCDEF", qy = Hy.split("").map((e)=>e.codePointAt(0)), Ky = Array(256).fill(!0).map((e, t)=>{
    const r = String.fromCodePoint(t), n = Hy.indexOf(r);
    return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), RB = new TextEncoder(), CB = new TextDecoder();
function zH(e) {
    return CB.decode(e);
}
function jH(e) {
    return RB.encode(e);
}
function kn(e) {
    const t = e.reduce((i, o)=>i + o.length, 0), r = new Uint8Array(t);
    let n = 0;
    for (const i of e)r.set(i, n), n += i.length;
    return r;
}
function rr(e) {
    const t = e || new Uint8Array();
    return t.length > 512 ? qH(t) : HH(t);
}
function HH(e) {
    let t = "";
    for(let r = 0; r < e.length; ++r)t += Hy[Ky[qy[e[r] >> 4]]], t += Hy[Ky[qy[e[r] & 15]]];
    return t;
}
function qH(e) {
    const t = new Uint8Array(e.length * 2);
    for(let r = 0; r < e.length; ++r)t[r * 2] = qy[e[r] >> 4], t[r * 2 + 1] = qy[e[r] & 15];
    return CB.decode(t);
}
function hc(e) {
    const t = RB.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
    let n;
    for(n = 0; n < r.length; n++){
        const i = Ky[t[n * 2]], o = Ky[t[n * 2 + 1]];
        if (i === void 0 || o === void 0) break;
        r[n] = i << 4 | o;
    }
    return n === r.length ? r : r.slice(0, n);
}
function KH(e) {
    return btoa(String.fromCharCode(...e));
}
function UB(e) {
    const t = atob(e), r = new Uint8Array(t.length);
    for(let n = 0; n < t.length; n++)r[n] = t.charCodeAt(n);
    return r;
}
function It(e, t) {
    const r = Math.min(e.length, t.length);
    for(let n = 0; n < r; ++n)if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
    return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function Po(e, t, r) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 255) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
    return e[t] = r, t + 1;
}
function WH(e, t, r, n) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 65535) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
    return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Wp(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 4294967295) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
    return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function VH(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 0xffffffffffffffffn) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
    return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function sc(e, t) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    return e[t];
}
function GH(e, t, r) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
    }
}
function wd(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
    }
}
function $B(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 2147483647 || r < -2147483648) throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
    return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function LB(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n) throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
    return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function ZH(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
        return e[t + 3] <= 127 ? n : n - 4294967296;
    } else {
        const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
        return e[t] <= 127 ? n : n - 4294967296;
    }
}
function DB(e, t, r) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    r = r.toUpperCase();
    let n = 0n;
    if (r === "LE") return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
    {
        let i = 0n;
        return i = (i << 8n) + BigInt(e[t]), i = (i << 8n) + BigInt(e[t + 1]), i = (i << 8n) + BigInt(e[t + 2]), i = (i << 8n) + BigInt(e[t + 3]), i = (i << 8n) + BigInt(e[t + 4]), i = (i << 8n) + BigInt(e[t + 5]), i = (i << 8n) + BigInt(e[t + 6]), i = (i << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i : i - 0x10000000000000000n;
    }
}
function FB(e) {
    return e < Kr.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function YH(e, t, r) {
    const n = FB(t);
    return n === 1 ? Po(e, r, t) : n === 2 ? (Po(e, r, Kr.OP_PUSHDATA1), Po(e, r + 1, t)) : n === 3 ? (Po(e, r, Kr.OP_PUSHDATA2), WH(e, r + 1, t, "LE")) : (Po(e, r, Kr.OP_PUSHDATA4), Wp(e, r + 1, t, "LE")), n;
}
function XH(e, t) {
    const r = sc(e, t);
    let n, i;
    if (r < Kr.OP_PUSHDATA1) n = r, i = 1;
    else if (r === Kr.OP_PUSHDATA1) {
        if (t + 2 > e.length) return null;
        n = sc(e, t + 1), i = 2;
    } else if (r === Kr.OP_PUSHDATA2) {
        if (t + 3 > e.length) return null;
        n = GH(e, t + 1, "LE"), i = 3;
    } else {
        if (t + 5 > e.length) return null;
        if (r !== Kr.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        n = wd(e, t + 1, "LE"), i = 5;
    }
    return {
        opcode: r,
        number: n,
        size: i
    };
}
function JH(e) {
    return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function QH(e) {
    let t = Math.abs(e);
    const r = JH(t), n = new Uint8Array(r), i = e < 0;
    for(let o = 0; o < r; ++o)Po(n, o, t & 255), t >>= 8;
    return n[r - 1] & 128 ? Po(n, r - 1, i ? 128 : 0) : i && (n[r - 1] |= 128), n;
}
var Da;
function eq(e) {
    return {
        lang: (e == null ? void 0 : e.lang) ?? (Da == null ? void 0 : Da.lang),
        message: e == null ? void 0 : e.message,
        abortEarly: (e == null ? void 0 : e.abortEarly) ?? (Da == null ? void 0 : Da.abortEarly),
        abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (Da == null ? void 0 : Da.abortPipeEarly)
    };
}
var Dw;
function tq(e) {
    return Dw == null ? void 0 : Dw.get(e);
}
var Fw;
function rq(e) {
    return Fw == null ? void 0 : Fw.get(e);
}
var zw;
function nq(e, t) {
    var r;
    return (r = zw == null ? void 0 : zw.get(e)) == null ? void 0 : r.get(t);
}
function Qh(e) {
    var r, n;
    const t = typeof e;
    return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function Ci(e, t, r, n, i) {
    const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? Qh(o), u = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: s,
        received: a,
        message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
        // @ts-expect-error
        requirement: e.requirement,
        path: i == null ? void 0 : i.path,
        issues: i == null ? void 0 : i.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, f = e.kind === "schema", c = (i == null ? void 0 : i.message) ?? // @ts-expect-error
    e.message ?? nq(e.reference, u.lang) ?? (f ? rq(u.lang) : null) ?? n.message ?? tq(u.lang);
    c && (u.message = typeof c == "function" ? c(u) : c), f && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [
        u
    ];
}
function iq(e, t) {
    const r = [
        ...new Set(e)
    ];
    return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var oq = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(r){
        super(r[0].message);
        /**
     * The error issues.
     */ pt(this, "issues");
        this.name = "ValiError", this.issues = r;
    }
};
function zB(e, t) {
    return {
        kind: "validation",
        type: "every_item",
        reference: zB,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !r.value.every(this.requirement) && Ci(this, "item", r, n), r;
        }
    };
}
function Zx(e) {
    return {
        kind: "validation",
        type: "integer",
        reference: Zx,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run (t, r) {
            return t.typed && !this.requirement(t.value) && Ci(this, "integer", t, r), t;
        }
    };
}
function jB(e, t) {
    return {
        kind: "validation",
        type: "length",
        reference: jB,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length !== this.requirement && Ci(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function nb(e, t) {
    return {
        kind: "validation",
        type: "max_value",
        reference: nb,
        async: !1,
        expects: `<=${e instanceof Date ? e.toJSON() : Qh(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value > this.requirement && Ci(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : Qh(r.value)
            }), r;
        }
    };
}
function ib(e, t) {
    return {
        kind: "validation",
        type: "min_value",
        reference: ib,
        async: !1,
        expects: `>=${e instanceof Date ? e.toJSON() : Qh(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value < this.requirement && Ci(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : Qh(r.value)
            }), r;
        }
    };
}
function HB(e, t) {
    return {
        kind: "validation",
        type: "regex",
        reference: HB,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement.test(r.value) && Ci(this, "format", r, n), r;
        }
    };
}
function Yx(e, t, r) {
    return typeof e.default == "function" ? // @ts-expect-error
    e.default(t, r) : // @ts-expect-error
    e.default;
}
function ob(e, t) {
    return !e._run({
        typed: !1,
        value: t
    }, {
        abortEarly: !0
    }).issues;
}
function qB() {
    return {
        kind: "schema",
        type: "any",
        reference: qB,
        expects: "any",
        async: !1,
        _run (e) {
            return e.typed = !0, e;
        }
    };
}
function lo(e, t) {
    return {
        kind: "schema",
        type: "array",
        reference: lo,
        expects: "Array",
        async: !1,
        item: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (Array.isArray(i)) {
                r.typed = !0, r.value = [];
                for(let s = 0; s < i.length; s++){
                    const a = i[s], u = this.item._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "array",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), r.value.push(u.value);
                }
            } else Ci(this, "type", r, n);
            return r;
        }
    };
}
function KB(e) {
    return {
        kind: "schema",
        type: "bigint",
        reference: KB,
        expects: "bigint",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "bigint" ? t.typed = !0 : Ci(this, "type", t, r), t;
        }
    };
}
function Ls(e, t) {
    return {
        kind: "schema",
        type: "custom",
        reference: Ls,
        expects: "unknown",
        async: !1,
        check: e,
        message: t,
        _run (r, n) {
            return this.check(r.value) ? r.typed = !0 : Ci(this, "type", r, n), r;
        }
    };
}
function sb(e, t) {
    return {
        kind: "schema",
        type: "instance",
        reference: sb,
        expects: e.name,
        async: !1,
        class: e,
        message: t,
        _run (r, n) {
            return r.value instanceof this.class ? r.typed = !0 : Ci(this, "type", r, n), r;
        }
    };
}
function vE(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullable",
        reference: vE,
        expects: `(${e.expects} | null)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return n.value === null && ("default" in this && (n.value = Yx(this, n, i)), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function WB(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullish",
        reference: WB,
        expects: `(${e.expects} | null | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return (n.value === null || n.value === void 0) && ("default" in this && (n.value = Yx(this, n, i)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function oo(e) {
    return {
        kind: "schema",
        type: "number",
        reference: oo,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Ci(this, "type", t, r), t;
        }
    };
}
function jn(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: jn,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
            } else Ci(this, "type", r, n);
            return r;
        }
    };
}
function Wy(e, ...t) {
    const r = {
        kind: "schema",
        type: "optional",
        reference: Wy,
        expects: `(${e.expects} | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return n.value === void 0 && ("default" in this && (n.value = Yx(this, n, i)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function Pf(e) {
    return {
        kind: "schema",
        type: "string",
        reference: Pf,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : Ci(this, "type", t, r), t;
        }
    };
}
function ca(e, t) {
    return {
        kind: "schema",
        type: "tuple",
        reference: ca,
        expects: "Array",
        async: !1,
        items: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (Array.isArray(i)) {
                r.typed = !0, r.value = [];
                for(let s = 0; s < this.items.length; s++){
                    const a = i[s], u = this.items[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "array",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), r.value.push(u.value);
                }
            } else Ci(this, "type", r, n);
            return r;
        }
    };
}
function I4(e) {
    let t;
    if (e) for (const r of e)t ? t.push(...r.issues) : t = r.issues;
    return t;
}
function Xx(e, t) {
    return {
        kind: "schema",
        type: "union",
        reference: Xx,
        expects: iq(e.map((r)=>r.expects), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            let i, o, s;
            for (const a of this.options){
                const u = a._run({
                    typed: !1,
                    value: r.value
                }, n);
                if (u.typed) if (u.issues) o ? o.push(u) : o = [
                    u
                ];
                else {
                    i = u;
                    break;
                }
                else s ? s.push(u) : s = [
                    u
                ];
            }
            if (i) return i;
            if (o) {
                if (o.length === 1) return o[0];
                Ci(this, "type", r, n, {
                    issues: I4(o)
                }), r.typed = !0;
            } else {
                if ((s == null ? void 0 : s.length) === 1) return s[0];
                Ci(this, "type", r, n, {
                    issues: I4(s)
                });
            }
            return r;
        }
    };
}
function En(e, t, r) {
    const n = e._run({
        typed: !1,
        value: t
    }, eq(r));
    if (n.issues) throw new oq(n.issues);
    return n.value;
}
function du(e, t) {
    const r = {};
    for(const n in e.entries)r[n] = Wy(e.entries[n]);
    return {
        ...e,
        entries: r
    };
}
function vd(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
const B4 = new Uint8Array(32), O4 = hc("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Yn = (e)=>vd(sb(Uint8Array), jB(e));
function ep(e, t) {
    return e.length !== t.length ? !1 : e.every((r, n)=>It(r, t[n]) === 0);
}
function Ms(e) {
    if (!(e instanceof Uint8Array) || e.length < 33) return !1;
    const t = e[0], r = e.slice(1, 33);
    if (It(B4, r) === 0 || It(r, O4) >= 0) return !1;
    if ((t === 2 || t === 3) && e.length === 33) return !0;
    const n = e.slice(33);
    return It(B4, n) === 0 || It(n, O4) >= 0 ? !1 : t === 4 && e.length === 65;
}
const xy = 254;
function Jx(e) {
    return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? !1 : e.version !== void 0 ? (e.version & xy) === e.version : !0;
}
function VB(e) {
    return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t)=>VB(t)) : Jx(e);
}
const sq = Yn(32), aq = Yn(20), P4 = Yn(32), tn = sb(Uint8Array);
vd(Pf(), HB(/^([0-9a-f]{2})+$/i));
const cq = vd(oo(), Zx(), ib(0), nb(255)), Za = vd(oo(), Zx(), ib(0), nb(4294967295)), jw = vd(KB(), ib(0n), nb(0x7fffffffffffffffn)), N4 = (e)=>jn(Object.entries(e).reduce((t, r)=>({
            ...t,
            [r[0]]: WB(r[1])
        }), {})), M4 = new Uint8Array(1);
function R4(e) {
    let t = 0;
    for(; e[t] === 0;)++t;
    return t === e.length ? M4 : (e = e.slice(t), e[0] & 128 ? kn([
        M4,
        e
    ]) : e);
}
function C4(e) {
    e[0] === 0 && (e = e.slice(1));
    const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
    return t.set(e, r), t;
}
function uq(e) {
    const t = sc(e, e.length - 1);
    if (!e3(t)) throw new Error("Invalid hashType " + t);
    const r = DH(e.subarray(0, -1)), n = C4(r.r), i = C4(r.s);
    return {
        signature: kn([
            n,
            i
        ]),
        hashType: t
    };
}
function fq(e, t) {
    if (En(jn({
        signature: Yn(64),
        hashType: cq
    }), {
        signature: e,
        hashType: t
    }), !e3(t)) throw new Error("Invalid hashType " + t);
    const r = new Uint8Array(1);
    Po(r, 0, t);
    const n = R4(e.slice(0, 32)), i = R4(e.slice(32, 64));
    return kn([
        FH(n, i),
        r
    ]);
}
const lq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    decode: uq,
    encode: fq
}, Symbol.toStringTag, {
    value: "Module"
})), GB = Kr.OP_RESERVED, ZB = lo(Xx([
    sb(Uint8Array),
    oo()
]));
function dq(e) {
    return ob(oo(), e) && (e === Kr.OP_0 || e >= Kr.OP_1 && e <= Kr.OP_16 || e === Kr.OP_1NEGATE);
}
function YB(e) {
    return ob(tn, e) || dq(e);
}
function Qx(e) {
    return ob(vd(qB(), zB(YB)), e);
}
function XB(e) {
    return e.length - e.filter(YB).length;
}
function Vy(e) {
    if (e.length === 0) return Kr.OP_0;
    if (e.length === 1) {
        if (e[0] >= 1 && e[0] <= 16) return GB + e[0];
        if (e[0] === 129) return Kr.OP_1NEGATE;
    }
}
function JB(e) {
    return e instanceof Uint8Array;
}
function hq(e) {
    return ob(ZB, e);
}
function Gy(e) {
    return e instanceof Uint8Array;
}
function Ri(e) {
    if (JB(e)) return e;
    En(ZB, e);
    const t = e.reduce((i, o)=>Gy(o) ? o.length === 1 && Vy(o) !== void 0 ? i + 1 : i + FB(o.length) + o.length : i + 1, 0), r = new Uint8Array(t);
    let n = 0;
    if (e.forEach((i)=>{
        if (Gy(i)) {
            const o = Vy(i);
            if (o !== void 0) {
                Po(r, n, o), n += 1;
                return;
            }
            n += YH(r, i.length, n), r.set(i, n), n += i.length;
        } else Po(r, n, i), n += 1;
    }), n !== r.length) throw new Error("Could not decode chunks");
    return r;
}
function Sn(e) {
    if (hq(e)) return e;
    En(tn, e);
    const t = [];
    let r = 0;
    for(; r < e.length;){
        const n = e[r];
        if (n > Kr.OP_0 && n <= Kr.OP_PUSHDATA4) {
            const i = XH(e, r);
            if (i === null || (r += i.size, r + i.number > e.length)) return null;
            const o = e.slice(r, r + i.number);
            r += i.number;
            const s = Vy(o);
            s !== void 0 ? t.push(s) : t.push(o);
        } else t.push(n), r += 1;
    }
    return t;
}
function pq(e) {
    if (JB(e) && (e = Sn(e)), !e) throw new Error("Could not convert invalid chunks to ASM");
    return e.map((t)=>{
        if (Gy(t)) {
            const r = Vy(t);
            if (r === void 0) return rr(t);
            t = r;
        }
        return MB[t];
    }).join(" ");
}
function gq(e) {
    return e = Sn(e), En(Ls(Qx), e), e.map((t)=>Gy(t) ? t : t === Kr.OP_0 ? new Uint8Array(0) : QH(t - GB));
}
function yq(e) {
    return Ms(e);
}
function e3(e) {
    const t = e & -129;
    return t > 0 && t < 4;
}
function ac(e) {
    return !(e instanceof Uint8Array) || !e3(e[e.length - 1]) ? !1 : LH(e.slice(0, -1));
}
const Nh = lq;
function Zt(e, t, r) {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !0,
        get () {
            const n = r.call(this);
            return this[t] = n, n;
        },
        set (n) {
            Object.defineProperty(this, t, {
                configurable: !0,
                enumerable: !0,
                value: n,
                writable: !0
            });
        }
    });
}
function fs(e) {
    let t;
    return ()=>(t !== void 0 || (t = e()), t);
}
const El = Kr, vg = El.OP_RESERVED;
function ab(e, t) {
    if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {});
    function r(u) {
        return ac(u) || (t.allowIncomplete && u === El.OP_0) !== void 0;
    }
    En(du(jn({
        network: jn({}),
        m: oo(),
        n: oo(),
        output: tn,
        pubkeys: lo(Ls(Ms), "Received invalid pubkey"),
        signatures: lo(Ls(r), "Expected signature to be of type isAcceptableSignature"),
        input: tn
    })), e);
    const i = {
        network: e.network || zs
    };
    let o = [], s = !1;
    function a(u) {
        s || (s = !0, o = Sn(u), i.m = o[0] - vg, i.n = o[o.length - 2] - vg, i.pubkeys = o.slice(1, -2));
    }
    if (Zt(i, "output", ()=>{
        if (e.m && i.n && e.pubkeys) return Ri([].concat(vg + e.m, e.pubkeys, vg + i.n, El.OP_CHECKMULTISIG));
    }), Zt(i, "m", ()=>{
        if (i.output) return a(i.output), i.m;
    }), Zt(i, "n", ()=>{
        if (i.pubkeys) return i.pubkeys.length;
    }), Zt(i, "pubkeys", ()=>{
        if (e.output) return a(e.output), i.pubkeys;
    }), Zt(i, "signatures", ()=>{
        if (e.input) return Sn(e.input).slice(1);
    }), Zt(i, "input", ()=>{
        if (e.signatures) return Ri([
            El.OP_0
        ].concat(e.signatures));
    }), Zt(i, "witness", ()=>{
        if (i.input) return [];
    }), Zt(i, "name", ()=>{
        if (!(!i.m || !i.n)) return `p2ms(${i.m} of ${i.n})`;
    }), t.validate) {
        if (e.output) {
            if (a(e.output), En(oo(), o[0], {
                message: "Output is invalid"
            }), En(oo(), o[o.length - 2], {
                message: "Output is invalid"
            }), o[o.length - 1] !== El.OP_CHECKMULTISIG) throw new TypeError("Output is invalid");
            if (i.m <= 0 || i.n > 16 || i.m > i.n || i.n !== o.length - 3) throw new TypeError("Output is invalid");
            if (!i.pubkeys.every((u)=>Ms(u))) throw new TypeError("Output is invalid");
            if (e.m !== void 0 && e.m !== i.m) throw new TypeError("m mismatch");
            if (e.n !== void 0 && e.n !== i.n) throw new TypeError("n mismatch");
            if (e.pubkeys && !ep(e.pubkeys, i.pubkeys)) throw new TypeError("Pubkeys mismatch");
        }
        if (e.pubkeys) {
            if (e.n !== void 0 && e.n !== e.pubkeys.length) throw new TypeError("Pubkey count mismatch");
            if (i.n = e.pubkeys.length, i.n < i.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (e.signatures) {
            if (e.signatures.length < i.m) throw new TypeError("Not enough signatures provided");
            if (e.signatures.length > i.m) throw new TypeError("Too many signatures provided");
        }
        if (e.input) {
            if (e.input[0] !== El.OP_0) throw new TypeError("Input is invalid");
            if (i.signatures.length === 0 || !i.signatures.every(r)) throw new TypeError("Input has invalid signature(s)");
            if (e.signatures && !ep(e.signatures, i.signatures)) throw new TypeError("Signature mismatch");
            if (e.m !== void 0 && e.m !== e.signatures.length) throw new TypeError("Signature count mismatch");
        }
    }
    return Object.assign(i, e);
}
const U4 = Kr;
function QB(e, t) {
    if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        network: jn({}),
        output: tn,
        pubkey: Ls(Ms, "invalid pubkey"),
        signature: Ls(ac, "Expected signature to be of type isCanonicalScriptSignature"),
        input: tn
    })), e);
    const r = fs(()=>Sn(e.input)), i = {
        name: "p2pk",
        network: e.network || zs
    };
    if (Zt(i, "output", ()=>{
        if (e.pubkey) return Ri([
            e.pubkey,
            U4.OP_CHECKSIG
        ]);
    }), Zt(i, "pubkey", ()=>{
        if (e.output) return e.output.slice(1, -1);
    }), Zt(i, "signature", ()=>{
        if (e.input) return r()[0];
    }), Zt(i, "input", ()=>{
        if (e.signature) return Ri([
            e.signature
        ]);
    }), Zt(i, "witness", ()=>{
        if (i.input) return [];
    }), t.validate) {
        if (e.output) {
            if (e.output[e.output.length - 1] !== U4.OP_CHECKSIG) throw new TypeError("Output is invalid");
            if (!Ms(i.pubkey)) throw new TypeError("Output pubkey is invalid");
            if (e.pubkey && It(e.pubkey, i.pubkey) !== 0) throw new TypeError("Pubkey mismatch");
        }
        if (e.signature && e.input && It(e.input, i.input) !== 0) throw new TypeError("Signature mismatch");
        if (e.input) {
            if (r().length !== 1) throw new TypeError("Input is invalid");
            if (!ac(i.signature)) throw new TypeError("Input has invalid signature");
        }
    }
    return Object.assign(i, e);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function mq(e) {
    return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function $4(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function cb(e, ...t) {
    if (!mq(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function bq(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    $4(e.outputLen), $4(e.blockLen);
}
function Zy(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function wq(e, t) {
    cb(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error("digestInto() expects output buffer of length at least " + r);
}
function hu(...e) {
    for(let t = 0; t < e.length; t++)e[t].fill(0);
}
function Hw(e) {
    return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function Vs(e, t) {
    return e << 32 - t | e >>> t;
}
function _g(e, t) {
    return e << t | e >>> 32 - t >>> 0;
}
function vq(e) {
    if (typeof e != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(e));
}
function t3(e) {
    return typeof e == "string" && (e = vq(e)), cb(e), e;
}
let e7 = class {
};
function r3(e) {
    const t = (n)=>e().update(t3(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function _q(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
function Eq(e, t, r) {
    return e & t ^ ~e & r;
}
function xq(e, t, r) {
    return e & t ^ e & r ^ t & r;
}
let n3 = class extends e7 {
    constructor(t, r, n, i){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Hw(this.buffer);
    }
    update(t) {
        Zy(this), t = t3(t), cb(t);
        const { view: r, buffer: n, blockLen: i } = this, o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = Hw(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        Zy(this), wq(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, hu(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        _q(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = Hw(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.destroyed = s, t.finished = o, t.length = i, t.pos = a, i % r && t.buffer.set(n), t;
    }
    clone() {
        return this._cloneInto();
    }
};
const Ic = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Ei = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]), Sq = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), t7 = Uint8Array.from(new Array(16).fill(0).map((e, t)=>t)), Aq = t7.map((e)=>(9 * e + 5) % 16), r7 = /* @__PURE__ */ (()=>{
    const r = [
        [
            t7
        ],
        [
            Aq
        ]
    ];
    for(let n = 0; n < 4; n++)for (let i of r)i.push(i[n].map((o)=>Sq[o]));
    return r;
})(), n7 = r7[0], i7 = r7[1], o7 = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>Uint8Array.from(e)), Tq = /* @__PURE__ */ n7.map((e, t)=>e.map((r)=>o7[t][r])), kq = /* @__PURE__ */ i7.map((e, t)=>e.map((r)=>o7[t][r])), Iq = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), Bq = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]);
function L4(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const Eg = /* @__PURE__ */ new Uint32Array(16);
let Oq = class extends n3 {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)Eg[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, u = a, f = this.h3 | 0, c = f, l = this.h4 | 0, p = l;
        for(let y = 0; y < 5; y++){
            const _ = 4 - y, A = Iq[y], O = Bq[y], N = n7[y], U = i7[y], D = Tq[y], H = kq[y];
            for(let K = 0; K < 16; K++){
                const re = _g(n + L4(y, o, a, f) + Eg[N[K]] + A, D[K]) + l | 0;
                n = l, l = f, f = _g(a, 10) | 0, a = o, o = re;
            }
            for(let K = 0; K < 16; K++){
                const re = _g(i + L4(_, s, u, c) + Eg[U[K]] + O, H[K]) + p | 0;
                i = p, p = c, c = _g(u, 10) | 0, u = s, s = re;
            }
        }
        this.set(this.h1 + a + c | 0, this.h2 + f + p | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + u | 0);
    }
    roundClean() {
        hu(Eg);
    }
    destroy() {
        this.destroyed = !0, hu(this.buffer), this.set(0, 0, 0, 0, 0);
    }
};
const Pq = /* @__PURE__ */ r3(()=>new Oq()), s7 = Pq, xg = /* @__PURE__ */ BigInt(2 ** 32 - 1), D4 = /* @__PURE__ */ BigInt(32);
function Nq(e, t = !1) {
    return t ? {
        h: Number(e & xg),
        l: Number(e >> D4 & xg)
    } : {
        h: Number(e >> D4 & xg) | 0,
        l: Number(e & xg) | 0
    };
}
function Mq(e, t = !1) {
    const r = e.length;
    let n = new Uint32Array(r), i = new Uint32Array(r);
    for(let o = 0; o < r; o++){
        const { h: s, l: a } = Nq(e[o], t);
        [n[o], i[o]] = [
            s,
            a
        ];
    }
    return [
        n,
        i
    ];
}
const F4 = (e, t, r)=>e >>> r, z4 = (e, t, r)=>e << 32 - r | t >>> r, al = (e, t, r)=>e >>> r | t << 32 - r, cl = (e, t, r)=>e << 32 - r | t >>> r, Sg = (e, t, r)=>e << 64 - r | t >>> r - 32, Ag = (e, t, r)=>e >>> r - 32 | t << 64 - r;
function Fa(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    };
}
const Rq = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0), Cq = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0, Uq = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), $q = (e, t, r, n, i)=>t + r + n + i + (e / 2 ** 32 | 0) | 0, Lq = (e, t, r, n, i)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Dq = (e, t, r, n, i, o)=>t + r + n + i + o + (e / 2 ** 32 | 0) | 0, Fq = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Bc = /* @__PURE__ */ new Uint32Array(64);
let zq = class extends n3 {
    constructor(t = 32){
        super(64, t, 8, !1), this.A = Ic[0] | 0, this.B = Ic[1] | 0, this.C = Ic[2] | 0, this.D = Ic[3] | 0, this.E = Ic[4] | 0, this.F = Ic[5] | 0, this.G = Ic[6] | 0, this.H = Ic[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Bc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Bc[l - 15], y = Bc[l - 2], _ = Vs(p, 7) ^ Vs(p, 18) ^ p >>> 3, A = Vs(y, 17) ^ Vs(y, 19) ^ y >>> 10;
            Bc[l] = A + Bc[l - 7] + _ + Bc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = Vs(a, 6) ^ Vs(a, 11) ^ Vs(a, 25), y = c + p + Eq(a, u, f) + Fq[l] + Bc[l] | 0, A = (Vs(n, 2) ^ Vs(n, 13) ^ Vs(n, 22)) + xq(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        hu(Bc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), hu(this.buffer);
    }
};
const a7 = Mq([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), jq = a7[0], Hq = a7[1], Oc = /* @__PURE__ */ new Uint32Array(80), Pc = /* @__PURE__ */ new Uint32Array(80);
let qq = class extends n3 {
    constructor(t = 64){
        super(128, t, 16, !1), this.Ah = Ei[0] | 0, this.Al = Ei[1] | 0, this.Bh = Ei[2] | 0, this.Bl = Ei[3] | 0, this.Ch = Ei[4] | 0, this.Cl = Ei[5] | 0, this.Dh = Ei[6] | 0, this.Dl = Ei[7] | 0, this.Eh = Ei[8] | 0, this.El = Ei[9] | 0, this.Fh = Ei[10] | 0, this.Fl = Ei[11] | 0, this.Gh = Ei[12] | 0, this.Gl = Ei[13] | 0, this.Hh = Ei[14] | 0, this.Hl = Ei[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: u, Eh: f, El: c, Fh: l, Fl: p, Gh: y, Gl: _, Hh: A, Hl: O } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u,
            f,
            c,
            l,
            p,
            y,
            _,
            A,
            O
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = f | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = A | 0, this.Hl = O | 0;
    }
    process(t, r) {
        for(let D = 0; D < 16; D++, r += 4)Oc[D] = t.getUint32(r), Pc[D] = t.getUint32(r += 4);
        for(let D = 16; D < 80; D++){
            const H = Oc[D - 15] | 0, K = Pc[D - 15] | 0, re = al(H, K, 1) ^ al(H, K, 8) ^ F4(H, K, 7), Q = cl(H, K, 1) ^ cl(H, K, 8) ^ z4(H, K, 7), G = Oc[D - 2] | 0, R = Pc[D - 2] | 0, X = al(G, R, 19) ^ Sg(G, R, 61) ^ F4(G, R, 6), $ = cl(G, R, 19) ^ Ag(G, R, 61) ^ z4(G, R, 6), S = Uq(Q, $, Pc[D - 7], Pc[D - 16]), w = $q(S, re, X, Oc[D - 7], Oc[D - 16]);
            Oc[D] = w | 0, Pc[D] = S | 0;
        }
        let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: u, Dh: f, Dl: c, Eh: l, El: p, Fh: y, Fl: _, Gh: A, Gl: O, Hh: N, Hl: U } = this;
        for(let D = 0; D < 80; D++){
            const H = al(l, p, 14) ^ al(l, p, 18) ^ Sg(l, p, 41), K = cl(l, p, 14) ^ cl(l, p, 18) ^ Ag(l, p, 41), re = l & y ^ ~l & A, Q = p & _ ^ ~p & O, G = Lq(U, K, Q, Hq[D], Pc[D]), R = Dq(G, N, H, re, jq[D], Oc[D]), X = G | 0, $ = al(n, i, 28) ^ Sg(n, i, 34) ^ Sg(n, i, 39), S = cl(n, i, 28) ^ Ag(n, i, 34) ^ Ag(n, i, 39), w = n & o ^ n & a ^ o & a, g = i & s ^ i & u ^ s & u;
            N = A | 0, U = O | 0, A = y | 0, O = _ | 0, y = l | 0, _ = p | 0, ({ h: l, l: p } = Fa(f | 0, c | 0, R | 0, X | 0)), f = a | 0, c = u | 0, a = o | 0, u = s | 0, o = n | 0, s = i | 0;
            const m = Rq(X, S, g);
            n = Cq(m, R, $, w), i = m | 0;
        }
        ({ h: n, l: i } = Fa(this.Ah | 0, this.Al | 0, n | 0, i | 0)), ({ h: o, l: s } = Fa(this.Bh | 0, this.Bl | 0, o | 0, s | 0)), ({ h: a, l: u } = Fa(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: f, l: c } = Fa(this.Dh | 0, this.Dl | 0, f | 0, c | 0)), ({ h: l, l: p } = Fa(this.Eh | 0, this.El | 0, l | 0, p | 0)), ({ h: y, l: _ } = Fa(this.Fh | 0, this.Fl | 0, y | 0, _ | 0)), ({ h: A, l: O } = Fa(this.Gh | 0, this.Gl | 0, A | 0, O | 0)), ({ h: N, l: U } = Fa(this.Hh | 0, this.Hl | 0, N | 0, U | 0)), this.set(n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U);
    }
    roundClean() {
        hu(Oc, Pc);
    }
    destroy() {
        hu(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
const Kq = /* @__PURE__ */ r3(()=>new zq()), Wq = /* @__PURE__ */ r3(()=>new qq()), pi = Kq;
function Rs(e) {
    return s7(pi(e));
}
function ju(e) {
    return pi(pi(e));
}
const Vq = {
    "BIP0340/challenge": Uint8Array.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
    ]),
    "BIP0340/aux": Uint8Array.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
    ]),
    "BIP0340/nonce": Uint8Array.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
    ]),
    TapLeaf: Uint8Array.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
    ]),
    TapBranch: Uint8Array.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
    ]),
    TapSighash: Uint8Array.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
    ]),
    TapTweak: Uint8Array.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
    ]),
    "KeyAgg list": Uint8Array.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
    ]),
    "KeyAgg coefficient": Uint8Array.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
    ])
};
function ub(e, t) {
    return pi(kn([
        Vq[e],
        t
    ]));
}
function Gq(e) {
    if (e.length >= 255) throw new TypeError("Alphabet too long");
    const t = new Uint8Array(256);
    for(let f = 0; f < t.length; f++)t[f] = 255;
    for(let f = 0; f < e.length; f++){
        const c = e.charAt(f), l = c.charCodeAt(0);
        if (t[l] !== 255) throw new TypeError(c + " is ambiguous");
        t[l] = f;
    }
    const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
    function s(f) {
        if (f instanceof Uint8Array || (ArrayBuffer.isView(f) ? f = new Uint8Array(f.buffer, f.byteOffset, f.byteLength) : Array.isArray(f) && (f = Uint8Array.from(f))), !(f instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (f.length === 0) return "";
        let c = 0, l = 0, p = 0;
        const y = f.length;
        for(; p !== y && f[p] === 0;)p++, c++;
        const _ = (y - p) * o + 1 >>> 0, A = new Uint8Array(_);
        for(; p !== y;){
            let U = f[p], D = 0;
            for(let H = _ - 1; (U !== 0 || D < l) && H !== -1; H--, D++)U += 256 * A[H] >>> 0, A[H] = U % r >>> 0, U = U / r >>> 0;
            if (U !== 0) throw new Error("Non-zero carry");
            l = D, p++;
        }
        let O = _ - l;
        for(; O !== _ && A[O] === 0;)O++;
        let N = n.repeat(c);
        for(; O < _; ++O)N += e.charAt(A[O]);
        return N;
    }
    function a(f) {
        if (typeof f != "string") throw new TypeError("Expected String");
        if (f.length === 0) return new Uint8Array();
        let c = 0, l = 0, p = 0;
        for(; f[c] === n;)l++, c++;
        const y = (f.length - c) * i + 1 >>> 0, _ = new Uint8Array(y);
        for(; c < f.length;){
            const U = f.charCodeAt(c);
            if (U > 255) return;
            let D = t[U];
            if (D === 255) return;
            let H = 0;
            for(let K = y - 1; (D !== 0 || H < p) && K !== -1; K--, H++)D += r * _[K] >>> 0, _[K] = D % 256 >>> 0, D = D / 256 >>> 0;
            if (D !== 0) throw new Error("Non-zero carry");
            p = H, c++;
        }
        let A = y - p;
        for(; A !== y && _[A] === 0;)A++;
        const O = new Uint8Array(l + (y - A));
        let N = l;
        for(; A !== y;)O[N++] = _[A++];
        return O;
    }
    function u(f) {
        const c = a(f);
        if (c) return c;
        throw new Error("Non-base" + r + " character");
    }
    return {
        encode: s,
        decodeUnsafe: a,
        decode: u
    };
}
var Zq = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const qw = Gq(Zq);
function Yq(e) {
    function t(o) {
        var s = Uint8Array.from(o), a = e(s), u = s.length + 4, f = new Uint8Array(u);
        return f.set(s, 0), f.set(a.subarray(0, 4), s.length), qw.encode(f);
    }
    function r(o) {
        var s = o.slice(0, -4), a = o.slice(-4), u = e(s);
        if (!(a[0] ^ u[0] | a[1] ^ u[1] | a[2] ^ u[2] | a[3] ^ u[3])) return s;
    }
    function n(o) {
        var s = qw.decodeUnsafe(o);
        if (s != null) return r(s);
    }
    function i(o) {
        var s = qw.decode(o), a = r(s);
        if (a == null) throw new Error("Invalid checksum");
        return a;
    }
    return {
        encode: t,
        decode: i,
        decodeUnsafe: n
    };
}
function Xq(e) {
    return pi(pi(e));
}
const Ql = Yq(Xq), Nc = Kr;
function Vp(e, t) {
    if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        network: jn({}),
        address: Pf(),
        hash: aq,
        output: Yn(25),
        pubkey: Ls(Ms),
        signature: Ls(ac),
        input: tn
    })), e);
    const r = fs(()=>{
        const s = Ql.decode(e.address), a = sc(s, 0), u = s.slice(1);
        return {
            version: a,
            hash: u
        };
    }), n = fs(()=>Sn(e.input)), i = e.network || zs, o = {
        name: "p2pkh",
        network: i
    };
    if (Zt(o, "address", ()=>{
        if (!o.hash) return;
        const s = new Uint8Array(21);
        return Po(s, 0, i.pubKeyHash), s.set(o.hash, 1), Ql.encode(s);
    }), Zt(o, "hash", ()=>{
        if (e.output) return e.output.slice(3, 23);
        if (e.address) return r().hash;
        if (e.pubkey || o.pubkey) return Rs(e.pubkey || o.pubkey);
    }), Zt(o, "output", ()=>{
        if (o.hash) return Ri([
            Nc.OP_DUP,
            Nc.OP_HASH160,
            o.hash,
            Nc.OP_EQUALVERIFY,
            Nc.OP_CHECKSIG
        ]);
    }), Zt(o, "pubkey", ()=>{
        if (e.input) return n()[1];
    }), Zt(o, "signature", ()=>{
        if (e.input) return n()[0];
    }), Zt(o, "input", ()=>{
        if (e.pubkey && e.signature) return Ri([
            e.signature,
            e.pubkey
        ]);
    }), Zt(o, "witness", ()=>{
        if (o.input) return [];
    }), t.validate) {
        let s = Uint8Array.from([]);
        if (e.address) {
            if (r().version !== i.pubKeyHash) throw new TypeError("Invalid version or Network mismatch");
            if (r().hash.length !== 20) throw new TypeError("Invalid address");
            s = r().hash;
        }
        if (e.hash) {
            if (s.length > 0 && It(s, e.hash) !== 0) throw new TypeError("Hash mismatch");
            s = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 25 || e.output[0] !== Nc.OP_DUP || e.output[1] !== Nc.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== Nc.OP_EQUALVERIFY || e.output[24] !== Nc.OP_CHECKSIG) throw new TypeError("Output is invalid");
            const a = e.output.slice(3, 23);
            if (s.length > 0 && It(s, a) !== 0) throw new TypeError("Hash mismatch");
            s = a;
        }
        if (e.pubkey) {
            const a = Rs(e.pubkey);
            if (s.length > 0 && It(s, a) !== 0) throw new TypeError("Hash mismatch");
            s = a;
        }
        if (e.input) {
            const a = n();
            if (a.length !== 2) throw new TypeError("Input is invalid");
            if (!ac(a[0])) throw new TypeError("Input has invalid signature");
            if (!Ms(a[1])) throw new TypeError("Input has invalid pubkey");
            if (e.signature && It(e.signature, a[0]) !== 0) throw new TypeError("Signature mismatch");
            if (e.pubkey && It(e.pubkey, a[1]) !== 0) throw new TypeError("Pubkey mismatch");
            const u = Rs(a[1]);
            if (s.length > 0 && It(s, u) !== 0) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(o, e);
}
const uh = Kr;
function _d(e, t) {
    if (!e.address && !e.hash && !e.output && !e.redeem && !e.input) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        network: jn({}),
        address: Pf(),
        hash: Yn(20),
        output: Yn(23),
        redeem: du(jn({
            network: jn({}),
            output: tn,
            input: tn,
            witness: lo(tn)
        })),
        input: tn,
        witness: lo(tn)
    })), e);
    let r = e.network;
    r || (r = e.redeem && e.redeem.network || zs);
    const n = {
        network: r
    }, i = fs(()=>{
        const a = Ql.decode(e.address), u = sc(a, 0), f = a.slice(1);
        return {
            version: u,
            hash: f
        };
    }), o = fs(()=>Sn(e.input)), s = fs(()=>{
        const a = o(), u = a[a.length - 1];
        return {
            network: r,
            output: u === uh.OP_FALSE ? Uint8Array.from([]) : u,
            input: Ri(a.slice(0, -1)),
            witness: e.witness || []
        };
    });
    if (Zt(n, "address", ()=>{
        if (!n.hash) return;
        const a = new Uint8Array(21);
        return Po(a, 0, n.network.scriptHash), a.set(n.hash, 1), Ql.encode(a);
    }), Zt(n, "hash", ()=>{
        if (e.output) return e.output.slice(2, 22);
        if (e.address) return i().hash;
        if (n.redeem && n.redeem.output) return Rs(n.redeem.output);
    }), Zt(n, "output", ()=>{
        if (n.hash) return Ri([
            uh.OP_HASH160,
            n.hash,
            uh.OP_EQUAL
        ]);
    }), Zt(n, "redeem", ()=>{
        if (e.input) return s();
    }), Zt(n, "input", ()=>{
        if (!(!e.redeem || !e.redeem.input || !e.redeem.output)) return Ri([].concat(Sn(e.redeem.input), e.redeem.output));
    }), Zt(n, "witness", ()=>{
        if (n.redeem && n.redeem.witness) return n.redeem.witness;
        if (n.input) return [];
    }), Zt(n, "name", ()=>{
        const a = [
            "p2sh"
        ];
        return n.redeem !== void 0 && n.redeem.name !== void 0 && a.push(n.redeem.name), a.join("-");
    }), t.validate) {
        let a = Uint8Array.from([]);
        if (e.address) {
            if (i().version !== r.scriptHash) throw new TypeError("Invalid version or Network mismatch");
            if (i().hash.length !== 20) throw new TypeError("Invalid address");
            a = i().hash;
        }
        if (e.hash) {
            if (a.length > 0 && It(a, e.hash) !== 0) throw new TypeError("Hash mismatch");
            a = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 23 || e.output[0] !== uh.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== uh.OP_EQUAL) throw new TypeError("Output is invalid");
            const f = e.output.slice(2, 22);
            if (a.length > 0 && It(a, f) !== 0) throw new TypeError("Hash mismatch");
            a = f;
        }
        const u = (f)=>{
            if (f.output) {
                const c = Sn(f.output);
                if (!c || c.length < 1) throw new TypeError("Redeem.output too short");
                if (f.output.byteLength > 520) throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
                if (XB(c) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
                const l = Rs(f.output);
                if (a.length > 0 && It(a, l) !== 0) throw new TypeError("Hash mismatch");
                a = l;
            }
            if (f.input) {
                const c = f.input.length > 0, l = f.witness && f.witness.length > 0;
                if (!c && !l) throw new TypeError("Empty input");
                if (c && l) throw new TypeError("Input and witness provided");
                if (c) {
                    const p = Sn(f.input);
                    if (!Qx(p)) throw new TypeError("Non push-only scriptSig");
                }
            }
        };
        if (e.input) {
            const f = o();
            if (!f || f.length < 1) throw new TypeError("Input too short");
            if (!(s().output instanceof Uint8Array)) throw new TypeError("Input is invalid");
            u(s());
        }
        if (e.redeem) {
            if (e.redeem.network && e.redeem.network !== r) throw new TypeError("Network mismatch");
            if (e.input) {
                const f = s();
                if (e.redeem.output && It(e.redeem.output, f.output) !== 0) throw new TypeError("Redeem.output mismatch");
                if (e.redeem.input && It(e.redeem.input, f.input) !== 0) throw new TypeError("Redeem.input mismatch");
            }
            u(e.redeem);
        }
        if (e.witness && e.redeem && e.redeem.witness && !ep(e.redeem.witness, e.witness)) throw new TypeError("Witness and redeem.witness mismatch");
    }
    return Object.assign(n, e);
}
var Ge = typeof globalThis < "u" ? globalThis : ("TURBOPACK compile-time value", "undefined") < "u" ? window : ("TURBOPACK compile-time value", "object") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g : typeof self < "u" ? self : {};
function c7(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Jq(e) {
    if (e.__esModule) return e;
    var t = e.default;
    if (typeof t == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
        };
        r.prototype = t.prototype;
    } else r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(n) {
        var i = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(r, n, i.get ? i : {
            enumerable: !0,
            get: function() {
                return e[n];
            }
        });
    }), r;
}
var tp = {};
Object.defineProperty(tp, "__esModule", {
    value: !0
});
var rp = tp.bech32m = No = tp.bech32 = void 0;
const Yy = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", u7 = {};
for(let e = 0; e < Yy.length; e++){
    const t = Yy.charAt(e);
    u7[t] = e;
}
function Fl(e) {
    const t = e >> 25;
    return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function j4(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = e.charCodeAt(r);
        if (n < 33 || n > 126) return "Invalid prefix (" + e + ")";
        t = Fl(t) ^ n >> 5;
    }
    t = Fl(t);
    for(let r = 0; r < e.length; ++r){
        const n = e.charCodeAt(r);
        t = Fl(t) ^ n & 31;
    }
    return t;
}
function i3(e, t, r, n) {
    let i = 0, o = 0;
    const s = (1 << r) - 1, a = [];
    for(let u = 0; u < e.length; ++u)for(i = i << t | e[u], o += t; o >= r;)o -= r, a.push(i >> o & s);
    if (n) o > 0 && a.push(i << r - o & s);
    else {
        if (o >= t) return "Excess padding";
        if (i << r - o & s) return "Non-zero padding";
    }
    return a;
}
function Qq(e) {
    return i3(e, 8, 5, !0);
}
function eK(e) {
    const t = i3(e, 5, 8, !1);
    if (Array.isArray(t)) return t;
}
function tK(e) {
    const t = i3(e, 5, 8, !1);
    if (Array.isArray(t)) return t;
    throw new Error(t);
}
function f7(e) {
    let t;
    e === "bech32" ? t = 1 : t = 734539939;
    function r(s, a, u) {
        if (u = u || 90, s.length + 7 + a.length > u) throw new TypeError("Exceeds length limit");
        s = s.toLowerCase();
        let f = j4(s);
        if (typeof f == "string") throw new Error(f);
        let c = s + "1";
        for(let l = 0; l < a.length; ++l){
            const p = a[l];
            if (p >> 5) throw new Error("Non 5-bit word");
            f = Fl(f) ^ p, c += Yy.charAt(p);
        }
        for(let l = 0; l < 6; ++l)f = Fl(f);
        f ^= t;
        for(let l = 0; l < 6; ++l){
            const p = f >> (5 - l) * 5 & 31;
            c += Yy.charAt(p);
        }
        return c;
    }
    function n(s, a) {
        if (a = a || 90, s.length < 8) return s + " too short";
        if (s.length > a) return "Exceeds length limit";
        const u = s.toLowerCase(), f = s.toUpperCase();
        if (s !== u && s !== f) return "Mixed-case string " + s;
        s = u;
        const c = s.lastIndexOf("1");
        if (c === -1) return "No separator character for " + s;
        if (c === 0) return "Missing prefix for " + s;
        const l = s.slice(0, c), p = s.slice(c + 1);
        if (p.length < 6) return "Data too short";
        let y = j4(l);
        if (typeof y == "string") return y;
        const _ = [];
        for(let A = 0; A < p.length; ++A){
            const O = p.charAt(A), N = u7[O];
            if (N === void 0) return "Unknown character " + O;
            y = Fl(y) ^ N, !(A + 6 >= p.length) && _.push(N);
        }
        return y !== t ? "Invalid checksum for " + s : {
            prefix: l,
            words: _
        };
    }
    function i(s, a) {
        const u = n(s, a);
        if (typeof u == "object") return u;
    }
    function o(s, a) {
        const u = n(s, a);
        if (typeof u == "object") return u;
        throw new Error(u);
    }
    return {
        decodeUnsafe: i,
        decode: o,
        encode: r,
        toWords: Qq,
        fromWordsUnsafe: eK,
        fromWords: tK
    };
}
var No = tp.bech32 = f7("bech32");
rp = tp.bech32m = f7("bech32m");
const H4 = Kr, rK = new Uint8Array(0);
function Gp(e, t) {
    if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        address: Pf(),
        hash: Yn(20),
        input: Yn(0),
        network: jn({}),
        output: Yn(22),
        pubkey: Ls(Ms, "Not a valid pubkey"),
        signature: Ls(ac),
        witness: lo(tn)
    })), e);
    const r = fs(()=>{
        const o = No.decode(e.address), s = o.words.shift(), a = No.fromWords(o.words);
        return {
            version: s,
            prefix: o.prefix,
            data: Uint8Array.from(a)
        };
    }), n = e.network || zs, i = {
        name: "p2wpkh",
        network: n
    };
    if (Zt(i, "address", ()=>{
        if (!i.hash) return;
        const o = No.toWords(i.hash);
        return o.unshift(0), No.encode(n.bech32, o);
    }), Zt(i, "hash", ()=>{
        if (e.output) return e.output.slice(2, 22);
        if (e.address) return r().data;
        if (e.pubkey || i.pubkey) return Rs(e.pubkey || i.pubkey);
    }), Zt(i, "output", ()=>{
        if (i.hash) return Ri([
            H4.OP_0,
            i.hash
        ]);
    }), Zt(i, "pubkey", ()=>{
        if (e.pubkey) return e.pubkey;
        if (e.witness) return e.witness[1];
    }), Zt(i, "signature", ()=>{
        if (e.witness) return e.witness[0];
    }), Zt(i, "input", ()=>{
        if (i.witness) return rK;
    }), Zt(i, "witness", ()=>{
        if (e.pubkey && e.signature) return [
            e.signature,
            e.pubkey
        ];
    }), t.validate) {
        let o = Uint8Array.from([]);
        if (e.address) {
            if (n && n.bech32 !== r().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== 0) throw new TypeError("Invalid address version");
            if (r().data.length !== 20) throw new TypeError("Invalid address data");
            o = r().data;
        }
        if (e.hash) {
            if (o.length > 0 && It(o, e.hash) !== 0) throw new TypeError("Hash mismatch");
            o = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 22 || e.output[0] !== H4.OP_0 || e.output[1] !== 20) throw new TypeError("Output is invalid");
            if (o.length > 0 && It(o, e.output.slice(2)) !== 0) throw new TypeError("Hash mismatch");
            o = e.output.slice(2);
        }
        if (e.pubkey) {
            const s = Rs(e.pubkey);
            if (o.length > 0 && It(o, s) !== 0) throw new TypeError("Hash mismatch");
            if (o = s, !Ms(e.pubkey) || e.pubkey.length !== 33) throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (e.witness) {
            if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
            if (!ac(e.witness[0])) throw new TypeError("Witness has invalid signature");
            if (!Ms(e.witness[1]) || e.witness[1].length !== 33) throw new TypeError("Witness has invalid pubkey");
            if (e.signature && It(e.signature, e.witness[0]) !== 0) throw new TypeError("Signature mismatch");
            if (e.pubkey && It(e.pubkey, e.witness[1]) !== 0) throw new TypeError("Pubkey mismatch");
            const s = Rs(e.witness[1]);
            if (o.length > 0 && It(o, s) !== 0) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(i, e);
}
const q4 = Kr, Kw = new Uint8Array(0);
function Tg(e) {
    return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && Ms(e));
}
function Zp(e, t) {
    if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(N4({
        network: jn({}),
        address: Pf(),
        hash: sq,
        output: Yn(34),
        redeem: N4({
            input: tn,
            network: jn({}),
            output: tn,
            witness: lo(tn)
        }),
        input: Yn(0),
        witness: lo(tn)
    }), e);
    const r = fs(()=>{
        const s = No.decode(e.address), a = s.words.shift(), u = No.fromWords(s.words);
        return {
            version: a,
            prefix: s.prefix,
            data: Uint8Array.from(u)
        };
    }), n = fs(()=>Sn(e.redeem.input));
    let i = e.network;
    i || (i = e.redeem && e.redeem.network || zs);
    const o = {
        network: i
    };
    if (Zt(o, "address", ()=>{
        if (!o.hash) return;
        const s = No.toWords(o.hash);
        return s.unshift(0), No.encode(i.bech32, s);
    }), Zt(o, "hash", ()=>{
        if (e.output) return e.output.slice(2);
        if (e.address) return r().data;
        if (o.redeem && o.redeem.output) return pi(o.redeem.output);
    }), Zt(o, "output", ()=>{
        if (o.hash) return Ri([
            q4.OP_0,
            o.hash
        ]);
    }), Zt(o, "redeem", ()=>{
        if (e.witness) return {
            output: e.witness[e.witness.length - 1],
            input: Kw,
            witness: e.witness.slice(0, -1)
        };
    }), Zt(o, "input", ()=>{
        if (o.witness) return Kw;
    }), Zt(o, "witness", ()=>{
        if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
            const s = gq(n());
            return o.redeem = Object.assign({
                witness: s
            }, e.redeem), o.redeem.input = Kw, [].concat(s, e.redeem.output);
        }
        if (e.redeem && e.redeem.output && e.redeem.witness) return [].concat(e.redeem.witness, e.redeem.output);
    }), Zt(o, "name", ()=>{
        const s = [
            "p2wsh"
        ];
        return o.redeem !== void 0 && o.redeem.name !== void 0 && s.push(o.redeem.name), s.join("-");
    }), t.validate) {
        let s = Uint8Array.from([]);
        if (e.address) {
            if (r().prefix !== i.bech32) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== 0) throw new TypeError("Invalid address version");
            if (r().data.length !== 32) throw new TypeError("Invalid address data");
            s = r().data;
        }
        if (e.hash) {
            if (s.length > 0 && It(s, e.hash) !== 0) throw new TypeError("Hash mismatch");
            s = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 34 || e.output[0] !== q4.OP_0 || e.output[1] !== 32) throw new TypeError("Output is invalid");
            const a = e.output.slice(2);
            if (s.length > 0 && It(s, a) !== 0) throw new TypeError("Hash mismatch");
            s = a;
        }
        if (e.redeem) {
            if (e.redeem.network && e.redeem.network !== i) throw new TypeError("Network mismatch");
            if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0) throw new TypeError("Ambiguous witness source");
            if (e.redeem.output) {
                const a = Sn(e.redeem.output);
                if (!a || a.length < 1) throw new TypeError("Redeem.output is invalid");
                if (e.redeem.output.byteLength > 3600) throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
                if (XB(a) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
                const u = pi(e.redeem.output);
                if (s.length > 0 && It(s, u) !== 0) throw new TypeError("Hash mismatch");
                s = u;
            }
            if (e.redeem.input && !Qx(n())) throw new TypeError("Non push-only scriptSig");
            if (e.witness && e.redeem.witness && !ep(e.witness, e.redeem.witness)) throw new TypeError("Witness and redeem.witness mismatch");
            if (e.redeem.input && n().some(Tg) || e.redeem.output && (Sn(e.redeem.output) || []).some(Tg)) throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
        }
        if (e.witness && e.witness.length > 0) {
            const a = e.witness[e.witness.length - 1];
            if (e.redeem && e.redeem.output && It(e.redeem.output, a) !== 0) throw new TypeError("Witness and redeem.output mismatch");
            if (e.witness.some(Tg) || (Sn(a) || []).some(Tg)) throw new TypeError("Witness contains uncompressed pubkey");
        }
    }
    return Object.assign(o, e);
}
const Mh = {};
function o3(e) {
    e ? e !== Mh.eccLib && (nK(e), Mh.eccLib = e) : Mh.eccLib = e;
}
function _E() {
    if (!Mh.eccLib) throw new Error("No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance");
    return Mh.eccLib;
}
const za = (e)=>hc(e);
function nK(e) {
    Go(typeof e.isXOnlyPoint == "function"), Go(e.isXOnlyPoint(za("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Go(e.isXOnlyPoint(za("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e"))), Go(e.isXOnlyPoint(za("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9"))), Go(e.isXOnlyPoint(za("0000000000000000000000000000000000000000000000000000000000000001"))), Go(!e.isXOnlyPoint(za("0000000000000000000000000000000000000000000000000000000000000000"))), Go(!e.isXOnlyPoint(za("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"))), Go(typeof e.xOnlyPointAddTweak == "function"), iK.forEach((t)=>{
        const r = e.xOnlyPointAddTweak(za(t.pubkey), za(t.tweak));
        t.result === null ? Go(r === null) : (Go(r !== null), Go(r.parity === t.parity), Go(It(r.xOnlyPubkey, za(t.result)) === 0));
    });
}
function Go(e) {
    if (!e) throw new Error("ecc library invalid");
}
const iK = [
    {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
    },
    {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
    },
    {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
    }
], l7 = "0123456789abcdefABCDEF";
l7.split("").map((e)=>e.codePointAt(0));
const K4 = Array(256).fill(!0).map((e, t)=>{
    const r = String.fromCodePoint(t), n = l7.indexOf(r);
    return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), d7 = new TextEncoder();
new TextDecoder();
function oK(e) {
    return d7.encode(e);
}
function sK(e) {
    const t = e.reduce((i, o)=>i + o.length, 0), r = new Uint8Array(t);
    let n = 0;
    for (const i of e)r.set(i, n), n += i.length;
    return r;
}
function aK(e) {
    const t = d7.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
    let n;
    for(n = 0; n < r.length; n++){
        const i = K4[t[n * 2]], o = K4[t[n * 2 + 1]];
        if (i === void 0 || o === void 0) break;
        r[n] = i << 4 | o;
    }
    return n === r.length ? r : r.slice(0, n);
}
function ja(e, t) {
    const r = Math.min(e.length, t.length);
    for(let n = 0; n < r; ++n)if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
    return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function W4(e, t, r) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 255) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
    e[t] = r;
}
function cK(e, t, r, n) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 65535) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
    n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Zu(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 4294967295) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
    n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function uK(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 0xffffffffffffffffn) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
    n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function fK(e, t, r) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
    }
}
function xl(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
    }
}
function lK(e, t, r) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0n;
        return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
    } else {
        let n = 0n;
        return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
    }
}
const dK = (e)=>{
    if (e < 0 || e > 0xffffffffffffffffn) throw new RangeError("value out of range");
};
function hK(e) {
    if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0) throw new RangeError("value out of range");
}
function h7(e) {
    typeof e == "number" ? hK(e) : dK(e);
}
function pu(e, t, r) {
    h7(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(ds(e)));
    let n = 0;
    return e < 253 ? (t.set([
        Number(e)
    ], r), n = 1) : e <= 65535 ? (t.set([
        253
    ], r), cK(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([
        254
    ], r), Zu(t, r + 1, Number(e), "LE"), n = 5) : (t.set([
        255
    ], r), uK(t, r + 1, BigInt(e), "LE"), n = 9), {
        buffer: t,
        bytes: n
    };
}
function Ed(e, t) {
    t === void 0 && (t = 0);
    const r = e.at(t);
    if (r === void 0) throw new Error("buffer too small");
    if (r < 253) return {
        numberValue: r,
        bigintValue: BigInt(r),
        bytes: 1
    };
    if (r === 253) {
        const n = fK(e, t + 1, "LE");
        return {
            numberValue: n,
            bigintValue: BigInt(n),
            bytes: 3
        };
    } else if (r === 254) {
        const n = xl(e, t + 1, "LE");
        return {
            numberValue: n,
            bigintValue: BigInt(n),
            bytes: 5
        };
    } else {
        const n = lK(e, t + 1, "LE");
        return {
            numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null,
            bigintValue: n,
            bytes: 9
        };
    }
}
function ds(e) {
    return h7(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const pK = 9007199254740991;
function gK(e, t) {
    if (typeof e != "number" && typeof e != "bigint") throw new Error("cannot write a non-number as a number");
    if (e < 0 && e < BigInt(0)) throw new Error("specified a negative value for writing an unsigned value");
    if (e > t && e > BigInt(t)) throw new Error("RangeError: value out of range");
    if (Math.floor(Number(e)) !== Number(e)) throw new Error("value has a fractional component");
}
function s3(e) {
    if (e.length < 1) return e;
    let t = e.length - 1, r = 0;
    for(let n = 0; n < e.length / 2; n++)r = e[n], e[n] = e[t], e[t] = r, t--;
    return e;
}
function V4(e) {
    const t = new Uint8Array(e.length);
    return t.set(e), t;
}
class Ii {
    constructor(t, r = 0){
        pt(this, "buffer");
        pt(this, "offset");
        this.buffer = t, this.offset = r, En(ca([
            tn,
            Za
        ]), [
            t,
            r
        ]);
    }
    static withCapacity(t) {
        return new Ii(new Uint8Array(t));
    }
    writeUInt8(t) {
        this.offset = Po(this.buffer, this.offset, t);
    }
    writeInt32(t) {
        this.offset = $B(this.buffer, this.offset, t, "LE");
    }
    writeInt64(t) {
        this.offset = LB(this.buffer, this.offset, BigInt(t), "LE");
    }
    writeUInt32(t) {
        this.offset = Wp(this.buffer, this.offset, t, "LE");
    }
    writeUInt64(t) {
        this.offset = VH(this.buffer, this.offset, BigInt(t), "LE");
    }
    writeVarInt(t) {
        const { bytes: r } = pu(t, this.buffer, this.offset);
        this.offset += r;
    }
    writeSlice(t) {
        if (this.buffer.length < this.offset + t.length) throw new Error("Cannot write slice out of bounds");
        this.buffer.set(t, this.offset), this.offset += t.length;
    }
    writeVarSlice(t) {
        this.writeVarInt(t.length), this.writeSlice(t);
    }
    writeVector(t) {
        this.writeVarInt(t.length), t.forEach((r)=>this.writeVarSlice(r));
    }
    end() {
        if (this.buffer.length === this.offset) return this.buffer;
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
    }
}
class yK {
    constructor(t, r = 0){
        pt(this, "buffer");
        pt(this, "offset");
        this.buffer = t, this.offset = r, En(ca([
            tn,
            Za
        ]), [
            t,
            r
        ]);
    }
    readUInt8() {
        const t = sc(this.buffer, this.offset);
        return this.offset++, t;
    }
    readInt32() {
        const t = ZH(this.buffer, this.offset, "LE");
        return this.offset += 4, t;
    }
    readUInt32() {
        const t = wd(this.buffer, this.offset, "LE");
        return this.offset += 4, t;
    }
    readInt64() {
        const t = DB(this.buffer, this.offset, "LE");
        return this.offset += 8, t;
    }
    readVarInt() {
        const { bigintValue: t, bytes: r } = Ed(this.buffer, this.offset);
        return this.offset += r, t;
    }
    readSlice(t) {
        gK(t, pK);
        const r = Number(t);
        if (this.buffer.length < this.offset + r) throw new Error("Cannot read slice out of bounds");
        const n = this.buffer.slice(this.offset, this.offset + r);
        return this.offset += r, n;
    }
    readVarSlice() {
        return this.readSlice(this.readVarInt());
    }
    readVector() {
        const t = this.readVarInt(), r = [];
        for(let n = 0; n < t; n++)r.push(this.readVarSlice());
        return r;
    }
}
const p7 = 192, mK = 128, bK = (e)=>"left" in e && "right" in e;
function EE(e, t) {
    if (e.length < 33) throw new TypeError(`The control-block length is too small. Got ${e.length}, expected min 33.`);
    const r = (e.length - 33) / 32;
    let n = t;
    for(let i = 0; i < r; i++){
        const o = e.slice(33 + 32 * i, 65 + 32 * i);
        It(n, o) < 0 ? n = SE(n, o) : n = SE(o, n);
    }
    return n;
}
function xE(e) {
    if (Jx(e)) return {
        hash: tc(e)
    };
    const t = [
        xE(e[0]),
        xE(e[1])
    ];
    t.sort((i, o)=>It(i.hash, o.hash));
    const [r, n] = t;
    return {
        hash: SE(r.hash, n.hash),
        left: r,
        right: n
    };
}
function Xy(e, t) {
    if (bK(e)) {
        const r = Xy(e.left, t);
        if (r !== void 0) return [
            ...r,
            e.right.hash
        ];
        const n = Xy(e.right, t);
        if (n !== void 0) return [
            ...n,
            e.left.hash
        ];
    } else if (It(e.hash, t) === 0) return [];
}
function tc(e) {
    const t = e.version || p7;
    return ub("TapLeaf", kn([
        Uint8Array.from([
            t
        ]),
        vK(e.output)
    ]));
}
function wK(e, t) {
    return ub("TapTweak", kn(t ? [
        e,
        t
    ] : [
        e
    ]));
}
function kg(e, t) {
    if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
    const r = wK(e, t), n = _E().xOnlyPointAddTweak(e, r);
    return !n || n.xOnlyPubkey === null ? null : {
        parity: n.parity,
        x: Uint8Array.from(n.xOnlyPubkey)
    };
}
function SE(e, t) {
    return ub("TapBranch", kn([
        e,
        t
    ]));
}
function vK(e) {
    const t = ds(e.length), r = new Uint8Array(t);
    return pu(e.length, r), kn([
        r,
        e
    ]);
}
const G4 = Kr, Z4 = 1, _K = 80;
function xd(e, t) {
    if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1)) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), En(du(jn({
        address: Pf(),
        input: Yn(0),
        network: jn({}),
        output: Yn(34),
        internalPubkey: Yn(32),
        hash: Yn(32),
        // merkle root hash, the tweak
        pubkey: Yn(32),
        // tweaked with `hash` from `internalPubkey`
        signature: Xx([
            Yn(64),
            Yn(65)
        ]),
        witness: lo(tn),
        scriptTree: Ls(VB, "Taptree is not of type isTaptree"),
        redeem: du(jn({
            output: tn,
            // tapleaf script
            redeemVersion: oo(),
            // tapleaf version
            witness: lo(tn)
        })),
        redeemVersion: oo()
    })), e);
    const r = fs(()=>a3(e.address)), n = fs(()=>{
        if (!(!e.witness || !e.witness.length)) return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === _K ? e.witness.slice(0, -1) : e.witness.slice();
    }), i = fs(()=>{
        if (e.scriptTree) return xE(e.scriptTree);
        if (e.hash) return {
            hash: e.hash
        };
    }), o = e.network || zs, s = {
        name: "p2tr",
        network: o
    };
    if (Zt(s, "address", ()=>{
        if (!s.pubkey) return;
        const a = rp.toWords(s.pubkey);
        return a.unshift(Z4), rp.encode(o.bech32, a);
    }), Zt(s, "hash", ()=>{
        const a = i();
        if (a) return a.hash;
        const u = n();
        if (u && u.length > 1) {
            const f = u[u.length - 1], c = f[0] & xy, l = u[u.length - 2], p = tc({
                output: l,
                version: c
            });
            return EE(f, p);
        }
        return null;
    }), Zt(s, "output", ()=>{
        if (s.pubkey) return Ri([
            G4.OP_1,
            s.pubkey
        ]);
    }), Zt(s, "redeemVersion", ()=>e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : p7), Zt(s, "redeem", ()=>{
        const a = n();
        if (!(!a || a.length < 2)) return {
            output: a[a.length - 2],
            witness: a.slice(0, -2),
            redeemVersion: a[a.length - 1][0] & xy
        };
    }), Zt(s, "pubkey", ()=>{
        if (e.pubkey) return e.pubkey;
        if (e.output) return e.output.slice(2);
        if (e.address) return r().data;
        if (s.internalPubkey) {
            const a = kg(s.internalPubkey, s.hash);
            if (a) return a.x;
        }
    }), Zt(s, "internalPubkey", ()=>{
        if (e.internalPubkey) return e.internalPubkey;
        const a = n();
        if (a && a.length > 1) return a[a.length - 1].slice(1, 33);
    }), Zt(s, "signature", ()=>{
        if (e.signature) return e.signature;
        const a = n();
        if (!(!a || a.length !== 1)) return a[0];
    }), Zt(s, "witness", ()=>{
        if (e.witness) return e.witness;
        const a = i();
        if (a && e.redeem && e.redeem.output && e.internalPubkey) {
            const u = tc({
                output: e.redeem.output,
                version: s.redeemVersion
            }), f = Xy(a, u);
            if (!f) return;
            const c = kg(e.internalPubkey, a.hash);
            if (!c) return;
            const l = kn([
                Uint8Array.from([
                    s.redeemVersion | c.parity
                ]),
                e.internalPubkey
            ].concat(f));
            return [
                e.redeem.output,
                l
            ];
        }
        if (e.signature) return [
            e.signature
        ];
    }), t.validate) {
        let a = Uint8Array.from([]);
        if (e.address) {
            if (o && o.bech32 !== r().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== Z4) throw new TypeError("Invalid address version");
            if (r().data.length !== 32) throw new TypeError("Invalid address data");
            a = r().data;
        }
        if (e.pubkey) {
            if (a.length > 0 && It(a, e.pubkey) !== 0) throw new TypeError("Pubkey mismatch");
            a = e.pubkey;
        }
        if (e.output) {
            if (e.output.length !== 34 || e.output[0] !== G4.OP_1 || e.output[1] !== 32) throw new TypeError("Output is invalid");
            if (a.length > 0 && It(a, e.output.slice(2)) !== 0) throw new TypeError("Pubkey mismatch");
            a = e.output.slice(2);
        }
        if (e.internalPubkey) {
            const c = kg(e.internalPubkey, s.hash);
            if (a.length > 0 && It(a, c.x) !== 0) throw new TypeError("Pubkey mismatch");
            a = c.x;
        }
        if (a && a.length && !_E().isXOnlyPoint(a)) throw new TypeError("Invalid pubkey for p2tr");
        const u = i();
        if (e.hash && u && It(e.hash, u.hash) !== 0) throw new TypeError("Hash mismatch");
        if (e.redeem && e.redeem.output && u) {
            const c = tc({
                output: e.redeem.output,
                version: s.redeemVersion
            });
            if (!Xy(u, c)) throw new TypeError("Redeem script not in tree");
        }
        const f = n();
        if (e.redeem && s.redeem) {
            if (e.redeem.redeemVersion && e.redeem.redeemVersion !== s.redeem.redeemVersion) throw new TypeError("Redeem.redeemVersion and witness mismatch");
            if (e.redeem.output) {
                if (Sn(e.redeem.output).length === 0) throw new TypeError("Redeem.output is invalid");
                if (s.redeem.output && It(e.redeem.output, s.redeem.output) !== 0) throw new TypeError("Redeem.output and witness mismatch");
            }
            if (e.redeem.witness && s.redeem.witness && !ep(e.redeem.witness, s.redeem.witness)) throw new TypeError("Redeem.witness and witness mismatch");
        }
        if (f && f.length) if (f.length === 1) {
            if (e.signature && It(e.signature, f[0]) !== 0) throw new TypeError("Signature mismatch");
        } else {
            const c = f[f.length - 1];
            if (c.length < 33) throw new TypeError(`The control-block length is too small. Got ${c.length}, expected min 33.`);
            if ((c.length - 33) % 32 !== 0) throw new TypeError(`The control-block length of ${c.length} is incorrect!`);
            const l = (c.length - 33) / 32;
            if (l > 128) throw new TypeError(`The script path is too long. Got ${l}, expected max 128.`);
            const p = c.slice(1, 33);
            if (e.internalPubkey && It(e.internalPubkey, p) !== 0) throw new TypeError("Internal pubkey mismatch");
            if (!_E().isXOnlyPoint(p)) throw new TypeError("Invalid internalPubkey for p2tr witness");
            const y = c[0] & xy, _ = f[f.length - 2], A = tc({
                output: _,
                version: y
            }), O = EE(c, A), N = kg(p, O);
            if (!N) throw new TypeError("Invalid outputKey for p2tr witness");
            if (a.length && It(a, N.x) !== 0) throw new TypeError("Pubkey mismatch for p2tr witness");
            if (N.parity !== (c[0] & 1)) throw new Error("Incorrect parity");
        }
    }
    return Object.assign(s, e);
}
const g7 = 40, y7 = 2, m7 = 16, b7 = 2, w7 = 80, v7 = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function EK(e, t) {
    const r = e.slice(2);
    if (r.length < y7 || r.length > g7) throw new TypeError("Invalid program length for segwit address");
    const n = e[0] - w7;
    if (n < b7 || n > m7) throw new TypeError("Invalid version for segwit address");
    if (e[1] !== r.length) throw new TypeError("Invalid script for segwit address");
    return console.warn(v7), xK(r, n, t.bech32);
}
function _7(e) {
    const t = Ql.decode(e);
    if (t.length < 21) throw new TypeError(e + " is too short");
    if (t.length > 21) throw new TypeError(e + " is too long");
    const r = sc(t, 0), n = t.slice(1);
    return {
        version: r,
        hash: n
    };
}
function a3(e) {
    let t, r;
    try {
        t = No.decode(e);
    } catch  {}
    if (t) {
        if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
    } else if (t = rp.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
    const n = No.fromWords(t.words.slice(1));
    return {
        version: r,
        prefix: t.prefix,
        data: Uint8Array.from(n)
    };
}
function xK(e, t, r) {
    const n = No.toWords(e);
    return n.unshift(t), t === 0 ? No.encode(r, n) : rp.encode(r, n);
}
function Yp(e, t) {
    t = t || zs;
    try {
        return Vp({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return _d({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return Gp({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return Zp({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return xd({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return EK(e, t);
    } catch  {}
    throw new Error(pq(e) + " has no matching Address");
}
function hs(e, t) {
    t = t || zs;
    let r, n;
    try {
        r = _7(e);
    } catch  {}
    if (r) {
        if (r.version === t.pubKeyHash) return Vp({
            hash: r.hash
        }).output;
        if (r.version === t.scriptHash) return _d({
            hash: r.hash
        }).output;
    } else {
        try {
            n = a3(e);
        } catch  {}
        if (n) {
            if (n.prefix !== t.bech32) throw new Error(e + " has an invalid prefix");
            if (n.version === 0) {
                if (n.data.length === 20) return Gp({
                    hash: n.data
                }).output;
                if (n.data.length === 32) return Zp({
                    hash: n.data
                }).output;
            } else if (n.version === 1) {
                if (n.data.length === 32) return xd({
                    pubkey: n.data
                }).output;
            } else if (n.version >= b7 && n.version <= m7 && n.data.length >= y7 && n.data.length <= g7) return console.warn(v7), Ri([
                n.version + w7,
                n.data
            ]);
        }
    }
    throw new Error(e + " has no matching Script");
}
function aa(e) {
    const t = e.length;
    return ds(t) + t;
}
function SK(e) {
    const t = e.length;
    return ds(t) + e.reduce((r, n)=>r + aa(n), 0);
}
const Jc = new Uint8Array(0), Y4 = [], Ww = hc("0000000000000000000000000000000000000000000000000000000000000000"), X4 = hc("0000000000000000000000000000000000000000000000000000000000000001"), AK = hc("ffffffffffffffff"), TK = {
    script: Jc,
    valueBuffer: AK
};
function kK(e) {
    return e.value !== void 0;
}
const Br = class Br {
    constructor(){
        pt(this, "version", 1);
        pt(this, "locktime", 0);
        pt(this, "ins", []);
        pt(this, "outs", []);
    }
    static fromBuffer(t, r) {
        const n = new yK(t), i = new Br();
        i.version = n.readInt32();
        const o = n.readUInt8(), s = n.readUInt8();
        let a = !1;
        o === Br.ADVANCED_TRANSACTION_MARKER && s === Br.ADVANCED_TRANSACTION_FLAG ? a = !0 : n.offset -= 2;
        const u = n.readVarInt();
        for(let c = 0; c < u; ++c)i.ins.push({
            hash: n.readSlice(32),
            index: n.readUInt32(),
            script: n.readVarSlice(),
            sequence: n.readUInt32(),
            witness: Y4
        });
        const f = n.readVarInt();
        for(let c = 0; c < f; ++c)i.outs.push({
            value: n.readInt64(),
            script: n.readVarSlice()
        });
        if (a) {
            for(let c = 0; c < u; ++c)i.ins[c].witness = n.readVector();
            if (!i.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
        }
        if (i.locktime = n.readUInt32(), r) return i;
        if (n.offset !== t.length) throw new Error("Transaction has unexpected data");
        return i;
    }
    static fromHex(t) {
        return Br.fromBuffer(hc(t), !1);
    }
    static isCoinbaseHash(t) {
        En(P4, t);
        for(let r = 0; r < 32; ++r)if (t[r] !== 0) return !1;
        return !0;
    }
    isCoinbase() {
        return this.ins.length === 1 && Br.isCoinbaseHash(this.ins[0].hash);
    }
    addInput(t, r, n, i) {
        return En(ca([
            P4,
            Za,
            vE(Wy(Za)),
            vE(Wy(tn))
        ]), [
            t,
            r,
            n,
            i
        ]), n == null && (n = Br.DEFAULT_SEQUENCE), this.ins.push({
            hash: t,
            index: r,
            script: i || Jc,
            sequence: n,
            witness: Y4
        }) - 1;
    }
    addOutput(t, r) {
        return En(ca([
            tn,
            jw
        ]), [
            t,
            r
        ]), this.outs.push({
            script: t,
            value: r
        }) - 1;
    }
    hasWitnesses() {
        return this.ins.some((t)=>t.witness.length !== 0);
    }
    weight() {
        const t = this.byteLength(!1), r = this.byteLength(!0);
        return t * 3 + r;
    }
    virtualSize() {
        return Math.ceil(this.weight() / 4);
    }
    byteLength(t = !0) {
        const r = t && this.hasWitnesses();
        return (r ? 10 : 8) + ds(this.ins.length) + ds(this.outs.length) + this.ins.reduce((n, i)=>n + 40 + aa(i.script), 0) + this.outs.reduce((n, i)=>n + 8 + aa(i.script), 0) + (r ? this.ins.reduce((n, i)=>n + SK(i.witness), 0) : 0);
    }
    clone() {
        const t = new Br();
        return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r)=>({
                hash: r.hash,
                index: r.index,
                script: r.script,
                sequence: r.sequence,
                witness: r.witness
            })), t.outs = this.outs.map((r)=>({
                script: r.script,
                value: r.value
            })), t;
    }
    /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */ hashForSignature(t, r, n) {
        if (En(ca([
            Za,
            tn,
            oo()
        ]), [
            t,
            r,
            n
        ]), t >= this.ins.length) return X4;
        const i = Ri(Sn(r).filter((a)=>a !== Kr.OP_CODESEPARATOR)), o = this.clone();
        if ((n & 31) === Br.SIGHASH_NONE) o.outs = [], o.ins.forEach((a, u)=>{
            u !== t && (a.sequence = 0);
        });
        else if ((n & 31) === Br.SIGHASH_SINGLE) {
            if (t >= this.outs.length) return X4;
            o.outs.length = t + 1;
            for(let a = 0; a < t; a++)o.outs[a] = TK;
            o.ins.forEach((a, u)=>{
                u !== t && (a.sequence = 0);
            });
        }
        n & Br.SIGHASH_ANYONECANPAY ? (o.ins = [
            o.ins[t]
        ], o.ins[0].script = i) : (o.ins.forEach((a)=>{
            a.script = Jc;
        }), o.ins[t].script = i);
        const s = new Uint8Array(o.byteLength(!1) + 4);
        return $B(s, s.length - 4, n, "LE"), o.__toBuffer(s, 0, !1), ju(s);
    }
    hashForWitnessV1(t, r, n, i, o, s) {
        if (En(ca([
            Za,
            lo(tn),
            lo(jw),
            Za
        ]), [
            t,
            r,
            n,
            i
        ]), n.length !== this.ins.length || r.length !== this.ins.length) throw new Error("Must supply prevout script and value for all inputs");
        const a = i === Br.SIGHASH_DEFAULT ? Br.SIGHASH_ALL : i & Br.SIGHASH_OUTPUT_MASK, f = (i & Br.SIGHASH_INPUT_MASK) === Br.SIGHASH_ANYONECANPAY, c = a === Br.SIGHASH_NONE, l = a === Br.SIGHASH_SINGLE;
        let p = Jc, y = Jc, _ = Jc, A = Jc, O = Jc;
        if (!f) {
            let H = Ii.withCapacity(36 * this.ins.length);
            this.ins.forEach((K)=>{
                H.writeSlice(K.hash), H.writeUInt32(K.index);
            }), p = pi(H.end()), H = Ii.withCapacity(8 * this.ins.length), n.forEach((K)=>H.writeInt64(K)), y = pi(H.end()), H = Ii.withCapacity(r.map(aa).reduce((K, re)=>K + re)), r.forEach((K)=>H.writeVarSlice(K)), _ = pi(H.end()), H = Ii.withCapacity(4 * this.ins.length), this.ins.forEach((K)=>H.writeUInt32(K.sequence)), A = pi(H.end());
        }
        if (c || l) {
            if (l && t < this.outs.length) {
                const H = this.outs[t], K = Ii.withCapacity(8 + aa(H.script));
                K.writeInt64(H.value), K.writeVarSlice(H.script), O = pi(K.end());
            }
        } else {
            if (!this.outs.length) throw new Error("Add outputs to the transaction before signing.");
            const H = this.outs.map((re)=>8 + aa(re.script)).reduce((re, Q)=>re + Q), K = Ii.withCapacity(H);
            this.outs.forEach((re)=>{
                K.writeInt64(re.value), K.writeVarSlice(re.script);
            }), O = pi(K.end());
        }
        const N = (o ? 2 : 0) + (s ? 1 : 0), U = 174 - (f ? 49 : 0) - (c ? 32 : 0) + (s ? 32 : 0) + (o ? 37 : 0), D = Ii.withCapacity(U);
        if (D.writeUInt8(i), D.writeInt32(this.version), D.writeUInt32(this.locktime), D.writeSlice(p), D.writeSlice(y), D.writeSlice(_), D.writeSlice(A), c || l || D.writeSlice(O), D.writeUInt8(N), f) {
            const H = this.ins[t];
            D.writeSlice(H.hash), D.writeUInt32(H.index), D.writeInt64(n[t]), D.writeVarSlice(r[t]), D.writeUInt32(H.sequence);
        } else D.writeUInt32(t);
        if (s) {
            const H = Ii.withCapacity(aa(s));
            H.writeVarSlice(s), D.writeSlice(pi(H.end()));
        }
        return l && D.writeSlice(O), o && (D.writeSlice(o), D.writeUInt8(0), D.writeUInt32(4294967295)), ub("TapSighash", kn([
            Uint8Array.from([
                0
            ]),
            D.end()
        ]));
    }
    hashForWitnessV0(t, r, n, i) {
        En(ca([
            Za,
            tn,
            jw,
            Za
        ]), [
            t,
            r,
            n,
            i
        ]);
        let o = Uint8Array.from([]), s, a = Ww, u = Ww, f = Ww;
        if (i & Br.SIGHASH_ANYONECANPAY || (o = new Uint8Array(36 * this.ins.length), s = new Ii(o, 0), this.ins.forEach((l)=>{
            s.writeSlice(l.hash), s.writeUInt32(l.index);
        }), u = ju(o)), !(i & Br.SIGHASH_ANYONECANPAY) && (i & 31) !== Br.SIGHASH_SINGLE && (i & 31) !== Br.SIGHASH_NONE && (o = new Uint8Array(4 * this.ins.length), s = new Ii(o, 0), this.ins.forEach((l)=>{
            s.writeUInt32(l.sequence);
        }), f = ju(o)), (i & 31) !== Br.SIGHASH_SINGLE && (i & 31) !== Br.SIGHASH_NONE) {
            const l = this.outs.reduce((p, y)=>p + 8 + aa(y.script), 0);
            o = new Uint8Array(l), s = new Ii(o, 0), this.outs.forEach((p)=>{
                s.writeInt64(p.value), s.writeVarSlice(p.script);
            }), a = ju(o);
        } else if ((i & 31) === Br.SIGHASH_SINGLE && t < this.outs.length) {
            const l = this.outs[t];
            o = new Uint8Array(8 + aa(l.script)), s = new Ii(o, 0), s.writeInt64(l.value), s.writeVarSlice(l.script), a = ju(o);
        }
        o = new Uint8Array(156 + aa(r)), s = new Ii(o, 0);
        const c = this.ins[t];
        return s.writeInt32(this.version), s.writeSlice(u), s.writeSlice(f), s.writeSlice(c.hash), s.writeUInt32(c.index), s.writeVarSlice(r), s.writeInt64(n), s.writeUInt32(c.sequence), s.writeSlice(a), s.writeUInt32(this.locktime), s.writeUInt32(i), ju(o);
    }
    getHash(t) {
        return t && this.isCoinbase() ? new Uint8Array(32) : ju(this.__toBuffer(void 0, void 0, t));
    }
    getId() {
        return rr(s3(this.getHash(!1)));
    }
    toBuffer(t, r) {
        return this.__toBuffer(t, r, !0);
    }
    toHex() {
        return rr(this.toBuffer(void 0, void 0));
    }
    setInputScript(t, r) {
        En(ca([
            oo(),
            tn
        ]), [
            t,
            r
        ]), this.ins[t].script = r;
    }
    setWitness(t, r) {
        En(ca([
            oo(),
            lo(tn)
        ]), [
            t,
            r
        ]), this.ins[t].witness = r;
    }
    __toBuffer(t, r, n = !1) {
        t || (t = new Uint8Array(this.byteLength(n)));
        const i = new Ii(t, r || 0);
        i.writeInt32(this.version);
        const o = n && this.hasWitnesses();
        return o && (i.writeUInt8(Br.ADVANCED_TRANSACTION_MARKER), i.writeUInt8(Br.ADVANCED_TRANSACTION_FLAG)), i.writeVarInt(this.ins.length), this.ins.forEach((s)=>{
            i.writeSlice(s.hash), i.writeUInt32(s.index), i.writeVarSlice(s.script), i.writeUInt32(s.sequence);
        }), i.writeVarInt(this.outs.length), this.outs.forEach((s)=>{
            kK(s) ? i.writeInt64(s.value) : i.writeSlice(s.valueBuffer), i.writeVarSlice(s.script);
        }), o && this.ins.forEach((s)=>{
            i.writeVector(s.witness);
        }), i.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, i.offset) : t;
    }
};
pt(Br, "DEFAULT_SEQUENCE", 4294967295), pt(Br, "SIGHASH_DEFAULT", 0), pt(Br, "SIGHASH_ALL", 1), pt(Br, "SIGHASH_NONE", 2), pt(Br, "SIGHASH_SINGLE", 3), pt(Br, "SIGHASH_ANYONECANPAY", 128), pt(Br, "SIGHASH_OUTPUT_MASK", 3), pt(Br, "SIGHASH_INPUT_MASK", 128), pt(Br, "ADVANCED_TRANSACTION_MARKER", 0), pt(Br, "ADVANCED_TRANSACTION_FLAG", 1);
let xn = Br;
var ya;
(function(e) {
    e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(ya || (ya = {}));
var Dt;
(function(e) {
    e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(Dt || (Dt = {}));
var $n;
(function(e) {
    e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})($n || ($n = {}));
const IK = (e)=>[
        ...Array(e).keys()
    ];
function BK(e) {
    if (e.key[0] !== ya.GLOBAL_XPUB) throw new Error("Decode Error: could not decode globalXpub with key 0x" + rr(e.key));
    if (e.key.length !== 79 || ![
        2,
        3
    ].includes(e.key[46])) throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x" + rr(e.key));
    if (e.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");
    const t = e.key.slice(1), r = {
        masterFingerprint: e.value.slice(0, 4),
        extendedPubkey: t,
        path: "m"
    };
    for (const n of IK(e.value.length / 4 - 1)){
        const i = wd(e.value, n * 4 + 4, "LE"), o = !!(i & 2147483648), s = i & 2147483647;
        r.path += "/" + s.toString(10) + (o ? "'" : "");
    }
    return r;
}
function OK(e) {
    const t = new Uint8Array([
        ya.GLOBAL_XPUB
    ]), r = kn([
        t,
        e.extendedPubkey
    ]), n = e.path.split("/"), i = new Uint8Array(n.length * 4);
    i.set(e.masterFingerprint, 0);
    let o = 4;
    return n.slice(1).forEach((s)=>{
        const a = s.slice(-1) === "'";
        let u = 2147483647 & parseInt(a ? s.slice(0, -1) : s, 10);
        a && (u += 2147483648), Wp(i, o, u, "LE"), o += 4;
    }), {
        key: r,
        value: i
    };
}
const PK = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function NK(e) {
    const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
    return t instanceof Uint8Array && t.length === 78 && [
        2,
        3
    ].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function MK(e, t, r) {
    const n = rr(t.extendedPubkey);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.extendedPubkey, t.extendedPubkey)).length === 0);
}
const RK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: MK,
    check: NK,
    decode: BK,
    encode: OK,
    expected: PK
}, Symbol.toStringTag, {
    value: "Module"
}));
function CK(e) {
    return {
        key: new Uint8Array([
            ya.UNSIGNED_TX
        ]),
        value: e.toBuffer()
    };
}
const UK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    encode: CK
}, Symbol.toStringTag, {
    value: "Module"
}));
function $K(e) {
    if (e.key[0] !== Dt.FINAL_SCRIPTSIG) throw new Error("Decode Error: could not decode finalScriptSig with key 0x" + rr(e.key));
    return e.value;
}
function LK(e) {
    return {
        key: new Uint8Array([
            Dt.FINAL_SCRIPTSIG
        ]),
        value: e
    };
}
const DK = "Uint8Array";
function FK(e) {
    return e instanceof Uint8Array;
}
function zK(e, t) {
    return !!e && !!t && e.finalScriptSig === void 0;
}
const jK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: zK,
    check: FK,
    decode: $K,
    encode: LK,
    expected: DK
}, Symbol.toStringTag, {
    value: "Module"
}));
function HK(e) {
    if (e.key[0] !== Dt.FINAL_SCRIPTWITNESS) throw new Error("Decode Error: could not decode finalScriptWitness with key 0x" + rr(e.key));
    return e.value;
}
function qK(e) {
    return {
        key: new Uint8Array([
            Dt.FINAL_SCRIPTWITNESS
        ]),
        value: e
    };
}
const KK = "Uint8Array";
function WK(e) {
    return e instanceof Uint8Array;
}
function VK(e, t) {
    return !!e && !!t && e.finalScriptWitness === void 0;
}
const GK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: VK,
    check: WK,
    decode: HK,
    encode: qK,
    expected: KK
}, Symbol.toStringTag, {
    value: "Module"
}));
function ZK(e) {
    if (e.key[0] !== Dt.NON_WITNESS_UTXO) throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x" + rr(e.key));
    return e.value;
}
function YK(e) {
    return {
        key: new Uint8Array([
            Dt.NON_WITNESS_UTXO
        ]),
        value: e
    };
}
const XK = "Uint8Array";
function JK(e) {
    return e instanceof Uint8Array;
}
function QK(e, t) {
    return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const eW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: QK,
    check: JK,
    decode: ZK,
    encode: YK,
    expected: XK
}, Symbol.toStringTag, {
    value: "Module"
}));
function tW(e) {
    if (e.key[0] !== Dt.PARTIAL_SIG) throw new Error("Decode Error: could not decode partialSig with key 0x" + rr(e.key));
    if (!(e.key.length === 34 || e.key.length === 66) || ![
        2,
        3,
        4
    ].includes(e.key[1])) throw new Error("Decode Error: partialSig has invalid pubkey in key 0x" + rr(e.key));
    return {
        pubkey: e.key.slice(1),
        signature: e.value
    };
}
function rW(e) {
    const t = new Uint8Array([
        Dt.PARTIAL_SIG
    ]);
    return {
        key: kn([
            t,
            e.pubkey
        ]),
        value: e.signature
    };
}
const nW = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function iW(e) {
    return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [
        33,
        65
    ].includes(e.pubkey.length) && [
        2,
        3,
        4
    ].includes(e.pubkey[0]) && oW(e.signature);
}
function oW(e) {
    if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
    const t = e[3];
    if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
    const r = e[3 + t + 2];
    return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function sW(e, t, r) {
    const n = rr(t.pubkey);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.pubkey, t.pubkey) === 0).length === 0);
}
const aW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: sW,
    check: iW,
    decode: tW,
    encode: rW,
    expected: nW
}, Symbol.toStringTag, {
    value: "Module"
}));
function cW(e) {
    if (e.key[0] !== Dt.POR_COMMITMENT) throw new Error("Decode Error: could not decode porCommitment with key 0x" + rr(e.key));
    return zH(e.value);
}
function uW(e) {
    return {
        key: new Uint8Array([
            Dt.POR_COMMITMENT
        ]),
        value: jH(e)
    };
}
const fW = "string";
function lW(e) {
    return typeof e == "string";
}
function dW(e, t) {
    return !!e && !!t && e.porCommitment === void 0;
}
const hW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: dW,
    check: lW,
    decode: cW,
    encode: uW,
    expected: fW
}, Symbol.toStringTag, {
    value: "Module"
}));
function pW(e) {
    if (e.key[0] !== Dt.SIGHASH_TYPE) throw new Error("Decode Error: could not decode sighashType with key 0x" + rr(e.key));
    return Number(wd(e.value, 0, "LE"));
}
function gW(e) {
    const t = Uint8Array.from([
        Dt.SIGHASH_TYPE
    ]), r = new Uint8Array(4);
    return Wp(r, 0, e, "LE"), {
        key: t,
        value: r
    };
}
const yW = "number";
function mW(e) {
    return typeof e == "number";
}
function bW(e, t) {
    return !!e && !!t && e.sighashType === void 0;
}
const wW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: bW,
    check: mW,
    decode: pW,
    encode: gW,
    expected: yW
}, Symbol.toStringTag, {
    value: "Module"
}));
function vW(e) {
    if (e.key[0] !== Dt.TAP_KEY_SIG || e.key.length !== 1) throw new Error("Decode Error: could not decode tapKeySig with key 0x" + rr(e.key));
    if (!E7(e.value)) throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");
    return e.value;
}
function _W(e) {
    return {
        key: Uint8Array.from([
            Dt.TAP_KEY_SIG
        ]),
        value: e
    };
}
const EW = "Uint8Array";
function E7(e) {
    return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function xW(e, t) {
    return !!e && !!t && e.tapKeySig === void 0;
}
const SW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: xW,
    check: E7,
    decode: vW,
    encode: _W,
    expected: EW
}, Symbol.toStringTag, {
    value: "Module"
}));
function AW(e) {
    if (e.key[0] !== Dt.TAP_LEAF_SCRIPT) throw new Error("Decode Error: could not decode tapLeafScript with key 0x" + rr(e.key));
    if ((e.key.length - 2) % 32 !== 0) throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x" + rr(e.key));
    const t = e.value[e.value.length - 1];
    if ((e.key[1] & 254) !== t) throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x" + rr(e.key));
    const r = e.value.slice(0, -1);
    return {
        controlBlock: e.key.slice(1),
        script: r,
        leafVersion: t
    };
}
function TW(e) {
    const t = Uint8Array.from([
        Dt.TAP_LEAF_SCRIPT
    ]), r = Uint8Array.from([
        e.leafVersion
    ]);
    return {
        key: kn([
            t,
            e.controlBlock
        ]),
        value: kn([
            e.script,
            r
        ])
    };
}
const kW = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function IW(e) {
    return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function BW(e, t, r) {
    const n = rr(t.controlBlock);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.controlBlock, t.controlBlock) === 0).length === 0);
}
const OW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: BW,
    check: IW,
    decode: AW,
    encode: TW,
    expected: kW
}, Symbol.toStringTag, {
    value: "Module"
}));
function PW(e) {
    if (e.key[0] !== Dt.TAP_MERKLE_ROOT || e.key.length !== 1) throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x" + rr(e.key));
    if (!x7(e.value)) throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
    return e.value;
}
function NW(e) {
    return {
        key: Uint8Array.from([
            Dt.TAP_MERKLE_ROOT
        ]),
        value: e
    };
}
const MW = "Uint8Array";
function x7(e) {
    return e instanceof Uint8Array && e.length === 32;
}
function RW(e, t) {
    return !!e && !!t && e.tapMerkleRoot === void 0;
}
const CW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: RW,
    check: x7,
    decode: PW,
    encode: NW,
    expected: MW
}, Symbol.toStringTag, {
    value: "Module"
}));
function UW(e) {
    if (e.key[0] !== Dt.TAP_SCRIPT_SIG) throw new Error("Decode Error: could not decode tapScriptSig with key 0x" + rr(e.key));
    if (e.key.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid key 0x" + rr(e.key));
    if (e.value.length !== 64 && e.value.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x" + rr(e.key));
    const t = e.key.slice(1, 33), r = e.key.slice(33);
    return {
        pubkey: t,
        leafHash: r,
        signature: e.value
    };
}
function $W(e) {
    const t = Uint8Array.from([
        Dt.TAP_SCRIPT_SIG
    ]);
    return {
        key: kn([
            t,
            e.pubkey,
            e.leafHash
        ]),
        value: e.signature
    };
}
const LW = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function DW(e) {
    return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function FW(e, t, r) {
    const n = rr(t.pubkey) + rr(t.leafHash);
    return r.has(n) ? !1 : (r.add(n), e.filter((i)=>It(i.pubkey, t.pubkey) === 0 && It(i.leafHash, t.leafHash) === 0).length === 0);
}
const zW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: FW,
    check: DW,
    decode: UW,
    encode: $W,
    expected: LW
}, Symbol.toStringTag, {
    value: "Module"
}));
function jW(e) {
    if (e.key[0] !== Dt.WITNESS_UTXO) throw new Error("Decode Error: could not decode witnessUtxo with key 0x" + rr(e.key));
    const t = DB(e.value, 0, "LE");
    let r = 8;
    const { numberValue: n, bytes: i } = Ed(e.value, r);
    r += i;
    const o = e.value.slice(r);
    if (o.length !== n) throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
    return {
        script: o,
        value: t
    };
}
function HW(e) {
    const { script: t, value: r } = e, n = ds(t.length), i = new Uint8Array(8 + n + t.length);
    return LB(i, 0, BigInt(r), "LE"), pu(t.length, i, 8), i.set(t, 8 + n), {
        key: Uint8Array.from([
            Dt.WITNESS_UTXO
        ]),
        value: i
    };
}
const qW = "{ script: Uint8Array; value: bigint; }";
function KW(e) {
    return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function WW(e, t) {
    return !!e && !!t && e.witnessUtxo === void 0;
}
const VW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: WW,
    check: KW,
    decode: jW,
    encode: HW,
    expected: qW
}, Symbol.toStringTag, {
    value: "Module"
}));
function GW(e) {
    if (e.key[0] !== $n.TAP_TREE || e.key.length !== 1) throw new Error("Decode Error: could not decode tapTree with key 0x" + rr(e.key));
    let t = 0;
    const r = [];
    for(; t < e.value.length;){
        const n = e.value[t++], i = e.value[t++], { numberValue: o, bytes: s } = Ed(e.value, t);
        t += s, r.push({
            depth: n,
            leafVersion: i,
            script: e.value.slice(t, t + o)
        }), t += o;
    }
    return {
        leaves: r
    };
}
function ZW(e) {
    const t = Uint8Array.from([
        $n.TAP_TREE
    ]), r = [].concat(...e.leaves.map((n)=>[
            Uint8Array.of(n.depth, n.leafVersion),
            pu(BigInt(n.script.length)).buffer,
            n.script
        ]));
    return {
        key: t,
        value: kn(r)
    };
}
const YW = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function XW(e) {
    return Array.isArray(e.leaves) && e.leaves.every((t)=>t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array);
}
function JW(e, t) {
    return !!e && !!t && e.tapTree === void 0;
}
const QW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: JW,
    check: XW,
    decode: GW,
    encode: ZW,
    expected: YW
}, Symbol.toStringTag, {
    value: "Module"
})), eV = (e)=>[
        ...Array(e).keys()
    ], tV = (e)=>e.length === 33 && [
        2,
        3
    ].includes(e[0]) || e.length === 65 && e[0] === 4;
function c3(e, t = tV) {
    function r(a) {
        if (a.key[0] !== e) throw new Error("Decode Error: could not decode bip32Derivation with key 0x" + rr(a.key));
        const u = a.key.slice(1);
        if (!t(u)) throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x" + rr(a.key));
        if (a.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");
        const f = {
            masterFingerprint: a.value.slice(0, 4),
            pubkey: u,
            path: "m"
        };
        for (const c of eV(a.value.length / 4 - 1)){
            const l = wd(a.value, c * 4 + 4, "LE"), p = !!(l & 2147483648), y = l & 2147483647;
            f.path += "/" + y.toString(10) + (p ? "'" : "");
        }
        return f;
    }
    function n(a) {
        const u = Uint8Array.from([
            e
        ]), f = kn([
            u,
            a.pubkey
        ]), c = a.path.split("/"), l = new Uint8Array(c.length * 4);
        l.set(a.masterFingerprint, 0);
        let p = 4;
        return c.slice(1).forEach((y)=>{
            const _ = y.slice(-1) === "'";
            let A = 2147483647 & parseInt(_ ? y.slice(0, -1) : y, 10);
            _ && (A += 2147483648), Wp(l, p, A, "LE"), p += 4;
        }), {
            key: f,
            value: l
        };
    }
    const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
    function o(a) {
        return a.pubkey instanceof Uint8Array && a.masterFingerprint instanceof Uint8Array && typeof a.path == "string" && t(a.pubkey) && a.masterFingerprint.length === 4;
    }
    function s(a, u, f) {
        const c = rr(u.pubkey);
        return f.has(c) ? !1 : (f.add(c), a.filter((l)=>It(l.pubkey, u.pubkey) === 0).length === 0);
    }
    return {
        decode: r,
        encode: n,
        check: o,
        expected: i,
        canAddToArray: s
    };
}
function u3(e) {
    return t;
    //TURBOPACK unreachable
    ;
    function t(r) {
        let n;
        if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![
            2,
            3,
            4
        ].includes(n[0]))) throw new Error("Format Error: invalid pubkey in key 0x" + rr(r.key));
        return n;
    }
}
function S7(e) {
    function t(s) {
        if (s.key[0] !== e) throw new Error("Decode Error: could not decode redeemScript with key 0x" + rr(s.key));
        return s.value;
    }
    function r(s) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: s
        };
    }
    const n = "Uint8Array";
    function i(s) {
        return s instanceof Uint8Array;
    }
    function o(s, a) {
        return !!s && !!a && s.redeemScript === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i,
        expected: n,
        canAdd: o
    };
}
const rV = (e)=>e.length === 32;
function A7(e) {
    const t = c3(e, rV);
    function r(s) {
        const { numberValue: a, bytes: u } = Ed(s.value), f = t.decode({
            key: s.key,
            value: s.value.slice(u + Number(a) * 32)
        }), c = new Array(Number(a));
        for(let l = 0, p = u; l < a; l++, p += 32)c[l] = s.value.slice(p, p + 32);
        return {
            ...f,
            leafHashes: c
        };
    }
    function n(s) {
        const a = t.encode(s), u = ds(s.leafHashes.length), f = new Uint8Array(u);
        pu(s.leafHashes.length, f);
        const c = kn([
            f,
            ...s.leafHashes,
            a.value
        ]);
        return {
            ...a,
            value: c
        };
    }
    const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
    function o(s) {
        return Array.isArray(s.leafHashes) && s.leafHashes.every((a)=>a instanceof Uint8Array && a.length === 32) && t.check(s);
    }
    return {
        decode: r,
        encode: n,
        check: o,
        expected: i,
        canAddToArray: t.canAddToArray
    };
}
function T7(e) {
    function t(s) {
        if (s.key[0] !== e || s.key.length !== 1) throw new Error("Decode Error: could not decode tapInternalKey with key 0x" + rr(s.key));
        if (s.value.length !== 32) throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");
        return s.value;
    }
    function r(s) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: s
        };
    }
    const n = "Uint8Array";
    function i(s) {
        return s instanceof Uint8Array && s.length === 32;
    }
    function o(s, a) {
        return !!s && !!a && s.tapInternalKey === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i,
        expected: n,
        canAdd: o
    };
}
function k7(e) {
    function t(s) {
        if (s.key[0] !== e) throw new Error("Decode Error: could not decode witnessScript with key 0x" + rr(s.key));
        return s.value;
    }
    function r(s) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: s
        };
    }
    const n = "Uint8Array";
    function i(s) {
        return s instanceof Uint8Array;
    }
    function o(s, a) {
        return !!s && !!a && s.witnessScript === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i,
        expected: n,
        canAdd: o
    };
}
const f3 = {
    unsignedTx: UK,
    globalXpub: RK,
    // pass an Array of key bytes that require pubkey beside the key
    checkPubkey: u3([])
}, Vn = {
    nonWitnessUtxo: eW,
    partialSig: aW,
    sighashType: wW,
    finalScriptSig: jK,
    finalScriptWitness: GK,
    porCommitment: hW,
    witnessUtxo: VW,
    bip32Derivation: c3(Dt.BIP32_DERIVATION),
    redeemScript: S7(Dt.REDEEM_SCRIPT),
    witnessScript: k7(Dt.WITNESS_SCRIPT),
    checkPubkey: u3([
        Dt.PARTIAL_SIG,
        Dt.BIP32_DERIVATION
    ]),
    tapKeySig: SW,
    tapScriptSig: zW,
    tapLeafScript: OW,
    tapBip32Derivation: A7(Dt.TAP_BIP32_DERIVATION),
    tapInternalKey: T7(Dt.TAP_INTERNAL_KEY),
    tapMerkleRoot: CW
}, Ya = {
    bip32Derivation: c3($n.BIP32_DERIVATION),
    redeemScript: S7($n.REDEEM_SCRIPT),
    witnessScript: k7($n.WITNESS_SCRIPT),
    checkPubkey: u3([
        $n.BIP32_DERIVATION
    ]),
    tapBip32Derivation: A7($n.TAP_BIP32_DERIVATION),
    tapTree: QW,
    tapInternalKey: T7($n.TAP_INTERNAL_KEY)
}, nV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    globals: f3,
    inputs: Vn,
    outputs: Ya
}, Symbol.toStringTag, {
    value: "Module"
})), Jy = (e)=>[
        ...Array(e).keys()
    ];
function J4(e) {
    const t = e.map(iV);
    return t.push(Uint8Array.from([
        0
    ])), kn(t);
}
function iV(e) {
    const t = e.key.length, r = e.value.length, n = ds(t), i = ds(r), o = new Uint8Array(n + t + i + r);
    return pu(t, o, 0), o.set(e.key, n), pu(r, o, n + t), o.set(e.value, n + t + i), o;
}
function oV(e, t) {
    let r = 0;
    function n() {
        const { numberValue: O, bytes: N } = Ed(e, r);
        r += N;
        const U = e.slice(r, r + Number(O));
        return r += Number(O), U;
    }
    function i() {
        const O = wd(e, r, "BE");
        return r += 4, O;
    }
    function o() {
        const O = sc(e, r);
        return r += 1, O;
    }
    function s() {
        const O = n(), N = n();
        return {
            key: O,
            value: N
        };
    }
    function a() {
        if (r >= e.length) throw new Error("Format Error: Unexpected End of PSBT");
        const O = sc(e, r) === 0;
        return O && r++, O;
    }
    if (i() !== 1886610036) throw new Error("Format Error: Invalid Magic Number");
    if (o() !== 255) throw new Error("Format Error: Magic Number must be followed by 0xff separator");
    const u = [], f = {};
    for(; !a();){
        const O = s(), N = rr(O.key);
        if (f[N]) throw new Error("Format Error: Keys must be unique for global keymap: key " + N);
        f[N] = 1, u.push(O);
    }
    const c = u.filter((O)=>O.key[0] === ya.UNSIGNED_TX);
    if (c.length !== 1) throw new Error("Format Error: Only one UNSIGNED_TX allowed");
    const l = t(c[0].value), { inputCount: p, outputCount: y } = l.getInputOutputCounts(), _ = [], A = [];
    for (const O of Jy(p)){
        const N = {}, U = [];
        for(; !a();){
            const D = s(), H = rr(D.key);
            if (N[H]) throw new Error("Format Error: Keys must be unique for each input: input index " + O + " key " + H);
            N[H] = 1, U.push(D);
        }
        _.push(U);
    }
    for (const O of Jy(y)){
        const N = {}, U = [];
        for(; !a();){
            const D = s(), H = rr(D.key);
            if (N[H]) throw new Error("Format Error: Keys must be unique for each output: output index " + O + " key " + H);
            N[H] = 1, U.push(D);
        }
        A.push(U);
    }
    return I7(l, {
        globalMapKeyVals: u,
        inputKeyVals: _,
        outputKeyVals: A
    });
}
function xi(e, t, r) {
    if (It(t, Uint8Array.from([
        r
    ]))) throw new Error(// `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    `Format Error: Invalid ${e} key: ${rr(t)}`);
}
function I7(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
    const i = {
        unsignedTx: e
    };
    let o = 0;
    for (const c of t)switch(c.key[0]){
        case ya.UNSIGNED_TX:
            if (xi("global", c.key, ya.UNSIGNED_TX), o > 0) throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            o++;
            break;
        case ya.GLOBAL_XPUB:
            i.globalXpub === void 0 && (i.globalXpub = []), i.globalXpub.push(f3.globalXpub.decode(c));
            break;
        default:
            i.unknownKeyVals || (i.unknownKeyVals = []), i.unknownKeyVals.push(c);
    }
    const s = r.length, a = n.length, u = [], f = [];
    for (const c of Jy(s)){
        const l = {};
        for (const p of r[c])switch(Vn.checkPubkey(p), p.key[0]){
            case Dt.NON_WITNESS_UTXO:
                if (xi("input", p.key, Dt.NON_WITNESS_UTXO), l.nonWitnessUtxo !== void 0) throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");
                l.nonWitnessUtxo = Vn.nonWitnessUtxo.decode(p);
                break;
            case Dt.WITNESS_UTXO:
                if (xi("input", p.key, Dt.WITNESS_UTXO), l.witnessUtxo !== void 0) throw new Error("Format Error: Input has multiple WITNESS_UTXO");
                l.witnessUtxo = Vn.witnessUtxo.decode(p);
                break;
            case Dt.PARTIAL_SIG:
                l.partialSig === void 0 && (l.partialSig = []), l.partialSig.push(Vn.partialSig.decode(p));
                break;
            case Dt.SIGHASH_TYPE:
                if (xi("input", p.key, Dt.SIGHASH_TYPE), l.sighashType !== void 0) throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
                l.sighashType = Vn.sighashType.decode(p);
                break;
            case Dt.REDEEM_SCRIPT:
                if (xi("input", p.key, Dt.REDEEM_SCRIPT), l.redeemScript !== void 0) throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
                l.redeemScript = Vn.redeemScript.decode(p);
                break;
            case Dt.WITNESS_SCRIPT:
                if (xi("input", p.key, Dt.WITNESS_SCRIPT), l.witnessScript !== void 0) throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
                l.witnessScript = Vn.witnessScript.decode(p);
                break;
            case Dt.BIP32_DERIVATION:
                l.bip32Derivation === void 0 && (l.bip32Derivation = []), l.bip32Derivation.push(Vn.bip32Derivation.decode(p));
                break;
            case Dt.FINAL_SCRIPTSIG:
                xi("input", p.key, Dt.FINAL_SCRIPTSIG), l.finalScriptSig = Vn.finalScriptSig.decode(p);
                break;
            case Dt.FINAL_SCRIPTWITNESS:
                xi("input", p.key, Dt.FINAL_SCRIPTWITNESS), l.finalScriptWitness = Vn.finalScriptWitness.decode(p);
                break;
            case Dt.POR_COMMITMENT:
                xi("input", p.key, Dt.POR_COMMITMENT), l.porCommitment = Vn.porCommitment.decode(p);
                break;
            case Dt.TAP_KEY_SIG:
                xi("input", p.key, Dt.TAP_KEY_SIG), l.tapKeySig = Vn.tapKeySig.decode(p);
                break;
            case Dt.TAP_SCRIPT_SIG:
                l.tapScriptSig === void 0 && (l.tapScriptSig = []), l.tapScriptSig.push(Vn.tapScriptSig.decode(p));
                break;
            case Dt.TAP_LEAF_SCRIPT:
                l.tapLeafScript === void 0 && (l.tapLeafScript = []), l.tapLeafScript.push(Vn.tapLeafScript.decode(p));
                break;
            case Dt.TAP_BIP32_DERIVATION:
                l.tapBip32Derivation === void 0 && (l.tapBip32Derivation = []), l.tapBip32Derivation.push(Vn.tapBip32Derivation.decode(p));
                break;
            case Dt.TAP_INTERNAL_KEY:
                xi("input", p.key, Dt.TAP_INTERNAL_KEY), l.tapInternalKey = Vn.tapInternalKey.decode(p);
                break;
            case Dt.TAP_MERKLE_ROOT:
                xi("input", p.key, Dt.TAP_MERKLE_ROOT), l.tapMerkleRoot = Vn.tapMerkleRoot.decode(p);
                break;
            default:
                l.unknownKeyVals || (l.unknownKeyVals = []), l.unknownKeyVals.push(p);
        }
        u.push(l);
    }
    for (const c of Jy(a)){
        const l = {};
        for (const p of n[c])switch(Ya.checkPubkey(p), p.key[0]){
            case $n.REDEEM_SCRIPT:
                if (xi("output", p.key, $n.REDEEM_SCRIPT), l.redeemScript !== void 0) throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
                l.redeemScript = Ya.redeemScript.decode(p);
                break;
            case $n.WITNESS_SCRIPT:
                if (xi("output", p.key, $n.WITNESS_SCRIPT), l.witnessScript !== void 0) throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
                l.witnessScript = Ya.witnessScript.decode(p);
                break;
            case $n.BIP32_DERIVATION:
                l.bip32Derivation === void 0 && (l.bip32Derivation = []), l.bip32Derivation.push(Ya.bip32Derivation.decode(p));
                break;
            case $n.TAP_INTERNAL_KEY:
                xi("output", p.key, $n.TAP_INTERNAL_KEY), l.tapInternalKey = Ya.tapInternalKey.decode(p);
                break;
            case $n.TAP_TREE:
                xi("output", p.key, $n.TAP_TREE), l.tapTree = Ya.tapTree.decode(p);
                break;
            case $n.TAP_BIP32_DERIVATION:
                l.tapBip32Derivation === void 0 && (l.tapBip32Derivation = []), l.tapBip32Derivation.push(Ya.tapBip32Derivation.decode(p));
                break;
            default:
                l.unknownKeyVals || (l.unknownKeyVals = []), l.unknownKeyVals.push(p);
        }
        f.push(l);
    }
    return {
        globalMap: i,
        inputs: u,
        outputs: f
    };
}
function sV({ globalMap: e, inputs: t, outputs: r }) {
    const { globalKeyVals: n, inputKeyVals: i, outputKeyVals: o } = AE({
        globalMap: e,
        inputs: t,
        outputs: r
    }), s = J4(n), a = (l)=>l.length === 0 ? [
            Uint8Array.from([
                0
            ])
        ] : l.map(J4), u = a(i), f = a(o), c = new Uint8Array(5);
    return c.set([
        112,
        115,
        98,
        116,
        255
    ], 0), kn([
        c,
        s
    ].concat(u, f));
}
const aV = (e, t)=>It(e.key, t.key);
function Vw(e, t) {
    const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((o, [s, a])=>{
        if (s === "unknownKeyVals") return o;
        const u = t[s];
        if (u === void 0) return o;
        const f = (Array.isArray(a) ? a : [
            a
        ]).map(u.encode);
        return f.map((l)=>rr(l.key)).forEach((l)=>{
            if (r.has(l)) throw new Error("Serialize Error: Duplicate key: " + l);
            r.add(l);
        }), o.concat(f);
    }, []), i = e.unknownKeyVals ? e.unknownKeyVals.filter((o)=>!r.has(rr(o.key))) : [];
    return n.concat(i).sort(aV);
}
function AE({ globalMap: e, inputs: t, outputs: r }) {
    return {
        globalKeyVals: Vw(e, f3),
        inputKeyVals: t.map((n)=>Vw(n, Vn)),
        outputKeyVals: r.map((n)=>Vw(n, Ya))
    };
}
function cV(e) {
    const t = e[0], r = AE(t), n = e.slice(1);
    if (n.length === 0) throw new Error("Combine: Nothing to combine");
    const i = Q4(t);
    if (i === void 0) throw new Error("Combine: Self missing transaction");
    const o = ul(r.globalKeyVals), s = r.inputKeyVals.map(ul), a = r.outputKeyVals.map(ul);
    for (const u of n){
        const f = Q4(u);
        if (f === void 0 || It(f.toBuffer(), i.toBuffer()) !== 0) throw new Error("Combine: One of the Psbts does not have the same transaction.");
        const c = AE(u);
        ul(c.globalKeyVals).forEach(Gw(o, r.globalKeyVals, c.globalKeyVals)), c.inputKeyVals.map(ul).forEach((_, A)=>_.forEach(Gw(s[A], r.inputKeyVals[A], c.inputKeyVals[A]))), c.outputKeyVals.map(ul).forEach((_, A)=>_.forEach(Gw(a[A], r.outputKeyVals[A], c.outputKeyVals[A])));
    }
    return I7(i, {
        globalMapKeyVals: r.globalKeyVals,
        inputKeyVals: r.inputKeyVals,
        outputKeyVals: r.outputKeyVals
    });
}
function Gw(e, t, r) {
    return (n)=>{
        if (e.has(n)) return;
        const i = r.filter((o)=>rr(o.key) === n)[0];
        t.push(i), e.add(n);
    };
}
function Q4(e) {
    return e.globalMap.unsignedTx;
}
function ul(e) {
    const t = /* @__PURE__ */ new Set();
    return e.forEach((r)=>{
        const n = rr(r.key);
        if (t.has(n)) throw new Error("Combine: KeyValue Map keys should be unique");
        t.add(n);
    }), t;
}
function li(e, t) {
    const r = e[t];
    if (r === void 0) throw new Error(`No input #${t}`);
    return r;
}
function np(e, t) {
    const r = e[t];
    if (r === void 0) throw new Error(`No output #${t}`);
    return r;
}
function Zw(e, t, r) {
    if (e.key[0] < r) throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");
    if (t && t.filter((n)=>It(n.key, e.key) === 0).length !== 0) throw new Error(`Duplicate Key: ${rr(e.key)}`);
}
function Yw(e) {
    let t = 0;
    return Object.keys(e).forEach((r)=>{
        Number(isNaN(Number(r))) && t++;
    }), t;
}
function uV(e, t) {
    let r = !1;
    if (t.nonWitnessUtxo || t.witnessUtxo) {
        const n = !!t.redeemScript, i = !!t.witnessScript, o = !n || !!t.finalScriptSig, s = !i || !!t.finalScriptWitness, a = !!t.finalScriptSig || !!t.finalScriptWitness;
        r = o && s && a;
    }
    if (r === !1) throw new Error(`Input #${e} has too much or too little data to clean`);
}
function eA(e, t, r, n) {
    throw new Error(`Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`);
}
function l3(e) {
    return (t, r)=>{
        for (const n of Object.keys(t)){
            const i = t[n], { canAdd: o, canAddToArray: s, check: a, expected: u } = // @ts-ignore
            nV[e + "s"][n] || {}, f = !!s;
            if (a) if (f) {
                if (!Array.isArray(i) || // @ts-ignore
                r[n] && !Array.isArray(r[n])) throw new Error(`Key type ${n} must be an array`);
                i.every(a) || eA(e, n, u, i);
                const c = r[n] || [], l = /* @__PURE__ */ new Set();
                if (!i.every((p)=>s(c, p, l))) throw new Error("Can not add duplicate data to array");
                r[n] = c.concat(i);
            } else {
                if (a(i) || eA(e, n, u, i), !o(r, i)) throw new Error(`Can not add duplicate data to ${e}`);
                r[n] = i;
            }
        }
    };
}
const fV = l3("global"), B7 = l3("input"), O7 = l3("output");
function lV(e, t) {
    const r = e.length - 1, n = li(e, r);
    B7(t, n);
}
function dV(e, t) {
    const r = e.length - 1, n = np(e, r);
    O7(t, n);
}
let tA = class {
    constructor(t){
        this.inputs = [], this.outputs = [], this.globalMap = {
            unsignedTx: t
        };
    }
    static fromBase64(t, r) {
        const n = UB(t);
        return this.fromBuffer(n, r);
    }
    static fromHex(t, r) {
        const n = hc(t);
        return this.fromBuffer(n, r);
    }
    static fromBuffer(t, r) {
        const n = oV(t, r), i = new this(n.globalMap.unsignedTx);
        return Object.assign(i, n), i;
    }
    toBase64() {
        const t = this.toBuffer();
        return KH(t);
    }
    toHex() {
        const t = this.toBuffer();
        return rr(t);
    }
    toBuffer() {
        return sV(this);
    }
    updateGlobal(t) {
        return fV(t, this.globalMap), this;
    }
    updateInput(t, r) {
        const n = li(this.inputs, t);
        return B7(r, n), this;
    }
    updateOutput(t, r) {
        const n = np(this.outputs, t);
        return O7(r, n), this;
    }
    addUnknownKeyValToGlobal(t) {
        return Zw(t, this.globalMap.unknownKeyVals, Yw(ya)), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
    }
    addUnknownKeyValToInput(t, r) {
        const n = li(this.inputs, t);
        return Zw(r, n.unknownKeyVals, Yw(Dt)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
    }
    addUnknownKeyValToOutput(t, r) {
        const n = np(this.outputs, t);
        return Zw(r, n.unknownKeyVals, Yw($n)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
    }
    addInput(t) {
        this.globalMap.unsignedTx.addInput(t), this.inputs.push({
            unknownKeyVals: []
        });
        const r = t.unknownKeyVals || [], n = this.inputs.length - 1;
        if (!Array.isArray(r)) throw new Error("unknownKeyVals must be an Array");
        return r.forEach((i)=>this.addUnknownKeyValToInput(n, i)), lV(this.inputs, t), this;
    }
    addOutput(t) {
        this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
            unknownKeyVals: []
        });
        const r = t.unknownKeyVals || [], n = this.outputs.length - 1;
        if (!Array.isArray(r)) throw new Error("unknownKeyVals must be an Array");
        return r.forEach((i)=>this.addUnknownKeyValToOutput(n, i)), dV(this.outputs, t), this;
    }
    clearFinalizedInput(t) {
        const r = li(this.inputs, t);
        uV(t, r);
        for (const n of Object.keys(r))[
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
        ].includes(n) || delete r[n];
        return this;
    }
    combine(...t) {
        const r = cV([
            this
        ].concat(t));
        return Object.assign(this, r), this;
    }
    getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
    }
};
function Nf(e) {
    return (t)=>{
        try {
            return e({
                output: t
            }), !0;
        } catch  {
            return !1;
        }
    };
}
const hV = Nf(ab), pV = Nf(QB), gV = Nf(Vp), fb = Nf(Gp), rA = Nf(Zp), P7 = Nf(_d), N7 = Nf(xd);
function Qy(e) {
    let t = new Uint8Array(0);
    function r(s) {
        t = kn([
            t,
            s
        ]);
    }
    function n(s) {
        const a = t.length, u = ds(s);
        t = kn([
            t,
            new Uint8Array(u)
        ]), pu(s, t, a);
    }
    function i(s) {
        n(s.length), r(s);
    }
    function o(s) {
        n(s.length), s.forEach(i);
    }
    return o(e), t;
}
function M7(e, t) {
    const r = Rs(e), n = e.slice(1, 33), i = Sn(t);
    if (i === null) throw new Error("Unknown script error");
    return i.findIndex((o)=>typeof o == "number" ? !1 : It(e, o) === 0 || It(r, o) === 0 || It(n, o) === 0);
}
function lb(e, t) {
    return M7(e, t) !== -1;
}
function yV(e, t) {
    return mV(e).some((n)=>R7(n, Nh.decode, t));
}
function R7(e, t, r) {
    const { hashType: n } = t(e), i = [];
    switch(n & xn.SIGHASH_ANYONECANPAY && i.push("addInput"), n & 31){
        case xn.SIGHASH_ALL:
            break;
        case xn.SIGHASH_SINGLE:
        case xn.SIGHASH_NONE:
            i.push("addOutput"), i.push("setInputSequence");
            break;
    }
    return i.indexOf(r) === -1;
}
function mV(e) {
    let t = [];
    if ((e.partialSig || []).length === 0) {
        if (!e.finalScriptSig && !e.finalScriptWitness) return [];
        t = bV(e);
    } else t = e.partialSig;
    return t.map((r)=>r.signature);
}
function bV(e) {
    const t = e.finalScriptSig ? Sn(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? Sn(e.finalScriptWitness) || [] : [];
    return t.concat(r).filter((n)=>n instanceof Uint8Array && ac(n)).map((n)=>({
            signature: n
        }));
}
const Mo = (e)=>e.length === 32 ? e : e.slice(1, 33);
function nA(e, t, r) {
    const n = NV(t, e, r);
    try {
        const o = OV(t, n).concat(n.script).concat(n.controlBlock);
        return {
            finalScriptWitness: Qy(o)
        };
    } catch (i) {
        throw new Error(`Can not finalize taproot input #${e}: ${i}`);
    }
}
function Ig(e, t) {
    const r = t ? Uint8Array.from([
        t
    ]) : Uint8Array.from([]);
    return kn([
        e,
        r
    ]);
}
function Is(e) {
    return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && N7(e.witnessUtxo.script));
}
function Xw(e, t) {
    return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function iA(e, t, r) {
    kV(e, t, r), BV(e, t, r);
}
function oA(e, t, r) {
    IV(e, t, r), wV(e, t);
}
function wV(e, t) {
    if (!t.tapTree && !t.tapInternalKey) return;
    const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
    if (r) {
        const { script: i } = e, o = vV(r, n);
        if (i && It(o, i) !== 0) throw new Error("Error adding output. Script or address mismatch.");
    }
}
function vV(e, t) {
    const r = t && _V(t.leaves), { output: n } = xd({
        internalPubkey: e,
        scriptTree: r
    });
    return n;
}
function _V(e = []) {
    return e.length === 1 && e[0].depth === 0 ? {
        output: e[0].script,
        version: e[0].leafVersion
    } : TV(e);
}
function EV(e, t) {
    return SV(e).some((n)=>R7(n, xV, t));
}
function xV(e) {
    return {
        signature: e.slice(0, 64),
        hashType: e.slice(64)[0] || xn.SIGHASH_DEFAULT
    };
}
function SV(e) {
    const t = [];
    if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r)=>r.signature)), !t.length) {
        const r = AV(e.finalScriptWitness);
        r && t.push(r);
    }
    return t;
}
function AV(e) {
    if (!e) return;
    const t = e.slice(2);
    if (t.length === 64 || t.length === 65) return t;
}
function TV(e) {
    let t;
    for (const r of e)if (t = TE(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
    return t;
}
function TE(e, t, r = 0) {
    if (r > mK) throw new Error("Max taptree depth exceeded.");
    if (e.depth === r) return t ? void 0 : {
        output: e.script,
        version: e.leafVersion
    };
    if (Jx(t)) return;
    const n = TE(e, t && t[0], r + 1);
    if (n) return [
        n,
        t && t[1]
    ];
    const i = TE(e, t && t[1], r + 1);
    if (i) return [
        t && t[0],
        i
    ];
}
function kV(e, t, r) {
    const n = Is(e) && zl(t), i = zl(e) && Is(t), o = e === t && Is(t) && zl(t);
    if (n || i || o) throw new Error(`Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`);
}
function IV(e, t, r) {
    const n = Xw(e) && zl(t), i = zl(e) && Xw(t), o = e === t && Xw(t) && zl(t);
    if (n || i || o) throw new Error(`Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`);
}
function BV(e, t, r) {
    if (t.tapMerkleRoot) {
        const n = (t.tapLeafScript || []).every((o)=>Jw(o, t.tapMerkleRoot)), i = (e.tapLeafScript || []).every((o)=>Jw(o, t.tapMerkleRoot));
        if (!n || !i) throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
    } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every((i)=>Jw(i, e.tapMerkleRoot))) throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
}
function Jw(e, t) {
    if (!t) return !0;
    const r = tc({
        output: e.script,
        version: e.leafVersion
    }), n = EE(e.controlBlock, r);
    return It(n, t) === 0;
}
function OV(e, t) {
    const r = tc({
        output: t.script,
        version: t.leafVersion
    });
    return (e.tapScriptSig || []).filter((n)=>It(n.leafHash, r) === 0).map((n)=>PV(t.script, n)).sort((n, i)=>i.positionInScript - n.positionInScript).map((n)=>n.signature);
}
function PV(e, t) {
    return Object.assign({
        positionInScript: M7(t.pubkey, e)
    }, t);
}
function NV(e, t, r) {
    if (!e.tapScriptSig || !e.tapScriptSig.length) throw new Error(`Can not finalize taproot input #${t}. No tapleaf script signature provided.`);
    const n = (e.tapLeafScript || []).sort((i, o)=>i.controlBlock.length - o.controlBlock.length).find((i)=>MV(i, e.tapScriptSig, r));
    if (!n) throw new Error(`Can not finalize taproot input #${t}. Signature for tapleaf script not found.`);
    return n;
}
function MV(e, t, r) {
    const n = tc({
        output: e.script,
        version: e.leafVersion
    });
    return (!r || It(n, r) === 0) && t.find((o)=>It(o.leafHash, n) === 0) !== void 0;
}
function zl(e) {
    return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const RV = {
    /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */ network: zs,
    /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */ maximumFeeRate: 5e3
};
class Cr {
    constructor(t = {}, r = new tA(new C7())){
        pt(this, "data");
        pt(this, "__CACHE");
        pt(this, "opts");
        this.data = r, this.opts = Object.assign({}, RV, t), this.__CACHE = {
            __NON_WITNESS_UTXO_TX_CACHE: [],
            __NON_WITNESS_UTXO_BUF_CACHE: [],
            __TX_IN_CACHE: {},
            __TX: this.data.globalMap.unsignedTx.tx,
            // Psbt's predecessor (TransactionBuilder - now removed) behavior
            // was to not confirm input values  before signing.
            // Even though we highly encourage people to get
            // the full parent transaction to verify values, the ability to
            // sign non-segwit inputs without the full transaction was often
            // requested. So the only way to activate is to use @ts-ignore.
            // We will disable exporting the Psbt when unsafe sign is active.
            // because it is not BIP174 compliant.
            __UNSAFE_SIGN_NONSEGWIT: !1
        }, this.data.inputs.length === 0 && this.setVersion(2);
        const n = (i, o, s, a)=>Object.defineProperty(i, o, {
                enumerable: s,
                writable: a
            });
        n(this, "__CACHE", !1, !0), n(this, "opts", !1, !0);
    }
    static fromBase64(t, r = {}) {
        const n = UB(t);
        return this.fromBuffer(n, r);
    }
    static fromHex(t, r = {}) {
        const n = hc(t);
        return this.fromBuffer(n, r);
    }
    static fromBuffer(t, r = {}) {
        const n = tA.fromBuffer(t, CV), i = new Cr(r, n);
        return FV(i.__CACHE.__TX, i.__CACHE), i;
    }
    get inputCount() {
        return this.data.inputs.length;
    }
    get version() {
        return this.__CACHE.__TX.version;
    }
    set version(t) {
        this.setVersion(t);
    }
    get locktime() {
        return this.__CACHE.__TX.locktime;
    }
    set locktime(t) {
        this.setLocktime(t);
    }
    get txInputs() {
        return this.__CACHE.__TX.ins.map((t)=>({
                hash: V4(t.hash),
                index: t.index,
                sequence: t.sequence
            }));
    }
    get txOutputs() {
        return this.__CACHE.__TX.outs.map((t)=>{
            let r;
            try {
                r = Yp(t.script, this.opts.network);
            } catch  {}
            return {
                script: V4(t.script),
                value: t.value,
                address: r
            };
        });
    }
    combine(...t) {
        return this.data.combine(...t.map((r)=>r.data)), this;
    }
    clone() {
        const t = Cr.fromBuffer(this.data.toBuffer());
        return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
    }
    setMaximumFeeRate(t) {
        Bg(t), this.opts.maximumFeeRate = t;
    }
    setVersion(t) {
        Bg(t), fh(this.data.inputs, "setVersion");
        const r = this.__CACHE;
        return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
    }
    setLocktime(t) {
        Bg(t), fh(this.data.inputs, "setLocktime");
        const r = this.__CACHE;
        return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
    }
    setInputSequence(t, r) {
        Bg(r), fh(this.data.inputs, "setInputSequence");
        const n = this.__CACHE;
        if (n.__TX.ins.length <= t) throw new Error("Input index too high");
        return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
    }
    addInputs(t) {
        return t.forEach((r)=>this.addInput(r)), this;
    }
    addInput(t) {
        if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0) throw new Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");
        iA(t, t, "addInput"), fh(this.data.inputs, "addInput"), t.witnessScript && em(t.witnessScript);
        const r = this.__CACHE;
        this.data.addInput(t);
        const n = r.__TX.ins[r.__TX.ins.length - 1];
        L7(r, n);
        const i = this.data.inputs.length - 1, o = this.data.inputs[i];
        return o.nonWitnessUtxo && IE(this.__CACHE, o, i), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
    }
    addOutputs(t) {
        return t.forEach((r)=>this.addOutput(r)), this;
    }
    addOutput(t) {
        if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0) throw new Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");
        fh(this.data.inputs, "addOutput");
        const { address: r } = t;
        if (typeof r == "string") {
            const { network: i } = this.opts, o = hs(r, i);
            t = Object.assign({}, t, {
                script: o
            });
        }
        oA(t, t, "addOutput");
        const n = this.__CACHE;
        return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
    }
    extractTransaction(t) {
        if (!this.data.inputs.every(U7)) throw new Error("Not finalized");
        const r = this.__CACHE;
        if (t || $V(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
        const n = r.__TX.clone();
        return q7(this.data.inputs, n, r, !0), n;
    }
    getFeeRate() {
        return fA("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
    }
    getFee() {
        return fA("__FEE", "fee", this.data.inputs, this.__CACHE);
    }
    finalizeAllInputs() {
        return li(this.data.inputs, 0), lh(this.data.inputs.length).forEach((t)=>this.finalizeInput(t)), this;
    }
    finalizeInput(t, r) {
        const n = li(this.data.inputs, t);
        return Is(n) ? this._finalizeTaprootInput(t, n, void 0, r) : this._finalizeInput(t, n, r);
    }
    finalizeTaprootInput(t, r, n = nA) {
        const i = li(this.data.inputs, t);
        if (Is(i)) return this._finalizeTaprootInput(t, i, r, n);
        throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
    }
    _finalizeInput(t, r, n = zV) {
        const { script: i, isP2SH: o, isP2WSH: s, isSegwit: a } = KV(t, r, this.__CACHE);
        if (!i) throw new Error(`No script found for input #${t}`);
        LV(r);
        const { finalScriptSig: u, finalScriptWitness: f } = n(t, r, i, a, o, s);
        if (u && this.data.updateInput(t, {
            finalScriptSig: u
        }), f && this.data.updateInput(t, {
            finalScriptWitness: f
        }), !u && !f) throw new Error(`Unknown error finalizing input #${t}`);
        return this.data.clearFinalizedInput(t), this;
    }
    _finalizeTaprootInput(t, r, n, i = nA) {
        if (!r.witnessUtxo) throw new Error(`Cannot finalize input #${t}. Missing withness utxo.`);
        if (r.tapKeySig) {
            const o = xd({
                output: r.witnessUtxo.script,
                signature: r.tapKeySig
            }), s = Qy(o.witness);
            this.data.updateInput(t, {
                finalScriptWitness: s
            });
        } else {
            const { finalScriptWitness: o } = i(t, r, n);
            this.data.updateInput(t, {
                finalScriptWitness: o
            });
        }
        return this.data.clearFinalizedInput(t), this;
    }
    getInputType(t) {
        const r = li(this.data.inputs, t), n = K7(t, r, this.__CACHE), i = hb(n, t, "input", r.redeemScript || YV(r.finalScriptSig), r.witnessScript || XV(r.finalScriptWitness)), o = i.type === "raw" ? "" : i.type + "-", s = V7(i.meaningfulScript);
        return o + s;
    }
    inputHasPubkey(t, r) {
        const n = li(this.data.inputs, t);
        return GV(r, n, t, this.__CACHE);
    }
    inputHasHDKey(t, r) {
        const n = li(this.data.inputs, t), i = aA(r);
        return !!n.bip32Derivation && n.bip32Derivation.some(i);
    }
    outputHasPubkey(t, r) {
        const n = np(this.data.outputs, t);
        return ZV(r, n, t, this.__CACHE);
    }
    outputHasHDKey(t, r) {
        const n = np(this.data.outputs, t), i = aA(r);
        return !!n.bip32Derivation && n.bip32Derivation.some(i);
    }
    validateSignaturesOfAllInputs(t) {
        return li(this.data.inputs, 0), lh(this.data.inputs.length).map((n)=>this.validateSignaturesOfInput(n, t)).reduce((n, i)=>i === !0 && n, !0);
    }
    validateSignaturesOfInput(t, r, n) {
        const i = this.data.inputs[t];
        return Is(i) ? this.validateSignaturesOfTaprootInput(t, r, n) : this._validateSignaturesOfInput(t, r, n);
    }
    _validateSignaturesOfInput(t, r, n) {
        const i = this.data.inputs[t], o = (i || {}).partialSig;
        if (!i || !o || o.length < 1) throw new Error("No signatures to validate");
        if (typeof r != "function") throw new Error("Need validator function to validate signatures");
        const s = n ? o.filter((l)=>It(l.pubkey, n) === 0) : o;
        if (s.length < 1) throw new Error("No signatures for this pubkey");
        const a = [];
        let u, f, c;
        for (const l of s){
            const p = Nh.decode(l.signature), { hash: y, script: _ } = c !== p.hashType ? F7(t, Object.assign({}, i, {
                sighashType: p.hashType
            }), this.__CACHE, !0) : {
                hash: u,
                script: f
            };
            c = p.hashType, u = y, f = _, $7(l.pubkey, _, "verify"), a.push(r(l.pubkey, y, p.signature));
        }
        return a.every((l)=>l === !0);
    }
    validateSignaturesOfTaprootInput(t, r, n) {
        const i = this.data.inputs[t], o = (i || {}).tapKeySig, s = (i || {}).tapScriptSig;
        if (!i && !o && !(s && !s.length)) throw new Error("No signatures to validate");
        if (typeof r != "function") throw new Error("Need validator function to validate signatures");
        n = n && Mo(n);
        const a = n ? kE(t, i, this.data.inputs, n, this.__CACHE) : HV(t, i, this.data.inputs, this.__CACHE);
        if (!a.length) throw new Error("No signatures for this pubkey");
        const u = a.find((c)=>!c.leafHash);
        let f = 0;
        if (o && u) {
            if (!r(u.pubkey, u.hash, dA(o))) return !1;
            f++;
        }
        if (s) for (const c of s){
            const l = a.find((p)=>It(p.pubkey, c.pubkey) === 0);
            if (l) {
                if (!r(c.pubkey, l.hash, dA(c.signature))) return !1;
                f++;
            }
        }
        return f > 0;
    }
    signAllInputsHD(t, r = [
        xn.SIGHASH_ALL
    ]) {
        if (!t || !t.publicKey || !t.fingerprint) throw new Error("Need HDSigner to sign input");
        const n = [];
        for (const i of lh(this.data.inputs.length))try {
            this.signInputHD(i, t, r), n.push(!0);
        } catch  {
            n.push(!1);
        }
        if (n.every((i)=>i === !1)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsHDAsync(t, r = [
        xn.SIGHASH_ALL
    ]) {
        return new Promise((n, i)=>{
            if (!t || !t.publicKey || !t.fingerprint) return i(new Error("Need HDSigner to sign input"));
            const o = [], s = [];
            for (const a of lh(this.data.inputs.length))s.push(this.signInputHDAsync(a, t, r).then(()=>{
                o.push(!0);
            }, ()=>{
                o.push(!1);
            }));
            return Promise.all(s).then(()=>{
                if (o.every((a)=>a === !1)) return i(new Error("No inputs were signed"));
                n();
            });
        });
    }
    signInputHD(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        if (!r || !r.publicKey || !r.fingerprint) throw new Error("Need HDSigner to sign input");
        return hA(t, this.data.inputs, r).forEach((o)=>this.signInput(t, o, n)), this;
    }
    signInputHDAsync(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        return new Promise((i, o)=>{
            if (!r || !r.publicKey || !r.fingerprint) return o(new Error("Need HDSigner to sign input"));
            const a = hA(t, this.data.inputs, r).map((u)=>this.signInputAsync(t, u, n));
            return Promise.all(a).then(()=>{
                i();
            }).catch(o);
        });
    }
    signAllInputs(t, r) {
        if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
        const n = [];
        for (const i of lh(this.data.inputs.length))try {
            this.signInput(i, t, r), n.push(!0);
        } catch  {
            n.push(!1);
        }
        if (n.every((i)=>i === !1)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsAsync(t, r) {
        return new Promise((n, i)=>{
            if (!t || !t.publicKey) return i(new Error("Need Signer to sign input"));
            const o = [], s = [];
            for (const [a] of this.data.inputs.entries())s.push(this.signInputAsync(a, t, r).then(()=>{
                o.push(!0);
            }, ()=>{
                o.push(!1);
            }));
            return Promise.all(s).then(()=>{
                if (o.every((a)=>a === !1)) return i(new Error("No inputs were signed"));
                n();
            });
        });
    }
    signInput(t, r, n) {
        if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
        const i = li(this.data.inputs, t);
        return Is(i) ? this._signTaprootInput(t, i, r, void 0, n) : this._signInput(t, r, n);
    }
    signTaprootInput(t, r, n, i) {
        if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
        const o = li(this.data.inputs, t);
        if (Is(o)) return this._signTaprootInput(t, o, r, n, i);
        throw new Error(`Input #${t} is not of type Taproot.`);
    }
    _signInput(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        const { hash: i, sighashType: o } = lA(this.data.inputs, t, r.publicKey, this.__CACHE, n), s = [
            {
                pubkey: r.publicKey,
                signature: Nh.encode(r.sign(i), o)
            }
        ];
        return this.data.updateInput(t, {
            partialSig: s
        }), this;
    }
    _signTaprootInput(t, r, n, i, o = [
        xn.SIGHASH_DEFAULT
    ]) {
        const s = this.checkTaprootHashesForSig(t, r, n, i, o), a = s.filter((f)=>!f.leafHash).map((f)=>Ig(n.signSchnorr(f.hash), r.sighashType))[0], u = s.filter((f)=>!!f.leafHash).map((f)=>({
                pubkey: Mo(n.publicKey),
                signature: Ig(n.signSchnorr(f.hash), r.sighashType),
                leafHash: f.leafHash
            }));
        return a && this.data.updateInput(t, {
            tapKeySig: a
        }), u.length && this.data.updateInput(t, {
            tapScriptSig: u
        }), this;
    }
    signInputAsync(t, r, n) {
        return Promise.resolve().then(()=>{
            if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
            const i = li(this.data.inputs, t);
            return Is(i) ? this._signTaprootInputAsync(t, i, r, void 0, n) : this._signInputAsync(t, r, n);
        });
    }
    signTaprootInputAsync(t, r, n, i) {
        return Promise.resolve().then(()=>{
            if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
            const o = li(this.data.inputs, t);
            if (Is(o)) return this._signTaprootInputAsync(t, o, r, n, i);
            throw new Error(`Input #${t} is not of type Taproot.`);
        });
    }
    _signInputAsync(t, r, n = [
        xn.SIGHASH_ALL
    ]) {
        const { hash: i, sighashType: o } = lA(this.data.inputs, t, r.publicKey, this.__CACHE, n);
        return Promise.resolve(r.sign(i)).then((s)=>{
            const a = [
                {
                    pubkey: r.publicKey,
                    signature: Nh.encode(s, o)
                }
            ];
            this.data.updateInput(t, {
                partialSig: a
            });
        });
    }
    async _signTaprootInputAsync(t, r, n, i, o = [
        xn.SIGHASH_DEFAULT
    ]) {
        const s = this.checkTaprootHashesForSig(t, r, n, i, o), a = [], u = s.filter((c)=>!c.leafHash)[0];
        if (u) {
            const c = Promise.resolve(n.signSchnorr(u.hash)).then((l)=>({
                    tapKeySig: Ig(l, r.sighashType)
                }));
            a.push(c);
        }
        const f = s.filter((c)=>!!c.leafHash);
        if (f.length) {
            const c = f.map((l)=>Promise.resolve(n.signSchnorr(l.hash)).then((p)=>({
                        tapScriptSig: [
                            {
                                pubkey: Mo(n.publicKey),
                                signature: Ig(p, r.sighashType),
                                leafHash: l.leafHash
                            }
                        ]
                    })));
            a.push(...c);
        }
        return Promise.all(a).then((c)=>{
            c.forEach((l)=>this.data.updateInput(t, l));
        });
    }
    checkTaprootHashesForSig(t, r, n, i, o) {
        if (typeof n.signSchnorr != "function") throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
        const s = kE(t, r, this.data.inputs, n.publicKey, this.__CACHE, i, o);
        if (!s || !s.length) throw new Error(`Can not sign for input #${t} with the key ${rr(n.publicKey)}`);
        return s;
    }
    toBuffer() {
        return Qw(this.__CACHE), this.data.toBuffer();
    }
    toHex() {
        return Qw(this.__CACHE), this.data.toHex();
    }
    toBase64() {
        return Qw(this.__CACHE), this.data.toBase64();
    }
    updateGlobal(t) {
        return this.data.updateGlobal(t), this;
    }
    updateInput(t, r) {
        return r.witnessScript && em(r.witnessScript), iA(this.data.inputs[t], r, "updateInput"), this.data.updateInput(t, r), r.nonWitnessUtxo && IE(this.__CACHE, this.data.inputs[t], t), this;
    }
    updateOutput(t, r) {
        const n = this.data.outputs[t];
        return oA(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
    }
    addUnknownKeyValToGlobal(t) {
        return this.data.addUnknownKeyValToGlobal(t), this;
    }
    addUnknownKeyValToInput(t, r) {
        return this.data.addUnknownKeyValToInput(t, r), this;
    }
    addUnknownKeyValToOutput(t, r) {
        return this.data.addUnknownKeyValToOutput(t, r), this;
    }
    clearFinalizedInput(t) {
        return this.data.clearFinalizedInput(t), this;
    }
}
const CV = (e)=>new C7(e);
class C7 {
    constructor(t = Uint8Array.from([
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ])){
        pt(this, "tx");
        this.tx = xn.fromBuffer(t), DV(this.tx), Object.defineProperty(this, "tx", {
            enumerable: !1,
            writable: !0
        });
    }
    getInputOutputCounts() {
        return {
            inputCount: this.tx.ins.length,
            outputCount: this.tx.outs.length
        };
    }
    addInput(t) {
        if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number") throw new Error("Error adding input.");
        const r = typeof t.hash == "string" ? s3(hc(t.hash)) : t.hash;
        this.tx.addInput(r, t.index, t.sequence);
    }
    addOutput(t) {
        if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint") throw new Error("Error adding output.");
        this.tx.addOutput(t.script, t.value);
    }
    toBuffer() {
        return this.tx.toBuffer();
    }
}
function UV(e, t, r) {
    switch(r){
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
            return sA(1, e.partialSig);
        case "multisig":
            const n = ab({
                output: t
            });
            return sA(n.m, e.partialSig, n.pubkeys);
        default:
            return !1;
    }
}
function Qw(e) {
    if (e.__UNSAFE_SIGN_NONSEGWIT !== !1) throw new Error("Not BIP174 compliant, can not export");
}
function sA(e, t, r) {
    if (!t) return !1;
    let n;
    if (r ? n = r.map((i)=>{
        const o = JV(i);
        return t.find((s)=>It(s.pubkey, o) === 0);
    }).filter((i)=>!!i) : n = t, n.length > e) throw new Error("Too many signatures");
    return n.length === e;
}
function U7(e) {
    return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function aA(e) {
    return (t)=>!(It(e.fingerprint, t.masterFingerprint) || It(e.derivePath(t.path).publicKey, t.pubkey));
}
function Bg(e) {
    if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0) throw new Error("Invalid 32 bit integer");
}
function $V(e, t, r) {
    const n = t.__FEE_RATE || e.getFeeRate(), i = t.__EXTRACTED_TX.virtualSize(), o = n * i;
    if (n >= r.maximumFeeRate) throw new Error(`Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`);
}
function fh(e, t) {
    e.forEach((r)=>{
        if (Is(r) ? EV(r, t) : yV(r, t)) throw new Error("Can not modify transaction, signatures exist.");
    });
}
function LV(e) {
    if (!e.sighashType || !e.partialSig) return;
    const { partialSig: t, sighashType: r } = e;
    t.forEach((n)=>{
        const { hashType: i } = Nh.decode(n.signature);
        if (r !== i) throw new Error("Signature sighash does not match input sighash type");
    });
}
function $7(e, t, r) {
    if (!lb(e, t)) throw new Error(`Can not ${r} for this input with the key ${rr(e)}`);
}
function DV(e) {
    if (!e.ins.every((r)=>r.script && r.script.length === 0 && r.witness && r.witness.length === 0)) throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function FV(e, t) {
    e.ins.forEach((r)=>{
        L7(t, r);
    });
}
function L7(e, t) {
    const r = rr(s3(Uint8Array.from(t.hash))) + ":" + t.index;
    if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
    e.__TX_IN_CACHE[r] = 1;
}
function D7(e, t) {
    return (r, n, i, o)=>{
        const s = e({
            redeem: {
                output: i
            }
        }).output;
        if (It(n, s)) throw new Error(`${t} for ${o} #${r} doesn't match the scriptPubKey in the prevout`);
    };
}
const cA = D7(_d, "Redeem script"), uA = D7(Zp, "Witness script");
function fA(e, t, r, n) {
    if (!r.every(U7)) throw new Error(`PSBT must be finalized to calculate ${t}`);
    if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
    if (e === "__FEE" && n.__FEE) return n.__FEE;
    let i, o = !0;
    if (n.__EXTRACTED_TX ? (i = n.__EXTRACTED_TX, o = !1) : i = n.__TX.clone(), q7(r, i, n, o), e === "__FEE_RATE") return n.__FEE_RATE;
    if (e === "__FEE") return n.__FEE;
}
function zV(e, t, r, n, i, o) {
    const s = V7(r);
    if (!UV(t, r, s)) throw new Error(`Can not finalize input #${e}`);
    return jV(r, s, t.partialSig, n, i, o);
}
function jV(e, t, r, n, i, o) {
    let s, a;
    const u = qV(e, t, r), f = o ? Zp({
        redeem: u
    }) : null, c = i ? _d({
        redeem: f || u
    }) : null;
    return n ? (f ? a = Qy(f.witness) : a = Qy(u.witness), c && (s = c.input)) : c ? s = c.input : s = u.input, {
        finalScriptSig: s,
        finalScriptWitness: a
    };
}
function lA(e, t, r, n, i) {
    const o = li(e, t), { hash: s, sighashType: a, script: u } = F7(t, o, n, !1, i);
    return $7(r, u, "sign"), {
        hash: s,
        sighashType: a
    };
}
function F7(e, t, r, n, i) {
    const o = r.__TX, s = t.sighashType || xn.SIGHASH_ALL;
    j7(s, i);
    let a, u;
    if (t.nonWitnessUtxo) {
        const l = db(r, t, e), p = o.ins[e].hash, y = l.getHash();
        if (It(p, y) !== 0) throw new Error(`Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`);
        const _ = o.ins[e].index;
        u = l.outs[_];
    } else if (t.witnessUtxo) u = t.witnessUtxo;
    else throw new Error("Need a Utxo input item for signing");
    const { meaningfulScript: f, type: c } = hb(u.script, e, "input", t.redeemScript, t.witnessScript);
    if ([
        "p2sh-p2wsh",
        "p2wsh"
    ].indexOf(c) >= 0) a = o.hashForWitnessV0(e, f, u.value, s);
    else if (fb(f)) {
        const l = Vp({
            hash: f.slice(2)
        }).output;
        a = o.hashForWitnessV0(e, l, u.value, s);
    } else {
        if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1) throw new Error(`Input #${e} has witnessUtxo but non-segwit script: ${rr(f)}`);
        !n && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(`Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`), a = o.hashForSignature(e, f, s);
    }
    return {
        script: f,
        sighashType: s,
        hash: a
    };
}
function HV(e, t, r, n) {
    const i = [];
    if (t.tapInternalKey) {
        const s = z7(e, t, n);
        s && i.push(s);
    }
    if (t.tapScriptSig) {
        const s = t.tapScriptSig.map((a)=>a.pubkey);
        i.push(...s);
    }
    return i.map((s)=>kE(e, t, r, s, n)).flat();
}
function z7(e, t, r) {
    const { script: n } = d3(e, t, r);
    return N7(n) ? n.subarray(2, 34) : null;
}
function dA(e) {
    return e.length === 64 ? e : e.subarray(0, 64);
}
function kE(e, t, r, n, i, o, s) {
    const a = i.__TX, u = t.sighashType || xn.SIGHASH_DEFAULT;
    j7(u, s);
    const f = r.map((_, A)=>d3(A, _, i)), c = f.map((_)=>_.script), l = f.map((_)=>_.value), p = [];
    if (t.tapInternalKey && !o) {
        const _ = z7(e, t, i) || Uint8Array.from([]);
        if (It(Mo(n), _) === 0) {
            const A = a.hashForWitnessV1(e, c, l, u);
            p.push({
                pubkey: n,
                hash: A
            });
        }
    }
    const y = (t.tapLeafScript || []).filter((_)=>lb(n, _.script)).map((_)=>{
        const A = tc({
            output: _.script,
            version: _.leafVersion
        });
        return Object.assign({
            hash: A
        }, _);
    }).filter((_)=>!o || It(o, _.hash) === 0).map((_)=>{
        const A = a.hashForWitnessV1(e, c, l, u, _.hash);
        return {
            pubkey: n,
            hash: A,
            leafHash: _.hash
        };
    });
    return p.concat(y);
}
function j7(e, t) {
    if (t && t.indexOf(e) < 0) {
        const r = VV(e);
        throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`);
    }
}
function qV(e, t, r) {
    let n;
    switch(t){
        case "multisig":
            const i = WV(e, r);
            n = ab({
                output: e,
                signatures: i
            });
            break;
        case "pubkey":
            n = QB({
                output: e,
                signature: r[0].signature
            });
            break;
        case "pubkeyhash":
            n = Vp({
                output: e,
                pubkey: r[0].pubkey,
                signature: r[0].signature
            });
            break;
        case "witnesspubkeyhash":
            n = Gp({
                output: e,
                pubkey: r[0].pubkey,
                signature: r[0].signature
            });
            break;
    }
    return n;
}
function KV(e, t, r) {
    const n = r.__TX, i = {
        script: null,
        isSegwit: !1,
        isP2SH: !1,
        isP2WSH: !1
    };
    if (i.isP2SH = !!t.redeemScript, i.isP2WSH = !!t.witnessScript, t.witnessScript) i.script = t.witnessScript;
    else if (t.redeemScript) i.script = t.redeemScript;
    else if (t.nonWitnessUtxo) {
        const o = db(r, t, e), s = n.ins[e].index;
        i.script = o.outs[s].script;
    } else t.witnessUtxo && (i.script = t.witnessUtxo.script);
    return (t.witnessScript || fb(i.script)) && (i.isSegwit = !0), i;
}
function hA(e, t, r) {
    const n = li(t, e);
    if (!n.bip32Derivation || n.bip32Derivation.length === 0) throw new Error("Need bip32Derivation to sign with HD");
    const i = n.bip32Derivation.map((s)=>{
        if (It(s.masterFingerprint, r.fingerprint) === 0) return s;
    }).filter((s)=>!!s);
    if (i.length === 0) throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
    return i.map((s)=>{
        const a = r.derivePath(s.path);
        if (It(s.pubkey, a.publicKey) !== 0) throw new Error("pubkey did not match bip32Derivation");
        return a;
    });
}
function WV(e, t) {
    return ab({
        output: e
    }).pubkeys.map((n)=>(t.filter((i)=>It(i.pubkey, n) === 0)[0] || {}).signature).filter((n)=>!!n);
}
function H7(e) {
    let t = 0;
    function r(s) {
        return t += s, e.slice(t - s, t);
    }
    function n() {
        const s = Ed(e, t);
        return t += ds(s.bigintValue), s.numberValue;
    }
    function i() {
        return r(n());
    }
    function o() {
        const s = n(), a = [];
        for(let u = 0; u < s; u++)a.push(i());
        return a;
    }
    return o();
}
function VV(e) {
    let t = e & xn.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
    switch(e & 31){
        case xn.SIGHASH_ALL:
            t += "SIGHASH_ALL";
            break;
        case xn.SIGHASH_SINGLE:
            t += "SIGHASH_SINGLE";
            break;
        case xn.SIGHASH_NONE:
            t += "SIGHASH_NONE";
            break;
    }
    return t;
}
function IE(e, t, r) {
    e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
    const n = xn.fromBuffer(t.nonWitnessUtxo);
    e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
    const i = e, o = r;
    delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
        enumerable: !0,
        get () {
            const s = i.__NON_WITNESS_UTXO_BUF_CACHE[o], a = i.__NON_WITNESS_UTXO_TX_CACHE[o];
            if (s !== void 0) return s;
            {
                const u = a.toBuffer();
                return i.__NON_WITNESS_UTXO_BUF_CACHE[o] = u, u;
            }
        },
        set (s) {
            i.__NON_WITNESS_UTXO_BUF_CACHE[o] = s;
        }
    });
}
function q7(e, t, r, n) {
    let i = 0n;
    e.forEach((u, f)=>{
        if (n && u.finalScriptSig && (t.ins[f].script = u.finalScriptSig), n && u.finalScriptWitness && (t.ins[f].witness = H7(u.finalScriptWitness)), u.witnessUtxo) i += u.witnessUtxo.value;
        else if (u.nonWitnessUtxo) {
            const c = db(r, u, f), l = t.ins[f].index, p = c.outs[l];
            i += p.value;
        }
    });
    const o = t.outs.reduce((u, f)=>u + f.value, 0n), s = i - o;
    if (s < 0) throw new Error("Outputs are spending more than Inputs");
    const a = t.virtualSize();
    r.__FEE = s, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(s / BigInt(a)));
}
function db(e, t, r) {
    const n = e.__NON_WITNESS_UTXO_TX_CACHE;
    return n[r] || IE(e, t, r), n[r];
}
function K7(e, t, r) {
    const { script: n } = d3(e, t, r);
    return n;
}
function d3(e, t, r) {
    if (t.witnessUtxo !== void 0) return {
        script: t.witnessUtxo.script,
        value: t.witnessUtxo.value
    };
    if (t.nonWitnessUtxo !== void 0) {
        const i = db(r, t, e).outs[r.__TX.ins[e].index];
        return {
            script: i.script,
            value: i.value
        };
    } else throw new Error("Can't find pubkey in input without Utxo data");
}
function GV(e, t, r, n) {
    const i = K7(r, t, n), { meaningfulScript: o } = hb(i, r, "input", t.redeemScript, t.witnessScript);
    return lb(e, o);
}
function ZV(e, t, r, n) {
    const i = n.__TX.outs[r].script, { meaningfulScript: o } = hb(i, r, "output", t.redeemScript, t.witnessScript);
    return lb(e, o);
}
function YV(e) {
    if (!e) return;
    const t = Sn(e);
    if (!t) return;
    const r = t[t.length - 1];
    if (!(!(r instanceof Uint8Array) || W7(r) || QV(r) || !Sn(r))) return r;
}
function XV(e) {
    if (!e) return;
    const t = H7(e), r = t[t.length - 1];
    if (!(W7(r) || !Sn(r))) return r;
}
function JV(e) {
    if (e.length === 65) {
        const t = e[64] & 1, r = e.slice(0, 33);
        return r[0] = 2 | t, r;
    }
    return e.slice();
}
function W7(e) {
    return e.length === 33 && yq(e);
}
function QV(e) {
    return ac(e);
}
function hb(e, t, r, n, i) {
    const o = P7(e), s = o && n && rA(n), a = rA(e);
    if (o && n === void 0) throw new Error("scriptPubkey is P2SH but redeemScript missing");
    if ((a || s) && i === void 0) throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    let u;
    return s ? (u = i, cA(t, e, n, r), uA(t, n, i, r), em(u)) : a ? (u = i, uA(t, e, i, r), em(u)) : o ? (u = n, cA(t, e, n, r)) : u = e, {
        meaningfulScript: u,
        type: s ? "p2sh-p2wsh" : o ? "p2sh" : a ? "p2wsh" : "raw"
    };
}
function em(e) {
    if (fb(e) || P7(e)) throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function V7(e) {
    return fb(e) ? "witnesspubkeyhash" : gV(e) ? "pubkeyhash" : hV(e) ? "multisig" : pV(e) ? "pubkey" : "nonstandard";
}
function lh(e) {
    return [
        ...Array(e).keys()
    ];
}
function eG(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var G7 = {
    exports: {}
}, Dn = G7.exports = {}, ua, fa;
function BE() {
    throw new Error("setTimeout has not been defined");
}
function OE() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        typeof setTimeout == "function" ? ua = setTimeout : ua = BE;
    } catch  {
        ua = BE;
    }
    try {
        typeof clearTimeout == "function" ? fa = clearTimeout : fa = OE;
    } catch  {
        fa = OE;
    }
})();
function Z7(e) {
    if (ua === setTimeout) return setTimeout(e, 0);
    if ((ua === BE || !ua) && setTimeout) return ua = setTimeout, setTimeout(e, 0);
    try {
        return ua(e, 0);
    } catch  {
        try {
            return ua.call(null, e, 0);
        } catch  {
            return ua.call(this, e, 0);
        }
    }
}
function tG(e) {
    if (fa === clearTimeout) return clearTimeout(e);
    if ((fa === OE || !fa) && clearTimeout) return fa = clearTimeout, clearTimeout(e);
    try {
        return fa(e);
    } catch  {
        try {
            return fa.call(null, e);
        } catch  {
            return fa.call(this, e);
        }
    }
}
var rc = [], jl = !1, rf, Sy = -1;
function rG() {
    !jl || !rf || (jl = !1, rf.length ? rc = rf.concat(rc) : Sy = -1, rc.length && Y7());
}
function Y7() {
    if (!jl) {
        var e = Z7(rG);
        jl = !0;
        for(var t = rc.length; t;){
            for(rf = rc, rc = []; ++Sy < t;)rf && rf[Sy].run();
            Sy = -1, t = rc.length;
        }
        rf = null, jl = !1, tG(e);
    }
}
Dn.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)t[r - 1] = arguments[r];
    rc.push(new X7(e, t)), rc.length === 1 && !jl && Z7(Y7);
};
function X7(e, t) {
    this.fun = e, this.array = t;
}
X7.prototype.run = function() {
    this.fun.apply(null, this.array);
};
Dn.title = "browser";
Dn.browser = !0;
Dn.env = {};
Dn.argv = [];
Dn.version = "";
Dn.versions = {};
function pc() {}
Dn.on = pc;
Dn.addListener = pc;
Dn.once = pc;
Dn.off = pc;
Dn.removeListener = pc;
Dn.removeAllListeners = pc;
Dn.emit = pc;
Dn.prependListener = pc;
Dn.prependOnceListener = pc;
Dn.listeners = function(e) {
    return [];
};
Dn.binding = function(e) {
    throw new Error("process.binding is not supported");
};
Dn.cwd = function() {
    return "/";
};
Dn.chdir = function(e) {
    throw new Error("process.chdir is not supported");
};
Dn.umask = function() {
    return 0;
};
var nG = G7.exports;
const bn = /* @__PURE__ */ eG(nG);
let PE = Symbol("clean"), xs = [], Mc = 0;
const Og = 4;
let NE = (e)=>{
    let t = [], r = {
        get () {
            return r.lc || r.listen(()=>{})(), r.value;
        },
        lc: 0,
        listen (n) {
            return r.lc = t.push(n), ()=>{
                for(let o = Mc + Og; o < xs.length;)xs[o] === n ? xs.splice(o, Og) : o += Og;
                let i = t.indexOf(n);
                ~i && (t.splice(i, 1), --r.lc || r.off());
            };
        },
        notify (n, i) {
            let o = !xs.length;
            for (let s of t)xs.push(s, r.value, n, i);
            if (o) {
                for(Mc = 0; Mc < xs.length; Mc += Og)xs[Mc](xs[Mc + 1], xs[Mc + 2], xs[Mc + 3]);
                xs.length = 0;
            }
        },
        /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */ off () {},
        set (n) {
            let i = r.value;
            i !== n && (r.value = n, r.notify(i));
        },
        subscribe (n) {
            let i = r.listen(n);
            return n(r.value), i;
        },
        value: e
    };
    return bn.env.NODE_ENV !== "production" && (r[PE] = ()=>{
        t = [], r.lc = 0, r.off();
    }), r;
};
const iG = 5, fl = 6, Pg = 10;
let oG = (e, t, r, n)=>(e.events = e.events || {}, e.events[r + Pg] || (e.events[r + Pg] = n((i)=>{
        e.events[r].reduceRight((o, s)=>(s(o), o), {
            shared: {},
            ...i
        });
    })), e.events[r] = e.events[r] || [], e.events[r].push(t), ()=>{
        let i = e.events[r], o = i.indexOf(t);
        i.splice(o, 1), i.length || (delete e.events[r], e.events[r + Pg](), delete e.events[r + Pg]);
    }), sG = 1e3, aG = (e, t)=>oG(e, (n)=>{
        let i = t(n);
        i && e.events[fl].push(i);
    }, iG, (n)=>{
        let i = e.listen;
        e.listen = (...s)=>(!e.lc && !e.active && (e.active = !0, n()), i(...s));
        let o = e.off;
        if (e.events[fl] = [], e.off = ()=>{
            o(), setTimeout(()=>{
                if (e.active && !e.lc) {
                    e.active = !1;
                    for (let s of e.events[fl])s();
                    e.events[fl] = [];
                }
            }, sG);
        }, bn.env.NODE_ENV !== "production") {
            let s = e[PE];
            e[PE] = ()=>{
                for (let a of e.events[fl])a();
                e.events[fl] = [], e.active = !1, s();
            };
        }
        return ()=>{
            e.listen = i, e.off = o;
        };
    }), cG = (e)=>{
    e.listen(()=>{});
};
function $o(e, t, r) {
    let n = new Set(t).add(void 0);
    return e.listen((i, o, s)=>{
        n.has(s) && r(i, o, s);
    });
}
let J7 = (e = {})=>{
    let t = NE(e);
    return t.setKey = function(r, n) {
        let i = t.value;
        typeof n > "u" && r in t.value ? (t.value = {
            ...t.value
        }, delete t.value[r], t.notify(i, r)) : t.value[r] !== n && (t.value = {
            ...t.value,
            [r]: n
        }, t.notify(i, r));
    }, t;
};
const ev = "defaultWallet", Il = "oyl", Bl = "unisat", Ol = "xverse", Pl = "phantom", Rh = "leather", ru = "magic-eden", Ch = "okx", Uh = "wizz", Qu = "orange", Nl = "op_net", Ml = "sparrow", $h = "tokeo", Rl = "keplr", df = "p2tr", uG = "p2pkh", fG = "p2sh-p2wpkh", Ay = "p2wpkh", tve = "p2psh", lG = "p2wsh", Xp = "p2sh", rve = {
    leather: {
        name: "leather",
        url: "https://leather.io/wallet"
    },
    "magic-eden": {
        name: "magic-eden",
        url: "https://wallet.magiceden.io/"
    },
    okx: {
        name: "okx",
        url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    op_net: {
        name: "op_net",
        url: "https://opnet.org/"
    },
    orange: {
        name: "orange",
        url: "https://www.orangewallet.com/"
    },
    oyl: {
        name: "oyl",
        url: "https://www.oyl.io/#get-wallet"
    },
    phantom: {
        name: "phantom",
        url: "https://phantom.app/download"
    },
    sparrow: {
        name: "sparrow",
        url: "https://sparrowwallet.com/"
    },
    tokeo: {
        name: "tokeo",
        url: "https://tokeo.io/"
    },
    unisat: {
        name: "unisat",
        url: "https://unisat.io/download"
    },
    wizz: {
        name: "wizz",
        url: "https://wizzwallet.io/#extension"
    },
    xverse: {
        name: "xverse",
        url: "https://www.xverse.app/download"
    },
    keplr: {
        name: "keplr",
        url: "https://keplr.app/download"
    }
};
var Q7 = {}, pb = {};
pb.byteLength = pG;
pb.toByteArray = yG;
pb.fromByteArray = wG;
var ha = [], is = [], dG = typeof Uint8Array < "u" ? Uint8Array : Array, tv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var ll = 0, hG = tv.length; ll < hG; ++ll)ha[ll] = tv[ll], is[tv.charCodeAt(ll)] = ll;
is[45] = 62;
is[95] = 63;
function e9(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [
        r,
        n
    ];
}
function pG(e) {
    var t = e9(e), r = t[0], n = t[1];
    return (r + n) * 3 / 4 - n;
}
function gG(e, t, r) {
    return (t + r) * 3 / 4 - r;
}
function yG(e) {
    var t, r = e9(e), n = r[0], i = r[1], o = new dG(gG(e, n, i)), s = 0, a = i > 0 ? n - 4 : n, u;
    for(u = 0; u < a; u += 4)t = is[e.charCodeAt(u)] << 18 | is[e.charCodeAt(u + 1)] << 12 | is[e.charCodeAt(u + 2)] << 6 | is[e.charCodeAt(u + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
    return i === 2 && (t = is[e.charCodeAt(u)] << 2 | is[e.charCodeAt(u + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = is[e.charCodeAt(u)] << 10 | is[e.charCodeAt(u + 1)] << 4 | is[e.charCodeAt(u + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function mG(e) {
    return ha[e >> 18 & 63] + ha[e >> 12 & 63] + ha[e >> 6 & 63] + ha[e & 63];
}
function bG(e, t, r) {
    for(var n, i = [], o = t; o < r; o += 3)n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(mG(n));
    return i.join("");
}
function wG(e) {
    for(var t, r = e.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)i.push(bG(e, s, s + o > a ? a : s + o));
    return n === 1 ? (t = e[r - 1], i.push(ha[t >> 2] + ha[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(ha[t >> 10] + ha[t >> 4 & 63] + ha[t << 2 & 63] + "=")), i.join("");
}
var h3 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ h3.read = function(e, t, r, n, i) {
    var o, s, a = i * 8 - n - 1, u = (1 << a) - 1, f = u >> 1, c = -7, l = r ? i - 1 : 0, p = r ? -1 : 1, y = e[t + l];
    for(l += p, o = y & (1 << -c) - 1, y >>= -c, c += a; c > 0; o = o * 256 + e[t + l], l += p, c -= 8);
    for(s = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; s = s * 256 + e[t + l], l += p, c -= 8);
    if (o === 0) o = 1 - f;
    else {
        if (o === u) return s ? NaN : (y ? -1 : 1) * (1 / 0);
        s = s + Math.pow(2, n), o = o - f;
    }
    return (y ? -1 : 1) * s * Math.pow(2, o - n);
};
h3.write = function(e, t, r, n, i, o) {
    var s, a, u, f = o * 8 - i - 1, c = (1 << f) - 1, l = c >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, _ = n ? 1 : -1, A = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + l >= 1 ? t += p / u : t += p * Math.pow(2, 1 - l), t * u >= 2 && (s++, u /= 2), s + l >= c ? (a = 0, s = c) : s + l >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s = s + l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + y] = a & 255, y += _, a /= 256, i -= 8);
    for(s = s << i | a, f += i; f > 0; e[r + y] = s & 255, y += _, s /= 256, f -= 8);
    e[r + y - _] |= A * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(e) {
    const t = pb, r = h3, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = c, e.SlowBuffer = K, e.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    e.kMaxLength = i;
    const { Uint8Array: o, ArrayBuffer: s, SharedArrayBuffer: a } = globalThis;
    c.TYPED_ARRAY_SUPPORT = u(), !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function u() {
        try {
            const V = new o(1), C = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(C, o.prototype), Object.setPrototypeOf(V, C), V.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(c.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (c.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(c.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (c.isBuffer(this)) return this.byteOffset;
        }
    });
    function f(V) {
        if (V > i) throw new RangeError('The value "' + V + '" is invalid for option "size"');
        const C = new o(V);
        return Object.setPrototypeOf(C, c.prototype), C;
    }
    function c(V, C, Z) {
        if (typeof V == "number") {
            if (typeof C == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return _(V);
        }
        return l(V, C, Z);
    }
    c.poolSize = 8192;
    function l(V, C, Z) {
        if (typeof V == "string") return A(V, C);
        if (s.isView(V)) return N(V);
        if (V == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof V);
        if (te(V, s) || V && te(V.buffer, s) || typeof a < "u" && (te(V, a) || V && te(V.buffer, a))) return U(V, C, Z);
        if (typeof V == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const le = V.valueOf && V.valueOf();
        if (le != null && le !== V) return c.from(le, C, Z);
        const se = D(V);
        if (se) return se;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof V[Symbol.toPrimitive] == "function") return c.from(V[Symbol.toPrimitive]("string"), C, Z);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof V);
    }
    c.from = function(V, C, Z) {
        return l(V, C, Z);
    }, Object.setPrototypeOf(c.prototype, o.prototype), Object.setPrototypeOf(c, o);
    function p(V) {
        if (typeof V != "number") throw new TypeError('"size" argument must be of type number');
        if (V < 0) throw new RangeError('The value "' + V + '" is invalid for option "size"');
    }
    function y(V, C, Z) {
        return p(V), V <= 0 ? f(V) : C !== void 0 ? typeof Z == "string" ? f(V).fill(C, Z) : f(V).fill(C) : f(V);
    }
    c.alloc = function(V, C, Z) {
        return y(V, C, Z);
    };
    function _(V) {
        return p(V), f(V < 0 ? 0 : H(V) | 0);
    }
    c.allocUnsafe = function(V) {
        return _(V);
    }, c.allocUnsafeSlow = function(V) {
        return _(V);
    };
    function A(V, C) {
        if ((typeof C != "string" || C === "") && (C = "utf8"), !c.isEncoding(C)) throw new TypeError("Unknown encoding: " + C);
        const Z = re(V, C) | 0;
        let le = f(Z);
        const se = le.write(V, C);
        return se !== Z && (le = le.slice(0, se)), le;
    }
    function O(V) {
        const C = V.length < 0 ? 0 : H(V.length) | 0, Z = f(C);
        for(let le = 0; le < C; le += 1)Z[le] = V[le] & 255;
        return Z;
    }
    function N(V) {
        if (te(V, o)) {
            const C = new o(V);
            return U(C.buffer, C.byteOffset, C.byteLength);
        }
        return O(V);
    }
    function U(V, C, Z) {
        if (C < 0 || V.byteLength < C) throw new RangeError('"offset" is outside of buffer bounds');
        if (V.byteLength < C + (Z || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let le;
        return C === void 0 && Z === void 0 ? le = new o(V) : Z === void 0 ? le = new o(V, C) : le = new o(V, C, Z), Object.setPrototypeOf(le, c.prototype), le;
    }
    function D(V) {
        if (c.isBuffer(V)) {
            const C = H(V.length) | 0, Z = f(C);
            return Z.length === 0 || V.copy(Z, 0, 0, C), Z;
        }
        if (V.length !== void 0) return typeof V.length != "number" || fe(V.length) ? f(0) : O(V);
        if (V.type === "Buffer" && Array.isArray(V.data)) return O(V.data);
    }
    function H(V) {
        if (V >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return V | 0;
    }
    function K(V) {
        return +V != V && (V = 0), c.alloc(+V);
    }
    c.isBuffer = function(C) {
        return C != null && C._isBuffer === !0 && C !== c.prototype;
    }, c.compare = function(C, Z) {
        if (te(C, o) && (C = c.from(C, C.offset, C.byteLength)), te(Z, o) && (Z = c.from(Z, Z.offset, Z.byteLength)), !c.isBuffer(C) || !c.isBuffer(Z)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (C === Z) return 0;
        let le = C.length, se = Z.length;
        for(let Ne = 0, Le = Math.min(le, se); Ne < Le; ++Ne)if (C[Ne] !== Z[Ne]) {
            le = C[Ne], se = Z[Ne];
            break;
        }
        return le < se ? -1 : se < le ? 1 : 0;
    }, c.isEncoding = function(C) {
        switch(String(C).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, c.concat = function(C, Z) {
        if (!Array.isArray(C)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (C.length === 0) return c.alloc(0);
        let le;
        if (Z === void 0) for(Z = 0, le = 0; le < C.length; ++le)Z += C[le].length;
        const se = c.allocUnsafe(Z);
        let Ne = 0;
        for(le = 0; le < C.length; ++le){
            let Le = C[le];
            if (te(Le, o)) Ne + Le.length > se.length ? (c.isBuffer(Le) || (Le = c.from(Le)), Le.copy(se, Ne)) : o.prototype.set.call(se, Le, Ne);
            else if (c.isBuffer(Le)) Le.copy(se, Ne);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            Ne += Le.length;
        }
        return se;
    };
    function re(V, C) {
        if (c.isBuffer(V)) return V.length;
        if (s.isView(V) || te(V, s)) return V.byteLength;
        if (typeof V != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof V);
        const Z = V.length, le = arguments.length > 2 && arguments[2] === !0;
        if (!le && Z === 0) return 0;
        let se = !1;
        for(;;)switch(C){
            case "ascii":
            case "latin1":
            case "binary":
                return Z;
            case "utf8":
            case "utf-8":
                return Ke(V).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Z * 2;
            case "hex":
                return Z >>> 1;
            case "base64":
                return x(V).length;
            default:
                if (se) return le ? -1 : Ke(V).length;
                C = ("" + C).toLowerCase(), se = !0;
        }
    }
    c.byteLength = re;
    function Q(V, C, Z) {
        let le = !1;
        if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((Z === void 0 || Z > this.length) && (Z = this.length), Z <= 0) || (Z >>>= 0, C >>>= 0, Z <= C)) return "";
        for(V || (V = "utf8");;)switch(V){
            case "hex":
                return j(this, C, Z);
            case "utf8":
            case "utf-8":
                return T(this, C, Z);
            case "ascii":
                return k(this, C, Z);
            case "latin1":
            case "binary":
                return L(this, C, Z);
            case "base64":
                return E(this, C, Z);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ie(this, C, Z);
            default:
                if (le) throw new TypeError("Unknown encoding: " + V);
                V = (V + "").toLowerCase(), le = !0;
        }
    }
    c.prototype._isBuffer = !0;
    function G(V, C, Z) {
        const le = V[C];
        V[C] = V[Z], V[Z] = le;
    }
    c.prototype.swap16 = function() {
        const C = this.length;
        if (C % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let Z = 0; Z < C; Z += 2)G(this, Z, Z + 1);
        return this;
    }, c.prototype.swap32 = function() {
        const C = this.length;
        if (C % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let Z = 0; Z < C; Z += 4)G(this, Z, Z + 3), G(this, Z + 1, Z + 2);
        return this;
    }, c.prototype.swap64 = function() {
        const C = this.length;
        if (C % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let Z = 0; Z < C; Z += 8)G(this, Z, Z + 7), G(this, Z + 1, Z + 6), G(this, Z + 2, Z + 5), G(this, Z + 3, Z + 4);
        return this;
    }, c.prototype.toString = function() {
        const C = this.length;
        return C === 0 ? "" : arguments.length === 0 ? T(this, 0, C) : Q.apply(this, arguments);
    }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(C) {
        if (!c.isBuffer(C)) throw new TypeError("Argument must be a Buffer");
        return this === C ? !0 : c.compare(this, C) === 0;
    }, c.prototype.inspect = function() {
        let C = "";
        const Z = e.INSPECT_MAX_BYTES;
        return C = this.toString("hex", 0, Z).replace(/(.{2})/g, "$1 ").trim(), this.length > Z && (C += " ... "), "<Buffer " + C + ">";
    }, n && (c.prototype[n] = c.prototype.inspect), c.prototype.compare = function(C, Z, le, se, Ne) {
        if (te(C, o) && (C = c.from(C, C.offset, C.byteLength)), !c.isBuffer(C)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C);
        if (Z === void 0 && (Z = 0), le === void 0 && (le = C ? C.length : 0), se === void 0 && (se = 0), Ne === void 0 && (Ne = this.length), Z < 0 || le > C.length || se < 0 || Ne > this.length) throw new RangeError("out of range index");
        if (se >= Ne && Z >= le) return 0;
        if (se >= Ne) return -1;
        if (Z >= le) return 1;
        if (Z >>>= 0, le >>>= 0, se >>>= 0, Ne >>>= 0, this === C) return 0;
        let Le = Ne - se, rt = le - Z;
        const yt = Math.min(Le, rt), _t = this.slice(se, Ne), Qe = C.slice(Z, le);
        for(let Rt = 0; Rt < yt; ++Rt)if (_t[Rt] !== Qe[Rt]) {
            Le = _t[Rt], rt = Qe[Rt];
            break;
        }
        return Le < rt ? -1 : rt < Le ? 1 : 0;
    };
    function R(V, C, Z, le, se) {
        if (V.length === 0) return -1;
        if (typeof Z == "string" ? (le = Z, Z = 0) : Z > 2147483647 ? Z = 2147483647 : Z < -2147483648 && (Z = -2147483648), Z = +Z, fe(Z) && (Z = se ? 0 : V.length - 1), Z < 0 && (Z = V.length + Z), Z >= V.length) {
            if (se) return -1;
            Z = V.length - 1;
        } else if (Z < 0) if (se) Z = 0;
        else return -1;
        if (typeof C == "string" && (C = c.from(C, le)), c.isBuffer(C)) return C.length === 0 ? -1 : X(V, C, Z, le, se);
        if (typeof C == "number") return C = C & 255, typeof o.prototype.indexOf == "function" ? se ? o.prototype.indexOf.call(V, C, Z) : o.prototype.lastIndexOf.call(V, C, Z) : X(V, [
            C
        ], Z, le, se);
        throw new TypeError("val must be string, number or Buffer");
    }
    function X(V, C, Z, le, se) {
        let Ne = 1, Le = V.length, rt = C.length;
        if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
            if (V.length < 2 || C.length < 2) return -1;
            Ne = 2, Le /= 2, rt /= 2, Z /= 2;
        }
        function yt(Qe, Rt) {
            return Ne === 1 ? Qe[Rt] : Qe.readUInt16BE(Rt * Ne);
        }
        let _t;
        if (se) {
            let Qe = -1;
            for(_t = Z; _t < Le; _t++)if (yt(V, _t) === yt(C, Qe === -1 ? 0 : _t - Qe)) {
                if (Qe === -1 && (Qe = _t), _t - Qe + 1 === rt) return Qe * Ne;
            } else Qe !== -1 && (_t -= _t - Qe), Qe = -1;
        } else for(Z + rt > Le && (Z = Le - rt), _t = Z; _t >= 0; _t--){
            let Qe = !0;
            for(let Rt = 0; Rt < rt; Rt++)if (yt(V, _t + Rt) !== yt(C, Rt)) {
                Qe = !1;
                break;
            }
            if (Qe) return _t;
        }
        return -1;
    }
    c.prototype.includes = function(C, Z, le) {
        return this.indexOf(C, Z, le) !== -1;
    }, c.prototype.indexOf = function(C, Z, le) {
        return R(this, C, Z, le, !0);
    }, c.prototype.lastIndexOf = function(C, Z, le) {
        return R(this, C, Z, le, !1);
    };
    function $(V, C, Z, le) {
        Z = Number(Z) || 0;
        const se = V.length - Z;
        le ? (le = Number(le), le > se && (le = se)) : le = se;
        const Ne = C.length;
        le > Ne / 2 && (le = Ne / 2);
        let Le;
        for(Le = 0; Le < le; ++Le){
            const rt = parseInt(C.substr(Le * 2, 2), 16);
            if (fe(rt)) return Le;
            V[Z + Le] = rt;
        }
        return Le;
    }
    function S(V, C, Z, le) {
        return q(Ke(C, V.length - Z), V, Z, le);
    }
    function w(V, C, Z, le) {
        return q(Ue(C), V, Z, le);
    }
    function g(V, C, Z, le) {
        return q(x(C), V, Z, le);
    }
    function m(V, C, Z, le) {
        return q(h(C, V.length - Z), V, Z, le);
    }
    c.prototype.write = function(C, Z, le, se) {
        if (Z === void 0) se = "utf8", le = this.length, Z = 0;
        else if (le === void 0 && typeof Z == "string") se = Z, le = this.length, Z = 0;
        else if (isFinite(Z)) Z = Z >>> 0, isFinite(le) ? (le = le >>> 0, se === void 0 && (se = "utf8")) : (se = le, le = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Ne = this.length - Z;
        if ((le === void 0 || le > Ne) && (le = Ne), C.length > 0 && (le < 0 || Z < 0) || Z > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        se || (se = "utf8");
        let Le = !1;
        for(;;)switch(se){
            case "hex":
                return $(this, C, Z, le);
            case "utf8":
            case "utf-8":
                return S(this, C, Z, le);
            case "ascii":
            case "latin1":
            case "binary":
                return w(this, C, Z, le);
            case "base64":
                return g(this, C, Z, le);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return m(this, C, Z, le);
            default:
                if (Le) throw new TypeError("Unknown encoding: " + se);
                se = ("" + se).toLowerCase(), Le = !0;
        }
    }, c.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function E(V, C, Z) {
        return C === 0 && Z === V.length ? t.fromByteArray(V) : t.fromByteArray(V.slice(C, Z));
    }
    function T(V, C, Z) {
        Z = Math.min(V.length, Z);
        const le = [];
        let se = C;
        for(; se < Z;){
            const Ne = V[se];
            let Le = null, rt = Ne > 239 ? 4 : Ne > 223 ? 3 : Ne > 191 ? 2 : 1;
            if (se + rt <= Z) {
                let yt, _t, Qe, Rt;
                switch(rt){
                    case 1:
                        Ne < 128 && (Le = Ne);
                        break;
                    case 2:
                        yt = V[se + 1], (yt & 192) === 128 && (Rt = (Ne & 31) << 6 | yt & 63, Rt > 127 && (Le = Rt));
                        break;
                    case 3:
                        yt = V[se + 1], _t = V[se + 2], (yt & 192) === 128 && (_t & 192) === 128 && (Rt = (Ne & 15) << 12 | (yt & 63) << 6 | _t & 63, Rt > 2047 && (Rt < 55296 || Rt > 57343) && (Le = Rt));
                        break;
                    case 4:
                        yt = V[se + 1], _t = V[se + 2], Qe = V[se + 3], (yt & 192) === 128 && (_t & 192) === 128 && (Qe & 192) === 128 && (Rt = (Ne & 15) << 18 | (yt & 63) << 12 | (_t & 63) << 6 | Qe & 63, Rt > 65535 && Rt < 1114112 && (Le = Rt));
                }
            }
            Le === null ? (Le = 65533, rt = 1) : Le > 65535 && (Le -= 65536, le.push(Le >>> 10 & 1023 | 55296), Le = 56320 | Le & 1023), le.push(Le), se += rt;
        }
        return P(le);
    }
    const I = 4096;
    function P(V) {
        const C = V.length;
        if (C <= I) return String.fromCharCode.apply(String, V);
        let Z = "", le = 0;
        for(; le < C;)Z += String.fromCharCode.apply(String, V.slice(le, le += I));
        return Z;
    }
    function k(V, C, Z) {
        let le = "";
        Z = Math.min(V.length, Z);
        for(let se = C; se < Z; ++se)le += String.fromCharCode(V[se] & 127);
        return le;
    }
    function L(V, C, Z) {
        let le = "";
        Z = Math.min(V.length, Z);
        for(let se = C; se < Z; ++se)le += String.fromCharCode(V[se]);
        return le;
    }
    function j(V, C, Z) {
        const le = V.length;
        (!C || C < 0) && (C = 0), (!Z || Z < 0 || Z > le) && (Z = le);
        let se = "";
        for(let Ne = C; Ne < Z; ++Ne)se += ne[V[Ne]];
        return se;
    }
    function ie(V, C, Z) {
        const le = V.slice(C, Z);
        let se = "";
        for(let Ne = 0; Ne < le.length - 1; Ne += 2)se += String.fromCharCode(le[Ne] + le[Ne + 1] * 256);
        return se;
    }
    c.prototype.slice = function(C, Z) {
        const le = this.length;
        C = ~~C, Z = Z === void 0 ? le : ~~Z, C < 0 ? (C += le, C < 0 && (C = 0)) : C > le && (C = le), Z < 0 ? (Z += le, Z < 0 && (Z = 0)) : Z > le && (Z = le), Z < C && (Z = C);
        const se = this.subarray(C, Z);
        return Object.setPrototypeOf(se, c.prototype), se;
    };
    function ue(V, C, Z) {
        if (V % 1 !== 0 || V < 0) throw new RangeError("offset is not uint");
        if (V + C > Z) throw new RangeError("Trying to access beyond buffer length");
    }
    c.prototype.readUintLE = c.prototype.readUIntLE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = this[C], Ne = 1, Le = 0;
        for(; ++Le < Z && (Ne *= 256);)se += this[C + Le] * Ne;
        return se;
    }, c.prototype.readUintBE = c.prototype.readUIntBE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = this[C + --Z], Ne = 1;
        for(; Z > 0 && (Ne *= 256);)se += this[C + --Z] * Ne;
        return se;
    }, c.prototype.readUint8 = c.prototype.readUInt8 = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 1, this.length), this[C];
    }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 2, this.length), this[C] | this[C + 1] << 8;
    }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 2, this.length), this[C] << 8 | this[C + 1];
    }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
    }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
    }, c.prototype.readBigUInt64LE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = Z + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24, Ne = this[++C] + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + le * 2 ** 24;
        return BigInt(se) + (BigInt(Ne) << BigInt(32));
    }), c.prototype.readBigUInt64BE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = Z * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C], Ne = this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + le;
        return (BigInt(se) << BigInt(32)) + BigInt(Ne);
    }), c.prototype.readIntLE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = this[C], Ne = 1, Le = 0;
        for(; ++Le < Z && (Ne *= 256);)se += this[C + Le] * Ne;
        return Ne *= 128, se >= Ne && (se -= Math.pow(2, 8 * Z)), se;
    }, c.prototype.readIntBE = function(C, Z, le) {
        C = C >>> 0, Z = Z >>> 0, le || ue(C, Z, this.length);
        let se = Z, Ne = 1, Le = this[C + --se];
        for(; se > 0 && (Ne *= 256);)Le += this[C + --se] * Ne;
        return Ne *= 128, Le >= Ne && (Le -= Math.pow(2, 8 * Z)), Le;
    }, c.prototype.readInt8 = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
    }, c.prototype.readInt16LE = function(C, Z) {
        C = C >>> 0, Z || ue(C, 2, this.length);
        const le = this[C] | this[C + 1] << 8;
        return le & 32768 ? le | 4294901760 : le;
    }, c.prototype.readInt16BE = function(C, Z) {
        C = C >>> 0, Z || ue(C, 2, this.length);
        const le = this[C + 1] | this[C] << 8;
        return le & 32768 ? le | 4294901760 : le;
    }, c.prototype.readInt32LE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
    }, c.prototype.readInt32BE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
    }, c.prototype.readBigInt64LE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = this[C + 4] + this[C + 5] * 2 ** 8 + this[C + 6] * 2 ** 16 + (le << 24);
        return (BigInt(se) << BigInt(32)) + BigInt(Z + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24);
    }), c.prototype.readBigInt64BE = W(function(C) {
        C = C >>> 0, de(C, "offset");
        const Z = this[C], le = this[C + 7];
        (Z === void 0 || le === void 0) && _e(C, this.length - 8);
        const se = (Z << 24) + // Overflow
        this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C];
        return (BigInt(se) << BigInt(32)) + BigInt(this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + le);
    }), c.prototype.readFloatLE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), r.read(this, C, !0, 23, 4);
    }, c.prototype.readFloatBE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 4, this.length), r.read(this, C, !1, 23, 4);
    }, c.prototype.readDoubleLE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 8, this.length), r.read(this, C, !0, 52, 8);
    }, c.prototype.readDoubleBE = function(C, Z) {
        return C = C >>> 0, Z || ue(C, 8, this.length), r.read(this, C, !1, 52, 8);
    };
    function ce(V, C, Z, le, se, Ne) {
        if (!c.isBuffer(V)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (C > se || C < Ne) throw new RangeError('"value" argument is out of bounds');
        if (Z + le > V.length) throw new RangeError("Index out of range");
    }
    c.prototype.writeUintLE = c.prototype.writeUIntLE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, le = le >>> 0, !se) {
            const rt = Math.pow(2, 8 * le) - 1;
            ce(this, C, Z, le, rt, 0);
        }
        let Ne = 1, Le = 0;
        for(this[Z] = C & 255; ++Le < le && (Ne *= 256);)this[Z + Le] = C / Ne & 255;
        return Z + le;
    }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, le = le >>> 0, !se) {
            const rt = Math.pow(2, 8 * le) - 1;
            ce(this, C, Z, le, rt, 0);
        }
        let Ne = le - 1, Le = 1;
        for(this[Z + Ne] = C & 255; --Ne >= 0 && (Le *= 256);)this[Z + Ne] = C / Le & 255;
        return Z + le;
    }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 1, 255, 0), this[Z] = C & 255, Z + 1;
    }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 65535, 0), this[Z] = C & 255, this[Z + 1] = C >>> 8, Z + 2;
    }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 65535, 0), this[Z] = C >>> 8, this[Z + 1] = C & 255, Z + 2;
    }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 4294967295, 0), this[Z + 3] = C >>> 24, this[Z + 2] = C >>> 16, this[Z + 1] = C >>> 8, this[Z] = C & 255, Z + 4;
    }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 4294967295, 0), this[Z] = C >>> 24, this[Z + 1] = C >>> 16, this[Z + 2] = C >>> 8, this[Z + 3] = C & 255, Z + 4;
    };
    function he(V, C, Z, le, se) {
        z(C, le, se, V, Z, 7);
        let Ne = Number(C & BigInt(4294967295));
        V[Z++] = Ne, Ne = Ne >> 8, V[Z++] = Ne, Ne = Ne >> 8, V[Z++] = Ne, Ne = Ne >> 8, V[Z++] = Ne;
        let Le = Number(C >> BigInt(32) & BigInt(4294967295));
        return V[Z++] = Le, Le = Le >> 8, V[Z++] = Le, Le = Le >> 8, V[Z++] = Le, Le = Le >> 8, V[Z++] = Le, Z;
    }
    function ee(V, C, Z, le, se) {
        z(C, le, se, V, Z, 7);
        let Ne = Number(C & BigInt(4294967295));
        V[Z + 7] = Ne, Ne = Ne >> 8, V[Z + 6] = Ne, Ne = Ne >> 8, V[Z + 5] = Ne, Ne = Ne >> 8, V[Z + 4] = Ne;
        let Le = Number(C >> BigInt(32) & BigInt(4294967295));
        return V[Z + 3] = Le, Le = Le >> 8, V[Z + 2] = Le, Le = Le >> 8, V[Z + 1] = Le, Le = Le >> 8, V[Z] = Le, Z + 8;
    }
    c.prototype.writeBigUInt64LE = W(function(C, Z = 0) {
        return he(this, C, Z, BigInt(0), BigInt("0xffffffffffffffff"));
    }), c.prototype.writeBigUInt64BE = W(function(C, Z = 0) {
        return ee(this, C, Z, BigInt(0), BigInt("0xffffffffffffffff"));
    }), c.prototype.writeIntLE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, !se) {
            const yt = Math.pow(2, 8 * le - 1);
            ce(this, C, Z, le, yt - 1, -yt);
        }
        let Ne = 0, Le = 1, rt = 0;
        for(this[Z] = C & 255; ++Ne < le && (Le *= 256);)C < 0 && rt === 0 && this[Z + Ne - 1] !== 0 && (rt = 1), this[Z + Ne] = (C / Le >> 0) - rt & 255;
        return Z + le;
    }, c.prototype.writeIntBE = function(C, Z, le, se) {
        if (C = +C, Z = Z >>> 0, !se) {
            const yt = Math.pow(2, 8 * le - 1);
            ce(this, C, Z, le, yt - 1, -yt);
        }
        let Ne = le - 1, Le = 1, rt = 0;
        for(this[Z + Ne] = C & 255; --Ne >= 0 && (Le *= 256);)C < 0 && rt === 0 && this[Z + Ne + 1] !== 0 && (rt = 1), this[Z + Ne] = (C / Le >> 0) - rt & 255;
        return Z + le;
    }, c.prototype.writeInt8 = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[Z] = C & 255, Z + 1;
    }, c.prototype.writeInt16LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 32767, -32768), this[Z] = C & 255, this[Z + 1] = C >>> 8, Z + 2;
    }, c.prototype.writeInt16BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 2, 32767, -32768), this[Z] = C >>> 8, this[Z + 1] = C & 255, Z + 2;
    }, c.prototype.writeInt32LE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 2147483647, -2147483648), this[Z] = C & 255, this[Z + 1] = C >>> 8, this[Z + 2] = C >>> 16, this[Z + 3] = C >>> 24, Z + 4;
    }, c.prototype.writeInt32BE = function(C, Z, le) {
        return C = +C, Z = Z >>> 0, le || ce(this, C, Z, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[Z] = C >>> 24, this[Z + 1] = C >>> 16, this[Z + 2] = C >>> 8, this[Z + 3] = C & 255, Z + 4;
    }, c.prototype.writeBigInt64LE = W(function(C, Z = 0) {
        return he(this, C, Z, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), c.prototype.writeBigInt64BE = W(function(C, Z = 0) {
        return ee(this, C, Z, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ae(V, C, Z, le, se, Ne) {
        if (Z + le > V.length) throw new RangeError("Index out of range");
        if (Z < 0) throw new RangeError("Index out of range");
    }
    function ye(V, C, Z, le, se) {
        return C = +C, Z = Z >>> 0, se || ae(V, C, Z, 4), r.write(V, C, Z, le, 23, 4), Z + 4;
    }
    c.prototype.writeFloatLE = function(C, Z, le) {
        return ye(this, C, Z, !0, le);
    }, c.prototype.writeFloatBE = function(C, Z, le) {
        return ye(this, C, Z, !1, le);
    };
    function Se(V, C, Z, le, se) {
        return C = +C, Z = Z >>> 0, se || ae(V, C, Z, 8), r.write(V, C, Z, le, 52, 8), Z + 8;
    }
    c.prototype.writeDoubleLE = function(C, Z, le) {
        return Se(this, C, Z, !0, le);
    }, c.prototype.writeDoubleBE = function(C, Z, le) {
        return Se(this, C, Z, !1, le);
    }, c.prototype.copy = function(C, Z, le, se) {
        if (!c.isBuffer(C)) throw new TypeError("argument should be a Buffer");
        if (le || (le = 0), !se && se !== 0 && (se = this.length), Z >= C.length && (Z = C.length), Z || (Z = 0), se > 0 && se < le && (se = le), se === le || C.length === 0 || this.length === 0) return 0;
        if (Z < 0) throw new RangeError("targetStart out of bounds");
        if (le < 0 || le >= this.length) throw new RangeError("Index out of range");
        if (se < 0) throw new RangeError("sourceEnd out of bounds");
        se > this.length && (se = this.length), C.length - Z < se - le && (se = C.length - Z + le);
        const Ne = se - le;
        return this === C && typeof o.prototype.copyWithin == "function" ? this.copyWithin(Z, le, se) : o.prototype.set.call(C, this.subarray(le, se), Z), Ne;
    }, c.prototype.fill = function(C, Z, le, se) {
        if (typeof C == "string") {
            if (typeof Z == "string" ? (se = Z, Z = 0, le = this.length) : typeof le == "string" && (se = le, le = this.length), se !== void 0 && typeof se != "string") throw new TypeError("encoding must be a string");
            if (typeof se == "string" && !c.isEncoding(se)) throw new TypeError("Unknown encoding: " + se);
            if (C.length === 1) {
                const Le = C.charCodeAt(0);
                (se === "utf8" && Le < 128 || se === "latin1") && (C = Le);
            }
        } else typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
        if (Z < 0 || this.length < Z || this.length < le) throw new RangeError("Out of range index");
        if (le <= Z) return this;
        Z = Z >>> 0, le = le === void 0 ? this.length : le >>> 0, C || (C = 0);
        let Ne;
        if (typeof C == "number") for(Ne = Z; Ne < le; ++Ne)this[Ne] = C;
        else {
            const Le = c.isBuffer(C) ? C : c.from(C, se), rt = Le.length;
            if (rt === 0) throw new TypeError('The value "' + C + '" is invalid for argument "value"');
            for(Ne = 0; Ne < le - Z; ++Ne)this[Ne + Z] = Le[Ne % rt];
        }
        return this;
    };
    const De = {};
    function Re(V, C, Z) {
        De[V] = class extends Z {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: C.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${V}]`, this.stack, delete this.name;
            }
            get code() {
                return V;
            }
            set code(se) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: se,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${V}]: ${this.message}`;
            }
        };
    }
    Re("ERR_BUFFER_OUT_OF_BOUNDS", function(V) {
        return V ? `${V} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), Re("ERR_INVALID_ARG_TYPE", function(V, C) {
        return `The "${V}" argument must be of type number. Received type ${typeof C}`;
    }, TypeError), Re("ERR_OUT_OF_RANGE", function(V, C, Z) {
        let le = `The value of "${V}" is out of range.`, se = Z;
        return Number.isInteger(Z) && Math.abs(Z) > 2 ** 32 ? se = Ce(String(Z)) : typeof Z == "bigint" && (se = String(Z), (Z > BigInt(2) ** BigInt(32) || Z < -(BigInt(2) ** BigInt(32))) && (se = Ce(se)), se += "n"), le += ` It must be ${C}. Received ${se}`, le;
    }, RangeError);
    function Ce(V) {
        let C = "", Z = V.length;
        const le = V[0] === "-" ? 1 : 0;
        for(; Z >= le + 4; Z -= 3)C = `_${V.slice(Z - 3, Z)}${C}`;
        return `${V.slice(0, Z)}${C}`;
    }
    function M(V, C, Z) {
        de(C, "offset"), (V[C] === void 0 || V[C + Z] === void 0) && _e(C, V.length - (Z + 1));
    }
    function z(V, C, Z, le, se, Ne) {
        if (V > Z || V < C) {
            const Le = typeof C == "bigint" ? "n" : "";
            let rt;
            throw C === 0 || C === BigInt(0) ? rt = `>= 0${Le} and < 2${Le} ** ${(Ne + 1) * 8}${Le}` : rt = `>= -(2${Le} ** ${(Ne + 1) * 8 - 1}${Le}) and < 2 ** ${(Ne + 1) * 8 - 1}${Le}`, new De.ERR_OUT_OF_RANGE("value", rt, V);
        }
        M(le, se, Ne);
    }
    function de(V, C) {
        if (typeof V != "number") throw new De.ERR_INVALID_ARG_TYPE(C, "number", V);
    }
    function _e(V, C, Z) {
        throw Math.floor(V) !== V ? (de(V, Z), new De.ERR_OUT_OF_RANGE("offset", "an integer", V)) : C < 0 ? new De.ERR_BUFFER_OUT_OF_BOUNDS() : new De.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${C}`, V);
    }
    const Ie = /[^+/0-9A-Za-z-_]/g;
    function je(V) {
        if (V = V.split("=")[0], V = V.trim().replace(Ie, ""), V.length < 2) return "";
        for(; V.length % 4 !== 0;)V = V + "=";
        return V;
    }
    function Ke(V, C) {
        C = C || 1 / 0;
        let Z;
        const le = V.length;
        let se = null;
        const Ne = [];
        for(let Le = 0; Le < le; ++Le){
            if (Z = V.charCodeAt(Le), Z > 55295 && Z < 57344) {
                if (!se) {
                    if (Z > 56319) {
                        (C -= 3) > -1 && Ne.push(239, 191, 189);
                        continue;
                    } else if (Le + 1 === le) {
                        (C -= 3) > -1 && Ne.push(239, 191, 189);
                        continue;
                    }
                    se = Z;
                    continue;
                }
                if (Z < 56320) {
                    (C -= 3) > -1 && Ne.push(239, 191, 189), se = Z;
                    continue;
                }
                Z = (se - 55296 << 10 | Z - 56320) + 65536;
            } else se && (C -= 3) > -1 && Ne.push(239, 191, 189);
            if (se = null, Z < 128) {
                if ((C -= 1) < 0) break;
                Ne.push(Z);
            } else if (Z < 2048) {
                if ((C -= 2) < 0) break;
                Ne.push(Z >> 6 | 192, Z & 63 | 128);
            } else if (Z < 65536) {
                if ((C -= 3) < 0) break;
                Ne.push(Z >> 12 | 224, Z >> 6 & 63 | 128, Z & 63 | 128);
            } else if (Z < 1114112) {
                if ((C -= 4) < 0) break;
                Ne.push(Z >> 18 | 240, Z >> 12 & 63 | 128, Z >> 6 & 63 | 128, Z & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return Ne;
    }
    function Ue(V) {
        const C = [];
        for(let Z = 0; Z < V.length; ++Z)C.push(V.charCodeAt(Z) & 255);
        return C;
    }
    function h(V, C) {
        let Z, le, se;
        const Ne = [];
        for(let Le = 0; Le < V.length && !((C -= 2) < 0); ++Le)Z = V.charCodeAt(Le), le = Z >> 8, se = Z % 256, Ne.push(se), Ne.push(le);
        return Ne;
    }
    function x(V) {
        return t.toByteArray(je(V));
    }
    function q(V, C, Z, le) {
        let se;
        for(se = 0; se < le && !(se + Z >= C.length || se >= V.length); ++se)C[se + Z] = V[se];
        return se;
    }
    function te(V, C) {
        return V instanceof C || V != null && V.constructor != null && V.constructor.name != null && V.constructor.name === C.name;
    }
    function fe(V) {
        return V !== V;
    }
    const ne = function() {
        const V = "0123456789abcdef", C = new Array(256);
        for(let Z = 0; Z < 16; ++Z){
            const le = Z * 16;
            for(let se = 0; se < 16; ++se)C[le + se] = V[Z] + V[se];
        }
        return C;
    }();
    function W(V) {
        return typeof BigInt > "u" ? J : V;
    }
    function J() {
        throw new Error("BigInt not supported");
    }
})(Q7);
const We = Q7.Buffer, t9 = "maestro", vG = "mempool-space", _G = "sandshrew";
var ME = /* @__PURE__ */ ((e)=>(e.MAINNET = "fractal_mainnet", e.TESTNET = "fractal_testnet", e))(ME || {}), Qc = /* @__PURE__ */ ((e)=>(e.MAINNET = "main", e.TESTNET = "testnet", e.SIGNET = "signet", e))(Qc || {}), Hl = /* @__PURE__ */ ((e)=>(e.MAINNET = "mainnet", e.TESTNET = "testnet", e))(Hl || {}), ro = /* @__PURE__ */ ((e)=>(e.MAINNET = "BITCOIN_MAINNET", e.TESTNET = "BITCOIN_TESTNET", e.TESTNET4 = "BITCOIN_TESTNET4", e.SIGNET = "BITCOIN_SIGNET", e.FRACTAL_MAINNET = "FRACTAL_BITCOIN_MAINNET", e.FRACTAL_TESTNET = "FRACTAL_BITCOIN_TESTNET", e))(ro || {}), cu = /* @__PURE__ */ ((e)=>(e.BITCOIN_MAINNET = "BITCOIN_MAINNET", e.BITCOIN_TESTNET = "BITCOIN_TESTNET", e.BITCOIN_SIGNET = "BITCOIN_SIGNET", e))(cu || {}), EG = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e))(EG || {}), Yu = /* @__PURE__ */ ((e)=>(e.MAINNET = "Mainnet", e.TESTNET = "Testnet", e.SIGNET = "Signet", e.FRACTAL_MAINNET = "fractal mainnet", e.FRACTAL_TESTNET = "fractal testnet", e.TESTNET4 = "Testnet4", e))(Yu || {}), RE = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e))(RE || {}), ko = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e.TESTNET4 = "testnet4", e.SIGNET = "signet", e))(ko || {}), eu = /* @__PURE__ */ ((e)=>(e.MAINNET = "Mainnet", e.TESTNET = "Testnet", e))(eu || {}), dt = /* @__PURE__ */ ((e)=>(e.MAINNET = "mainnet", e.SIGNET = "signet", e.TESTNET = "testnet", e.TESTNET4 = "testnet4", e.REGTEST = "regtest", e.FRACTAL_MAINNET = "fractal_mainnet", e.FRACTAL_TESTNET = "fractal_testnet", e.OYLNET = "oylnet", e))(dt || {}), In = {}, p3 = {}, en = {}, Pi = {}, Hr = {}, gb = {};
Object.defineProperty(gb, "__esModule", {
    value: !0
});
gb.crypto = void 0;
gb.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.Hash = e.nextTick = e.swap32IfBE = e.byteSwapIfBE = e.swap8IfBE = e.isLE = void 0, e.isBytes = r, e.anumber = n, e.abytes = i, e.ahash = o, e.aexists = s, e.aoutput = a, e.u8 = u, e.u32 = f, e.clean = c, e.createView = l, e.rotr = p, e.rotl = y, e.byteSwap = _, e.byteSwap32 = A, e.bytesToHex = U, e.hexToBytes = K, e.asyncLoop = Q, e.utf8ToBytes = G, e.bytesToUtf8 = R, e.toBytes = X, e.kdfInputToBytes = $, e.concatBytes = S, e.checkOpts = w, e.createHasher = m, e.createOptHasher = E, e.createXOFer = T, e.randomBytes = I;
    const t = gb;
    function r(P) {
        return P instanceof Uint8Array || ArrayBuffer.isView(P) && P.constructor.name === "Uint8Array";
    }
    function n(P) {
        if (!Number.isSafeInteger(P) || P < 0) throw new Error("positive integer expected, got " + P);
    }
    function i(P, ...k) {
        if (!r(P)) throw new Error("Uint8Array expected");
        if (k.length > 0 && !k.includes(P.length)) throw new Error("Uint8Array expected of length " + k + ", got length=" + P.length);
    }
    function o(P) {
        if (typeof P != "function" || typeof P.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
        n(P.outputLen), n(P.blockLen);
    }
    function s(P, k = !0) {
        if (P.destroyed) throw new Error("Hash instance has been destroyed");
        if (k && P.finished) throw new Error("Hash#digest() has already been called");
    }
    function a(P, k) {
        i(P);
        const L = k.outputLen;
        if (P.length < L) throw new Error("digestInto() expects output buffer of length at least " + L);
    }
    function u(P) {
        return new Uint8Array(P.buffer, P.byteOffset, P.byteLength);
    }
    function f(P) {
        return new Uint32Array(P.buffer, P.byteOffset, Math.floor(P.byteLength / 4));
    }
    function c(...P) {
        for(let k = 0; k < P.length; k++)P[k].fill(0);
    }
    function l(P) {
        return new DataView(P.buffer, P.byteOffset, P.byteLength);
    }
    function p(P, k) {
        return P << 32 - k | P >>> k;
    }
    function y(P, k) {
        return P << k | P >>> 32 - k >>> 0;
    }
    e.isLE = new Uint8Array(new Uint32Array([
        287454020
    ]).buffer)[0] === 68;
    function _(P) {
        return P << 24 & 4278190080 | P << 8 & 16711680 | P >>> 8 & 65280 | P >>> 24 & 255;
    }
    e.swap8IfBE = e.isLE ? (P)=>P : (P)=>_(P), e.byteSwapIfBE = e.swap8IfBE;
    function A(P) {
        for(let k = 0; k < P.length; k++)P[k] = _(P[k]);
        return P;
    }
    e.swap32IfBE = e.isLE ? (P)=>P : A;
    const O = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", N = /* @__PURE__ */ Array.from({
        length: 256
    }, (P, k)=>k.toString(16).padStart(2, "0"));
    function U(P) {
        if (i(P), O) return P.toHex();
        let k = "";
        for(let L = 0; L < P.length; L++)k += N[P[L]];
        return k;
    }
    const D = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function H(P) {
        if (P >= D._0 && P <= D._9) return P - D._0;
        if (P >= D.A && P <= D.F) return P - (D.A - 10);
        if (P >= D.a && P <= D.f) return P - (D.a - 10);
    }
    function K(P) {
        if (typeof P != "string") throw new Error("hex string expected, got " + typeof P);
        if (O) return Uint8Array.fromHex(P);
        const k = P.length, L = k / 2;
        if (k % 2) throw new Error("hex string expected, got unpadded hex of length " + k);
        const j = new Uint8Array(L);
        for(let ie = 0, ue = 0; ie < L; ie++, ue += 2){
            const ce = H(P.charCodeAt(ue)), he = H(P.charCodeAt(ue + 1));
            if (ce === void 0 || he === void 0) {
                const ee = P[ue] + P[ue + 1];
                throw new Error('hex string expected, got non-hex character "' + ee + '" at index ' + ue);
            }
            j[ie] = ce * 16 + he;
        }
        return j;
    }
    const re = async ()=>{};
    e.nextTick = re;
    async function Q(P, k, L) {
        let j = Date.now();
        for(let ie = 0; ie < P; ie++){
            L(ie);
            const ue = Date.now() - j;
            ue >= 0 && ue < k || (await (0, e.nextTick)(), j += ue);
        }
    }
    function G(P) {
        if (typeof P != "string") throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(P));
    }
    function R(P) {
        return new TextDecoder().decode(P);
    }
    function X(P) {
        return typeof P == "string" && (P = G(P)), i(P), P;
    }
    function $(P) {
        return typeof P == "string" && (P = G(P)), i(P), P;
    }
    function S(...P) {
        let k = 0;
        for(let j = 0; j < P.length; j++){
            const ie = P[j];
            i(ie), k += ie.length;
        }
        const L = new Uint8Array(k);
        for(let j = 0, ie = 0; j < P.length; j++){
            const ue = P[j];
            L.set(ue, ie), ie += ue.length;
        }
        return L;
    }
    function w(P, k) {
        if (k !== void 0 && ({}).toString.call(k) !== "[object Object]") throw new Error("options should be object or undefined");
        return Object.assign(P, k);
    }
    class g {
    }
    e.Hash = g;
    function m(P) {
        const k = (j)=>P().update(X(j)).digest(), L = P();
        return k.outputLen = L.outputLen, k.blockLen = L.blockLen, k.create = ()=>P(), k;
    }
    function E(P) {
        const k = (j, ie)=>P(ie).update(X(j)).digest(), L = P({});
        return k.outputLen = L.outputLen, k.blockLen = L.blockLen, k.create = (j)=>P(j), k;
    }
    function T(P) {
        const k = (j, ie)=>P(ie).update(X(j)).digest(), L = P({});
        return k.outputLen = L.outputLen, k.blockLen = L.blockLen, k.create = (j)=>P(j), k;
    }
    e.wrapConstructor = m, e.wrapConstructorWithOpts = E, e.wrapXOFConstructorWithOpts = T;
    function I(P = 32) {
        if (t.crypto && typeof t.crypto.getRandomValues == "function") return t.crypto.getRandomValues(new Uint8Array(P));
        if (t.crypto && typeof t.crypto.randomBytes == "function") return Uint8Array.from(t.crypto.randomBytes(P));
        throw new Error("crypto.getRandomValues must be defined");
    }
})(Hr);
Object.defineProperty(Pi, "__esModule", {
    value: !0
});
Pi.SHA512_IV = Pi.SHA384_IV = Pi.SHA224_IV = Pi.SHA256_IV = Pi.HashMD = void 0;
Pi.setBigUint64 = r9;
Pi.Chi = xG;
Pi.Maj = SG;
const Gs = Hr;
function r9(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
function xG(e, t, r) {
    return e & t ^ ~e & r;
}
function SG(e, t, r) {
    return e & t ^ e & r ^ t & r;
}
class AG extends Gs.Hash {
    constructor(t, r, n, i){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = (0, Gs.createView)(this.buffer);
    }
    update(t) {
        (0, Gs.aexists)(this), t = (0, Gs.toBytes)(t), (0, Gs.abytes)(t);
        const { view: r, buffer: n, blockLen: i } = this, o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = (0, Gs.createView)(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        (0, Gs.aexists)(this), (0, Gs.aoutput)(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, (0, Gs.clean)(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        r9(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = (0, Gs.createView)(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.destroyed = s, t.finished = o, t.length = i, t.pos = a, i % r && t.buffer.set(n), t;
    }
    clone() {
        return this._cloneInto();
    }
}
Pi.HashMD = AG;
Pi.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]);
Pi.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
]);
Pi.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
]);
Pi.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]);
var ar = {};
Object.defineProperty(ar, "__esModule", {
    value: !0
});
ar.toBig = ar.shrSL = ar.shrSH = ar.rotrSL = ar.rotrSH = ar.rotrBL = ar.rotrBH = ar.rotr32L = ar.rotr32H = ar.rotlSL = ar.rotlSH = ar.rotlBL = ar.rotlBH = ar.add5L = ar.add5H = ar.add4L = ar.add4H = ar.add3L = ar.add3H = void 0;
ar.add = m9;
ar.fromBig = g3;
ar.split = n9;
const Ng = /* @__PURE__ */ BigInt(2 ** 32 - 1), CE = /* @__PURE__ */ BigInt(32);
function g3(e, t = !1) {
    return t ? {
        h: Number(e & Ng),
        l: Number(e >> CE & Ng)
    } : {
        h: Number(e >> CE & Ng) | 0,
        l: Number(e & Ng) | 0
    };
}
function n9(e, t = !1) {
    const r = e.length;
    let n = new Uint32Array(r), i = new Uint32Array(r);
    for(let o = 0; o < r; o++){
        const { h: s, l: a } = g3(e[o], t);
        [n[o], i[o]] = [
            s,
            a
        ];
    }
    return [
        n,
        i
    ];
}
const i9 = (e, t)=>BigInt(e >>> 0) << CE | BigInt(t >>> 0);
ar.toBig = i9;
const o9 = (e, t, r)=>e >>> r;
ar.shrSH = o9;
const s9 = (e, t, r)=>e << 32 - r | t >>> r;
ar.shrSL = s9;
const a9 = (e, t, r)=>e >>> r | t << 32 - r;
ar.rotrSH = a9;
const c9 = (e, t, r)=>e << 32 - r | t >>> r;
ar.rotrSL = c9;
const u9 = (e, t, r)=>e << 64 - r | t >>> r - 32;
ar.rotrBH = u9;
const f9 = (e, t, r)=>e >>> r - 32 | t << 64 - r;
ar.rotrBL = f9;
const l9 = (e, t)=>t;
ar.rotr32H = l9;
const d9 = (e, t)=>e;
ar.rotr32L = d9;
const h9 = (e, t, r)=>e << r | t >>> 32 - r;
ar.rotlSH = h9;
const p9 = (e, t, r)=>t << r | e >>> 32 - r;
ar.rotlSL = p9;
const g9 = (e, t, r)=>t << r - 32 | e >>> 64 - r;
ar.rotlBH = g9;
const y9 = (e, t, r)=>e << r - 32 | t >>> 64 - r;
ar.rotlBL = y9;
function m9(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    };
}
const b9 = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0);
ar.add3L = b9;
const w9 = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0;
ar.add3H = w9;
const v9 = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
ar.add4L = v9;
const _9 = (e, t, r, n, i)=>t + r + n + i + (e / 2 ** 32 | 0) | 0;
ar.add4H = _9;
const E9 = (e, t, r, n, i)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0);
ar.add5L = E9;
const x9 = (e, t, r, n, i, o)=>t + r + n + i + o + (e / 2 ** 32 | 0) | 0;
ar.add5H = x9;
const TG = {
    fromBig: g3,
    split: n9,
    toBig: i9,
    shrSH: o9,
    shrSL: s9,
    rotrSH: a9,
    rotrSL: c9,
    rotrBH: u9,
    rotrBL: f9,
    rotr32H: l9,
    rotr32L: d9,
    rotlSH: h9,
    rotlSL: p9,
    rotlBH: g9,
    rotlBL: y9,
    add: m9,
    add3L: b9,
    add3H: w9,
    add4L: v9,
    add4H: _9,
    add5H: x9,
    add5L: E9
};
ar.default = TG;
Object.defineProperty(en, "__esModule", {
    value: !0
});
en.sha512_224 = en.sha512_256 = en.sha384 = en.sha512 = en.sha224 = B9 = en.sha256 = en.SHA512_256 = en.SHA512_224 = en.SHA384 = en.SHA512 = en.SHA224 = en.SHA256 = void 0;
const Kt = Pi, _r = ar, Fn = Hr, kG = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Rc = /* @__PURE__ */ new Uint32Array(64);
let y3 = class extends Kt.HashMD {
    constructor(t = 32){
        super(64, t, 8, !1), this.A = Kt.SHA256_IV[0] | 0, this.B = Kt.SHA256_IV[1] | 0, this.C = Kt.SHA256_IV[2] | 0, this.D = Kt.SHA256_IV[3] | 0, this.E = Kt.SHA256_IV[4] | 0, this.F = Kt.SHA256_IV[5] | 0, this.G = Kt.SHA256_IV[6] | 0, this.H = Kt.SHA256_IV[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Rc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Rc[l - 15], y = Rc[l - 2], _ = (0, Fn.rotr)(p, 7) ^ (0, Fn.rotr)(p, 18) ^ p >>> 3, A = (0, Fn.rotr)(y, 17) ^ (0, Fn.rotr)(y, 19) ^ y >>> 10;
            Rc[l] = A + Rc[l - 7] + _ + Rc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = (0, Fn.rotr)(a, 6) ^ (0, Fn.rotr)(a, 11) ^ (0, Fn.rotr)(a, 25), y = c + p + (0, Kt.Chi)(a, u, f) + kG[l] + Rc[l] | 0, A = ((0, Fn.rotr)(n, 2) ^ (0, Fn.rotr)(n, 13) ^ (0, Fn.rotr)(n, 22)) + (0, Kt.Maj)(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        (0, Fn.clean)(Rc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, Fn.clean)(this.buffer);
    }
};
en.SHA256 = y3;
let S9 = class extends y3 {
    constructor(){
        super(28), this.A = Kt.SHA224_IV[0] | 0, this.B = Kt.SHA224_IV[1] | 0, this.C = Kt.SHA224_IV[2] | 0, this.D = Kt.SHA224_IV[3] | 0, this.E = Kt.SHA224_IV[4] | 0, this.F = Kt.SHA224_IV[5] | 0, this.G = Kt.SHA224_IV[6] | 0, this.H = Kt.SHA224_IV[7] | 0;
    }
};
en.SHA224 = S9;
const A9 = _r.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), IG = A9[0], BG = A9[1], Cc = /* @__PURE__ */ new Uint32Array(80), Uc = /* @__PURE__ */ new Uint32Array(80);
let Jp = class extends Kt.HashMD {
    constructor(t = 64){
        super(128, t, 16, !1), this.Ah = Kt.SHA512_IV[0] | 0, this.Al = Kt.SHA512_IV[1] | 0, this.Bh = Kt.SHA512_IV[2] | 0, this.Bl = Kt.SHA512_IV[3] | 0, this.Ch = Kt.SHA512_IV[4] | 0, this.Cl = Kt.SHA512_IV[5] | 0, this.Dh = Kt.SHA512_IV[6] | 0, this.Dl = Kt.SHA512_IV[7] | 0, this.Eh = Kt.SHA512_IV[8] | 0, this.El = Kt.SHA512_IV[9] | 0, this.Fh = Kt.SHA512_IV[10] | 0, this.Fl = Kt.SHA512_IV[11] | 0, this.Gh = Kt.SHA512_IV[12] | 0, this.Gl = Kt.SHA512_IV[13] | 0, this.Hh = Kt.SHA512_IV[14] | 0, this.Hl = Kt.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: u, Eh: f, El: c, Fh: l, Fl: p, Gh: y, Gl: _, Hh: A, Hl: O } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u,
            f,
            c,
            l,
            p,
            y,
            _,
            A,
            O
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = f | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = A | 0, this.Hl = O | 0;
    }
    process(t, r) {
        for(let D = 0; D < 16; D++, r += 4)Cc[D] = t.getUint32(r), Uc[D] = t.getUint32(r += 4);
        for(let D = 16; D < 80; D++){
            const H = Cc[D - 15] | 0, K = Uc[D - 15] | 0, re = _r.rotrSH(H, K, 1) ^ _r.rotrSH(H, K, 8) ^ _r.shrSH(H, K, 7), Q = _r.rotrSL(H, K, 1) ^ _r.rotrSL(H, K, 8) ^ _r.shrSL(H, K, 7), G = Cc[D - 2] | 0, R = Uc[D - 2] | 0, X = _r.rotrSH(G, R, 19) ^ _r.rotrBH(G, R, 61) ^ _r.shrSH(G, R, 6), $ = _r.rotrSL(G, R, 19) ^ _r.rotrBL(G, R, 61) ^ _r.shrSL(G, R, 6), S = _r.add4L(Q, $, Uc[D - 7], Uc[D - 16]), w = _r.add4H(S, re, X, Cc[D - 7], Cc[D - 16]);
            Cc[D] = w | 0, Uc[D] = S | 0;
        }
        let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: u, Dh: f, Dl: c, Eh: l, El: p, Fh: y, Fl: _, Gh: A, Gl: O, Hh: N, Hl: U } = this;
        for(let D = 0; D < 80; D++){
            const H = _r.rotrSH(l, p, 14) ^ _r.rotrSH(l, p, 18) ^ _r.rotrBH(l, p, 41), K = _r.rotrSL(l, p, 14) ^ _r.rotrSL(l, p, 18) ^ _r.rotrBL(l, p, 41), re = l & y ^ ~l & A, Q = p & _ ^ ~p & O, G = _r.add5L(U, K, Q, BG[D], Uc[D]), R = _r.add5H(G, N, H, re, IG[D], Cc[D]), X = G | 0, $ = _r.rotrSH(n, i, 28) ^ _r.rotrBH(n, i, 34) ^ _r.rotrBH(n, i, 39), S = _r.rotrSL(n, i, 28) ^ _r.rotrBL(n, i, 34) ^ _r.rotrBL(n, i, 39), w = n & o ^ n & a ^ o & a, g = i & s ^ i & u ^ s & u;
            N = A | 0, U = O | 0, A = y | 0, O = _ | 0, y = l | 0, _ = p | 0, ({ h: l, l: p } = _r.add(f | 0, c | 0, R | 0, X | 0)), f = a | 0, c = u | 0, a = o | 0, u = s | 0, o = n | 0, s = i | 0;
            const m = _r.add3L(X, S, g);
            n = _r.add3H(m, R, $, w), i = m | 0;
        }
        ({ h: n, l: i } = _r.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), ({ h: o, l: s } = _r.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0)), ({ h: a, l: u } = _r.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: f, l: c } = _r.add(this.Dh | 0, this.Dl | 0, f | 0, c | 0)), ({ h: l, l: p } = _r.add(this.Eh | 0, this.El | 0, l | 0, p | 0)), ({ h: y, l: _ } = _r.add(this.Fh | 0, this.Fl | 0, y | 0, _ | 0)), ({ h: A, l: O } = _r.add(this.Gh | 0, this.Gl | 0, A | 0, O | 0)), ({ h: N, l: U } = _r.add(this.Hh | 0, this.Hl | 0, N | 0, U | 0)), this.set(n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U);
    }
    roundClean() {
        (0, Fn.clean)(Cc, Uc);
    }
    destroy() {
        (0, Fn.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
en.SHA512 = Jp;
let T9 = class extends Jp {
    constructor(){
        super(48), this.Ah = Kt.SHA384_IV[0] | 0, this.Al = Kt.SHA384_IV[1] | 0, this.Bh = Kt.SHA384_IV[2] | 0, this.Bl = Kt.SHA384_IV[3] | 0, this.Ch = Kt.SHA384_IV[4] | 0, this.Cl = Kt.SHA384_IV[5] | 0, this.Dh = Kt.SHA384_IV[6] | 0, this.Dl = Kt.SHA384_IV[7] | 0, this.Eh = Kt.SHA384_IV[8] | 0, this.El = Kt.SHA384_IV[9] | 0, this.Fh = Kt.SHA384_IV[10] | 0, this.Fl = Kt.SHA384_IV[11] | 0, this.Gh = Kt.SHA384_IV[12] | 0, this.Gl = Kt.SHA384_IV[13] | 0, this.Hh = Kt.SHA384_IV[14] | 0, this.Hl = Kt.SHA384_IV[15] | 0;
    }
};
en.SHA384 = T9;
const Si = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
]), Ai = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
]);
let k9 = class extends Jp {
    constructor(){
        super(28), this.Ah = Si[0] | 0, this.Al = Si[1] | 0, this.Bh = Si[2] | 0, this.Bl = Si[3] | 0, this.Ch = Si[4] | 0, this.Cl = Si[5] | 0, this.Dh = Si[6] | 0, this.Dl = Si[7] | 0, this.Eh = Si[8] | 0, this.El = Si[9] | 0, this.Fh = Si[10] | 0, this.Fl = Si[11] | 0, this.Gh = Si[12] | 0, this.Gl = Si[13] | 0, this.Hh = Si[14] | 0, this.Hl = Si[15] | 0;
    }
};
en.SHA512_224 = k9;
let I9 = class extends Jp {
    constructor(){
        super(32), this.Ah = Ai[0] | 0, this.Al = Ai[1] | 0, this.Bh = Ai[2] | 0, this.Bl = Ai[3] | 0, this.Ch = Ai[4] | 0, this.Cl = Ai[5] | 0, this.Dh = Ai[6] | 0, this.Dl = Ai[7] | 0, this.Eh = Ai[8] | 0, this.El = Ai[9] | 0, this.Fh = Ai[10] | 0, this.Fl = Ai[11] | 0, this.Gh = Ai[12] | 0, this.Gl = Ai[13] | 0, this.Hh = Ai[14] | 0, this.Hl = Ai[15] | 0;
    }
};
en.SHA512_256 = I9;
var B9 = en.sha256 = (0, Fn.createHasher)(()=>new y3());
en.sha224 = (0, Fn.createHasher)(()=>new S9());
en.sha512 = (0, Fn.createHasher)(()=>new Jp());
en.sha384 = (0, Fn.createHasher)(()=>new T9());
en.sha512_256 = (0, Fn.createHasher)(()=>new I9());
en.sha512_224 = (0, Fn.createHasher)(()=>new k9());
var yb = {}, m3 = {}, Qp = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.hmac = e.HMAC = void 0;
    const t = Hr;
    class r extends t.Hash {
        constructor(o, s){
            super(), this.finished = !1, this.destroyed = !1, (0, t.ahash)(o);
            const a = (0, t.toBytes)(s);
            if (this.iHash = o.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
            const u = this.blockLen, f = new Uint8Array(u);
            f.set(a.length > u ? o.create().update(a).digest() : a);
            for(let c = 0; c < f.length; c++)f[c] ^= 54;
            this.iHash.update(f), this.oHash = o.create();
            for(let c = 0; c < f.length; c++)f[c] ^= 106;
            this.oHash.update(f), (0, t.clean)(f);
        }
        update(o) {
            return (0, t.aexists)(this), this.iHash.update(o), this;
        }
        digestInto(o) {
            (0, t.aexists)(this), (0, t.abytes)(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();
        }
        digest() {
            const o = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(o), o;
        }
        _cloneInto(o) {
            o || (o = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash: s, iHash: a, finished: u, destroyed: f, blockLen: c, outputLen: l } = this;
            return o = o, o.finished = u, o.destroyed = f, o.blockLen = c, o.outputLen = l, o.oHash = s._cloneInto(o.oHash), o.iHash = a._cloneInto(o.iHash), o;
        }
        clone() {
            return this._cloneInto();
        }
        destroy() {
            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
        }
    }
    e.HMAC = r;
    const n = (i, o, s)=>new r(i, o).update(s).digest();
    e.hmac = n, e.hmac.create = (i, o)=>new r(i, o);
})(Qp);
var Mf = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.notImplemented = e.bitMask = e.utf8ToBytes = e.randomBytes = e.isBytes = e.hexToBytes = e.concatBytes = e.bytesToUtf8 = e.bytesToHex = e.anumber = e.abytes = void 0, e.abool = o, e.numberToHexUnpadded = s, e.hexToNumber = a, e.bytesToNumberBE = u, e.bytesToNumberLE = f, e.numberToBytesBE = c, e.numberToBytesLE = l, e.numberToVarBytesBE = p, e.ensureBytes = y, e.equalBytes = _, e.inRange = O, e.aInRange = N, e.bitLen = U, e.bitGet = D, e.bitSet = H, e.createHmacDrbg = re, e.validateObject = G, e.isHash = R, e._validateObject = X, e.memoized = S;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = Hr;
    var r = Hr;
    Object.defineProperty(e, "abytes", {
        enumerable: !0,
        get: function() {
            return r.abytes;
        }
    }), Object.defineProperty(e, "anumber", {
        enumerable: !0,
        get: function() {
            return r.anumber;
        }
    }), Object.defineProperty(e, "bytesToHex", {
        enumerable: !0,
        get: function() {
            return r.bytesToHex;
        }
    }), Object.defineProperty(e, "bytesToUtf8", {
        enumerable: !0,
        get: function() {
            return r.bytesToUtf8;
        }
    }), Object.defineProperty(e, "concatBytes", {
        enumerable: !0,
        get: function() {
            return r.concatBytes;
        }
    }), Object.defineProperty(e, "hexToBytes", {
        enumerable: !0,
        get: function() {
            return r.hexToBytes;
        }
    }), Object.defineProperty(e, "isBytes", {
        enumerable: !0,
        get: function() {
            return r.isBytes;
        }
    }), Object.defineProperty(e, "randomBytes", {
        enumerable: !0,
        get: function() {
            return r.randomBytes;
        }
    }), Object.defineProperty(e, "utf8ToBytes", {
        enumerable: !0,
        get: function() {
            return r.utf8ToBytes;
        }
    });
    const n = /* @__PURE__ */ BigInt(0), i = /* @__PURE__ */ BigInt(1);
    function o(w, g) {
        if (typeof g != "boolean") throw new Error(w + " boolean expected, got " + g);
    }
    function s(w) {
        const g = w.toString(16);
        return g.length & 1 ? "0" + g : g;
    }
    function a(w) {
        if (typeof w != "string") throw new Error("hex string expected, got " + typeof w);
        return w === "" ? n : BigInt("0x" + w);
    }
    function u(w) {
        return a((0, t.bytesToHex)(w));
    }
    function f(w) {
        return (0, t.abytes)(w), a((0, t.bytesToHex)(Uint8Array.from(w).reverse()));
    }
    function c(w, g) {
        return (0, t.hexToBytes)(w.toString(16).padStart(g * 2, "0"));
    }
    function l(w, g) {
        return c(w, g).reverse();
    }
    function p(w) {
        return (0, t.hexToBytes)(s(w));
    }
    function y(w, g, m) {
        let E;
        if (typeof g == "string") try {
            E = (0, t.hexToBytes)(g);
        } catch (I) {
            throw new Error(w + " must be hex string or Uint8Array, cause: " + I);
        }
        else if ((0, t.isBytes)(g)) E = Uint8Array.from(g);
        else throw new Error(w + " must be hex string or Uint8Array");
        const T = E.length;
        if (typeof m == "number" && T !== m) throw new Error(w + " of length " + m + " expected, got " + T);
        return E;
    }
    function _(w, g) {
        if (w.length !== g.length) return !1;
        let m = 0;
        for(let E = 0; E < w.length; E++)m |= w[E] ^ g[E];
        return m === 0;
    }
    const A = (w)=>typeof w == "bigint" && n <= w;
    function O(w, g, m) {
        return A(w) && A(g) && A(m) && g <= w && w < m;
    }
    function N(w, g, m, E) {
        if (!O(g, m, E)) throw new Error("expected valid " + w + ": " + m + " <= n < " + E + ", got " + g);
    }
    function U(w) {
        let g;
        for(g = 0; w > n; w >>= i, g += 1);
        return g;
    }
    function D(w, g) {
        return w >> BigInt(g) & i;
    }
    function H(w, g, m) {
        return w | (m ? i : n) << BigInt(g);
    }
    const K = (w)=>(i << BigInt(w)) - i;
    e.bitMask = K;
    function re(w, g, m) {
        if (typeof w != "number" || w < 2) throw new Error("hashLen must be a number");
        if (typeof g != "number" || g < 2) throw new Error("qByteLen must be a number");
        if (typeof m != "function") throw new Error("hmacFn must be a function");
        const E = (he)=>new Uint8Array(he), T = (he)=>Uint8Array.of(he);
        let I = E(w), P = E(w), k = 0;
        const L = ()=>{
            I.fill(1), P.fill(0), k = 0;
        }, j = (...he)=>m(P, I, ...he), ie = (he = E(0))=>{
            P = j(T(0), he), I = j(), he.length !== 0 && (P = j(T(1), he), I = j());
        }, ue = ()=>{
            if (k++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let he = 0;
            const ee = [];
            for(; he < g;){
                I = j();
                const ae = I.slice();
                ee.push(ae), he += I.length;
            }
            return (0, t.concatBytes)(...ee);
        };
        return (he, ee)=>{
            L(), ie(he);
            let ae;
            for(; !(ae = ee(ue()));)ie();
            return L(), ae;
        };
    }
    const Q = {
        bigint: (w)=>typeof w == "bigint",
        function: (w)=>typeof w == "function",
        boolean: (w)=>typeof w == "boolean",
        string: (w)=>typeof w == "string",
        stringOrUint8Array: (w)=>typeof w == "string" || (0, t.isBytes)(w),
        isSafeInteger: (w)=>Number.isSafeInteger(w),
        array: (w)=>Array.isArray(w),
        field: (w, g)=>g.Fp.isValid(w),
        hash: (w)=>typeof w == "function" && Number.isSafeInteger(w.outputLen)
    };
    function G(w, g, m = {}) {
        const E = (T, I, P)=>{
            const k = Q[I];
            if (typeof k != "function") throw new Error("invalid validator function");
            const L = w[T];
            if (!(P && L === void 0) && !k(L, w)) throw new Error("param " + String(T) + " is invalid. Expected " + I + ", got " + L);
        };
        for (const [T, I] of Object.entries(g))E(T, I, !1);
        for (const [T, I] of Object.entries(m))E(T, I, !0);
        return w;
    }
    function R(w) {
        return typeof w == "function" && Number.isSafeInteger(w.outputLen);
    }
    function X(w, g, m = {}) {
        if (!w || typeof w != "object") throw new Error("expected valid options object");
        function E(T, I, P) {
            const k = w[T];
            if (P && k === void 0) return;
            const L = typeof k;
            if (L !== I || k === null) throw new Error(`param "${T}" is invalid: expected ${I}, got ${L}`);
        }
        Object.entries(g).forEach(([T, I])=>E(T, I, !1)), Object.entries(m).forEach(([T, I])=>E(T, I, !0));
    }
    const $ = ()=>{
        throw new Error("not implemented");
    };
    e.notImplemented = $;
    function S(w) {
        const g = /* @__PURE__ */ new WeakMap();
        return (m, ...E)=>{
            const T = g.get(m);
            if (T !== void 0) return T;
            const I = w(m, ...E);
            return g.set(m, I), I;
        };
    }
})(Mf);
var xa = {}, sn = {};
Object.defineProperty(sn, "__esModule", {
    value: !0
});
sn.isNegativeLE = void 0;
sn.mod = Io;
sn.pow = PG;
sn.pow2 = NG;
sn.invert = tm;
sn.tonelliShanks = R9;
sn.FpSqrt = C9;
sn.validateField = UG;
sn.FpPow = b3;
sn.FpInvertBatch = U9;
sn.FpDiv = $G;
sn.FpLegendre = rm;
sn.FpIsSquare = LG;
sn.nLength = w3;
sn.Field = v3;
sn.FpSqrtOdd = DG;
sn.FpSqrtEven = FG;
sn.hashToPrivateScalar = zG;
sn.getFieldBytesLength = _3;
sn.getMinHashLength = $9;
sn.mapHashToField = jG;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const io = Mf, so = BigInt(0), Xn = BigInt(1), nf = /* @__PURE__ */ BigInt(2), OG = /* @__PURE__ */ BigInt(3), O9 = /* @__PURE__ */ BigInt(4), P9 = /* @__PURE__ */ BigInt(5), N9 = /* @__PURE__ */ BigInt(8);
function Io(e, t) {
    const r = e % t;
    return r >= so ? r : t + r;
}
function PG(e, t, r) {
    return b3(v3(r), e, t);
}
function NG(e, t, r) {
    let n = e;
    for(; t-- > so;)n *= n, n %= r;
    return n;
}
function tm(e, t) {
    if (e === so) throw new Error("invert: expected non-zero number");
    if (t <= so) throw new Error("invert: expected positive modulus, got " + t);
    let r = Io(e, t), n = t, i = so, o = Xn;
    for(; r !== so;){
        const a = n / r, u = n % r, f = i - o * a;
        n = r, r = u, i = o, o = f;
    }
    if (n !== Xn) throw new Error("invert: does not exist");
    return Io(i, t);
}
function M9(e, t) {
    const r = (e.ORDER + Xn) / O9, n = e.pow(t, r);
    if (!e.eql(e.sqr(n), t)) throw new Error("Cannot find square root");
    return n;
}
function MG(e, t) {
    const r = (e.ORDER - P9) / N9, n = e.mul(t, nf), i = e.pow(n, r), o = e.mul(t, i), s = e.mul(e.mul(o, nf), i), a = e.mul(o, e.sub(s, e.ONE));
    if (!e.eql(e.sqr(a), t)) throw new Error("Cannot find square root");
    return a;
}
function R9(e) {
    if (e < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let t = e - Xn, r = 0;
    for(; t % nf === so;)t /= nf, r++;
    let n = nf;
    const i = v3(e);
    for(; rm(i, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return M9;
    let o = i.pow(n, t);
    const s = (t + Xn) / nf;
    return function(u, f) {
        if (u.is0(f)) return f;
        if (rm(u, f) !== 1) throw new Error("Cannot find square root");
        let c = r, l = u.mul(u.ONE, o), p = u.pow(f, t), y = u.pow(f, s);
        for(; !u.eql(p, u.ONE);){
            if (u.is0(p)) return u.ZERO;
            let _ = 1, A = u.sqr(p);
            for(; !u.eql(A, u.ONE);)if (_++, A = u.sqr(A), _ === c) throw new Error("Cannot find square root");
            const O = Xn << BigInt(c - _ - 1), N = u.pow(l, O);
            c = _, l = u.sqr(N), p = u.mul(p, l), y = u.mul(y, N);
        }
        return y;
    };
}
function C9(e) {
    return e % O9 === OG ? M9 : e % N9 === P9 ? MG : R9(e);
}
const RG = (e, t)=>(Io(e, t) & Xn) === Xn;
sn.isNegativeLE = RG;
const CG = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function UG(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, r = CG.reduce((n, i)=>(n[i] = "function", n), t);
    return (0, io._validateObject)(e, r), e;
}
function b3(e, t, r) {
    if (r < so) throw new Error("invalid exponent, negatives unsupported");
    if (r === so) return e.ONE;
    if (r === Xn) return t;
    let n = e.ONE, i = t;
    for(; r > so;)r & Xn && (n = e.mul(n, i)), i = e.sqr(i), r >>= Xn;
    return n;
}
function U9(e, t, r = !1) {
    const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, a, u)=>e.is0(a) ? s : (n[u] = s, e.mul(s, a)), e.ONE), o = e.inv(i);
    return t.reduceRight((s, a, u)=>e.is0(a) ? s : (n[u] = e.mul(s, n[u]), e.mul(s, a)), o), n;
}
function $G(e, t, r) {
    return e.mul(t, typeof r == "bigint" ? tm(r, e.ORDER) : e.inv(r));
}
function rm(e, t) {
    const r = (e.ORDER - Xn) / nf, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), s = e.eql(n, e.neg(e.ONE));
    if (!i && !o && !s) throw new Error("invalid Legendre symbol result");
    return i ? 1 : o ? 0 : -1;
}
function LG(e, t) {
    return rm(e, t) === 1;
}
function w3(e, t) {
    t !== void 0 && (0, io.anumber)(t);
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function v3(e, t, r = !1, n = {}) {
    if (e <= so) throw new Error("invalid field: expected ORDER > 0, got " + e);
    let i, o;
    if (typeof t == "object" && t != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const c = t;
        c.BITS && (i = c.BITS), c.sqrt && (o = c.sqrt), typeof c.isLE == "boolean" && (r = c.isLE);
    } else typeof t == "number" && (i = t), n.sqrt && (o = n.sqrt);
    const { nBitLength: s, nByteLength: a } = w3(e, i);
    if (a > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const f = Object.freeze({
        ORDER: e,
        isLE: r,
        BITS: s,
        BYTES: a,
        MASK: (0, io.bitMask)(s),
        ZERO: so,
        ONE: Xn,
        create: (c)=>Io(c, e),
        isValid: (c)=>{
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return so <= c && c < e;
        },
        is0: (c)=>c === so,
        // is valid and invertible
        isValidNot0: (c)=>!f.is0(c) && f.isValid(c),
        isOdd: (c)=>(c & Xn) === Xn,
        neg: (c)=>Io(-c, e),
        eql: (c, l)=>c === l,
        sqr: (c)=>Io(c * c, e),
        add: (c, l)=>Io(c + l, e),
        sub: (c, l)=>Io(c - l, e),
        mul: (c, l)=>Io(c * l, e),
        pow: (c, l)=>b3(f, c, l),
        div: (c, l)=>Io(c * tm(l, e), e),
        // Same as above, but doesn't normalize
        sqrN: (c)=>c * c,
        addN: (c, l)=>c + l,
        subN: (c, l)=>c - l,
        mulN: (c, l)=>c * l,
        inv: (c)=>tm(c, e),
        sqrt: o || ((c)=>(u || (u = C9(e)), u(f, c))),
        toBytes: (c)=>r ? (0, io.numberToBytesLE)(c, a) : (0, io.numberToBytesBE)(c, a),
        fromBytes: (c)=>{
            if (c.length !== a) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + c.length);
            return r ? (0, io.bytesToNumberLE)(c) : (0, io.bytesToNumberBE)(c);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (c)=>U9(f, c),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (c, l, p)=>p ? l : c
    });
    return Object.freeze(f);
}
function DG(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? r : e.neg(r);
}
function FG(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? e.neg(r) : r;
}
function zG(e, t, r = !1) {
    e = (0, io.ensureBytes)("privateHash", e);
    const n = e.length, i = w3(t).nByteLength + 8;
    if (i < 24 || n < i || n > 1024) throw new Error("hashToPrivateScalar: expected " + i + "-1024 bytes of input, got " + n);
    const o = r ? (0, io.bytesToNumberLE)(e) : (0, io.bytesToNumberBE)(e);
    return Io(o, t - Xn) + Xn;
}
function _3(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function $9(e) {
    const t = _3(e);
    return t + Math.ceil(t / 2);
}
function jG(e, t, r = !1) {
    const n = e.length, i = _3(t), o = $9(t);
    if (n < 16 || n < o || n > 1024) throw new Error("expected " + o + "-1024 bytes of input, got " + n);
    const s = r ? (0, io.bytesToNumberLE)(e) : (0, io.bytesToNumberBE)(e), a = Io(s, t - Xn) + Xn;
    return r ? (0, io.numberToBytesLE)(a, i) : (0, io.numberToBytesBE)(a, i);
}
Object.defineProperty(xa, "__esModule", {
    value: !0
});
xa.negateCt = Ty;
xa.normalizeZ = HG;
xa.wNAF = qG;
xa.mulEndoUnsafe = KG;
xa.pippenger = WG;
xa.precomputeMSMUnsafe = VG;
xa.validateBasic = GG;
xa._createCurveFields = ZG;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ip = Mf, op = sn, ed = BigInt(0), of = BigInt(1);
function Ty(e, t) {
    const r = t.negate();
    return e ? r : t;
}
function HG(e, t, r) {
    const n = t === "pz" ? (s)=>s.pz : (s)=>s.ez, i = (0, op.FpInvertBatch)(e.Fp, r.map(n));
    return r.map((s, a)=>s.toAffine(i[a])).map(e.fromAffine);
}
function E3(e, t) {
    if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function rv(e, t) {
    E3(e, t);
    const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = (0, ip.bitMask)(e), s = BigInt(e);
    return {
        windows: r,
        windowSize: n,
        mask: o,
        maxNumber: i,
        shiftBy: s
    };
}
function pA(e, t, r) {
    const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = r;
    let a = Number(e & i), u = e >> s;
    a > n && (a -= o, u += of);
    const f = t * n, c = f + Math.abs(a) - 1, l = a === 0, p = a < 0, y = t % 2 !== 0;
    return {
        nextN: u,
        offset: c,
        isZero: l,
        isNeg: p,
        isNegF: y,
        offsetF: f
    };
}
function L9(e, t) {
    if (!Array.isArray(e)) throw new Error("array expected");
    e.forEach((r, n)=>{
        if (!(r instanceof t)) throw new Error("invalid point at index " + n);
    });
}
function D9(e, t) {
    if (!Array.isArray(e)) throw new Error("array of scalars expected");
    e.forEach((r, n)=>{
        if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
    });
}
const nv = /* @__PURE__ */ new WeakMap(), F9 = /* @__PURE__ */ new WeakMap();
function iv(e) {
    return F9.get(e) || 1;
}
function gA(e) {
    if (e !== ed) throw new Error("invalid wNAF");
}
function qG(e, t) {
    return {
        constTimeNegate: Ty,
        hasPrecomputes (r) {
            return iv(r) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (r, n, i = e.ZERO) {
            let o = r;
            for(; n > ed;)n & of && (i = i.add(o)), o = o.double(), n >>= of;
            return i;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (r, n) {
            const { windows: i, windowSize: o } = rv(n, t), s = [];
            let a = r, u = a;
            for(let f = 0; f < i; f++){
                u = a, s.push(u);
                for(let c = 1; c < o; c++)u = u.add(a), s.push(u);
                a = u.double();
            }
            return s;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (r, n, i) {
            let o = e.ZERO, s = e.BASE;
            const a = rv(r, t);
            for(let u = 0; u < a.windows; u++){
                const { nextN: f, offset: c, isZero: l, isNeg: p, isNegF: y, offsetF: _ } = pA(i, u, a);
                i = f, l ? s = s.add(Ty(y, n[_])) : o = o.add(Ty(p, n[c]));
            }
            return gA(i), {
                p: o,
                f: s
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (r, n, i, o = e.ZERO) {
            const s = rv(r, t);
            for(let a = 0; a < s.windows && i !== ed; a++){
                const { nextN: u, offset: f, isZero: c, isNeg: l } = pA(i, a, s);
                if (i = u, !c) {
                    const p = n[f];
                    o = o.add(l ? p.negate() : p);
                }
            }
            return gA(i), o;
        },
        getPrecomputes (r, n, i) {
            let o = nv.get(n);
            return o || (o = this.precomputeWindow(n, r), r !== 1 && (typeof i == "function" && (o = i(o)), nv.set(n, o))), o;
        },
        wNAFCached (r, n, i) {
            const o = iv(r);
            return this.wNAF(o, this.getPrecomputes(o, r, i), n);
        },
        wNAFCachedUnsafe (r, n, i, o) {
            const s = iv(r);
            return s === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, r, i), n, o);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (r, n) {
            E3(n, t), F9.set(r, n), nv.delete(r);
        }
    };
}
function KG(e, t, r, n) {
    let i = t, o = e.ZERO, s = e.ZERO;
    for(; r > ed || n > ed;)r & of && (o = o.add(i)), n & of && (s = s.add(i)), i = i.double(), r >>= of, n >>= of;
    return {
        p1: o,
        p2: s
    };
}
function WG(e, t, r, n) {
    L9(r, e), D9(n, t);
    const i = r.length, o = n.length;
    if (i !== o) throw new Error("arrays of points and scalars must have equal length");
    const s = e.ZERO, a = (0, ip.bitLen)(BigInt(i));
    let u = 1;
    a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
    const f = (0, ip.bitMask)(u), c = new Array(Number(f) + 1).fill(s), l = Math.floor((t.BITS - 1) / u) * u;
    let p = s;
    for(let y = l; y >= 0; y -= u){
        c.fill(s);
        for(let A = 0; A < o; A++){
            const O = n[A], N = Number(O >> BigInt(y) & f);
            c[N] = c[N].add(r[A]);
        }
        let _ = s;
        for(let A = c.length - 1, O = s; A > 0; A--)O = O.add(c[A]), _ = _.add(O);
        if (p = p.add(_), y !== 0) for(let A = 0; A < u; A++)p = p.double();
    }
    return p;
}
function VG(e, t, r, n) {
    E3(n, t.BITS), L9(r, e);
    const i = e.ZERO, o = 2 ** n - 1, s = Math.ceil(t.BITS / n), a = (0, ip.bitMask)(n), u = r.map((f)=>{
        const c = [];
        for(let l = 0, p = f; l < o; l++)c.push(p), p = p.add(f);
        return c;
    });
    return (f)=>{
        if (D9(f, t), f.length > r.length) throw new Error("array of scalars must be smaller than array of points");
        let c = i;
        for(let l = 0; l < s; l++){
            if (c !== i) for(let y = 0; y < n; y++)c = c.double();
            const p = BigInt(s * n - (l + 1) * n);
            for(let y = 0; y < f.length; y++){
                const _ = f[y], A = Number(_ >> p & a);
                A && (c = c.add(u[y][A - 1]));
            }
        }
        return c;
    };
}
function GG(e) {
    return (0, op.validateField)(e.Fp), (0, ip.validateObject)(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...(0, op.nLength)(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
}
function yA(e, t) {
    if (t) {
        if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return (0, op.validateField)(t), t;
    } else return (0, op.Field)(e);
}
function ZG(e, t, r = {}) {
    if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const u = t[a];
        if (!(typeof u == "bigint" && u > ed)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const n = yA(t.p, r.Fp), i = yA(t.n, r.Fn), s = [
        "Gx",
        "Gy",
        "a",
        e === "weierstrass" ? "b" : "d"
    ];
    for (const a of s)if (!n.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i
    };
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.DER = e.DERErr = void 0, e._legacyHelperEquat = p, e._legacyHelperNormPriv = y, e.weierstrassN = _, e.weierstrassPoints = A, e.ecdsa = N, e.weierstrass = re, e.SWUFpSqrtRatio = Q, e.mapToCurveSimpleSWU = G;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = Qp, r = Mf, n = xa, i = sn;
    function o(R) {
        R.lowS !== void 0 && (0, r.abool)("lowS", R.lowS), R.prehash !== void 0 && (0, r.abool)("prehash", R.prehash);
    }
    class s extends Error {
        constructor(X = ""){
            super(X);
        }
    }
    e.DERErr = s, e.DER = {
        // asn.1 DER encoding utils
        Err: s,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
            encode: (R, X)=>{
                const { Err: $ } = e.DER;
                if (R < 0 || R > 256) throw new $("tlv.encode: wrong tag");
                if (X.length & 1) throw new $("tlv.encode: unpadded data");
                const S = X.length / 2, w = (0, r.numberToHexUnpadded)(S);
                if (w.length / 2 & 128) throw new $("tlv.encode: long form length too big");
                const g = S > 127 ? (0, r.numberToHexUnpadded)(w.length / 2 | 128) : "";
                return (0, r.numberToHexUnpadded)(R) + g + w + X;
            },
            // v - value, l - left bytes (unparsed)
            decode (R, X) {
                const { Err: $ } = e.DER;
                let S = 0;
                if (R < 0 || R > 256) throw new $("tlv.encode: wrong tag");
                if (X.length < 2 || X[S++] !== R) throw new $("tlv.decode: wrong tlv");
                const w = X[S++], g = !!(w & 128);
                let m = 0;
                if (!g) m = w;
                else {
                    const T = w & 127;
                    if (!T) throw new $("tlv.decode(long): indefinite length not supported");
                    if (T > 4) throw new $("tlv.decode(long): byte length is too big");
                    const I = X.subarray(S, S + T);
                    if (I.length !== T) throw new $("tlv.decode: length bytes not complete");
                    if (I[0] === 0) throw new $("tlv.decode(long): zero leftmost byte");
                    for (const P of I)m = m << 8 | P;
                    if (S += T, m < 128) throw new $("tlv.decode(long): not minimal encoding");
                }
                const E = X.subarray(S, S + m);
                if (E.length !== m) throw new $("tlv.decode: wrong value length");
                return {
                    v: E,
                    l: X.subarray(S + m)
                };
            }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
            encode (R) {
                const { Err: X } = e.DER;
                if (R < a) throw new X("integer: negative integers are not allowed");
                let $ = (0, r.numberToHexUnpadded)(R);
                if (Number.parseInt($[0], 16) & 8 && ($ = "00" + $), $.length & 1) throw new X("unexpected DER parsing assertion: unpadded hex");
                return $;
            },
            decode (R) {
                const { Err: X } = e.DER;
                if (R[0] & 128) throw new X("invalid signature integer: negative");
                if (R[0] === 0 && !(R[1] & 128)) throw new X("invalid signature integer: unnecessary leading zero");
                return (0, r.bytesToNumberBE)(R);
            }
        },
        toSig (R) {
            const { Err: X, _int: $, _tlv: S } = e.DER, w = (0, r.ensureBytes)("signature", R), { v: g, l: m } = S.decode(48, w);
            if (m.length) throw new X("invalid signature: left bytes after parsing");
            const { v: E, l: T } = S.decode(2, g), { v: I, l: P } = S.decode(2, T);
            if (P.length) throw new X("invalid signature: left bytes after parsing");
            return {
                r: $.decode(E),
                s: $.decode(I)
            };
        },
        hexFromSig (R) {
            const { _tlv: X, _int: $ } = e.DER, S = X.encode(2, $.encode(R.r)), w = X.encode(2, $.encode(R.s)), g = S + w;
            return X.encode(48, g);
        }
    };
    const a = BigInt(0), u = BigInt(1), f = BigInt(2), c = BigInt(3), l = BigInt(4);
    function p(R, X, $) {
        function S(w) {
            const g = R.sqr(w), m = R.mul(g, w);
            return R.add(R.add(m, R.mul(w, X)), $);
        }
        return S;
    }
    function y(R, X, $) {
        const { BYTES: S } = R;
        function w(g) {
            let m;
            if (typeof g == "bigint") m = g;
            else {
                let E = (0, r.ensureBytes)("private key", g);
                if (X) {
                    if (!X.includes(E.length * 2)) throw new Error("invalid private key");
                    const T = new Uint8Array(S);
                    T.set(E, T.length - E.length), E = T;
                }
                try {
                    m = R.fromBytes(E);
                } catch  {
                    throw new Error(`invalid private key: expected ui8a of size ${S}, got ${typeof g}`);
                }
            }
            if ($ && (m = R.create(m)), !R.isValidNot0(m)) throw new Error("invalid private key: out of range [1..N-1]");
            return m;
        }
        return w;
    }
    function _(R, X = {}) {
        const { Fp: $, Fn: S } = (0, n._createCurveFields)("weierstrass", R, X), { h: w, n: g } = R;
        (0, r._validateObject)(X, {}, {
            allowInfinityPoint: "boolean",
            clearCofactor: "function",
            isTorsionFree: "function",
            fromBytes: "function",
            toBytes: "function",
            endo: "object",
            wrapPrivateKey: "boolean"
        });
        const { endo: m } = X;
        if (m && (!$.is0(R.a) || typeof m.beta != "bigint" || typeof m.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
        function E() {
            if (!$.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
        }
        function T(Ce, M, z) {
            const { x: de, y: _e } = M.toAffine(), Ie = $.toBytes(de);
            if ((0, r.abool)("isCompressed", z), z) {
                E();
                const je = !$.isOdd(_e);
                return (0, r.concatBytes)(O(je), Ie);
            } else return (0, r.concatBytes)(Uint8Array.of(4), Ie, $.toBytes(_e));
        }
        function I(Ce) {
            (0, r.abytes)(Ce);
            const M = $.BYTES, z = M + 1, de = 2 * M + 1, _e = Ce.length, Ie = Ce[0], je = Ce.subarray(1);
            if (_e === z && (Ie === 2 || Ie === 3)) {
                const Ke = $.fromBytes(je);
                if (!$.isValid(Ke)) throw new Error("bad point: is not on curve, wrong x");
                const Ue = L(Ke);
                let h;
                try {
                    h = $.sqrt(Ue);
                } catch (te) {
                    const fe = te instanceof Error ? ": " + te.message : "";
                    throw new Error("bad point: is not on curve, sqrt error" + fe);
                }
                E();
                const x = $.isOdd(h);
                return (Ie & 1) === 1 !== x && (h = $.neg(h)), {
                    x: Ke,
                    y: h
                };
            } else if (_e === de && Ie === 4) {
                const Ke = $.fromBytes(je.subarray(M * 0, M * 1)), Ue = $.fromBytes(je.subarray(M * 1, M * 2));
                if (!j(Ke, Ue)) throw new Error("bad point: is not on curve");
                return {
                    x: Ke,
                    y: Ue
                };
            } else throw new Error(`bad point: got length ${_e}, expected compressed=${z} or uncompressed=${de}`);
        }
        const P = X.toBytes || T, k = X.fromBytes || I, L = p($, R.a, R.b);
        function j(Ce, M) {
            const z = $.sqr(M), de = L(Ce);
            return $.eql(z, de);
        }
        if (!j(R.Gx, R.Gy)) throw new Error("bad curve params: generator point");
        const ie = $.mul($.pow(R.a, c), l), ue = $.mul($.sqr(R.b), BigInt(27));
        if ($.is0($.add(ie, ue))) throw new Error("bad curve params: a or b");
        function ce(Ce, M, z = !1) {
            if (!$.isValid(M) || z && $.is0(M)) throw new Error(`bad point coordinate ${Ce}`);
            return M;
        }
        function he(Ce) {
            if (!(Ce instanceof Se)) throw new Error("ProjectivePoint expected");
        }
        const ee = (0, r.memoized)((Ce, M)=>{
            const { px: z, py: de, pz: _e } = Ce;
            if ($.eql(_e, $.ONE)) return {
                x: z,
                y: de
            };
            const Ie = Ce.is0();
            M == null && (M = Ie ? $.ONE : $.inv(_e));
            const je = $.mul(z, M), Ke = $.mul(de, M), Ue = $.mul(_e, M);
            if (Ie) return {
                x: $.ZERO,
                y: $.ZERO
            };
            if (!$.eql(Ue, $.ONE)) throw new Error("invZ was invalid");
            return {
                x: je,
                y: Ke
            };
        }), ae = (0, r.memoized)((Ce)=>{
            if (Ce.is0()) {
                if (X.allowInfinityPoint && !$.is0(Ce.py)) return;
                throw new Error("bad point: ZERO");
            }
            const { x: M, y: z } = Ce.toAffine();
            if (!$.isValid(M) || !$.isValid(z)) throw new Error("bad point: x or y not field elements");
            if (!j(M, z)) throw new Error("bad point: equation left != right");
            if (!Ce.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0;
        });
        function ye(Ce, M, z, de, _e) {
            return z = new Se($.mul(z.px, Ce), z.py, z.pz), M = (0, n.negateCt)(de, M), z = (0, n.negateCt)(_e, z), M.add(z);
        }
        class Se {
            /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(M, z, de){
                this.px = ce("x", M), this.py = ce("y", z, !0), this.pz = ce("z", de), Object.freeze(this);
            }
            /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(M) {
                const { x: z, y: de } = M || {};
                if (!M || !$.isValid(z) || !$.isValid(de)) throw new Error("invalid affine point");
                if (M instanceof Se) throw new Error("projective point not allowed");
                return $.is0(z) && $.is0(de) ? Se.ZERO : new Se(z, de, $.ONE);
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            static normalizeZ(M) {
                return (0, n.normalizeZ)(Se, "pz", M);
            }
            static fromBytes(M) {
                return (0, r.abytes)(M), Se.fromHex(M);
            }
            /** Converts hash string or Uint8Array to Point. */ static fromHex(M) {
                const z = Se.fromAffine(k((0, r.ensureBytes)("pointHex", M)));
                return z.assertValidity(), z;
            }
            /** Multiplies generator point by privateKey. */ static fromPrivateKey(M) {
                const z = y(S, X.allowedPrivateKeyLengths, X.wrapPrivateKey);
                return Se.BASE.multiply(z(M));
            }
            /** Multiscalar Multiplication */ static msm(M, z) {
                return (0, n.pippenger)(Se, S, M, z);
            }
            /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */ precompute(M = 8, z = !0) {
                return Re.setWindowSize(this, M), z || this.multiply(c), this;
            }
            /** "Private method", don't use it directly */ _setWindowSize(M) {
                this.precompute(M);
            }
            // TODO: return `this`
            /** A point on curve is valid if it conforms to equation. */ assertValidity() {
                ae(this);
            }
            hasEvenY() {
                const { y: M } = this.toAffine();
                if (!$.isOdd) throw new Error("Field doesn't support isOdd");
                return !$.isOdd(M);
            }
            /** Compare one point to another. */ equals(M) {
                he(M);
                const { px: z, py: de, pz: _e } = this, { px: Ie, py: je, pz: Ke } = M, Ue = $.eql($.mul(z, Ke), $.mul(Ie, _e)), h = $.eql($.mul(de, Ke), $.mul(je, _e));
                return Ue && h;
            }
            /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
                return new Se(this.px, $.neg(this.py), this.pz);
            }
            // Renes-Costello-Batina exception-free doubling formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 3
            // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
            double() {
                const { a: M, b: z } = R, de = $.mul(z, c), { px: _e, py: Ie, pz: je } = this;
                let Ke = $.ZERO, Ue = $.ZERO, h = $.ZERO, x = $.mul(_e, _e), q = $.mul(Ie, Ie), te = $.mul(je, je), fe = $.mul(_e, Ie);
                return fe = $.add(fe, fe), h = $.mul(_e, je), h = $.add(h, h), Ke = $.mul(M, h), Ue = $.mul(de, te), Ue = $.add(Ke, Ue), Ke = $.sub(q, Ue), Ue = $.add(q, Ue), Ue = $.mul(Ke, Ue), Ke = $.mul(fe, Ke), h = $.mul(de, h), te = $.mul(M, te), fe = $.sub(x, te), fe = $.mul(M, fe), fe = $.add(fe, h), h = $.add(x, x), x = $.add(h, x), x = $.add(x, te), x = $.mul(x, fe), Ue = $.add(Ue, x), te = $.mul(Ie, je), te = $.add(te, te), x = $.mul(te, fe), Ke = $.sub(Ke, x), h = $.mul(te, q), h = $.add(h, h), h = $.add(h, h), new Se(Ke, Ue, h);
            }
            // Renes-Costello-Batina exception-free addition formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 1
            // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
            add(M) {
                he(M);
                const { px: z, py: de, pz: _e } = this, { px: Ie, py: je, pz: Ke } = M;
                let Ue = $.ZERO, h = $.ZERO, x = $.ZERO;
                const q = R.a, te = $.mul(R.b, c);
                let fe = $.mul(z, Ie), ne = $.mul(de, je), W = $.mul(_e, Ke), J = $.add(z, de), V = $.add(Ie, je);
                J = $.mul(J, V), V = $.add(fe, ne), J = $.sub(J, V), V = $.add(z, _e);
                let C = $.add(Ie, Ke);
                return V = $.mul(V, C), C = $.add(fe, W), V = $.sub(V, C), C = $.add(de, _e), Ue = $.add(je, Ke), C = $.mul(C, Ue), Ue = $.add(ne, W), C = $.sub(C, Ue), x = $.mul(q, V), Ue = $.mul(te, W), x = $.add(Ue, x), Ue = $.sub(ne, x), x = $.add(ne, x), h = $.mul(Ue, x), ne = $.add(fe, fe), ne = $.add(ne, fe), W = $.mul(q, W), V = $.mul(te, V), ne = $.add(ne, W), W = $.sub(fe, W), W = $.mul(q, W), V = $.add(V, W), fe = $.mul(ne, V), h = $.add(h, fe), fe = $.mul(C, V), Ue = $.mul(J, Ue), Ue = $.sub(Ue, fe), fe = $.mul(J, ne), x = $.mul(C, x), x = $.add(x, fe), new Se(Ue, h, x);
            }
            subtract(M) {
                return this.add(M.negate());
            }
            is0() {
                return this.equals(Se.ZERO);
            }
            /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */ multiply(M) {
                const { endo: z } = X;
                if (!S.isValidNot0(M)) throw new Error("invalid scalar: out of range");
                let de, _e;
                const Ie = (je)=>Re.wNAFCached(this, je, Se.normalizeZ);
                if (z) {
                    const { k1neg: je, k1: Ke, k2neg: Ue, k2: h } = z.splitScalar(M), { p: x, f: q } = Ie(Ke), { p: te, f: fe } = Ie(h);
                    _e = q.add(fe), de = ye(z.beta, x, te, je, Ue);
                } else {
                    const { p: je, f: Ke } = Ie(M);
                    de = je, _e = Ke;
                }
                return Se.normalizeZ([
                    de,
                    _e
                ])[0];
            }
            /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */ multiplyUnsafe(M) {
                const { endo: z } = X, de = this;
                if (!S.isValid(M)) throw new Error("invalid scalar: out of range");
                if (M === a || de.is0()) return Se.ZERO;
                if (M === u) return de;
                if (Re.hasPrecomputes(this)) return this.multiply(M);
                if (z) {
                    const { k1neg: _e, k1: Ie, k2neg: je, k2: Ke } = z.splitScalar(M), { p1: Ue, p2: h } = (0, n.mulEndoUnsafe)(Se, de, Ie, Ke);
                    return ye(z.beta, Ue, h, _e, je);
                } else return Re.wNAFCachedUnsafe(de, M);
            }
            multiplyAndAddUnsafe(M, z, de) {
                const _e = this.multiplyUnsafe(z).add(M.multiplyUnsafe(de));
                return _e.is0() ? void 0 : _e;
            }
            /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */ toAffine(M) {
                return ee(this, M);
            }
            /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */ isTorsionFree() {
                const { isTorsionFree: M } = X;
                return w === u ? !0 : M ? M(Se, this) : Re.wNAFCachedUnsafe(this, g).is0();
            }
            clearCofactor() {
                const { clearCofactor: M } = X;
                return w === u ? this : M ? M(Se, this) : this.multiplyUnsafe(w);
            }
            toBytes(M = !0) {
                return (0, r.abool)("isCompressed", M), this.assertValidity(), P(Se, this, M);
            }
            /** @deprecated use `toBytes` */ toRawBytes(M = !0) {
                return this.toBytes(M);
            }
            toHex(M = !0) {
                return (0, r.bytesToHex)(this.toBytes(M));
            }
            toString() {
                return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
            }
        }
        Se.BASE = new Se(R.Gx, R.Gy, $.ONE), Se.ZERO = new Se($.ZERO, $.ONE, $.ZERO), Se.Fp = $, Se.Fn = S;
        const De = S.BITS, Re = (0, n.wNAF)(Se, X.endo ? Math.ceil(De / 2) : De);
        return Se;
    }
    function A(R) {
        const { CURVE: X, curveOpts: $ } = U(R), S = _(X, $);
        return H(R, S);
    }
    function O(R) {
        return Uint8Array.of(R ? 2 : 3);
    }
    function N(R, X, $ = {}) {
        (0, r._validateObject)(X, {
            hash: "function"
        }, {
            hmac: "function",
            lowS: "boolean",
            randomBytes: "function",
            bits2int: "function",
            bits2int_modN: "function"
        });
        const S = X.randomBytes || r.randomBytes, w = X.hmac || ((de, ..._e)=>(0, t.hmac)(X.hash, de, (0, r.concatBytes)(..._e))), { Fp: g, Fn: m } = R, { ORDER: E, BITS: T } = m;
        function I(de) {
            const _e = E >> u;
            return de > _e;
        }
        function P(de) {
            return I(de) ? m.neg(de) : de;
        }
        function k(de, _e) {
            if (!m.isValidNot0(_e)) throw new Error(`invalid signature ${de}: out of range 1..CURVE.n`);
        }
        class L {
            constructor(_e, Ie, je){
                k("r", _e), k("s", Ie), this.r = _e, this.s = Ie, je != null && (this.recovery = je), Object.freeze(this);
            }
            // pair (bytes of r, bytes of s)
            static fromCompact(_e) {
                const Ie = m.BYTES, je = (0, r.ensureBytes)("compactSignature", _e, Ie * 2);
                return new L(m.fromBytes(je.subarray(0, Ie)), m.fromBytes(je.subarray(Ie, Ie * 2)));
            }
            // DER encoded ECDSA signature
            // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
            static fromDER(_e) {
                const { r: Ie, s: je } = e.DER.toSig((0, r.ensureBytes)("DER", _e));
                return new L(Ie, je);
            }
            /**
       * @todo remove
       * @deprecated
       */ assertValidity() {}
            addRecoveryBit(_e) {
                return new L(this.r, this.s, _e);
            }
            // ProjPointType<bigint>
            recoverPublicKey(_e) {
                const Ie = g.ORDER, { r: je, s: Ke, recovery: Ue } = this;
                if (Ue == null || ![
                    0,
                    1,
                    2,
                    3
                ].includes(Ue)) throw new Error("recovery id invalid");
                if (E * f < Ie && Ue > 1) throw new Error("recovery id is ambiguous for h>1 curve");
                const x = Ue === 2 || Ue === 3 ? je + E : je;
                if (!g.isValid(x)) throw new Error("recovery id 2 or 3 invalid");
                const q = g.toBytes(x), te = R.fromHex((0, r.concatBytes)(O((Ue & 1) === 0), q)), fe = m.inv(x), ne = ae((0, r.ensureBytes)("msgHash", _e)), W = m.create(-ne * fe), J = m.create(Ke * fe), V = R.BASE.multiplyUnsafe(W).add(te.multiplyUnsafe(J));
                if (V.is0()) throw new Error("point at infinify");
                return V.assertValidity(), V;
            }
            // Signatures should be low-s, to prevent malleability.
            hasHighS() {
                return I(this.s);
            }
            normalizeS() {
                return this.hasHighS() ? new L(this.r, m.neg(this.s), this.recovery) : this;
            }
            toBytes(_e) {
                if (_e === "compact") return (0, r.concatBytes)(m.toBytes(this.r), m.toBytes(this.s));
                if (_e === "der") return (0, r.hexToBytes)(e.DER.hexFromSig(this));
                throw new Error("invalid format");
            }
            // DER-encoded
            toDERRawBytes() {
                return this.toBytes("der");
            }
            toDERHex() {
                return (0, r.bytesToHex)(this.toBytes("der"));
            }
            // padded bytes of r, then padded bytes of s
            toCompactRawBytes() {
                return this.toBytes("compact");
            }
            toCompactHex() {
                return (0, r.bytesToHex)(this.toBytes("compact"));
            }
        }
        const j = y(m, $.allowedPrivateKeyLengths, $.wrapPrivateKey), ie = {
            isValidPrivateKey (de) {
                try {
                    return j(de), !0;
                } catch  {
                    return !1;
                }
            },
            normPrivateKeyToScalar: j,
            /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */ randomPrivateKey: ()=>{
                const de = E;
                return (0, i.mapHashToField)(S((0, i.getMinHashLength)(de)), de);
            },
            precompute (de = 8, _e = R.BASE) {
                return _e.precompute(de, !1);
            }
        };
        function ue(de, _e = !0) {
            return R.fromPrivateKey(de).toBytes(_e);
        }
        function ce(de) {
            if (typeof de == "bigint") return !1;
            if (de instanceof R) return !0;
            const Ie = (0, r.ensureBytes)("key", de).length, je = g.BYTES, Ke = je + 1, Ue = 2 * je + 1;
            if (!($.allowedPrivateKeyLengths || m.BYTES === Ke)) return Ie === Ke || Ie === Ue;
        }
        function he(de, _e, Ie = !0) {
            if (ce(de) === !0) throw new Error("first arg must be private key");
            if (ce(_e) === !1) throw new Error("second arg must be public key");
            return R.fromHex(_e).multiply(j(de)).toBytes(Ie);
        }
        const ee = X.bits2int || function(de) {
            if (de.length > 8192) throw new Error("input is too large");
            const _e = (0, r.bytesToNumberBE)(de), Ie = de.length * 8 - T;
            return Ie > 0 ? _e >> BigInt(Ie) : _e;
        }, ae = X.bits2int_modN || function(de) {
            return m.create(ee(de));
        }, ye = (0, r.bitMask)(T);
        function Se(de) {
            return (0, r.aInRange)("num < 2^" + T, de, a, ye), m.toBytes(de);
        }
        function De(de, _e, Ie = Re) {
            if ([
                "recovered",
                "canonical"
            ].some((J)=>J in Ie)) throw new Error("sign() legacy options not supported");
            const { hash: je } = X;
            let { lowS: Ke, prehash: Ue, extraEntropy: h } = Ie;
            Ke == null && (Ke = !0), de = (0, r.ensureBytes)("msgHash", de), o(Ie), Ue && (de = (0, r.ensureBytes)("prehashed msgHash", je(de)));
            const x = ae(de), q = j(_e), te = [
                Se(q),
                Se(x)
            ];
            if (h != null && h !== !1) {
                const J = h === !0 ? S(g.BYTES) : h;
                te.push((0, r.ensureBytes)("extraEntropy", J));
            }
            const fe = (0, r.concatBytes)(...te), ne = x;
            function W(J) {
                const V = ee(J);
                if (!m.isValidNot0(V)) return;
                const C = m.inv(V), Z = R.BASE.multiply(V).toAffine(), le = m.create(Z.x);
                if (le === a) return;
                const se = m.create(C * m.create(ne + le * q));
                if (se === a) return;
                let Ne = (Z.x === le ? 0 : 2) | Number(Z.y & u), Le = se;
                return Ke && I(se) && (Le = P(se), Ne ^= 1), new L(le, Le, Ne);
            }
            return {
                seed: fe,
                k2sig: W
            };
        }
        const Re = {
            lowS: X.lowS,
            prehash: !1
        }, Ce = {
            lowS: X.lowS,
            prehash: !1
        };
        function M(de, _e, Ie = Re) {
            const { seed: je, k2sig: Ke } = De(de, _e, Ie);
            return (0, r.createHmacDrbg)(X.hash.outputLen, m.BYTES, w)(je, Ke);
        }
        R.BASE.precompute(8);
        function z(de, _e, Ie, je = Ce) {
            const Ke = de;
            _e = (0, r.ensureBytes)("msgHash", _e), Ie = (0, r.ensureBytes)("publicKey", Ie), o(je);
            const { lowS: Ue, prehash: h, format: x } = je;
            if ("strict" in je) throw new Error("options.strict was renamed to lowS");
            if (x !== void 0 && ![
                "compact",
                "der",
                "js"
            ].includes(x)) throw new Error('format must be "compact", "der" or "js"');
            const q = typeof Ke == "string" || (0, r.isBytes)(Ke), te = !q && !x && typeof Ke == "object" && Ke !== null && typeof Ke.r == "bigint" && typeof Ke.s == "bigint";
            if (!q && !te) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
            let fe, ne;
            try {
                if (te) if (x === void 0 || x === "js") fe = new L(Ke.r, Ke.s);
                else throw new Error("invalid format");
                if (q) {
                    try {
                        x !== "compact" && (fe = L.fromDER(Ke));
                    } catch (Le) {
                        if (!(Le instanceof e.DER.Err)) throw Le;
                    }
                    !fe && x !== "der" && (fe = L.fromCompact(Ke));
                }
                ne = R.fromHex(Ie);
            } catch  {
                return !1;
            }
            if (!fe || Ue && fe.hasHighS()) return !1;
            h && (_e = X.hash(_e));
            const { r: W, s: J } = fe, V = ae(_e), C = m.inv(J), Z = m.create(V * C), le = m.create(W * C), se = R.BASE.multiplyUnsafe(Z).add(ne.multiplyUnsafe(le));
            return se.is0() ? !1 : m.create(se.x) === W;
        }
        return Object.freeze({
            getPublicKey: ue,
            getSharedSecret: he,
            sign: M,
            verify: z,
            utils: ie,
            Point: R,
            Signature: L
        });
    }
    function U(R) {
        const X = {
            a: R.a,
            b: R.b,
            p: R.Fp.ORDER,
            n: R.n,
            h: R.h,
            Gx: R.Gx,
            Gy: R.Gy
        }, $ = R.Fp, S = (0, i.Field)(X.n, R.nBitLength), w = {
            Fp: $,
            Fn: S,
            allowedPrivateKeyLengths: R.allowedPrivateKeyLengths,
            allowInfinityPoint: R.allowInfinityPoint,
            endo: R.endo,
            wrapPrivateKey: R.wrapPrivateKey,
            isTorsionFree: R.isTorsionFree,
            clearCofactor: R.clearCofactor,
            fromBytes: R.fromBytes,
            toBytes: R.toBytes
        };
        return {
            CURVE: X,
            curveOpts: w
        };
    }
    function D(R) {
        const { CURVE: X, curveOpts: $ } = U(R), S = {
            hash: R.hash,
            hmac: R.hmac,
            randomBytes: R.randomBytes,
            lowS: R.lowS,
            bits2int: R.bits2int,
            bits2int_modN: R.bits2int_modN
        };
        return {
            CURVE: X,
            curveOpts: $,
            ecdsaOpts: S
        };
    }
    function H(R, X) {
        const { Fp: $, Fn: S } = X;
        function w(E) {
            return (0, r.inRange)(E, u, S.ORDER);
        }
        const g = p($, R.a, R.b), m = y(S, R.allowedPrivateKeyLengths, R.wrapPrivateKey);
        return Object.assign({}, {
            CURVE: R,
            Point: X,
            ProjectivePoint: X,
            normPrivateKeyToScalar: m,
            weierstrassEquation: g,
            isWithinCurveOrder: w
        });
    }
    function K(R, X) {
        return Object.assign({}, X, {
            ProjectivePoint: X.Point,
            CURVE: R
        });
    }
    function re(R) {
        const { CURVE: X, curveOpts: $, ecdsaOpts: S } = D(R), w = _(X, $), g = N(w, S, $);
        return K(R, g);
    }
    function Q(R, X) {
        const $ = R.ORDER;
        let S = a;
        for(let ie = $ - u; ie % f === a; ie /= f)S += u;
        const w = S, g = f << w - u - u, m = g * f, E = ($ - u) / m, T = (E - u) / f, I = m - u, P = g, k = R.pow(X, E), L = R.pow(X, (E + u) / f);
        let j = (ie, ue)=>{
            let ce = k, he = R.pow(ue, I), ee = R.sqr(he);
            ee = R.mul(ee, ue);
            let ae = R.mul(ie, ee);
            ae = R.pow(ae, T), ae = R.mul(ae, he), he = R.mul(ae, ue), ee = R.mul(ae, ie);
            let ye = R.mul(ee, he);
            ae = R.pow(ye, P);
            let Se = R.eql(ae, R.ONE);
            he = R.mul(ee, L), ae = R.mul(ye, ce), ee = R.cmov(he, ee, Se), ye = R.cmov(ae, ye, Se);
            for(let De = w; De > u; De--){
                let Re = De - f;
                Re = f << Re - u;
                let Ce = R.pow(ye, Re);
                const M = R.eql(Ce, R.ONE);
                he = R.mul(ee, ce), ce = R.mul(ce, ce), Ce = R.mul(ye, ce), ee = R.cmov(he, ee, M), ye = R.cmov(Ce, ye, M);
            }
            return {
                isValid: Se,
                value: ee
            };
        };
        if (R.ORDER % l === c) {
            const ie = (R.ORDER - c) / l, ue = R.sqrt(R.neg(X));
            j = (ce, he)=>{
                let ee = R.sqr(he);
                const ae = R.mul(ce, he);
                ee = R.mul(ee, ae);
                let ye = R.pow(ee, ie);
                ye = R.mul(ye, ae);
                const Se = R.mul(ye, ue), De = R.mul(R.sqr(ye), he), Re = R.eql(De, ce);
                let Ce = R.cmov(Se, ye, Re);
                return {
                    isValid: Re,
                    value: Ce
                };
            };
        }
        return j;
    }
    function G(R, X) {
        (0, i.validateField)(R);
        const { A: $, B: S, Z: w } = X;
        if (!R.isValid($) || !R.isValid(S) || !R.isValid(w)) throw new Error("mapToCurveSimpleSWU: invalid opts");
        const g = Q(R, w);
        if (!R.isOdd) throw new Error("Field does not have .isOdd()");
        return (m)=>{
            let E, T, I, P, k, L, j, ie;
            E = R.sqr(m), E = R.mul(E, w), T = R.sqr(E), T = R.add(T, E), I = R.add(T, R.ONE), I = R.mul(I, S), P = R.cmov(w, R.neg(T), !R.eql(T, R.ZERO)), P = R.mul(P, $), T = R.sqr(I), L = R.sqr(P), k = R.mul(L, $), T = R.add(T, k), T = R.mul(T, I), L = R.mul(L, P), k = R.mul(L, S), T = R.add(T, k), j = R.mul(E, I);
            const { isValid: ue, value: ce } = g(T, L);
            ie = R.mul(E, m), ie = R.mul(ie, ce), j = R.cmov(j, I, ue), ie = R.cmov(ie, ce, ue);
            const he = R.isOdd(m) === R.isOdd(ie);
            ie = R.cmov(R.neg(ie), ie, he);
            const ee = (0, i.FpInvertBatch)(R, [
                P
            ], !0)[0];
            return j = R.mul(j, ee), {
                x: j,
                y: ie
            };
        };
    }
})(m3);
Object.defineProperty(yb, "__esModule", {
    value: !0
});
yb.getHash = XG;
yb.createCurve = JG;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const YG = m3;
function XG(e) {
    return {
        hash: e
    };
}
function JG(e, t) {
    const r = (n)=>(0, YG.weierstrass)({
            ...e,
            hash: n
        });
    return {
        ...r(t),
        create: r
    };
}
var Rf = {};
Object.defineProperty(Rf, "__esModule", {
    value: !0
});
Rf.expand_message_xmd = j9;
Rf.expand_message_xof = H9;
Rf.hash_to_field = UE;
Rf.isogenyMap = tZ;
Rf.createHasher = rZ;
const ii = Mf, z9 = sn, QG = ii.bytesToNumberBE;
function nu(e, t) {
    if (sp(e), sp(t), e < 0 || e >= 1 << 8 * t) throw new Error("invalid I2OSP input: " + e);
    const r = Array.from({
        length: t
    }).fill(0);
    for(let n = t - 1; n >= 0; n--)r[n] = e & 255, e >>>= 8;
    return new Uint8Array(r);
}
function eZ(e, t) {
    const r = new Uint8Array(e.length);
    for(let n = 0; n < e.length; n++)r[n] = e[n] ^ t[n];
    return r;
}
function sp(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function j9(e, t, r, n) {
    (0, ii.abytes)(e), (0, ii.abytes)(t), sp(r), t.length > 255 && (t = n((0, ii.concatBytes)((0, ii.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i, blockLen: o } = n, s = Math.ceil(r / i);
    if (r > 65535 || s > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const a = (0, ii.concatBytes)(t, nu(t.length, 1)), u = nu(0, o), f = nu(r, 2), c = new Array(s), l = n((0, ii.concatBytes)(u, e, f, nu(0, 1), a));
    c[0] = n((0, ii.concatBytes)(l, nu(1, 1), a));
    for(let y = 1; y <= s; y++){
        const _ = [
            eZ(l, c[y - 1]),
            nu(y + 1, 1),
            a
        ];
        c[y] = n((0, ii.concatBytes)(..._));
    }
    return (0, ii.concatBytes)(...c).slice(0, r);
}
function H9(e, t, r, n, i) {
    if ((0, ii.abytes)(e), (0, ii.abytes)(t), sp(r), t.length > 255) {
        const o = Math.ceil(2 * n / 8);
        t = i.create({
            dkLen: o
        }).update((0, ii.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (r > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i.create({
        dkLen: r
    }).update(e).update(nu(r, 2)).update(t).update(nu(t.length, 1)).digest();
}
function UE(e, t, r) {
    (0, ii._validateObject)(r, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
    });
    const { p: n, k: i, m: o, hash: s, expand: a, DST: u } = r;
    if (!(0, ii.isBytes)(u) && typeof u != "string") throw new Error("DST must be string or uint8array");
    if (!(0, ii.isHash)(r.hash)) throw new Error("expected valid hash");
    (0, ii.abytes)(e), sp(t);
    const f = typeof u == "string" ? (0, ii.utf8ToBytes)(u) : u, c = n.toString(2).length, l = Math.ceil((c + i) / 8), p = t * o * l;
    let y;
    if (a === "xmd") y = j9(e, f, p, s);
    else if (a === "xof") y = H9(e, f, p, i, s);
    else if (a === "_internal_pass") y = e;
    else throw new Error('expand must be "xmd" or "xof"');
    const _ = new Array(t);
    for(let A = 0; A < t; A++){
        const O = new Array(o);
        for(let N = 0; N < o; N++){
            const U = l * (N + A * o), D = y.subarray(U, U + l);
            O[N] = (0, z9.mod)(QG(D), n);
        }
        _[A] = O;
    }
    return _;
}
function tZ(e, t) {
    const r = t.map((n)=>Array.from(n).reverse());
    return (n, i)=>{
        const [o, s, a, u] = r.map((l)=>l.reduce((p, y)=>e.add(e.mul(p, n), y))), [f, c] = (0, z9.FpInvertBatch)(e, [
            s,
            u
        ], !0);
        return n = e.mul(o, f), i = e.mul(i, e.mul(a, c)), {
            x: n,
            y: i
        };
    };
}
function rZ(e, t, r) {
    if (typeof t != "function") throw new Error("mapToCurve() must be defined");
    function n(o) {
        return e.fromAffine(t(o));
    }
    function i(o) {
        const s = o.clearCofactor();
        return s.equals(e.ZERO) ? e.ZERO : (s.assertValidity(), s);
    }
    return {
        defaults: r,
        hashToCurve (o, s) {
            const a = r.DST ? r.DST : {}, u = Object.assign({}, r, a, s), f = UE(o, 2, u), c = n(f[0]), l = n(f[1]);
            return i(c.add(l));
        },
        encodeToCurve (o, s) {
            const a = r.encodeDST ? r.encodeDST : {}, u = Object.assign({}, r, a, s), f = UE(o, 1, u);
            return i(n(f[0]));
        },
        /** See {@link H2CHasher} */ mapToCurve (o) {
            if (!Array.isArray(o)) throw new Error("expected array of bigints");
            for (const s of o)if (typeof s != "bigint") throw new Error("expected array of bigints");
            return i(n(o));
        }
    };
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.encodeToCurve = e.hashToCurve = e.secp256k1_hasher = e.schnorr = e.secp256k1 = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = en, r = Hr, n = yb, i = Rf, o = sn, s = m3, a = Mf, u = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    }, f = BigInt(0), c = BigInt(1), l = BigInt(2), p = (E, T)=>(E + T / l) / T;
    function y(E) {
        const T = u.p, I = BigInt(3), P = BigInt(6), k = BigInt(11), L = BigInt(22), j = BigInt(23), ie = BigInt(44), ue = BigInt(88), ce = E * E * E % T, he = ce * ce * E % T, ee = (0, o.pow2)(he, I, T) * he % T, ae = (0, o.pow2)(ee, I, T) * he % T, ye = (0, o.pow2)(ae, l, T) * ce % T, Se = (0, o.pow2)(ye, k, T) * ye % T, De = (0, o.pow2)(Se, L, T) * Se % T, Re = (0, o.pow2)(De, ie, T) * De % T, Ce = (0, o.pow2)(Re, ue, T) * Re % T, M = (0, o.pow2)(Ce, ie, T) * De % T, z = (0, o.pow2)(M, I, T) * he % T, de = (0, o.pow2)(z, j, T) * Se % T, _e = (0, o.pow2)(de, P, T) * ce % T, Ie = (0, o.pow2)(_e, l, T);
        if (!_.eql(_.sqr(Ie), E)) throw new Error("Cannot find square root");
        return Ie;
    }
    const _ = (0, o.Field)(u.p, void 0, void 0, {
        sqrt: y
    });
    e.secp256k1 = (0, n.createCurve)({
        ...u,
        Fp: _,
        lowS: !0,
        // Allow only low-S signatures by default in sign() and verify()
        endo: {
            // Endomorphism, see above
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: (E)=>{
                const T = u.n, I = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), P = -c * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), k = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), L = I, j = BigInt("0x100000000000000000000000000000000"), ie = p(L * E, T), ue = p(-P * E, T);
                let ce = (0, o.mod)(E - ie * I - ue * k, T), he = (0, o.mod)(-ie * P - ue * L, T);
                const ee = ce > j, ae = he > j;
                if (ee && (ce = T - ce), ae && (he = T - he), ce > j || he > j) throw new Error("splitScalar: Endomorphism failed, k=" + E);
                return {
                    k1neg: ee,
                    k1: ce,
                    k2neg: ae,
                    k2: he
                };
            }
        }
    }, t.sha256);
    const A = {};
    function O(E, ...T) {
        let I = A[E];
        if (I === void 0) {
            const P = (0, t.sha256)(Uint8Array.from(E, (k)=>k.charCodeAt(0)));
            I = (0, a.concatBytes)(P, P), A[E] = I;
        }
        return (0, t.sha256)((0, a.concatBytes)(I, ...T));
    }
    const N = (E)=>E.toBytes(!0).slice(1), U = (E)=>(0, a.numberToBytesBE)(E, 32), D = (E)=>(0, o.mod)(E, u.p), H = (E)=>(0, o.mod)(E, u.n), K = e.secp256k1.Point, re = (E)=>E % l === f;
    function Q(E) {
        let T = e.secp256k1.utils.normPrivateKeyToScalar(E), I = K.fromPrivateKey(T);
        return {
            scalar: re(I.y) ? T : H(-T),
            bytes: N(I)
        };
    }
    function G(E) {
        (0, a.aInRange)("x", E, c, u.p);
        const T = D(E * E), I = D(T * E + BigInt(7));
        let P = y(I);
        re(P) || (P = D(-P));
        const k = K.fromAffine({
            x: E,
            y: P
        });
        return k.assertValidity(), k;
    }
    const R = a.bytesToNumberBE;
    function X(...E) {
        return H(R(O("BIP0340/challenge", ...E)));
    }
    function $(E) {
        return Q(E).bytes;
    }
    function S(E, T, I = (0, r.randomBytes)(32)) {
        const P = (0, a.ensureBytes)("message", E), { bytes: k, scalar: L } = Q(T), j = (0, a.ensureBytes)("auxRand", I, 32), ie = U(L ^ R(O("BIP0340/aux", j))), ue = O("BIP0340/nonce", ie, k, P), ce = H(R(ue));
        if (ce === f) throw new Error("sign failed: k is zero");
        const { bytes: he, scalar: ee } = Q(ce), ae = X(he, k, P), ye = new Uint8Array(64);
        if (ye.set(he, 0), ye.set(U(H(ee + ae * L)), 32), !w(ye, P, k)) throw new Error("sign: Invalid signature produced");
        return ye;
    }
    function w(E, T, I) {
        const P = (0, a.ensureBytes)("signature", E, 64), k = (0, a.ensureBytes)("message", T), L = (0, a.ensureBytes)("publicKey", I, 32);
        try {
            const j = G(R(L)), ie = R(P.subarray(0, 32));
            if (!(0, a.inRange)(ie, c, u.p)) return !1;
            const ue = R(P.subarray(32, 64));
            if (!(0, a.inRange)(ue, c, u.n)) return !1;
            const ce = X(U(ie), N(j), k), he = K.BASE.multiplyUnsafe(ue).add(j.multiplyUnsafe(H(-ce))), { x: ee, y: ae } = he.toAffine();
            return !(he.is0() || !re(ae) || ee !== ie);
        } catch  {
            return !1;
        }
    }
    e.schnorr = {
        getPublicKey: $,
        sign: S,
        verify: w,
        utils: {
            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
            lift_x: G,
            pointToBytes: N,
            numberToBytesBE: a.numberToBytesBE,
            bytesToNumberBE: a.bytesToNumberBE,
            taggedHash: O,
            mod: o.mod
        }
    };
    const g = (0, i.isogenyMap)(_, [
        // xNum
        [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        // yNum
        [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
    ].map((E)=>E.map((T)=>BigInt(T)))), m = (0, s.mapToCurveSimpleSWU)(_, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: _.create(BigInt("-11"))
    });
    e.secp256k1_hasher = (0, i.createHasher)(e.secp256k1.Point, (E)=>{
        const { x: T, y: I } = m(_.create(E[0]));
        return g(T, I);
    }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: _.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: t.sha256
    }), e.hashToCurve = e.secp256k1_hasher.hashToCurve, e.encodeToCurve = e.secp256k1_hasher.encodeToCurve;
})(p3);
var q9 = {};
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Mf, e);
})(q9);
var mi = p3, nZ = sn, iZ = q9;
function K9(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
        if (r !== "default") {
            var n = Object.getOwnPropertyDescriptor(e, r);
            Object.defineProperty(t, r, n.get ? n : {
                enumerable: !0,
                get: function() {
                    return e[r];
                }
            });
        }
    }), t.default = e, Object.freeze(t);
}
var W9 = /* @__PURE__ */ K9(nZ), gu = /* @__PURE__ */ K9(iZ);
const x3 = mi.secp256k1.ProjectivePoint, Au = "Expected Private", Tu = "Expected Point", e0 = "Expected Tweak", oZ = "Expected Hash", Lh = "Expected Signature", S3 = "Expected Extra Data (32 bytes)", t0 = "Expected Scalar", sZ = "Bad Recovery Id", aZ = 32, cZ = 32, $E = new Uint8Array([
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    254,
    186,
    174,
    220,
    230,
    175,
    72,
    160,
    59,
    191,
    210,
    94,
    140,
    208,
    54,
    65,
    65
]), uZ = 32, fZ = new Uint8Array(32), lZ = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    69,
    81,
    35,
    25,
    80,
    183,
    95,
    196,
    64,
    45,
    161,
    114,
    47,
    201,
    186,
    238
]), dZ = BigInt(1);
function hZ(e) {
    return e instanceof Uint8Array;
}
function ap(e, t) {
    for(let r = 0; r < 32; ++r)if (e[r] !== t[r]) return e[r] < t[r] ? -1 : 1;
    return 0;
}
function mA(e) {
    return ap(e, fZ) === 0;
}
function r0(e) {
    return !(!(e instanceof Uint8Array) || e.length !== cZ || ap(e, $E) >= 0);
}
function A3(e) {
    return e instanceof Uint8Array && e.length === 64 && ap(e.subarray(0, 32), $E) < 0 && ap(e.subarray(32, 64), $E) < 0;
}
function pZ(e) {
    return hZ(e) && e.length === 64 && ap(e.subarray(0, 32), lZ) < 0;
}
function gZ(e) {
    return !(mA(e.subarray(0, 32)) || mA(e.subarray(32, 64)));
}
function Sd(e) {
    return e instanceof Uint8Array && e.length === aZ;
}
function T3(e) {
    return e === void 0 || e instanceof Uint8Array && e.length === uZ;
}
function k3(e) {
    let t;
    if (typeof e == "bigint") t = e;
    else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0) t = BigInt(e);
    else if (typeof e == "string") {
        if (e.length !== 64) throw new Error("Expected 32 bytes of private scalar");
        t = gu.hexToNumber(e);
    } else if (e instanceof Uint8Array) {
        if (e.length !== 32) throw new Error("Expected 32 bytes of private scalar");
        t = gu.bytesToNumberBE(e);
    } else throw new TypeError("Expected valid private scalar");
    if (t < 0) throw new Error("Expected private scalar >= 0");
    return t;
}
function I3(e) {
    return mi.secp256k1.utils.normPrivateKeyToScalar(e);
}
function yZ(e, t) {
    const r = I3(e), n = k3(t), i = gu.numberToBytesBE(W9.mod(r + n, mi.secp256k1.CURVE.n), 32);
    return mi.secp256k1.utils.isValidPrivateKey(i) ? i : null;
}
function mZ(e, t) {
    const r = I3(e), n = k3(t), i = gu.numberToBytesBE(W9.mod(r - n, mi.secp256k1.CURVE.n), 32);
    return mi.secp256k1.utils.isValidPrivateKey(i) ? i : null;
}
function bZ(e) {
    const t = I3(e), r = gu.numberToBytesBE(mi.secp256k1.CURVE.n - t, 32);
    return mi.secp256k1.utils.isValidPrivateKey(r) ? r : null;
}
function V9(e, t, r) {
    const n = cp(e), i = k3(t), o = x3.BASE.multiplyAndAddUnsafe(n, i, dZ);
    if (!o) throw new Error("Tweaked point at infinity");
    return o.toRawBytes(r);
}
function wZ(e, t, r) {
    const n = cp(e), i = typeof t == "string" ? t : gu.bytesToHex(t), o = gu.hexToNumber(i);
    return n.multiply(o).toRawBytes(r);
}
function Ad(e, t) {
    return e === void 0 ? t !== void 0 ? Z9(t) : !0 : !!e;
}
function Cf(e) {
    try {
        return e();
    } catch  {
        return null;
    }
}
function G9(e) {
    return mi.schnorr.utils.lift_x(gu.bytesToNumberBE(e));
}
function cp(e) {
    return e.length === 32 ? G9(e) : x3.fromHex(e);
}
function B3(e, t) {
    if (e.length === 32 !== t) return !1;
    try {
        return t ? !!G9(e) : !!x3.fromHex(e);
    } catch  {
        return !1;
    }
}
function yu(e) {
    return B3(e, !1);
}
function Z9(e) {
    return B3(e, !1) && e.length === 33;
}
function gc(e) {
    return mi.secp256k1.utils.isValidPrivateKey(e);
}
function mb(e) {
    return B3(e, !0);
}
function vZ(e, t) {
    if (!mb(e)) throw new Error(Tu);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>{
        const r = V9(e, t, !0);
        return {
            parity: r[0] % 2 === 1 ? 1 : 0,
            xOnlyPubkey: r.slice(1)
        };
    });
}
function Y9(e) {
    if (!yu(e)) throw new Error(Tu);
    return e.slice(1, 33);
}
function X9(e, t) {
    if (!gc(e)) throw new Error(Au);
    return Cf(()=>mi.secp256k1.getPublicKey(e, Ad(t)));
}
function _Z(e) {
    if (!gc(e)) throw new Error(Au);
    return Y9(X9(e));
}
function EZ(e, t) {
    if (!yu(e)) throw new Error(Tu);
    return cp(e).toRawBytes(Ad(t, e));
}
function xZ(e, t, r) {
    if (!yu(e)) throw new Error(Tu);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>wZ(e, t, Ad(r, e)));
}
function SZ(e, t, r) {
    if (!yu(e) || !yu(t)) throw new Error(Tu);
    return Cf(()=>{
        const n = cp(e), i = cp(t);
        return n.equals(i.negate()) ? null : n.add(i).toRawBytes(Ad(r, e));
    });
}
function AZ(e, t, r) {
    if (!yu(e)) throw new Error(Tu);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>V9(e, t, Ad(r, e)));
}
function TZ(e, t) {
    if (!gc(e)) throw new Error(Au);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>yZ(e, t));
}
function kZ(e, t) {
    if (!gc(e)) throw new Error(Au);
    if (!r0(t)) throw new Error(e0);
    return Cf(()=>mZ(e, t));
}
function IZ(e) {
    if (!gc(e)) throw new Error(Au);
    return bZ(e);
}
function BZ(e, t, r) {
    if (!gc(t)) throw new Error(Au);
    if (!Sd(e)) throw new Error(t0);
    if (!T3(r)) throw new Error(S3);
    return mi.secp256k1.sign(e, t, {
        extraEntropy: r
    }).toCompactRawBytes();
}
function OZ(e, t, r) {
    if (!gc(t)) throw new Error(Au);
    if (!Sd(e)) throw new Error(t0);
    if (!T3(r)) throw new Error(S3);
    const n = mi.secp256k1.sign(e, t, {
        extraEntropy: r
    });
    return {
        signature: n.toCompactRawBytes(),
        recoveryId: n.recovery
    };
}
function PZ(e, t, r) {
    if (!gc(t)) throw new Error(Au);
    if (!Sd(e)) throw new Error(t0);
    if (!T3(r)) throw new Error(S3);
    return mi.schnorr.sign(e, t, r);
}
function NZ(e, t, r, n) {
    if (!Sd(e)) throw new Error(oZ);
    if (!A3(t) || !gZ(t)) throw new Error(Lh);
    if (r & 2 && !pZ(t)) throw new Error(sZ);
    if (!mb(t.subarray(0, 32))) throw new Error(Lh);
    const o = mi.secp256k1.Signature.fromCompact(t).addRecoveryBit(r).recoverPublicKey(e);
    if (!o) throw new Error(Lh);
    return o.toRawBytes(Ad(n));
}
function MZ(e, t, r, n) {
    if (!yu(t)) throw new Error(Tu);
    if (!A3(r)) throw new Error(Lh);
    if (!Sd(e)) throw new Error(t0);
    return mi.secp256k1.verify(r, e, t, {
        lowS: n
    });
}
function RZ(e, t, r) {
    if (!mb(t)) throw new Error(Tu);
    if (!A3(r)) throw new Error(Lh);
    if (!Sd(e)) throw new Error(t0);
    return mi.schnorr.verify(r, e, t);
}
var CZ = In.isPoint = yu, UZ = In.isPointCompressed = Z9, $Z = In.isPrivate = gc, LZ = In.isXOnlyPoint = mb, DZ = In.pointAdd = SZ, FZ = In.pointAddScalar = AZ, zZ = In.pointCompress = EZ, jZ = In.pointFromScalar = X9, HZ = In.pointMultiply = xZ, qZ = In.privateAdd = TZ, KZ = In.privateNegate = IZ, WZ = In.privateSub = kZ, VZ = In.recover = NZ, GZ = In.sign = BZ, ZZ = In.signRecoverable = OZ, YZ = In.signSchnorr = PZ, XZ = In.verify = MZ, JZ = In.verifySchnorr = RZ, QZ = In.xOnlyPointAddTweak = vZ, eY = In.xOnlyPointFromPoint = Y9, tY = In.xOnlyPointFromScalar = _Z;
const bb = /* @__PURE__ */ UH({
    __proto__: null,
    default: In,
    isPoint: CZ,
    isPointCompressed: UZ,
    isPrivate: $Z,
    isXOnlyPoint: LZ,
    pointAdd: DZ,
    pointAddScalar: FZ,
    pointCompress: zZ,
    pointFromScalar: jZ,
    pointMultiply: HZ,
    privateAdd: qZ,
    privateNegate: KZ,
    privateSub: WZ,
    recover: VZ,
    sign: GZ,
    signRecoverable: ZZ,
    signSchnorr: YZ,
    verify: XZ,
    verifySchnorr: JZ,
    xOnlyPointAddTweak: QZ,
    xOnlyPointFromPoint: eY,
    xOnlyPointFromScalar: tY
}, [
    In
]);
var Lo = {}, td = {}, ji = {}, Td = {};
Td.byteLength = iY;
Td.toByteArray = sY;
Td.fromByteArray = uY;
var pa = [], os = [], rY = typeof Uint8Array < "u" ? Uint8Array : Array, ov = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var dl = 0, nY = ov.length; dl < nY; ++dl)pa[dl] = ov[dl], os[ov.charCodeAt(dl)] = dl;
os[45] = 62;
os[95] = 63;
function J9(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [
        r,
        n
    ];
}
function iY(e) {
    var t = J9(e), r = t[0], n = t[1];
    return (r + n) * 3 / 4 - n;
}
function oY(e, t, r) {
    return (t + r) * 3 / 4 - r;
}
function sY(e) {
    var t, r = J9(e), n = r[0], i = r[1], o = new rY(oY(e, n, i)), s = 0, a = i > 0 ? n - 4 : n, u;
    for(u = 0; u < a; u += 4)t = os[e.charCodeAt(u)] << 18 | os[e.charCodeAt(u + 1)] << 12 | os[e.charCodeAt(u + 2)] << 6 | os[e.charCodeAt(u + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
    return i === 2 && (t = os[e.charCodeAt(u)] << 2 | os[e.charCodeAt(u + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = os[e.charCodeAt(u)] << 10 | os[e.charCodeAt(u + 1)] << 4 | os[e.charCodeAt(u + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function aY(e) {
    return pa[e >> 18 & 63] + pa[e >> 12 & 63] + pa[e >> 6 & 63] + pa[e & 63];
}
function cY(e, t, r) {
    for(var n, i = [], o = t; o < r; o += 3)n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(aY(n));
    return i.join("");
}
function uY(e) {
    for(var t, r = e.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)i.push(cY(e, s, s + o > a ? a : s + o));
    return n === 1 ? (t = e[r - 1], i.push(pa[t >> 2] + pa[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(pa[t >> 10] + pa[t >> 4 & 63] + pa[t << 2 & 63] + "=")), i.join("");
}
Object.defineProperty(ji, "__esModule", {
    value: !0
});
ji.decode = ji.encode = ji.unescape = ji.escape = ji.pad = void 0;
const Q9 = Td;
function O3(e) {
    return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
ji.pad = O3;
function eO(e) {
    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
ji.escape = eO;
function tO(e) {
    return O3(e).replace(/-/g, "+").replace(/_/g, "/");
}
ji.unescape = tO;
function fY(e) {
    return eO((0, Q9.fromByteArray)(new TextEncoder().encode(e)));
}
ji.encode = fY;
function lY(e) {
    return new TextDecoder().decode((0, Q9.toByteArray)(O3(tO(e))));
}
ji.decode = lY;
var wb = {}, vb = {}, us = {};
Object.defineProperty(us, "__esModule", {
    value: !0
});
us.sha224 = us.SHA224 = us.sha256 = us.SHA256 = void 0;
const _b = en;
us.SHA256 = _b.SHA256;
us.sha256 = _b.sha256;
us.SHA224 = _b.SHA224;
us.sha224 = _b.sha224;
var rO = {}, gr = {}, Mg = {
    exports: {}
}, Rg = {
    exports: {}
}, ku = {}, P3 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ P3.read = function(e, t, r, n, i) {
    var o, s, a = i * 8 - n - 1, u = (1 << a) - 1, f = u >> 1, c = -7, l = r ? i - 1 : 0, p = r ? -1 : 1, y = e[t + l];
    for(l += p, o = y & (1 << -c) - 1, y >>= -c, c += a; c > 0; o = o * 256 + e[t + l], l += p, c -= 8);
    for(s = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; s = s * 256 + e[t + l], l += p, c -= 8);
    if (o === 0) o = 1 - f;
    else {
        if (o === u) return s ? NaN : (y ? -1 : 1) * (1 / 0);
        s = s + Math.pow(2, n), o = o - f;
    }
    return (y ? -1 : 1) * s * Math.pow(2, o - n);
};
P3.write = function(e, t, r, n, i, o) {
    var s, a, u, f = o * 8 - i - 1, c = (1 << f) - 1, l = c >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, _ = n ? 1 : -1, A = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + l >= 1 ? t += p / u : t += p * Math.pow(2, 1 - l), t * u >= 2 && (s++, u /= 2), s + l >= c ? (a = 0, s = c) : s + l >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s = s + l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + y] = a & 255, y += _, a /= 256, i -= 8);
    for(s = s << i | a, f += i; f > 0; e[r + y] = s & 255, y += _, s /= 256, f -= 8);
    e[r + y - _] |= A * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(e) {
    const t = Td, r = P3, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = a, e.SlowBuffer = U, e.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    e.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function o() {
        try {
            const ne = new Uint8Array(1), W = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(W, Uint8Array.prototype), Object.setPrototypeOf(ne, W), ne.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.byteOffset;
        }
    });
    function s(ne) {
        if (ne > i) throw new RangeError('The value "' + ne + '" is invalid for option "size"');
        const W = new Uint8Array(ne);
        return Object.setPrototypeOf(W, a.prototype), W;
    }
    function a(ne, W, J) {
        if (typeof ne == "number") {
            if (typeof W == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return l(ne);
        }
        return u(ne, W, J);
    }
    a.poolSize = 8192;
    function u(ne, W, J) {
        if (typeof ne == "string") return p(ne, W);
        if (ArrayBuffer.isView(ne)) return _(ne);
        if (ne == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne);
        if (h(ne, ArrayBuffer) || ne && h(ne.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (h(ne, SharedArrayBuffer) || ne && h(ne.buffer, SharedArrayBuffer))) return A(ne, W, J);
        if (typeof ne == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const V = ne.valueOf && ne.valueOf();
        if (V != null && V !== ne) return a.from(V, W, J);
        const C = O(ne);
        if (C) return C;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ne[Symbol.toPrimitive] == "function") return a.from(ne[Symbol.toPrimitive]("string"), W, J);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne);
    }
    a.from = function(ne, W, J) {
        return u(ne, W, J);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function f(ne) {
        if (typeof ne != "number") throw new TypeError('"size" argument must be of type number');
        if (ne < 0) throw new RangeError('The value "' + ne + '" is invalid for option "size"');
    }
    function c(ne, W, J) {
        return f(ne), ne <= 0 ? s(ne) : W !== void 0 ? typeof J == "string" ? s(ne).fill(W, J) : s(ne).fill(W) : s(ne);
    }
    a.alloc = function(ne, W, J) {
        return c(ne, W, J);
    };
    function l(ne) {
        return f(ne), s(ne < 0 ? 0 : N(ne) | 0);
    }
    a.allocUnsafe = function(ne) {
        return l(ne);
    }, a.allocUnsafeSlow = function(ne) {
        return l(ne);
    };
    function p(ne, W) {
        if ((typeof W != "string" || W === "") && (W = "utf8"), !a.isEncoding(W)) throw new TypeError("Unknown encoding: " + W);
        const J = D(ne, W) | 0;
        let V = s(J);
        const C = V.write(ne, W);
        return C !== J && (V = V.slice(0, C)), V;
    }
    function y(ne) {
        const W = ne.length < 0 ? 0 : N(ne.length) | 0, J = s(W);
        for(let V = 0; V < W; V += 1)J[V] = ne[V] & 255;
        return J;
    }
    function _(ne) {
        if (h(ne, Uint8Array)) {
            const W = new Uint8Array(ne);
            return A(W.buffer, W.byteOffset, W.byteLength);
        }
        return y(ne);
    }
    function A(ne, W, J) {
        if (W < 0 || ne.byteLength < W) throw new RangeError('"offset" is outside of buffer bounds');
        if (ne.byteLength < W + (J || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let V;
        return W === void 0 && J === void 0 ? V = new Uint8Array(ne) : J === void 0 ? V = new Uint8Array(ne, W) : V = new Uint8Array(ne, W, J), Object.setPrototypeOf(V, a.prototype), V;
    }
    function O(ne) {
        if (a.isBuffer(ne)) {
            const W = N(ne.length) | 0, J = s(W);
            return J.length === 0 || ne.copy(J, 0, 0, W), J;
        }
        if (ne.length !== void 0) return typeof ne.length != "number" || x(ne.length) ? s(0) : y(ne);
        if (ne.type === "Buffer" && Array.isArray(ne.data)) return y(ne.data);
    }
    function N(ne) {
        if (ne >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return ne | 0;
    }
    function U(ne) {
        return +ne != ne && (ne = 0), a.alloc(+ne);
    }
    a.isBuffer = function(W) {
        return W != null && W._isBuffer === !0 && W !== a.prototype;
    }, a.compare = function(W, J) {
        if (h(W, Uint8Array) && (W = a.from(W, W.offset, W.byteLength)), h(J, Uint8Array) && (J = a.from(J, J.offset, J.byteLength)), !a.isBuffer(W) || !a.isBuffer(J)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (W === J) return 0;
        let V = W.length, C = J.length;
        for(let Z = 0, le = Math.min(V, C); Z < le; ++Z)if (W[Z] !== J[Z]) {
            V = W[Z], C = J[Z];
            break;
        }
        return V < C ? -1 : C < V ? 1 : 0;
    }, a.isEncoding = function(W) {
        switch(String(W).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, a.concat = function(W, J) {
        if (!Array.isArray(W)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (W.length === 0) return a.alloc(0);
        let V;
        if (J === void 0) for(J = 0, V = 0; V < W.length; ++V)J += W[V].length;
        const C = a.allocUnsafe(J);
        let Z = 0;
        for(V = 0; V < W.length; ++V){
            let le = W[V];
            if (h(le, Uint8Array)) Z + le.length > C.length ? (a.isBuffer(le) || (le = a.from(le)), le.copy(C, Z)) : Uint8Array.prototype.set.call(C, le, Z);
            else if (a.isBuffer(le)) le.copy(C, Z);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            Z += le.length;
        }
        return C;
    };
    function D(ne, W) {
        if (a.isBuffer(ne)) return ne.length;
        if (ArrayBuffer.isView(ne) || h(ne, ArrayBuffer)) return ne.byteLength;
        if (typeof ne != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ne);
        const J = ne.length, V = arguments.length > 2 && arguments[2] === !0;
        if (!V && J === 0) return 0;
        let C = !1;
        for(;;)switch(W){
            case "ascii":
            case "latin1":
            case "binary":
                return J;
            case "utf8":
            case "utf-8":
                return _e(ne).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return J * 2;
            case "hex":
                return J >>> 1;
            case "base64":
                return Ke(ne).length;
            default:
                if (C) return V ? -1 : _e(ne).length;
                W = ("" + W).toLowerCase(), C = !0;
        }
    }
    a.byteLength = D;
    function H(ne, W, J) {
        let V = !1;
        if ((W === void 0 || W < 0) && (W = 0), W > this.length || ((J === void 0 || J > this.length) && (J = this.length), J <= 0) || (J >>>= 0, W >>>= 0, J <= W)) return "";
        for(ne || (ne = "utf8");;)switch(ne){
            case "hex":
                return P(this, W, J);
            case "utf8":
            case "utf-8":
                return g(this, W, J);
            case "ascii":
                return T(this, W, J);
            case "latin1":
            case "binary":
                return I(this, W, J);
            case "base64":
                return w(this, W, J);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return k(this, W, J);
            default:
                if (V) throw new TypeError("Unknown encoding: " + ne);
                ne = (ne + "").toLowerCase(), V = !0;
        }
    }
    a.prototype._isBuffer = !0;
    function K(ne, W, J) {
        const V = ne[W];
        ne[W] = ne[J], ne[J] = V;
    }
    a.prototype.swap16 = function() {
        const W = this.length;
        if (W % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let J = 0; J < W; J += 2)K(this, J, J + 1);
        return this;
    }, a.prototype.swap32 = function() {
        const W = this.length;
        if (W % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let J = 0; J < W; J += 4)K(this, J, J + 3), K(this, J + 1, J + 2);
        return this;
    }, a.prototype.swap64 = function() {
        const W = this.length;
        if (W % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let J = 0; J < W; J += 8)K(this, J, J + 7), K(this, J + 1, J + 6), K(this, J + 2, J + 5), K(this, J + 3, J + 4);
        return this;
    }, a.prototype.toString = function() {
        const W = this.length;
        return W === 0 ? "" : arguments.length === 0 ? g(this, 0, W) : H.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(W) {
        if (!a.isBuffer(W)) throw new TypeError("Argument must be a Buffer");
        return this === W ? !0 : a.compare(this, W) === 0;
    }, a.prototype.inspect = function() {
        let W = "";
        const J = e.INSPECT_MAX_BYTES;
        return W = this.toString("hex", 0, J).replace(/(.{2})/g, "$1 ").trim(), this.length > J && (W += " ... "), "<Buffer " + W + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(W, J, V, C, Z) {
        if (h(W, Uint8Array) && (W = a.from(W, W.offset, W.byteLength)), !a.isBuffer(W)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof W);
        if (J === void 0 && (J = 0), V === void 0 && (V = W ? W.length : 0), C === void 0 && (C = 0), Z === void 0 && (Z = this.length), J < 0 || V > W.length || C < 0 || Z > this.length) throw new RangeError("out of range index");
        if (C >= Z && J >= V) return 0;
        if (C >= Z) return -1;
        if (J >= V) return 1;
        if (J >>>= 0, V >>>= 0, C >>>= 0, Z >>>= 0, this === W) return 0;
        let le = Z - C, se = V - J;
        const Ne = Math.min(le, se), Le = this.slice(C, Z), rt = W.slice(J, V);
        for(let yt = 0; yt < Ne; ++yt)if (Le[yt] !== rt[yt]) {
            le = Le[yt], se = rt[yt];
            break;
        }
        return le < se ? -1 : se < le ? 1 : 0;
    };
    function re(ne, W, J, V, C) {
        if (ne.length === 0) return -1;
        if (typeof J == "string" ? (V = J, J = 0) : J > 2147483647 ? J = 2147483647 : J < -2147483648 && (J = -2147483648), J = +J, x(J) && (J = C ? 0 : ne.length - 1), J < 0 && (J = ne.length + J), J >= ne.length) {
            if (C) return -1;
            J = ne.length - 1;
        } else if (J < 0) if (C) J = 0;
        else return -1;
        if (typeof W == "string" && (W = a.from(W, V)), a.isBuffer(W)) return W.length === 0 ? -1 : Q(ne, W, J, V, C);
        if (typeof W == "number") return W = W & 255, typeof Uint8Array.prototype.indexOf == "function" ? C ? Uint8Array.prototype.indexOf.call(ne, W, J) : Uint8Array.prototype.lastIndexOf.call(ne, W, J) : Q(ne, [
            W
        ], J, V, C);
        throw new TypeError("val must be string, number or Buffer");
    }
    function Q(ne, W, J, V, C) {
        let Z = 1, le = ne.length, se = W.length;
        if (V !== void 0 && (V = String(V).toLowerCase(), V === "ucs2" || V === "ucs-2" || V === "utf16le" || V === "utf-16le")) {
            if (ne.length < 2 || W.length < 2) return -1;
            Z = 2, le /= 2, se /= 2, J /= 2;
        }
        function Ne(rt, yt) {
            return Z === 1 ? rt[yt] : rt.readUInt16BE(yt * Z);
        }
        let Le;
        if (C) {
            let rt = -1;
            for(Le = J; Le < le; Le++)if (Ne(ne, Le) === Ne(W, rt === -1 ? 0 : Le - rt)) {
                if (rt === -1 && (rt = Le), Le - rt + 1 === se) return rt * Z;
            } else rt !== -1 && (Le -= Le - rt), rt = -1;
        } else for(J + se > le && (J = le - se), Le = J; Le >= 0; Le--){
            let rt = !0;
            for(let yt = 0; yt < se; yt++)if (Ne(ne, Le + yt) !== Ne(W, yt)) {
                rt = !1;
                break;
            }
            if (rt) return Le;
        }
        return -1;
    }
    a.prototype.includes = function(W, J, V) {
        return this.indexOf(W, J, V) !== -1;
    }, a.prototype.indexOf = function(W, J, V) {
        return re(this, W, J, V, !0);
    }, a.prototype.lastIndexOf = function(W, J, V) {
        return re(this, W, J, V, !1);
    };
    function G(ne, W, J, V) {
        J = Number(J) || 0;
        const C = ne.length - J;
        V ? (V = Number(V), V > C && (V = C)) : V = C;
        const Z = W.length;
        V > Z / 2 && (V = Z / 2);
        let le;
        for(le = 0; le < V; ++le){
            const se = parseInt(W.substr(le * 2, 2), 16);
            if (x(se)) return le;
            ne[J + le] = se;
        }
        return le;
    }
    function R(ne, W, J, V) {
        return Ue(_e(W, ne.length - J), ne, J, V);
    }
    function X(ne, W, J, V) {
        return Ue(Ie(W), ne, J, V);
    }
    function $(ne, W, J, V) {
        return Ue(Ke(W), ne, J, V);
    }
    function S(ne, W, J, V) {
        return Ue(je(W, ne.length - J), ne, J, V);
    }
    a.prototype.write = function(W, J, V, C) {
        if (J === void 0) C = "utf8", V = this.length, J = 0;
        else if (V === void 0 && typeof J == "string") C = J, V = this.length, J = 0;
        else if (isFinite(J)) J = J >>> 0, isFinite(V) ? (V = V >>> 0, C === void 0 && (C = "utf8")) : (C = V, V = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Z = this.length - J;
        if ((V === void 0 || V > Z) && (V = Z), W.length > 0 && (V < 0 || J < 0) || J > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        C || (C = "utf8");
        let le = !1;
        for(;;)switch(C){
            case "hex":
                return G(this, W, J, V);
            case "utf8":
            case "utf-8":
                return R(this, W, J, V);
            case "ascii":
            case "latin1":
            case "binary":
                return X(this, W, J, V);
            case "base64":
                return $(this, W, J, V);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return S(this, W, J, V);
            default:
                if (le) throw new TypeError("Unknown encoding: " + C);
                C = ("" + C).toLowerCase(), le = !0;
        }
    }, a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function w(ne, W, J) {
        return W === 0 && J === ne.length ? t.fromByteArray(ne) : t.fromByteArray(ne.slice(W, J));
    }
    function g(ne, W, J) {
        J = Math.min(ne.length, J);
        const V = [];
        let C = W;
        for(; C < J;){
            const Z = ne[C];
            let le = null, se = Z > 239 ? 4 : Z > 223 ? 3 : Z > 191 ? 2 : 1;
            if (C + se <= J) {
                let Ne, Le, rt, yt;
                switch(se){
                    case 1:
                        Z < 128 && (le = Z);
                        break;
                    case 2:
                        Ne = ne[C + 1], (Ne & 192) === 128 && (yt = (Z & 31) << 6 | Ne & 63, yt > 127 && (le = yt));
                        break;
                    case 3:
                        Ne = ne[C + 1], Le = ne[C + 2], (Ne & 192) === 128 && (Le & 192) === 128 && (yt = (Z & 15) << 12 | (Ne & 63) << 6 | Le & 63, yt > 2047 && (yt < 55296 || yt > 57343) && (le = yt));
                        break;
                    case 4:
                        Ne = ne[C + 1], Le = ne[C + 2], rt = ne[C + 3], (Ne & 192) === 128 && (Le & 192) === 128 && (rt & 192) === 128 && (yt = (Z & 15) << 18 | (Ne & 63) << 12 | (Le & 63) << 6 | rt & 63, yt > 65535 && yt < 1114112 && (le = yt));
                }
            }
            le === null ? (le = 65533, se = 1) : le > 65535 && (le -= 65536, V.push(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), V.push(le), C += se;
        }
        return E(V);
    }
    const m = 4096;
    function E(ne) {
        const W = ne.length;
        if (W <= m) return String.fromCharCode.apply(String, ne);
        let J = "", V = 0;
        for(; V < W;)J += String.fromCharCode.apply(String, ne.slice(V, V += m));
        return J;
    }
    function T(ne, W, J) {
        let V = "";
        J = Math.min(ne.length, J);
        for(let C = W; C < J; ++C)V += String.fromCharCode(ne[C] & 127);
        return V;
    }
    function I(ne, W, J) {
        let V = "";
        J = Math.min(ne.length, J);
        for(let C = W; C < J; ++C)V += String.fromCharCode(ne[C]);
        return V;
    }
    function P(ne, W, J) {
        const V = ne.length;
        (!W || W < 0) && (W = 0), (!J || J < 0 || J > V) && (J = V);
        let C = "";
        for(let Z = W; Z < J; ++Z)C += q[ne[Z]];
        return C;
    }
    function k(ne, W, J) {
        const V = ne.slice(W, J);
        let C = "";
        for(let Z = 0; Z < V.length - 1; Z += 2)C += String.fromCharCode(V[Z] + V[Z + 1] * 256);
        return C;
    }
    a.prototype.slice = function(W, J) {
        const V = this.length;
        W = ~~W, J = J === void 0 ? V : ~~J, W < 0 ? (W += V, W < 0 && (W = 0)) : W > V && (W = V), J < 0 ? (J += V, J < 0 && (J = 0)) : J > V && (J = V), J < W && (J = W);
        const C = this.subarray(W, J);
        return Object.setPrototypeOf(C, a.prototype), C;
    };
    function L(ne, W, J) {
        if (ne % 1 !== 0 || ne < 0) throw new RangeError("offset is not uint");
        if (ne + W > J) throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = this[W], Z = 1, le = 0;
        for(; ++le < J && (Z *= 256);)C += this[W + le] * Z;
        return C;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = this[W + --J], Z = 1;
        for(; J > 0 && (Z *= 256);)C += this[W + --J] * Z;
        return C;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(W, J) {
        return W = W >>> 0, J || L(W, 1, this.length), this[W];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(W, J) {
        return W = W >>> 0, J || L(W, 2, this.length), this[W] | this[W + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(W, J) {
        return W = W >>> 0, J || L(W, 2, this.length), this[W] << 8 | this[W + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), (this[W] | this[W + 1] << 8 | this[W + 2] << 16) + this[W + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), this[W] * 16777216 + (this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3]);
    }, a.prototype.readBigUInt64LE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = J + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24, Z = this[++W] + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + V * 2 ** 24;
        return BigInt(C) + (BigInt(Z) << BigInt(32));
    }), a.prototype.readBigUInt64BE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = J * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W], Z = this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + V;
        return (BigInt(C) << BigInt(32)) + BigInt(Z);
    }), a.prototype.readIntLE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = this[W], Z = 1, le = 0;
        for(; ++le < J && (Z *= 256);)C += this[W + le] * Z;
        return Z *= 128, C >= Z && (C -= Math.pow(2, 8 * J)), C;
    }, a.prototype.readIntBE = function(W, J, V) {
        W = W >>> 0, J = J >>> 0, V || L(W, J, this.length);
        let C = J, Z = 1, le = this[W + --C];
        for(; C > 0 && (Z *= 256);)le += this[W + --C] * Z;
        return Z *= 128, le >= Z && (le -= Math.pow(2, 8 * J)), le;
    }, a.prototype.readInt8 = function(W, J) {
        return W = W >>> 0, J || L(W, 1, this.length), this[W] & 128 ? (255 - this[W] + 1) * -1 : this[W];
    }, a.prototype.readInt16LE = function(W, J) {
        W = W >>> 0, J || L(W, 2, this.length);
        const V = this[W] | this[W + 1] << 8;
        return V & 32768 ? V | 4294901760 : V;
    }, a.prototype.readInt16BE = function(W, J) {
        W = W >>> 0, J || L(W, 2, this.length);
        const V = this[W + 1] | this[W] << 8;
        return V & 32768 ? V | 4294901760 : V;
    }, a.prototype.readInt32LE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), this[W] | this[W + 1] << 8 | this[W + 2] << 16 | this[W + 3] << 24;
    }, a.prototype.readInt32BE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), this[W] << 24 | this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3];
    }, a.prototype.readBigInt64LE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = this[W + 4] + this[W + 5] * 2 ** 8 + this[W + 6] * 2 ** 16 + (V << 24);
        return (BigInt(C) << BigInt(32)) + BigInt(J + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24);
    }), a.prototype.readBigInt64BE = te(function(W) {
        W = W >>> 0, Ce(W, "offset");
        const J = this[W], V = this[W + 7];
        (J === void 0 || V === void 0) && M(W, this.length - 8);
        const C = (J << 24) + // Overflow
        this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W];
        return (BigInt(C) << BigInt(32)) + BigInt(this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + V);
    }), a.prototype.readFloatLE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), r.read(this, W, !0, 23, 4);
    }, a.prototype.readFloatBE = function(W, J) {
        return W = W >>> 0, J || L(W, 4, this.length), r.read(this, W, !1, 23, 4);
    }, a.prototype.readDoubleLE = function(W, J) {
        return W = W >>> 0, J || L(W, 8, this.length), r.read(this, W, !0, 52, 8);
    }, a.prototype.readDoubleBE = function(W, J) {
        return W = W >>> 0, J || L(W, 8, this.length), r.read(this, W, !1, 52, 8);
    };
    function j(ne, W, J, V, C, Z) {
        if (!a.isBuffer(ne)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (W > C || W < Z) throw new RangeError('"value" argument is out of bounds');
        if (J + V > ne.length) throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, V = V >>> 0, !C) {
            const se = Math.pow(2, 8 * V) - 1;
            j(this, W, J, V, se, 0);
        }
        let Z = 1, le = 0;
        for(this[J] = W & 255; ++le < V && (Z *= 256);)this[J + le] = W / Z & 255;
        return J + V;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, V = V >>> 0, !C) {
            const se = Math.pow(2, 8 * V) - 1;
            j(this, W, J, V, se, 0);
        }
        let Z = V - 1, le = 1;
        for(this[J + Z] = W & 255; --Z >= 0 && (le *= 256);)this[J + Z] = W / le & 255;
        return J + V;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 1, 255, 0), this[J] = W & 255, J + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 65535, 0), this[J] = W & 255, this[J + 1] = W >>> 8, J + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 65535, 0), this[J] = W >>> 8, this[J + 1] = W & 255, J + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 4294967295, 0), this[J + 3] = W >>> 24, this[J + 2] = W >>> 16, this[J + 1] = W >>> 8, this[J] = W & 255, J + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 4294967295, 0), this[J] = W >>> 24, this[J + 1] = W >>> 16, this[J + 2] = W >>> 8, this[J + 3] = W & 255, J + 4;
    };
    function ie(ne, W, J, V, C) {
        Re(W, V, C, ne, J, 7);
        let Z = Number(W & BigInt(4294967295));
        ne[J++] = Z, Z = Z >> 8, ne[J++] = Z, Z = Z >> 8, ne[J++] = Z, Z = Z >> 8, ne[J++] = Z;
        let le = Number(W >> BigInt(32) & BigInt(4294967295));
        return ne[J++] = le, le = le >> 8, ne[J++] = le, le = le >> 8, ne[J++] = le, le = le >> 8, ne[J++] = le, J;
    }
    function ue(ne, W, J, V, C) {
        Re(W, V, C, ne, J, 7);
        let Z = Number(W & BigInt(4294967295));
        ne[J + 7] = Z, Z = Z >> 8, ne[J + 6] = Z, Z = Z >> 8, ne[J + 5] = Z, Z = Z >> 8, ne[J + 4] = Z;
        let le = Number(W >> BigInt(32) & BigInt(4294967295));
        return ne[J + 3] = le, le = le >> 8, ne[J + 2] = le, le = le >> 8, ne[J + 1] = le, le = le >> 8, ne[J] = le, J + 8;
    }
    a.prototype.writeBigUInt64LE = te(function(W, J = 0) {
        return ie(this, W, J, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = te(function(W, J = 0) {
        return ue(this, W, J, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, !C) {
            const Ne = Math.pow(2, 8 * V - 1);
            j(this, W, J, V, Ne - 1, -Ne);
        }
        let Z = 0, le = 1, se = 0;
        for(this[J] = W & 255; ++Z < V && (le *= 256);)W < 0 && se === 0 && this[J + Z - 1] !== 0 && (se = 1), this[J + Z] = (W / le >> 0) - se & 255;
        return J + V;
    }, a.prototype.writeIntBE = function(W, J, V, C) {
        if (W = +W, J = J >>> 0, !C) {
            const Ne = Math.pow(2, 8 * V - 1);
            j(this, W, J, V, Ne - 1, -Ne);
        }
        let Z = V - 1, le = 1, se = 0;
        for(this[J + Z] = W & 255; --Z >= 0 && (le *= 256);)W < 0 && se === 0 && this[J + Z + 1] !== 0 && (se = 1), this[J + Z] = (W / le >> 0) - se & 255;
        return J + V;
    }, a.prototype.writeInt8 = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 1, 127, -128), W < 0 && (W = 255 + W + 1), this[J] = W & 255, J + 1;
    }, a.prototype.writeInt16LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 32767, -32768), this[J] = W & 255, this[J + 1] = W >>> 8, J + 2;
    }, a.prototype.writeInt16BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 2, 32767, -32768), this[J] = W >>> 8, this[J + 1] = W & 255, J + 2;
    }, a.prototype.writeInt32LE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 2147483647, -2147483648), this[J] = W & 255, this[J + 1] = W >>> 8, this[J + 2] = W >>> 16, this[J + 3] = W >>> 24, J + 4;
    }, a.prototype.writeInt32BE = function(W, J, V) {
        return W = +W, J = J >>> 0, V || j(this, W, J, 4, 2147483647, -2147483648), W < 0 && (W = 4294967295 + W + 1), this[J] = W >>> 24, this[J + 1] = W >>> 16, this[J + 2] = W >>> 8, this[J + 3] = W & 255, J + 4;
    }, a.prototype.writeBigInt64LE = te(function(W, J = 0) {
        return ie(this, W, J, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = te(function(W, J = 0) {
        return ue(this, W, J, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ce(ne, W, J, V, C, Z) {
        if (J + V > ne.length) throw new RangeError("Index out of range");
        if (J < 0) throw new RangeError("Index out of range");
    }
    function he(ne, W, J, V, C) {
        return W = +W, J = J >>> 0, C || ce(ne, W, J, 4), r.write(ne, W, J, V, 23, 4), J + 4;
    }
    a.prototype.writeFloatLE = function(W, J, V) {
        return he(this, W, J, !0, V);
    }, a.prototype.writeFloatBE = function(W, J, V) {
        return he(this, W, J, !1, V);
    };
    function ee(ne, W, J, V, C) {
        return W = +W, J = J >>> 0, C || ce(ne, W, J, 8), r.write(ne, W, J, V, 52, 8), J + 8;
    }
    a.prototype.writeDoubleLE = function(W, J, V) {
        return ee(this, W, J, !0, V);
    }, a.prototype.writeDoubleBE = function(W, J, V) {
        return ee(this, W, J, !1, V);
    }, a.prototype.copy = function(W, J, V, C) {
        if (!a.isBuffer(W)) throw new TypeError("argument should be a Buffer");
        if (V || (V = 0), !C && C !== 0 && (C = this.length), J >= W.length && (J = W.length), J || (J = 0), C > 0 && C < V && (C = V), C === V || W.length === 0 || this.length === 0) return 0;
        if (J < 0) throw new RangeError("targetStart out of bounds");
        if (V < 0 || V >= this.length) throw new RangeError("Index out of range");
        if (C < 0) throw new RangeError("sourceEnd out of bounds");
        C > this.length && (C = this.length), W.length - J < C - V && (C = W.length - J + V);
        const Z = C - V;
        return this === W && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(J, V, C) : Uint8Array.prototype.set.call(W, this.subarray(V, C), J), Z;
    }, a.prototype.fill = function(W, J, V, C) {
        if (typeof W == "string") {
            if (typeof J == "string" ? (C = J, J = 0, V = this.length) : typeof V == "string" && (C = V, V = this.length), C !== void 0 && typeof C != "string") throw new TypeError("encoding must be a string");
            if (typeof C == "string" && !a.isEncoding(C)) throw new TypeError("Unknown encoding: " + C);
            if (W.length === 1) {
                const le = W.charCodeAt(0);
                (C === "utf8" && le < 128 || C === "latin1") && (W = le);
            }
        } else typeof W == "number" ? W = W & 255 : typeof W == "boolean" && (W = Number(W));
        if (J < 0 || this.length < J || this.length < V) throw new RangeError("Out of range index");
        if (V <= J) return this;
        J = J >>> 0, V = V === void 0 ? this.length : V >>> 0, W || (W = 0);
        let Z;
        if (typeof W == "number") for(Z = J; Z < V; ++Z)this[Z] = W;
        else {
            const le = a.isBuffer(W) ? W : a.from(W, C), se = le.length;
            if (se === 0) throw new TypeError('The value "' + W + '" is invalid for argument "value"');
            for(Z = 0; Z < V - J; ++Z)this[Z + J] = le[Z % se];
        }
        return this;
    };
    const ae = {};
    function ye(ne, W, J) {
        ae[ne] = class extends J {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: W.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${ne}]`, this.stack, delete this.name;
            }
            get code() {
                return ne;
            }
            set code(C) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: C,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${ne}]: ${this.message}`;
            }
        };
    }
    ye("ERR_BUFFER_OUT_OF_BOUNDS", function(ne) {
        return ne ? `${ne} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), ye("ERR_INVALID_ARG_TYPE", function(ne, W) {
        return `The "${ne}" argument must be of type number. Received type ${typeof W}`;
    }, TypeError), ye("ERR_OUT_OF_RANGE", function(ne, W, J) {
        let V = `The value of "${ne}" is out of range.`, C = J;
        return Number.isInteger(J) && Math.abs(J) > 2 ** 32 ? C = Se(String(J)) : typeof J == "bigint" && (C = String(J), (J > BigInt(2) ** BigInt(32) || J < -(BigInt(2) ** BigInt(32))) && (C = Se(C)), C += "n"), V += ` It must be ${W}. Received ${C}`, V;
    }, RangeError);
    function Se(ne) {
        let W = "", J = ne.length;
        const V = ne[0] === "-" ? 1 : 0;
        for(; J >= V + 4; J -= 3)W = `_${ne.slice(J - 3, J)}${W}`;
        return `${ne.slice(0, J)}${W}`;
    }
    function De(ne, W, J) {
        Ce(W, "offset"), (ne[W] === void 0 || ne[W + J] === void 0) && M(W, ne.length - (J + 1));
    }
    function Re(ne, W, J, V, C, Z) {
        if (ne > J || ne < W) {
            const le = typeof W == "bigint" ? "n" : "";
            let se;
            throw W === 0 || W === BigInt(0) ? se = `>= 0${le} and < 2${le} ** ${(Z + 1) * 8}${le}` : se = `>= -(2${le} ** ${(Z + 1) * 8 - 1}${le}) and < 2 ** ${(Z + 1) * 8 - 1}${le}`, new ae.ERR_OUT_OF_RANGE("value", se, ne);
        }
        De(V, C, Z);
    }
    function Ce(ne, W) {
        if (typeof ne != "number") throw new ae.ERR_INVALID_ARG_TYPE(W, "number", ne);
    }
    function M(ne, W, J) {
        throw Math.floor(ne) !== ne ? (Ce(ne, J), new ae.ERR_OUT_OF_RANGE("offset", "an integer", ne)) : W < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS() : new ae.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${W}`, ne);
    }
    const z = /[^+/0-9A-Za-z-_]/g;
    function de(ne) {
        if (ne = ne.split("=")[0], ne = ne.trim().replace(z, ""), ne.length < 2) return "";
        for(; ne.length % 4 !== 0;)ne = ne + "=";
        return ne;
    }
    function _e(ne, W) {
        W = W || 1 / 0;
        let J;
        const V = ne.length;
        let C = null;
        const Z = [];
        for(let le = 0; le < V; ++le){
            if (J = ne.charCodeAt(le), J > 55295 && J < 57344) {
                if (!C) {
                    if (J > 56319) {
                        (W -= 3) > -1 && Z.push(239, 191, 189);
                        continue;
                    } else if (le + 1 === V) {
                        (W -= 3) > -1 && Z.push(239, 191, 189);
                        continue;
                    }
                    C = J;
                    continue;
                }
                if (J < 56320) {
                    (W -= 3) > -1 && Z.push(239, 191, 189), C = J;
                    continue;
                }
                J = (C - 55296 << 10 | J - 56320) + 65536;
            } else C && (W -= 3) > -1 && Z.push(239, 191, 189);
            if (C = null, J < 128) {
                if ((W -= 1) < 0) break;
                Z.push(J);
            } else if (J < 2048) {
                if ((W -= 2) < 0) break;
                Z.push(J >> 6 | 192, J & 63 | 128);
            } else if (J < 65536) {
                if ((W -= 3) < 0) break;
                Z.push(J >> 12 | 224, J >> 6 & 63 | 128, J & 63 | 128);
            } else if (J < 1114112) {
                if ((W -= 4) < 0) break;
                Z.push(J >> 18 | 240, J >> 12 & 63 | 128, J >> 6 & 63 | 128, J & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return Z;
    }
    function Ie(ne) {
        const W = [];
        for(let J = 0; J < ne.length; ++J)W.push(ne.charCodeAt(J) & 255);
        return W;
    }
    function je(ne, W) {
        let J, V, C;
        const Z = [];
        for(let le = 0; le < ne.length && !((W -= 2) < 0); ++le)J = ne.charCodeAt(le), V = J >> 8, C = J % 256, Z.push(C), Z.push(V);
        return Z;
    }
    function Ke(ne) {
        return t.toByteArray(de(ne));
    }
    function Ue(ne, W, J, V) {
        let C;
        for(C = 0; C < V && !(C + J >= W.length || C >= ne.length); ++C)W[C + J] = ne[C];
        return C;
    }
    function h(ne, W) {
        return ne instanceof W || ne != null && ne.constructor != null && ne.constructor.name != null && ne.constructor.name === W.name;
    }
    function x(ne) {
        return ne !== ne;
    }
    const q = function() {
        const ne = "0123456789abcdef", W = new Array(256);
        for(let J = 0; J < 16; ++J){
            const V = J * 16;
            for(let C = 0; C < 16; ++C)W[V + C] = ne[J] + ne[C];
        }
        return W;
    }();
    function te(ne) {
        return typeof BigInt > "u" ? fe : ne;
    }
    function fe() {
        throw new Error("BigInt not supported");
    }
})(ku);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var bA;
function Ar() {
    return bA || (bA = 1, function(e, t) {
        var r = ku, n = r.Buffer;
        function i(s, a) {
            for(var u in s)a[u] = s[u];
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = o);
        function o(s, a, u) {
            return n(s, a, u);
        }
        o.prototype = Object.create(n.prototype), i(n, o), o.from = function(s, a, u) {
            if (typeof s == "number") throw new TypeError("Argument must not be a number");
            return n(s, a, u);
        }, o.alloc = function(s, a, u) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            var f = n(s);
            return a !== void 0 ? typeof u == "string" ? f.fill(a, u) : f.fill(a) : f.fill(0), f;
        }, o.allocUnsafe = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return n(s);
        }, o.allocUnsafeSlow = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return r.SlowBuffer(s);
        };
    }(Rg, Rg.exports)), Rg.exports;
}
var wA;
function kd() {
    if (wA) return Mg.exports;
    wA = 1;
    var e = 65536, t = 4294967295;
    function r() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var n = Ar().Buffer, i = Ge.crypto || Ge.msCrypto;
    i && i.getRandomValues ? Mg.exports = o : Mg.exports = r;
    function o(s, a) {
        if (s > t) throw new RangeError("requested too many random bytes");
        var u = n.allocUnsafe(s);
        if (s > 0) if (s > e) for(var f = 0; f < s; f += e)i.getRandomValues(u.slice(f, f + e));
        else i.getRandomValues(u);
        return typeof a == "function" ? bn.nextTick(function() {
            a(null, u);
        }) : u;
    }
    return Mg.exports;
}
var Cg = {
    exports: {}
}, vA;
function Or() {
    return vA || (vA = 1, typeof Object.create == "function" ? Cg.exports = function(t, r) {
        r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    } : Cg.exports = function(t, r) {
        if (r) {
            t.super_ = r;
            var n = function() {};
            n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
        }
    }), Cg.exports;
}
const dY = {}, hY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: dY
}, Symbol.toStringTag, {
    value: "Module"
})), Iu = /* @__PURE__ */ Jq(hY);
var sv, _A;
function nO() {
    if (_A) return sv;
    _A = 1;
    var e = Ar().Buffer, t = Iu.Transform, r = Or();
    function n(a) {
        t.call(this), this._block = e.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [
            0,
            0,
            0,
            0
        ], this._finalized = !1;
    }
    r(n, t), n.prototype._transform = function(a, u, f) {
        var c = null;
        try {
            this.update(a, u);
        } catch (l) {
            c = l;
        }
        f(c);
    }, n.prototype._flush = function(a) {
        var u = null;
        try {
            this.push(this.digest());
        } catch (f) {
            u = f;
        }
        a(u);
    };
    var i = typeof Uint8Array < "u", o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
    function s(a, u) {
        if (a instanceof e) return a;
        if (typeof a == "string") return e.from(a, u);
        if (o && ArrayBuffer.isView(a)) {
            if (a.byteLength === 0) return e.alloc(0);
            var f = e.from(a.buffer, a.byteOffset, a.byteLength);
            if (f.byteLength === a.byteLength) return f;
        }
        if (i && a instanceof Uint8Array || e.isBuffer(a) && a.constructor && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a)) return e.from(a);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    return n.prototype.update = function(a, u) {
        if (this._finalized) throw new Error("Digest already called");
        a = s(a, u);
        for(var f = this._block, c = 0; this._blockOffset + a.length - c >= this._blockSize;){
            for(var l = this._blockOffset; l < this._blockSize;)f[l++] = a[c++];
            this._update(), this._blockOffset = 0;
        }
        for(; c < a.length;)f[this._blockOffset++] = a[c++];
        for(var p = 0, y = a.length * 8; y > 0; ++p)this._length[p] += y, y = this._length[p] / 4294967296 | 0, y > 0 && (this._length[p] -= 4294967296 * y);
        return this;
    }, n.prototype._update = function() {
        throw new Error("_update is not implemented");
    }, n.prototype.digest = function(a) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = !0;
        var u = this._digest();
        a !== void 0 && (u = u.toString(a)), this._block.fill(0), this._blockOffset = 0;
        for(var f = 0; f < 4; ++f)this._length[f] = 0;
        return u;
    }, n.prototype._digest = function() {
        throw new Error("_digest is not implemented");
    }, sv = n, sv;
}
var av, EA;
function N3() {
    if (EA) return av;
    EA = 1;
    var e = Or(), t = nO(), r = Ar().Buffer, n = new Array(16);
    function i() {
        t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    e(i, t), i.prototype._update = function() {
        for(var c = n, l = 0; l < 16; ++l)c[l] = this._block.readInt32LE(l * 4);
        var p = this._a, y = this._b, _ = this._c, A = this._d;
        p = s(p, y, _, A, c[0], 3614090360, 7), A = s(A, p, y, _, c[1], 3905402710, 12), _ = s(_, A, p, y, c[2], 606105819, 17), y = s(y, _, A, p, c[3], 3250441966, 22), p = s(p, y, _, A, c[4], 4118548399, 7), A = s(A, p, y, _, c[5], 1200080426, 12), _ = s(_, A, p, y, c[6], 2821735955, 17), y = s(y, _, A, p, c[7], 4249261313, 22), p = s(p, y, _, A, c[8], 1770035416, 7), A = s(A, p, y, _, c[9], 2336552879, 12), _ = s(_, A, p, y, c[10], 4294925233, 17), y = s(y, _, A, p, c[11], 2304563134, 22), p = s(p, y, _, A, c[12], 1804603682, 7), A = s(A, p, y, _, c[13], 4254626195, 12), _ = s(_, A, p, y, c[14], 2792965006, 17), y = s(y, _, A, p, c[15], 1236535329, 22), p = a(p, y, _, A, c[1], 4129170786, 5), A = a(A, p, y, _, c[6], 3225465664, 9), _ = a(_, A, p, y, c[11], 643717713, 14), y = a(y, _, A, p, c[0], 3921069994, 20), p = a(p, y, _, A, c[5], 3593408605, 5), A = a(A, p, y, _, c[10], 38016083, 9), _ = a(_, A, p, y, c[15], 3634488961, 14), y = a(y, _, A, p, c[4], 3889429448, 20), p = a(p, y, _, A, c[9], 568446438, 5), A = a(A, p, y, _, c[14], 3275163606, 9), _ = a(_, A, p, y, c[3], 4107603335, 14), y = a(y, _, A, p, c[8], 1163531501, 20), p = a(p, y, _, A, c[13], 2850285829, 5), A = a(A, p, y, _, c[2], 4243563512, 9), _ = a(_, A, p, y, c[7], 1735328473, 14), y = a(y, _, A, p, c[12], 2368359562, 20), p = u(p, y, _, A, c[5], 4294588738, 4), A = u(A, p, y, _, c[8], 2272392833, 11), _ = u(_, A, p, y, c[11], 1839030562, 16), y = u(y, _, A, p, c[14], 4259657740, 23), p = u(p, y, _, A, c[1], 2763975236, 4), A = u(A, p, y, _, c[4], 1272893353, 11), _ = u(_, A, p, y, c[7], 4139469664, 16), y = u(y, _, A, p, c[10], 3200236656, 23), p = u(p, y, _, A, c[13], 681279174, 4), A = u(A, p, y, _, c[0], 3936430074, 11), _ = u(_, A, p, y, c[3], 3572445317, 16), y = u(y, _, A, p, c[6], 76029189, 23), p = u(p, y, _, A, c[9], 3654602809, 4), A = u(A, p, y, _, c[12], 3873151461, 11), _ = u(_, A, p, y, c[15], 530742520, 16), y = u(y, _, A, p, c[2], 3299628645, 23), p = f(p, y, _, A, c[0], 4096336452, 6), A = f(A, p, y, _, c[7], 1126891415, 10), _ = f(_, A, p, y, c[14], 2878612391, 15), y = f(y, _, A, p, c[5], 4237533241, 21), p = f(p, y, _, A, c[12], 1700485571, 6), A = f(A, p, y, _, c[3], 2399980690, 10), _ = f(_, A, p, y, c[10], 4293915773, 15), y = f(y, _, A, p, c[1], 2240044497, 21), p = f(p, y, _, A, c[8], 1873313359, 6), A = f(A, p, y, _, c[15], 4264355552, 10), _ = f(_, A, p, y, c[6], 2734768916, 15), y = f(y, _, A, p, c[13], 1309151649, 21), p = f(p, y, _, A, c[4], 4149444226, 6), A = f(A, p, y, _, c[11], 3174756917, 10), _ = f(_, A, p, y, c[2], 718787259, 15), y = f(y, _, A, p, c[9], 3951481745, 21), this._a = this._a + p | 0, this._b = this._b + y | 0, this._c = this._c + _ | 0, this._d = this._d + A | 0;
    }, i.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var c = r.allocUnsafe(16);
        return c.writeInt32LE(this._a, 0), c.writeInt32LE(this._b, 4), c.writeInt32LE(this._c, 8), c.writeInt32LE(this._d, 12), c;
    };
    function o(c, l) {
        return c << l | c >>> 32 - l;
    }
    function s(c, l, p, y, _, A, O) {
        return o(c + (l & p | ~l & y) + _ + A | 0, O) + l | 0;
    }
    function a(c, l, p, y, _, A, O) {
        return o(c + (l & y | p & ~y) + _ + A | 0, O) + l | 0;
    }
    function u(c, l, p, y, _, A, O) {
        return o(c + (l ^ p ^ y) + _ + A | 0, O) + l | 0;
    }
    function f(c, l, p, y, _, A, O) {
        return o(c + (p ^ (l | ~y)) + _ + A | 0, O) + l | 0;
    }
    return av = i, av;
}
var cv, xA;
function M3() {
    if (xA) return cv;
    xA = 1;
    var e = ku.Buffer, t = Or(), r = nO(), n = new Array(16), i = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], o = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], a = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ], u = [
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
    ], f = [
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
    ];
    function c() {
        r.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    t(c, r), c.prototype._update = function() {
        for(var N = n, U = 0; U < 16; ++U)N[U] = this._block.readInt32LE(U * 4);
        for(var D = this._a | 0, H = this._b | 0, K = this._c | 0, re = this._d | 0, Q = this._e | 0, G = this._a | 0, R = this._b | 0, X = this._c | 0, $ = this._d | 0, S = this._e | 0, w = 0; w < 80; w += 1){
            var g, m;
            w < 16 ? (g = p(D, H, K, re, Q, N[i[w]], u[0], s[w]), m = O(G, R, X, $, S, N[o[w]], f[0], a[w])) : w < 32 ? (g = y(D, H, K, re, Q, N[i[w]], u[1], s[w]), m = A(G, R, X, $, S, N[o[w]], f[1], a[w])) : w < 48 ? (g = _(D, H, K, re, Q, N[i[w]], u[2], s[w]), m = _(G, R, X, $, S, N[o[w]], f[2], a[w])) : w < 64 ? (g = A(D, H, K, re, Q, N[i[w]], u[3], s[w]), m = y(G, R, X, $, S, N[o[w]], f[3], a[w])) : (g = O(D, H, K, re, Q, N[i[w]], u[4], s[w]), m = p(G, R, X, $, S, N[o[w]], f[4], a[w])), D = Q, Q = re, re = l(K, 10), K = H, H = g, G = S, S = $, $ = l(X, 10), X = R, R = m;
        }
        var E = this._b + K + $ | 0;
        this._b = this._c + re + S | 0, this._c = this._d + Q + G | 0, this._d = this._e + D + R | 0, this._e = this._a + H + X | 0, this._a = E;
    }, c.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var N = e.alloc ? e.alloc(20) : new e(20);
        return N.writeInt32LE(this._a, 0), N.writeInt32LE(this._b, 4), N.writeInt32LE(this._c, 8), N.writeInt32LE(this._d, 12), N.writeInt32LE(this._e, 16), N;
    };
    function l(N, U) {
        return N << U | N >>> 32 - U;
    }
    function p(N, U, D, H, K, re, Q, G) {
        return l(N + (U ^ D ^ H) + re + Q | 0, G) + K | 0;
    }
    function y(N, U, D, H, K, re, Q, G) {
        return l(N + (U & D | ~U & H) + re + Q | 0, G) + K | 0;
    }
    function _(N, U, D, H, K, re, Q, G) {
        return l(N + ((U | ~D) ^ H) + re + Q | 0, G) + K | 0;
    }
    function A(N, U, D, H, K, re, Q, G) {
        return l(N + (U & H | D & ~H) + re + Q | 0, G) + K | 0;
    }
    function O(N, U, D, H, K, re, Q, G) {
        return l(N + (U ^ (D | ~H)) + re + Q | 0, G) + K | 0;
    }
    return cv = c, cv;
}
var uv = {
    exports: {}
}, fv, SA;
function Id() {
    if (SA) return fv;
    SA = 1;
    var e = Ar().Buffer;
    function t(r, n) {
        this._block = e.alloc(r), this._finalSize = n, this._blockSize = r, this._len = 0;
    }
    return t.prototype.update = function(r, n) {
        typeof r == "string" && (n = n || "utf8", r = e.from(r, n));
        for(var i = this._block, o = this._blockSize, s = r.length, a = this._len, u = 0; u < s;){
            for(var f = a % o, c = Math.min(s - u, o - f), l = 0; l < c; l++)i[f + l] = r[u + l];
            a += c, u += c, a % o === 0 && this._update(i);
        }
        return this._len += s, this;
    }, t.prototype.digest = function(r) {
        var n = this._len % this._blockSize;
        this._block[n] = 128, this._block.fill(0, n + 1), n >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var i = this._len * 8;
        if (i <= 4294967295) this._block.writeUInt32BE(i, this._blockSize - 4);
        else {
            var o = (i & 4294967295) >>> 0, s = (i - o) / 4294967296;
            this._block.writeUInt32BE(s, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
        }
        this._update(this._block);
        var a = this._hash();
        return r ? a.toString(r) : a;
    }, t.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    }, fv = t, fv;
}
var lv, AA;
function pY() {
    if (AA) return lv;
    AA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], i = new Array(80);
    function o() {
        this.init(), this._w = i, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function s(f) {
        return f << 5 | f >>> 27;
    }
    function a(f) {
        return f << 30 | f >>> 2;
    }
    function u(f, c, l, p) {
        return f === 0 ? c & l | ~c & p : f === 2 ? c & l | c & p | l & p : c ^ l ^ p;
    }
    return o.prototype._update = function(f) {
        for(var c = this._w, l = this._a | 0, p = this._b | 0, y = this._c | 0, _ = this._d | 0, A = this._e | 0, O = 0; O < 16; ++O)c[O] = f.readInt32BE(O * 4);
        for(; O < 80; ++O)c[O] = c[O - 3] ^ c[O - 8] ^ c[O - 14] ^ c[O - 16];
        for(var N = 0; N < 80; ++N){
            var U = ~~(N / 20), D = s(l) + u(U, p, y, _) + A + c[N] + n[U] | 0;
            A = _, _ = y, y = a(p), p = l, l = D;
        }
        this._a = l + this._a | 0, this._b = p + this._b | 0, this._c = y + this._c | 0, this._d = _ + this._d | 0, this._e = A + this._e | 0;
    }, o.prototype._hash = function() {
        var f = r.allocUnsafe(20);
        return f.writeInt32BE(this._a | 0, 0), f.writeInt32BE(this._b | 0, 4), f.writeInt32BE(this._c | 0, 8), f.writeInt32BE(this._d | 0, 12), f.writeInt32BE(this._e | 0, 16), f;
    }, lv = o, lv;
}
var dv, TA;
function gY() {
    if (TA) return dv;
    TA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], i = new Array(80);
    function o() {
        this.init(), this._w = i, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function s(c) {
        return c << 1 | c >>> 31;
    }
    function a(c) {
        return c << 5 | c >>> 27;
    }
    function u(c) {
        return c << 30 | c >>> 2;
    }
    function f(c, l, p, y) {
        return c === 0 ? l & p | ~l & y : c === 2 ? l & p | l & y | p & y : l ^ p ^ y;
    }
    return o.prototype._update = function(c) {
        for(var l = this._w, p = this._a | 0, y = this._b | 0, _ = this._c | 0, A = this._d | 0, O = this._e | 0, N = 0; N < 16; ++N)l[N] = c.readInt32BE(N * 4);
        for(; N < 80; ++N)l[N] = s(l[N - 3] ^ l[N - 8] ^ l[N - 14] ^ l[N - 16]);
        for(var U = 0; U < 80; ++U){
            var D = ~~(U / 20), H = a(p) + f(D, y, _, A) + O + l[U] + n[D] | 0;
            O = A, A = _, _ = u(y), y = p, p = H;
        }
        this._a = p + this._a | 0, this._b = y + this._b | 0, this._c = _ + this._c | 0, this._d = A + this._d | 0, this._e = O + this._e | 0;
    }, o.prototype._hash = function() {
        var c = r.allocUnsafe(20);
        return c.writeInt32BE(this._a | 0, 0), c.writeInt32BE(this._b | 0, 4), c.writeInt32BE(this._c | 0, 8), c.writeInt32BE(this._d | 0, 12), c.writeInt32BE(this._e | 0, 16), c;
    }, dv = o, dv;
}
var hv, kA;
function iO() {
    if (kA) return hv;
    kA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ], i = new Array(64);
    function o() {
        this.init(), this._w = i, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function s(p, y, _) {
        return _ ^ p & (y ^ _);
    }
    function a(p, y, _) {
        return p & y | _ & (p | y);
    }
    function u(p) {
        return (p >>> 2 | p << 30) ^ (p >>> 13 | p << 19) ^ (p >>> 22 | p << 10);
    }
    function f(p) {
        return (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7);
    }
    function c(p) {
        return (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3;
    }
    function l(p) {
        return (p >>> 17 | p << 15) ^ (p >>> 19 | p << 13) ^ p >>> 10;
    }
    return o.prototype._update = function(p) {
        for(var y = this._w, _ = this._a | 0, A = this._b | 0, O = this._c | 0, N = this._d | 0, U = this._e | 0, D = this._f | 0, H = this._g | 0, K = this._h | 0, re = 0; re < 16; ++re)y[re] = p.readInt32BE(re * 4);
        for(; re < 64; ++re)y[re] = l(y[re - 2]) + y[re - 7] + c(y[re - 15]) + y[re - 16] | 0;
        for(var Q = 0; Q < 64; ++Q){
            var G = K + f(U) + s(U, D, H) + n[Q] + y[Q] | 0, R = u(_) + a(_, A, O) | 0;
            K = H, H = D, D = U, U = N + G | 0, N = O, O = A, A = _, _ = G + R | 0;
        }
        this._a = _ + this._a | 0, this._b = A + this._b | 0, this._c = O + this._c | 0, this._d = N + this._d | 0, this._e = U + this._e | 0, this._f = D + this._f | 0, this._g = H + this._g | 0, this._h = K + this._h | 0;
    }, o.prototype._hash = function() {
        var p = r.allocUnsafe(32);
        return p.writeInt32BE(this._a, 0), p.writeInt32BE(this._b, 4), p.writeInt32BE(this._c, 8), p.writeInt32BE(this._d, 12), p.writeInt32BE(this._e, 16), p.writeInt32BE(this._f, 20), p.writeInt32BE(this._g, 24), p.writeInt32BE(this._h, 28), p;
    }, hv = o, hv;
}
var pv, IA;
function yY() {
    if (IA) return pv;
    IA = 1;
    var e = Or(), t = iO(), r = Id(), n = Ar().Buffer, i = new Array(64);
    function o() {
        this.init(), this._w = i, r.call(this, 64, 56);
    }
    return e(o, t), o.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    }, o.prototype._hash = function() {
        var s = n.allocUnsafe(28);
        return s.writeInt32BE(this._a, 0), s.writeInt32BE(this._b, 4), s.writeInt32BE(this._c, 8), s.writeInt32BE(this._d, 12), s.writeInt32BE(this._e, 16), s.writeInt32BE(this._f, 20), s.writeInt32BE(this._g, 24), s;
    }, pv = o, pv;
}
var gv, BA;
function oO() {
    if (BA) return gv;
    BA = 1;
    var e = Or(), t = Id(), r = Ar().Buffer, n = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ], i = new Array(160);
    function o() {
        this.init(), this._w = i, t.call(this, 128, 112);
    }
    e(o, t), o.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function s(A, O, N) {
        return N ^ A & (O ^ N);
    }
    function a(A, O, N) {
        return A & O | N & (A | O);
    }
    function u(A, O) {
        return (A >>> 28 | O << 4) ^ (O >>> 2 | A << 30) ^ (O >>> 7 | A << 25);
    }
    function f(A, O) {
        return (A >>> 14 | O << 18) ^ (A >>> 18 | O << 14) ^ (O >>> 9 | A << 23);
    }
    function c(A, O) {
        return (A >>> 1 | O << 31) ^ (A >>> 8 | O << 24) ^ A >>> 7;
    }
    function l(A, O) {
        return (A >>> 1 | O << 31) ^ (A >>> 8 | O << 24) ^ (A >>> 7 | O << 25);
    }
    function p(A, O) {
        return (A >>> 19 | O << 13) ^ (O >>> 29 | A << 3) ^ A >>> 6;
    }
    function y(A, O) {
        return (A >>> 19 | O << 13) ^ (O >>> 29 | A << 3) ^ (A >>> 6 | O << 26);
    }
    function _(A, O) {
        return A >>> 0 < O >>> 0 ? 1 : 0;
    }
    return o.prototype._update = function(A) {
        for(var O = this._w, N = this._ah | 0, U = this._bh | 0, D = this._ch | 0, H = this._dh | 0, K = this._eh | 0, re = this._fh | 0, Q = this._gh | 0, G = this._hh | 0, R = this._al | 0, X = this._bl | 0, $ = this._cl | 0, S = this._dl | 0, w = this._el | 0, g = this._fl | 0, m = this._gl | 0, E = this._hl | 0, T = 0; T < 32; T += 2)O[T] = A.readInt32BE(T * 4), O[T + 1] = A.readInt32BE(T * 4 + 4);
        for(; T < 160; T += 2){
            var I = O[T - 30], P = O[T - 15 * 2 + 1], k = c(I, P), L = l(P, I);
            I = O[T - 2 * 2], P = O[T - 2 * 2 + 1];
            var j = p(I, P), ie = y(P, I), ue = O[T - 7 * 2], ce = O[T - 7 * 2 + 1], he = O[T - 16 * 2], ee = O[T - 16 * 2 + 1], ae = L + ce | 0, ye = k + ue + _(ae, L) | 0;
            ae = ae + ie | 0, ye = ye + j + _(ae, ie) | 0, ae = ae + ee | 0, ye = ye + he + _(ae, ee) | 0, O[T] = ye, O[T + 1] = ae;
        }
        for(var Se = 0; Se < 160; Se += 2){
            ye = O[Se], ae = O[Se + 1];
            var De = a(N, U, D), Re = a(R, X, $), Ce = u(N, R), M = u(R, N), z = f(K, w), de = f(w, K), _e = n[Se], Ie = n[Se + 1], je = s(K, re, Q), Ke = s(w, g, m), Ue = E + de | 0, h = G + z + _(Ue, E) | 0;
            Ue = Ue + Ke | 0, h = h + je + _(Ue, Ke) | 0, Ue = Ue + Ie | 0, h = h + _e + _(Ue, Ie) | 0, Ue = Ue + ae | 0, h = h + ye + _(Ue, ae) | 0;
            var x = M + Re | 0, q = Ce + De + _(x, M) | 0;
            G = Q, E = m, Q = re, m = g, re = K, g = w, w = S + Ue | 0, K = H + h + _(w, S) | 0, H = D, S = $, D = U, $ = X, U = N, X = R, R = Ue + x | 0, N = h + q + _(R, Ue) | 0;
        }
        this._al = this._al + R | 0, this._bl = this._bl + X | 0, this._cl = this._cl + $ | 0, this._dl = this._dl + S | 0, this._el = this._el + w | 0, this._fl = this._fl + g | 0, this._gl = this._gl + m | 0, this._hl = this._hl + E | 0, this._ah = this._ah + N + _(this._al, R) | 0, this._bh = this._bh + U + _(this._bl, X) | 0, this._ch = this._ch + D + _(this._cl, $) | 0, this._dh = this._dh + H + _(this._dl, S) | 0, this._eh = this._eh + K + _(this._el, w) | 0, this._fh = this._fh + re + _(this._fl, g) | 0, this._gh = this._gh + Q + _(this._gl, m) | 0, this._hh = this._hh + G + _(this._hl, E) | 0;
    }, o.prototype._hash = function() {
        var A = r.allocUnsafe(64);
        function O(N, U, D) {
            A.writeInt32BE(N, D), A.writeInt32BE(U, D + 4);
        }
        return O(this._ah, this._al, 0), O(this._bh, this._bl, 8), O(this._ch, this._cl, 16), O(this._dh, this._dl, 24), O(this._eh, this._el, 32), O(this._fh, this._fl, 40), O(this._gh, this._gl, 48), O(this._hh, this._hl, 56), A;
    }, gv = o, gv;
}
var yv, OA;
function mY() {
    if (OA) return yv;
    OA = 1;
    var e = Or(), t = oO(), r = Id(), n = Ar().Buffer, i = new Array(160);
    function o() {
        this.init(), this._w = i, r.call(this, 128, 112);
    }
    return e(o, t), o.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    }, o.prototype._hash = function() {
        var s = n.allocUnsafe(48);
        function a(u, f, c) {
            s.writeInt32BE(u, c), s.writeInt32BE(f, c + 4);
        }
        return a(this._ah, this._al, 0), a(this._bh, this._bl, 8), a(this._ch, this._cl, 16), a(this._dh, this._dl, 24), a(this._eh, this._el, 32), a(this._fh, this._fl, 40), s;
    }, yv = o, yv;
}
var PA;
function R3() {
    if (PA) return uv.exports;
    PA = 1;
    var e = uv.exports = function(r) {
        r = r.toLowerCase();
        var n = e[r];
        if (!n) throw new Error(r + " is not supported (we accept pull requests)");
        return new n();
    };
    return e.sha = pY(), e.sha1 = gY(), e.sha224 = yY(), e.sha256 = iO(), e.sha384 = mY(), e.sha512 = oO(), uv.exports;
}
var mv = {}, NA;
function bY() {
    if (NA) return mv;
    NA = 1;
    var e = Ar().Buffer, t = e.isEncoding || function(N) {
        switch(N = "" + N, N && N.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function r(N) {
        if (!N) return "utf8";
        for(var U;;)switch(N){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return N;
            default:
                if (U) return;
                N = ("" + N).toLowerCase(), U = !0;
        }
    }
    function n(N) {
        var U = r(N);
        if (typeof U != "string" && (e.isEncoding === t || !t(N))) throw new Error("Unknown encoding: " + N);
        return U || N;
    }
    mv.StringDecoder = i;
    function i(N) {
        this.encoding = n(N);
        var U;
        switch(this.encoding){
            case "utf16le":
                this.text = l, this.end = p, U = 4;
                break;
            case "utf8":
                this.fillLast = u, U = 4;
                break;
            case "base64":
                this.text = y, this.end = _, U = 3;
                break;
            default:
                this.write = A, this.end = O;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(U);
    }
    i.prototype.write = function(N) {
        if (N.length === 0) return "";
        var U, D;
        if (this.lastNeed) {
            if (U = this.fillLast(N), U === void 0) return "";
            D = this.lastNeed, this.lastNeed = 0;
        } else D = 0;
        return D < N.length ? U ? U + this.text(N, D) : this.text(N, D) : U || "";
    }, i.prototype.end = c, i.prototype.text = f, i.prototype.fillLast = function(N) {
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, N.length), this.lastNeed -= N.length;
    };
    function o(N) {
        return N <= 127 ? 0 : N >> 5 === 6 ? 2 : N >> 4 === 14 ? 3 : N >> 3 === 30 ? 4 : N >> 6 === 2 ? -1 : -2;
    }
    function s(N, U, D) {
        var H = U.length - 1;
        if (H < D) return 0;
        var K = o(U[H]);
        return K >= 0 ? (K > 0 && (N.lastNeed = K - 1), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (N.lastNeed = K - 2), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (K === 2 ? K = 0 : N.lastNeed = K - 3), K) : 0));
    }
    function a(N, U, D) {
        if ((U[0] & 192) !== 128) return N.lastNeed = 0, "";
        if (N.lastNeed > 1 && U.length > 1) {
            if ((U[1] & 192) !== 128) return N.lastNeed = 1, "";
            if (N.lastNeed > 2 && U.length > 2 && (U[2] & 192) !== 128) return N.lastNeed = 2, "";
        }
    }
    function u(N) {
        var U = this.lastTotal - this.lastNeed, D = a(this, N);
        if (D !== void 0) return D;
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, U, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, U, 0, N.length), this.lastNeed -= N.length;
    }
    function f(N, U) {
        var D = s(this, N, U);
        if (!this.lastNeed) return N.toString("utf8", U);
        this.lastTotal = D;
        var H = N.length - (D - this.lastNeed);
        return N.copy(this.lastChar, 0, H), N.toString("utf8", U, H);
    }
    function c(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + "" : U;
    }
    function l(N, U) {
        if ((N.length - U) % 2 === 0) {
            var D = N.toString("utf16le", U);
            if (D) {
                var H = D.charCodeAt(D.length - 1);
                if (H >= 55296 && H <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1], D.slice(0, -1);
            }
            return D;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = N[N.length - 1], N.toString("utf16le", U, N.length - 1);
    }
    function p(N) {
        var U = N && N.length ? this.write(N) : "";
        if (this.lastNeed) {
            var D = this.lastTotal - this.lastNeed;
            return U + this.lastChar.toString("utf16le", 0, D);
        }
        return U;
    }
    function y(N, U) {
        var D = (N.length - U) % 3;
        return D === 0 ? N.toString("base64", U) : (this.lastNeed = 3 - D, this.lastTotal = 3, D === 1 ? this.lastChar[0] = N[N.length - 1] : (this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1]), N.toString("base64", U, N.length - D));
    }
    function _(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : U;
    }
    function A(N) {
        return N.toString(this.encoding);
    }
    function O(N) {
        return N && N.length ? this.write(N) : "";
    }
    return mv;
}
var bv, MA;
function Bu() {
    if (MA) return bv;
    MA = 1;
    var e = Ar().Buffer, t = Iu.Transform, r = bY().StringDecoder, n = Or();
    function i(u) {
        t.call(this), this.hashMode = typeof u == "string", this.hashMode ? this[u] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    n(i, t);
    var o = typeof Uint8Array < "u", s = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
    function a(u, f) {
        if (u instanceof e) return u;
        if (typeof u == "string") return e.from(u, f);
        if (s && ArrayBuffer.isView(u)) {
            if (u.byteLength === 0) return e.alloc(0);
            var c = e.from(u.buffer, u.byteOffset, u.byteLength);
            if (c.byteLength === u.byteLength) return c;
        }
        if (o && u instanceof Uint8Array || e.isBuffer(u) && u.constructor && typeof u.constructor.isBuffer == "function" && u.constructor.isBuffer(u)) return e.from(u);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    return i.prototype.update = function(u, f, c) {
        var l = a(u, f), p = this._update(l);
        return this.hashMode ? this : (c && (p = this._toString(p, c)), p);
    }, i.prototype.setAutoPadding = function() {}, i.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
    }, i.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
    }, i.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
    }, i.prototype._transform = function(u, f, c) {
        var l;
        try {
            this.hashMode ? this._update(u) : this.push(this._update(u));
        } catch (p) {
            l = p;
        } finally{
            c(l);
        }
    }, i.prototype._flush = function(u) {
        var f;
        try {
            this.push(this.__final());
        } catch (c) {
            f = c;
        }
        u(f);
    }, i.prototype._finalOrDigest = function(u) {
        var f = this.__final() || e.alloc(0);
        return u && (f = this._toString(f, u, !0)), f;
    }, i.prototype._toString = function(u, f, c) {
        if (this._decoder || (this._decoder = new r(f), this._encoding = f), this._encoding !== f) throw new Error("cant switch encodings");
        var l = this._decoder.write(u);
        return c && (l += this._decoder.end()), l;
    }, bv = i, bv;
}
var wv, RA;
function n0() {
    if (RA) return wv;
    RA = 1;
    var e = Or(), t = N3(), r = M3(), n = R3(), i = Bu();
    function o(s) {
        i.call(this, "digest"), this._hash = s;
    }
    return e(o, i), o.prototype._update = function(s) {
        this._hash.update(s);
    }, o.prototype._final = function() {
        return this._hash.digest();
    }, wv = function(a) {
        return a = a.toLowerCase(), a === "md5" ? new t() : a === "rmd160" || a === "ripemd160" ? new r() : new o(n(a));
    }, wv;
}
var vv, CA;
function wY() {
    if (CA) return vv;
    CA = 1;
    var e = Or(), t = Ar().Buffer, r = Bu(), n = t.alloc(128), i = 64;
    function o(s, a) {
        r.call(this, "digest"), typeof a == "string" && (a = t.from(a)), this._alg = s, this._key = a, a.length > i ? a = s(a) : a.length < i && (a = t.concat([
            a,
            n
        ], i));
        for(var u = this._ipad = t.allocUnsafe(i), f = this._opad = t.allocUnsafe(i), c = 0; c < i; c++)u[c] = a[c] ^ 54, f[c] = a[c] ^ 92;
        this._hash = [
            u
        ];
    }
    return e(o, r), o.prototype._update = function(s) {
        this._hash.push(s);
    }, o.prototype._final = function() {
        var s = this._alg(t.concat(this._hash));
        return this._alg(t.concat([
            this._opad,
            s
        ]));
    }, vv = o, vv;
}
var _v, UA;
function sO() {
    if (UA) return _v;
    UA = 1;
    var e = N3();
    return _v = function(t) {
        return new e().update(t).digest();
    }, _v;
}
var Ev, $A;
function aO() {
    if ($A) return Ev;
    $A = 1;
    var e = Or(), t = wY(), r = Bu(), n = Ar().Buffer, i = sO(), o = M3(), s = R3(), a = n.alloc(128);
    function u(f, c) {
        r.call(this, "digest"), typeof c == "string" && (c = n.from(c));
        var l = f === "sha512" || f === "sha384" ? 128 : 64;
        if (this._alg = f, this._key = c, c.length > l) {
            var p = f === "rmd160" ? new o() : s(f);
            c = p.update(c).digest();
        } else c.length < l && (c = n.concat([
            c,
            a
        ], l));
        for(var y = this._ipad = n.allocUnsafe(l), _ = this._opad = n.allocUnsafe(l), A = 0; A < l; A++)y[A] = c[A] ^ 54, _[A] = c[A] ^ 92;
        this._hash = f === "rmd160" ? new o() : s(f), this._hash.update(y);
    }
    return e(u, r), u.prototype._update = function(f) {
        this._hash.update(f);
    }, u.prototype._final = function() {
        var f = this._hash.digest(), c = this._alg === "rmd160" ? new o() : s(this._alg);
        return c.update(this._opad).update(f).digest();
    }, Ev = function(c, l) {
        return c = c.toLowerCase(), c === "rmd160" || c === "ripemd160" ? new u("rmd160", l) : c === "md5" ? new t(i, l) : new u(c, l);
    }, Ev;
}
const vY = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
}, _Y = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
}, EY = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
}, xY = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
}, SY = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
}, AY = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
}, TY = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
}, kY = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
}, IY = {
    sign: "dsa",
    hash: "sha1",
    id: ""
}, BY = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
}, OY = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
}, cO = {
    sha224WithRSAEncryption: vY,
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption: _Y,
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption: EY,
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption: xY,
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256: SY,
    sha224: AY,
    sha384: TY,
    sha512: kY,
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA: IY,
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA: BY,
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption: OY,
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var xv, LA;
function PY() {
    return LA || (LA = 1, xv = cO), xv;
}
var Ug = {}, Sv, DA;
function uO() {
    if (DA) return Sv;
    DA = 1;
    var e = Math.pow(2, 30) - 1;
    return Sv = function(t, r) {
        if (typeof t != "number") throw new TypeError("Iterations not a number");
        if (t < 0) throw new TypeError("Bad iterations");
        if (typeof r != "number") throw new TypeError("Key length not a number");
        if (r < 0 || r > e || r !== r) throw new TypeError("Bad key length");
    }, Sv;
}
var Av, FA;
function fO() {
    if (FA) return Av;
    FA = 1;
    var e;
    if (Ge.process && Ge.process.browser) e = "utf-8";
    else if (Ge.process && Ge.process.version) {
        var t = parseInt(bn.version.split(".")[0].slice(1), 10);
        e = t >= 6 ? "utf-8" : "binary";
    } else e = "utf-8";
    return Av = e, Av;
}
var Tv, zA;
function lO() {
    if (zA) return Tv;
    zA = 1;
    var e = Ar().Buffer;
    return Tv = function(t, r, n) {
        if (e.isBuffer(t)) return t;
        if (typeof t == "string") return e.from(t, r);
        if (ArrayBuffer.isView(t)) return e.from(t.buffer);
        throw new TypeError(n + " must be a string, a Buffer, a typed array or a DataView");
    }, Tv;
}
var kv, jA;
function dO() {
    if (jA) return kv;
    jA = 1;
    var e = sO(), t = M3(), r = R3(), n = Ar().Buffer, i = uO(), o = fO(), s = lO(), a = n.alloc(128), u = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function f(p, y, _) {
        var A = c(p), O = p === "sha512" || p === "sha384" ? 128 : 64;
        y.length > O ? y = A(y) : y.length < O && (y = n.concat([
            y,
            a
        ], O));
        for(var N = n.allocUnsafe(O + u[p]), U = n.allocUnsafe(O + u[p]), D = 0; D < O; D++)N[D] = y[D] ^ 54, U[D] = y[D] ^ 92;
        var H = n.allocUnsafe(O + _ + 4);
        N.copy(H, 0, 0, O), this.ipad1 = H, this.ipad2 = N, this.opad = U, this.alg = p, this.blocksize = O, this.hash = A, this.size = u[p];
    }
    f.prototype.run = function(p, y) {
        p.copy(y, this.blocksize);
        var _ = this.hash(y);
        return _.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function c(p) {
        function y(A) {
            return r(p).update(A).digest();
        }
        function _(A) {
            return new t().update(A).digest();
        }
        return p === "rmd160" || p === "ripemd160" ? _ : p === "md5" ? e : y;
    }
    function l(p, y, _, A, O) {
        i(_, A), p = s(p, o, "Password"), y = s(y, o, "Salt"), O = O || "sha1";
        var N = new f(O, p, y.length), U = n.allocUnsafe(A), D = n.allocUnsafe(y.length + 4);
        y.copy(D, 0, 0, y.length);
        for(var H = 0, K = u[O], re = Math.ceil(A / K), Q = 1; Q <= re; Q++){
            D.writeUInt32BE(Q, y.length);
            for(var G = N.run(D, N.ipad1), R = G, X = 1; X < _; X++){
                R = N.run(R, N.ipad2);
                for(var $ = 0; $ < K; $++)G[$] ^= R[$];
            }
            G.copy(U, H), H += K;
        }
        return U;
    }
    return kv = l, kv;
}
var Iv, HA;
function NY() {
    if (HA) return Iv;
    HA = 1;
    var e = Ar().Buffer, t = uO(), r = fO(), n = dO(), i = lO(), o, s = Ge.crypto && Ge.crypto.subtle, a = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, u = [];
    function f(_) {
        if (Ge.process && !Ge.process.browser || !s || !s.importKey || !s.deriveBits) return Promise.resolve(!1);
        if (u[_] !== void 0) return u[_];
        o = o || e.alloc(8);
        var A = p(o, o, 10, 128, _).then(function() {
            return !0;
        }).catch(function() {
            return !1;
        });
        return u[_] = A, A;
    }
    var c;
    function l() {
        return c || (Ge.process && Ge.process.nextTick ? c = Ge.process.nextTick : Ge.queueMicrotask ? c = Ge.queueMicrotask : Ge.setImmediate ? c = Ge.setImmediate : c = Ge.setTimeout, c);
    }
    function p(_, A, O, N, U) {
        return s.importKey("raw", _, {
            name: "PBKDF2"
        }, !1, [
            "deriveBits"
        ]).then(function(D) {
            return s.deriveBits({
                name: "PBKDF2",
                salt: A,
                iterations: O,
                hash: {
                    name: U
                }
            }, D, N << 3);
        }).then(function(D) {
            return e.from(D);
        });
    }
    function y(_, A) {
        _.then(function(O) {
            l()(function() {
                A(null, O);
            });
        }, function(O) {
            l()(function() {
                A(O);
            });
        });
    }
    return Iv = function(_, A, O, N, U, D) {
        typeof U == "function" && (D = U, U = void 0), U = U || "sha1";
        var H = a[U.toLowerCase()];
        if (!H || typeof Ge.Promise != "function") {
            l()(function() {
                var K;
                try {
                    K = n(_, A, O, N, U);
                } catch (re) {
                    return D(re);
                }
                D(null, K);
            });
            return;
        }
        if (t(O, N), _ = i(_, r, "Password"), A = i(A, r, "Salt"), typeof D != "function") throw new Error("No callback provided to pbkdf2");
        y(f(H).then(function(K) {
            return K ? p(_, A, O, N, H) : n(_, A, O, N, U);
        }), D);
    }, Iv;
}
var qA;
function hO() {
    return qA || (qA = 1, Ug.pbkdf2 = NY(), Ug.pbkdf2Sync = dO()), Ug;
}
var Zo = {}, Hu = {}, So = {}, KA;
function pO() {
    if (KA) return So;
    KA = 1, So.readUInt32BE = function(i, o) {
        var s = i[0 + o] << 24 | i[1 + o] << 16 | i[2 + o] << 8 | i[3 + o];
        return s >>> 0;
    }, So.writeUInt32BE = function(i, o, s) {
        i[0 + s] = o >>> 24, i[1 + s] = o >>> 16 & 255, i[2 + s] = o >>> 8 & 255, i[3 + s] = o & 255;
    }, So.ip = function(i, o, s, a) {
        for(var u = 0, f = 0, c = 6; c >= 0; c -= 2){
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= o >>> l + c & 1;
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= i >>> l + c & 1;
        }
        for(var c = 6; c >= 0; c -= 2){
            for(var l = 1; l <= 25; l += 8)f <<= 1, f |= o >>> l + c & 1;
            for(var l = 1; l <= 25; l += 8)f <<= 1, f |= i >>> l + c & 1;
        }
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.rip = function(i, o, s, a) {
        for(var u = 0, f = 0, c = 0; c < 4; c++)for(var l = 24; l >= 0; l -= 8)u <<= 1, u |= o >>> l + c & 1, u <<= 1, u |= i >>> l + c & 1;
        for(var c = 4; c < 8; c++)for(var l = 24; l >= 0; l -= 8)f <<= 1, f |= o >>> l + c & 1, f <<= 1, f |= i >>> l + c & 1;
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.pc1 = function(i, o, s, a) {
        for(var u = 0, f = 0, c = 7; c >= 5; c--){
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= o >> l + c & 1;
            for(var l = 0; l <= 24; l += 8)u <<= 1, u |= i >> l + c & 1;
        }
        for(var l = 0; l <= 24; l += 8)u <<= 1, u |= o >> l + c & 1;
        for(var c = 1; c <= 3; c++){
            for(var l = 0; l <= 24; l += 8)f <<= 1, f |= o >> l + c & 1;
            for(var l = 0; l <= 24; l += 8)f <<= 1, f |= i >> l + c & 1;
        }
        for(var l = 0; l <= 24; l += 8)f <<= 1, f |= i >> l + c & 1;
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.r28shl = function(i, o) {
        return i << o & 268435455 | i >>> 28 - o;
    };
    var e = [
        // inL => outL
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        // inR => outR
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
    ];
    So.pc2 = function(i, o, s, a) {
        for(var u = 0, f = 0, c = e.length >>> 1, l = 0; l < c; l++)u <<= 1, u |= i >>> e[l] & 1;
        for(var l = c; l < e.length; l++)f <<= 1, f |= o >>> e[l] & 1;
        s[a + 0] = u >>> 0, s[a + 1] = f >>> 0;
    }, So.expand = function(i, o, s) {
        var a = 0, u = 0;
        a = (i & 1) << 5 | i >>> 27;
        for(var f = 23; f >= 15; f -= 4)a <<= 6, a |= i >>> f & 63;
        for(var f = 11; f >= 3; f -= 4)u |= i >>> f & 63, u <<= 6;
        u |= (i & 31) << 1 | i >>> 31, o[s + 0] = a >>> 0, o[s + 1] = u >>> 0;
    };
    var t = [
        14,
        0,
        4,
        15,
        13,
        7,
        1,
        4,
        2,
        14,
        15,
        2,
        11,
        13,
        8,
        1,
        3,
        10,
        10,
        6,
        6,
        12,
        12,
        11,
        5,
        9,
        9,
        5,
        0,
        3,
        7,
        8,
        4,
        15,
        1,
        12,
        14,
        8,
        8,
        2,
        13,
        4,
        6,
        9,
        2,
        1,
        11,
        7,
        15,
        5,
        12,
        11,
        9,
        3,
        7,
        14,
        3,
        10,
        10,
        0,
        5,
        6,
        0,
        13,
        15,
        3,
        1,
        13,
        8,
        4,
        14,
        7,
        6,
        15,
        11,
        2,
        3,
        8,
        4,
        14,
        9,
        12,
        7,
        0,
        2,
        1,
        13,
        10,
        12,
        6,
        0,
        9,
        5,
        11,
        10,
        5,
        0,
        13,
        14,
        8,
        7,
        10,
        11,
        1,
        10,
        3,
        4,
        15,
        13,
        4,
        1,
        2,
        5,
        11,
        8,
        6,
        12,
        7,
        6,
        12,
        9,
        0,
        3,
        5,
        2,
        14,
        15,
        9,
        10,
        13,
        0,
        7,
        9,
        0,
        14,
        9,
        6,
        3,
        3,
        4,
        15,
        6,
        5,
        10,
        1,
        2,
        13,
        8,
        12,
        5,
        7,
        14,
        11,
        12,
        4,
        11,
        2,
        15,
        8,
        1,
        13,
        1,
        6,
        10,
        4,
        13,
        9,
        0,
        8,
        6,
        15,
        9,
        3,
        8,
        0,
        7,
        11,
        4,
        1,
        15,
        2,
        14,
        12,
        3,
        5,
        11,
        10,
        5,
        14,
        2,
        7,
        12,
        7,
        13,
        13,
        8,
        14,
        11,
        3,
        5,
        0,
        6,
        6,
        15,
        9,
        0,
        10,
        3,
        1,
        4,
        2,
        7,
        8,
        2,
        5,
        12,
        11,
        1,
        12,
        10,
        4,
        14,
        15,
        9,
        10,
        3,
        6,
        15,
        9,
        0,
        0,
        6,
        12,
        10,
        11,
        1,
        7,
        13,
        13,
        8,
        15,
        9,
        1,
        4,
        3,
        5,
        14,
        11,
        5,
        12,
        2,
        7,
        8,
        2,
        4,
        14,
        2,
        14,
        12,
        11,
        4,
        2,
        1,
        12,
        7,
        4,
        10,
        7,
        11,
        13,
        6,
        1,
        8,
        5,
        5,
        0,
        3,
        15,
        15,
        10,
        13,
        3,
        0,
        9,
        14,
        8,
        9,
        6,
        4,
        11,
        2,
        8,
        1,
        12,
        11,
        7,
        10,
        1,
        13,
        14,
        7,
        2,
        8,
        13,
        15,
        6,
        9,
        15,
        12,
        0,
        5,
        9,
        6,
        10,
        3,
        4,
        0,
        5,
        14,
        3,
        12,
        10,
        1,
        15,
        10,
        4,
        15,
        2,
        9,
        7,
        2,
        12,
        6,
        9,
        8,
        5,
        0,
        6,
        13,
        1,
        3,
        13,
        4,
        14,
        14,
        0,
        7,
        11,
        5,
        3,
        11,
        8,
        9,
        4,
        14,
        3,
        15,
        2,
        5,
        12,
        2,
        9,
        8,
        5,
        12,
        15,
        3,
        10,
        7,
        11,
        0,
        14,
        4,
        1,
        10,
        7,
        1,
        6,
        13,
        0,
        11,
        8,
        6,
        13,
        4,
        13,
        11,
        0,
        2,
        11,
        14,
        7,
        15,
        4,
        0,
        9,
        8,
        1,
        13,
        10,
        3,
        14,
        12,
        3,
        9,
        5,
        7,
        12,
        5,
        2,
        10,
        15,
        6,
        8,
        1,
        6,
        1,
        6,
        4,
        11,
        11,
        13,
        13,
        8,
        12,
        1,
        3,
        4,
        7,
        10,
        14,
        7,
        10,
        9,
        15,
        5,
        6,
        0,
        8,
        15,
        0,
        14,
        5,
        2,
        9,
        3,
        2,
        12,
        13,
        1,
        2,
        15,
        8,
        13,
        4,
        8,
        6,
        10,
        15,
        3,
        11,
        7,
        1,
        4,
        10,
        12,
        9,
        5,
        3,
        6,
        14,
        11,
        5,
        0,
        0,
        14,
        12,
        9,
        7,
        2,
        7,
        2,
        11,
        1,
        4,
        14,
        1,
        7,
        9,
        4,
        12,
        10,
        14,
        8,
        2,
        13,
        0,
        15,
        6,
        12,
        10,
        9,
        13,
        0,
        15,
        3,
        3,
        5,
        5,
        6,
        8,
        11
    ];
    So.substitute = function(i, o) {
        for(var s = 0, a = 0; a < 4; a++){
            var u = i >>> 18 - a * 6 & 63, f = t[a * 64 + u];
            s <<= 4, s |= f;
        }
        for(var a = 0; a < 4; a++){
            var u = o >>> 18 - a * 6 & 63, f = t[4 * 64 + a * 64 + u];
            s <<= 4, s |= f;
        }
        return s >>> 0;
    };
    var r = [
        16,
        25,
        12,
        11,
        3,
        20,
        4,
        15,
        31,
        17,
        9,
        6,
        27,
        14,
        1,
        22,
        30,
        24,
        8,
        18,
        0,
        5,
        29,
        23,
        13,
        19,
        2,
        26,
        10,
        21,
        28,
        7
    ];
    return So.permute = function(i) {
        for(var o = 0, s = 0; s < r.length; s++)o <<= 1, o |= i >>> r[s] & 1;
        return o >>> 0;
    }, So.padSplit = function(i, o, s) {
        for(var a = i.toString(2); a.length < o;)a = "0" + a;
        for(var u = [], f = 0; f < o; f += s)u.push(a.slice(f, f + s));
        return u.join(" ");
    }, So;
}
var Bv, WA;
function ys() {
    if (WA) return Bv;
    WA = 1, Bv = e;
    function e(t, r) {
        if (!t) throw new Error(r || "Assertion failed");
    }
    return e.equal = function(r, n, i) {
        if (r != n) throw new Error(i || "Assertion failed: " + r + " != " + n);
    }, Bv;
}
var Ov, VA;
function C3() {
    if (VA) return Ov;
    VA = 1;
    var e = ys();
    function t(r) {
        this.options = r, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = r.padding !== !1;
    }
    return Ov = t, t.prototype._init = function() {}, t.prototype.update = function(n) {
        return n.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(n) : this._updateEncrypt(n);
    }, t.prototype._buffer = function(n, i) {
        for(var o = Math.min(this.buffer.length - this.bufferOff, n.length - i), s = 0; s < o; s++)this.buffer[this.bufferOff + s] = n[i + s];
        return this.bufferOff += o, o;
    }, t.prototype._flushBuffer = function(n, i) {
        return this._update(this.buffer, 0, n, i), this.bufferOff = 0, this.blockSize;
    }, t.prototype._updateEncrypt = function(n) {
        var i = 0, o = 0, s = (this.bufferOff + n.length) / this.blockSize | 0, a = new Array(s * this.blockSize);
        this.bufferOff !== 0 && (i += this._buffer(n, i), this.bufferOff === this.buffer.length && (o += this._flushBuffer(a, o)));
        for(var u = n.length - (n.length - i) % this.blockSize; i < u; i += this.blockSize)this._update(n, i, a, o), o += this.blockSize;
        for(; i < n.length; i++, this.bufferOff++)this.buffer[this.bufferOff] = n[i];
        return a;
    }, t.prototype._updateDecrypt = function(n) {
        for(var i = 0, o = 0, s = Math.ceil((this.bufferOff + n.length) / this.blockSize) - 1, a = new Array(s * this.blockSize); s > 0; s--)i += this._buffer(n, i), o += this._flushBuffer(a, o);
        return i += this._buffer(n, i), a;
    }, t.prototype.final = function(n) {
        var i;
        n && (i = this.update(n));
        var o;
        return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), i ? i.concat(o) : o;
    }, t.prototype._pad = function(n, i) {
        if (i === 0) return !1;
        for(; i < n.length;)n[i++] = 0;
        return !0;
    }, t.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff)) return [];
        var n = new Array(this.blockSize);
        return this._update(this.buffer, 0, n, 0), n;
    }, t.prototype._unpad = function(n) {
        return n;
    }, t.prototype._finalDecrypt = function() {
        e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var n = new Array(this.blockSize);
        return this._flushBuffer(n, 0), this._unpad(n);
    }, Ov;
}
var Pv, GA;
function gO() {
    if (GA) return Pv;
    GA = 1;
    var e = ys(), t = Or(), r = pO(), n = C3();
    function i() {
        this.tmp = new Array(2), this.keys = null;
    }
    function o(a) {
        n.call(this, a);
        var u = new i();
        this._desState = u, this.deriveKeys(u, a.key);
    }
    t(o, n), Pv = o, o.create = function(u) {
        return new o(u);
    };
    var s = [
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1
    ];
    return o.prototype.deriveKeys = function(u, f) {
        u.keys = new Array(16 * 2), e.equal(f.length, this.blockSize, "Invalid key length");
        var c = r.readUInt32BE(f, 0), l = r.readUInt32BE(f, 4);
        r.pc1(c, l, u.tmp, 0), c = u.tmp[0], l = u.tmp[1];
        for(var p = 0; p < u.keys.length; p += 2){
            var y = s[p >>> 1];
            c = r.r28shl(c, y), l = r.r28shl(l, y), r.pc2(c, l, u.keys, p);
        }
    }, o.prototype._update = function(u, f, c, l) {
        var p = this._desState, y = r.readUInt32BE(u, f), _ = r.readUInt32BE(u, f + 4);
        r.ip(y, _, p.tmp, 0), y = p.tmp[0], _ = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, y, _, p.tmp, 0) : this._decrypt(p, y, _, p.tmp, 0), y = p.tmp[0], _ = p.tmp[1], r.writeUInt32BE(c, y, l), r.writeUInt32BE(c, _, l + 4);
    }, o.prototype._pad = function(u, f) {
        if (this.padding === !1) return !1;
        for(var c = u.length - f, l = f; l < u.length; l++)u[l] = c;
        return !0;
    }, o.prototype._unpad = function(u) {
        if (this.padding === !1) return u;
        for(var f = u[u.length - 1], c = u.length - f; c < u.length; c++)e.equal(u[c], f);
        return u.slice(0, u.length - f);
    }, o.prototype._encrypt = function(u, f, c, l, p) {
        for(var y = f, _ = c, A = 0; A < u.keys.length; A += 2){
            var O = u.keys[A], N = u.keys[A + 1];
            r.expand(_, u.tmp, 0), O ^= u.tmp[0], N ^= u.tmp[1];
            var U = r.substitute(O, N), D = r.permute(U), H = _;
            _ = (y ^ D) >>> 0, y = H;
        }
        r.rip(_, y, l, p);
    }, o.prototype._decrypt = function(u, f, c, l, p) {
        for(var y = c, _ = f, A = u.keys.length - 2; A >= 0; A -= 2){
            var O = u.keys[A], N = u.keys[A + 1];
            r.expand(y, u.tmp, 0), O ^= u.tmp[0], N ^= u.tmp[1];
            var U = r.substitute(O, N), D = r.permute(U), H = y;
            y = (_ ^ D) >>> 0, _ = H;
        }
        r.rip(y, _, l, p);
    }, Pv;
}
var Nv = {}, ZA;
function MY() {
    if (ZA) return Nv;
    ZA = 1;
    var e = ys(), t = Or(), r = {};
    function n(o) {
        e.equal(o.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for(var s = 0; s < this.iv.length; s++)this.iv[s] = o[s];
    }
    function i(o) {
        function s(c) {
            o.call(this, c), this._cbcInit();
        }
        t(s, o);
        for(var a = Object.keys(r), u = 0; u < a.length; u++){
            var f = a[u];
            s.prototype[f] = r[f];
        }
        return s.create = function(l) {
            return new s(l);
        }, s;
    }
    return Nv.instantiate = i, r._cbcInit = function() {
        var s = new n(this.options.iv);
        this._cbcState = s;
    }, r._update = function(s, a, u, f) {
        var c = this._cbcState, l = this.constructor.super_.prototype, p = c.iv;
        if (this.type === "encrypt") {
            for(var y = 0; y < this.blockSize; y++)p[y] ^= s[a + y];
            l._update.call(this, p, 0, u, f);
            for(var y = 0; y < this.blockSize; y++)p[y] = u[f + y];
        } else {
            l._update.call(this, s, a, u, f);
            for(var y = 0; y < this.blockSize; y++)u[f + y] ^= p[y];
            for(var y = 0; y < this.blockSize; y++)p[y] = s[a + y];
        }
    }, Nv;
}
var Mv, YA;
function RY() {
    if (YA) return Mv;
    YA = 1;
    var e = ys(), t = Or(), r = C3(), n = gO();
    function i(s, a) {
        e.equal(a.length, 24, "Invalid key length");
        var u = a.slice(0, 8), f = a.slice(8, 16), c = a.slice(16, 24);
        s === "encrypt" ? this.ciphers = [
            n.create({
                type: "encrypt",
                key: u
            }),
            n.create({
                type: "decrypt",
                key: f
            }),
            n.create({
                type: "encrypt",
                key: c
            })
        ] : this.ciphers = [
            n.create({
                type: "decrypt",
                key: c
            }),
            n.create({
                type: "encrypt",
                key: f
            }),
            n.create({
                type: "decrypt",
                key: u
            })
        ];
    }
    function o(s) {
        r.call(this, s);
        var a = new i(this.type, this.options.key);
        this._edeState = a;
    }
    return t(o, r), Mv = o, o.create = function(a) {
        return new o(a);
    }, o.prototype._update = function(a, u, f, c) {
        var l = this._edeState;
        l.ciphers[0]._update(a, u, f, c), l.ciphers[1]._update(f, c, f, c), l.ciphers[2]._update(f, c, f, c);
    }, o.prototype._pad = n.prototype._pad, o.prototype._unpad = n.prototype._unpad, Mv;
}
var XA;
function CY() {
    return XA || (XA = 1, Hu.utils = pO(), Hu.Cipher = C3(), Hu.DES = gO(), Hu.CBC = MY(), Hu.EDE = RY()), Hu;
}
var Rv, JA;
function UY() {
    if (JA) return Rv;
    JA = 1;
    var e = Bu(), t = CY(), r = Or(), n = Ar().Buffer, i = {
        "des-ede3-cbc": t.CBC.instantiate(t.EDE),
        "des-ede3": t.EDE,
        "des-ede-cbc": t.CBC.instantiate(t.EDE),
        "des-ede": t.EDE,
        "des-cbc": t.CBC.instantiate(t.DES),
        "des-ecb": t.DES
    };
    i.des = i["des-cbc"], i.des3 = i["des-ede3-cbc"], Rv = o, r(o, e);
    function o(s) {
        e.call(this);
        var a = s.mode.toLowerCase(), u = i[a], f;
        s.decrypt ? f = "decrypt" : f = "encrypt";
        var c = s.key;
        n.isBuffer(c) || (c = n.from(c)), (a === "des-ede" || a === "des-ede-cbc") && (c = n.concat([
            c,
            c.slice(0, 8)
        ]));
        var l = s.iv;
        n.isBuffer(l) || (l = n.from(l)), this._des = u.create({
            key: c,
            iv: l,
            type: f
        });
    }
    return o.prototype._update = function(s) {
        return n.from(this._des.update(s));
    }, o.prototype._final = function() {
        return n.from(this._des.final());
    }, Rv;
}
var Yo = {}, $g = {}, Lg = {}, QA;
function $Y() {
    return QA || (QA = 1, Lg.encrypt = function(e, t) {
        return e._cipher.encryptBlock(t);
    }, Lg.decrypt = function(e, t) {
        return e._cipher.decryptBlock(t);
    }), Lg;
}
var Dg = {}, Cv, e5;
function i0() {
    return e5 || (e5 = 1, Cv = function(t, r) {
        for(var n = Math.min(t.length, r.length), i = new We(n), o = 0; o < n; ++o)i[o] = t[o] ^ r[o];
        return i;
    }), Cv;
}
var t5;
function LY() {
    if (t5) return Dg;
    t5 = 1;
    var e = i0();
    return Dg.encrypt = function(t, r) {
        var n = e(r, t._prev);
        return t._prev = t._cipher.encryptBlock(n), t._prev;
    }, Dg.decrypt = function(t, r) {
        var n = t._prev;
        t._prev = r;
        var i = t._cipher.decryptBlock(r);
        return e(i, n);
    }, Dg;
}
var Uv = {}, r5;
function DY() {
    if (r5) return Uv;
    r5 = 1;
    var e = Ar().Buffer, t = i0();
    function r(n, i, o) {
        var s = i.length, a = t(i, n._cache);
        return n._cache = n._cache.slice(s), n._prev = e.concat([
            n._prev,
            o ? i : a
        ]), a;
    }
    return Uv.encrypt = function(n, i, o) {
        for(var s = e.allocUnsafe(0), a; i.length;)if (n._cache.length === 0 && (n._cache = n._cipher.encryptBlock(n._prev), n._prev = e.allocUnsafe(0)), n._cache.length <= i.length) a = n._cache.length, s = e.concat([
            s,
            r(n, i.slice(0, a), o)
        ]), i = i.slice(a);
        else {
            s = e.concat([
                s,
                r(n, i, o)
            ]);
            break;
        }
        return s;
    }, Uv;
}
var $v = {}, n5;
function FY() {
    if (n5) return $v;
    n5 = 1;
    var e = Ar().Buffer;
    function t(r, n, i) {
        var o = r._cipher.encryptBlock(r._prev), s = o[0] ^ n;
        return r._prev = e.concat([
            r._prev.slice(1),
            e.from([
                i ? n : s
            ])
        ]), s;
    }
    return $v.encrypt = function(r, n, i) {
        for(var o = n.length, s = e.allocUnsafe(o), a = -1; ++a < o;)s[a] = t(r, n[a], i);
        return s;
    }, $v;
}
var Lv = {}, i5;
function zY() {
    if (i5) return Lv;
    i5 = 1;
    var e = Ar().Buffer;
    function t(n, i, o) {
        for(var s, a = -1, u = 8, f = 0, c, l; ++a < u;)s = n._cipher.encryptBlock(n._prev), c = i & 1 << 7 - a ? 128 : 0, l = s[0] ^ c, f += (l & 128) >> a % 8, n._prev = r(n._prev, o ? c : l);
        return f;
    }
    function r(n, i) {
        var o = n.length, s = -1, a = e.allocUnsafe(n.length);
        for(n = e.concat([
            n,
            e.from([
                i
            ])
        ]); ++s < o;)a[s] = n[s] << 1 | n[s + 1] >> 7;
        return a;
    }
    return Lv.encrypt = function(n, i, o) {
        for(var s = i.length, a = e.allocUnsafe(s), u = -1; ++u < s;)a[u] = t(n, i[u], o);
        return a;
    }, Lv;
}
var Dv = {}, o5;
function jY() {
    if (o5) return Dv;
    o5 = 1;
    var e = i0();
    function t(r) {
        return r._prev = r._cipher.encryptBlock(r._prev), r._prev;
    }
    return Dv.encrypt = function(r, n) {
        for(; r._cache.length < n.length;)r._cache = We.concat([
            r._cache,
            t(r)
        ]);
        var i = r._cache.slice(0, n.length);
        return r._cache = r._cache.slice(n.length), e(n, i);
    }, Dv;
}
var Fv = {}, zv, s5;
function yO() {
    if (s5) return zv;
    s5 = 1;
    function e(t) {
        for(var r = t.length, n; r--;)if (n = t.readUInt8(r), n === 255) t.writeUInt8(0, r);
        else {
            n++, t.writeUInt8(n, r);
            break;
        }
    }
    return zv = e, zv;
}
var a5;
function c5() {
    if (a5) return Fv;
    a5 = 1;
    var e = i0(), t = Ar().Buffer, r = yO();
    function n(o) {
        var s = o._cipher.encryptBlockRaw(o._prev);
        return r(o._prev), s;
    }
    var i = 16;
    return Fv.encrypt = function(o, s) {
        var a = Math.ceil(s.length / i), u = o._cache.length;
        o._cache = t.concat([
            o._cache,
            t.allocUnsafe(a * i)
        ]);
        for(var f = 0; f < a; f++){
            var c = n(o), l = u + f * i;
            o._cache.writeUInt32BE(c[0], l + 0), o._cache.writeUInt32BE(c[1], l + 4), o._cache.writeUInt32BE(c[2], l + 8), o._cache.writeUInt32BE(c[3], l + 12);
        }
        var p = o._cache.slice(0, s.length);
        return o._cache = o._cache.slice(s.length), e(s, p);
    }, Fv;
}
const HY = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
}, qY = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
}, KY = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
}, mO = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128: HY,
    aes192: qY,
    aes256: KY,
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
};
var jv, u5;
function U3() {
    if (u5) return jv;
    u5 = 1;
    var e = {
        ECB: $Y(),
        CBC: LY(),
        CFB: DY(),
        CFB8: FY(),
        CFB1: zY(),
        OFB: jY(),
        CTR: c5(),
        GCM: c5()
    }, t = mO;
    for(var r in t)t[r].module = e[t[r].mode];
    return jv = t, jv;
}
var Hv = {}, f5;
function Eb() {
    if (f5) return Hv;
    f5 = 1;
    var e = Ar().Buffer;
    function t(a) {
        e.isBuffer(a) || (a = e.from(a));
        for(var u = a.length / 4 | 0, f = new Array(u), c = 0; c < u; c++)f[c] = a.readUInt32BE(c * 4);
        return f;
    }
    function r(a) {
        for(var u = 0; u < a.length; a++)a[u] = 0;
    }
    function n(a, u, f, c, l) {
        for(var p = f[0], y = f[1], _ = f[2], A = f[3], O = a[0] ^ u[0], N = a[1] ^ u[1], U = a[2] ^ u[2], D = a[3] ^ u[3], H, K, re, Q, G = 4, R = 1; R < l; R++)H = p[O >>> 24] ^ y[N >>> 16 & 255] ^ _[U >>> 8 & 255] ^ A[D & 255] ^ u[G++], K = p[N >>> 24] ^ y[U >>> 16 & 255] ^ _[D >>> 8 & 255] ^ A[O & 255] ^ u[G++], re = p[U >>> 24] ^ y[D >>> 16 & 255] ^ _[O >>> 8 & 255] ^ A[N & 255] ^ u[G++], Q = p[D >>> 24] ^ y[O >>> 16 & 255] ^ _[N >>> 8 & 255] ^ A[U & 255] ^ u[G++], O = H, N = K, U = re, D = Q;
        return H = (c[O >>> 24] << 24 | c[N >>> 16 & 255] << 16 | c[U >>> 8 & 255] << 8 | c[D & 255]) ^ u[G++], K = (c[N >>> 24] << 24 | c[U >>> 16 & 255] << 16 | c[D >>> 8 & 255] << 8 | c[O & 255]) ^ u[G++], re = (c[U >>> 24] << 24 | c[D >>> 16 & 255] << 16 | c[O >>> 8 & 255] << 8 | c[N & 255]) ^ u[G++], Q = (c[D >>> 24] << 24 | c[O >>> 16 & 255] << 16 | c[N >>> 8 & 255] << 8 | c[U & 255]) ^ u[G++], H = H >>> 0, K = K >>> 0, re = re >>> 0, Q = Q >>> 0, [
            H,
            K,
            re,
            Q
        ];
    }
    var i = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], o = function() {
        for(var a = new Array(256), u = 0; u < 256; u++)u < 128 ? a[u] = u << 1 : a[u] = u << 1 ^ 283;
        for(var f = [], c = [], l = [
            [],
            [],
            [],
            []
        ], p = [
            [],
            [],
            [],
            []
        ], y = 0, _ = 0, A = 0; A < 256; ++A){
            var O = _ ^ _ << 1 ^ _ << 2 ^ _ << 3 ^ _ << 4;
            O = O >>> 8 ^ O & 255 ^ 99, f[y] = O, c[O] = y;
            var N = a[y], U = a[N], D = a[U], H = a[O] * 257 ^ O * 16843008;
            l[0][y] = H << 24 | H >>> 8, l[1][y] = H << 16 | H >>> 16, l[2][y] = H << 8 | H >>> 24, l[3][y] = H, H = D * 16843009 ^ U * 65537 ^ N * 257 ^ y * 16843008, p[0][O] = H << 24 | H >>> 8, p[1][O] = H << 16 | H >>> 16, p[2][O] = H << 8 | H >>> 24, p[3][O] = H, y === 0 ? y = _ = 1 : (y = N ^ a[a[a[D ^ N]]], _ ^= a[a[_]]);
        }
        return {
            SBOX: f,
            INV_SBOX: c,
            SUB_MIX: l,
            INV_SUB_MIX: p
        };
    }();
    function s(a) {
        this._key = t(a), this._reset();
    }
    return s.blockSize = 4 * 4, s.keySize = 256 / 8, s.prototype.blockSize = s.blockSize, s.prototype.keySize = s.keySize, s.prototype._reset = function() {
        for(var a = this._key, u = a.length, f = u + 6, c = (f + 1) * 4, l = [], p = 0; p < u; p++)l[p] = a[p];
        for(p = u; p < c; p++){
            var y = l[p - 1];
            p % u === 0 ? (y = y << 8 | y >>> 24, y = o.SBOX[y >>> 24] << 24 | o.SBOX[y >>> 16 & 255] << 16 | o.SBOX[y >>> 8 & 255] << 8 | o.SBOX[y & 255], y ^= i[p / u | 0] << 24) : u > 6 && p % u === 4 && (y = o.SBOX[y >>> 24] << 24 | o.SBOX[y >>> 16 & 255] << 16 | o.SBOX[y >>> 8 & 255] << 8 | o.SBOX[y & 255]), l[p] = l[p - u] ^ y;
        }
        for(var _ = [], A = 0; A < c; A++){
            var O = c - A, N = l[O - (A % 4 ? 0 : 4)];
            A < 4 || O <= 4 ? _[A] = N : _[A] = o.INV_SUB_MIX[0][o.SBOX[N >>> 24]] ^ o.INV_SUB_MIX[1][o.SBOX[N >>> 16 & 255]] ^ o.INV_SUB_MIX[2][o.SBOX[N >>> 8 & 255]] ^ o.INV_SUB_MIX[3][o.SBOX[N & 255]];
        }
        this._nRounds = f, this._keySchedule = l, this._invKeySchedule = _;
    }, s.prototype.encryptBlockRaw = function(a) {
        return a = t(a), n(a, this._keySchedule, o.SUB_MIX, o.SBOX, this._nRounds);
    }, s.prototype.encryptBlock = function(a) {
        var u = this.encryptBlockRaw(a), f = e.allocUnsafe(16);
        return f.writeUInt32BE(u[0], 0), f.writeUInt32BE(u[1], 4), f.writeUInt32BE(u[2], 8), f.writeUInt32BE(u[3], 12), f;
    }, s.prototype.decryptBlock = function(a) {
        a = t(a);
        var u = a[1];
        a[1] = a[3], a[3] = u;
        var f = n(a, this._invKeySchedule, o.INV_SUB_MIX, o.INV_SBOX, this._nRounds), c = e.allocUnsafe(16);
        return c.writeUInt32BE(f[0], 0), c.writeUInt32BE(f[3], 4), c.writeUInt32BE(f[2], 8), c.writeUInt32BE(f[1], 12), c;
    }, s.prototype.scrub = function() {
        r(this._keySchedule), r(this._invKeySchedule), r(this._key);
    }, Hv.AES = s, Hv;
}
var qv, l5;
function WY() {
    if (l5) return qv;
    l5 = 1;
    var e = Ar().Buffer, t = e.alloc(16, 0);
    function r(o) {
        return [
            o.readUInt32BE(0),
            o.readUInt32BE(4),
            o.readUInt32BE(8),
            o.readUInt32BE(12)
        ];
    }
    function n(o) {
        var s = e.allocUnsafe(16);
        return s.writeUInt32BE(o[0] >>> 0, 0), s.writeUInt32BE(o[1] >>> 0, 4), s.writeUInt32BE(o[2] >>> 0, 8), s.writeUInt32BE(o[3] >>> 0, 12), s;
    }
    function i(o) {
        this.h = o, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
    }
    return i.prototype.ghash = function(o) {
        for(var s = -1; ++s < o.length;)this.state[s] ^= o[s];
        this._multiply();
    }, i.prototype._multiply = function() {
        for(var o = r(this.h), s = [
            0,
            0,
            0,
            0
        ], a, u, f, c = -1; ++c < 128;){
            for(u = (this.state[~~(c / 8)] & 1 << 7 - c % 8) !== 0, u && (s[0] ^= o[0], s[1] ^= o[1], s[2] ^= o[2], s[3] ^= o[3]), f = (o[3] & 1) !== 0, a = 3; a > 0; a--)o[a] = o[a] >>> 1 | (o[a - 1] & 1) << 31;
            o[0] = o[0] >>> 1, f && (o[0] = o[0] ^ 225 << 24);
        }
        this.state = n(s);
    }, i.prototype.update = function(o) {
        this.cache = e.concat([
            this.cache,
            o
        ]);
        for(var s; this.cache.length >= 16;)s = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(s);
    }, i.prototype.final = function(o, s) {
        return this.cache.length && this.ghash(e.concat([
            this.cache,
            t
        ], 16)), this.ghash(n([
            0,
            o,
            0,
            s
        ])), this.state;
    }, qv = i, qv;
}
var Kv, d5;
function bO() {
    if (d5) return Kv;
    d5 = 1;
    var e = Eb(), t = Ar().Buffer, r = Bu(), n = Or(), i = WY(), o = i0(), s = yO();
    function a(c, l) {
        var p = 0;
        c.length !== l.length && p++;
        for(var y = Math.min(c.length, l.length), _ = 0; _ < y; ++_)p += c[_] ^ l[_];
        return p;
    }
    function u(c, l, p) {
        if (l.length === 12) return c._finID = t.concat([
            l,
            t.from([
                0,
                0,
                0,
                1
            ])
        ]), t.concat([
            l,
            t.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var y = new i(p), _ = l.length, A = _ % 16;
        y.update(l), A && (A = 16 - A, y.update(t.alloc(A, 0))), y.update(t.alloc(8, 0));
        var O = _ * 8, N = t.alloc(8);
        N.writeUIntBE(O, 0, 8), y.update(N), c._finID = y.state;
        var U = t.from(c._finID);
        return s(U), U;
    }
    function f(c, l, p, y) {
        r.call(this);
        var _ = t.alloc(4, 0);
        this._cipher = new e.AES(l);
        var A = this._cipher.encryptBlock(_);
        this._ghash = new i(A), p = u(this, p, A), this._prev = t.from(p), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = y, this._alen = 0, this._len = 0, this._mode = c, this._authTag = null, this._called = !1;
    }
    return n(f, r), f.prototype._update = function(c) {
        if (!this._called && this._alen) {
            var l = 16 - this._alen % 16;
            l < 16 && (l = t.alloc(l, 0), this._ghash.update(l));
        }
        this._called = !0;
        var p = this._mode.encrypt(this, c);
        return this._decrypt ? this._ghash.update(c) : this._ghash.update(p), this._len += c.length, p;
    }, f.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var c = o(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && a(c, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = c, this._cipher.scrub();
    }, f.prototype.getAuthTag = function() {
        if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    }, f.prototype.setAuthTag = function(l) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = l;
    }, f.prototype.setAAD = function(l) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(l), this._alen += l.length;
    }, Kv = f, Kv;
}
var Wv, h5;
function wO() {
    if (h5) return Wv;
    h5 = 1;
    var e = Eb(), t = Ar().Buffer, r = Bu(), n = Or();
    function i(o, s, a, u) {
        r.call(this), this._cipher = new e.AES(s), this._prev = t.from(a), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = u, this._mode = o;
    }
    return n(i, r), i.prototype._update = function(o) {
        return this._mode.encrypt(this, o, this._decrypt);
    }, i.prototype._final = function() {
        this._cipher.scrub();
    }, Wv = i, Wv;
}
var Vv, p5;
function xb() {
    if (p5) return Vv;
    p5 = 1;
    var e = Ar().Buffer, t = N3();
    function r(n, i, o, s) {
        if (e.isBuffer(n) || (n = e.from(n, "binary")), i && (e.isBuffer(i) || (i = e.from(i, "binary")), i.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
        for(var a = o / 8, u = e.alloc(a), f = e.alloc(s || 0), c = e.alloc(0); a > 0 || s > 0;){
            var l = new t();
            l.update(c), l.update(n), i && l.update(i), c = l.digest();
            var p = 0;
            if (a > 0) {
                var y = u.length - a;
                p = Math.min(a, c.length), c.copy(u, y, 0, p), a -= p;
            }
            if (p < c.length && s > 0) {
                var _ = f.length - s, A = Math.min(s, c.length - p);
                c.copy(f, _, p, p + A), s -= A;
            }
        }
        return c.fill(0), {
            key: u,
            iv: f
        };
    }
    return Vv = r, Vv;
}
var g5;
function VY() {
    if (g5) return $g;
    g5 = 1;
    var e = U3(), t = bO(), r = Ar().Buffer, n = wO(), i = Bu(), o = Eb(), s = xb(), a = Or();
    function u(y, _, A) {
        i.call(this), this._cache = new c(), this._cipher = new o.AES(_), this._prev = r.from(A), this._mode = y, this._autopadding = !0;
    }
    a(u, i), u.prototype._update = function(y) {
        this._cache.add(y);
        for(var _, A, O = []; _ = this._cache.get();)A = this._mode.encrypt(this, _), O.push(A);
        return r.concat(O);
    };
    var f = r.alloc(16, 16);
    u.prototype._final = function() {
        var y = this._cache.flush();
        if (this._autopadding) return y = this._mode.encrypt(this, y), this._cipher.scrub(), y;
        if (!y.equals(f)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    }, u.prototype.setAutoPadding = function(y) {
        return this._autopadding = !!y, this;
    };
    function c() {
        this.cache = r.allocUnsafe(0);
    }
    c.prototype.add = function(y) {
        this.cache = r.concat([
            this.cache,
            y
        ]);
    }, c.prototype.get = function() {
        if (this.cache.length > 15) {
            var y = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), y;
        }
        return null;
    }, c.prototype.flush = function() {
        for(var y = 16 - this.cache.length, _ = r.allocUnsafe(y), A = -1; ++A < y;)_.writeUInt8(y, A);
        return r.concat([
            this.cache,
            _
        ]);
    };
    function l(y, _, A) {
        var O = e[y.toLowerCase()];
        if (!O) throw new TypeError("invalid suite type");
        if (typeof _ == "string" && (_ = r.from(_)), _.length !== O.key / 8) throw new TypeError("invalid key length " + _.length);
        if (typeof A == "string" && (A = r.from(A)), O.mode !== "GCM" && A.length !== O.iv) throw new TypeError("invalid iv length " + A.length);
        return O.type === "stream" ? new n(O.module, _, A) : O.type === "auth" ? new t(O.module, _, A) : new u(O.module, _, A);
    }
    function p(y, _) {
        var A = e[y.toLowerCase()];
        if (!A) throw new TypeError("invalid suite type");
        var O = s(_, !1, A.key, A.iv);
        return l(y, O.key, O.iv);
    }
    return $g.createCipheriv = l, $g.createCipher = p, $g;
}
var Fg = {}, y5;
function GY() {
    if (y5) return Fg;
    y5 = 1;
    var e = bO(), t = Ar().Buffer, r = U3(), n = wO(), i = Bu(), o = Eb(), s = xb(), a = Or();
    function u(y, _, A) {
        i.call(this), this._cache = new f(), this._last = void 0, this._cipher = new o.AES(_), this._prev = t.from(A), this._mode = y, this._autopadding = !0;
    }
    a(u, i), u.prototype._update = function(y) {
        this._cache.add(y);
        for(var _, A, O = []; _ = this._cache.get(this._autopadding);)A = this._mode.decrypt(this, _), O.push(A);
        return t.concat(O);
    }, u.prototype._final = function() {
        var y = this._cache.flush();
        if (this._autopadding) return c(this._mode.decrypt(this, y));
        if (y) throw new Error("data not multiple of block length");
    }, u.prototype.setAutoPadding = function(y) {
        return this._autopadding = !!y, this;
    };
    function f() {
        this.cache = t.allocUnsafe(0);
    }
    f.prototype.add = function(y) {
        this.cache = t.concat([
            this.cache,
            y
        ]);
    }, f.prototype.get = function(y) {
        var _;
        if (y) {
            if (this.cache.length > 16) return _ = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _;
        } else if (this.cache.length >= 16) return _ = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _;
        return null;
    }, f.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function c(y) {
        var _ = y[15];
        if (_ < 1 || _ > 16) throw new Error("unable to decrypt data");
        for(var A = -1; ++A < _;)if (y[A + (16 - _)] !== _) throw new Error("unable to decrypt data");
        if (_ !== 16) return y.slice(0, 16 - _);
    }
    function l(y, _, A) {
        var O = r[y.toLowerCase()];
        if (!O) throw new TypeError("invalid suite type");
        if (typeof A == "string" && (A = t.from(A)), O.mode !== "GCM" && A.length !== O.iv) throw new TypeError("invalid iv length " + A.length);
        if (typeof _ == "string" && (_ = t.from(_)), _.length !== O.key / 8) throw new TypeError("invalid key length " + _.length);
        return O.type === "stream" ? new n(O.module, _, A, !0) : O.type === "auth" ? new e(O.module, _, A, !0) : new u(O.module, _, A);
    }
    function p(y, _) {
        var A = r[y.toLowerCase()];
        if (!A) throw new TypeError("invalid suite type");
        var O = s(_, !1, A.key, A.iv);
        return l(y, O.key, O.iv);
    }
    return Fg.createDecipher = p, Fg.createDecipheriv = l, Fg;
}
var m5;
function $3() {
    if (m5) return Yo;
    m5 = 1;
    var e = VY(), t = GY(), r = mO;
    function n() {
        return Object.keys(r);
    }
    return Yo.createCipher = Yo.Cipher = e.createCipher, Yo.createCipheriv = Yo.Cipheriv = e.createCipheriv, Yo.createDecipher = Yo.Decipher = t.createDecipher, Yo.createDecipheriv = Yo.Decipheriv = t.createDecipheriv, Yo.listCiphers = Yo.getCiphers = n, Yo;
}
var Gv = {}, b5;
function ZY() {
    return b5 || (b5 = 1, function(e) {
        e["des-ecb"] = {
            key: 8,
            iv: 0
        }, e["des-cbc"] = e.des = {
            key: 8,
            iv: 8
        }, e["des-ede3-cbc"] = e.des3 = {
            key: 24,
            iv: 8
        }, e["des-ede3"] = {
            key: 24,
            iv: 0
        }, e["des-ede-cbc"] = {
            key: 16,
            iv: 8
        }, e["des-ede"] = {
            key: 16,
            iv: 0
        };
    }(Gv)), Gv;
}
var w5;
function YY() {
    if (w5) return Zo;
    w5 = 1;
    var e = UY(), t = $3(), r = U3(), n = ZY(), i = xb();
    function o(c, l) {
        c = c.toLowerCase();
        var p, y;
        if (r[c]) p = r[c].key, y = r[c].iv;
        else if (n[c]) p = n[c].key * 8, y = n[c].iv;
        else throw new TypeError("invalid suite type");
        var _ = i(l, !1, p, y);
        return a(c, _.key, _.iv);
    }
    function s(c, l) {
        c = c.toLowerCase();
        var p, y;
        if (r[c]) p = r[c].key, y = r[c].iv;
        else if (n[c]) p = n[c].key * 8, y = n[c].iv;
        else throw new TypeError("invalid suite type");
        var _ = i(l, !1, p, y);
        return u(c, _.key, _.iv);
    }
    function a(c, l, p) {
        if (c = c.toLowerCase(), r[c]) return t.createCipheriv(c, l, p);
        if (n[c]) return new e({
            key: l,
            iv: p,
            mode: c
        });
        throw new TypeError("invalid suite type");
    }
    function u(c, l, p) {
        if (c = c.toLowerCase(), r[c]) return t.createDecipheriv(c, l, p);
        if (n[c]) return new e({
            key: l,
            iv: p,
            mode: c,
            decrypt: !0
        });
        throw new TypeError("invalid suite type");
    }
    function f() {
        return Object.keys(n).concat(t.getCiphers());
    }
    return Zo.createCipher = Zo.Cipher = o, Zo.createCipheriv = Zo.Cipheriv = a, Zo.createDecipher = Zo.Decipher = s, Zo.createDecipheriv = Zo.Decipheriv = u, Zo.listCiphers = Zo.getCiphers = f, Zo;
}
var qu = {}, ky = {
    exports: {}
};
ky.exports;
var v5;
function bi() {
    return v5 || (v5 = 1, function(e) {
        (function(t, r) {
            function n($, S) {
                if (!$) throw new Error(S || "Assertion failed");
            }
            function i($, S) {
                $.super_ = S;
                var w = function() {};
                w.prototype = S.prototype, $.prototype = new w(), $.prototype.constructor = $;
            }
            function o($, S, w) {
                if (o.isBN($)) return $;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, $ !== null && ((S === "le" || S === "be") && (w = S, S = 10), this._init($ || 0, S || 10, w || "be"));
            }
            typeof t == "object" ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
            var s;
            try {
                ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = Iu.Buffer;
            } catch  {}
            o.isBN = function(S) {
                return S instanceof o ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === o.wordSize && Array.isArray(S.words);
            }, o.max = function(S, w) {
                return S.cmp(w) > 0 ? S : w;
            }, o.min = function(S, w) {
                return S.cmp(w) < 0 ? S : w;
            }, o.prototype._init = function(S, w, g) {
                if (typeof S == "number") return this._initNumber(S, w, g);
                if (typeof S == "object") return this._initArray(S, w, g);
                w === "hex" && (w = 16), n(w === (w | 0) && w >= 2 && w <= 36), S = S.toString().replace(/\s+/g, "");
                var m = 0;
                S[0] === "-" && (m++, this.negative = 1), m < S.length && (w === 16 ? this._parseHex(S, m, g) : (this._parseBase(S, w, m), g === "le" && this._initArray(this.toArray(), w, g)));
            }, o.prototype._initNumber = function(S, w, g) {
                S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [
                    S & 67108863
                ], this.length = 1) : S < 4503599627370496 ? (this.words = [
                    S & 67108863,
                    S / 67108864 & 67108863
                ], this.length = 2) : (n(S < 9007199254740992), this.words = [
                    S & 67108863,
                    S / 67108864 & 67108863,
                    1
                ], this.length = 3), g === "le" && this._initArray(this.toArray(), w, g);
            }, o.prototype._initArray = function(S, w, g) {
                if (n(typeof S.length == "number"), S.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
                for(var m = 0; m < this.length; m++)this.words[m] = 0;
                var E, T, I = 0;
                if (g === "be") for(m = S.length - 1, E = 0; m >= 0; m -= 3)T = S[m] | S[m - 1] << 8 | S[m - 2] << 16, this.words[E] |= T << I & 67108863, this.words[E + 1] = T >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, E++);
                else if (g === "le") for(m = 0, E = 0; m < S.length; m += 3)T = S[m] | S[m + 1] << 8 | S[m + 2] << 16, this.words[E] |= T << I & 67108863, this.words[E + 1] = T >>> 26 - I & 67108863, I += 24, I >= 26 && (I -= 26, E++);
                return this.strip();
            };
            function a($, S) {
                var w = $.charCodeAt(S);
                return w >= 65 && w <= 70 ? w - 55 : w >= 97 && w <= 102 ? w - 87 : w - 48 & 15;
            }
            function u($, S, w) {
                var g = a($, w);
                return w - 1 >= S && (g |= a($, w - 1) << 4), g;
            }
            o.prototype._parseHex = function(S, w, g) {
                this.length = Math.ceil((S.length - w) / 6), this.words = new Array(this.length);
                for(var m = 0; m < this.length; m++)this.words[m] = 0;
                var E = 0, T = 0, I;
                if (g === "be") for(m = S.length - 1; m >= w; m -= 2)I = u(S, w, m) << E, this.words[T] |= I & 67108863, E >= 18 ? (E -= 18, T += 1, this.words[T] |= I >>> 26) : E += 8;
                else {
                    var P = S.length - w;
                    for(m = P % 2 === 0 ? w + 1 : w; m < S.length; m += 2)I = u(S, w, m) << E, this.words[T] |= I & 67108863, E >= 18 ? (E -= 18, T += 1, this.words[T] |= I >>> 26) : E += 8;
                }
                this.strip();
            };
            function f($, S, w, g) {
                for(var m = 0, E = Math.min($.length, w), T = S; T < E; T++){
                    var I = $.charCodeAt(T) - 48;
                    m *= g, I >= 49 ? m += I - 49 + 10 : I >= 17 ? m += I - 17 + 10 : m += I;
                }
                return m;
            }
            o.prototype._parseBase = function(S, w, g) {
                this.words = [
                    0
                ], this.length = 1;
                for(var m = 0, E = 1; E <= 67108863; E *= w)m++;
                m--, E = E / w | 0;
                for(var T = S.length - g, I = T % m, P = Math.min(T, T - I) + g, k = 0, L = g; L < P; L += m)k = f(S, L, L + m, w), this.imuln(E), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
                if (I !== 0) {
                    var j = 1;
                    for(k = f(S, L, S.length, w), L = 0; L < I; L++)j *= w;
                    this.imuln(j), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
                }
                this.strip();
            }, o.prototype.copy = function(S) {
                S.words = new Array(this.length);
                for(var w = 0; w < this.length; w++)S.words[w] = this.words[w];
                S.length = this.length, S.negative = this.negative, S.red = this.red;
            }, o.prototype.clone = function() {
                var S = new o(null);
                return this.copy(S), S;
            }, o.prototype._expand = function(S) {
                for(; this.length < S;)this.words[this.length++] = 0;
                return this;
            }, o.prototype.strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, o.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, o.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var c = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], l = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], p = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            o.prototype.toString = function(S, w) {
                S = S || 10, w = w | 0 || 1;
                var g;
                if (S === 16 || S === "hex") {
                    g = "";
                    for(var m = 0, E = 0, T = 0; T < this.length; T++){
                        var I = this.words[T], P = ((I << m | E) & 16777215).toString(16);
                        E = I >>> 24 - m & 16777215, m += 2, m >= 26 && (m -= 26, T--), E !== 0 || T !== this.length - 1 ? g = c[6 - P.length] + P + g : g = P + g;
                    }
                    for(E !== 0 && (g = E.toString(16) + g); g.length % w !== 0;)g = "0" + g;
                    return this.negative !== 0 && (g = "-" + g), g;
                }
                if (S === (S | 0) && S >= 2 && S <= 36) {
                    var k = l[S], L = p[S];
                    g = "";
                    var j = this.clone();
                    for(j.negative = 0; !j.isZero();){
                        var ie = j.modn(L).toString(S);
                        j = j.idivn(L), j.isZero() ? g = ie + g : g = c[k - ie.length] + ie + g;
                    }
                    for(this.isZero() && (g = "0" + g); g.length % w !== 0;)g = "0" + g;
                    return this.negative !== 0 && (g = "-" + g), g;
                }
                n(!1, "Base should be between 2 and 36");
            }, o.prototype.toNumber = function() {
                var S = this.words[0];
                return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
            }, o.prototype.toJSON = function() {
                return this.toString(16);
            }, o.prototype.toBuffer = function(S, w) {
                return n(typeof s < "u"), this.toArrayLike(s, S, w);
            }, o.prototype.toArray = function(S, w) {
                return this.toArrayLike(Array, S, w);
            }, o.prototype.toArrayLike = function(S, w, g) {
                var m = this.byteLength(), E = g || Math.max(1, m);
                n(m <= E, "byte array longer than desired length"), n(E > 0, "Requested array length <= 0"), this.strip();
                var T = w === "le", I = new S(E), P, k, L = this.clone();
                if (T) {
                    for(k = 0; !L.isZero(); k++)P = L.andln(255), L.iushrn(8), I[k] = P;
                    for(; k < E; k++)I[k] = 0;
                } else {
                    for(k = 0; k < E - m; k++)I[k] = 0;
                    for(k = 0; !L.isZero(); k++)P = L.andln(255), L.iushrn(8), I[E - k - 1] = P;
                }
                return I;
            }, Math.clz32 ? o.prototype._countBits = function(S) {
                return 32 - Math.clz32(S);
            } : o.prototype._countBits = function(S) {
                var w = S, g = 0;
                return w >= 4096 && (g += 13, w >>>= 13), w >= 64 && (g += 7, w >>>= 7), w >= 8 && (g += 4, w >>>= 4), w >= 2 && (g += 2, w >>>= 2), g + w;
            }, o.prototype._zeroBits = function(S) {
                if (S === 0) return 26;
                var w = S, g = 0;
                return w & 8191 || (g += 13, w >>>= 13), w & 127 || (g += 7, w >>>= 7), w & 15 || (g += 4, w >>>= 4), w & 3 || (g += 2, w >>>= 2), w & 1 || g++, g;
            }, o.prototype.bitLength = function() {
                var S = this.words[this.length - 1], w = this._countBits(S);
                return (this.length - 1) * 26 + w;
            };
            function y($) {
                for(var S = new Array($.bitLength()), w = 0; w < S.length; w++){
                    var g = w / 26 | 0, m = w % 26;
                    S[w] = ($.words[g] & 1 << m) >>> m;
                }
                return S;
            }
            o.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var S = 0, w = 0; w < this.length; w++){
                    var g = this._zeroBits(this.words[w]);
                    if (S += g, g !== 26) break;
                }
                return S;
            }, o.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, o.prototype.toTwos = function(S) {
                return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
            }, o.prototype.fromTwos = function(S) {
                return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
            }, o.prototype.isNeg = function() {
                return this.negative !== 0;
            }, o.prototype.neg = function() {
                return this.clone().ineg();
            }, o.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, o.prototype.iuor = function(S) {
                for(; this.length < S.length;)this.words[this.length++] = 0;
                for(var w = 0; w < S.length; w++)this.words[w] = this.words[w] | S.words[w];
                return this.strip();
            }, o.prototype.ior = function(S) {
                return n((this.negative | S.negative) === 0), this.iuor(S);
            }, o.prototype.or = function(S) {
                return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
            }, o.prototype.uor = function(S) {
                return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
            }, o.prototype.iuand = function(S) {
                var w;
                this.length > S.length ? w = S : w = this;
                for(var g = 0; g < w.length; g++)this.words[g] = this.words[g] & S.words[g];
                return this.length = w.length, this.strip();
            }, o.prototype.iand = function(S) {
                return n((this.negative | S.negative) === 0), this.iuand(S);
            }, o.prototype.and = function(S) {
                return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
            }, o.prototype.uand = function(S) {
                return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
            }, o.prototype.iuxor = function(S) {
                var w, g;
                this.length > S.length ? (w = this, g = S) : (w = S, g = this);
                for(var m = 0; m < g.length; m++)this.words[m] = w.words[m] ^ g.words[m];
                if (this !== w) for(; m < w.length; m++)this.words[m] = w.words[m];
                return this.length = w.length, this.strip();
            }, o.prototype.ixor = function(S) {
                return n((this.negative | S.negative) === 0), this.iuxor(S);
            }, o.prototype.xor = function(S) {
                return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
            }, o.prototype.uxor = function(S) {
                return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
            }, o.prototype.inotn = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = Math.ceil(S / 26) | 0, g = S % 26;
                this._expand(w), g > 0 && w--;
                for(var m = 0; m < w; m++)this.words[m] = ~this.words[m] & 67108863;
                return g > 0 && (this.words[m] = ~this.words[m] & 67108863 >> 26 - g), this.strip();
            }, o.prototype.notn = function(S) {
                return this.clone().inotn(S);
            }, o.prototype.setn = function(S, w) {
                n(typeof S == "number" && S >= 0);
                var g = S / 26 | 0, m = S % 26;
                return this._expand(g + 1), w ? this.words[g] = this.words[g] | 1 << m : this.words[g] = this.words[g] & ~(1 << m), this.strip();
            }, o.prototype.iadd = function(S) {
                var w;
                if (this.negative !== 0 && S.negative === 0) return this.negative = 0, w = this.isub(S), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && S.negative !== 0) return S.negative = 0, w = this.isub(S), S.negative = 1, w._normSign();
                var g, m;
                this.length > S.length ? (g = this, m = S) : (g = S, m = this);
                for(var E = 0, T = 0; T < m.length; T++)w = (g.words[T] | 0) + (m.words[T] | 0) + E, this.words[T] = w & 67108863, E = w >>> 26;
                for(; E !== 0 && T < g.length; T++)w = (g.words[T] | 0) + E, this.words[T] = w & 67108863, E = w >>> 26;
                if (this.length = g.length, E !== 0) this.words[this.length] = E, this.length++;
                else if (g !== this) for(; T < g.length; T++)this.words[T] = g.words[T];
                return this;
            }, o.prototype.add = function(S) {
                var w;
                return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, w = this.sub(S), S.negative ^= 1, w) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, w = S.sub(this), this.negative = 1, w) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
            }, o.prototype.isub = function(S) {
                if (S.negative !== 0) {
                    S.negative = 0;
                    var w = this.iadd(S);
                    return S.negative = 1, w._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
                var g = this.cmp(S);
                if (g === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var m, E;
                g > 0 ? (m = this, E = S) : (m = S, E = this);
                for(var T = 0, I = 0; I < E.length; I++)w = (m.words[I] | 0) - (E.words[I] | 0) + T, T = w >> 26, this.words[I] = w & 67108863;
                for(; T !== 0 && I < m.length; I++)w = (m.words[I] | 0) + T, T = w >> 26, this.words[I] = w & 67108863;
                if (T === 0 && I < m.length && m !== this) for(; I < m.length; I++)this.words[I] = m.words[I];
                return this.length = Math.max(this.length, I), m !== this && (this.negative = 1), this.strip();
            }, o.prototype.sub = function(S) {
                return this.clone().isub(S);
            };
            function _($, S, w) {
                w.negative = S.negative ^ $.negative;
                var g = $.length + S.length | 0;
                w.length = g, g = g - 1 | 0;
                var m = $.words[0] | 0, E = S.words[0] | 0, T = m * E, I = T & 67108863, P = T / 67108864 | 0;
                w.words[0] = I;
                for(var k = 1; k < g; k++){
                    for(var L = P >>> 26, j = P & 67108863, ie = Math.min(k, S.length - 1), ue = Math.max(0, k - $.length + 1); ue <= ie; ue++){
                        var ce = k - ue | 0;
                        m = $.words[ce] | 0, E = S.words[ue] | 0, T = m * E + j, L += T / 67108864 | 0, j = T & 67108863;
                    }
                    w.words[k] = j | 0, P = L | 0;
                }
                return P !== 0 ? w.words[k] = P | 0 : w.length--, w.strip();
            }
            var A = function(S, w, g) {
                var m = S.words, E = w.words, T = g.words, I = 0, P, k, L, j = m[0] | 0, ie = j & 8191, ue = j >>> 13, ce = m[1] | 0, he = ce & 8191, ee = ce >>> 13, ae = m[2] | 0, ye = ae & 8191, Se = ae >>> 13, De = m[3] | 0, Re = De & 8191, Ce = De >>> 13, M = m[4] | 0, z = M & 8191, de = M >>> 13, _e = m[5] | 0, Ie = _e & 8191, je = _e >>> 13, Ke = m[6] | 0, Ue = Ke & 8191, h = Ke >>> 13, x = m[7] | 0, q = x & 8191, te = x >>> 13, fe = m[8] | 0, ne = fe & 8191, W = fe >>> 13, J = m[9] | 0, V = J & 8191, C = J >>> 13, Z = E[0] | 0, le = Z & 8191, se = Z >>> 13, Ne = E[1] | 0, Le = Ne & 8191, rt = Ne >>> 13, yt = E[2] | 0, _t = yt & 8191, Qe = yt >>> 13, Rt = E[3] | 0, Lt = Rt & 8191, Ur = Rt >>> 13, jr = E[4] | 0, Et = jr & 8191, Xt = jr >>> 13, wr = E[5] | 0, zt = wr & 8191, Ae = wr >>> 13, we = E[6] | 0, xe = we & 8191, Me = we >>> 13, ze = E[7] | 0, Ve = ze & 8191, at = ze >>> 13, ct = E[8] | 0, lt = ct & 8191, mt = ct >>> 13, wt = E[9] | 0, bt = wt & 8191, Mt = wt >>> 13;
                g.negative = S.negative ^ w.negative, g.length = 19, P = Math.imul(ie, le), k = Math.imul(ie, se), k = k + Math.imul(ue, le) | 0, L = Math.imul(ue, se);
                var Ct = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(he, le), k = Math.imul(he, se), k = k + Math.imul(ee, le) | 0, L = Math.imul(ee, se), P = P + Math.imul(ie, Le) | 0, k = k + Math.imul(ie, rt) | 0, k = k + Math.imul(ue, Le) | 0, L = L + Math.imul(ue, rt) | 0;
                var Xe = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, P = Math.imul(ye, le), k = Math.imul(ye, se), k = k + Math.imul(Se, le) | 0, L = Math.imul(Se, se), P = P + Math.imul(he, Le) | 0, k = k + Math.imul(he, rt) | 0, k = k + Math.imul(ee, Le) | 0, L = L + Math.imul(ee, rt) | 0, P = P + Math.imul(ie, _t) | 0, k = k + Math.imul(ie, Qe) | 0, k = k + Math.imul(ue, _t) | 0, L = L + Math.imul(ue, Qe) | 0;
                var xt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(Re, le), k = Math.imul(Re, se), k = k + Math.imul(Ce, le) | 0, L = Math.imul(Ce, se), P = P + Math.imul(ye, Le) | 0, k = k + Math.imul(ye, rt) | 0, k = k + Math.imul(Se, Le) | 0, L = L + Math.imul(Se, rt) | 0, P = P + Math.imul(he, _t) | 0, k = k + Math.imul(he, Qe) | 0, k = k + Math.imul(ee, _t) | 0, L = L + Math.imul(ee, Qe) | 0, P = P + Math.imul(ie, Lt) | 0, k = k + Math.imul(ie, Ur) | 0, k = k + Math.imul(ue, Lt) | 0, L = L + Math.imul(ue, Ur) | 0;
                var St = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(z, le), k = Math.imul(z, se), k = k + Math.imul(de, le) | 0, L = Math.imul(de, se), P = P + Math.imul(Re, Le) | 0, k = k + Math.imul(Re, rt) | 0, k = k + Math.imul(Ce, Le) | 0, L = L + Math.imul(Ce, rt) | 0, P = P + Math.imul(ye, _t) | 0, k = k + Math.imul(ye, Qe) | 0, k = k + Math.imul(Se, _t) | 0, L = L + Math.imul(Se, Qe) | 0, P = P + Math.imul(he, Lt) | 0, k = k + Math.imul(he, Ur) | 0, k = k + Math.imul(ee, Lt) | 0, L = L + Math.imul(ee, Ur) | 0, P = P + Math.imul(ie, Et) | 0, k = k + Math.imul(ie, Xt) | 0, k = k + Math.imul(ue, Et) | 0, L = L + Math.imul(ue, Xt) | 0;
                var Pe = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, P = Math.imul(Ie, le), k = Math.imul(Ie, se), k = k + Math.imul(je, le) | 0, L = Math.imul(je, se), P = P + Math.imul(z, Le) | 0, k = k + Math.imul(z, rt) | 0, k = k + Math.imul(de, Le) | 0, L = L + Math.imul(de, rt) | 0, P = P + Math.imul(Re, _t) | 0, k = k + Math.imul(Re, Qe) | 0, k = k + Math.imul(Ce, _t) | 0, L = L + Math.imul(Ce, Qe) | 0, P = P + Math.imul(ye, Lt) | 0, k = k + Math.imul(ye, Ur) | 0, k = k + Math.imul(Se, Lt) | 0, L = L + Math.imul(Se, Ur) | 0, P = P + Math.imul(he, Et) | 0, k = k + Math.imul(he, Xt) | 0, k = k + Math.imul(ee, Et) | 0, L = L + Math.imul(ee, Xt) | 0, P = P + Math.imul(ie, zt) | 0, k = k + Math.imul(ie, Ae) | 0, k = k + Math.imul(ue, zt) | 0, L = L + Math.imul(ue, Ae) | 0;
                var et = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, P = Math.imul(Ue, le), k = Math.imul(Ue, se), k = k + Math.imul(h, le) | 0, L = Math.imul(h, se), P = P + Math.imul(Ie, Le) | 0, k = k + Math.imul(Ie, rt) | 0, k = k + Math.imul(je, Le) | 0, L = L + Math.imul(je, rt) | 0, P = P + Math.imul(z, _t) | 0, k = k + Math.imul(z, Qe) | 0, k = k + Math.imul(de, _t) | 0, L = L + Math.imul(de, Qe) | 0, P = P + Math.imul(Re, Lt) | 0, k = k + Math.imul(Re, Ur) | 0, k = k + Math.imul(Ce, Lt) | 0, L = L + Math.imul(Ce, Ur) | 0, P = P + Math.imul(ye, Et) | 0, k = k + Math.imul(ye, Xt) | 0, k = k + Math.imul(Se, Et) | 0, L = L + Math.imul(Se, Xt) | 0, P = P + Math.imul(he, zt) | 0, k = k + Math.imul(he, Ae) | 0, k = k + Math.imul(ee, zt) | 0, L = L + Math.imul(ee, Ae) | 0, P = P + Math.imul(ie, xe) | 0, k = k + Math.imul(ie, Me) | 0, k = k + Math.imul(ue, xe) | 0, L = L + Math.imul(ue, Me) | 0;
                var vt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(q, le), k = Math.imul(q, se), k = k + Math.imul(te, le) | 0, L = Math.imul(te, se), P = P + Math.imul(Ue, Le) | 0, k = k + Math.imul(Ue, rt) | 0, k = k + Math.imul(h, Le) | 0, L = L + Math.imul(h, rt) | 0, P = P + Math.imul(Ie, _t) | 0, k = k + Math.imul(Ie, Qe) | 0, k = k + Math.imul(je, _t) | 0, L = L + Math.imul(je, Qe) | 0, P = P + Math.imul(z, Lt) | 0, k = k + Math.imul(z, Ur) | 0, k = k + Math.imul(de, Lt) | 0, L = L + Math.imul(de, Ur) | 0, P = P + Math.imul(Re, Et) | 0, k = k + Math.imul(Re, Xt) | 0, k = k + Math.imul(Ce, Et) | 0, L = L + Math.imul(Ce, Xt) | 0, P = P + Math.imul(ye, zt) | 0, k = k + Math.imul(ye, Ae) | 0, k = k + Math.imul(Se, zt) | 0, L = L + Math.imul(Se, Ae) | 0, P = P + Math.imul(he, xe) | 0, k = k + Math.imul(he, Me) | 0, k = k + Math.imul(ee, xe) | 0, L = L + Math.imul(ee, Me) | 0, P = P + Math.imul(ie, Ve) | 0, k = k + Math.imul(ie, at) | 0, k = k + Math.imul(ue, Ve) | 0, L = L + Math.imul(ue, at) | 0;
                var be = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, P = Math.imul(ne, le), k = Math.imul(ne, se), k = k + Math.imul(W, le) | 0, L = Math.imul(W, se), P = P + Math.imul(q, Le) | 0, k = k + Math.imul(q, rt) | 0, k = k + Math.imul(te, Le) | 0, L = L + Math.imul(te, rt) | 0, P = P + Math.imul(Ue, _t) | 0, k = k + Math.imul(Ue, Qe) | 0, k = k + Math.imul(h, _t) | 0, L = L + Math.imul(h, Qe) | 0, P = P + Math.imul(Ie, Lt) | 0, k = k + Math.imul(Ie, Ur) | 0, k = k + Math.imul(je, Lt) | 0, L = L + Math.imul(je, Ur) | 0, P = P + Math.imul(z, Et) | 0, k = k + Math.imul(z, Xt) | 0, k = k + Math.imul(de, Et) | 0, L = L + Math.imul(de, Xt) | 0, P = P + Math.imul(Re, zt) | 0, k = k + Math.imul(Re, Ae) | 0, k = k + Math.imul(Ce, zt) | 0, L = L + Math.imul(Ce, Ae) | 0, P = P + Math.imul(ye, xe) | 0, k = k + Math.imul(ye, Me) | 0, k = k + Math.imul(Se, xe) | 0, L = L + Math.imul(Se, Me) | 0, P = P + Math.imul(he, Ve) | 0, k = k + Math.imul(he, at) | 0, k = k + Math.imul(ee, Ve) | 0, L = L + Math.imul(ee, at) | 0, P = P + Math.imul(ie, lt) | 0, k = k + Math.imul(ie, mt) | 0, k = k + Math.imul(ue, lt) | 0, L = L + Math.imul(ue, mt) | 0;
                var $r = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, P = Math.imul(V, le), k = Math.imul(V, se), k = k + Math.imul(C, le) | 0, L = Math.imul(C, se), P = P + Math.imul(ne, Le) | 0, k = k + Math.imul(ne, rt) | 0, k = k + Math.imul(W, Le) | 0, L = L + Math.imul(W, rt) | 0, P = P + Math.imul(q, _t) | 0, k = k + Math.imul(q, Qe) | 0, k = k + Math.imul(te, _t) | 0, L = L + Math.imul(te, Qe) | 0, P = P + Math.imul(Ue, Lt) | 0, k = k + Math.imul(Ue, Ur) | 0, k = k + Math.imul(h, Lt) | 0, L = L + Math.imul(h, Ur) | 0, P = P + Math.imul(Ie, Et) | 0, k = k + Math.imul(Ie, Xt) | 0, k = k + Math.imul(je, Et) | 0, L = L + Math.imul(je, Xt) | 0, P = P + Math.imul(z, zt) | 0, k = k + Math.imul(z, Ae) | 0, k = k + Math.imul(de, zt) | 0, L = L + Math.imul(de, Ae) | 0, P = P + Math.imul(Re, xe) | 0, k = k + Math.imul(Re, Me) | 0, k = k + Math.imul(Ce, xe) | 0, L = L + Math.imul(Ce, Me) | 0, P = P + Math.imul(ye, Ve) | 0, k = k + Math.imul(ye, at) | 0, k = k + Math.imul(Se, Ve) | 0, L = L + Math.imul(Se, at) | 0, P = P + Math.imul(he, lt) | 0, k = k + Math.imul(he, mt) | 0, k = k + Math.imul(ee, lt) | 0, L = L + Math.imul(ee, mt) | 0, P = P + Math.imul(ie, bt) | 0, k = k + Math.imul(ie, Mt) | 0, k = k + Math.imul(ue, bt) | 0, L = L + Math.imul(ue, Mt) | 0;
                var jt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, P = Math.imul(V, Le), k = Math.imul(V, rt), k = k + Math.imul(C, Le) | 0, L = Math.imul(C, rt), P = P + Math.imul(ne, _t) | 0, k = k + Math.imul(ne, Qe) | 0, k = k + Math.imul(W, _t) | 0, L = L + Math.imul(W, Qe) | 0, P = P + Math.imul(q, Lt) | 0, k = k + Math.imul(q, Ur) | 0, k = k + Math.imul(te, Lt) | 0, L = L + Math.imul(te, Ur) | 0, P = P + Math.imul(Ue, Et) | 0, k = k + Math.imul(Ue, Xt) | 0, k = k + Math.imul(h, Et) | 0, L = L + Math.imul(h, Xt) | 0, P = P + Math.imul(Ie, zt) | 0, k = k + Math.imul(Ie, Ae) | 0, k = k + Math.imul(je, zt) | 0, L = L + Math.imul(je, Ae) | 0, P = P + Math.imul(z, xe) | 0, k = k + Math.imul(z, Me) | 0, k = k + Math.imul(de, xe) | 0, L = L + Math.imul(de, Me) | 0, P = P + Math.imul(Re, Ve) | 0, k = k + Math.imul(Re, at) | 0, k = k + Math.imul(Ce, Ve) | 0, L = L + Math.imul(Ce, at) | 0, P = P + Math.imul(ye, lt) | 0, k = k + Math.imul(ye, mt) | 0, k = k + Math.imul(Se, lt) | 0, L = L + Math.imul(Se, mt) | 0, P = P + Math.imul(he, bt) | 0, k = k + Math.imul(he, Mt) | 0, k = k + Math.imul(ee, bt) | 0, L = L + Math.imul(ee, Mt) | 0;
                var nr = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, P = Math.imul(V, _t), k = Math.imul(V, Qe), k = k + Math.imul(C, _t) | 0, L = Math.imul(C, Qe), P = P + Math.imul(ne, Lt) | 0, k = k + Math.imul(ne, Ur) | 0, k = k + Math.imul(W, Lt) | 0, L = L + Math.imul(W, Ur) | 0, P = P + Math.imul(q, Et) | 0, k = k + Math.imul(q, Xt) | 0, k = k + Math.imul(te, Et) | 0, L = L + Math.imul(te, Xt) | 0, P = P + Math.imul(Ue, zt) | 0, k = k + Math.imul(Ue, Ae) | 0, k = k + Math.imul(h, zt) | 0, L = L + Math.imul(h, Ae) | 0, P = P + Math.imul(Ie, xe) | 0, k = k + Math.imul(Ie, Me) | 0, k = k + Math.imul(je, xe) | 0, L = L + Math.imul(je, Me) | 0, P = P + Math.imul(z, Ve) | 0, k = k + Math.imul(z, at) | 0, k = k + Math.imul(de, Ve) | 0, L = L + Math.imul(de, at) | 0, P = P + Math.imul(Re, lt) | 0, k = k + Math.imul(Re, mt) | 0, k = k + Math.imul(Ce, lt) | 0, L = L + Math.imul(Ce, mt) | 0, P = P + Math.imul(ye, bt) | 0, k = k + Math.imul(ye, Mt) | 0, k = k + Math.imul(Se, bt) | 0, L = L + Math.imul(Se, Mt) | 0;
                var kt = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, P = Math.imul(V, Lt), k = Math.imul(V, Ur), k = k + Math.imul(C, Lt) | 0, L = Math.imul(C, Ur), P = P + Math.imul(ne, Et) | 0, k = k + Math.imul(ne, Xt) | 0, k = k + Math.imul(W, Et) | 0, L = L + Math.imul(W, Xt) | 0, P = P + Math.imul(q, zt) | 0, k = k + Math.imul(q, Ae) | 0, k = k + Math.imul(te, zt) | 0, L = L + Math.imul(te, Ae) | 0, P = P + Math.imul(Ue, xe) | 0, k = k + Math.imul(Ue, Me) | 0, k = k + Math.imul(h, xe) | 0, L = L + Math.imul(h, Me) | 0, P = P + Math.imul(Ie, Ve) | 0, k = k + Math.imul(Ie, at) | 0, k = k + Math.imul(je, Ve) | 0, L = L + Math.imul(je, at) | 0, P = P + Math.imul(z, lt) | 0, k = k + Math.imul(z, mt) | 0, k = k + Math.imul(de, lt) | 0, L = L + Math.imul(de, mt) | 0, P = P + Math.imul(Re, bt) | 0, k = k + Math.imul(Re, Mt) | 0, k = k + Math.imul(Ce, bt) | 0, L = L + Math.imul(Ce, Mt) | 0;
                var Hn = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Hn >>> 26) | 0, Hn &= 67108863, P = Math.imul(V, Et), k = Math.imul(V, Xt), k = k + Math.imul(C, Et) | 0, L = Math.imul(C, Xt), P = P + Math.imul(ne, zt) | 0, k = k + Math.imul(ne, Ae) | 0, k = k + Math.imul(W, zt) | 0, L = L + Math.imul(W, Ae) | 0, P = P + Math.imul(q, xe) | 0, k = k + Math.imul(q, Me) | 0, k = k + Math.imul(te, xe) | 0, L = L + Math.imul(te, Me) | 0, P = P + Math.imul(Ue, Ve) | 0, k = k + Math.imul(Ue, at) | 0, k = k + Math.imul(h, Ve) | 0, L = L + Math.imul(h, at) | 0, P = P + Math.imul(Ie, lt) | 0, k = k + Math.imul(Ie, mt) | 0, k = k + Math.imul(je, lt) | 0, L = L + Math.imul(je, mt) | 0, P = P + Math.imul(z, bt) | 0, k = k + Math.imul(z, Mt) | 0, k = k + Math.imul(de, bt) | 0, L = L + Math.imul(de, Mt) | 0;
                var Zr = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, P = Math.imul(V, zt), k = Math.imul(V, Ae), k = k + Math.imul(C, zt) | 0, L = Math.imul(C, Ae), P = P + Math.imul(ne, xe) | 0, k = k + Math.imul(ne, Me) | 0, k = k + Math.imul(W, xe) | 0, L = L + Math.imul(W, Me) | 0, P = P + Math.imul(q, Ve) | 0, k = k + Math.imul(q, at) | 0, k = k + Math.imul(te, Ve) | 0, L = L + Math.imul(te, at) | 0, P = P + Math.imul(Ue, lt) | 0, k = k + Math.imul(Ue, mt) | 0, k = k + Math.imul(h, lt) | 0, L = L + Math.imul(h, mt) | 0, P = P + Math.imul(Ie, bt) | 0, k = k + Math.imul(Ie, Mt) | 0, k = k + Math.imul(je, bt) | 0, L = L + Math.imul(je, Mt) | 0;
                var v = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (v >>> 26) | 0, v &= 67108863, P = Math.imul(V, xe), k = Math.imul(V, Me), k = k + Math.imul(C, xe) | 0, L = Math.imul(C, Me), P = P + Math.imul(ne, Ve) | 0, k = k + Math.imul(ne, at) | 0, k = k + Math.imul(W, Ve) | 0, L = L + Math.imul(W, at) | 0, P = P + Math.imul(q, lt) | 0, k = k + Math.imul(q, mt) | 0, k = k + Math.imul(te, lt) | 0, L = L + Math.imul(te, mt) | 0, P = P + Math.imul(Ue, bt) | 0, k = k + Math.imul(Ue, Mt) | 0, k = k + Math.imul(h, bt) | 0, L = L + Math.imul(h, Mt) | 0;
                var B = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (B >>> 26) | 0, B &= 67108863, P = Math.imul(V, Ve), k = Math.imul(V, at), k = k + Math.imul(C, Ve) | 0, L = Math.imul(C, at), P = P + Math.imul(ne, lt) | 0, k = k + Math.imul(ne, mt) | 0, k = k + Math.imul(W, lt) | 0, L = L + Math.imul(W, mt) | 0, P = P + Math.imul(q, bt) | 0, k = k + Math.imul(q, Mt) | 0, k = k + Math.imul(te, bt) | 0, L = L + Math.imul(te, Mt) | 0;
                var Y = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (Y >>> 26) | 0, Y &= 67108863, P = Math.imul(V, lt), k = Math.imul(V, mt), k = k + Math.imul(C, lt) | 0, L = Math.imul(C, mt), P = P + Math.imul(ne, bt) | 0, k = k + Math.imul(ne, Mt) | 0, k = k + Math.imul(W, bt) | 0, L = L + Math.imul(W, Mt) | 0;
                var pe = (I + P | 0) + ((k & 8191) << 13) | 0;
                I = (L + (k >>> 13) | 0) + (pe >>> 26) | 0, pe &= 67108863, P = Math.imul(V, bt), k = Math.imul(V, Mt), k = k + Math.imul(C, bt) | 0, L = Math.imul(C, Mt);
                var ke = (I + P | 0) + ((k & 8191) << 13) | 0;
                return I = (L + (k >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, T[0] = Ct, T[1] = Xe, T[2] = xt, T[3] = St, T[4] = Pe, T[5] = et, T[6] = vt, T[7] = be, T[8] = $r, T[9] = jt, T[10] = nr, T[11] = kt, T[12] = Hn, T[13] = Zr, T[14] = v, T[15] = B, T[16] = Y, T[17] = pe, T[18] = ke, I !== 0 && (T[19] = I, g.length++), g;
            };
            Math.imul || (A = _);
            function O($, S, w) {
                w.negative = S.negative ^ $.negative, w.length = $.length + S.length;
                for(var g = 0, m = 0, E = 0; E < w.length - 1; E++){
                    var T = m;
                    m = 0;
                    for(var I = g & 67108863, P = Math.min(E, S.length - 1), k = Math.max(0, E - $.length + 1); k <= P; k++){
                        var L = E - k, j = $.words[L] | 0, ie = S.words[k] | 0, ue = j * ie, ce = ue & 67108863;
                        T = T + (ue / 67108864 | 0) | 0, ce = ce + I | 0, I = ce & 67108863, T = T + (ce >>> 26) | 0, m += T >>> 26, T &= 67108863;
                    }
                    w.words[E] = I, g = T, T = m;
                }
                return g !== 0 ? w.words[E] = g : w.length--, w.strip();
            }
            function N($, S, w) {
                var g = new U();
                return g.mulp($, S, w);
            }
            o.prototype.mulTo = function(S, w) {
                var g, m = this.length + S.length;
                return this.length === 10 && S.length === 10 ? g = A(this, S, w) : m < 63 ? g = _(this, S, w) : m < 1024 ? g = O(this, S, w) : g = N(this, S, w), g;
            };
            function U($, S) {
                this.x = $, this.y = S;
            }
            U.prototype.makeRBT = function(S) {
                for(var w = new Array(S), g = o.prototype._countBits(S) - 1, m = 0; m < S; m++)w[m] = this.revBin(m, g, S);
                return w;
            }, U.prototype.revBin = function(S, w, g) {
                if (S === 0 || S === g - 1) return S;
                for(var m = 0, E = 0; E < w; E++)m |= (S & 1) << w - E - 1, S >>= 1;
                return m;
            }, U.prototype.permute = function(S, w, g, m, E, T) {
                for(var I = 0; I < T; I++)m[I] = w[S[I]], E[I] = g[S[I]];
            }, U.prototype.transform = function(S, w, g, m, E, T) {
                this.permute(T, S, w, g, m, E);
                for(var I = 1; I < E; I <<= 1)for(var P = I << 1, k = Math.cos(2 * Math.PI / P), L = Math.sin(2 * Math.PI / P), j = 0; j < E; j += P)for(var ie = k, ue = L, ce = 0; ce < I; ce++){
                    var he = g[j + ce], ee = m[j + ce], ae = g[j + ce + I], ye = m[j + ce + I], Se = ie * ae - ue * ye;
                    ye = ie * ye + ue * ae, ae = Se, g[j + ce] = he + ae, m[j + ce] = ee + ye, g[j + ce + I] = he - ae, m[j + ce + I] = ee - ye, ce !== P && (Se = k * ie - L * ue, ue = k * ue + L * ie, ie = Se);
                }
            }, U.prototype.guessLen13b = function(S, w) {
                var g = Math.max(w, S) | 1, m = g & 1, E = 0;
                for(g = g / 2 | 0; g; g = g >>> 1)E++;
                return 1 << E + 1 + m;
            }, U.prototype.conjugate = function(S, w, g) {
                if (!(g <= 1)) for(var m = 0; m < g / 2; m++){
                    var E = S[m];
                    S[m] = S[g - m - 1], S[g - m - 1] = E, E = w[m], w[m] = -w[g - m - 1], w[g - m - 1] = -E;
                }
            }, U.prototype.normalize13b = function(S, w) {
                for(var g = 0, m = 0; m < w / 2; m++){
                    var E = Math.round(S[2 * m + 1] / w) * 8192 + Math.round(S[2 * m] / w) + g;
                    S[m] = E & 67108863, E < 67108864 ? g = 0 : g = E / 67108864 | 0;
                }
                return S;
            }, U.prototype.convert13b = function(S, w, g, m) {
                for(var E = 0, T = 0; T < w; T++)E = E + (S[T] | 0), g[2 * T] = E & 8191, E = E >>> 13, g[2 * T + 1] = E & 8191, E = E >>> 13;
                for(T = 2 * w; T < m; ++T)g[T] = 0;
                n(E === 0), n((E & -8192) === 0);
            }, U.prototype.stub = function(S) {
                for(var w = new Array(S), g = 0; g < S; g++)w[g] = 0;
                return w;
            }, U.prototype.mulp = function(S, w, g) {
                var m = 2 * this.guessLen13b(S.length, w.length), E = this.makeRBT(m), T = this.stub(m), I = new Array(m), P = new Array(m), k = new Array(m), L = new Array(m), j = new Array(m), ie = new Array(m), ue = g.words;
                ue.length = m, this.convert13b(S.words, S.length, I, m), this.convert13b(w.words, w.length, L, m), this.transform(I, T, P, k, m, E), this.transform(L, T, j, ie, m, E);
                for(var ce = 0; ce < m; ce++){
                    var he = P[ce] * j[ce] - k[ce] * ie[ce];
                    k[ce] = P[ce] * ie[ce] + k[ce] * j[ce], P[ce] = he;
                }
                return this.conjugate(P, k, m), this.transform(P, k, ue, T, m, E), this.conjugate(ue, T, m), this.normalize13b(ue, m), g.negative = S.negative ^ w.negative, g.length = S.length + w.length, g.strip();
            }, o.prototype.mul = function(S) {
                var w = new o(null);
                return w.words = new Array(this.length + S.length), this.mulTo(S, w);
            }, o.prototype.mulf = function(S) {
                var w = new o(null);
                return w.words = new Array(this.length + S.length), N(this, S, w);
            }, o.prototype.imul = function(S) {
                return this.clone().mulTo(S, this);
            }, o.prototype.imuln = function(S) {
                n(typeof S == "number"), n(S < 67108864);
                for(var w = 0, g = 0; g < this.length; g++){
                    var m = (this.words[g] | 0) * S, E = (m & 67108863) + (w & 67108863);
                    w >>= 26, w += m / 67108864 | 0, w += E >>> 26, this.words[g] = E & 67108863;
                }
                return w !== 0 && (this.words[g] = w, this.length++), this.length = S === 0 ? 1 : this.length, this;
            }, o.prototype.muln = function(S) {
                return this.clone().imuln(S);
            }, o.prototype.sqr = function() {
                return this.mul(this);
            }, o.prototype.isqr = function() {
                return this.imul(this.clone());
            }, o.prototype.pow = function(S) {
                var w = y(S);
                if (w.length === 0) return new o(1);
                for(var g = this, m = 0; m < w.length && w[m] === 0; m++, g = g.sqr());
                if (++m < w.length) for(var E = g.sqr(); m < w.length; m++, E = E.sqr())w[m] !== 0 && (g = g.mul(E));
                return g;
            }, o.prototype.iushln = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = S % 26, g = (S - w) / 26, m = 67108863 >>> 26 - w << 26 - w, E;
                if (w !== 0) {
                    var T = 0;
                    for(E = 0; E < this.length; E++){
                        var I = this.words[E] & m, P = (this.words[E] | 0) - I << w;
                        this.words[E] = P | T, T = I >>> 26 - w;
                    }
                    T && (this.words[E] = T, this.length++);
                }
                if (g !== 0) {
                    for(E = this.length - 1; E >= 0; E--)this.words[E + g] = this.words[E];
                    for(E = 0; E < g; E++)this.words[E] = 0;
                    this.length += g;
                }
                return this.strip();
            }, o.prototype.ishln = function(S) {
                return n(this.negative === 0), this.iushln(S);
            }, o.prototype.iushrn = function(S, w, g) {
                n(typeof S == "number" && S >= 0);
                var m;
                w ? m = (w - w % 26) / 26 : m = 0;
                var E = S % 26, T = Math.min((S - E) / 26, this.length), I = 67108863 ^ 67108863 >>> E << E, P = g;
                if (m -= T, m = Math.max(0, m), P) {
                    for(var k = 0; k < T; k++)P.words[k] = this.words[k];
                    P.length = T;
                }
                if (T !== 0) if (this.length > T) for(this.length -= T, k = 0; k < this.length; k++)this.words[k] = this.words[k + T];
                else this.words[0] = 0, this.length = 1;
                var L = 0;
                for(k = this.length - 1; k >= 0 && (L !== 0 || k >= m); k--){
                    var j = this.words[k] | 0;
                    this.words[k] = L << 26 - E | j >>> E, L = j & I;
                }
                return P && L !== 0 && (P.words[P.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
            }, o.prototype.ishrn = function(S, w, g) {
                return n(this.negative === 0), this.iushrn(S, w, g);
            }, o.prototype.shln = function(S) {
                return this.clone().ishln(S);
            }, o.prototype.ushln = function(S) {
                return this.clone().iushln(S);
            }, o.prototype.shrn = function(S) {
                return this.clone().ishrn(S);
            }, o.prototype.ushrn = function(S) {
                return this.clone().iushrn(S);
            }, o.prototype.testn = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = S % 26, g = (S - w) / 26, m = 1 << w;
                if (this.length <= g) return !1;
                var E = this.words[g];
                return !!(E & m);
            }, o.prototype.imaskn = function(S) {
                n(typeof S == "number" && S >= 0);
                var w = S % 26, g = (S - w) / 26;
                if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g) return this;
                if (w !== 0 && g++, this.length = Math.min(g, this.length), w !== 0) {
                    var m = 67108863 ^ 67108863 >>> w << w;
                    this.words[this.length - 1] &= m;
                }
                return this.strip();
            }, o.prototype.maskn = function(S) {
                return this.clone().imaskn(S);
            }, o.prototype.iaddn = function(S) {
                return n(typeof S == "number"), n(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
            }, o.prototype._iaddn = function(S) {
                this.words[0] += S;
                for(var w = 0; w < this.length && this.words[w] >= 67108864; w++)this.words[w] -= 67108864, w === this.length - 1 ? this.words[w + 1] = 1 : this.words[w + 1]++;
                return this.length = Math.max(this.length, w + 1), this;
            }, o.prototype.isubn = function(S) {
                if (n(typeof S == "number"), n(S < 67108864), S < 0) return this.iaddn(-S);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(S), this.negative = 1, this;
                if (this.words[0] -= S, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var w = 0; w < this.length && this.words[w] < 0; w++)this.words[w] += 67108864, this.words[w + 1] -= 1;
                return this.strip();
            }, o.prototype.addn = function(S) {
                return this.clone().iaddn(S);
            }, o.prototype.subn = function(S) {
                return this.clone().isubn(S);
            }, o.prototype.iabs = function() {
                return this.negative = 0, this;
            }, o.prototype.abs = function() {
                return this.clone().iabs();
            }, o.prototype._ishlnsubmul = function(S, w, g) {
                var m = S.length + g, E;
                this._expand(m);
                var T, I = 0;
                for(E = 0; E < S.length; E++){
                    T = (this.words[E + g] | 0) + I;
                    var P = (S.words[E] | 0) * w;
                    T -= P & 67108863, I = (T >> 26) - (P / 67108864 | 0), this.words[E + g] = T & 67108863;
                }
                for(; E < this.length - g; E++)T = (this.words[E + g] | 0) + I, I = T >> 26, this.words[E + g] = T & 67108863;
                if (I === 0) return this.strip();
                for(n(I === -1), I = 0, E = 0; E < this.length; E++)T = -(this.words[E] | 0) + I, I = T >> 26, this.words[E] = T & 67108863;
                return this.negative = 1, this.strip();
            }, o.prototype._wordDiv = function(S, w) {
                var g = this.length - S.length, m = this.clone(), E = S, T = E.words[E.length - 1] | 0, I = this._countBits(T);
                g = 26 - I, g !== 0 && (E = E.ushln(g), m.iushln(g), T = E.words[E.length - 1] | 0);
                var P = m.length - E.length, k;
                if (w !== "mod") {
                    k = new o(null), k.length = P + 1, k.words = new Array(k.length);
                    for(var L = 0; L < k.length; L++)k.words[L] = 0;
                }
                var j = m.clone()._ishlnsubmul(E, 1, P);
                j.negative === 0 && (m = j, k && (k.words[P] = 1));
                for(var ie = P - 1; ie >= 0; ie--){
                    var ue = (m.words[E.length + ie] | 0) * 67108864 + (m.words[E.length + ie - 1] | 0);
                    for(ue = Math.min(ue / T | 0, 67108863), m._ishlnsubmul(E, ue, ie); m.negative !== 0;)ue--, m.negative = 0, m._ishlnsubmul(E, 1, ie), m.isZero() || (m.negative ^= 1);
                    k && (k.words[ie] = ue);
                }
                return k && k.strip(), m.strip(), w !== "div" && g !== 0 && m.iushrn(g), {
                    div: k || null,
                    mod: m
                };
            }, o.prototype.divmod = function(S, w, g) {
                if (n(!S.isZero()), this.isZero()) return {
                    div: new o(0),
                    mod: new o(0)
                };
                var m, E, T;
                return this.negative !== 0 && S.negative === 0 ? (T = this.neg().divmod(S, w), w !== "mod" && (m = T.div.neg()), w !== "div" && (E = T.mod.neg(), g && E.negative !== 0 && E.iadd(S)), {
                    div: m,
                    mod: E
                }) : this.negative === 0 && S.negative !== 0 ? (T = this.divmod(S.neg(), w), w !== "mod" && (m = T.div.neg()), {
                    div: m,
                    mod: T.mod
                }) : this.negative & S.negative ? (T = this.neg().divmod(S.neg(), w), w !== "div" && (E = T.mod.neg(), g && E.negative !== 0 && E.isub(S)), {
                    div: T.div,
                    mod: E
                }) : S.length > this.length || this.cmp(S) < 0 ? {
                    div: new o(0),
                    mod: this
                } : S.length === 1 ? w === "div" ? {
                    div: this.divn(S.words[0]),
                    mod: null
                } : w === "mod" ? {
                    div: null,
                    mod: new o(this.modn(S.words[0]))
                } : {
                    div: this.divn(S.words[0]),
                    mod: new o(this.modn(S.words[0]))
                } : this._wordDiv(S, w);
            }, o.prototype.div = function(S) {
                return this.divmod(S, "div", !1).div;
            }, o.prototype.mod = function(S) {
                return this.divmod(S, "mod", !1).mod;
            }, o.prototype.umod = function(S) {
                return this.divmod(S, "mod", !0).mod;
            }, o.prototype.divRound = function(S) {
                var w = this.divmod(S);
                if (w.mod.isZero()) return w.div;
                var g = w.div.negative !== 0 ? w.mod.isub(S) : w.mod, m = S.ushrn(1), E = S.andln(1), T = g.cmp(m);
                return T < 0 || E === 1 && T === 0 ? w.div : w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
            }, o.prototype.modn = function(S) {
                n(S <= 67108863);
                for(var w = (1 << 26) % S, g = 0, m = this.length - 1; m >= 0; m--)g = (w * g + (this.words[m] | 0)) % S;
                return g;
            }, o.prototype.idivn = function(S) {
                n(S <= 67108863);
                for(var w = 0, g = this.length - 1; g >= 0; g--){
                    var m = (this.words[g] | 0) + w * 67108864;
                    this.words[g] = m / S | 0, w = m % S;
                }
                return this.strip();
            }, o.prototype.divn = function(S) {
                return this.clone().idivn(S);
            }, o.prototype.egcd = function(S) {
                n(S.negative === 0), n(!S.isZero());
                var w = this, g = S.clone();
                w.negative !== 0 ? w = w.umod(S) : w = w.clone();
                for(var m = new o(1), E = new o(0), T = new o(0), I = new o(1), P = 0; w.isEven() && g.isEven();)w.iushrn(1), g.iushrn(1), ++P;
                for(var k = g.clone(), L = w.clone(); !w.isZero();){
                    for(var j = 0, ie = 1; !(w.words[0] & ie) && j < 26; ++j, ie <<= 1);
                    if (j > 0) for(w.iushrn(j); j-- > 0;)(m.isOdd() || E.isOdd()) && (m.iadd(k), E.isub(L)), m.iushrn(1), E.iushrn(1);
                    for(var ue = 0, ce = 1; !(g.words[0] & ce) && ue < 26; ++ue, ce <<= 1);
                    if (ue > 0) for(g.iushrn(ue); ue-- > 0;)(T.isOdd() || I.isOdd()) && (T.iadd(k), I.isub(L)), T.iushrn(1), I.iushrn(1);
                    w.cmp(g) >= 0 ? (w.isub(g), m.isub(T), E.isub(I)) : (g.isub(w), T.isub(m), I.isub(E));
                }
                return {
                    a: T,
                    b: I,
                    gcd: g.iushln(P)
                };
            }, o.prototype._invmp = function(S) {
                n(S.negative === 0), n(!S.isZero());
                var w = this, g = S.clone();
                w.negative !== 0 ? w = w.umod(S) : w = w.clone();
                for(var m = new o(1), E = new o(0), T = g.clone(); w.cmpn(1) > 0 && g.cmpn(1) > 0;){
                    for(var I = 0, P = 1; !(w.words[0] & P) && I < 26; ++I, P <<= 1);
                    if (I > 0) for(w.iushrn(I); I-- > 0;)m.isOdd() && m.iadd(T), m.iushrn(1);
                    for(var k = 0, L = 1; !(g.words[0] & L) && k < 26; ++k, L <<= 1);
                    if (k > 0) for(g.iushrn(k); k-- > 0;)E.isOdd() && E.iadd(T), E.iushrn(1);
                    w.cmp(g) >= 0 ? (w.isub(g), m.isub(E)) : (g.isub(w), E.isub(m));
                }
                var j;
                return w.cmpn(1) === 0 ? j = m : j = E, j.cmpn(0) < 0 && j.iadd(S), j;
            }, o.prototype.gcd = function(S) {
                if (this.isZero()) return S.abs();
                if (S.isZero()) return this.abs();
                var w = this.clone(), g = S.clone();
                w.negative = 0, g.negative = 0;
                for(var m = 0; w.isEven() && g.isEven(); m++)w.iushrn(1), g.iushrn(1);
                do {
                    for(; w.isEven();)w.iushrn(1);
                    for(; g.isEven();)g.iushrn(1);
                    var E = w.cmp(g);
                    if (E < 0) {
                        var T = w;
                        w = g, g = T;
                    } else if (E === 0 || g.cmpn(1) === 0) break;
                    w.isub(g);
                }while (!0)
                return g.iushln(m);
            }, o.prototype.invm = function(S) {
                return this.egcd(S).a.umod(S);
            }, o.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, o.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, o.prototype.andln = function(S) {
                return this.words[0] & S;
            }, o.prototype.bincn = function(S) {
                n(typeof S == "number");
                var w = S % 26, g = (S - w) / 26, m = 1 << w;
                if (this.length <= g) return this._expand(g + 1), this.words[g] |= m, this;
                for(var E = m, T = g; E !== 0 && T < this.length; T++){
                    var I = this.words[T] | 0;
                    I += E, E = I >>> 26, I &= 67108863, this.words[T] = I;
                }
                return E !== 0 && (this.words[T] = E, this.length++), this;
            }, o.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, o.prototype.cmpn = function(S) {
                var w = S < 0;
                if (this.negative !== 0 && !w) return -1;
                if (this.negative === 0 && w) return 1;
                this.strip();
                var g;
                if (this.length > 1) g = 1;
                else {
                    w && (S = -S), n(S <= 67108863, "Number is too big");
                    var m = this.words[0] | 0;
                    g = m === S ? 0 : m < S ? -1 : 1;
                }
                return this.negative !== 0 ? -g | 0 : g;
            }, o.prototype.cmp = function(S) {
                if (this.negative !== 0 && S.negative === 0) return -1;
                if (this.negative === 0 && S.negative !== 0) return 1;
                var w = this.ucmp(S);
                return this.negative !== 0 ? -w | 0 : w;
            }, o.prototype.ucmp = function(S) {
                if (this.length > S.length) return 1;
                if (this.length < S.length) return -1;
                for(var w = 0, g = this.length - 1; g >= 0; g--){
                    var m = this.words[g] | 0, E = S.words[g] | 0;
                    if (m !== E) {
                        m < E ? w = -1 : m > E && (w = 1);
                        break;
                    }
                }
                return w;
            }, o.prototype.gtn = function(S) {
                return this.cmpn(S) === 1;
            }, o.prototype.gt = function(S) {
                return this.cmp(S) === 1;
            }, o.prototype.gten = function(S) {
                return this.cmpn(S) >= 0;
            }, o.prototype.gte = function(S) {
                return this.cmp(S) >= 0;
            }, o.prototype.ltn = function(S) {
                return this.cmpn(S) === -1;
            }, o.prototype.lt = function(S) {
                return this.cmp(S) === -1;
            }, o.prototype.lten = function(S) {
                return this.cmpn(S) <= 0;
            }, o.prototype.lte = function(S) {
                return this.cmp(S) <= 0;
            }, o.prototype.eqn = function(S) {
                return this.cmpn(S) === 0;
            }, o.prototype.eq = function(S) {
                return this.cmp(S) === 0;
            }, o.red = function(S) {
                return new R(S);
            }, o.prototype.toRed = function(S) {
                return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
            }, o.prototype.fromRed = function() {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, o.prototype._forceRed = function(S) {
                return this.red = S, this;
            }, o.prototype.forceRed = function(S) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(S);
            }, o.prototype.redAdd = function(S) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
            }, o.prototype.redIAdd = function(S) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
            }, o.prototype.redSub = function(S) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
            }, o.prototype.redISub = function(S) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
            }, o.prototype.redShl = function(S) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
            }, o.prototype.redMul = function(S) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
            }, o.prototype.redIMul = function(S) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
            }, o.prototype.redSqr = function() {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, o.prototype.redISqr = function() {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, o.prototype.redSqrt = function() {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, o.prototype.redInvm = function() {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, o.prototype.redNeg = function() {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, o.prototype.redPow = function(S) {
                return n(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
            };
            var D = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function H($, S) {
                this.name = $, this.p = new o(S, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            H.prototype._tmp = function() {
                var S = new o(null);
                return S.words = new Array(Math.ceil(this.n / 13)), S;
            }, H.prototype.ireduce = function(S) {
                var w = S, g;
                do this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), g = w.bitLength();
                while (g > this.n)
                var m = g < this.n ? -1 : w.ucmp(this.p);
                return m === 0 ? (w.words[0] = 0, w.length = 1) : m > 0 ? w.isub(this.p) : w.strip !== void 0 ? w.strip() : w._strip(), w;
            }, H.prototype.split = function(S, w) {
                S.iushrn(this.n, 0, w);
            }, H.prototype.imulK = function(S) {
                return S.imul(this.k);
            };
            function K() {
                H.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            i(K, H), K.prototype.split = function(S, w) {
                for(var g = 4194303, m = Math.min(S.length, 9), E = 0; E < m; E++)w.words[E] = S.words[E];
                if (w.length = m, S.length <= 9) {
                    S.words[0] = 0, S.length = 1;
                    return;
                }
                var T = S.words[9];
                for(w.words[w.length++] = T & g, E = 10; E < S.length; E++){
                    var I = S.words[E] | 0;
                    S.words[E - 10] = (I & g) << 4 | T >>> 22, T = I;
                }
                T >>>= 22, S.words[E - 10] = T, T === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
            }, K.prototype.imulK = function(S) {
                S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
                for(var w = 0, g = 0; g < S.length; g++){
                    var m = S.words[g] | 0;
                    w += m * 977, S.words[g] = w & 67108863, w = m * 64 + (w / 67108864 | 0);
                }
                return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
            };
            function re() {
                H.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            i(re, H);
            function Q() {
                H.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            i(Q, H);
            function G() {
                H.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            i(G, H), G.prototype.imulK = function(S) {
                for(var w = 0, g = 0; g < S.length; g++){
                    var m = (S.words[g] | 0) * 19 + w, E = m & 67108863;
                    m >>>= 26, S.words[g] = E, w = m;
                }
                return w !== 0 && (S.words[S.length++] = w), S;
            }, o._prime = function(S) {
                if (D[S]) return D[S];
                var w;
                if (S === "k256") w = new K();
                else if (S === "p224") w = new re();
                else if (S === "p192") w = new Q();
                else if (S === "p25519") w = new G();
                else throw new Error("Unknown prime " + S);
                return D[S] = w, w;
            };
            function R($) {
                if (typeof $ == "string") {
                    var S = o._prime($);
                    this.m = S.p, this.prime = S;
                } else n($.gtn(1), "modulus must be greater than 1"), this.m = $, this.prime = null;
            }
            R.prototype._verify1 = function(S) {
                n(S.negative === 0, "red works only with positives"), n(S.red, "red works only with red numbers");
            }, R.prototype._verify2 = function(S, w) {
                n((S.negative | w.negative) === 0, "red works only with positives"), n(S.red && S.red === w.red, "red works only with red numbers");
            }, R.prototype.imod = function(S) {
                return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
            }, R.prototype.neg = function(S) {
                return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
            }, R.prototype.add = function(S, w) {
                this._verify2(S, w);
                var g = S.add(w);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
            }, R.prototype.iadd = function(S, w) {
                this._verify2(S, w);
                var g = S.iadd(w);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g;
            }, R.prototype.sub = function(S, w) {
                this._verify2(S, w);
                var g = S.sub(w);
                return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
            }, R.prototype.isub = function(S, w) {
                this._verify2(S, w);
                var g = S.isub(w);
                return g.cmpn(0) < 0 && g.iadd(this.m), g;
            }, R.prototype.shl = function(S, w) {
                return this._verify1(S), this.imod(S.ushln(w));
            }, R.prototype.imul = function(S, w) {
                return this._verify2(S, w), this.imod(S.imul(w));
            }, R.prototype.mul = function(S, w) {
                return this._verify2(S, w), this.imod(S.mul(w));
            }, R.prototype.isqr = function(S) {
                return this.imul(S, S.clone());
            }, R.prototype.sqr = function(S) {
                return this.mul(S, S);
            }, R.prototype.sqrt = function(S) {
                if (S.isZero()) return S.clone();
                var w = this.m.andln(3);
                if (n(w % 2 === 1), w === 3) {
                    var g = this.m.add(new o(1)).iushrn(2);
                    return this.pow(S, g);
                }
                for(var m = this.m.subn(1), E = 0; !m.isZero() && m.andln(1) === 0;)E++, m.iushrn(1);
                n(!m.isZero());
                var T = new o(1).toRed(this), I = T.redNeg(), P = this.m.subn(1).iushrn(1), k = this.m.bitLength();
                for(k = new o(2 * k * k).toRed(this); this.pow(k, P).cmp(I) !== 0;)k.redIAdd(I);
                for(var L = this.pow(k, m), j = this.pow(S, m.addn(1).iushrn(1)), ie = this.pow(S, m), ue = E; ie.cmp(T) !== 0;){
                    for(var ce = ie, he = 0; ce.cmp(T) !== 0; he++)ce = ce.redSqr();
                    n(he < ue);
                    var ee = this.pow(L, new o(1).iushln(ue - he - 1));
                    j = j.redMul(ee), L = ee.redSqr(), ie = ie.redMul(L), ue = he;
                }
                return j;
            }, R.prototype.invm = function(S) {
                var w = S._invmp(this.m);
                return w.negative !== 0 ? (w.negative = 0, this.imod(w).redNeg()) : this.imod(w);
            }, R.prototype.pow = function(S, w) {
                if (w.isZero()) return new o(1).toRed(this);
                if (w.cmpn(1) === 0) return S.clone();
                var g = 4, m = new Array(1 << g);
                m[0] = new o(1).toRed(this), m[1] = S;
                for(var E = 2; E < m.length; E++)m[E] = this.mul(m[E - 1], S);
                var T = m[0], I = 0, P = 0, k = w.bitLength() % 26;
                for(k === 0 && (k = 26), E = w.length - 1; E >= 0; E--){
                    for(var L = w.words[E], j = k - 1; j >= 0; j--){
                        var ie = L >> j & 1;
                        if (T !== m[0] && (T = this.sqr(T)), ie === 0 && I === 0) {
                            P = 0;
                            continue;
                        }
                        I <<= 1, I |= ie, P++, !(P !== g && (E !== 0 || j !== 0)) && (T = this.mul(T, m[I]), P = 0, I = 0);
                    }
                    k = 26;
                }
                return T;
            }, R.prototype.convertTo = function(S) {
                var w = S.umod(this.m);
                return w === S ? w.clone() : w;
            }, R.prototype.convertFrom = function(S) {
                var w = S.clone();
                return w.red = null, w;
            }, o.mont = function(S) {
                return new X(S);
            };
            function X($) {
                R.call(this, $), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            i(X, R), X.prototype.convertTo = function(S) {
                return this.imod(S.ushln(this.shift));
            }, X.prototype.convertFrom = function(S) {
                var w = this.imod(S.mul(this.rinv));
                return w.red = null, w;
            }, X.prototype.imul = function(S, w) {
                if (S.isZero() || w.isZero()) return S.words[0] = 0, S.length = 1, S;
                var g = S.imul(w), m = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = g.isub(m).iushrn(this.shift), T = E;
                return E.cmp(this.m) >= 0 ? T = E.isub(this.m) : E.cmpn(0) < 0 && (T = E.iadd(this.m)), T._forceRed(this);
            }, X.prototype.mul = function(S, w) {
                if (S.isZero() || w.isZero()) return new o(0)._forceRed(this);
                var g = S.mul(w), m = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = g.isub(m).iushrn(this.shift), T = E;
                return E.cmp(this.m) >= 0 ? T = E.isub(this.m) : E.cmpn(0) < 0 && (T = E.iadd(this.m)), T._forceRed(this);
            }, X.prototype.invm = function(S) {
                var w = this.imod(S._invmp(this.m).mul(this.r2));
                return w._forceRed(this);
            };
        })(e, Ge);
    }(ky)), ky.exports;
}
var zg = {
    exports: {}
}, _5;
function L3() {
    if (_5) return zg.exports;
    _5 = 1;
    var e;
    zg.exports = function(i) {
        return e || (e = new t(null)), e.generate(i);
    };
    function t(n) {
        this.rand = n;
    }
    if (zg.exports.Rand = t, t.prototype.generate = function(i) {
        return this._rand(i);
    }, t.prototype._rand = function(i) {
        if (this.rand.getBytes) return this.rand.getBytes(i);
        for(var o = new Uint8Array(i), s = 0; s < o.length; s++)o[s] = this.rand.getByte();
        return o;
    }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(i) {
        var o = new Uint8Array(i);
        return self.crypto.getRandomValues(o), o;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(i) {
        var o = new Uint8Array(i);
        return self.msCrypto.getRandomValues(o), o;
    } : ("TURBOPACK compile-time value", "undefined") == "object" && (t.prototype._rand = function() {
        throw new Error("Not implemented yet");
    });
    else try {
        var r = q3();
        if (typeof r.randomBytes != "function") throw new Error("Not supported");
        t.prototype._rand = function(i) {
            return r.randomBytes(i);
        };
    } catch  {}
    return zg.exports;
}
var Zv, E5;
function vO() {
    if (E5) return Zv;
    E5 = 1;
    var e = bi(), t = L3();
    function r(n) {
        this.rand = n || new t.Rand();
    }
    return Zv = r, r.create = function(i) {
        return new r(i);
    }, r.prototype._randbelow = function(i) {
        var o = i.bitLength(), s = Math.ceil(o / 8);
        do var a = new e(this.rand.generate(s));
        while (a.cmp(i) >= 0)
        return a;
    }, r.prototype._randrange = function(i, o) {
        var s = o.sub(i);
        return i.add(this._randbelow(s));
    }, r.prototype.test = function(i, o, s) {
        var a = i.bitLength(), u = e.mont(i), f = new e(1).toRed(u);
        o || (o = Math.max(1, a / 48 | 0));
        for(var c = i.subn(1), l = 0; !c.testn(l); l++);
        for(var p = i.shrn(l), y = c.toRed(u), _ = !0; o > 0; o--){
            var A = this._randrange(new e(2), c);
            s && s(A);
            var O = A.toRed(u).redPow(p);
            if (!(O.cmp(f) === 0 || O.cmp(y) === 0)) {
                for(var N = 1; N < l; N++){
                    if (O = O.redSqr(), O.cmp(f) === 0) return !1;
                    if (O.cmp(y) === 0) break;
                }
                if (N === l) return !1;
            }
        }
        return _;
    }, r.prototype.getDivisor = function(i, o) {
        var s = i.bitLength(), a = e.mont(i), u = new e(1).toRed(a);
        o || (o = Math.max(1, s / 48 | 0));
        for(var f = i.subn(1), c = 0; !f.testn(c); c++);
        for(var l = i.shrn(c), p = f.toRed(a); o > 0; o--){
            var y = this._randrange(new e(2), f), _ = i.gcd(y);
            if (_.cmpn(1) !== 0) return _;
            var A = y.toRed(a).redPow(l);
            if (!(A.cmp(u) === 0 || A.cmp(p) === 0)) {
                for(var O = 1; O < c; O++){
                    if (A = A.redSqr(), A.cmp(u) === 0) return A.fromRed().subn(1).gcd(i);
                    if (A.cmp(p) === 0) break;
                }
                if (O === c) return A = A.redSqr(), A.fromRed().subn(1).gcd(i);
            }
        }
        return !1;
    }, Zv;
}
var Yv, x5;
function _O() {
    if (x5) return Yv;
    x5 = 1;
    var e = kd();
    Yv = O, O.simpleSieve = _, O.fermatTest = A;
    var t = bi(), r = new t(24), n = vO(), i = new n(), o = new t(1), s = new t(2), a = new t(5);
    new t(16), new t(8);
    var u = new t(10), f = new t(3);
    new t(7);
    var c = new t(11), l = new t(4);
    new t(12);
    var p = null;
    function y() {
        if (p !== null) return p;
        var N = 1048576, U = [];
        U[0] = 2;
        for(var D = 1, H = 3; H < N; H += 2){
            for(var K = Math.ceil(Math.sqrt(H)), re = 0; re < D && U[re] <= K && H % U[re] !== 0; re++);
            D !== re && U[re] <= K || (U[D++] = H);
        }
        return p = U, U;
    }
    function _(N) {
        for(var U = y(), D = 0; D < U.length; D++)if (N.modn(U[D]) === 0) return N.cmpn(U[D]) === 0;
        return !0;
    }
    function A(N) {
        var U = t.mont(N);
        return s.toRed(U).redPow(N.subn(1)).fromRed().cmpn(1) === 0;
    }
    function O(N, U) {
        if (N < 16) return U === 2 || U === 5 ? new t([
            140,
            123
        ]) : new t([
            140,
            39
        ]);
        U = new t(U);
        for(var D, H;;){
            for(D = new t(e(Math.ceil(N / 8))); D.bitLength() > N;)D.ishrn(1);
            if (D.isEven() && D.iadd(o), D.testn(1) || D.iadd(s), U.cmp(s)) {
                if (!U.cmp(a)) for(; D.mod(u).cmp(f);)D.iadd(l);
            } else for(; D.mod(r).cmp(c);)D.iadd(l);
            if (H = D.shrn(1), _(H) && _(D) && A(H) && A(D) && i.test(H) && i.test(D)) return D;
        }
    }
    return Yv;
}
const XY = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, JY = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, QY = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, eX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, tX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, rX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, nX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, iX = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, oX = {
    modp1: XY,
    modp2: JY,
    modp5: QY,
    modp14: eX,
    modp15: tX,
    modp16: rX,
    modp17: nX,
    modp18: iX
};
var Xv, S5;
function sX() {
    if (S5) return Xv;
    S5 = 1;
    var e = bi(), t = vO(), r = new t(), n = new e(24), i = new e(11), o = new e(10), s = new e(3), a = new e(7), u = _O(), f = kd();
    Xv = _;
    function c(O, N) {
        return N = N || "utf8", We.isBuffer(O) || (O = new We(O, N)), this._pub = new e(O), this;
    }
    function l(O, N) {
        return N = N || "utf8", We.isBuffer(O) || (O = new We(O, N)), this._priv = new e(O), this;
    }
    var p = {};
    function y(O, N) {
        var U = N.toString("hex"), D = [
            U,
            O.toString(16)
        ].join("_");
        if (D in p) return p[D];
        var H = 0;
        if (O.isEven() || !u.simpleSieve || !u.fermatTest(O) || !r.test(O)) return H += 1, U === "02" || U === "05" ? H += 8 : H += 4, p[D] = H, H;
        r.test(O.shrn(1)) || (H += 2);
        var K;
        switch(U){
            case "02":
                O.mod(n).cmp(i) && (H += 8);
                break;
            case "05":
                K = O.mod(o), K.cmp(s) && K.cmp(a) && (H += 8);
                break;
            default:
                H += 4;
        }
        return p[D] = H, H;
    }
    function _(O, N, U) {
        this.setGenerator(N), this.__prime = new e(O), this._prime = e.mont(this.__prime), this._primeLen = O.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, U ? (this.setPublicKey = c, this.setPrivateKey = l) : this._primeCode = 8;
    }
    Object.defineProperty(_.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = y(this.__prime, this.__gen)), this._primeCode;
        }
    }), _.prototype.generateKeys = function() {
        return this._priv || (this._priv = new e(f(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    }, _.prototype.computeSecret = function(O) {
        O = new e(O), O = O.toRed(this._prime);
        var N = O.redPow(this._priv).fromRed(), U = new We(N.toArray()), D = this.getPrime();
        if (U.length < D.length) {
            var H = new We(D.length - U.length);
            H.fill(0), U = We.concat([
                H,
                U
            ]);
        }
        return U;
    }, _.prototype.getPublicKey = function(N) {
        return A(this._pub, N);
    }, _.prototype.getPrivateKey = function(N) {
        return A(this._priv, N);
    }, _.prototype.getPrime = function(O) {
        return A(this.__prime, O);
    }, _.prototype.getGenerator = function(O) {
        return A(this._gen, O);
    }, _.prototype.setGenerator = function(O, N) {
        return N = N || "utf8", We.isBuffer(O) || (O = new We(O, N)), this.__gen = O, this._gen = new e(O), this;
    };
    function A(O, N) {
        var U = new We(O.toArray());
        return N ? U.toString(N) : U;
    }
    return Xv;
}
var A5;
function aX() {
    if (A5) return qu;
    A5 = 1;
    var e = _O(), t = oX, r = sX();
    function n(s) {
        var a = new We(t[s].prime, "hex"), u = new We(t[s].gen, "hex");
        return new r(a, u);
    }
    var i = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function o(s, a, u, f) {
        return We.isBuffer(a) || i[a] === void 0 ? o(s, "binary", a, u) : (a = a || "binary", f = f || "binary", u = u || new We([
            2
        ]), We.isBuffer(u) || (u = new We(u, f)), typeof s == "number" ? new r(e(s, u), u, !0) : (We.isBuffer(s) || (s = new We(s, a)), new r(s, u, !0)));
    }
    return qu.DiffieHellmanGroup = qu.createDiffieHellmanGroup = qu.getDiffieHellman = n, qu.createDiffieHellman = qu.DiffieHellman = o, qu;
}
var jg = {
    exports: {}
}, Hg = {
    exports: {}
}, T5;
function Sb() {
    if (T5) return Hg.exports;
    T5 = 1, typeof bn > "u" || !bn.version || bn.version.indexOf("v0.") === 0 || bn.version.indexOf("v1.") === 0 && bn.version.indexOf("v1.8.") !== 0 ? Hg.exports = {
        nextTick: e
    } : Hg.exports = bn;
    function e(t, r, n, i) {
        if (typeof t != "function") throw new TypeError('"callback" argument must be a function');
        var o = arguments.length, s, a;
        switch(o){
            case 0:
            case 1:
                return bn.nextTick(t);
            case 2:
                return bn.nextTick(function() {
                    t.call(null, r);
                });
            case 3:
                return bn.nextTick(function() {
                    t.call(null, r, n);
                });
            case 4:
                return bn.nextTick(function() {
                    t.call(null, r, n, i);
                });
            default:
                for(s = new Array(o - 1), a = 0; a < s.length;)s[a++] = arguments[a];
                return bn.nextTick(function() {
                    t.apply(null, s);
                });
        }
    }
    return Hg.exports;
}
var Jv, k5;
function cX() {
    if (k5) return Jv;
    k5 = 1;
    var e = {}.toString;
    return Jv = Array.isArray || function(t) {
        return e.call(t) == "[object Array]";
    }, Jv;
}
var qg = {
    exports: {}
}, I5;
function EO() {
    if (I5) return qg.exports;
    I5 = 1;
    var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(K, re, Q) {
        return Function.prototype.apply.call(K, re, Q);
    }, r;
    e && typeof e.ownKeys == "function" ? r = e.ownKeys : Object.getOwnPropertySymbols ? r = function(K) {
        return Object.getOwnPropertyNames(K).concat(Object.getOwnPropertySymbols(K));
    } : r = function(K) {
        return Object.getOwnPropertyNames(K);
    };
    function n(H) {
        console && console.warn && console.warn(H);
    }
    var i = Number.isNaN || function(K) {
        return K !== K;
    };
    function o() {
        o.init.call(this);
    }
    qg.exports = o, qg.exports.once = N, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    var s = 10;
    function a(H) {
        if (typeof H != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof H);
    }
    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return s;
        },
        set: function(H) {
            if (typeof H != "number" || H < 0 || i(H)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + H + ".");
            s = H;
        }
    }), o.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o.prototype.setMaxListeners = function(K) {
        if (typeof K != "number" || K < 0 || i(K)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + K + ".");
        return this._maxListeners = K, this;
    };
    function u(H) {
        return H._maxListeners === void 0 ? o.defaultMaxListeners : H._maxListeners;
    }
    o.prototype.getMaxListeners = function() {
        return u(this);
    }, o.prototype.emit = function(K) {
        for(var re = [], Q = 1; Q < arguments.length; Q++)re.push(arguments[Q]);
        var G = K === "error", R = this._events;
        if (R !== void 0) G = G && R.error === void 0;
        else if (!G) return !1;
        if (G) {
            var X;
            if (re.length > 0 && (X = re[0]), X instanceof Error) throw X;
            var $ = new Error("Unhandled error." + (X ? " (" + X.message + ")" : ""));
            throw $.context = X, $;
        }
        var S = R[K];
        if (S === void 0) return !1;
        if (typeof S == "function") t(S, this, re);
        else for(var w = S.length, g = _(S, w), Q = 0; Q < w; ++Q)t(g[Q], this, re);
        return !0;
    };
    function f(H, K, re, Q) {
        var G, R, X;
        if (a(re), R = H._events, R === void 0 ? (R = H._events = /* @__PURE__ */ Object.create(null), H._eventsCount = 0) : (R.newListener !== void 0 && (H.emit("newListener", K, re.listener ? re.listener : re), R = H._events), X = R[K]), X === void 0) X = R[K] = re, ++H._eventsCount;
        else if (typeof X == "function" ? X = R[K] = Q ? [
            re,
            X
        ] : [
            X,
            re
        ] : Q ? X.unshift(re) : X.push(re), G = u(H), G > 0 && X.length > G && !X.warned) {
            X.warned = !0;
            var $ = new Error("Possible EventEmitter memory leak detected. " + X.length + " " + String(K) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            $.name = "MaxListenersExceededWarning", $.emitter = H, $.type = K, $.count = X.length, n($);
        }
        return H;
    }
    o.prototype.addListener = function(K, re) {
        return f(this, K, re, !1);
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(K, re) {
        return f(this, K, re, !0);
    };
    function c() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function l(H, K, re) {
        var Q = {
            fired: !1,
            wrapFn: void 0,
            target: H,
            type: K,
            listener: re
        }, G = c.bind(Q);
        return G.listener = re, Q.wrapFn = G, G;
    }
    o.prototype.once = function(K, re) {
        return a(re), this.on(K, l(this, K, re)), this;
    }, o.prototype.prependOnceListener = function(K, re) {
        return a(re), this.prependListener(K, l(this, K, re)), this;
    }, o.prototype.removeListener = function(K, re) {
        var Q, G, R, X, $;
        if (a(re), G = this._events, G === void 0) return this;
        if (Q = G[K], Q === void 0) return this;
        if (Q === re || Q.listener === re) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete G[K], G.removeListener && this.emit("removeListener", K, Q.listener || re));
        else if (typeof Q != "function") {
            for(R = -1, X = Q.length - 1; X >= 0; X--)if (Q[X] === re || Q[X].listener === re) {
                $ = Q[X].listener, R = X;
                break;
            }
            if (R < 0) return this;
            R === 0 ? Q.shift() : A(Q, R), Q.length === 1 && (G[K] = Q[0]), G.removeListener !== void 0 && this.emit("removeListener", K, $ || re);
        }
        return this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(K) {
        var re, Q, G;
        if (Q = this._events, Q === void 0) return this;
        if (Q.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Q[K] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Q[K]), this;
        if (arguments.length === 0) {
            var R = Object.keys(Q), X;
            for(G = 0; G < R.length; ++G)X = R[G], X !== "removeListener" && this.removeAllListeners(X);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if (re = Q[K], typeof re == "function") this.removeListener(K, re);
        else if (re !== void 0) for(G = re.length - 1; G >= 0; G--)this.removeListener(K, re[G]);
        return this;
    };
    function p(H, K, re) {
        var Q = H._events;
        if (Q === void 0) return [];
        var G = Q[K];
        return G === void 0 ? [] : typeof G == "function" ? re ? [
            G.listener || G
        ] : [
            G
        ] : re ? O(G) : _(G, G.length);
    }
    o.prototype.listeners = function(K) {
        return p(this, K, !0);
    }, o.prototype.rawListeners = function(K) {
        return p(this, K, !1);
    }, o.listenerCount = function(H, K) {
        return typeof H.listenerCount == "function" ? H.listenerCount(K) : y.call(H, K);
    }, o.prototype.listenerCount = y;
    function y(H) {
        var K = this._events;
        if (K !== void 0) {
            var re = K[H];
            if (typeof re == "function") return 1;
            if (re !== void 0) return re.length;
        }
        return 0;
    }
    o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r(this._events) : [];
    };
    function _(H, K) {
        for(var re = new Array(K), Q = 0; Q < K; ++Q)re[Q] = H[Q];
        return re;
    }
    function A(H, K) {
        for(; K + 1 < H.length; K++)H[K] = H[K + 1];
        H.pop();
    }
    function O(H) {
        for(var K = new Array(H.length), re = 0; re < K.length; ++re)K[re] = H[re].listener || H[re];
        return K;
    }
    function N(H, K) {
        return new Promise(function(re, Q) {
            function G(X) {
                H.removeListener(K, R), Q(X);
            }
            function R() {
                typeof H.removeListener == "function" && H.removeListener("error", G), re([].slice.call(arguments));
            }
            D(H, K, R, {
                once: !0
            }), K !== "error" && U(H, G, {
                once: !0
            });
        });
    }
    function U(H, K, re) {
        typeof H.on == "function" && D(H, "error", K, re);
    }
    function D(H, K, re, Q) {
        if (typeof H.on == "function") Q.once ? H.once(K, re) : H.on(K, re);
        else if (typeof H.addEventListener == "function") H.addEventListener(K, function G(R) {
            Q.once && H.removeEventListener(K, G), re(R);
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof H);
    }
    return qg.exports;
}
var Qv, B5;
function xO() {
    return B5 || (B5 = 1, Qv = EO().EventEmitter), Qv;
}
var Kg = {
    exports: {}
}, O5;
function Ab() {
    return O5 || (O5 = 1, function(e, t) {
        var r = ku, n = r.Buffer;
        function i(s, a) {
            for(var u in s)a[u] = s[u];
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = o);
        function o(s, a, u) {
            return n(s, a, u);
        }
        i(n, o), o.from = function(s, a, u) {
            if (typeof s == "number") throw new TypeError("Argument must not be a number");
            return n(s, a, u);
        }, o.alloc = function(s, a, u) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            var f = n(s);
            return a !== void 0 ? typeof u == "string" ? f.fill(a, u) : f.fill(a) : f.fill(0), f;
        }, o.allocUnsafe = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return n(s);
        }, o.allocUnsafeSlow = function(s) {
            if (typeof s != "number") throw new TypeError("Argument must be a number");
            return r.SlowBuffer(s);
        };
    }(Kg, Kg.exports)), Kg.exports;
}
var fi = {}, P5;
function o0() {
    if (P5) return fi;
    P5 = 1;
    function e(A) {
        return Array.isArray ? Array.isArray(A) : _(A) === "[object Array]";
    }
    fi.isArray = e;
    function t(A) {
        return typeof A == "boolean";
    }
    fi.isBoolean = t;
    function r(A) {
        return A === null;
    }
    fi.isNull = r;
    function n(A) {
        return A == null;
    }
    fi.isNullOrUndefined = n;
    function i(A) {
        return typeof A == "number";
    }
    fi.isNumber = i;
    function o(A) {
        return typeof A == "string";
    }
    fi.isString = o;
    function s(A) {
        return typeof A == "symbol";
    }
    fi.isSymbol = s;
    function a(A) {
        return A === void 0;
    }
    fi.isUndefined = a;
    function u(A) {
        return _(A) === "[object RegExp]";
    }
    fi.isRegExp = u;
    function f(A) {
        return typeof A == "object" && A !== null;
    }
    fi.isObject = f;
    function c(A) {
        return _(A) === "[object Date]";
    }
    fi.isDate = c;
    function l(A) {
        return _(A) === "[object Error]" || A instanceof Error;
    }
    fi.isError = l;
    function p(A) {
        return typeof A == "function";
    }
    fi.isFunction = p;
    function y(A) {
        return A === null || typeof A == "boolean" || typeof A == "number" || typeof A == "string" || typeof A == "symbol" || // ES6 symbol
        typeof A > "u";
    }
    fi.isPrimitive = y, fi.isBuffer = ku.Buffer.isBuffer;
    function _(A) {
        return Object.prototype.toString.call(A);
    }
    return fi;
}
var e2 = {
    exports: {}
}, N5;
function uX() {
    return N5 || (N5 = 1, function(e) {
        function t(o, s) {
            if (!(o instanceof s)) throw new TypeError("Cannot call a class as a function");
        }
        var r = Ab().Buffer, n = Iu;
        function i(o, s, a) {
            o.copy(s, a);
        }
        e.exports = function() {
            function o() {
                t(this, o), this.head = null, this.tail = null, this.length = 0;
            }
            return o.prototype.push = function(a) {
                var u = {
                    data: a,
                    next: null
                };
                this.length > 0 ? this.tail.next = u : this.head = u, this.tail = u, ++this.length;
            }, o.prototype.unshift = function(a) {
                var u = {
                    data: a,
                    next: this.head
                };
                this.length === 0 && (this.tail = u), this.head = u, ++this.length;
            }, o.prototype.shift = function() {
                if (this.length !== 0) {
                    var a = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, a;
                }
            }, o.prototype.clear = function() {
                this.head = this.tail = null, this.length = 0;
            }, o.prototype.join = function(a) {
                if (this.length === 0) return "";
                for(var u = this.head, f = "" + u.data; u = u.next;)f += a + u.data;
                return f;
            }, o.prototype.concat = function(a) {
                if (this.length === 0) return r.alloc(0);
                for(var u = r.allocUnsafe(a >>> 0), f = this.head, c = 0; f;)i(f.data, u, c), c += f.data.length, f = f.next;
                return u;
            }, o;
        }(), n && n.inspect && n.inspect.custom && (e.exports.prototype[n.inspect.custom] = function() {
            var o = n.inspect({
                length: this.length
            });
            return this.constructor.name + " " + o;
        });
    }(e2)), e2.exports;
}
var t2, M5;
function SO() {
    if (M5) return t2;
    M5 = 1;
    var e = Sb();
    function t(i, o) {
        var s = this, a = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
        return a || u ? (o ? o(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(n, this, i)) : e.nextTick(n, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(f) {
            !o && f ? s._writableState ? s._writableState.errorEmitted || (s._writableState.errorEmitted = !0, e.nextTick(n, s, f)) : e.nextTick(n, s, f) : o && o(f);
        }), this);
    }
    function r() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function n(i, o) {
        i.emit("error", o);
    }
    return t2 = {
        destroy: t,
        undestroy: r
    }, t2;
}
var r2, R5;
function fX() {
    if (R5) return r2;
    R5 = 1, r2 = e;
    function e(r, n) {
        if (t("noDeprecation")) return r;
        var i = !1;
        function o() {
            if (!i) {
                if (t("throwDeprecation")) throw new Error(n);
                t("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
            }
            return r.apply(this, arguments);
        }
        return o;
    }
    function t(r) {
        try {
            if (!Ge.localStorage) return !1;
        } catch  {
            return !1;
        }
        var n = Ge.localStorage[r];
        return n == null ? !1 : String(n).toLowerCase() === "true";
    }
    return r2;
}
var n2, C5;
function AO() {
    if (C5) return n2;
    C5 = 1;
    var e = Sb();
    n2 = A;
    function t(T) {
        var I = this;
        this.next = null, this.entry = null, this.finish = function() {
            E(I, T);
        };
    }
    var r = !bn.browser && [
        "v0.10",
        "v0.9."
    ].indexOf(bn.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, n;
    A.WritableState = y;
    var i = Object.create(o0());
    i.inherits = Or();
    var o = {
        deprecate: fX()
    }, s = xO(), a = Ab().Buffer, u = (typeof Ge < "u" ? Ge : ("TURBOPACK compile-time value", "undefined") < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function f(T) {
        return a.from(T);
    }
    function c(T) {
        return a.isBuffer(T) || T instanceof u;
    }
    var l = SO();
    i.inherits(A, s);
    function p() {}
    function y(T, I) {
        n = n || rd(), T = T || {};
        var P = I instanceof n;
        this.objectMode = !!T.objectMode, P && (this.objectMode = this.objectMode || !!T.writableObjectMode);
        var k = T.highWaterMark, L = T.writableHighWaterMark, j = this.objectMode ? 16 : 16 * 1024;
        k || k === 0 ? this.highWaterMark = k : P && (L || L === 0) ? this.highWaterMark = L : this.highWaterMark = j, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var ie = T.decodeStrings === !1;
        this.decodeStrings = !ie, this.defaultEncoding = T.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ue) {
            Q(I, ue);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
    }
    y.prototype.getBuffer = function() {
        for(var I = this.bufferedRequest, P = []; I;)P.push(I), I = I.next;
        return P;
    }, function() {
        try {
            Object.defineProperty(y.prototype, "buffer", {
                get: o.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch  {}
    }();
    var _;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (_ = Function.prototype[Symbol.hasInstance], Object.defineProperty(A, Symbol.hasInstance, {
        value: function(T) {
            return _.call(this, T) ? !0 : this !== A ? !1 : T && T._writableState instanceof y;
        }
    })) : _ = function(T) {
        return T instanceof this;
    };
    function A(T) {
        if (n = n || rd(), !_.call(A, this) && !(this instanceof n)) return new A(T);
        this._writableState = new y(T, this), this.writable = !0, T && (typeof T.write == "function" && (this._write = T.write), typeof T.writev == "function" && (this._writev = T.writev), typeof T.destroy == "function" && (this._destroy = T.destroy), typeof T.final == "function" && (this._final = T.final)), s.call(this);
    }
    A.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function O(T, I) {
        var P = new Error("write after end");
        T.emit("error", P), e.nextTick(I, P);
    }
    function N(T, I, P, k) {
        var L = !0, j = !1;
        return P === null ? j = new TypeError("May not write null values to stream") : typeof P != "string" && P !== void 0 && !I.objectMode && (j = new TypeError("Invalid non-string/buffer chunk")), j && (T.emit("error", j), e.nextTick(k, j), L = !1), L;
    }
    A.prototype.write = function(T, I, P) {
        var k = this._writableState, L = !1, j = !k.objectMode && c(T);
        return j && !a.isBuffer(T) && (T = f(T)), typeof I == "function" && (P = I, I = null), j ? I = "buffer" : I || (I = k.defaultEncoding), typeof P != "function" && (P = p), k.ended ? O(this, P) : (j || N(this, k, T, P)) && (k.pendingcb++, L = D(this, k, j, T, I, P)), L;
    }, A.prototype.cork = function() {
        var T = this._writableState;
        T.corked++;
    }, A.prototype.uncork = function() {
        var T = this._writableState;
        T.corked && (T.corked--, !T.writing && !T.corked && !T.bufferProcessing && T.bufferedRequest && X(this, T));
    }, A.prototype.setDefaultEncoding = function(I) {
        if (typeof I == "string" && (I = I.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((I + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + I);
        return this._writableState.defaultEncoding = I, this;
    };
    function U(T, I, P) {
        return !T.objectMode && T.decodeStrings !== !1 && typeof I == "string" && (I = a.from(I, P)), I;
    }
    Object.defineProperty(A.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function D(T, I, P, k, L, j) {
        if (!P) {
            var ie = U(I, k, L);
            k !== ie && (P = !0, L = "buffer", k = ie);
        }
        var ue = I.objectMode ? 1 : k.length;
        I.length += ue;
        var ce = I.length < I.highWaterMark;
        if (ce || (I.needDrain = !0), I.writing || I.corked) {
            var he = I.lastBufferedRequest;
            I.lastBufferedRequest = {
                chunk: k,
                encoding: L,
                isBuf: P,
                callback: j,
                next: null
            }, he ? he.next = I.lastBufferedRequest : I.bufferedRequest = I.lastBufferedRequest, I.bufferedRequestCount += 1;
        } else H(T, I, !1, ue, k, L, j);
        return ce;
    }
    function H(T, I, P, k, L, j, ie) {
        I.writelen = k, I.writecb = ie, I.writing = !0, I.sync = !0, P ? T._writev(L, I.onwrite) : T._write(L, j, I.onwrite), I.sync = !1;
    }
    function K(T, I, P, k, L) {
        --I.pendingcb, P ? (e.nextTick(L, k), e.nextTick(g, T, I), T._writableState.errorEmitted = !0, T.emit("error", k)) : (L(k), T._writableState.errorEmitted = !0, T.emit("error", k), g(T, I));
    }
    function re(T) {
        T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0;
    }
    function Q(T, I) {
        var P = T._writableState, k = P.sync, L = P.writecb;
        if (re(P), I) K(T, P, k, I, L);
        else {
            var j = $(P);
            !j && !P.corked && !P.bufferProcessing && P.bufferedRequest && X(T, P), k ? r(G, T, P, j, L) : G(T, P, j, L);
        }
    }
    function G(T, I, P, k) {
        P || R(T, I), I.pendingcb--, k(), g(T, I);
    }
    function R(T, I) {
        I.length === 0 && I.needDrain && (I.needDrain = !1, T.emit("drain"));
    }
    function X(T, I) {
        I.bufferProcessing = !0;
        var P = I.bufferedRequest;
        if (T._writev && P && P.next) {
            var k = I.bufferedRequestCount, L = new Array(k), j = I.corkedRequestsFree;
            j.entry = P;
            for(var ie = 0, ue = !0; P;)L[ie] = P, P.isBuf || (ue = !1), P = P.next, ie += 1;
            L.allBuffers = ue, H(T, I, !0, I.length, L, "", j.finish), I.pendingcb++, I.lastBufferedRequest = null, j.next ? (I.corkedRequestsFree = j.next, j.next = null) : I.corkedRequestsFree = new t(I), I.bufferedRequestCount = 0;
        } else {
            for(; P;){
                var ce = P.chunk, he = P.encoding, ee = P.callback, ae = I.objectMode ? 1 : ce.length;
                if (H(T, I, !1, ae, ce, he, ee), P = P.next, I.bufferedRequestCount--, I.writing) break;
            }
            P === null && (I.lastBufferedRequest = null);
        }
        I.bufferedRequest = P, I.bufferProcessing = !1;
    }
    A.prototype._write = function(T, I, P) {
        P(new Error("_write() is not implemented"));
    }, A.prototype._writev = null, A.prototype.end = function(T, I, P) {
        var k = this._writableState;
        typeof T == "function" ? (P = T, T = null, I = null) : typeof I == "function" && (P = I, I = null), T != null && this.write(T, I), k.corked && (k.corked = 1, this.uncork()), k.ending || m(this, k, P);
    };
    function $(T) {
        return T.ending && T.length === 0 && T.bufferedRequest === null && !T.finished && !T.writing;
    }
    function S(T, I) {
        T._final(function(P) {
            I.pendingcb--, P && T.emit("error", P), I.prefinished = !0, T.emit("prefinish"), g(T, I);
        });
    }
    function w(T, I) {
        !I.prefinished && !I.finalCalled && (typeof T._final == "function" ? (I.pendingcb++, I.finalCalled = !0, e.nextTick(S, T, I)) : (I.prefinished = !0, T.emit("prefinish")));
    }
    function g(T, I) {
        var P = $(I);
        return P && (w(T, I), I.pendingcb === 0 && (I.finished = !0, T.emit("finish"))), P;
    }
    function m(T, I, P) {
        I.ending = !0, g(T, I), P && (I.finished ? e.nextTick(P) : T.once("finish", P)), I.ended = !0, T.writable = !1;
    }
    function E(T, I, P) {
        var k = T.entry;
        for(T.entry = null; k;){
            var L = k.callback;
            I.pendingcb--, L(P), k = k.next;
        }
        I.corkedRequestsFree.next = T;
    }
    return Object.defineProperty(A.prototype, "destroyed", {
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(T) {
            this._writableState && (this._writableState.destroyed = T);
        }
    }), A.prototype.destroy = l.destroy, A.prototype._undestroy = l.undestroy, A.prototype._destroy = function(T, I) {
        this.end(), I(T);
    }, n2;
}
var i2, U5;
function rd() {
    if (U5) return i2;
    U5 = 1;
    var e = Sb(), t = Object.keys || function(l) {
        var p = [];
        for(var y in l)p.push(y);
        return p;
    };
    i2 = u;
    var r = Object.create(o0());
    r.inherits = Or();
    var n = TO(), i = AO();
    r.inherits(u, n);
    for(var o = t(i.prototype), s = 0; s < o.length; s++){
        var a = o[s];
        u.prototype[a] || (u.prototype[a] = i.prototype[a]);
    }
    function u(l) {
        if (!(this instanceof u)) return new u(l);
        n.call(this, l), i.call(this, l), l && l.readable === !1 && (this.readable = !1), l && l.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, l && l.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", f);
    }
    Object.defineProperty(u.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function f() {
        this.allowHalfOpen || this._writableState.ended || e.nextTick(c, this);
    }
    function c(l) {
        l.end();
    }
    return Object.defineProperty(u.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(l) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
        }
    }), u.prototype._destroy = function(l, p) {
        this.push(null), this.end(), e.nextTick(p, l);
    }, i2;
}
var o2 = {}, $5;
function L5() {
    if ($5) return o2;
    $5 = 1;
    var e = Ab().Buffer, t = e.isEncoding || function(N) {
        switch(N = "" + N, N && N.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function r(N) {
        if (!N) return "utf8";
        for(var U;;)switch(N){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return N;
            default:
                if (U) return;
                N = ("" + N).toLowerCase(), U = !0;
        }
    }
    function n(N) {
        var U = r(N);
        if (typeof U != "string" && (e.isEncoding === t || !t(N))) throw new Error("Unknown encoding: " + N);
        return U || N;
    }
    o2.StringDecoder = i;
    function i(N) {
        this.encoding = n(N);
        var U;
        switch(this.encoding){
            case "utf16le":
                this.text = l, this.end = p, U = 4;
                break;
            case "utf8":
                this.fillLast = u, U = 4;
                break;
            case "base64":
                this.text = y, this.end = _, U = 3;
                break;
            default:
                this.write = A, this.end = O;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(U);
    }
    i.prototype.write = function(N) {
        if (N.length === 0) return "";
        var U, D;
        if (this.lastNeed) {
            if (U = this.fillLast(N), U === void 0) return "";
            D = this.lastNeed, this.lastNeed = 0;
        } else D = 0;
        return D < N.length ? U ? U + this.text(N, D) : this.text(N, D) : U || "";
    }, i.prototype.end = c, i.prototype.text = f, i.prototype.fillLast = function(N) {
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, N.length), this.lastNeed -= N.length;
    };
    function o(N) {
        return N <= 127 ? 0 : N >> 5 === 6 ? 2 : N >> 4 === 14 ? 3 : N >> 3 === 30 ? 4 : N >> 6 === 2 ? -1 : -2;
    }
    function s(N, U, D) {
        var H = U.length - 1;
        if (H < D) return 0;
        var K = o(U[H]);
        return K >= 0 ? (K > 0 && (N.lastNeed = K - 1), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (N.lastNeed = K - 2), K) : --H < D || K === -2 ? 0 : (K = o(U[H]), K >= 0 ? (K > 0 && (K === 2 ? K = 0 : N.lastNeed = K - 3), K) : 0));
    }
    function a(N, U, D) {
        if ((U[0] & 192) !== 128) return N.lastNeed = 0, "";
        if (N.lastNeed > 1 && U.length > 1) {
            if ((U[1] & 192) !== 128) return N.lastNeed = 1, "";
            if (N.lastNeed > 2 && U.length > 2 && (U[2] & 192) !== 128) return N.lastNeed = 2, "";
        }
    }
    function u(N) {
        var U = this.lastTotal - this.lastNeed, D = a(this, N);
        if (D !== void 0) return D;
        if (this.lastNeed <= N.length) return N.copy(this.lastChar, U, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        N.copy(this.lastChar, U, 0, N.length), this.lastNeed -= N.length;
    }
    function f(N, U) {
        var D = s(this, N, U);
        if (!this.lastNeed) return N.toString("utf8", U);
        this.lastTotal = D;
        var H = N.length - (D - this.lastNeed);
        return N.copy(this.lastChar, 0, H), N.toString("utf8", U, H);
    }
    function c(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + "" : U;
    }
    function l(N, U) {
        if ((N.length - U) % 2 === 0) {
            var D = N.toString("utf16le", U);
            if (D) {
                var H = D.charCodeAt(D.length - 1);
                if (H >= 55296 && H <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1], D.slice(0, -1);
            }
            return D;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = N[N.length - 1], N.toString("utf16le", U, N.length - 1);
    }
    function p(N) {
        var U = N && N.length ? this.write(N) : "";
        if (this.lastNeed) {
            var D = this.lastTotal - this.lastNeed;
            return U + this.lastChar.toString("utf16le", 0, D);
        }
        return U;
    }
    function y(N, U) {
        var D = (N.length - U) % 3;
        return D === 0 ? N.toString("base64", U) : (this.lastNeed = 3 - D, this.lastTotal = 3, D === 1 ? this.lastChar[0] = N[N.length - 1] : (this.lastChar[0] = N[N.length - 2], this.lastChar[1] = N[N.length - 1]), N.toString("base64", U, N.length - D));
    }
    function _(N) {
        var U = N && N.length ? this.write(N) : "";
        return this.lastNeed ? U + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : U;
    }
    function A(N) {
        return N.toString(this.encoding);
    }
    function O(N) {
        return N && N.length ? this.write(N) : "";
    }
    return o2;
}
var s2, D5;
function TO() {
    if (D5) return s2;
    D5 = 1;
    var e = Sb();
    s2 = U;
    var t = cX(), r;
    U.ReadableState = N, EO().EventEmitter;
    var n = function(ee, ae) {
        return ee.listeners(ae).length;
    }, i = xO(), o = Ab().Buffer, s = (typeof Ge < "u" ? Ge : ("TURBOPACK compile-time value", "undefined") < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function a(ee) {
        return o.from(ee);
    }
    function u(ee) {
        return o.isBuffer(ee) || ee instanceof s;
    }
    var f = Object.create(o0());
    f.inherits = Or();
    var c = Iu, l = void 0;
    c && c.debuglog ? l = c.debuglog("stream") : l = function() {};
    var p = uX(), y = SO(), _;
    f.inherits(U, i);
    var A = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function O(ee, ae, ye) {
        if (typeof ee.prependListener == "function") return ee.prependListener(ae, ye);
        !ee._events || !ee._events[ae] ? ee.on(ae, ye) : t(ee._events[ae]) ? ee._events[ae].unshift(ye) : ee._events[ae] = [
            ye,
            ee._events[ae]
        ];
    }
    function N(ee, ae) {
        r = r || rd(), ee = ee || {};
        var ye = ae instanceof r;
        this.objectMode = !!ee.objectMode, ye && (this.objectMode = this.objectMode || !!ee.readableObjectMode);
        var Se = ee.highWaterMark, De = ee.readableHighWaterMark, Re = this.objectMode ? 16 : 16 * 1024;
        Se || Se === 0 ? this.highWaterMark = Se : ye && (De || De === 0) ? this.highWaterMark = De : this.highWaterMark = Re, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = ee.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ee.encoding && (_ || (_ = L5().StringDecoder), this.decoder = new _(ee.encoding), this.encoding = ee.encoding);
    }
    function U(ee) {
        if (r = r || rd(), !(this instanceof U)) return new U(ee);
        this._readableState = new N(ee, this), this.readable = !0, ee && (typeof ee.read == "function" && (this._read = ee.read), typeof ee.destroy == "function" && (this._destroy = ee.destroy)), i.call(this);
    }
    Object.defineProperty(U.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(ee) {
            this._readableState && (this._readableState.destroyed = ee);
        }
    }), U.prototype.destroy = y.destroy, U.prototype._undestroy = y.undestroy, U.prototype._destroy = function(ee, ae) {
        this.push(null), ae(ee);
    }, U.prototype.push = function(ee, ae) {
        var ye = this._readableState, Se;
        return ye.objectMode ? Se = !0 : typeof ee == "string" && (ae = ae || ye.defaultEncoding, ae !== ye.encoding && (ee = o.from(ee, ae), ae = ""), Se = !0), D(this, ee, ae, !1, Se);
    }, U.prototype.unshift = function(ee) {
        return D(this, ee, null, !0, !1);
    };
    function D(ee, ae, ye, Se, De) {
        var Re = ee._readableState;
        if (ae === null) Re.reading = !1, X(ee, Re);
        else {
            var Ce;
            De || (Ce = K(Re, ae)), Ce ? ee.emit("error", Ce) : Re.objectMode || ae && ae.length > 0 ? (typeof ae != "string" && !Re.objectMode && Object.getPrototypeOf(ae) !== o.prototype && (ae = a(ae)), Se ? Re.endEmitted ? ee.emit("error", new Error("stream.unshift() after end event")) : H(ee, Re, ae, !0) : Re.ended ? ee.emit("error", new Error("stream.push() after EOF")) : (Re.reading = !1, Re.decoder && !ye ? (ae = Re.decoder.write(ae), Re.objectMode || ae.length !== 0 ? H(ee, Re, ae, !1) : w(ee, Re)) : H(ee, Re, ae, !1))) : Se || (Re.reading = !1);
        }
        return re(Re);
    }
    function H(ee, ae, ye, Se) {
        ae.flowing && ae.length === 0 && !ae.sync ? (ee.emit("data", ye), ee.read(0)) : (ae.length += ae.objectMode ? 1 : ye.length, Se ? ae.buffer.unshift(ye) : ae.buffer.push(ye), ae.needReadable && $(ee)), w(ee, ae);
    }
    function K(ee, ae) {
        var ye;
        return !u(ae) && typeof ae != "string" && ae !== void 0 && !ee.objectMode && (ye = new TypeError("Invalid non-string/buffer chunk")), ye;
    }
    function re(ee) {
        return !ee.ended && (ee.needReadable || ee.length < ee.highWaterMark || ee.length === 0);
    }
    U.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    }, U.prototype.setEncoding = function(ee) {
        return _ || (_ = L5().StringDecoder), this._readableState.decoder = new _(ee), this._readableState.encoding = ee, this;
    };
    var Q = 8388608;
    function G(ee) {
        return ee >= Q ? ee = Q : (ee--, ee |= ee >>> 1, ee |= ee >>> 2, ee |= ee >>> 4, ee |= ee >>> 8, ee |= ee >>> 16, ee++), ee;
    }
    function R(ee, ae) {
        return ee <= 0 || ae.length === 0 && ae.ended ? 0 : ae.objectMode ? 1 : ee !== ee ? ae.flowing && ae.length ? ae.buffer.head.data.length : ae.length : (ee > ae.highWaterMark && (ae.highWaterMark = G(ee)), ee <= ae.length ? ee : ae.ended ? ae.length : (ae.needReadable = !0, 0));
    }
    U.prototype.read = function(ee) {
        l("read", ee), ee = parseInt(ee, 10);
        var ae = this._readableState, ye = ee;
        if (ee !== 0 && (ae.emittedReadable = !1), ee === 0 && ae.needReadable && (ae.length >= ae.highWaterMark || ae.ended)) return l("read: emitReadable", ae.length, ae.ended), ae.length === 0 && ae.ended ? ue(this) : $(this), null;
        if (ee = R(ee, ae), ee === 0 && ae.ended) return ae.length === 0 && ue(this), null;
        var Se = ae.needReadable;
        l("need readable", Se), (ae.length === 0 || ae.length - ee < ae.highWaterMark) && (Se = !0, l("length less than watermark", Se)), ae.ended || ae.reading ? (Se = !1, l("reading or ended", Se)) : Se && (l("do read"), ae.reading = !0, ae.sync = !0, ae.length === 0 && (ae.needReadable = !0), this._read(ae.highWaterMark), ae.sync = !1, ae.reading || (ee = R(ye, ae)));
        var De;
        return ee > 0 ? De = k(ee, ae) : De = null, De === null ? (ae.needReadable = !0, ee = 0) : ae.length -= ee, ae.length === 0 && (ae.ended || (ae.needReadable = !0), ye !== ee && ae.ended && ue(this)), De !== null && this.emit("data", De), De;
    };
    function X(ee, ae) {
        if (!ae.ended) {
            if (ae.decoder) {
                var ye = ae.decoder.end();
                ye && ye.length && (ae.buffer.push(ye), ae.length += ae.objectMode ? 1 : ye.length);
            }
            ae.ended = !0, $(ee);
        }
    }
    function $(ee) {
        var ae = ee._readableState;
        ae.needReadable = !1, ae.emittedReadable || (l("emitReadable", ae.flowing), ae.emittedReadable = !0, ae.sync ? e.nextTick(S, ee) : S(ee));
    }
    function S(ee) {
        l("emit readable"), ee.emit("readable"), P(ee);
    }
    function w(ee, ae) {
        ae.readingMore || (ae.readingMore = !0, e.nextTick(g, ee, ae));
    }
    function g(ee, ae) {
        for(var ye = ae.length; !ae.reading && !ae.flowing && !ae.ended && ae.length < ae.highWaterMark && (l("maybeReadMore read 0"), ee.read(0), ye !== ae.length);)ye = ae.length;
        ae.readingMore = !1;
    }
    U.prototype._read = function(ee) {
        this.emit("error", new Error("_read() is not implemented"));
    }, U.prototype.pipe = function(ee, ae) {
        var ye = this, Se = this._readableState;
        switch(Se.pipesCount){
            case 0:
                Se.pipes = ee;
                break;
            case 1:
                Se.pipes = [
                    Se.pipes,
                    ee
                ];
                break;
            default:
                Se.pipes.push(ee);
                break;
        }
        Se.pipesCount += 1, l("pipe count=%d opts=%j", Se.pipesCount, ae);
        var De = (!ae || ae.end !== !1) && ee !== bn.stdout && ee !== bn.stderr, Re = De ? M : x;
        Se.endEmitted ? e.nextTick(Re) : ye.once("end", Re), ee.on("unpipe", Ce);
        function Ce(q, te) {
            l("onunpipe"), q === ye && te && te.hasUnpiped === !1 && (te.hasUnpiped = !0, _e());
        }
        function M() {
            l("onend"), ee.end();
        }
        var z = m(ye);
        ee.on("drain", z);
        var de = !1;
        function _e() {
            l("cleanup"), ee.removeListener("close", Ue), ee.removeListener("finish", h), ee.removeListener("drain", z), ee.removeListener("error", Ke), ee.removeListener("unpipe", Ce), ye.removeListener("end", M), ye.removeListener("end", x), ye.removeListener("data", je), de = !0, Se.awaitDrain && (!ee._writableState || ee._writableState.needDrain) && z();
        }
        var Ie = !1;
        ye.on("data", je);
        function je(q) {
            l("ondata"), Ie = !1;
            var te = ee.write(q);
            te === !1 && !Ie && ((Se.pipesCount === 1 && Se.pipes === ee || Se.pipesCount > 1 && he(Se.pipes, ee) !== -1) && !de && (l("false write response, pause", Se.awaitDrain), Se.awaitDrain++, Ie = !0), ye.pause());
        }
        function Ke(q) {
            l("onerror", q), x(), ee.removeListener("error", Ke), n(ee, "error") === 0 && ee.emit("error", q);
        }
        O(ee, "error", Ke);
        function Ue() {
            ee.removeListener("finish", h), x();
        }
        ee.once("close", Ue);
        function h() {
            l("onfinish"), ee.removeListener("close", Ue), x();
        }
        ee.once("finish", h);
        function x() {
            l("unpipe"), ye.unpipe(ee);
        }
        return ee.emit("pipe", ye), Se.flowing || (l("pipe resume"), ye.resume()), ee;
    };
    function m(ee) {
        return function() {
            var ae = ee._readableState;
            l("pipeOnDrain", ae.awaitDrain), ae.awaitDrain && ae.awaitDrain--, ae.awaitDrain === 0 && n(ee, "data") && (ae.flowing = !0, P(ee));
        };
    }
    U.prototype.unpipe = function(ee) {
        var ae = this._readableState, ye = {
            hasUnpiped: !1
        };
        if (ae.pipesCount === 0) return this;
        if (ae.pipesCount === 1) return ee && ee !== ae.pipes ? this : (ee || (ee = ae.pipes), ae.pipes = null, ae.pipesCount = 0, ae.flowing = !1, ee && ee.emit("unpipe", this, ye), this);
        if (!ee) {
            var Se = ae.pipes, De = ae.pipesCount;
            ae.pipes = null, ae.pipesCount = 0, ae.flowing = !1;
            for(var Re = 0; Re < De; Re++)Se[Re].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var Ce = he(ae.pipes, ee);
        return Ce === -1 ? this : (ae.pipes.splice(Ce, 1), ae.pipesCount -= 1, ae.pipesCount === 1 && (ae.pipes = ae.pipes[0]), ee.emit("unpipe", this, ye), this);
    }, U.prototype.on = function(ee, ae) {
        var ye = i.prototype.on.call(this, ee, ae);
        if (ee === "data") this._readableState.flowing !== !1 && this.resume();
        else if (ee === "readable") {
            var Se = this._readableState;
            !Se.endEmitted && !Se.readableListening && (Se.readableListening = Se.needReadable = !0, Se.emittedReadable = !1, Se.reading ? Se.length && $(this) : e.nextTick(E, this));
        }
        return ye;
    }, U.prototype.addListener = U.prototype.on;
    function E(ee) {
        l("readable nexttick read 0"), ee.read(0);
    }
    U.prototype.resume = function() {
        var ee = this._readableState;
        return ee.flowing || (l("resume"), ee.flowing = !0, T(this, ee)), this;
    };
    function T(ee, ae) {
        ae.resumeScheduled || (ae.resumeScheduled = !0, e.nextTick(I, ee, ae));
    }
    function I(ee, ae) {
        ae.reading || (l("resume read 0"), ee.read(0)), ae.resumeScheduled = !1, ae.awaitDrain = 0, ee.emit("resume"), P(ee), ae.flowing && !ae.reading && ee.read(0);
    }
    U.prototype.pause = function() {
        return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    };
    function P(ee) {
        var ae = ee._readableState;
        for(l("flow", ae.flowing); ae.flowing && ee.read() !== null;);
    }
    U.prototype.wrap = function(ee) {
        var ae = this, ye = this._readableState, Se = !1;
        ee.on("end", function() {
            if (l("wrapped end"), ye.decoder && !ye.ended) {
                var Ce = ye.decoder.end();
                Ce && Ce.length && ae.push(Ce);
            }
            ae.push(null);
        }), ee.on("data", function(Ce) {
            if (l("wrapped data"), ye.decoder && (Ce = ye.decoder.write(Ce)), !(ye.objectMode && Ce == null) && !(!ye.objectMode && (!Ce || !Ce.length))) {
                var M = ae.push(Ce);
                M || (Se = !0, ee.pause());
            }
        });
        for(var De in ee)this[De] === void 0 && typeof ee[De] == "function" && (this[De] = /* @__PURE__ */ function(Ce) {
            return function() {
                return ee[Ce].apply(ee, arguments);
            };
        }(De));
        for(var Re = 0; Re < A.length; Re++)ee.on(A[Re], this.emit.bind(this, A[Re]));
        return this._read = function(Ce) {
            l("wrapped _read", Ce), Se && (Se = !1, ee.resume());
        }, this;
    }, Object.defineProperty(U.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    }), U._fromList = k;
    function k(ee, ae) {
        if (ae.length === 0) return null;
        var ye;
        return ae.objectMode ? ye = ae.buffer.shift() : !ee || ee >= ae.length ? (ae.decoder ? ye = ae.buffer.join("") : ae.buffer.length === 1 ? ye = ae.buffer.head.data : ye = ae.buffer.concat(ae.length), ae.buffer.clear()) : ye = L(ee, ae.buffer, ae.decoder), ye;
    }
    function L(ee, ae, ye) {
        var Se;
        return ee < ae.head.data.length ? (Se = ae.head.data.slice(0, ee), ae.head.data = ae.head.data.slice(ee)) : ee === ae.head.data.length ? Se = ae.shift() : Se = ye ? j(ee, ae) : ie(ee, ae), Se;
    }
    function j(ee, ae) {
        var ye = ae.head, Se = 1, De = ye.data;
        for(ee -= De.length; ye = ye.next;){
            var Re = ye.data, Ce = ee > Re.length ? Re.length : ee;
            if (Ce === Re.length ? De += Re : De += Re.slice(0, ee), ee -= Ce, ee === 0) {
                Ce === Re.length ? (++Se, ye.next ? ae.head = ye.next : ae.head = ae.tail = null) : (ae.head = ye, ye.data = Re.slice(Ce));
                break;
            }
            ++Se;
        }
        return ae.length -= Se, De;
    }
    function ie(ee, ae) {
        var ye = o.allocUnsafe(ee), Se = ae.head, De = 1;
        for(Se.data.copy(ye), ee -= Se.data.length; Se = Se.next;){
            var Re = Se.data, Ce = ee > Re.length ? Re.length : ee;
            if (Re.copy(ye, ye.length - ee, 0, Ce), ee -= Ce, ee === 0) {
                Ce === Re.length ? (++De, Se.next ? ae.head = Se.next : ae.head = ae.tail = null) : (ae.head = Se, Se.data = Re.slice(Ce));
                break;
            }
            ++De;
        }
        return ae.length -= De, ye;
    }
    function ue(ee) {
        var ae = ee._readableState;
        if (ae.length > 0) throw new Error('"endReadable()" called on non-empty stream');
        ae.endEmitted || (ae.ended = !0, e.nextTick(ce, ae, ee));
    }
    function ce(ee, ae) {
        !ee.endEmitted && ee.length === 0 && (ee.endEmitted = !0, ae.readable = !1, ae.emit("end"));
    }
    function he(ee, ae) {
        for(var ye = 0, Se = ee.length; ye < Se; ye++)if (ee[ye] === ae) return ye;
        return -1;
    }
    return s2;
}
var a2, F5;
function kO() {
    if (F5) return a2;
    F5 = 1, a2 = n;
    var e = rd(), t = Object.create(o0());
    t.inherits = Or(), t.inherits(n, e);
    function r(s, a) {
        var u = this._transformState;
        u.transforming = !1;
        var f = u.writecb;
        if (!f) return this.emit("error", new Error("write callback called multiple times"));
        u.writechunk = null, u.writecb = null, a != null && this.push(a), f(s);
        var c = this._readableState;
        c.reading = !1, (c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
    }
    function n(s) {
        if (!(this instanceof n)) return new n(s);
        e.call(this, s), this._transformState = {
            afterTransform: r.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", i);
    }
    function i() {
        var s = this;
        typeof this._flush == "function" ? this._flush(function(a, u) {
            o(s, a, u);
        }) : o(this, null, null);
    }
    n.prototype.push = function(s, a) {
        return this._transformState.needTransform = !1, e.prototype.push.call(this, s, a);
    }, n.prototype._transform = function(s, a, u) {
        throw new Error("_transform() is not implemented");
    }, n.prototype._write = function(s, a, u) {
        var f = this._transformState;
        if (f.writecb = u, f.writechunk = s, f.writeencoding = a, !f.transforming) {
            var c = this._readableState;
            (f.needTransform || c.needReadable || c.length < c.highWaterMark) && this._read(c.highWaterMark);
        }
    }, n.prototype._read = function(s) {
        var a = this._transformState;
        a.writechunk !== null && a.writecb && !a.transforming ? (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)) : a.needTransform = !0;
    }, n.prototype._destroy = function(s, a) {
        var u = this;
        e.prototype._destroy.call(this, s, function(f) {
            a(f), u.emit("close");
        });
    };
    function o(s, a, u) {
        if (a) return s.emit("error", a);
        if (u != null && s.push(u), s._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (s._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return s.push(null);
    }
    return a2;
}
var c2, z5;
function lX() {
    if (z5) return c2;
    z5 = 1, c2 = r;
    var e = kO(), t = Object.create(o0());
    t.inherits = Or(), t.inherits(r, e);
    function r(n) {
        if (!(this instanceof r)) return new r(n);
        e.call(this, n);
    }
    return r.prototype._transform = function(n, i, o) {
        o(null, n);
    }, c2;
}
var j5;
function dX() {
    return j5 || (j5 = 1, function(e, t) {
        t = e.exports = TO(), t.Stream = t, t.Readable = t, t.Writable = AO(), t.Duplex = rd(), t.Transform = kO(), t.PassThrough = lX();
    }(jg, jg.exports)), jg.exports;
}
var dh = {
    exports: {}
}, Iy = {
    exports: {}
};
Iy.exports;
var H5;
function D3() {
    return H5 || (H5 = 1, function(e) {
        (function(t, r) {
            function n(w, g) {
                if (!w) throw new Error(g || "Assertion failed");
            }
            function i(w, g) {
                w.super_ = g;
                var m = function() {};
                m.prototype = g.prototype, w.prototype = new m(), w.prototype.constructor = w;
            }
            function o(w, g, m) {
                if (o.isBN(w)) return w;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, w !== null && ((g === "le" || g === "be") && (m = g, g = 10), this._init(w || 0, g || 10, m || "be"));
            }
            typeof t == "object" ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
            var s;
            try {
                ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = Iu.Buffer;
            } catch  {}
            o.isBN = function(g) {
                return g instanceof o ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === o.wordSize && Array.isArray(g.words);
            }, o.max = function(g, m) {
                return g.cmp(m) > 0 ? g : m;
            }, o.min = function(g, m) {
                return g.cmp(m) < 0 ? g : m;
            }, o.prototype._init = function(g, m, E) {
                if (typeof g == "number") return this._initNumber(g, m, E);
                if (typeof g == "object") return this._initArray(g, m, E);
                m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), g = g.toString().replace(/\s+/g, "");
                var T = 0;
                g[0] === "-" && (T++, this.negative = 1), T < g.length && (m === 16 ? this._parseHex(g, T, E) : (this._parseBase(g, m, T), E === "le" && this._initArray(this.toArray(), m, E)));
            }, o.prototype._initNumber = function(g, m, E) {
                g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [
                    g & 67108863
                ], this.length = 1) : g < 4503599627370496 ? (this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863
                ], this.length = 2) : (n(g < 9007199254740992), this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863,
                    1
                ], this.length = 3), E === "le" && this._initArray(this.toArray(), m, E);
            }, o.prototype._initArray = function(g, m, E) {
                if (n(typeof g.length == "number"), g.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
                for(var T = 0; T < this.length; T++)this.words[T] = 0;
                var I, P, k = 0;
                if (E === "be") for(T = g.length - 1, I = 0; T >= 0; T -= 3)P = g[T] | g[T - 1] << 8 | g[T - 2] << 16, this.words[I] |= P << k & 67108863, this.words[I + 1] = P >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, I++);
                else if (E === "le") for(T = 0, I = 0; T < g.length; T += 3)P = g[T] | g[T + 1] << 8 | g[T + 2] << 16, this.words[I] |= P << k & 67108863, this.words[I + 1] = P >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, I++);
                return this._strip();
            };
            function a(w, g) {
                var m = w.charCodeAt(g);
                if (m >= 48 && m <= 57) return m - 48;
                if (m >= 65 && m <= 70) return m - 55;
                if (m >= 97 && m <= 102) return m - 87;
                n(!1, "Invalid character in " + w);
            }
            function u(w, g, m) {
                var E = a(w, m);
                return m - 1 >= g && (E |= a(w, m - 1) << 4), E;
            }
            o.prototype._parseHex = function(g, m, E) {
                this.length = Math.ceil((g.length - m) / 6), this.words = new Array(this.length);
                for(var T = 0; T < this.length; T++)this.words[T] = 0;
                var I = 0, P = 0, k;
                if (E === "be") for(T = g.length - 1; T >= m; T -= 2)k = u(g, m, T) << I, this.words[P] |= k & 67108863, I >= 18 ? (I -= 18, P += 1, this.words[P] |= k >>> 26) : I += 8;
                else {
                    var L = g.length - m;
                    for(T = L % 2 === 0 ? m + 1 : m; T < g.length; T += 2)k = u(g, m, T) << I, this.words[P] |= k & 67108863, I >= 18 ? (I -= 18, P += 1, this.words[P] |= k >>> 26) : I += 8;
                }
                this._strip();
            };
            function f(w, g, m, E) {
                for(var T = 0, I = 0, P = Math.min(w.length, m), k = g; k < P; k++){
                    var L = w.charCodeAt(k) - 48;
                    T *= E, L >= 49 ? I = L - 49 + 10 : L >= 17 ? I = L - 17 + 10 : I = L, n(L >= 0 && I < E, "Invalid character"), T += I;
                }
                return T;
            }
            o.prototype._parseBase = function(g, m, E) {
                this.words = [
                    0
                ], this.length = 1;
                for(var T = 0, I = 1; I <= 67108863; I *= m)T++;
                T--, I = I / m | 0;
                for(var P = g.length - E, k = P % T, L = Math.min(P, P - k) + E, j = 0, ie = E; ie < L; ie += T)j = f(g, ie, ie + T, m), this.imuln(I), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
                if (k !== 0) {
                    var ue = 1;
                    for(j = f(g, ie, g.length, m), ie = 0; ie < k; ie++)ue *= m;
                    this.imuln(ue), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
                }
                this._strip();
            }, o.prototype.copy = function(g) {
                g.words = new Array(this.length);
                for(var m = 0; m < this.length; m++)g.words[m] = this.words[m];
                g.length = this.length, g.negative = this.negative, g.red = this.red;
            };
            function c(w, g) {
                w.words = g.words, w.length = g.length, w.negative = g.negative, w.red = g.red;
            }
            if (o.prototype._move = function(g) {
                c(g, this);
            }, o.prototype.clone = function() {
                var g = new o(null);
                return this.copy(g), g;
            }, o.prototype._expand = function(g) {
                for(; this.length < g;)this.words[this.length++] = 0;
                return this;
            }, o.prototype._strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, o.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
                o.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
            } catch  {
                o.prototype.inspect = l;
            }
            else o.prototype.inspect = l;
            function l() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            }
            var p = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], y = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], _ = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            o.prototype.toString = function(g, m) {
                g = g || 10, m = m | 0 || 1;
                var E;
                if (g === 16 || g === "hex") {
                    E = "";
                    for(var T = 0, I = 0, P = 0; P < this.length; P++){
                        var k = this.words[P], L = ((k << T | I) & 16777215).toString(16);
                        I = k >>> 24 - T & 16777215, T += 2, T >= 26 && (T -= 26, P--), I !== 0 || P !== this.length - 1 ? E = p[6 - L.length] + L + E : E = L + E;
                    }
                    for(I !== 0 && (E = I.toString(16) + E); E.length % m !== 0;)E = "0" + E;
                    return this.negative !== 0 && (E = "-" + E), E;
                }
                if (g === (g | 0) && g >= 2 && g <= 36) {
                    var j = y[g], ie = _[g];
                    E = "";
                    var ue = this.clone();
                    for(ue.negative = 0; !ue.isZero();){
                        var ce = ue.modrn(ie).toString(g);
                        ue = ue.idivn(ie), ue.isZero() ? E = ce + E : E = p[j - ce.length] + ce + E;
                    }
                    for(this.isZero() && (E = "0" + E); E.length % m !== 0;)E = "0" + E;
                    return this.negative !== 0 && (E = "-" + E), E;
                }
                n(!1, "Base should be between 2 and 36");
            }, o.prototype.toNumber = function() {
                var g = this.words[0];
                return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
            }, o.prototype.toJSON = function() {
                return this.toString(16, 2);
            }, s && (o.prototype.toBuffer = function(g, m) {
                return this.toArrayLike(s, g, m);
            }), o.prototype.toArray = function(g, m) {
                return this.toArrayLike(Array, g, m);
            };
            var A = function(g, m) {
                return g.allocUnsafe ? g.allocUnsafe(m) : new g(m);
            };
            o.prototype.toArrayLike = function(g, m, E) {
                this._strip();
                var T = this.byteLength(), I = E || Math.max(1, T);
                n(T <= I, "byte array longer than desired length"), n(I > 0, "Requested array length <= 0");
                var P = A(g, I), k = m === "le" ? "LE" : "BE";
                return this["_toArrayLike" + k](P, T), P;
            }, o.prototype._toArrayLikeLE = function(g, m) {
                for(var E = 0, T = 0, I = 0, P = 0; I < this.length; I++){
                    var k = this.words[I] << P | T;
                    g[E++] = k & 255, E < g.length && (g[E++] = k >> 8 & 255), E < g.length && (g[E++] = k >> 16 & 255), P === 6 ? (E < g.length && (g[E++] = k >> 24 & 255), T = 0, P = 0) : (T = k >>> 24, P += 2);
                }
                if (E < g.length) for(g[E++] = T; E < g.length;)g[E++] = 0;
            }, o.prototype._toArrayLikeBE = function(g, m) {
                for(var E = g.length - 1, T = 0, I = 0, P = 0; I < this.length; I++){
                    var k = this.words[I] << P | T;
                    g[E--] = k & 255, E >= 0 && (g[E--] = k >> 8 & 255), E >= 0 && (g[E--] = k >> 16 & 255), P === 6 ? (E >= 0 && (g[E--] = k >> 24 & 255), T = 0, P = 0) : (T = k >>> 24, P += 2);
                }
                if (E >= 0) for(g[E--] = T; E >= 0;)g[E--] = 0;
            }, Math.clz32 ? o.prototype._countBits = function(g) {
                return 32 - Math.clz32(g);
            } : o.prototype._countBits = function(g) {
                var m = g, E = 0;
                return m >= 4096 && (E += 13, m >>>= 13), m >= 64 && (E += 7, m >>>= 7), m >= 8 && (E += 4, m >>>= 4), m >= 2 && (E += 2, m >>>= 2), E + m;
            }, o.prototype._zeroBits = function(g) {
                if (g === 0) return 26;
                var m = g, E = 0;
                return m & 8191 || (E += 13, m >>>= 13), m & 127 || (E += 7, m >>>= 7), m & 15 || (E += 4, m >>>= 4), m & 3 || (E += 2, m >>>= 2), m & 1 || E++, E;
            }, o.prototype.bitLength = function() {
                var g = this.words[this.length - 1], m = this._countBits(g);
                return (this.length - 1) * 26 + m;
            };
            function O(w) {
                for(var g = new Array(w.bitLength()), m = 0; m < g.length; m++){
                    var E = m / 26 | 0, T = m % 26;
                    g[m] = w.words[E] >>> T & 1;
                }
                return g;
            }
            o.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var g = 0, m = 0; m < this.length; m++){
                    var E = this._zeroBits(this.words[m]);
                    if (g += E, E !== 26) break;
                }
                return g;
            }, o.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, o.prototype.toTwos = function(g) {
                return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
            }, o.prototype.fromTwos = function(g) {
                return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
            }, o.prototype.isNeg = function() {
                return this.negative !== 0;
            }, o.prototype.neg = function() {
                return this.clone().ineg();
            }, o.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, o.prototype.iuor = function(g) {
                for(; this.length < g.length;)this.words[this.length++] = 0;
                for(var m = 0; m < g.length; m++)this.words[m] = this.words[m] | g.words[m];
                return this._strip();
            }, o.prototype.ior = function(g) {
                return n((this.negative | g.negative) === 0), this.iuor(g);
            }, o.prototype.or = function(g) {
                return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
            }, o.prototype.uor = function(g) {
                return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
            }, o.prototype.iuand = function(g) {
                var m;
                this.length > g.length ? m = g : m = this;
                for(var E = 0; E < m.length; E++)this.words[E] = this.words[E] & g.words[E];
                return this.length = m.length, this._strip();
            }, o.prototype.iand = function(g) {
                return n((this.negative | g.negative) === 0), this.iuand(g);
            }, o.prototype.and = function(g) {
                return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
            }, o.prototype.uand = function(g) {
                return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
            }, o.prototype.iuxor = function(g) {
                var m, E;
                this.length > g.length ? (m = this, E = g) : (m = g, E = this);
                for(var T = 0; T < E.length; T++)this.words[T] = m.words[T] ^ E.words[T];
                if (this !== m) for(; T < m.length; T++)this.words[T] = m.words[T];
                return this.length = m.length, this._strip();
            }, o.prototype.ixor = function(g) {
                return n((this.negative | g.negative) === 0), this.iuxor(g);
            }, o.prototype.xor = function(g) {
                return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
            }, o.prototype.uxor = function(g) {
                return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
            }, o.prototype.inotn = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = Math.ceil(g / 26) | 0, E = g % 26;
                this._expand(m), E > 0 && m--;
                for(var T = 0; T < m; T++)this.words[T] = ~this.words[T] & 67108863;
                return E > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - E), this._strip();
            }, o.prototype.notn = function(g) {
                return this.clone().inotn(g);
            }, o.prototype.setn = function(g, m) {
                n(typeof g == "number" && g >= 0);
                var E = g / 26 | 0, T = g % 26;
                return this._expand(E + 1), m ? this.words[E] = this.words[E] | 1 << T : this.words[E] = this.words[E] & ~(1 << T), this._strip();
            }, o.prototype.iadd = function(g) {
                var m;
                if (this.negative !== 0 && g.negative === 0) return this.negative = 0, m = this.isub(g), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && g.negative !== 0) return g.negative = 0, m = this.isub(g), g.negative = 1, m._normSign();
                var E, T;
                this.length > g.length ? (E = this, T = g) : (E = g, T = this);
                for(var I = 0, P = 0; P < T.length; P++)m = (E.words[P] | 0) + (T.words[P] | 0) + I, this.words[P] = m & 67108863, I = m >>> 26;
                for(; I !== 0 && P < E.length; P++)m = (E.words[P] | 0) + I, this.words[P] = m & 67108863, I = m >>> 26;
                if (this.length = E.length, I !== 0) this.words[this.length] = I, this.length++;
                else if (E !== this) for(; P < E.length; P++)this.words[P] = E.words[P];
                return this;
            }, o.prototype.add = function(g) {
                var m;
                return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, m = this.sub(g), g.negative ^= 1, m) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = g.sub(this), this.negative = 1, m) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
            }, o.prototype.isub = function(g) {
                if (g.negative !== 0) {
                    g.negative = 0;
                    var m = this.iadd(g);
                    return g.negative = 1, m._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
                var E = this.cmp(g);
                if (E === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var T, I;
                E > 0 ? (T = this, I = g) : (T = g, I = this);
                for(var P = 0, k = 0; k < I.length; k++)m = (T.words[k] | 0) - (I.words[k] | 0) + P, P = m >> 26, this.words[k] = m & 67108863;
                for(; P !== 0 && k < T.length; k++)m = (T.words[k] | 0) + P, P = m >> 26, this.words[k] = m & 67108863;
                if (P === 0 && k < T.length && T !== this) for(; k < T.length; k++)this.words[k] = T.words[k];
                return this.length = Math.max(this.length, k), T !== this && (this.negative = 1), this._strip();
            }, o.prototype.sub = function(g) {
                return this.clone().isub(g);
            };
            function N(w, g, m) {
                m.negative = g.negative ^ w.negative;
                var E = w.length + g.length | 0;
                m.length = E, E = E - 1 | 0;
                var T = w.words[0] | 0, I = g.words[0] | 0, P = T * I, k = P & 67108863, L = P / 67108864 | 0;
                m.words[0] = k;
                for(var j = 1; j < E; j++){
                    for(var ie = L >>> 26, ue = L & 67108863, ce = Math.min(j, g.length - 1), he = Math.max(0, j - w.length + 1); he <= ce; he++){
                        var ee = j - he | 0;
                        T = w.words[ee] | 0, I = g.words[he] | 0, P = T * I + ue, ie += P / 67108864 | 0, ue = P & 67108863;
                    }
                    m.words[j] = ue | 0, L = ie | 0;
                }
                return L !== 0 ? m.words[j] = L | 0 : m.length--, m._strip();
            }
            var U = function(g, m, E) {
                var T = g.words, I = m.words, P = E.words, k = 0, L, j, ie, ue = T[0] | 0, ce = ue & 8191, he = ue >>> 13, ee = T[1] | 0, ae = ee & 8191, ye = ee >>> 13, Se = T[2] | 0, De = Se & 8191, Re = Se >>> 13, Ce = T[3] | 0, M = Ce & 8191, z = Ce >>> 13, de = T[4] | 0, _e = de & 8191, Ie = de >>> 13, je = T[5] | 0, Ke = je & 8191, Ue = je >>> 13, h = T[6] | 0, x = h & 8191, q = h >>> 13, te = T[7] | 0, fe = te & 8191, ne = te >>> 13, W = T[8] | 0, J = W & 8191, V = W >>> 13, C = T[9] | 0, Z = C & 8191, le = C >>> 13, se = I[0] | 0, Ne = se & 8191, Le = se >>> 13, rt = I[1] | 0, yt = rt & 8191, _t = rt >>> 13, Qe = I[2] | 0, Rt = Qe & 8191, Lt = Qe >>> 13, Ur = I[3] | 0, jr = Ur & 8191, Et = Ur >>> 13, Xt = I[4] | 0, wr = Xt & 8191, zt = Xt >>> 13, Ae = I[5] | 0, we = Ae & 8191, xe = Ae >>> 13, Me = I[6] | 0, ze = Me & 8191, Ve = Me >>> 13, at = I[7] | 0, ct = at & 8191, lt = at >>> 13, mt = I[8] | 0, wt = mt & 8191, bt = mt >>> 13, Mt = I[9] | 0, Ct = Mt & 8191, Xe = Mt >>> 13;
                E.negative = g.negative ^ m.negative, E.length = 19, L = Math.imul(ce, Ne), j = Math.imul(ce, Le), j = j + Math.imul(he, Ne) | 0, ie = Math.imul(he, Le);
                var xt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, L = Math.imul(ae, Ne), j = Math.imul(ae, Le), j = j + Math.imul(ye, Ne) | 0, ie = Math.imul(ye, Le), L = L + Math.imul(ce, yt) | 0, j = j + Math.imul(ce, _t) | 0, j = j + Math.imul(he, yt) | 0, ie = ie + Math.imul(he, _t) | 0;
                var St = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, L = Math.imul(De, Ne), j = Math.imul(De, Le), j = j + Math.imul(Re, Ne) | 0, ie = Math.imul(Re, Le), L = L + Math.imul(ae, yt) | 0, j = j + Math.imul(ae, _t) | 0, j = j + Math.imul(ye, yt) | 0, ie = ie + Math.imul(ye, _t) | 0, L = L + Math.imul(ce, Rt) | 0, j = j + Math.imul(ce, Lt) | 0, j = j + Math.imul(he, Rt) | 0, ie = ie + Math.imul(he, Lt) | 0;
                var Pe = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, L = Math.imul(M, Ne), j = Math.imul(M, Le), j = j + Math.imul(z, Ne) | 0, ie = Math.imul(z, Le), L = L + Math.imul(De, yt) | 0, j = j + Math.imul(De, _t) | 0, j = j + Math.imul(Re, yt) | 0, ie = ie + Math.imul(Re, _t) | 0, L = L + Math.imul(ae, Rt) | 0, j = j + Math.imul(ae, Lt) | 0, j = j + Math.imul(ye, Rt) | 0, ie = ie + Math.imul(ye, Lt) | 0, L = L + Math.imul(ce, jr) | 0, j = j + Math.imul(ce, Et) | 0, j = j + Math.imul(he, jr) | 0, ie = ie + Math.imul(he, Et) | 0;
                var et = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, L = Math.imul(_e, Ne), j = Math.imul(_e, Le), j = j + Math.imul(Ie, Ne) | 0, ie = Math.imul(Ie, Le), L = L + Math.imul(M, yt) | 0, j = j + Math.imul(M, _t) | 0, j = j + Math.imul(z, yt) | 0, ie = ie + Math.imul(z, _t) | 0, L = L + Math.imul(De, Rt) | 0, j = j + Math.imul(De, Lt) | 0, j = j + Math.imul(Re, Rt) | 0, ie = ie + Math.imul(Re, Lt) | 0, L = L + Math.imul(ae, jr) | 0, j = j + Math.imul(ae, Et) | 0, j = j + Math.imul(ye, jr) | 0, ie = ie + Math.imul(ye, Et) | 0, L = L + Math.imul(ce, wr) | 0, j = j + Math.imul(ce, zt) | 0, j = j + Math.imul(he, wr) | 0, ie = ie + Math.imul(he, zt) | 0;
                var vt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, L = Math.imul(Ke, Ne), j = Math.imul(Ke, Le), j = j + Math.imul(Ue, Ne) | 0, ie = Math.imul(Ue, Le), L = L + Math.imul(_e, yt) | 0, j = j + Math.imul(_e, _t) | 0, j = j + Math.imul(Ie, yt) | 0, ie = ie + Math.imul(Ie, _t) | 0, L = L + Math.imul(M, Rt) | 0, j = j + Math.imul(M, Lt) | 0, j = j + Math.imul(z, Rt) | 0, ie = ie + Math.imul(z, Lt) | 0, L = L + Math.imul(De, jr) | 0, j = j + Math.imul(De, Et) | 0, j = j + Math.imul(Re, jr) | 0, ie = ie + Math.imul(Re, Et) | 0, L = L + Math.imul(ae, wr) | 0, j = j + Math.imul(ae, zt) | 0, j = j + Math.imul(ye, wr) | 0, ie = ie + Math.imul(ye, zt) | 0, L = L + Math.imul(ce, we) | 0, j = j + Math.imul(ce, xe) | 0, j = j + Math.imul(he, we) | 0, ie = ie + Math.imul(he, xe) | 0;
                var be = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, L = Math.imul(x, Ne), j = Math.imul(x, Le), j = j + Math.imul(q, Ne) | 0, ie = Math.imul(q, Le), L = L + Math.imul(Ke, yt) | 0, j = j + Math.imul(Ke, _t) | 0, j = j + Math.imul(Ue, yt) | 0, ie = ie + Math.imul(Ue, _t) | 0, L = L + Math.imul(_e, Rt) | 0, j = j + Math.imul(_e, Lt) | 0, j = j + Math.imul(Ie, Rt) | 0, ie = ie + Math.imul(Ie, Lt) | 0, L = L + Math.imul(M, jr) | 0, j = j + Math.imul(M, Et) | 0, j = j + Math.imul(z, jr) | 0, ie = ie + Math.imul(z, Et) | 0, L = L + Math.imul(De, wr) | 0, j = j + Math.imul(De, zt) | 0, j = j + Math.imul(Re, wr) | 0, ie = ie + Math.imul(Re, zt) | 0, L = L + Math.imul(ae, we) | 0, j = j + Math.imul(ae, xe) | 0, j = j + Math.imul(ye, we) | 0, ie = ie + Math.imul(ye, xe) | 0, L = L + Math.imul(ce, ze) | 0, j = j + Math.imul(ce, Ve) | 0, j = j + Math.imul(he, ze) | 0, ie = ie + Math.imul(he, Ve) | 0;
                var $r = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, L = Math.imul(fe, Ne), j = Math.imul(fe, Le), j = j + Math.imul(ne, Ne) | 0, ie = Math.imul(ne, Le), L = L + Math.imul(x, yt) | 0, j = j + Math.imul(x, _t) | 0, j = j + Math.imul(q, yt) | 0, ie = ie + Math.imul(q, _t) | 0, L = L + Math.imul(Ke, Rt) | 0, j = j + Math.imul(Ke, Lt) | 0, j = j + Math.imul(Ue, Rt) | 0, ie = ie + Math.imul(Ue, Lt) | 0, L = L + Math.imul(_e, jr) | 0, j = j + Math.imul(_e, Et) | 0, j = j + Math.imul(Ie, jr) | 0, ie = ie + Math.imul(Ie, Et) | 0, L = L + Math.imul(M, wr) | 0, j = j + Math.imul(M, zt) | 0, j = j + Math.imul(z, wr) | 0, ie = ie + Math.imul(z, zt) | 0, L = L + Math.imul(De, we) | 0, j = j + Math.imul(De, xe) | 0, j = j + Math.imul(Re, we) | 0, ie = ie + Math.imul(Re, xe) | 0, L = L + Math.imul(ae, ze) | 0, j = j + Math.imul(ae, Ve) | 0, j = j + Math.imul(ye, ze) | 0, ie = ie + Math.imul(ye, Ve) | 0, L = L + Math.imul(ce, ct) | 0, j = j + Math.imul(ce, lt) | 0, j = j + Math.imul(he, ct) | 0, ie = ie + Math.imul(he, lt) | 0;
                var jt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, L = Math.imul(J, Ne), j = Math.imul(J, Le), j = j + Math.imul(V, Ne) | 0, ie = Math.imul(V, Le), L = L + Math.imul(fe, yt) | 0, j = j + Math.imul(fe, _t) | 0, j = j + Math.imul(ne, yt) | 0, ie = ie + Math.imul(ne, _t) | 0, L = L + Math.imul(x, Rt) | 0, j = j + Math.imul(x, Lt) | 0, j = j + Math.imul(q, Rt) | 0, ie = ie + Math.imul(q, Lt) | 0, L = L + Math.imul(Ke, jr) | 0, j = j + Math.imul(Ke, Et) | 0, j = j + Math.imul(Ue, jr) | 0, ie = ie + Math.imul(Ue, Et) | 0, L = L + Math.imul(_e, wr) | 0, j = j + Math.imul(_e, zt) | 0, j = j + Math.imul(Ie, wr) | 0, ie = ie + Math.imul(Ie, zt) | 0, L = L + Math.imul(M, we) | 0, j = j + Math.imul(M, xe) | 0, j = j + Math.imul(z, we) | 0, ie = ie + Math.imul(z, xe) | 0, L = L + Math.imul(De, ze) | 0, j = j + Math.imul(De, Ve) | 0, j = j + Math.imul(Re, ze) | 0, ie = ie + Math.imul(Re, Ve) | 0, L = L + Math.imul(ae, ct) | 0, j = j + Math.imul(ae, lt) | 0, j = j + Math.imul(ye, ct) | 0, ie = ie + Math.imul(ye, lt) | 0, L = L + Math.imul(ce, wt) | 0, j = j + Math.imul(ce, bt) | 0, j = j + Math.imul(he, wt) | 0, ie = ie + Math.imul(he, bt) | 0;
                var nr = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, L = Math.imul(Z, Ne), j = Math.imul(Z, Le), j = j + Math.imul(le, Ne) | 0, ie = Math.imul(le, Le), L = L + Math.imul(J, yt) | 0, j = j + Math.imul(J, _t) | 0, j = j + Math.imul(V, yt) | 0, ie = ie + Math.imul(V, _t) | 0, L = L + Math.imul(fe, Rt) | 0, j = j + Math.imul(fe, Lt) | 0, j = j + Math.imul(ne, Rt) | 0, ie = ie + Math.imul(ne, Lt) | 0, L = L + Math.imul(x, jr) | 0, j = j + Math.imul(x, Et) | 0, j = j + Math.imul(q, jr) | 0, ie = ie + Math.imul(q, Et) | 0, L = L + Math.imul(Ke, wr) | 0, j = j + Math.imul(Ke, zt) | 0, j = j + Math.imul(Ue, wr) | 0, ie = ie + Math.imul(Ue, zt) | 0, L = L + Math.imul(_e, we) | 0, j = j + Math.imul(_e, xe) | 0, j = j + Math.imul(Ie, we) | 0, ie = ie + Math.imul(Ie, xe) | 0, L = L + Math.imul(M, ze) | 0, j = j + Math.imul(M, Ve) | 0, j = j + Math.imul(z, ze) | 0, ie = ie + Math.imul(z, Ve) | 0, L = L + Math.imul(De, ct) | 0, j = j + Math.imul(De, lt) | 0, j = j + Math.imul(Re, ct) | 0, ie = ie + Math.imul(Re, lt) | 0, L = L + Math.imul(ae, wt) | 0, j = j + Math.imul(ae, bt) | 0, j = j + Math.imul(ye, wt) | 0, ie = ie + Math.imul(ye, bt) | 0, L = L + Math.imul(ce, Ct) | 0, j = j + Math.imul(ce, Xe) | 0, j = j + Math.imul(he, Ct) | 0, ie = ie + Math.imul(he, Xe) | 0;
                var kt = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, L = Math.imul(Z, yt), j = Math.imul(Z, _t), j = j + Math.imul(le, yt) | 0, ie = Math.imul(le, _t), L = L + Math.imul(J, Rt) | 0, j = j + Math.imul(J, Lt) | 0, j = j + Math.imul(V, Rt) | 0, ie = ie + Math.imul(V, Lt) | 0, L = L + Math.imul(fe, jr) | 0, j = j + Math.imul(fe, Et) | 0, j = j + Math.imul(ne, jr) | 0, ie = ie + Math.imul(ne, Et) | 0, L = L + Math.imul(x, wr) | 0, j = j + Math.imul(x, zt) | 0, j = j + Math.imul(q, wr) | 0, ie = ie + Math.imul(q, zt) | 0, L = L + Math.imul(Ke, we) | 0, j = j + Math.imul(Ke, xe) | 0, j = j + Math.imul(Ue, we) | 0, ie = ie + Math.imul(Ue, xe) | 0, L = L + Math.imul(_e, ze) | 0, j = j + Math.imul(_e, Ve) | 0, j = j + Math.imul(Ie, ze) | 0, ie = ie + Math.imul(Ie, Ve) | 0, L = L + Math.imul(M, ct) | 0, j = j + Math.imul(M, lt) | 0, j = j + Math.imul(z, ct) | 0, ie = ie + Math.imul(z, lt) | 0, L = L + Math.imul(De, wt) | 0, j = j + Math.imul(De, bt) | 0, j = j + Math.imul(Re, wt) | 0, ie = ie + Math.imul(Re, bt) | 0, L = L + Math.imul(ae, Ct) | 0, j = j + Math.imul(ae, Xe) | 0, j = j + Math.imul(ye, Ct) | 0, ie = ie + Math.imul(ye, Xe) | 0;
                var Hn = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Hn >>> 26) | 0, Hn &= 67108863, L = Math.imul(Z, Rt), j = Math.imul(Z, Lt), j = j + Math.imul(le, Rt) | 0, ie = Math.imul(le, Lt), L = L + Math.imul(J, jr) | 0, j = j + Math.imul(J, Et) | 0, j = j + Math.imul(V, jr) | 0, ie = ie + Math.imul(V, Et) | 0, L = L + Math.imul(fe, wr) | 0, j = j + Math.imul(fe, zt) | 0, j = j + Math.imul(ne, wr) | 0, ie = ie + Math.imul(ne, zt) | 0, L = L + Math.imul(x, we) | 0, j = j + Math.imul(x, xe) | 0, j = j + Math.imul(q, we) | 0, ie = ie + Math.imul(q, xe) | 0, L = L + Math.imul(Ke, ze) | 0, j = j + Math.imul(Ke, Ve) | 0, j = j + Math.imul(Ue, ze) | 0, ie = ie + Math.imul(Ue, Ve) | 0, L = L + Math.imul(_e, ct) | 0, j = j + Math.imul(_e, lt) | 0, j = j + Math.imul(Ie, ct) | 0, ie = ie + Math.imul(Ie, lt) | 0, L = L + Math.imul(M, wt) | 0, j = j + Math.imul(M, bt) | 0, j = j + Math.imul(z, wt) | 0, ie = ie + Math.imul(z, bt) | 0, L = L + Math.imul(De, Ct) | 0, j = j + Math.imul(De, Xe) | 0, j = j + Math.imul(Re, Ct) | 0, ie = ie + Math.imul(Re, Xe) | 0;
                var Zr = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, L = Math.imul(Z, jr), j = Math.imul(Z, Et), j = j + Math.imul(le, jr) | 0, ie = Math.imul(le, Et), L = L + Math.imul(J, wr) | 0, j = j + Math.imul(J, zt) | 0, j = j + Math.imul(V, wr) | 0, ie = ie + Math.imul(V, zt) | 0, L = L + Math.imul(fe, we) | 0, j = j + Math.imul(fe, xe) | 0, j = j + Math.imul(ne, we) | 0, ie = ie + Math.imul(ne, xe) | 0, L = L + Math.imul(x, ze) | 0, j = j + Math.imul(x, Ve) | 0, j = j + Math.imul(q, ze) | 0, ie = ie + Math.imul(q, Ve) | 0, L = L + Math.imul(Ke, ct) | 0, j = j + Math.imul(Ke, lt) | 0, j = j + Math.imul(Ue, ct) | 0, ie = ie + Math.imul(Ue, lt) | 0, L = L + Math.imul(_e, wt) | 0, j = j + Math.imul(_e, bt) | 0, j = j + Math.imul(Ie, wt) | 0, ie = ie + Math.imul(Ie, bt) | 0, L = L + Math.imul(M, Ct) | 0, j = j + Math.imul(M, Xe) | 0, j = j + Math.imul(z, Ct) | 0, ie = ie + Math.imul(z, Xe) | 0;
                var v = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (v >>> 26) | 0, v &= 67108863, L = Math.imul(Z, wr), j = Math.imul(Z, zt), j = j + Math.imul(le, wr) | 0, ie = Math.imul(le, zt), L = L + Math.imul(J, we) | 0, j = j + Math.imul(J, xe) | 0, j = j + Math.imul(V, we) | 0, ie = ie + Math.imul(V, xe) | 0, L = L + Math.imul(fe, ze) | 0, j = j + Math.imul(fe, Ve) | 0, j = j + Math.imul(ne, ze) | 0, ie = ie + Math.imul(ne, Ve) | 0, L = L + Math.imul(x, ct) | 0, j = j + Math.imul(x, lt) | 0, j = j + Math.imul(q, ct) | 0, ie = ie + Math.imul(q, lt) | 0, L = L + Math.imul(Ke, wt) | 0, j = j + Math.imul(Ke, bt) | 0, j = j + Math.imul(Ue, wt) | 0, ie = ie + Math.imul(Ue, bt) | 0, L = L + Math.imul(_e, Ct) | 0, j = j + Math.imul(_e, Xe) | 0, j = j + Math.imul(Ie, Ct) | 0, ie = ie + Math.imul(Ie, Xe) | 0;
                var B = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (B >>> 26) | 0, B &= 67108863, L = Math.imul(Z, we), j = Math.imul(Z, xe), j = j + Math.imul(le, we) | 0, ie = Math.imul(le, xe), L = L + Math.imul(J, ze) | 0, j = j + Math.imul(J, Ve) | 0, j = j + Math.imul(V, ze) | 0, ie = ie + Math.imul(V, Ve) | 0, L = L + Math.imul(fe, ct) | 0, j = j + Math.imul(fe, lt) | 0, j = j + Math.imul(ne, ct) | 0, ie = ie + Math.imul(ne, lt) | 0, L = L + Math.imul(x, wt) | 0, j = j + Math.imul(x, bt) | 0, j = j + Math.imul(q, wt) | 0, ie = ie + Math.imul(q, bt) | 0, L = L + Math.imul(Ke, Ct) | 0, j = j + Math.imul(Ke, Xe) | 0, j = j + Math.imul(Ue, Ct) | 0, ie = ie + Math.imul(Ue, Xe) | 0;
                var Y = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (Y >>> 26) | 0, Y &= 67108863, L = Math.imul(Z, ze), j = Math.imul(Z, Ve), j = j + Math.imul(le, ze) | 0, ie = Math.imul(le, Ve), L = L + Math.imul(J, ct) | 0, j = j + Math.imul(J, lt) | 0, j = j + Math.imul(V, ct) | 0, ie = ie + Math.imul(V, lt) | 0, L = L + Math.imul(fe, wt) | 0, j = j + Math.imul(fe, bt) | 0, j = j + Math.imul(ne, wt) | 0, ie = ie + Math.imul(ne, bt) | 0, L = L + Math.imul(x, Ct) | 0, j = j + Math.imul(x, Xe) | 0, j = j + Math.imul(q, Ct) | 0, ie = ie + Math.imul(q, Xe) | 0;
                var pe = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (pe >>> 26) | 0, pe &= 67108863, L = Math.imul(Z, ct), j = Math.imul(Z, lt), j = j + Math.imul(le, ct) | 0, ie = Math.imul(le, lt), L = L + Math.imul(J, wt) | 0, j = j + Math.imul(J, bt) | 0, j = j + Math.imul(V, wt) | 0, ie = ie + Math.imul(V, bt) | 0, L = L + Math.imul(fe, Ct) | 0, j = j + Math.imul(fe, Xe) | 0, j = j + Math.imul(ne, Ct) | 0, ie = ie + Math.imul(ne, Xe) | 0;
                var ke = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, L = Math.imul(Z, wt), j = Math.imul(Z, bt), j = j + Math.imul(le, wt) | 0, ie = Math.imul(le, bt), L = L + Math.imul(J, Ct) | 0, j = j + Math.imul(J, Xe) | 0, j = j + Math.imul(V, Ct) | 0, ie = ie + Math.imul(V, Xe) | 0;
                var qe = (k + L | 0) + ((j & 8191) << 13) | 0;
                k = (ie + (j >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, L = Math.imul(Z, Ct), j = Math.imul(Z, Xe), j = j + Math.imul(le, Ct) | 0, ie = Math.imul(le, Xe);
                var ut = (k + L | 0) + ((j & 8191) << 13) | 0;
                return k = (ie + (j >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, P[0] = xt, P[1] = St, P[2] = Pe, P[3] = et, P[4] = vt, P[5] = be, P[6] = $r, P[7] = jt, P[8] = nr, P[9] = kt, P[10] = Hn, P[11] = Zr, P[12] = v, P[13] = B, P[14] = Y, P[15] = pe, P[16] = ke, P[17] = qe, P[18] = ut, k !== 0 && (P[19] = k, E.length++), E;
            };
            Math.imul || (U = N);
            function D(w, g, m) {
                m.negative = g.negative ^ w.negative, m.length = w.length + g.length;
                for(var E = 0, T = 0, I = 0; I < m.length - 1; I++){
                    var P = T;
                    T = 0;
                    for(var k = E & 67108863, L = Math.min(I, g.length - 1), j = Math.max(0, I - w.length + 1); j <= L; j++){
                        var ie = I - j, ue = w.words[ie] | 0, ce = g.words[j] | 0, he = ue * ce, ee = he & 67108863;
                        P = P + (he / 67108864 | 0) | 0, ee = ee + k | 0, k = ee & 67108863, P = P + (ee >>> 26) | 0, T += P >>> 26, P &= 67108863;
                    }
                    m.words[I] = k, E = P, P = T;
                }
                return E !== 0 ? m.words[I] = E : m.length--, m._strip();
            }
            function H(w, g, m) {
                return D(w, g, m);
            }
            o.prototype.mulTo = function(g, m) {
                var E, T = this.length + g.length;
                return this.length === 10 && g.length === 10 ? E = U(this, g, m) : T < 63 ? E = N(this, g, m) : T < 1024 ? E = D(this, g, m) : E = H(this, g, m), E;
            }, o.prototype.mul = function(g) {
                var m = new o(null);
                return m.words = new Array(this.length + g.length), this.mulTo(g, m);
            }, o.prototype.mulf = function(g) {
                var m = new o(null);
                return m.words = new Array(this.length + g.length), H(this, g, m);
            }, o.prototype.imul = function(g) {
                return this.clone().mulTo(g, this);
            }, o.prototype.imuln = function(g) {
                var m = g < 0;
                m && (g = -g), n(typeof g == "number"), n(g < 67108864);
                for(var E = 0, T = 0; T < this.length; T++){
                    var I = (this.words[T] | 0) * g, P = (I & 67108863) + (E & 67108863);
                    E >>= 26, E += I / 67108864 | 0, E += P >>> 26, this.words[T] = P & 67108863;
                }
                return E !== 0 && (this.words[T] = E, this.length++), this.length = g === 0 ? 1 : this.length, m ? this.ineg() : this;
            }, o.prototype.muln = function(g) {
                return this.clone().imuln(g);
            }, o.prototype.sqr = function() {
                return this.mul(this);
            }, o.prototype.isqr = function() {
                return this.imul(this.clone());
            }, o.prototype.pow = function(g) {
                var m = O(g);
                if (m.length === 0) return new o(1);
                for(var E = this, T = 0; T < m.length && m[T] === 0; T++, E = E.sqr());
                if (++T < m.length) for(var I = E.sqr(); T < m.length; T++, I = I.sqr())m[T] !== 0 && (E = E.mul(I));
                return E;
            }, o.prototype.iushln = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = g % 26, E = (g - m) / 26, T = 67108863 >>> 26 - m << 26 - m, I;
                if (m !== 0) {
                    var P = 0;
                    for(I = 0; I < this.length; I++){
                        var k = this.words[I] & T, L = (this.words[I] | 0) - k << m;
                        this.words[I] = L | P, P = k >>> 26 - m;
                    }
                    P && (this.words[I] = P, this.length++);
                }
                if (E !== 0) {
                    for(I = this.length - 1; I >= 0; I--)this.words[I + E] = this.words[I];
                    for(I = 0; I < E; I++)this.words[I] = 0;
                    this.length += E;
                }
                return this._strip();
            }, o.prototype.ishln = function(g) {
                return n(this.negative === 0), this.iushln(g);
            }, o.prototype.iushrn = function(g, m, E) {
                n(typeof g == "number" && g >= 0);
                var T;
                m ? T = (m - m % 26) / 26 : T = 0;
                var I = g % 26, P = Math.min((g - I) / 26, this.length), k = 67108863 ^ 67108863 >>> I << I, L = E;
                if (T -= P, T = Math.max(0, T), L) {
                    for(var j = 0; j < P; j++)L.words[j] = this.words[j];
                    L.length = P;
                }
                if (P !== 0) if (this.length > P) for(this.length -= P, j = 0; j < this.length; j++)this.words[j] = this.words[j + P];
                else this.words[0] = 0, this.length = 1;
                var ie = 0;
                for(j = this.length - 1; j >= 0 && (ie !== 0 || j >= T); j--){
                    var ue = this.words[j] | 0;
                    this.words[j] = ie << 26 - I | ue >>> I, ie = ue & k;
                }
                return L && ie !== 0 && (L.words[L.length++] = ie), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
            }, o.prototype.ishrn = function(g, m, E) {
                return n(this.negative === 0), this.iushrn(g, m, E);
            }, o.prototype.shln = function(g) {
                return this.clone().ishln(g);
            }, o.prototype.ushln = function(g) {
                return this.clone().iushln(g);
            }, o.prototype.shrn = function(g) {
                return this.clone().ishrn(g);
            }, o.prototype.ushrn = function(g) {
                return this.clone().iushrn(g);
            }, o.prototype.testn = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = g % 26, E = (g - m) / 26, T = 1 << m;
                if (this.length <= E) return !1;
                var I = this.words[E];
                return !!(I & T);
            }, o.prototype.imaskn = function(g) {
                n(typeof g == "number" && g >= 0);
                var m = g % 26, E = (g - m) / 26;
                if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= E) return this;
                if (m !== 0 && E++, this.length = Math.min(E, this.length), m !== 0) {
                    var T = 67108863 ^ 67108863 >>> m << m;
                    this.words[this.length - 1] &= T;
                }
                return this._strip();
            }, o.prototype.maskn = function(g) {
                return this.clone().imaskn(g);
            }, o.prototype.iaddn = function(g) {
                return n(typeof g == "number"), n(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
            }, o.prototype._iaddn = function(g) {
                this.words[0] += g;
                for(var m = 0; m < this.length && this.words[m] >= 67108864; m++)this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
                return this.length = Math.max(this.length, m + 1), this;
            }, o.prototype.isubn = function(g) {
                if (n(typeof g == "number"), n(g < 67108864), g < 0) return this.iaddn(-g);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this;
                if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var m = 0; m < this.length && this.words[m] < 0; m++)this.words[m] += 67108864, this.words[m + 1] -= 1;
                return this._strip();
            }, o.prototype.addn = function(g) {
                return this.clone().iaddn(g);
            }, o.prototype.subn = function(g) {
                return this.clone().isubn(g);
            }, o.prototype.iabs = function() {
                return this.negative = 0, this;
            }, o.prototype.abs = function() {
                return this.clone().iabs();
            }, o.prototype._ishlnsubmul = function(g, m, E) {
                var T = g.length + E, I;
                this._expand(T);
                var P, k = 0;
                for(I = 0; I < g.length; I++){
                    P = (this.words[I + E] | 0) + k;
                    var L = (g.words[I] | 0) * m;
                    P -= L & 67108863, k = (P >> 26) - (L / 67108864 | 0), this.words[I + E] = P & 67108863;
                }
                for(; I < this.length - E; I++)P = (this.words[I + E] | 0) + k, k = P >> 26, this.words[I + E] = P & 67108863;
                if (k === 0) return this._strip();
                for(n(k === -1), k = 0, I = 0; I < this.length; I++)P = -(this.words[I] | 0) + k, k = P >> 26, this.words[I] = P & 67108863;
                return this.negative = 1, this._strip();
            }, o.prototype._wordDiv = function(g, m) {
                var E = this.length - g.length, T = this.clone(), I = g, P = I.words[I.length - 1] | 0, k = this._countBits(P);
                E = 26 - k, E !== 0 && (I = I.ushln(E), T.iushln(E), P = I.words[I.length - 1] | 0);
                var L = T.length - I.length, j;
                if (m !== "mod") {
                    j = new o(null), j.length = L + 1, j.words = new Array(j.length);
                    for(var ie = 0; ie < j.length; ie++)j.words[ie] = 0;
                }
                var ue = T.clone()._ishlnsubmul(I, 1, L);
                ue.negative === 0 && (T = ue, j && (j.words[L] = 1));
                for(var ce = L - 1; ce >= 0; ce--){
                    var he = (T.words[I.length + ce] | 0) * 67108864 + (T.words[I.length + ce - 1] | 0);
                    for(he = Math.min(he / P | 0, 67108863), T._ishlnsubmul(I, he, ce); T.negative !== 0;)he--, T.negative = 0, T._ishlnsubmul(I, 1, ce), T.isZero() || (T.negative ^= 1);
                    j && (j.words[ce] = he);
                }
                return j && j._strip(), T._strip(), m !== "div" && E !== 0 && T.iushrn(E), {
                    div: j || null,
                    mod: T
                };
            }, o.prototype.divmod = function(g, m, E) {
                if (n(!g.isZero()), this.isZero()) return {
                    div: new o(0),
                    mod: new o(0)
                };
                var T, I, P;
                return this.negative !== 0 && g.negative === 0 ? (P = this.neg().divmod(g, m), m !== "mod" && (T = P.div.neg()), m !== "div" && (I = P.mod.neg(), E && I.negative !== 0 && I.iadd(g)), {
                    div: T,
                    mod: I
                }) : this.negative === 0 && g.negative !== 0 ? (P = this.divmod(g.neg(), m), m !== "mod" && (T = P.div.neg()), {
                    div: T,
                    mod: P.mod
                }) : this.negative & g.negative ? (P = this.neg().divmod(g.neg(), m), m !== "div" && (I = P.mod.neg(), E && I.negative !== 0 && I.isub(g)), {
                    div: P.div,
                    mod: I
                }) : g.length > this.length || this.cmp(g) < 0 ? {
                    div: new o(0),
                    mod: this
                } : g.length === 1 ? m === "div" ? {
                    div: this.divn(g.words[0]),
                    mod: null
                } : m === "mod" ? {
                    div: null,
                    mod: new o(this.modrn(g.words[0]))
                } : {
                    div: this.divn(g.words[0]),
                    mod: new o(this.modrn(g.words[0]))
                } : this._wordDiv(g, m);
            }, o.prototype.div = function(g) {
                return this.divmod(g, "div", !1).div;
            }, o.prototype.mod = function(g) {
                return this.divmod(g, "mod", !1).mod;
            }, o.prototype.umod = function(g) {
                return this.divmod(g, "mod", !0).mod;
            }, o.prototype.divRound = function(g) {
                var m = this.divmod(g);
                if (m.mod.isZero()) return m.div;
                var E = m.div.negative !== 0 ? m.mod.isub(g) : m.mod, T = g.ushrn(1), I = g.andln(1), P = E.cmp(T);
                return P < 0 || I === 1 && P === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
            }, o.prototype.modrn = function(g) {
                var m = g < 0;
                m && (g = -g), n(g <= 67108863);
                for(var E = (1 << 26) % g, T = 0, I = this.length - 1; I >= 0; I--)T = (E * T + (this.words[I] | 0)) % g;
                return m ? -T : T;
            }, o.prototype.modn = function(g) {
                return this.modrn(g);
            }, o.prototype.idivn = function(g) {
                var m = g < 0;
                m && (g = -g), n(g <= 67108863);
                for(var E = 0, T = this.length - 1; T >= 0; T--){
                    var I = (this.words[T] | 0) + E * 67108864;
                    this.words[T] = I / g | 0, E = I % g;
                }
                return this._strip(), m ? this.ineg() : this;
            }, o.prototype.divn = function(g) {
                return this.clone().idivn(g);
            }, o.prototype.egcd = function(g) {
                n(g.negative === 0), n(!g.isZero());
                var m = this, E = g.clone();
                m.negative !== 0 ? m = m.umod(g) : m = m.clone();
                for(var T = new o(1), I = new o(0), P = new o(0), k = new o(1), L = 0; m.isEven() && E.isEven();)m.iushrn(1), E.iushrn(1), ++L;
                for(var j = E.clone(), ie = m.clone(); !m.isZero();){
                    for(var ue = 0, ce = 1; !(m.words[0] & ce) && ue < 26; ++ue, ce <<= 1);
                    if (ue > 0) for(m.iushrn(ue); ue-- > 0;)(T.isOdd() || I.isOdd()) && (T.iadd(j), I.isub(ie)), T.iushrn(1), I.iushrn(1);
                    for(var he = 0, ee = 1; !(E.words[0] & ee) && he < 26; ++he, ee <<= 1);
                    if (he > 0) for(E.iushrn(he); he-- > 0;)(P.isOdd() || k.isOdd()) && (P.iadd(j), k.isub(ie)), P.iushrn(1), k.iushrn(1);
                    m.cmp(E) >= 0 ? (m.isub(E), T.isub(P), I.isub(k)) : (E.isub(m), P.isub(T), k.isub(I));
                }
                return {
                    a: P,
                    b: k,
                    gcd: E.iushln(L)
                };
            }, o.prototype._invmp = function(g) {
                n(g.negative === 0), n(!g.isZero());
                var m = this, E = g.clone();
                m.negative !== 0 ? m = m.umod(g) : m = m.clone();
                for(var T = new o(1), I = new o(0), P = E.clone(); m.cmpn(1) > 0 && E.cmpn(1) > 0;){
                    for(var k = 0, L = 1; !(m.words[0] & L) && k < 26; ++k, L <<= 1);
                    if (k > 0) for(m.iushrn(k); k-- > 0;)T.isOdd() && T.iadd(P), T.iushrn(1);
                    for(var j = 0, ie = 1; !(E.words[0] & ie) && j < 26; ++j, ie <<= 1);
                    if (j > 0) for(E.iushrn(j); j-- > 0;)I.isOdd() && I.iadd(P), I.iushrn(1);
                    m.cmp(E) >= 0 ? (m.isub(E), T.isub(I)) : (E.isub(m), I.isub(T));
                }
                var ue;
                return m.cmpn(1) === 0 ? ue = T : ue = I, ue.cmpn(0) < 0 && ue.iadd(g), ue;
            }, o.prototype.gcd = function(g) {
                if (this.isZero()) return g.abs();
                if (g.isZero()) return this.abs();
                var m = this.clone(), E = g.clone();
                m.negative = 0, E.negative = 0;
                for(var T = 0; m.isEven() && E.isEven(); T++)m.iushrn(1), E.iushrn(1);
                do {
                    for(; m.isEven();)m.iushrn(1);
                    for(; E.isEven();)E.iushrn(1);
                    var I = m.cmp(E);
                    if (I < 0) {
                        var P = m;
                        m = E, E = P;
                    } else if (I === 0 || E.cmpn(1) === 0) break;
                    m.isub(E);
                }while (!0)
                return E.iushln(T);
            }, o.prototype.invm = function(g) {
                return this.egcd(g).a.umod(g);
            }, o.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, o.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, o.prototype.andln = function(g) {
                return this.words[0] & g;
            }, o.prototype.bincn = function(g) {
                n(typeof g == "number");
                var m = g % 26, E = (g - m) / 26, T = 1 << m;
                if (this.length <= E) return this._expand(E + 1), this.words[E] |= T, this;
                for(var I = T, P = E; I !== 0 && P < this.length; P++){
                    var k = this.words[P] | 0;
                    k += I, I = k >>> 26, k &= 67108863, this.words[P] = k;
                }
                return I !== 0 && (this.words[P] = I, this.length++), this;
            }, o.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, o.prototype.cmpn = function(g) {
                var m = g < 0;
                if (this.negative !== 0 && !m) return -1;
                if (this.negative === 0 && m) return 1;
                this._strip();
                var E;
                if (this.length > 1) E = 1;
                else {
                    m && (g = -g), n(g <= 67108863, "Number is too big");
                    var T = this.words[0] | 0;
                    E = T === g ? 0 : T < g ? -1 : 1;
                }
                return this.negative !== 0 ? -E | 0 : E;
            }, o.prototype.cmp = function(g) {
                if (this.negative !== 0 && g.negative === 0) return -1;
                if (this.negative === 0 && g.negative !== 0) return 1;
                var m = this.ucmp(g);
                return this.negative !== 0 ? -m | 0 : m;
            }, o.prototype.ucmp = function(g) {
                if (this.length > g.length) return 1;
                if (this.length < g.length) return -1;
                for(var m = 0, E = this.length - 1; E >= 0; E--){
                    var T = this.words[E] | 0, I = g.words[E] | 0;
                    if (T !== I) {
                        T < I ? m = -1 : T > I && (m = 1);
                        break;
                    }
                }
                return m;
            }, o.prototype.gtn = function(g) {
                return this.cmpn(g) === 1;
            }, o.prototype.gt = function(g) {
                return this.cmp(g) === 1;
            }, o.prototype.gten = function(g) {
                return this.cmpn(g) >= 0;
            }, o.prototype.gte = function(g) {
                return this.cmp(g) >= 0;
            }, o.prototype.ltn = function(g) {
                return this.cmpn(g) === -1;
            }, o.prototype.lt = function(g) {
                return this.cmp(g) === -1;
            }, o.prototype.lten = function(g) {
                return this.cmpn(g) <= 0;
            }, o.prototype.lte = function(g) {
                return this.cmp(g) <= 0;
            }, o.prototype.eqn = function(g) {
                return this.cmpn(g) === 0;
            }, o.prototype.eq = function(g) {
                return this.cmp(g) === 0;
            }, o.red = function(g) {
                return new $(g);
            }, o.prototype.toRed = function(g) {
                return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
            }, o.prototype.fromRed = function() {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, o.prototype._forceRed = function(g) {
                return this.red = g, this;
            }, o.prototype.forceRed = function(g) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(g);
            }, o.prototype.redAdd = function(g) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
            }, o.prototype.redIAdd = function(g) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
            }, o.prototype.redSub = function(g) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
            }, o.prototype.redISub = function(g) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
            }, o.prototype.redShl = function(g) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
            }, o.prototype.redMul = function(g) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
            }, o.prototype.redIMul = function(g) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
            }, o.prototype.redSqr = function() {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, o.prototype.redISqr = function() {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, o.prototype.redSqrt = function() {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, o.prototype.redInvm = function() {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, o.prototype.redNeg = function() {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, o.prototype.redPow = function(g) {
                return n(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
            };
            var K = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function re(w, g) {
                this.name = w, this.p = new o(g, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            re.prototype._tmp = function() {
                var g = new o(null);
                return g.words = new Array(Math.ceil(this.n / 13)), g;
            }, re.prototype.ireduce = function(g) {
                var m = g, E;
                do this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), E = m.bitLength();
                while (E > this.n)
                var T = E < this.n ? -1 : m.ucmp(this.p);
                return T === 0 ? (m.words[0] = 0, m.length = 1) : T > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
            }, re.prototype.split = function(g, m) {
                g.iushrn(this.n, 0, m);
            }, re.prototype.imulK = function(g) {
                return g.imul(this.k);
            };
            function Q() {
                re.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            i(Q, re), Q.prototype.split = function(g, m) {
                for(var E = 4194303, T = Math.min(g.length, 9), I = 0; I < T; I++)m.words[I] = g.words[I];
                if (m.length = T, g.length <= 9) {
                    g.words[0] = 0, g.length = 1;
                    return;
                }
                var P = g.words[9];
                for(m.words[m.length++] = P & E, I = 10; I < g.length; I++){
                    var k = g.words[I] | 0;
                    g.words[I - 10] = (k & E) << 4 | P >>> 22, P = k;
                }
                P >>>= 22, g.words[I - 10] = P, P === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
            }, Q.prototype.imulK = function(g) {
                g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
                for(var m = 0, E = 0; E < g.length; E++){
                    var T = g.words[E] | 0;
                    m += T * 977, g.words[E] = m & 67108863, m = T * 64 + (m / 67108864 | 0);
                }
                return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
            };
            function G() {
                re.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            i(G, re);
            function R() {
                re.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            i(R, re);
            function X() {
                re.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            i(X, re), X.prototype.imulK = function(g) {
                for(var m = 0, E = 0; E < g.length; E++){
                    var T = (g.words[E] | 0) * 19 + m, I = T & 67108863;
                    T >>>= 26, g.words[E] = I, m = T;
                }
                return m !== 0 && (g.words[g.length++] = m), g;
            }, o._prime = function(g) {
                if (K[g]) return K[g];
                var m;
                if (g === "k256") m = new Q();
                else if (g === "p224") m = new G();
                else if (g === "p192") m = new R();
                else if (g === "p25519") m = new X();
                else throw new Error("Unknown prime " + g);
                return K[g] = m, m;
            };
            function $(w) {
                if (typeof w == "string") {
                    var g = o._prime(w);
                    this.m = g.p, this.prime = g;
                } else n(w.gtn(1), "modulus must be greater than 1"), this.m = w, this.prime = null;
            }
            $.prototype._verify1 = function(g) {
                n(g.negative === 0, "red works only with positives"), n(g.red, "red works only with red numbers");
            }, $.prototype._verify2 = function(g, m) {
                n((g.negative | m.negative) === 0, "red works only with positives"), n(g.red && g.red === m.red, "red works only with red numbers");
            }, $.prototype.imod = function(g) {
                return this.prime ? this.prime.ireduce(g)._forceRed(this) : (c(g, g.umod(this.m)._forceRed(this)), g);
            }, $.prototype.neg = function(g) {
                return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
            }, $.prototype.add = function(g, m) {
                this._verify2(g, m);
                var E = g.add(m);
                return E.cmp(this.m) >= 0 && E.isub(this.m), E._forceRed(this);
            }, $.prototype.iadd = function(g, m) {
                this._verify2(g, m);
                var E = g.iadd(m);
                return E.cmp(this.m) >= 0 && E.isub(this.m), E;
            }, $.prototype.sub = function(g, m) {
                this._verify2(g, m);
                var E = g.sub(m);
                return E.cmpn(0) < 0 && E.iadd(this.m), E._forceRed(this);
            }, $.prototype.isub = function(g, m) {
                this._verify2(g, m);
                var E = g.isub(m);
                return E.cmpn(0) < 0 && E.iadd(this.m), E;
            }, $.prototype.shl = function(g, m) {
                return this._verify1(g), this.imod(g.ushln(m));
            }, $.prototype.imul = function(g, m) {
                return this._verify2(g, m), this.imod(g.imul(m));
            }, $.prototype.mul = function(g, m) {
                return this._verify2(g, m), this.imod(g.mul(m));
            }, $.prototype.isqr = function(g) {
                return this.imul(g, g.clone());
            }, $.prototype.sqr = function(g) {
                return this.mul(g, g);
            }, $.prototype.sqrt = function(g) {
                if (g.isZero()) return g.clone();
                var m = this.m.andln(3);
                if (n(m % 2 === 1), m === 3) {
                    var E = this.m.add(new o(1)).iushrn(2);
                    return this.pow(g, E);
                }
                for(var T = this.m.subn(1), I = 0; !T.isZero() && T.andln(1) === 0;)I++, T.iushrn(1);
                n(!T.isZero());
                var P = new o(1).toRed(this), k = P.redNeg(), L = this.m.subn(1).iushrn(1), j = this.m.bitLength();
                for(j = new o(2 * j * j).toRed(this); this.pow(j, L).cmp(k) !== 0;)j.redIAdd(k);
                for(var ie = this.pow(j, T), ue = this.pow(g, T.addn(1).iushrn(1)), ce = this.pow(g, T), he = I; ce.cmp(P) !== 0;){
                    for(var ee = ce, ae = 0; ee.cmp(P) !== 0; ae++)ee = ee.redSqr();
                    n(ae < he);
                    var ye = this.pow(ie, new o(1).iushln(he - ae - 1));
                    ue = ue.redMul(ye), ie = ye.redSqr(), ce = ce.redMul(ie), he = ae;
                }
                return ue;
            }, $.prototype.invm = function(g) {
                var m = g._invmp(this.m);
                return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
            }, $.prototype.pow = function(g, m) {
                if (m.isZero()) return new o(1).toRed(this);
                if (m.cmpn(1) === 0) return g.clone();
                var E = 4, T = new Array(1 << E);
                T[0] = new o(1).toRed(this), T[1] = g;
                for(var I = 2; I < T.length; I++)T[I] = this.mul(T[I - 1], g);
                var P = T[0], k = 0, L = 0, j = m.bitLength() % 26;
                for(j === 0 && (j = 26), I = m.length - 1; I >= 0; I--){
                    for(var ie = m.words[I], ue = j - 1; ue >= 0; ue--){
                        var ce = ie >> ue & 1;
                        if (P !== T[0] && (P = this.sqr(P)), ce === 0 && k === 0) {
                            L = 0;
                            continue;
                        }
                        k <<= 1, k |= ce, L++, !(L !== E && (I !== 0 || ue !== 0)) && (P = this.mul(P, T[k]), L = 0, k = 0);
                    }
                    j = 26;
                }
                return P;
            }, $.prototype.convertTo = function(g) {
                var m = g.umod(this.m);
                return m === g ? m.clone() : m;
            }, $.prototype.convertFrom = function(g) {
                var m = g.clone();
                return m.red = null, m;
            }, o.mont = function(g) {
                return new S(g);
            };
            function S(w) {
                $.call(this, w), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            i(S, $), S.prototype.convertTo = function(g) {
                return this.imod(g.ushln(this.shift));
            }, S.prototype.convertFrom = function(g) {
                var m = this.imod(g.mul(this.rinv));
                return m.red = null, m;
            }, S.prototype.imul = function(g, m) {
                if (g.isZero() || m.isZero()) return g.words[0] = 0, g.length = 1, g;
                var E = g.imul(m), T = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = E.isub(T).iushrn(this.shift), P = I;
                return I.cmp(this.m) >= 0 ? P = I.isub(this.m) : I.cmpn(0) < 0 && (P = I.iadd(this.m)), P._forceRed(this);
            }, S.prototype.mul = function(g, m) {
                if (g.isZero() || m.isZero()) return new o(0)._forceRed(this);
                var E = g.mul(m), T = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), I = E.isub(T).iushrn(this.shift), P = I;
                return I.cmp(this.m) >= 0 ? P = I.isub(this.m) : I.cmpn(0) < 0 && (P = I.iadd(this.m)), P._forceRed(this);
            }, S.prototype.invm = function(g) {
                var m = this.imod(g._invmp(this.m).mul(this.r2));
                return m._forceRed(this);
            };
        })(e, Ge);
    }(Iy)), Iy.exports;
}
var u2, q5;
function F3() {
    if (q5) return u2;
    q5 = 1;
    var e = D3(), t = kd(), r = Ar().Buffer;
    function n(s) {
        var a = s.modulus.byteLength(), u;
        do u = new e(t(a));
        while (u.cmp(s.modulus) >= 0 || !u.umod(s.prime1) || !u.umod(s.prime2))
        return u;
    }
    function i(s) {
        var a = n(s), u = a.toRed(e.mont(s.modulus)).redPow(new e(s.publicExponent)).fromRed();
        return {
            blinder: u,
            unblinder: a.invm(s.modulus)
        };
    }
    function o(s, a) {
        var u = i(a), f = a.modulus.byteLength(), c = new e(s).mul(u.blinder).umod(a.modulus), l = c.toRed(e.mont(a.prime1)), p = c.toRed(e.mont(a.prime2)), y = a.coefficient, _ = a.prime1, A = a.prime2, O = l.redPow(a.exponent1).fromRed(), N = p.redPow(a.exponent2).fromRed(), U = O.isub(N).imul(y).umod(_).imul(A);
        return N.iadd(U).imul(u.unblinder).umod(a.modulus).toArrayLike(r, "be", f);
    }
    return o.getr = n, u2 = o, u2;
}
var f2 = {};
const hX = "6.6.1", pX = {
    version: hX
};
var l2 = {}, d2 = {}, K5;
function IO() {
    return K5 || (K5 = 1, function(e) {
        var t = e;
        function r(o, s) {
            if (Array.isArray(o)) return o.slice();
            if (!o) return [];
            var a = [];
            if (typeof o != "string") {
                for(var u = 0; u < o.length; u++)a[u] = o[u] | 0;
                return a;
            }
            if (s === "hex") {
                o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
                for(var u = 0; u < o.length; u += 2)a.push(parseInt(o[u] + o[u + 1], 16));
            } else for(var u = 0; u < o.length; u++){
                var f = o.charCodeAt(u), c = f >> 8, l = f & 255;
                c ? a.push(c, l) : a.push(l);
            }
            return a;
        }
        t.toArray = r;
        function n(o) {
            return o.length === 1 ? "0" + o : o;
        }
        t.zero2 = n;
        function i(o) {
            for(var s = "", a = 0; a < o.length; a++)s += n(o[a].toString(16));
            return s;
        }
        t.toHex = i, t.encode = function(s, a) {
            return a === "hex" ? i(s) : s;
        };
    }(d2)), d2;
}
var W5;
function ms() {
    return W5 || (W5 = 1, function(e) {
        var t = e, r = bi(), n = ys(), i = IO();
        t.assert = n, t.toArray = i.toArray, t.zero2 = i.zero2, t.toHex = i.toHex, t.encode = i.encode;
        function o(c, l, p) {
            var y = new Array(Math.max(c.bitLength(), p) + 1), _;
            for(_ = 0; _ < y.length; _ += 1)y[_] = 0;
            var A = 1 << l + 1, O = c.clone();
            for(_ = 0; _ < y.length; _++){
                var N, U = O.andln(A - 1);
                O.isOdd() ? (U > (A >> 1) - 1 ? N = (A >> 1) - U : N = U, O.isubn(N)) : N = 0, y[_] = N, O.iushrn(1);
            }
            return y;
        }
        t.getNAF = o;
        function s(c, l) {
            var p = [
                [],
                []
            ];
            c = c.clone(), l = l.clone();
            for(var y = 0, _ = 0, A; c.cmpn(-y) > 0 || l.cmpn(-_) > 0;){
                var O = c.andln(3) + y & 3, N = l.andln(3) + _ & 3;
                O === 3 && (O = -1), N === 3 && (N = -1);
                var U;
                O & 1 ? (A = c.andln(7) + y & 7, (A === 3 || A === 5) && N === 2 ? U = -O : U = O) : U = 0, p[0].push(U);
                var D;
                N & 1 ? (A = l.andln(7) + _ & 7, (A === 3 || A === 5) && O === 2 ? D = -N : D = N) : D = 0, p[1].push(D), 2 * y === U + 1 && (y = 1 - y), 2 * _ === D + 1 && (_ = 1 - _), c.iushrn(1), l.iushrn(1);
            }
            return p;
        }
        t.getJSF = s;
        function a(c, l, p) {
            var y = "_" + l;
            c.prototype[l] = function() {
                return this[y] !== void 0 ? this[y] : this[y] = p.call(this);
            };
        }
        t.cachedProperty = a;
        function u(c) {
            return typeof c == "string" ? t.toArray(c, "hex") : c;
        }
        t.parseBytes = u;
        function f(c) {
            return new r(c, "hex", "le");
        }
        t.intFromLE = f;
    }(l2)), l2;
}
var h2 = {}, p2, V5;
function Tb() {
    if (V5) return p2;
    V5 = 1;
    var e = bi(), t = ms(), r = t.getNAF, n = t.getJSF, i = t.assert;
    function o(a, u) {
        this.type = a, this.p = new e(u.p, 16), this.red = u.prime ? e.red(u.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = u.n && new e(u.n, 16), this.g = u.g && this.pointFromJSON(u.g, u.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var f = this.n && this.p.div(this.n);
        !f || f.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
    }
    p2 = o, o.prototype.point = function() {
        throw new Error("Not implemented");
    }, o.prototype.validate = function() {
        throw new Error("Not implemented");
    }, o.prototype._fixedNafMul = function(u, f) {
        i(u.precomputed);
        var c = u._getDoubles(), l = r(f, 1, this._bitLength), p = (1 << c.step + 1) - (c.step % 2 === 0 ? 2 : 1);
        p /= 3;
        var y = [], _, A;
        for(_ = 0; _ < l.length; _ += c.step){
            A = 0;
            for(var O = _ + c.step - 1; O >= _; O--)A = (A << 1) + l[O];
            y.push(A);
        }
        for(var N = this.jpoint(null, null, null), U = this.jpoint(null, null, null), D = p; D > 0; D--){
            for(_ = 0; _ < y.length; _++)A = y[_], A === D ? U = U.mixedAdd(c.points[_]) : A === -D && (U = U.mixedAdd(c.points[_].neg()));
            N = N.add(U);
        }
        return N.toP();
    }, o.prototype._wnafMul = function(u, f) {
        var c = 4, l = u._getNAFPoints(c);
        c = l.wnd;
        for(var p = l.points, y = r(f, c, this._bitLength), _ = this.jpoint(null, null, null), A = y.length - 1; A >= 0; A--){
            for(var O = 0; A >= 0 && y[A] === 0; A--)O++;
            if (A >= 0 && O++, _ = _.dblp(O), A < 0) break;
            var N = y[A];
            i(N !== 0), u.type === "affine" ? N > 0 ? _ = _.mixedAdd(p[N - 1 >> 1]) : _ = _.mixedAdd(p[-N - 1 >> 1].neg()) : N > 0 ? _ = _.add(p[N - 1 >> 1]) : _ = _.add(p[-N - 1 >> 1].neg());
        }
        return u.type === "affine" ? _.toP() : _;
    }, o.prototype._wnafMulAdd = function(u, f, c, l, p) {
        var y = this._wnafT1, _ = this._wnafT2, A = this._wnafT3, O = 0, N, U, D;
        for(N = 0; N < l; N++){
            D = f[N];
            var H = D._getNAFPoints(u);
            y[N] = H.wnd, _[N] = H.points;
        }
        for(N = l - 1; N >= 1; N -= 2){
            var K = N - 1, re = N;
            if (y[K] !== 1 || y[re] !== 1) {
                A[K] = r(c[K], y[K], this._bitLength), A[re] = r(c[re], y[re], this._bitLength), O = Math.max(A[K].length, O), O = Math.max(A[re].length, O);
                continue;
            }
            var Q = [
                f[K],
                /* 1 */ null,
                /* 3 */ null,
                /* 5 */ f[re]
            ];
            f[K].y.cmp(f[re].y) === 0 ? (Q[1] = f[K].add(f[re]), Q[2] = f[K].toJ().mixedAdd(f[re].neg())) : f[K].y.cmp(f[re].y.redNeg()) === 0 ? (Q[1] = f[K].toJ().mixedAdd(f[re]), Q[2] = f[K].add(f[re].neg())) : (Q[1] = f[K].toJ().mixedAdd(f[re]), Q[2] = f[K].toJ().mixedAdd(f[re].neg()));
            var G = [
                -3,
                /* -1 -1 */ -1,
                /* -1 0 */ -5,
                /* -1 1 */ -7,
                /* 0 -1 */ 0,
                /* 0 0 */ 7,
                /* 0 1 */ 5,
                /* 1 -1 */ 1,
                /* 1 0 */ 3
            ], R = n(c[K], c[re]);
            for(O = Math.max(R[0].length, O), A[K] = new Array(O), A[re] = new Array(O), U = 0; U < O; U++){
                var X = R[0][U] | 0, $ = R[1][U] | 0;
                A[K][U] = G[(X + 1) * 3 + ($ + 1)], A[re][U] = 0, _[K] = Q;
            }
        }
        var S = this.jpoint(null, null, null), w = this._wnafT4;
        for(N = O; N >= 0; N--){
            for(var g = 0; N >= 0;){
                var m = !0;
                for(U = 0; U < l; U++)w[U] = A[U][N] | 0, w[U] !== 0 && (m = !1);
                if (!m) break;
                g++, N--;
            }
            if (N >= 0 && g++, S = S.dblp(g), N < 0) break;
            for(U = 0; U < l; U++){
                var E = w[U];
                E !== 0 && (E > 0 ? D = _[U][E - 1 >> 1] : E < 0 && (D = _[U][-E - 1 >> 1].neg()), D.type === "affine" ? S = S.mixedAdd(D) : S = S.add(D));
            }
        }
        for(N = 0; N < l; N++)_[N] = null;
        return p ? S : S.toP();
    };
    function s(a, u) {
        this.curve = a, this.type = u, this.precomputed = null;
    }
    return o.BasePoint = s, s.prototype.eq = function() {
        throw new Error("Not implemented");
    }, s.prototype.validate = function() {
        return this.curve.validate(this);
    }, o.prototype.decodePoint = function(u, f) {
        u = t.toArray(u, f);
        var c = this.p.byteLength();
        if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 === 2 * c) {
            u[0] === 6 ? i(u[u.length - 1] % 2 === 0) : u[0] === 7 && i(u[u.length - 1] % 2 === 1);
            var l = this.point(u.slice(1, 1 + c), u.slice(1 + c, 1 + 2 * c));
            return l;
        } else if ((u[0] === 2 || u[0] === 3) && u.length - 1 === c) return this.pointFromX(u.slice(1, 1 + c), u[0] === 3);
        throw new Error("Unknown point format");
    }, s.prototype.encodeCompressed = function(u) {
        return this.encode(u, !0);
    }, s.prototype._encode = function(u) {
        var f = this.curve.p.byteLength(), c = this.getX().toArray("be", f);
        return u ? [
            this.getY().isEven() ? 2 : 3
        ].concat(c) : [
            4
        ].concat(c, this.getY().toArray("be", f));
    }, s.prototype.encode = function(u, f) {
        return t.encode(this._encode(f), u);
    }, s.prototype.precompute = function(u) {
        if (this.precomputed) return this;
        var f = {
            doubles: null,
            naf: null,
            beta: null
        };
        return f.naf = this._getNAFPoints(8), f.doubles = this._getDoubles(4, u), f.beta = this._getBeta(), this.precomputed = f, this;
    }, s.prototype._hasDoubles = function(u) {
        if (!this.precomputed) return !1;
        var f = this.precomputed.doubles;
        return f ? f.points.length >= Math.ceil((u.bitLength() + 1) / f.step) : !1;
    }, s.prototype._getDoubles = function(u, f) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        for(var c = [
            this
        ], l = this, p = 0; p < f; p += u){
            for(var y = 0; y < u; y++)l = l.dbl();
            c.push(l);
        }
        return {
            step: u,
            points: c
        };
    }, s.prototype._getNAFPoints = function(u) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        for(var f = [
            this
        ], c = (1 << u) - 1, l = c === 1 ? null : this.dbl(), p = 1; p < c; p++)f[p] = f[p - 1].add(l);
        return {
            wnd: u,
            points: f
        };
    }, s.prototype._getBeta = function() {
        return null;
    }, s.prototype.dblp = function(u) {
        for(var f = this, c = 0; c < u; c++)f = f.dbl();
        return f;
    }, p2;
}
var g2, G5;
function gX() {
    if (G5) return g2;
    G5 = 1;
    var e = ms(), t = bi(), r = Or(), n = Tb(), i = e.assert;
    function o(u) {
        n.call(this, "short", u), this.a = new t(u.a, 16).toRed(this.red), this.b = new t(u.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(u), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    r(o, n), g2 = o, o.prototype._getEndomorphism = function(f) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var c, l;
            if (f.beta) c = new t(f.beta, 16).toRed(this.red);
            else {
                var p = this._getEndoRoots(this.p);
                c = p[0].cmp(p[1]) < 0 ? p[0] : p[1], c = c.toRed(this.red);
            }
            if (f.lambda) l = new t(f.lambda, 16);
            else {
                var y = this._getEndoRoots(this.n);
                this.g.mul(y[0]).x.cmp(this.g.x.redMul(c)) === 0 ? l = y[0] : (l = y[1], i(this.g.mul(l).x.cmp(this.g.x.redMul(c)) === 0));
            }
            var _;
            return f.basis ? _ = f.basis.map(function(A) {
                return {
                    a: new t(A.a, 16),
                    b: new t(A.b, 16)
                };
            }) : _ = this._getEndoBasis(l), {
                beta: c,
                lambda: l,
                basis: _
            };
        }
    }, o.prototype._getEndoRoots = function(f) {
        var c = f === this.p ? this.red : t.mont(f), l = new t(2).toRed(c).redInvm(), p = l.redNeg(), y = new t(3).toRed(c).redNeg().redSqrt().redMul(l), _ = p.redAdd(y).fromRed(), A = p.redSub(y).fromRed();
        return [
            _,
            A
        ];
    }, o.prototype._getEndoBasis = function(f) {
        for(var c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), l = f, p = this.n.clone(), y = new t(1), _ = new t(0), A = new t(0), O = new t(1), N, U, D, H, K, re, Q, G = 0, R, X; l.cmpn(0) !== 0;){
            var $ = p.div(l);
            R = p.sub($.mul(l)), X = A.sub($.mul(y));
            var S = O.sub($.mul(_));
            if (!D && R.cmp(c) < 0) N = Q.neg(), U = y, D = R.neg(), H = X;
            else if (D && ++G === 2) break;
            Q = R, p = l, l = R, A = y, y = X, O = _, _ = S;
        }
        K = R.neg(), re = X;
        var w = D.sqr().add(H.sqr()), g = K.sqr().add(re.sqr());
        return g.cmp(w) >= 0 && (K = N, re = U), D.negative && (D = D.neg(), H = H.neg()), K.negative && (K = K.neg(), re = re.neg()), [
            {
                a: D,
                b: H
            },
            {
                a: K,
                b: re
            }
        ];
    }, o.prototype._endoSplit = function(f) {
        var c = this.endo.basis, l = c[0], p = c[1], y = p.b.mul(f).divRound(this.n), _ = l.b.neg().mul(f).divRound(this.n), A = y.mul(l.a), O = _.mul(p.a), N = y.mul(l.b), U = _.mul(p.b), D = f.sub(A).sub(O), H = N.add(U).neg();
        return {
            k1: D,
            k2: H
        };
    }, o.prototype.pointFromX = function(f, c) {
        f = new t(f, 16), f.red || (f = f.toRed(this.red));
        var l = f.redSqr().redMul(f).redIAdd(f.redMul(this.a)).redIAdd(this.b), p = l.redSqrt();
        if (p.redSqr().redSub(l).cmp(this.zero) !== 0) throw new Error("invalid point");
        var y = p.fromRed().isOdd();
        return (c && !y || !c && y) && (p = p.redNeg()), this.point(f, p);
    }, o.prototype.validate = function(f) {
        if (f.inf) return !0;
        var c = f.x, l = f.y, p = this.a.redMul(c), y = c.redSqr().redMul(c).redIAdd(p).redIAdd(this.b);
        return l.redSqr().redISub(y).cmpn(0) === 0;
    }, o.prototype._endoWnafMulAdd = function(f, c, l) {
        for(var p = this._endoWnafT1, y = this._endoWnafT2, _ = 0; _ < f.length; _++){
            var A = this._endoSplit(c[_]), O = f[_], N = O._getBeta();
            A.k1.negative && (A.k1.ineg(), O = O.neg(!0)), A.k2.negative && (A.k2.ineg(), N = N.neg(!0)), p[_ * 2] = O, p[_ * 2 + 1] = N, y[_ * 2] = A.k1, y[_ * 2 + 1] = A.k2;
        }
        for(var U = this._wnafMulAdd(1, p, y, _ * 2, l), D = 0; D < _ * 2; D++)p[D] = null, y[D] = null;
        return U;
    };
    function s(u, f, c, l) {
        n.BasePoint.call(this, u, "affine"), f === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(f, 16), this.y = new t(c, 16), l && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
    }
    r(s, n.BasePoint), o.prototype.point = function(f, c, l) {
        return new s(this, f, c, l);
    }, o.prototype.pointFromJSON = function(f, c) {
        return s.fromJSON(this, f, c);
    }, s.prototype._getBeta = function() {
        if (this.curve.endo) {
            var f = this.precomputed;
            if (f && f.beta) return f.beta;
            var c = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (f) {
                var l = this.curve, p = function(y) {
                    return l.point(y.x.redMul(l.endo.beta), y.y);
                };
                f.beta = c, c.precomputed = {
                    beta: null,
                    naf: f.naf && {
                        wnd: f.naf.wnd,
                        points: f.naf.points.map(p)
                    },
                    doubles: f.doubles && {
                        step: f.doubles.step,
                        points: f.doubles.points.map(p)
                    }
                };
            }
            return c;
        }
    }, s.prototype.toJSON = function() {
        return this.precomputed ? [
            this.x,
            this.y,
            this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }
        ] : [
            this.x,
            this.y
        ];
    }, s.fromJSON = function(f, c, l) {
        typeof c == "string" && (c = JSON.parse(c));
        var p = f.point(c[0], c[1], l);
        if (!c[2]) return p;
        function y(A) {
            return f.point(A[0], A[1], l);
        }
        var _ = c[2];
        return p.precomputed = {
            beta: null,
            doubles: _.doubles && {
                step: _.doubles.step,
                points: [
                    p
                ].concat(_.doubles.points.map(y))
            },
            naf: _.naf && {
                wnd: _.naf.wnd,
                points: [
                    p
                ].concat(_.naf.points.map(y))
            }
        }, p;
    }, s.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, s.prototype.isInfinity = function() {
        return this.inf;
    }, s.prototype.add = function(f) {
        if (this.inf) return f;
        if (f.inf) return this;
        if (this.eq(f)) return this.dbl();
        if (this.neg().eq(f)) return this.curve.point(null, null);
        if (this.x.cmp(f.x) === 0) return this.curve.point(null, null);
        var c = this.y.redSub(f.y);
        c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(f.x).redInvm()));
        var l = c.redSqr().redISub(this.x).redISub(f.x), p = c.redMul(this.x.redSub(l)).redISub(this.y);
        return this.curve.point(l, p);
    }, s.prototype.dbl = function() {
        if (this.inf) return this;
        var f = this.y.redAdd(this.y);
        if (f.cmpn(0) === 0) return this.curve.point(null, null);
        var c = this.curve.a, l = this.x.redSqr(), p = f.redInvm(), y = l.redAdd(l).redIAdd(l).redIAdd(c).redMul(p), _ = y.redSqr().redISub(this.x.redAdd(this.x)), A = y.redMul(this.x.redSub(_)).redISub(this.y);
        return this.curve.point(_, A);
    }, s.prototype.getX = function() {
        return this.x.fromRed();
    }, s.prototype.getY = function() {
        return this.y.fromRed();
    }, s.prototype.mul = function(f) {
        return f = new t(f, 16), this.isInfinity() ? this : this._hasDoubles(f) ? this.curve._fixedNafMul(this, f) : this.curve.endo ? this.curve._endoWnafMulAdd([
            this
        ], [
            f
        ]) : this.curve._wnafMul(this, f);
    }, s.prototype.mulAdd = function(f, c, l) {
        var p = [
            this,
            c
        ], y = [
            f,
            l
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(p, y) : this.curve._wnafMulAdd(1, p, y, 2);
    }, s.prototype.jmulAdd = function(f, c, l) {
        var p = [
            this,
            c
        ], y = [
            f,
            l
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(p, y, !0) : this.curve._wnafMulAdd(1, p, y, 2, !0);
    }, s.prototype.eq = function(f) {
        return this === f || this.inf === f.inf && (this.inf || this.x.cmp(f.x) === 0 && this.y.cmp(f.y) === 0);
    }, s.prototype.neg = function(f) {
        if (this.inf) return this;
        var c = this.curve.point(this.x, this.y.redNeg());
        if (f && this.precomputed) {
            var l = this.precomputed, p = function(y) {
                return y.neg();
            };
            c.precomputed = {
                naf: l.naf && {
                    wnd: l.naf.wnd,
                    points: l.naf.points.map(p)
                },
                doubles: l.doubles && {
                    step: l.doubles.step,
                    points: l.doubles.points.map(p)
                }
            };
        }
        return c;
    }, s.prototype.toJ = function() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var f = this.curve.jpoint(this.x, this.y, this.curve.one);
        return f;
    };
    function a(u, f, c, l) {
        n.BasePoint.call(this, u, "jacobian"), f === null && c === null && l === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(f, 16), this.y = new t(c, 16), this.z = new t(l, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    return r(a, n.BasePoint), o.prototype.jpoint = function(f, c, l) {
        return new a(this, f, c, l);
    }, a.prototype.toP = function() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var f = this.z.redInvm(), c = f.redSqr(), l = this.x.redMul(c), p = this.y.redMul(c).redMul(f);
        return this.curve.point(l, p);
    }, a.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, a.prototype.add = function(f) {
        if (this.isInfinity()) return f;
        if (f.isInfinity()) return this;
        var c = f.z.redSqr(), l = this.z.redSqr(), p = this.x.redMul(c), y = f.x.redMul(l), _ = this.y.redMul(c.redMul(f.z)), A = f.y.redMul(l.redMul(this.z)), O = p.redSub(y), N = _.redSub(A);
        if (O.cmpn(0) === 0) return N.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var U = O.redSqr(), D = U.redMul(O), H = p.redMul(U), K = N.redSqr().redIAdd(D).redISub(H).redISub(H), re = N.redMul(H.redISub(K)).redISub(_.redMul(D)), Q = this.z.redMul(f.z).redMul(O);
        return this.curve.jpoint(K, re, Q);
    }, a.prototype.mixedAdd = function(f) {
        if (this.isInfinity()) return f.toJ();
        if (f.isInfinity()) return this;
        var c = this.z.redSqr(), l = this.x, p = f.x.redMul(c), y = this.y, _ = f.y.redMul(c).redMul(this.z), A = l.redSub(p), O = y.redSub(_);
        if (A.cmpn(0) === 0) return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var N = A.redSqr(), U = N.redMul(A), D = l.redMul(N), H = O.redSqr().redIAdd(U).redISub(D).redISub(D), K = O.redMul(D.redISub(H)).redISub(y.redMul(U)), re = this.z.redMul(A);
        return this.curve.jpoint(H, K, re);
    }, a.prototype.dblp = function(f) {
        if (f === 0) return this;
        if (this.isInfinity()) return this;
        if (!f) return this.dbl();
        var c;
        if (this.curve.zeroA || this.curve.threeA) {
            var l = this;
            for(c = 0; c < f; c++)l = l.dbl();
            return l;
        }
        var p = this.curve.a, y = this.curve.tinv, _ = this.x, A = this.y, O = this.z, N = O.redSqr().redSqr(), U = A.redAdd(A);
        for(c = 0; c < f; c++){
            var D = _.redSqr(), H = U.redSqr(), K = H.redSqr(), re = D.redAdd(D).redIAdd(D).redIAdd(p.redMul(N)), Q = _.redMul(H), G = re.redSqr().redISub(Q.redAdd(Q)), R = Q.redISub(G), X = re.redMul(R);
            X = X.redIAdd(X).redISub(K);
            var $ = U.redMul(O);
            c + 1 < f && (N = N.redMul(K)), _ = G, O = $, U = X;
        }
        return this.curve.jpoint(_, U.redMul(y), O);
    }, a.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, a.prototype._zeroDbl = function() {
        var f, c, l;
        if (this.zOne) {
            var p = this.x.redSqr(), y = this.y.redSqr(), _ = y.redSqr(), A = this.x.redAdd(y).redSqr().redISub(p).redISub(_);
            A = A.redIAdd(A);
            var O = p.redAdd(p).redIAdd(p), N = O.redSqr().redISub(A).redISub(A), U = _.redIAdd(_);
            U = U.redIAdd(U), U = U.redIAdd(U), f = N, c = O.redMul(A.redISub(N)).redISub(U), l = this.y.redAdd(this.y);
        } else {
            var D = this.x.redSqr(), H = this.y.redSqr(), K = H.redSqr(), re = this.x.redAdd(H).redSqr().redISub(D).redISub(K);
            re = re.redIAdd(re);
            var Q = D.redAdd(D).redIAdd(D), G = Q.redSqr(), R = K.redIAdd(K);
            R = R.redIAdd(R), R = R.redIAdd(R), f = G.redISub(re).redISub(re), c = Q.redMul(re.redISub(f)).redISub(R), l = this.y.redMul(this.z), l = l.redIAdd(l);
        }
        return this.curve.jpoint(f, c, l);
    }, a.prototype._threeDbl = function() {
        var f, c, l;
        if (this.zOne) {
            var p = this.x.redSqr(), y = this.y.redSqr(), _ = y.redSqr(), A = this.x.redAdd(y).redSqr().redISub(p).redISub(_);
            A = A.redIAdd(A);
            var O = p.redAdd(p).redIAdd(p).redIAdd(this.curve.a), N = O.redSqr().redISub(A).redISub(A);
            f = N;
            var U = _.redIAdd(_);
            U = U.redIAdd(U), U = U.redIAdd(U), c = O.redMul(A.redISub(N)).redISub(U), l = this.y.redAdd(this.y);
        } else {
            var D = this.z.redSqr(), H = this.y.redSqr(), K = this.x.redMul(H), re = this.x.redSub(D).redMul(this.x.redAdd(D));
            re = re.redAdd(re).redIAdd(re);
            var Q = K.redIAdd(K);
            Q = Q.redIAdd(Q);
            var G = Q.redAdd(Q);
            f = re.redSqr().redISub(G), l = this.y.redAdd(this.z).redSqr().redISub(H).redISub(D);
            var R = H.redSqr();
            R = R.redIAdd(R), R = R.redIAdd(R), R = R.redIAdd(R), c = re.redMul(Q.redISub(f)).redISub(R);
        }
        return this.curve.jpoint(f, c, l);
    }, a.prototype._dbl = function() {
        var f = this.curve.a, c = this.x, l = this.y, p = this.z, y = p.redSqr().redSqr(), _ = c.redSqr(), A = l.redSqr(), O = _.redAdd(_).redIAdd(_).redIAdd(f.redMul(y)), N = c.redAdd(c);
        N = N.redIAdd(N);
        var U = N.redMul(A), D = O.redSqr().redISub(U.redAdd(U)), H = U.redISub(D), K = A.redSqr();
        K = K.redIAdd(K), K = K.redIAdd(K), K = K.redIAdd(K);
        var re = O.redMul(H).redISub(K), Q = l.redAdd(l).redMul(p);
        return this.curve.jpoint(D, re, Q);
    }, a.prototype.trpl = function() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var f = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr(), p = c.redSqr(), y = f.redAdd(f).redIAdd(f), _ = y.redSqr(), A = this.x.redAdd(c).redSqr().redISub(f).redISub(p);
        A = A.redIAdd(A), A = A.redAdd(A).redIAdd(A), A = A.redISub(_);
        var O = A.redSqr(), N = p.redIAdd(p);
        N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
        var U = y.redIAdd(A).redSqr().redISub(_).redISub(O).redISub(N), D = c.redMul(U);
        D = D.redIAdd(D), D = D.redIAdd(D);
        var H = this.x.redMul(O).redISub(D);
        H = H.redIAdd(H), H = H.redIAdd(H);
        var K = this.y.redMul(U.redMul(N.redISub(U)).redISub(A.redMul(O)));
        K = K.redIAdd(K), K = K.redIAdd(K), K = K.redIAdd(K);
        var re = this.z.redAdd(A).redSqr().redISub(l).redISub(O);
        return this.curve.jpoint(H, K, re);
    }, a.prototype.mul = function(f, c) {
        return f = new t(f, c), this.curve._wnafMul(this, f);
    }, a.prototype.eq = function(f) {
        if (f.type === "affine") return this.eq(f.toJ());
        if (this === f) return !0;
        var c = this.z.redSqr(), l = f.z.redSqr();
        if (this.x.redMul(l).redISub(f.x.redMul(c)).cmpn(0) !== 0) return !1;
        var p = c.redMul(this.z), y = l.redMul(f.z);
        return this.y.redMul(y).redISub(f.y.redMul(p)).cmpn(0) === 0;
    }, a.prototype.eqXToP = function(f) {
        var c = this.z.redSqr(), l = f.toRed(this.curve.red).redMul(c);
        if (this.x.cmp(l) === 0) return !0;
        for(var p = f.clone(), y = this.curve.redN.redMul(c);;){
            if (p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0) return !1;
            if (l.redIAdd(y), this.x.cmp(l) === 0) return !0;
        }
    }, a.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, a.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    }, g2;
}
var y2, Z5;
function yX() {
    if (Z5) return y2;
    Z5 = 1;
    var e = bi(), t = Or(), r = Tb(), n = ms();
    function i(s) {
        r.call(this, "mont", s), this.a = new e(s.a, 16).toRed(this.red), this.b = new e(s.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    t(i, r), y2 = i, i.prototype.validate = function(a) {
        var u = a.normalize().x, f = u.redSqr(), c = f.redMul(u).redAdd(f.redMul(this.a)).redAdd(u), l = c.redSqrt();
        return l.redSqr().cmp(c) === 0;
    };
    function o(s, a, u) {
        r.BasePoint.call(this, s, "projective"), a === null && u === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(a, 16), this.z = new e(u, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    return t(o, r.BasePoint), i.prototype.decodePoint = function(a, u) {
        return this.point(n.toArray(a, u), 1);
    }, i.prototype.point = function(a, u) {
        return new o(this, a, u);
    }, i.prototype.pointFromJSON = function(a) {
        return o.fromJSON(this, a);
    }, o.prototype.precompute = function() {}, o.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    }, o.fromJSON = function(a, u) {
        return new o(a, u[0], u[1] || a.one);
    }, o.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, o.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    }, o.prototype.dbl = function() {
        var a = this.x.redAdd(this.z), u = a.redSqr(), f = this.x.redSub(this.z), c = f.redSqr(), l = u.redSub(c), p = u.redMul(c), y = l.redMul(c.redAdd(this.curve.a24.redMul(l)));
        return this.curve.point(p, y);
    }, o.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.diffAdd = function(a, u) {
        var f = this.x.redAdd(this.z), c = this.x.redSub(this.z), l = a.x.redAdd(a.z), p = a.x.redSub(a.z), y = p.redMul(f), _ = l.redMul(c), A = u.z.redMul(y.redAdd(_).redSqr()), O = u.x.redMul(y.redISub(_).redSqr());
        return this.curve.point(A, O);
    }, o.prototype.mul = function(a) {
        for(var u = a.clone(), f = this, c = this.curve.point(null, null), l = this, p = []; u.cmpn(0) !== 0; u.iushrn(1))p.push(u.andln(1));
        for(var y = p.length - 1; y >= 0; y--)p[y] === 0 ? (f = f.diffAdd(c, l), c = c.dbl()) : (c = f.diffAdd(c, l), f = f.dbl());
        return c;
    }, o.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.eq = function(a) {
        return this.getX().cmp(a.getX()) === 0;
    }, o.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, o.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    }, y2;
}
var m2, Y5;
function mX() {
    if (Y5) return m2;
    Y5 = 1;
    var e = ms(), t = bi(), r = Or(), n = Tb(), i = e.assert;
    function o(a) {
        this.twisted = (a.a | 0) !== 1, this.mOneA = this.twisted && (a.a | 0) === -1, this.extended = this.mOneA, n.call(this, "edwards", a), this.a = new t(a.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(a.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(a.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), i(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (a.c | 0) === 1;
    }
    r(o, n), m2 = o, o.prototype._mulA = function(u) {
        return this.mOneA ? u.redNeg() : this.a.redMul(u);
    }, o.prototype._mulC = function(u) {
        return this.oneC ? u : this.c.redMul(u);
    }, o.prototype.jpoint = function(u, f, c, l) {
        return this.point(u, f, c, l);
    }, o.prototype.pointFromX = function(u, f) {
        u = new t(u, 16), u.red || (u = u.toRed(this.red));
        var c = u.redSqr(), l = this.c2.redSub(this.a.redMul(c)), p = this.one.redSub(this.c2.redMul(this.d).redMul(c)), y = l.redMul(p.redInvm()), _ = y.redSqrt();
        if (_.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error("invalid point");
        var A = _.fromRed().isOdd();
        return (f && !A || !f && A) && (_ = _.redNeg()), this.point(u, _);
    }, o.prototype.pointFromY = function(u, f) {
        u = new t(u, 16), u.red || (u = u.toRed(this.red));
        var c = u.redSqr(), l = c.redSub(this.c2), p = c.redMul(this.d).redMul(this.c2).redSub(this.a), y = l.redMul(p.redInvm());
        if (y.cmp(this.zero) === 0) {
            if (f) throw new Error("invalid point");
            return this.point(this.zero, u);
        }
        var _ = y.redSqrt();
        if (_.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error("invalid point");
        return _.fromRed().isOdd() !== f && (_ = _.redNeg()), this.point(_, u);
    }, o.prototype.validate = function(u) {
        if (u.isInfinity()) return !0;
        u.normalize();
        var f = u.x.redSqr(), c = u.y.redSqr(), l = f.redMul(this.a).redAdd(c), p = this.c2.redMul(this.one.redAdd(this.d.redMul(f).redMul(c)));
        return l.cmp(p) === 0;
    };
    function s(a, u, f, c, l) {
        n.BasePoint.call(this, a, "projective"), u === null && f === null && c === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(u, 16), this.y = new t(f, 16), this.z = c ? new t(c, 16) : this.curve.one, this.t = l && new t(l, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    return r(s, n.BasePoint), o.prototype.pointFromJSON = function(u) {
        return s.fromJSON(this, u);
    }, o.prototype.point = function(u, f, c, l) {
        return new s(this, u, f, c, l);
    }, s.fromJSON = function(u, f) {
        return new s(u, f[0], f[1], f[2]);
    }, s.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, s.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, s.prototype._extDbl = function() {
        var u = this.x.redSqr(), f = this.y.redSqr(), c = this.z.redSqr();
        c = c.redIAdd(c);
        var l = this.curve._mulA(u), p = this.x.redAdd(this.y).redSqr().redISub(u).redISub(f), y = l.redAdd(f), _ = y.redSub(c), A = l.redSub(f), O = p.redMul(_), N = y.redMul(A), U = p.redMul(A), D = _.redMul(y);
        return this.curve.point(O, N, D, U);
    }, s.prototype._projDbl = function() {
        var u = this.x.redAdd(this.y).redSqr(), f = this.x.redSqr(), c = this.y.redSqr(), l, p, y, _, A, O;
        if (this.curve.twisted) {
            _ = this.curve._mulA(f);
            var N = _.redAdd(c);
            this.zOne ? (l = u.redSub(f).redSub(c).redMul(N.redSub(this.curve.two)), p = N.redMul(_.redSub(c)), y = N.redSqr().redSub(N).redSub(N)) : (A = this.z.redSqr(), O = N.redSub(A).redISub(A), l = u.redSub(f).redISub(c).redMul(O), p = N.redMul(_.redSub(c)), y = N.redMul(O));
        } else _ = f.redAdd(c), A = this.curve._mulC(this.z).redSqr(), O = _.redSub(A).redSub(A), l = this.curve._mulC(u.redISub(_)).redMul(O), p = this.curve._mulC(_).redMul(f.redISub(c)), y = _.redMul(O);
        return this.curve.point(l, p, y);
    }, s.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }, s.prototype._extAdd = function(u) {
        var f = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), c = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), l = this.t.redMul(this.curve.dd).redMul(u.t), p = this.z.redMul(u.z.redAdd(u.z)), y = c.redSub(f), _ = p.redSub(l), A = p.redAdd(l), O = c.redAdd(f), N = y.redMul(_), U = A.redMul(O), D = y.redMul(O), H = _.redMul(A);
        return this.curve.point(N, U, H, D);
    }, s.prototype._projAdd = function(u) {
        var f = this.z.redMul(u.z), c = f.redSqr(), l = this.x.redMul(u.x), p = this.y.redMul(u.y), y = this.curve.d.redMul(l).redMul(p), _ = c.redSub(y), A = c.redAdd(y), O = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(l).redISub(p), N = f.redMul(_).redMul(O), U, D;
        return this.curve.twisted ? (U = f.redMul(A).redMul(p.redSub(this.curve._mulA(l))), D = _.redMul(A)) : (U = f.redMul(A).redMul(p.redSub(l)), D = this.curve._mulC(_).redMul(A)), this.curve.point(N, U, D);
    }, s.prototype.add = function(u) {
        return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u);
    }, s.prototype.mul = function(u) {
        return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u);
    }, s.prototype.mulAdd = function(u, f, c) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            u,
            c
        ], 2, !1);
    }, s.prototype.jmulAdd = function(u, f, c) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            u,
            c
        ], 2, !0);
    }, s.prototype.normalize = function() {
        if (this.zOne) return this;
        var u = this.z.redInvm();
        return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this;
    }, s.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, s.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    }, s.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
    }, s.prototype.eq = function(u) {
        return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0;
    }, s.prototype.eqXToP = function(u) {
        var f = u.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(f) === 0) return !0;
        for(var c = u.clone(), l = this.curve.redN.redMul(this.z);;){
            if (c.iadd(this.curve.n), c.cmp(this.curve.p) >= 0) return !1;
            if (f.redIAdd(l), this.x.cmp(f) === 0) return !0;
        }
    }, s.prototype.toP = s.prototype.normalize, s.prototype.mixedAdd = s.prototype.add, m2;
}
var X5;
function BO() {
    return X5 || (X5 = 1, function(e) {
        var t = e;
        t.base = Tb(), t.short = gX(), t.mont = yX(), t.edwards = mX();
    }(h2)), h2;
}
var b2 = {}, w2 = {}, nn = {}, J5;
function Sa() {
    if (J5) return nn;
    J5 = 1;
    var e = ys(), t = Or();
    nn.inherits = t;
    function r(S, w) {
        return (S.charCodeAt(w) & 64512) !== 55296 || w < 0 || w + 1 >= S.length ? !1 : (S.charCodeAt(w + 1) & 64512) === 56320;
    }
    function n(S, w) {
        if (Array.isArray(S)) return S.slice();
        if (!S) return [];
        var g = [];
        if (typeof S == "string") if (w) {
            if (w === "hex") for(S = S.replace(/[^a-z0-9]+/ig, ""), S.length % 2 !== 0 && (S = "0" + S), E = 0; E < S.length; E += 2)g.push(parseInt(S[E] + S[E + 1], 16));
        } else for(var m = 0, E = 0; E < S.length; E++){
            var T = S.charCodeAt(E);
            T < 128 ? g[m++] = T : T < 2048 ? (g[m++] = T >> 6 | 192, g[m++] = T & 63 | 128) : r(S, E) ? (T = 65536 + ((T & 1023) << 10) + (S.charCodeAt(++E) & 1023), g[m++] = T >> 18 | 240, g[m++] = T >> 12 & 63 | 128, g[m++] = T >> 6 & 63 | 128, g[m++] = T & 63 | 128) : (g[m++] = T >> 12 | 224, g[m++] = T >> 6 & 63 | 128, g[m++] = T & 63 | 128);
        }
        else for(E = 0; E < S.length; E++)g[E] = S[E] | 0;
        return g;
    }
    nn.toArray = n;
    function i(S) {
        for(var w = "", g = 0; g < S.length; g++)w += a(S[g].toString(16));
        return w;
    }
    nn.toHex = i;
    function o(S) {
        var w = S >>> 24 | S >>> 8 & 65280 | S << 8 & 16711680 | (S & 255) << 24;
        return w >>> 0;
    }
    nn.htonl = o;
    function s(S, w) {
        for(var g = "", m = 0; m < S.length; m++){
            var E = S[m];
            w === "little" && (E = o(E)), g += u(E.toString(16));
        }
        return g;
    }
    nn.toHex32 = s;
    function a(S) {
        return S.length === 1 ? "0" + S : S;
    }
    nn.zero2 = a;
    function u(S) {
        return S.length === 7 ? "0" + S : S.length === 6 ? "00" + S : S.length === 5 ? "000" + S : S.length === 4 ? "0000" + S : S.length === 3 ? "00000" + S : S.length === 2 ? "000000" + S : S.length === 1 ? "0000000" + S : S;
    }
    nn.zero8 = u;
    function f(S, w, g, m) {
        var E = g - w;
        e(E % 4 === 0);
        for(var T = new Array(E / 4), I = 0, P = w; I < T.length; I++, P += 4){
            var k;
            m === "big" ? k = S[P] << 24 | S[P + 1] << 16 | S[P + 2] << 8 | S[P + 3] : k = S[P + 3] << 24 | S[P + 2] << 16 | S[P + 1] << 8 | S[P], T[I] = k >>> 0;
        }
        return T;
    }
    nn.join32 = f;
    function c(S, w) {
        for(var g = new Array(S.length * 4), m = 0, E = 0; m < S.length; m++, E += 4){
            var T = S[m];
            w === "big" ? (g[E] = T >>> 24, g[E + 1] = T >>> 16 & 255, g[E + 2] = T >>> 8 & 255, g[E + 3] = T & 255) : (g[E + 3] = T >>> 24, g[E + 2] = T >>> 16 & 255, g[E + 1] = T >>> 8 & 255, g[E] = T & 255);
        }
        return g;
    }
    nn.split32 = c;
    function l(S, w) {
        return S >>> w | S << 32 - w;
    }
    nn.rotr32 = l;
    function p(S, w) {
        return S << w | S >>> 32 - w;
    }
    nn.rotl32 = p;
    function y(S, w) {
        return S + w >>> 0;
    }
    nn.sum32 = y;
    function _(S, w, g) {
        return S + w + g >>> 0;
    }
    nn.sum32_3 = _;
    function A(S, w, g, m) {
        return S + w + g + m >>> 0;
    }
    nn.sum32_4 = A;
    function O(S, w, g, m, E) {
        return S + w + g + m + E >>> 0;
    }
    nn.sum32_5 = O;
    function N(S, w, g, m) {
        var E = S[w], T = S[w + 1], I = m + T >>> 0, P = (I < m ? 1 : 0) + g + E;
        S[w] = P >>> 0, S[w + 1] = I;
    }
    nn.sum64 = N;
    function U(S, w, g, m) {
        var E = w + m >>> 0, T = (E < w ? 1 : 0) + S + g;
        return T >>> 0;
    }
    nn.sum64_hi = U;
    function D(S, w, g, m) {
        var E = w + m;
        return E >>> 0;
    }
    nn.sum64_lo = D;
    function H(S, w, g, m, E, T, I, P) {
        var k = 0, L = w;
        L = L + m >>> 0, k += L < w ? 1 : 0, L = L + T >>> 0, k += L < T ? 1 : 0, L = L + P >>> 0, k += L < P ? 1 : 0;
        var j = S + g + E + I + k;
        return j >>> 0;
    }
    nn.sum64_4_hi = H;
    function K(S, w, g, m, E, T, I, P) {
        var k = w + m + T + P;
        return k >>> 0;
    }
    nn.sum64_4_lo = K;
    function re(S, w, g, m, E, T, I, P, k, L) {
        var j = 0, ie = w;
        ie = ie + m >>> 0, j += ie < w ? 1 : 0, ie = ie + T >>> 0, j += ie < T ? 1 : 0, ie = ie + P >>> 0, j += ie < P ? 1 : 0, ie = ie + L >>> 0, j += ie < L ? 1 : 0;
        var ue = S + g + E + I + k + j;
        return ue >>> 0;
    }
    nn.sum64_5_hi = re;
    function Q(S, w, g, m, E, T, I, P, k, L) {
        var j = w + m + T + P + L;
        return j >>> 0;
    }
    nn.sum64_5_lo = Q;
    function G(S, w, g) {
        var m = w << 32 - g | S >>> g;
        return m >>> 0;
    }
    nn.rotr64_hi = G;
    function R(S, w, g) {
        var m = S << 32 - g | w >>> g;
        return m >>> 0;
    }
    nn.rotr64_lo = R;
    function X(S, w, g) {
        return S >>> g;
    }
    nn.shr64_hi = X;
    function $(S, w, g) {
        var m = S << 32 - g | w >>> g;
        return m >>> 0;
    }
    return nn.shr64_lo = $, nn;
}
var v2 = {}, Q5;
function s0() {
    if (Q5) return v2;
    Q5 = 1;
    var e = Sa(), t = ys();
    function r() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    return v2.BlockHash = r, r.prototype.update = function(i, o) {
        if (i = e.toArray(i, o), this.pending ? this.pending = this.pending.concat(i) : this.pending = i, this.pendingTotal += i.length, this.pending.length >= this._delta8) {
            i = this.pending;
            var s = i.length % this._delta8;
            this.pending = i.slice(i.length - s, i.length), this.pending.length === 0 && (this.pending = null), i = e.join32(i, 0, i.length - s, this.endian);
            for(var a = 0; a < i.length; a += this._delta32)this._update(i, a, a + this._delta32);
        }
        return this;
    }, r.prototype.digest = function(i) {
        return this.update(this._pad()), t(this.pending === null), this._digest(i);
    }, r.prototype._pad = function() {
        var i = this.pendingTotal, o = this._delta8, s = o - (i + this.padLength) % o, a = new Array(s + this.padLength);
        a[0] = 128;
        for(var u = 1; u < s; u++)a[u] = 0;
        if (i <<= 3, this.endian === "big") {
            for(var f = 8; f < this.padLength; f++)a[u++] = 0;
            a[u++] = 0, a[u++] = 0, a[u++] = 0, a[u++] = 0, a[u++] = i >>> 24 & 255, a[u++] = i >>> 16 & 255, a[u++] = i >>> 8 & 255, a[u++] = i & 255;
        } else for(a[u++] = i & 255, a[u++] = i >>> 8 & 255, a[u++] = i >>> 16 & 255, a[u++] = i >>> 24 & 255, a[u++] = 0, a[u++] = 0, a[u++] = 0, a[u++] = 0, f = 8; f < this.padLength; f++)a[u++] = 0;
        return a;
    }, v2;
}
var Ku = {}, Zs = {}, eT;
function OO() {
    if (eT) return Zs;
    eT = 1;
    var e = Sa(), t = e.rotr32;
    function r(c, l, p, y) {
        if (c === 0) return n(l, p, y);
        if (c === 1 || c === 3) return o(l, p, y);
        if (c === 2) return i(l, p, y);
    }
    Zs.ft_1 = r;
    function n(c, l, p) {
        return c & l ^ ~c & p;
    }
    Zs.ch32 = n;
    function i(c, l, p) {
        return c & l ^ c & p ^ l & p;
    }
    Zs.maj32 = i;
    function o(c, l, p) {
        return c ^ l ^ p;
    }
    Zs.p32 = o;
    function s(c) {
        return t(c, 2) ^ t(c, 13) ^ t(c, 22);
    }
    Zs.s0_256 = s;
    function a(c) {
        return t(c, 6) ^ t(c, 11) ^ t(c, 25);
    }
    Zs.s1_256 = a;
    function u(c) {
        return t(c, 7) ^ t(c, 18) ^ c >>> 3;
    }
    Zs.g0_256 = u;
    function f(c) {
        return t(c, 17) ^ t(c, 19) ^ c >>> 10;
    }
    return Zs.g1_256 = f, Zs;
}
var _2, tT;
function bX() {
    if (tT) return _2;
    tT = 1;
    var e = Sa(), t = s0(), r = OO(), n = e.rotl32, i = e.sum32, o = e.sum32_5, s = r.ft_1, a = t.BlockHash, u = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    function f() {
        if (!(this instanceof f)) return new f();
        a.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.W = new Array(80);
    }
    return e.inherits(f, a), _2 = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 80, f.padLength = 64, f.prototype._update = function(l, p) {
        for(var y = this.W, _ = 0; _ < 16; _++)y[_] = l[p + _];
        for(; _ < y.length; _++)y[_] = n(y[_ - 3] ^ y[_ - 8] ^ y[_ - 14] ^ y[_ - 16], 1);
        var A = this.h[0], O = this.h[1], N = this.h[2], U = this.h[3], D = this.h[4];
        for(_ = 0; _ < y.length; _++){
            var H = ~~(_ / 20), K = o(n(A, 5), s(H, O, N, U), D, y[_], u[H]);
            D = U, U = N, N = n(O, 30), O = A, A = K;
        }
        this.h[0] = i(this.h[0], A), this.h[1] = i(this.h[1], O), this.h[2] = i(this.h[2], N), this.h[3] = i(this.h[3], U), this.h[4] = i(this.h[4], D);
    }, f.prototype._digest = function(l) {
        return l === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    }, _2;
}
var E2, rT;
function PO() {
    if (rT) return E2;
    rT = 1;
    var e = Sa(), t = s0(), r = OO(), n = ys(), i = e.sum32, o = e.sum32_4, s = e.sum32_5, a = r.ch32, u = r.maj32, f = r.s0_256, c = r.s1_256, l = r.g0_256, p = r.g1_256, y = t.BlockHash, _ = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ];
    function A() {
        if (!(this instanceof A)) return new A();
        y.call(this), this.h = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
        ], this.k = _, this.W = new Array(64);
    }
    return e.inherits(A, y), E2 = A, A.blockSize = 512, A.outSize = 256, A.hmacStrength = 192, A.padLength = 64, A.prototype._update = function(N, U) {
        for(var D = this.W, H = 0; H < 16; H++)D[H] = N[U + H];
        for(; H < D.length; H++)D[H] = o(p(D[H - 2]), D[H - 7], l(D[H - 15]), D[H - 16]);
        var K = this.h[0], re = this.h[1], Q = this.h[2], G = this.h[3], R = this.h[4], X = this.h[5], $ = this.h[6], S = this.h[7];
        for(n(this.k.length === D.length), H = 0; H < D.length; H++){
            var w = s(S, c(R), a(R, X, $), this.k[H], D[H]), g = i(f(K), u(K, re, Q));
            S = $, $ = X, X = R, R = i(G, w), G = Q, Q = re, re = K, K = i(w, g);
        }
        this.h[0] = i(this.h[0], K), this.h[1] = i(this.h[1], re), this.h[2] = i(this.h[2], Q), this.h[3] = i(this.h[3], G), this.h[4] = i(this.h[4], R), this.h[5] = i(this.h[5], X), this.h[6] = i(this.h[6], $), this.h[7] = i(this.h[7], S);
    }, A.prototype._digest = function(N) {
        return N === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    }, E2;
}
var x2, nT;
function wX() {
    if (nT) return x2;
    nT = 1;
    var e = Sa(), t = PO();
    function r() {
        if (!(this instanceof r)) return new r();
        t.call(this), this.h = [
            3238371032,
            914150663,
            812702999,
            4144912697,
            4290775857,
            1750603025,
            1694076839,
            3204075428
        ];
    }
    return e.inherits(r, t), x2 = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(i) {
        return i === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
    }, x2;
}
var S2, iT;
function NO() {
    if (iT) return S2;
    iT = 1;
    var e = Sa(), t = s0(), r = ys(), n = e.rotr64_hi, i = e.rotr64_lo, o = e.shr64_hi, s = e.shr64_lo, a = e.sum64, u = e.sum64_hi, f = e.sum64_lo, c = e.sum64_4_hi, l = e.sum64_4_lo, p = e.sum64_5_hi, y = e.sum64_5_lo, _ = t.BlockHash, A = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ];
    function O() {
        if (!(this instanceof O)) return new O();
        _.call(this), this.h = [
            1779033703,
            4089235720,
            3144134277,
            2227873595,
            1013904242,
            4271175723,
            2773480762,
            1595750129,
            1359893119,
            2917565137,
            2600822924,
            725511199,
            528734635,
            4215389547,
            1541459225,
            327033209
        ], this.k = A, this.W = new Array(160);
    }
    e.inherits(O, _), S2 = O, O.blockSize = 1024, O.outSize = 512, O.hmacStrength = 192, O.padLength = 128, O.prototype._prepareBlock = function(g, m) {
        for(var E = this.W, T = 0; T < 32; T++)E[T] = g[m + T];
        for(; T < E.length; T += 2){
            var I = $(E[T - 4], E[T - 3]), P = S(E[T - 4], E[T - 3]), k = E[T - 14], L = E[T - 13], j = R(E[T - 30], E[T - 29]), ie = X(E[T - 30], E[T - 29]), ue = E[T - 32], ce = E[T - 31];
            E[T] = c(I, P, k, L, j, ie, ue, ce), E[T + 1] = l(I, P, k, L, j, ie, ue, ce);
        }
    }, O.prototype._update = function(g, m) {
        this._prepareBlock(g, m);
        var E = this.W, T = this.h[0], I = this.h[1], P = this.h[2], k = this.h[3], L = this.h[4], j = this.h[5], ie = this.h[6], ue = this.h[7], ce = this.h[8], he = this.h[9], ee = this.h[10], ae = this.h[11], ye = this.h[12], Se = this.h[13], De = this.h[14], Re = this.h[15];
        r(this.k.length === E.length);
        for(var Ce = 0; Ce < E.length; Ce += 2){
            var M = De, z = Re, de = Q(ce, he), _e = G(ce, he), Ie = N(ce, he, ee, ae, ye), je = U(ce, he, ee, ae, ye, Se), Ke = this.k[Ce], Ue = this.k[Ce + 1], h = E[Ce], x = E[Ce + 1], q = p(M, z, de, _e, Ie, je, Ke, Ue, h, x), te = y(M, z, de, _e, Ie, je, Ke, Ue, h, x);
            M = K(T, I), z = re(T, I), de = D(T, I, P, k, L), _e = H(T, I, P, k, L, j);
            var fe = u(M, z, de, _e), ne = f(M, z, de, _e);
            De = ye, Re = Se, ye = ee, Se = ae, ee = ce, ae = he, ce = u(ie, ue, q, te), he = f(ue, ue, q, te), ie = L, ue = j, L = P, j = k, P = T, k = I, T = u(q, te, fe, ne), I = f(q, te, fe, ne);
        }
        a(this.h, 0, T, I), a(this.h, 2, P, k), a(this.h, 4, L, j), a(this.h, 6, ie, ue), a(this.h, 8, ce, he), a(this.h, 10, ee, ae), a(this.h, 12, ye, Se), a(this.h, 14, De, Re);
    }, O.prototype._digest = function(g) {
        return g === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    };
    function N(w, g, m, E, T) {
        var I = w & m ^ ~w & T;
        return I < 0 && (I += 4294967296), I;
    }
    function U(w, g, m, E, T, I) {
        var P = g & E ^ ~g & I;
        return P < 0 && (P += 4294967296), P;
    }
    function D(w, g, m, E, T) {
        var I = w & m ^ w & T ^ m & T;
        return I < 0 && (I += 4294967296), I;
    }
    function H(w, g, m, E, T, I) {
        var P = g & E ^ g & I ^ E & I;
        return P < 0 && (P += 4294967296), P;
    }
    function K(w, g) {
        var m = n(w, g, 28), E = n(g, w, 2), T = n(g, w, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function re(w, g) {
        var m = i(w, g, 28), E = i(g, w, 2), T = i(g, w, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function Q(w, g) {
        var m = n(w, g, 14), E = n(w, g, 18), T = n(g, w, 9), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function G(w, g) {
        var m = i(w, g, 14), E = i(w, g, 18), T = i(g, w, 9), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function R(w, g) {
        var m = n(w, g, 1), E = n(w, g, 8), T = o(w, g, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function X(w, g) {
        var m = i(w, g, 1), E = i(w, g, 8), T = s(w, g, 7), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function $(w, g) {
        var m = n(w, g, 19), E = n(g, w, 29), T = o(w, g, 6), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    function S(w, g) {
        var m = i(w, g, 19), E = i(g, w, 29), T = s(w, g, 6), I = m ^ E ^ T;
        return I < 0 && (I += 4294967296), I;
    }
    return S2;
}
var A2, oT;
function vX() {
    if (oT) return A2;
    oT = 1;
    var e = Sa(), t = NO();
    function r() {
        if (!(this instanceof r)) return new r();
        t.call(this), this.h = [
            3418070365,
            3238371032,
            1654270250,
            914150663,
            2438529370,
            812702999,
            355462360,
            4144912697,
            1731405415,
            4290775857,
            2394180231,
            1750603025,
            3675008525,
            1694076839,
            1203062813,
            3204075428
        ];
    }
    return e.inherits(r, t), A2 = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(i) {
        return i === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
    }, A2;
}
var sT;
function _X() {
    return sT || (sT = 1, Ku.sha1 = bX(), Ku.sha224 = wX(), Ku.sha256 = PO(), Ku.sha384 = vX(), Ku.sha512 = NO()), Ku;
}
var T2 = {}, aT;
function EX() {
    if (aT) return T2;
    aT = 1;
    var e = Sa(), t = s0(), r = e.rotl32, n = e.sum32, i = e.sum32_3, o = e.sum32_4, s = t.BlockHash;
    function a() {
        if (!(this instanceof a)) return new a();
        s.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.endian = "little";
    }
    e.inherits(a, s), T2.ripemd160 = a, a.blockSize = 512, a.outSize = 160, a.hmacStrength = 192, a.padLength = 64, a.prototype._update = function(O, N) {
        for(var U = this.h[0], D = this.h[1], H = this.h[2], K = this.h[3], re = this.h[4], Q = U, G = D, R = H, X = K, $ = re, S = 0; S < 80; S++){
            var w = n(r(o(U, u(S, D, H, K), O[l[S] + N], f(S)), y[S]), re);
            U = re, re = K, K = r(H, 10), H = D, D = w, w = n(r(o(Q, u(79 - S, G, R, X), O[p[S] + N], c(S)), _[S]), $), Q = $, $ = X, X = r(R, 10), R = G, G = w;
        }
        w = i(this.h[1], H, X), this.h[1] = i(this.h[2], K, $), this.h[2] = i(this.h[3], re, Q), this.h[3] = i(this.h[4], U, G), this.h[4] = i(this.h[0], D, R), this.h[0] = w;
    }, a.prototype._digest = function(O) {
        return O === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
    };
    function u(A, O, N, U) {
        return A <= 15 ? O ^ N ^ U : A <= 31 ? O & N | ~O & U : A <= 47 ? (O | ~N) ^ U : A <= 63 ? O & U | N & ~U : O ^ (N | ~U);
    }
    function f(A) {
        return A <= 15 ? 0 : A <= 31 ? 1518500249 : A <= 47 ? 1859775393 : A <= 63 ? 2400959708 : 2840853838;
    }
    function c(A) {
        return A <= 15 ? 1352829926 : A <= 31 ? 1548603684 : A <= 47 ? 1836072691 : A <= 63 ? 2053994217 : 0;
    }
    var l = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], p = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], y = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], _ = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ];
    return T2;
}
var k2, cT;
function xX() {
    if (cT) return k2;
    cT = 1;
    var e = Sa(), t = ys();
    function r(n, i, o) {
        if (!(this instanceof r)) return new r(n, i, o);
        this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(i, o));
    }
    return k2 = r, r.prototype._init = function(i) {
        i.length > this.blockSize && (i = new this.Hash().update(i).digest()), t(i.length <= this.blockSize);
        for(var o = i.length; o < this.blockSize; o++)i.push(0);
        for(o = 0; o < i.length; o++)i[o] ^= 54;
        for(this.inner = new this.Hash().update(i), o = 0; o < i.length; o++)i[o] ^= 106;
        this.outer = new this.Hash().update(i);
    }, r.prototype.update = function(i, o) {
        return this.inner.update(i, o), this;
    }, r.prototype.digest = function(i) {
        return this.outer.update(this.inner.digest()), this.outer.digest(i);
    }, k2;
}
var uT;
function z3() {
    return uT || (uT = 1, function(e) {
        var t = e;
        t.utils = Sa(), t.common = s0(), t.sha = _X(), t.ripemd = EX(), t.hmac = xX(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
    }(w2)), w2;
}
var I2, fT;
function SX() {
    return fT || (fT = 1, I2 = {
        doubles: {
            step: 4,
            points: [
                [
                    "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                    "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
                ],
                [
                    "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                    "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
                ],
                [
                    "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                    "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
                ],
                [
                    "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                    "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
                ],
                [
                    "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                    "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
                ],
                [
                    "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                    "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
                ],
                [
                    "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                    "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
                ],
                [
                    "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                    "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
                ],
                [
                    "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                    "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
                ],
                [
                    "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                    "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
                ],
                [
                    "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                    "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
                ],
                [
                    "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                    "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
                ],
                [
                    "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                    "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
                ],
                [
                    "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                    "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
                ],
                [
                    "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                    "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
                ],
                [
                    "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                    "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
                ],
                [
                    "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                    "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
                ],
                [
                    "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                    "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
                ],
                [
                    "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                    "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
                ],
                [
                    "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                    "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
                ],
                [
                    "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                    "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
                ],
                [
                    "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                    "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
                ],
                [
                    "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                    "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
                ],
                [
                    "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                    "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
                ],
                [
                    "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                    "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
                ],
                [
                    "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                    "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
                ],
                [
                    "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                    "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
                ],
                [
                    "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                    "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
                ],
                [
                    "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                    "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
                ],
                [
                    "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                    "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
                ],
                [
                    "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                    "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
                ],
                [
                    "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                    "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
                ],
                [
                    "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                    "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
                ],
                [
                    "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                    "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
                ],
                [
                    "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                    "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
                ],
                [
                    "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                    "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
                ],
                [
                    "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                    "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
                ],
                [
                    "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                    "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
                ],
                [
                    "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                    "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
                ],
                [
                    "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                    "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
                ],
                [
                    "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                    "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
                ],
                [
                    "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                    "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
                ],
                [
                    "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                    "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
                ],
                [
                    "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                    "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
                ],
                [
                    "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                    "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
                ],
                [
                    "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                    "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
                ],
                [
                    "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                    "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
                ],
                [
                    "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                    "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
                ],
                [
                    "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                    "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
                ],
                [
                    "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                    "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
                ],
                [
                    "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                    "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
                ],
                [
                    "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                    "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
                ],
                [
                    "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                    "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
                ],
                [
                    "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                    "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
                ],
                [
                    "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                    "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
                ],
                [
                    "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                    "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
                ],
                [
                    "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                    "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
                ],
                [
                    "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                    "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
                ],
                [
                    "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                    "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
                ],
                [
                    "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                    "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
                ],
                [
                    "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                    "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
                ],
                [
                    "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                    "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
                ],
                [
                    "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                    "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
                ],
                [
                    "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                    "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
                ],
                [
                    "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                    "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
                ]
            ]
        },
        naf: {
            wnd: 7,
            points: [
                [
                    "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                    "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
                ],
                [
                    "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                    "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
                ],
                [
                    "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                    "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
                ],
                [
                    "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                    "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
                ],
                [
                    "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                    "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
                ],
                [
                    "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                    "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
                ],
                [
                    "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                    "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
                ],
                [
                    "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                    "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
                ],
                [
                    "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                    "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
                ],
                [
                    "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                    "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
                ],
                [
                    "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                    "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
                ],
                [
                    "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                    "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
                ],
                [
                    "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                    "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
                ],
                [
                    "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                    "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
                ],
                [
                    "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                    "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
                ],
                [
                    "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                    "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
                ],
                [
                    "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                    "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
                ],
                [
                    "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                    "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
                ],
                [
                    "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                    "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
                ],
                [
                    "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                    "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
                ],
                [
                    "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                    "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
                ],
                [
                    "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                    "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
                ],
                [
                    "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                    "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
                ],
                [
                    "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                    "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
                ],
                [
                    "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                    "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
                ],
                [
                    "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                    "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
                ],
                [
                    "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                    "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
                ],
                [
                    "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                    "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
                ],
                [
                    "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                    "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
                ],
                [
                    "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                    "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
                ],
                [
                    "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                    "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
                ],
                [
                    "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                    "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
                ],
                [
                    "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                    "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
                ],
                [
                    "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                    "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
                ],
                [
                    "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                    "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
                ],
                [
                    "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                    "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
                ],
                [
                    "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                    "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
                ],
                [
                    "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                    "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
                ],
                [
                    "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                    "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
                ],
                [
                    "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                    "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
                ],
                [
                    "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                    "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
                ],
                [
                    "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                    "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
                ],
                [
                    "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                    "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
                ],
                [
                    "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                    "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
                ],
                [
                    "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                    "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
                ],
                [
                    "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                    "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
                ],
                [
                    "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                    "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
                ],
                [
                    "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                    "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
                ],
                [
                    "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                    "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
                ],
                [
                    "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                    "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
                ],
                [
                    "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                    "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
                ],
                [
                    "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                    "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
                ],
                [
                    "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                    "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
                ],
                [
                    "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                    "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
                ],
                [
                    "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                    "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
                ],
                [
                    "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                    "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
                ],
                [
                    "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                    "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
                ],
                [
                    "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                    "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
                ],
                [
                    "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                    "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
                ],
                [
                    "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                    "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
                ],
                [
                    "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                    "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
                ],
                [
                    "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                    "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
                ],
                [
                    "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                    "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
                ],
                [
                    "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                    "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
                ],
                [
                    "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                    "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
                ],
                [
                    "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                    "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
                ],
                [
                    "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                    "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
                ],
                [
                    "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                    "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
                ],
                [
                    "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                    "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
                ],
                [
                    "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                    "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
                ],
                [
                    "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                    "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
                ],
                [
                    "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                    "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
                ],
                [
                    "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                    "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
                ],
                [
                    "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                    "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
                ],
                [
                    "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                    "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
                ],
                [
                    "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                    "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
                ],
                [
                    "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                    "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
                ],
                [
                    "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                    "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
                ],
                [
                    "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                    "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
                ],
                [
                    "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                    "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
                ],
                [
                    "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                    "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
                ],
                [
                    "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                    "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
                ],
                [
                    "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                    "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
                ],
                [
                    "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                    "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
                ],
                [
                    "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                    "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
                ],
                [
                    "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                    "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
                ],
                [
                    "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                    "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
                ],
                [
                    "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                    "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
                ],
                [
                    "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                    "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
                ],
                [
                    "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                    "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
                ],
                [
                    "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                    "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
                ],
                [
                    "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                    "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
                ],
                [
                    "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                    "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
                ],
                [
                    "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                    "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
                ],
                [
                    "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                    "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
                ],
                [
                    "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                    "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
                ],
                [
                    "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                    "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
                ],
                [
                    "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                    "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
                ],
                [
                    "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                    "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
                ],
                [
                    "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                    "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
                ],
                [
                    "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                    "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
                ],
                [
                    "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                    "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
                ],
                [
                    "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                    "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
                ],
                [
                    "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                    "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
                ],
                [
                    "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                    "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
                ],
                [
                    "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                    "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
                ],
                [
                    "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                    "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
                ],
                [
                    "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                    "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
                ],
                [
                    "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                    "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
                ],
                [
                    "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                    "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
                ],
                [
                    "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                    "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
                ],
                [
                    "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                    "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
                ],
                [
                    "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                    "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
                ],
                [
                    "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                    "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
                ],
                [
                    "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                    "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
                ],
                [
                    "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                    "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
                ],
                [
                    "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                    "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
                ],
                [
                    "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                    "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
                ],
                [
                    "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                    "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
                ],
                [
                    "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                    "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
                ],
                [
                    "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                    "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
                ],
                [
                    "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                    "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
                ],
                [
                    "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                    "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
                ],
                [
                    "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                    "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
                ],
                [
                    "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                    "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
                ],
                [
                    "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                    "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
                ],
                [
                    "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                    "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
                ]
            ]
        }
    }), I2;
}
var lT;
function j3() {
    return lT || (lT = 1, function(e) {
        var t = e, r = z3(), n = BO(), i = ms(), o = i.assert;
        function s(f) {
            f.type === "short" ? this.curve = new n.short(f) : f.type === "edwards" ? this.curve = new n.edwards(f) : this.curve = new n.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, o(this.g.validate(), "Invalid curve"), o(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        t.PresetCurve = s;
        function a(f, c) {
            Object.defineProperty(t, f, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var l = new s(c);
                    return Object.defineProperty(t, f, {
                        configurable: !0,
                        enumerable: !0,
                        value: l
                    }), l;
                }
            });
        }
        a("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: r.sha256,
            gRed: !1,
            g: [
                "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
                "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
            ]
        }), a("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: r.sha256,
            gRed: !1,
            g: [
                "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
                "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
            ]
        }), a("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: r.sha256,
            gRed: !1,
            g: [
                "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
                "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
            ]
        }), a("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: r.sha384,
            gRed: !1,
            g: [
                "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
            ]
        }), a("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: r.sha512,
            gRed: !1,
            g: [
                "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
            ]
        }), a("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: r.sha256,
            gRed: !1,
            g: [
                "9"
            ]
        }), a("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            // -121665 * (121666^(-1)) (mod P)
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: r.sha256,
            gRed: !1,
            g: [
                "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
                // 4/5
                "6666666666666666666666666666666666666666666666666666666666666658"
            ]
        });
        var u;
        try {
            u = SX();
        } catch  {
            u = void 0;
        }
        a("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: r.sha256,
            // Precomputed endomorphism
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                {
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                },
                {
                    a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                    b: "3086d221a7d46bcde86c90e49284eb15"
                }
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                u
            ]
        });
    }(b2)), b2;
}
var B2, dT;
function AX() {
    if (dT) return B2;
    dT = 1;
    var e = z3(), t = IO(), r = ys();
    function n(i) {
        if (!(this instanceof n)) return new n(i);
        this.hash = i.hash, this.predResist = !!i.predResist, this.outLen = this.hash.outSize, this.minEntropy = i.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var o = t.toArray(i.entropy, i.entropyEnc || "hex"), s = t.toArray(i.nonce, i.nonceEnc || "hex"), a = t.toArray(i.pers, i.persEnc || "hex");
        r(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(o, s, a);
    }
    return B2 = n, n.prototype._init = function(o, s, a) {
        var u = o.concat(s).concat(a);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for(var f = 0; f < this.V.length; f++)this.K[f] = 0, this.V[f] = 1;
        this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, n.prototype._hmac = function() {
        return new e.hmac(this.hash, this.K);
    }, n.prototype._update = function(o) {
        var s = this._hmac().update(this.V).update([
            0
        ]);
        o && (s = s.update(o)), this.K = s.digest(), this.V = this._hmac().update(this.V).digest(), o && (this.K = this._hmac().update(this.V).update([
            1
        ]).update(o).digest(), this.V = this._hmac().update(this.V).digest());
    }, n.prototype.reseed = function(o, s, a, u) {
        typeof s != "string" && (u = a, a = s, s = null), o = t.toArray(o, s), a = t.toArray(a, u), r(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(o.concat(a || [])), this._reseed = 1;
    }, n.prototype.generate = function(o, s, a, u) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        typeof s != "string" && (u = a, a = s, s = null), a && (a = t.toArray(a, u || "hex"), this._update(a));
        for(var f = []; f.length < o;)this.V = this._hmac().update(this.V).digest(), f = f.concat(this.V);
        var c = f.slice(0, o);
        return this._update(a), this._reseed++, t.encode(c, s);
    }, B2;
}
var O2, hT;
function TX() {
    if (hT) return O2;
    hT = 1;
    var e = bi(), t = ms(), r = t.assert;
    function n(i, o) {
        this.ec = i, this.priv = null, this.pub = null, o.priv && this._importPrivate(o.priv, o.privEnc), o.pub && this._importPublic(o.pub, o.pubEnc);
    }
    return O2 = n, n.fromPublic = function(o, s, a) {
        return s instanceof n ? s : new n(o, {
            pub: s,
            pubEnc: a
        });
    }, n.fromPrivate = function(o, s, a) {
        return s instanceof n ? s : new n(o, {
            priv: s,
            privEnc: a
        });
    }, n.prototype.validate = function() {
        var o = this.getPublic();
        return o.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : o.validate() ? o.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        };
    }, n.prototype.getPublic = function(o, s) {
        return typeof o == "string" && (s = o, o = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), s ? this.pub.encode(s, o) : this.pub;
    }, n.prototype.getPrivate = function(o) {
        return o === "hex" ? this.priv.toString(16, 2) : this.priv;
    }, n.prototype._importPrivate = function(o, s) {
        this.priv = new e(o, s || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, n.prototype._importPublic = function(o, s) {
        if (o.x || o.y) {
            this.ec.curve.type === "mont" ? r(o.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && r(o.x && o.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(o.x, o.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(o, s);
    }, n.prototype.derive = function(o) {
        return o.validate() || r(o.validate(), "public point not validated"), o.mul(this.priv).getX();
    }, n.prototype.sign = function(o, s, a) {
        return this.ec.sign(o, this, s, a);
    }, n.prototype.verify = function(o, s, a) {
        return this.ec.verify(o, s, this, void 0, a);
    }, n.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    }, O2;
}
var P2, pT;
function kX() {
    if (pT) return P2;
    pT = 1;
    var e = bi(), t = ms(), r = t.assert;
    function n(u, f) {
        if (u instanceof n) return u;
        this._importDER(u, f) || (r(u.r && u.s, "Signature without r or s"), this.r = new e(u.r, 16), this.s = new e(u.s, 16), u.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = u.recoveryParam);
    }
    P2 = n;
    function i() {
        this.place = 0;
    }
    function o(u, f) {
        var c = u[f.place++];
        if (!(c & 128)) return c;
        var l = c & 15;
        if (l === 0 || l > 4 || u[f.place] === 0) return !1;
        for(var p = 0, y = 0, _ = f.place; y < l; y++, _++)p <<= 8, p |= u[_], p >>>= 0;
        return p <= 127 ? !1 : (f.place = _, p);
    }
    function s(u) {
        for(var f = 0, c = u.length - 1; !u[f] && !(u[f + 1] & 128) && f < c;)f++;
        return f === 0 ? u : u.slice(f);
    }
    n.prototype._importDER = function(f, c) {
        f = t.toArray(f, c);
        var l = new i();
        if (f[l.place++] !== 48) return !1;
        var p = o(f, l);
        if (p === !1 || p + l.place !== f.length || f[l.place++] !== 2) return !1;
        var y = o(f, l);
        if (y === !1 || f[l.place] & 128) return !1;
        var _ = f.slice(l.place, y + l.place);
        if (l.place += y, f[l.place++] !== 2) return !1;
        var A = o(f, l);
        if (A === !1 || f.length !== A + l.place || f[l.place] & 128) return !1;
        var O = f.slice(l.place, A + l.place);
        if (_[0] === 0) if (_[1] & 128) _ = _.slice(1);
        else return !1;
        if (O[0] === 0) if (O[1] & 128) O = O.slice(1);
        else return !1;
        return this.r = new e(_), this.s = new e(O), this.recoveryParam = null, !0;
    };
    function a(u, f) {
        if (f < 128) {
            u.push(f);
            return;
        }
        var c = 1 + (Math.log(f) / Math.LN2 >>> 3);
        for(u.push(c | 128); --c;)u.push(f >>> (c << 3) & 255);
        u.push(f);
    }
    return n.prototype.toDER = function(f) {
        var c = this.r.toArray(), l = this.s.toArray();
        for(c[0] & 128 && (c = [
            0
        ].concat(c)), l[0] & 128 && (l = [
            0
        ].concat(l)), c = s(c), l = s(l); !l[0] && !(l[1] & 128);)l = l.slice(1);
        var p = [
            2
        ];
        a(p, c.length), p = p.concat(c), p.push(2), a(p, l.length);
        var y = p.concat(l), _ = [
            48
        ];
        return a(_, y.length), _ = _.concat(y), t.encode(_, f);
    }, P2;
}
var N2, gT;
function IX() {
    if (gT) return N2;
    gT = 1;
    var e = bi(), t = AX(), r = ms(), n = j3(), i = L3(), o = r.assert, s = TX(), a = kX();
    function u(f) {
        if (!(this instanceof u)) return new u(f);
        typeof f == "string" && (o(Object.prototype.hasOwnProperty.call(n, f), "Unknown curve " + f), f = n[f]), f instanceof n.PresetCurve && (f = {
            curve: f
        }), this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash;
    }
    return N2 = u, u.prototype.keyPair = function(c) {
        return new s(this, c);
    }, u.prototype.keyFromPrivate = function(c, l) {
        return s.fromPrivate(this, c, l);
    }, u.prototype.keyFromPublic = function(c, l) {
        return s.fromPublic(this, c, l);
    }, u.prototype.genKeyPair = function(c) {
        c || (c = {});
        for(var l = new t({
            hash: this.hash,
            pers: c.pers,
            persEnc: c.persEnc || "utf8",
            entropy: c.entropy || i(this.hash.hmacStrength),
            entropyEnc: c.entropy && c.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), p = this.n.byteLength(), y = this.n.sub(new e(2));;){
            var _ = new e(l.generate(p));
            if (!(_.cmp(y) > 0)) return _.iaddn(1), this.keyFromPrivate(_);
        }
    }, u.prototype._truncateToN = function(c, l, p) {
        var y;
        if (e.isBN(c) || typeof c == "number") c = new e(c, 16), y = c.byteLength();
        else if (typeof c == "object") y = c.length, c = new e(c, 16);
        else {
            var _ = c.toString();
            y = _.length + 1 >>> 1, c = new e(_, 16);
        }
        typeof p != "number" && (p = y * 8);
        var A = p - this.n.bitLength();
        return A > 0 && (c = c.ushrn(A)), !l && c.cmp(this.n) >= 0 ? c.sub(this.n) : c;
    }, u.prototype.sign = function(c, l, p, y) {
        if (typeof p == "object" && (y = p, p = null), y || (y = {}), typeof c != "string" && typeof c != "number" && !e.isBN(c)) {
            o(typeof c == "object" && c && typeof c.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), o(c.length >>> 0 === c.length);
            for(var _ = 0; _ < c.length; _++)o((c[_] & 255) === c[_]);
        }
        l = this.keyFromPrivate(l, p), c = this._truncateToN(c, !1, y.msgBitLength), o(!c.isNeg(), "Can not sign a negative message");
        var A = this.n.byteLength(), O = l.getPrivate().toArray("be", A), N = c.toArray("be", A);
        o(new e(N).eq(c), "Can not sign message");
        for(var U = new t({
            hash: this.hash,
            entropy: O,
            nonce: N,
            pers: y.pers,
            persEnc: y.persEnc || "utf8"
        }), D = this.n.sub(new e(1)), H = 0;; H++){
            var K = y.k ? y.k(H) : new e(U.generate(this.n.byteLength()));
            if (K = this._truncateToN(K, !0), !(K.cmpn(1) <= 0 || K.cmp(D) >= 0)) {
                var re = this.g.mul(K);
                if (!re.isInfinity()) {
                    var Q = re.getX(), G = Q.umod(this.n);
                    if (G.cmpn(0) !== 0) {
                        var R = K.invm(this.n).mul(G.mul(l.getPrivate()).iadd(c));
                        if (R = R.umod(this.n), R.cmpn(0) !== 0) {
                            var X = (re.getY().isOdd() ? 1 : 0) | (Q.cmp(G) !== 0 ? 2 : 0);
                            return y.canonical && R.cmp(this.nh) > 0 && (R = this.n.sub(R), X ^= 1), new a({
                                r: G,
                                s: R,
                                recoveryParam: X
                            });
                        }
                    }
                }
            }
        }
    }, u.prototype.verify = function(c, l, p, y, _) {
        _ || (_ = {}), c = this._truncateToN(c, !1, _.msgBitLength), p = this.keyFromPublic(p, y), l = new a(l, "hex");
        var A = l.r, O = l.s;
        if (A.cmpn(1) < 0 || A.cmp(this.n) >= 0 || O.cmpn(1) < 0 || O.cmp(this.n) >= 0) return !1;
        var N = O.invm(this.n), U = N.mul(c).umod(this.n), D = N.mul(A).umod(this.n), H;
        return this.curve._maxwellTrick ? (H = this.g.jmulAdd(U, p.getPublic(), D), H.isInfinity() ? !1 : H.eqXToP(A)) : (H = this.g.mulAdd(U, p.getPublic(), D), H.isInfinity() ? !1 : H.getX().umod(this.n).cmp(A) === 0);
    }, u.prototype.recoverPubKey = function(f, c, l, p) {
        o((3 & l) === l, "The recovery param is more than two bits"), c = new a(c, p);
        var y = this.n, _ = new e(f), A = c.r, O = c.s, N = l & 1, U = l >> 1;
        if (A.cmp(this.curve.p.umod(this.curve.n)) >= 0 && U) throw new Error("Unable to find sencond key candinate");
        U ? A = this.curve.pointFromX(A.add(this.curve.n), N) : A = this.curve.pointFromX(A, N);
        var D = c.r.invm(y), H = y.sub(_).mul(D).umod(y), K = O.mul(D).umod(y);
        return this.g.mulAdd(H, A, K);
    }, u.prototype.getKeyRecoveryParam = function(f, c, l, p) {
        if (c = new a(c, p), c.recoveryParam !== null) return c.recoveryParam;
        for(var y = 0; y < 4; y++){
            var _;
            try {
                _ = this.recoverPubKey(f, c, y);
            } catch  {
                continue;
            }
            if (_.eq(l)) return y;
        }
        throw new Error("Unable to find valid recovery factor");
    }, N2;
}
var M2, yT;
function BX() {
    if (yT) return M2;
    yT = 1;
    var e = ms(), t = e.assert, r = e.parseBytes, n = e.cachedProperty;
    function i(o, s) {
        this.eddsa = o, this._secret = r(s.secret), o.isPoint(s.pub) ? this._pub = s.pub : this._pubBytes = r(s.pub);
    }
    return i.fromPublic = function(s, a) {
        return a instanceof i ? a : new i(s, {
            pub: a
        });
    }, i.fromSecret = function(s, a) {
        return a instanceof i ? a : new i(s, {
            secret: a
        });
    }, i.prototype.secret = function() {
        return this._secret;
    }, n(i, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
    }), n(i, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    }), n(i, "privBytes", function() {
        var s = this.eddsa, a = this.hash(), u = s.encodingLength - 1, f = a.slice(0, s.encodingLength);
        return f[0] &= 248, f[u] &= 127, f[u] |= 64, f;
    }), n(i, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
    }), n(i, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
    }), n(i, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
    }), i.prototype.sign = function(s) {
        return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(s, this);
    }, i.prototype.verify = function(s, a) {
        return this.eddsa.verify(s, a, this);
    }, i.prototype.getSecret = function(s) {
        return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), s);
    }, i.prototype.getPublic = function(s) {
        return e.encode(this.pubBytes(), s);
    }, M2 = i, M2;
}
var R2, mT;
function OX() {
    if (mT) return R2;
    mT = 1;
    var e = bi(), t = ms(), r = t.assert, n = t.cachedProperty, i = t.parseBytes;
    function o(s, a) {
        this.eddsa = s, typeof a != "object" && (a = i(a)), Array.isArray(a) && (r(a.length === s.encodingLength * 2, "Signature has invalid size"), a = {
            R: a.slice(0, s.encodingLength),
            S: a.slice(s.encodingLength)
        }), r(a.R && a.S, "Signature without R or S"), s.isPoint(a.R) && (this._R = a.R), a.S instanceof e && (this._S = a.S), this._Rencoded = Array.isArray(a.R) ? a.R : a.Rencoded, this._Sencoded = Array.isArray(a.S) ? a.S : a.Sencoded;
    }
    return n(o, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
    }), n(o, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
    }), n(o, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
    }), n(o, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
    }), o.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
    }, o.prototype.toHex = function() {
        return t.encode(this.toBytes(), "hex").toUpperCase();
    }, R2 = o, R2;
}
var C2, bT;
function PX() {
    if (bT) return C2;
    bT = 1;
    var e = z3(), t = j3(), r = ms(), n = r.assert, i = r.parseBytes, o = BX(), s = OX();
    function a(u) {
        if (n(u === "ed25519", "only tested with ed25519 so far"), !(this instanceof a)) return new a(u);
        u = t[u].curve, this.curve = u, this.g = u.g, this.g.precompute(u.n.bitLength() + 1), this.pointClass = u.point().constructor, this.encodingLength = Math.ceil(u.n.bitLength() / 8), this.hash = e.sha512;
    }
    return C2 = a, a.prototype.sign = function(f, c) {
        f = i(f);
        var l = this.keyFromSecret(c), p = this.hashInt(l.messagePrefix(), f), y = this.g.mul(p), _ = this.encodePoint(y), A = this.hashInt(_, l.pubBytes(), f).mul(l.priv()), O = p.add(A).umod(this.curve.n);
        return this.makeSignature({
            R: y,
            S: O,
            Rencoded: _
        });
    }, a.prototype.verify = function(f, c, l) {
        if (f = i(f), c = this.makeSignature(c), c.S().gte(c.eddsa.curve.n) || c.S().isNeg()) return !1;
        var p = this.keyFromPublic(l), y = this.hashInt(c.Rencoded(), p.pubBytes(), f), _ = this.g.mul(c.S()), A = c.R().add(p.pub().mul(y));
        return A.eq(_);
    }, a.prototype.hashInt = function() {
        for(var f = this.hash(), c = 0; c < arguments.length; c++)f.update(arguments[c]);
        return r.intFromLE(f.digest()).umod(this.curve.n);
    }, a.prototype.keyFromPublic = function(f) {
        return o.fromPublic(this, f);
    }, a.prototype.keyFromSecret = function(f) {
        return o.fromSecret(this, f);
    }, a.prototype.makeSignature = function(f) {
        return f instanceof s ? f : new s(this, f);
    }, a.prototype.encodePoint = function(f) {
        var c = f.getY().toArray("le", this.encodingLength);
        return c[this.encodingLength - 1] |= f.getX().isOdd() ? 128 : 0, c;
    }, a.prototype.decodePoint = function(f) {
        f = r.parseBytes(f);
        var c = f.length - 1, l = f.slice(0, c).concat(f[c] & -129), p = (f[c] & 128) !== 0, y = r.intFromLE(l);
        return this.curve.pointFromY(y, p);
    }, a.prototype.encodeInt = function(f) {
        return f.toArray("le", this.encodingLength);
    }, a.prototype.decodeInt = function(f) {
        return r.intFromLE(f);
    }, a.prototype.isPoint = function(f) {
        return f instanceof this.pointClass;
    }, C2;
}
var wT;
function H3() {
    return wT || (wT = 1, function(e) {
        var t = e;
        t.version = pX.version, t.utils = ms(), t.rand = L3(), t.curve = BO(), t.curves = j3(), t.ec = IX(), t.eddsa = PX();
    }(f2)), f2;
}
var Xo = {}, U2 = {}, $2 = {}, vT;
function NX() {
    return vT || (vT = 1, function(e) {
        var t = a0(), r = Or(), n = e;
        n.define = function(s, a) {
            return new i(s, a);
        };
        function i(o, s) {
            this.name = o, this.body = s, this.decoders = {}, this.encoders = {};
        }
        i.prototype._createNamed = function(s) {
            var a;
            try {
                a = Iu.runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
            } catch  {
                a = function(f) {
                    this._initNamed(f);
                };
            }
            return r(a, s), a.prototype._initNamed = function(f) {
                s.call(this, f);
            }, new a(this);
        }, i.prototype._getDecoder = function(s) {
            return s = s || "der", this.decoders.hasOwnProperty(s) || (this.decoders[s] = this._createNamed(t.decoders[s])), this.decoders[s];
        }, i.prototype.decode = function(s, a, u) {
            return this._getDecoder(a).decode(s, u);
        }, i.prototype._getEncoder = function(s) {
            return s = s || "der", this.encoders.hasOwnProperty(s) || (this.encoders[s] = this._createNamed(t.encoders[s])), this.encoders[s];
        }, i.prototype.encode = function(s, a, u) {
            return this._getEncoder(a).encode(s, u);
        };
    }($2)), $2;
}
var L2 = {}, D2 = {}, _T;
function MX() {
    if (_T) return D2;
    _T = 1;
    var e = Or();
    function t(n) {
        this._reporterState = {
            obj: null,
            path: [],
            options: n || {},
            errors: []
        };
    }
    D2.Reporter = t, t.prototype.isError = function(i) {
        return i instanceof r;
    }, t.prototype.save = function() {
        var i = this._reporterState;
        return {
            obj: i.obj,
            pathLen: i.path.length
        };
    }, t.prototype.restore = function(i) {
        var o = this._reporterState;
        o.obj = i.obj, o.path = o.path.slice(0, i.pathLen);
    }, t.prototype.enterKey = function(i) {
        return this._reporterState.path.push(i);
    }, t.prototype.exitKey = function(i) {
        var o = this._reporterState;
        o.path = o.path.slice(0, i - 1);
    }, t.prototype.leaveKey = function(i, o, s) {
        var a = this._reporterState;
        this.exitKey(i), a.obj !== null && (a.obj[o] = s);
    }, t.prototype.path = function() {
        return this._reporterState.path.join("/");
    }, t.prototype.enterObject = function() {
        var i = this._reporterState, o = i.obj;
        return i.obj = {}, o;
    }, t.prototype.leaveObject = function(i) {
        var o = this._reporterState, s = o.obj;
        return o.obj = i, s;
    }, t.prototype.error = function(i) {
        var o, s = this._reporterState, a = i instanceof r;
        if (a ? o = i : o = new r(s.path.map(function(u) {
            return "[" + JSON.stringify(u) + "]";
        }).join(""), i.message || i, i.stack), !s.options.partial) throw o;
        return a || s.errors.push(o), o;
    }, t.prototype.wrapResult = function(i) {
        var o = this._reporterState;
        return o.options.partial ? {
            result: this.isError(i) ? null : i,
            errors: o.errors
        } : i;
    };
    function r(n, i) {
        this.path = n, this.rethrow(i);
    }
    return e(r, Error), r.prototype.rethrow = function(i) {
        if (this.message = i + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, r), !this.stack) try {
            throw new Error(this.message);
        } catch (o) {
            this.stack = o.stack;
        }
        return this;
    }, D2;
}
var Wg = {}, ET;
function xT() {
    if (ET) return Wg;
    ET = 1;
    var e = Or(), t = Dh().Reporter, r = ku.Buffer;
    function n(o, s) {
        if (t.call(this, s), !r.isBuffer(o)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = o, this.offset = 0, this.length = o.length;
    }
    e(n, t), Wg.DecoderBuffer = n, n.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: t.prototype.save.call(this)
        };
    }, n.prototype.restore = function(s) {
        var a = new n(this.base);
        return a.offset = s.offset, a.length = this.offset, this.offset = s.offset, t.prototype.restore.call(this, s.reporter), a;
    }, n.prototype.isEmpty = function() {
        return this.offset === this.length;
    }, n.prototype.readUInt8 = function(s) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(s || "DecoderBuffer overrun");
    }, n.prototype.skip = function(s, a) {
        if (!(this.offset + s <= this.length)) return this.error(a || "DecoderBuffer overrun");
        var u = new n(this.base);
        return u._reporterState = this._reporterState, u.offset = this.offset, u.length = this.offset + s, this.offset += s, u;
    }, n.prototype.raw = function(s) {
        return this.base.slice(s ? s.offset : this.offset, this.length);
    };
    function i(o, s) {
        if (Array.isArray(o)) this.length = 0, this.value = o.map(function(a) {
            return a instanceof i || (a = new i(a, s)), this.length += a.length, a;
        }, this);
        else if (typeof o == "number") {
            if (!(0 <= o && o <= 255)) return s.error("non-byte EncoderBuffer value");
            this.value = o, this.length = 1;
        } else if (typeof o == "string") this.value = o, this.length = r.byteLength(o);
        else if (r.isBuffer(o)) this.value = o, this.length = o.length;
        else return s.error("Unsupported type: " + typeof o);
    }
    return Wg.EncoderBuffer = i, i.prototype.join = function(s, a) {
        return s || (s = new r(this.length)), a || (a = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(u) {
            u.join(s, a), a += u.length;
        }) : (typeof this.value == "number" ? s[a] = this.value : typeof this.value == "string" ? s.write(this.value, a) : r.isBuffer(this.value) && this.value.copy(s, a), a += this.length)), s;
    }, Wg;
}
var F2, ST;
function RX() {
    if (ST) return F2;
    ST = 1;
    var e = Dh().Reporter, t = Dh().EncoderBuffer, r = Dh().DecoderBuffer, n = ys(), i = [
        "seq",
        "seqof",
        "set",
        "setof",
        "objid",
        "bool",
        "gentime",
        "utctime",
        "null_",
        "enum",
        "int",
        "objDesc",
        "bitstr",
        "bmpstr",
        "charstr",
        "genstr",
        "graphstr",
        "ia5str",
        "iso646str",
        "numstr",
        "octstr",
        "printstr",
        "t61str",
        "unistr",
        "utf8str",
        "videostr"
    ], o = [
        "key",
        "obj",
        "use",
        "optional",
        "explicit",
        "implicit",
        "def",
        "choice",
        "any",
        "contains"
    ].concat(i), s = [
        "_peekTag",
        "_decodeTag",
        "_use",
        "_decodeStr",
        "_decodeObjid",
        "_decodeTime",
        "_decodeNull",
        "_decodeInt",
        "_decodeBool",
        "_decodeList",
        "_encodeComposite",
        "_encodeStr",
        "_encodeObjid",
        "_encodeTime",
        "_encodeNull",
        "_encodeInt",
        "_encodeBool"
    ];
    function a(f, c) {
        var l = {};
        this._baseState = l, l.enc = f, l.parent = c || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
    }
    F2 = a;
    var u = [
        "enc",
        "parent",
        "children",
        "tag",
        "args",
        "reverseArgs",
        "choice",
        "optional",
        "any",
        "obj",
        "use",
        "alteredUse",
        "key",
        "default",
        "explicit",
        "implicit",
        "contains"
    ];
    return a.prototype.clone = function() {
        var c = this._baseState, l = {};
        u.forEach(function(y) {
            l[y] = c[y];
        });
        var p = new this.constructor(l.parent);
        return p._baseState = l, p;
    }, a.prototype._wrap = function() {
        var c = this._baseState;
        o.forEach(function(l) {
            this[l] = function() {
                var y = new this.constructor(this);
                return c.children.push(y), y[l].apply(y, arguments);
            };
        }, this);
    }, a.prototype._init = function(c) {
        var l = this._baseState;
        n(l.parent === null), c.call(this), l.children = l.children.filter(function(p) {
            return p._baseState.parent === this;
        }, this), n.equal(l.children.length, 1, "Root node can have only one child");
    }, a.prototype._useArgs = function(c) {
        var l = this._baseState, p = c.filter(function(y) {
            return y instanceof this.constructor;
        }, this);
        c = c.filter(function(y) {
            return !(y instanceof this.constructor);
        }, this), p.length !== 0 && (n(l.children === null), l.children = p, p.forEach(function(y) {
            y._baseState.parent = this;
        }, this)), c.length !== 0 && (n(l.args === null), l.args = c, l.reverseArgs = c.map(function(y) {
            if (typeof y != "object" || y.constructor !== Object) return y;
            var _ = {};
            return Object.keys(y).forEach(function(A) {
                A == (A | 0) && (A |= 0);
                var O = y[A];
                _[O] = A;
            }), _;
        }));
    }, s.forEach(function(f) {
        a.prototype[f] = function() {
            var l = this._baseState;
            throw new Error(f + " not implemented for encoding: " + l.enc);
        };
    }), i.forEach(function(f) {
        a.prototype[f] = function() {
            var l = this._baseState, p = Array.prototype.slice.call(arguments);
            return n(l.tag === null), l.tag = f, this._useArgs(p), this;
        };
    }), a.prototype.use = function(c) {
        n(c);
        var l = this._baseState;
        return n(l.use === null), l.use = c, this;
    }, a.prototype.optional = function() {
        var c = this._baseState;
        return c.optional = !0, this;
    }, a.prototype.def = function(c) {
        var l = this._baseState;
        return n(l.default === null), l.default = c, l.optional = !0, this;
    }, a.prototype.explicit = function(c) {
        var l = this._baseState;
        return n(l.explicit === null && l.implicit === null), l.explicit = c, this;
    }, a.prototype.implicit = function(c) {
        var l = this._baseState;
        return n(l.explicit === null && l.implicit === null), l.implicit = c, this;
    }, a.prototype.obj = function() {
        var c = this._baseState, l = Array.prototype.slice.call(arguments);
        return c.obj = !0, l.length !== 0 && this._useArgs(l), this;
    }, a.prototype.key = function(c) {
        var l = this._baseState;
        return n(l.key === null), l.key = c, this;
    }, a.prototype.any = function() {
        var c = this._baseState;
        return c.any = !0, this;
    }, a.prototype.choice = function(c) {
        var l = this._baseState;
        return n(l.choice === null), l.choice = c, this._useArgs(Object.keys(c).map(function(p) {
            return c[p];
        })), this;
    }, a.prototype.contains = function(c) {
        var l = this._baseState;
        return n(l.use === null), l.contains = c, this;
    }, a.prototype._decode = function(c, l) {
        var p = this._baseState;
        if (p.parent === null) return c.wrapResult(p.children[0]._decode(c, l));
        var y = p.default, _ = !0, A = null;
        if (p.key !== null && (A = c.enterKey(p.key)), p.optional) {
            var O = null;
            if (p.explicit !== null ? O = p.explicit : p.implicit !== null ? O = p.implicit : p.tag !== null && (O = p.tag), O === null && !p.any) {
                var N = c.save();
                try {
                    p.choice === null ? this._decodeGeneric(p.tag, c, l) : this._decodeChoice(c, l), _ = !0;
                } catch  {
                    _ = !1;
                }
                c.restore(N);
            } else if (_ = this._peekTag(c, O, p.any), c.isError(_)) return _;
        }
        var U;
        if (p.obj && _ && (U = c.enterObject()), _) {
            if (p.explicit !== null) {
                var D = this._decodeTag(c, p.explicit);
                if (c.isError(D)) return D;
                c = D;
            }
            var H = c.offset;
            if (p.use === null && p.choice === null) {
                if (p.any) var N = c.save();
                var K = this._decodeTag(c, p.implicit !== null ? p.implicit : p.tag, p.any);
                if (c.isError(K)) return K;
                p.any ? y = c.raw(N) : c = K;
            }
            if (l && l.track && p.tag !== null && l.track(c.path(), H, c.length, "tagged"), l && l.track && p.tag !== null && l.track(c.path(), c.offset, c.length, "content"), p.any ? y = y : p.choice === null ? y = this._decodeGeneric(p.tag, c, l) : y = this._decodeChoice(c, l), c.isError(y)) return y;
            if (!p.any && p.choice === null && p.children !== null && p.children.forEach(function(G) {
                G._decode(c, l);
            }), p.contains && (p.tag === "octstr" || p.tag === "bitstr")) {
                var re = new r(y);
                y = this._getUse(p.contains, c._reporterState.obj)._decode(re, l);
            }
        }
        return p.obj && _ && (y = c.leaveObject(U)), p.key !== null && (y !== null || _ === !0) ? c.leaveKey(A, p.key, y) : A !== null && c.exitKey(A), y;
    }, a.prototype._decodeGeneric = function(c, l, p) {
        var y = this._baseState;
        return c === "seq" || c === "set" ? null : c === "seqof" || c === "setof" ? this._decodeList(l, c, y.args[0], p) : /str$/.test(c) ? this._decodeStr(l, c, p) : c === "objid" && y.args ? this._decodeObjid(l, y.args[0], y.args[1], p) : c === "objid" ? this._decodeObjid(l, null, null, p) : c === "gentime" || c === "utctime" ? this._decodeTime(l, c, p) : c === "null_" ? this._decodeNull(l, p) : c === "bool" ? this._decodeBool(l, p) : c === "objDesc" ? this._decodeStr(l, c, p) : c === "int" || c === "enum" ? this._decodeInt(l, y.args && y.args[0], p) : y.use !== null ? this._getUse(y.use, l._reporterState.obj)._decode(l, p) : l.error("unknown tag: " + c);
    }, a.prototype._getUse = function(c, l) {
        var p = this._baseState;
        return p.useDecoder = this._use(c, l), n(p.useDecoder._baseState.parent === null), p.useDecoder = p.useDecoder._baseState.children[0], p.implicit !== p.useDecoder._baseState.implicit && (p.useDecoder = p.useDecoder.clone(), p.useDecoder._baseState.implicit = p.implicit), p.useDecoder;
    }, a.prototype._decodeChoice = function(c, l) {
        var p = this._baseState, y = null, _ = !1;
        return Object.keys(p.choice).some(function(A) {
            var O = c.save(), N = p.choice[A];
            try {
                var U = N._decode(c, l);
                if (c.isError(U)) return !1;
                y = {
                    type: A,
                    value: U
                }, _ = !0;
            } catch  {
                return c.restore(O), !1;
            }
            return !0;
        }, this), _ ? y : c.error("Choice not matched");
    }, a.prototype._createEncoderBuffer = function(c) {
        return new t(c, this.reporter);
    }, a.prototype._encode = function(c, l, p) {
        var y = this._baseState;
        if (!(y.default !== null && y.default === c)) {
            var _ = this._encodeValue(c, l, p);
            if (_ !== void 0 && !this._skipDefault(_, l, p)) return _;
        }
    }, a.prototype._encodeValue = function(c, l, p) {
        var y = this._baseState;
        if (y.parent === null) return y.children[0]._encode(c, l || new e());
        var N = null;
        if (this.reporter = l, y.optional && c === void 0) if (y.default !== null) c = y.default;
        else return;
        var _ = null, A = !1;
        if (y.any) N = this._createEncoderBuffer(c);
        else if (y.choice) N = this._encodeChoice(c, l);
        else if (y.contains) _ = this._getUse(y.contains, p)._encode(c, l), A = !0;
        else if (y.children) _ = y.children.map(function(H) {
            if (H._baseState.tag === "null_") return H._encode(null, l, c);
            if (H._baseState.key === null) return l.error("Child should have a key");
            var K = l.enterKey(H._baseState.key);
            if (typeof c != "object") return l.error("Child expected, but input is not object");
            var re = H._encode(c[H._baseState.key], l, c);
            return l.leaveKey(K), re;
        }, this).filter(function(H) {
            return H;
        }), _ = this._createEncoderBuffer(_);
        else if (y.tag === "seqof" || y.tag === "setof") {
            if (!(y.args && y.args.length === 1)) return l.error("Too many args for : " + y.tag);
            if (!Array.isArray(c)) return l.error("seqof/setof, but data is not Array");
            var O = this.clone();
            O._baseState.implicit = null, _ = this._createEncoderBuffer(c.map(function(H) {
                var K = this._baseState;
                return this._getUse(K.args[0], c)._encode(H, l);
            }, O));
        } else y.use !== null ? N = this._getUse(y.use, p)._encode(c, l) : (_ = this._encodePrimitive(y.tag, c), A = !0);
        var N;
        if (!y.any && y.choice === null) {
            var U = y.implicit !== null ? y.implicit : y.tag, D = y.implicit === null ? "universal" : "context";
            U === null ? y.use === null && l.error("Tag could be omitted only for .use()") : y.use === null && (N = this._encodeComposite(U, A, D, _));
        }
        return y.explicit !== null && (N = this._encodeComposite(y.explicit, !1, "context", N)), N;
    }, a.prototype._encodeChoice = function(c, l) {
        var p = this._baseState, y = p.choice[c.type];
        return y || n(!1, c.type + " not found in " + JSON.stringify(Object.keys(p.choice))), y._encode(c.value, l);
    }, a.prototype._encodePrimitive = function(c, l) {
        var p = this._baseState;
        if (/str$/.test(c)) return this._encodeStr(l, c);
        if (c === "objid" && p.args) return this._encodeObjid(l, p.reverseArgs[0], p.args[1]);
        if (c === "objid") return this._encodeObjid(l, null, null);
        if (c === "gentime" || c === "utctime") return this._encodeTime(l, c);
        if (c === "null_") return this._encodeNull();
        if (c === "int" || c === "enum") return this._encodeInt(l, p.args && p.reverseArgs[0]);
        if (c === "bool") return this._encodeBool(l);
        if (c === "objDesc") return this._encodeStr(l, c);
        throw new Error("Unsupported tag: " + c);
    }, a.prototype._isNumstr = function(c) {
        return /^[0-9 ]*$/.test(c);
    }, a.prototype._isPrintstr = function(c) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(c);
    }, F2;
}
var AT;
function Dh() {
    return AT || (AT = 1, function(e) {
        var t = e;
        t.Reporter = MX().Reporter, t.DecoderBuffer = xT().DecoderBuffer, t.EncoderBuffer = xT().EncoderBuffer, t.Node = RX();
    }(L2)), L2;
}
var z2 = {}, j2 = {}, TT;
function CX() {
    return TT || (TT = 1, function(e) {
        var t = MO();
        e.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        }, e.tagByName = t._reverse(e.tag);
    }(j2)), j2;
}
var kT;
function MO() {
    return kT || (kT = 1, function(e) {
        var t = e;
        t._reverse = function(n) {
            var i = {};
            return Object.keys(n).forEach(function(o) {
                (o | 0) == o && (o = o | 0);
                var s = n[o];
                i[s] = o;
            }), i;
        }, t.der = CX();
    }(z2)), z2;
}
var H2 = {}, q2, IT;
function RO() {
    if (IT) return q2;
    IT = 1;
    var e = Or(), t = a0(), r = t.base, n = t.bignum, i = t.constants.der;
    function o(f) {
        this.enc = "der", this.name = f.name, this.entity = f, this.tree = new s(), this.tree._init(f.body);
    }
    q2 = o, o.prototype.decode = function(c, l) {
        return c instanceof r.DecoderBuffer || (c = new r.DecoderBuffer(c, l)), this.tree._decode(c, l);
    };
    function s(f) {
        r.Node.call(this, "der", f);
    }
    e(s, r.Node), s.prototype._peekTag = function(c, l, p) {
        if (c.isEmpty()) return !1;
        var y = c.save(), _ = a(c, 'Failed to peek tag: "' + l + '"');
        return c.isError(_) ? _ : (c.restore(y), _.tag === l || _.tagStr === l || _.tagStr + "of" === l || p);
    }, s.prototype._decodeTag = function(c, l, p) {
        var y = a(c, 'Failed to decode tag of "' + l + '"');
        if (c.isError(y)) return y;
        var _ = u(c, y.primitive, 'Failed to get length of "' + l + '"');
        if (c.isError(_)) return _;
        if (!p && y.tag !== l && y.tagStr !== l && y.tagStr + "of" !== l) return c.error('Failed to match tag: "' + l + '"');
        if (y.primitive || _ !== null) return c.skip(_, 'Failed to match body of: "' + l + '"');
        var A = c.save(), O = this._skipUntilEnd(c, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return c.isError(O) ? O : (_ = c.offset - A.offset, c.restore(A), c.skip(_, 'Failed to match body of: "' + l + '"'));
    }, s.prototype._skipUntilEnd = function(c, l) {
        for(;;){
            var p = a(c, l);
            if (c.isError(p)) return p;
            var y = u(c, p.primitive, l);
            if (c.isError(y)) return y;
            var _;
            if (p.primitive || y !== null ? _ = c.skip(y) : _ = this._skipUntilEnd(c, l), c.isError(_)) return _;
            if (p.tagStr === "end") break;
        }
    }, s.prototype._decodeList = function(c, l, p, y) {
        for(var _ = []; !c.isEmpty();){
            var A = this._peekTag(c, "end");
            if (c.isError(A)) return A;
            var O = p.decode(c, "der", y);
            if (c.isError(O) && A) break;
            _.push(O);
        }
        return _;
    }, s.prototype._decodeStr = function(c, l) {
        if (l === "bitstr") {
            var p = c.readUInt8();
            return c.isError(p) ? p : {
                unused: p,
                data: c.raw()
            };
        } else if (l === "bmpstr") {
            var y = c.raw();
            if (y.length % 2 === 1) return c.error("Decoding of string type: bmpstr length mismatch");
            for(var _ = "", A = 0; A < y.length / 2; A++)_ += String.fromCharCode(y.readUInt16BE(A * 2));
            return _;
        } else if (l === "numstr") {
            var O = c.raw().toString("ascii");
            return this._isNumstr(O) ? O : c.error("Decoding of string type: numstr unsupported characters");
        } else {
            if (l === "octstr") return c.raw();
            if (l === "objDesc") return c.raw();
            if (l === "printstr") {
                var N = c.raw().toString("ascii");
                return this._isPrintstr(N) ? N : c.error("Decoding of string type: printstr unsupported characters");
            } else return /str$/.test(l) ? c.raw().toString() : c.error("Decoding of string type: " + l + " unsupported");
        }
    }, s.prototype._decodeObjid = function(c, l, p) {
        for(var y, _ = [], A = 0; !c.isEmpty();){
            var O = c.readUInt8();
            A <<= 7, A |= O & 127, O & 128 || (_.push(A), A = 0);
        }
        O & 128 && _.push(A);
        var N = _[0] / 40 | 0, U = _[0] % 40;
        if (p ? y = _ : y = [
            N,
            U
        ].concat(_.slice(1)), l) {
            var D = l[y.join(" ")];
            D === void 0 && (D = l[y.join(".")]), D !== void 0 && (y = D);
        }
        return y;
    }, s.prototype._decodeTime = function(c, l) {
        var p = c.raw().toString();
        if (l === "gentime") var y = p.slice(0, 4) | 0, _ = p.slice(4, 6) | 0, A = p.slice(6, 8) | 0, O = p.slice(8, 10) | 0, N = p.slice(10, 12) | 0, U = p.slice(12, 14) | 0;
        else if (l === "utctime") {
            var y = p.slice(0, 2) | 0, _ = p.slice(2, 4) | 0, A = p.slice(4, 6) | 0, O = p.slice(6, 8) | 0, N = p.slice(8, 10) | 0, U = p.slice(10, 12) | 0;
            y < 70 ? y = 2e3 + y : y = 1900 + y;
        } else return c.error("Decoding " + l + " time is not supported yet");
        return Date.UTC(y, _ - 1, A, O, N, U, 0);
    }, s.prototype._decodeNull = function(c) {
        return null;
    }, s.prototype._decodeBool = function(c) {
        var l = c.readUInt8();
        return c.isError(l) ? l : l !== 0;
    }, s.prototype._decodeInt = function(c, l) {
        var p = c.raw(), y = new n(p);
        return l && (y = l[y.toString(10)] || y), y;
    }, s.prototype._use = function(c, l) {
        return typeof c == "function" && (c = c(l)), c._getDecoder("der").tree;
    };
    function a(f, c) {
        var l = f.readUInt8(c);
        if (f.isError(l)) return l;
        var p = i.tagClass[l >> 6], y = (l & 32) === 0;
        if ((l & 31) === 31) {
            var _ = l;
            for(l = 0; (_ & 128) === 128;){
                if (_ = f.readUInt8(c), f.isError(_)) return _;
                l <<= 7, l |= _ & 127;
            }
        } else l &= 31;
        var A = i.tag[l];
        return {
            cls: p,
            primitive: y,
            tag: l,
            tagStr: A
        };
    }
    function u(f, c, l) {
        var p = f.readUInt8(l);
        if (f.isError(p)) return p;
        if (!c && p === 128) return null;
        if (!(p & 128)) return p;
        var y = p & 127;
        if (y > 4) return f.error("length octect is too long");
        p = 0;
        for(var _ = 0; _ < y; _++){
            p <<= 8;
            var A = f.readUInt8(l);
            if (f.isError(A)) return A;
            p |= A;
        }
        return p;
    }
    return q2;
}
var K2, BT;
function UX() {
    if (BT) return K2;
    BT = 1;
    var e = Or(), t = ku.Buffer, r = RO();
    function n(i) {
        r.call(this, i), this.enc = "pem";
    }
    return e(n, r), K2 = n, n.prototype.decode = function(o, s) {
        for(var a = o.toString().split(/[\r\n]+/g), u = s.label.toUpperCase(), f = /^-----(BEGIN|END) ([^-]+)-----$/, c = -1, l = -1, p = 0; p < a.length; p++){
            var y = a[p].match(f);
            if (y !== null && y[2] === u) if (c === -1) {
                if (y[1] !== "BEGIN") break;
                c = p;
            } else {
                if (y[1] !== "END") break;
                l = p;
                break;
            }
        }
        if (c === -1 || l === -1) throw new Error("PEM section not found for: " + u);
        var _ = a.slice(c + 1, l).join("");
        _.replace(/[^a-z0-9\+\/=]+/gi, "");
        var A = new t(_, "base64");
        return r.prototype.decode.call(this, A, s);
    }, K2;
}
var OT;
function $X() {
    return OT || (OT = 1, function(e) {
        var t = e;
        t.der = RO(), t.pem = UX();
    }(H2)), H2;
}
var W2 = {}, V2, PT;
function CO() {
    if (PT) return V2;
    PT = 1;
    var e = Or(), t = ku.Buffer, r = a0(), n = r.base, i = r.constants.der;
    function o(f) {
        this.enc = "der", this.name = f.name, this.entity = f, this.tree = new s(), this.tree._init(f.body);
    }
    V2 = o, o.prototype.encode = function(c, l) {
        return this.tree._encode(c, l).join();
    };
    function s(f) {
        n.Node.call(this, "der", f);
    }
    e(s, n.Node), s.prototype._encodeComposite = function(c, l, p, y) {
        var _ = u(c, l, p, this.reporter);
        if (y.length < 128) {
            var N = new t(2);
            return N[0] = _, N[1] = y.length, this._createEncoderBuffer([
                N,
                y
            ]);
        }
        for(var A = 1, O = y.length; O >= 256; O >>= 8)A++;
        var N = new t(2 + A);
        N[0] = _, N[1] = 128 | A;
        for(var O = 1 + A, U = y.length; U > 0; O--, U >>= 8)N[O] = U & 255;
        return this._createEncoderBuffer([
            N,
            y
        ]);
    }, s.prototype._encodeStr = function(c, l) {
        if (l === "bitstr") return this._createEncoderBuffer([
            c.unused | 0,
            c.data
        ]);
        if (l === "bmpstr") {
            for(var p = new t(c.length * 2), y = 0; y < c.length; y++)p.writeUInt16BE(c.charCodeAt(y), y * 2);
            return this._createEncoderBuffer(p);
        } else return l === "numstr" ? this._isNumstr(c) ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : l === "printstr" ? this._isPrintstr(c) ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(l) ? this._createEncoderBuffer(c) : l === "objDesc" ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: " + l + " unsupported");
    }, s.prototype._encodeObjid = function(c, l, p) {
        if (typeof c == "string") {
            if (!l) return this.reporter.error("string objid given, but no values map found");
            if (!l.hasOwnProperty(c)) return this.reporter.error("objid not found in values map");
            c = l[c].split(/[\s\.]+/g);
            for(var y = 0; y < c.length; y++)c[y] |= 0;
        } else if (Array.isArray(c)) {
            c = c.slice();
            for(var y = 0; y < c.length; y++)c[y] |= 0;
        }
        if (!Array.isArray(c)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(c));
        if (!p) {
            if (c[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            c.splice(0, 2, c[0] * 40 + c[1]);
        }
        for(var _ = 0, y = 0; y < c.length; y++){
            var A = c[y];
            for(_++; A >= 128; A >>= 7)_++;
        }
        for(var O = new t(_), N = O.length - 1, y = c.length - 1; y >= 0; y--){
            var A = c[y];
            for(O[N--] = A & 127; (A >>= 7) > 0;)O[N--] = 128 | A & 127;
        }
        return this._createEncoderBuffer(O);
    };
    function a(f) {
        return f < 10 ? "0" + f : f;
    }
    s.prototype._encodeTime = function(c, l) {
        var p, y = new Date(c);
        return l === "gentime" ? p = [
            a(y.getFullYear()),
            a(y.getUTCMonth() + 1),
            a(y.getUTCDate()),
            a(y.getUTCHours()),
            a(y.getUTCMinutes()),
            a(y.getUTCSeconds()),
            "Z"
        ].join("") : l === "utctime" ? p = [
            a(y.getFullYear() % 100),
            a(y.getUTCMonth() + 1),
            a(y.getUTCDate()),
            a(y.getUTCHours()),
            a(y.getUTCMinutes()),
            a(y.getUTCSeconds()),
            "Z"
        ].join("") : this.reporter.error("Encoding " + l + " time is not supported yet"), this._encodeStr(p, "octstr");
    }, s.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
    }, s.prototype._encodeInt = function(c, l) {
        if (typeof c == "string") {
            if (!l) return this.reporter.error("String int or enum given, but no values map");
            if (!l.hasOwnProperty(c)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(c));
            c = l[c];
        }
        if (typeof c != "number" && !t.isBuffer(c)) {
            var p = c.toArray();
            !c.sign && p[0] & 128 && p.unshift(0), c = new t(p);
        }
        if (t.isBuffer(c)) {
            var y = c.length;
            c.length === 0 && y++;
            var A = new t(y);
            return c.copy(A), c.length === 0 && (A[0] = 0), this._createEncoderBuffer(A);
        }
        if (c < 128) return this._createEncoderBuffer(c);
        if (c < 256) return this._createEncoderBuffer([
            0,
            c
        ]);
        for(var y = 1, _ = c; _ >= 256; _ >>= 8)y++;
        for(var A = new Array(y), _ = A.length - 1; _ >= 0; _--)A[_] = c & 255, c >>= 8;
        return A[0] & 128 && A.unshift(0), this._createEncoderBuffer(new t(A));
    }, s.prototype._encodeBool = function(c) {
        return this._createEncoderBuffer(c ? 255 : 0);
    }, s.prototype._use = function(c, l) {
        return typeof c == "function" && (c = c(l)), c._getEncoder("der").tree;
    }, s.prototype._skipDefault = function(c, l, p) {
        var y = this._baseState, _;
        if (y.default === null) return !1;
        var A = c.join();
        if (y.defaultBuffer === void 0 && (y.defaultBuffer = this._encodeValue(y.default, l, p).join()), A.length !== y.defaultBuffer.length) return !1;
        for(_ = 0; _ < A.length; _++)if (A[_] !== y.defaultBuffer[_]) return !1;
        return !0;
    };
    function u(f, c, l, p) {
        var y;
        if (f === "seqof" ? f = "seq" : f === "setof" && (f = "set"), i.tagByName.hasOwnProperty(f)) y = i.tagByName[f];
        else if (typeof f == "number" && (f | 0) === f) y = f;
        else return p.error("Unknown tag: " + f);
        return y >= 31 ? p.error("Multi-octet tag encoding unsupported") : (c || (y |= 32), y |= i.tagClassByName[l || "universal"] << 6, y);
    }
    return V2;
}
var G2, NT;
function LX() {
    if (NT) return G2;
    NT = 1;
    var e = Or(), t = CO();
    function r(n) {
        t.call(this, n), this.enc = "pem";
    }
    return e(r, t), G2 = r, r.prototype.encode = function(i, o) {
        for(var s = t.prototype.encode.call(this, i), a = s.toString("base64"), u = [
            "-----BEGIN " + o.label + "-----"
        ], f = 0; f < a.length; f += 64)u.push(a.slice(f, f + 64));
        return u.push("-----END " + o.label + "-----"), u.join(`
`);
    }, G2;
}
var MT;
function DX() {
    return MT || (MT = 1, function(e) {
        var t = e;
        t.der = CO(), t.pem = LX();
    }(W2)), W2;
}
var RT;
function a0() {
    return RT || (RT = 1, function(e) {
        var t = e;
        t.bignum = bi(), t.define = NX().define, t.base = Dh(), t.constants = MO(), t.decoders = $X(), t.encoders = DX();
    }(U2)), U2;
}
var Z2, CT;
function FX() {
    if (CT) return Z2;
    CT = 1;
    var e = a0(), t = e.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        });
    }), r = e.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), i = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr());
    }), o = e.define("RelativeDistinguishedName", function() {
        this.setof(r);
    }), s = e.define("RDNSequence", function() {
        this.seqof(o);
    }), a = e.define("Name", function() {
        this.choice({
            rdnSequence: this.use(s)
        });
    }), u = e.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(t), this.key("notAfter").use(t));
    }), f = e.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
    }), c = e.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(n), this.key("issuer").use(a), this.key("validity").use(u), this.key("subject").use(a), this.key("subjectPublicKeyInfo").use(i), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(f).optional());
    }), l = e.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(c), this.key("signatureAlgorithm").use(n), this.key("signatureValue").bitstr());
    });
    return Z2 = l, Z2;
}
var UT;
function zX() {
    if (UT) return Xo;
    UT = 1;
    var e = a0();
    Xo.certificate = FX();
    var t = e.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Xo.RSAPrivateKey = t;
    var r = e.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Xo.RSAPublicKey = r;
    var n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), i = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr());
    });
    Xo.PublicKey = i;
    var o = e.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(n), this.key("subjectPrivateKey").octstr());
    });
    Xo.PrivateKey = o;
    var s = e.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Xo.EncryptedPrivateKey = s;
    var a = e.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Xo.DSAPrivateKey = a, Xo.DSAparam = e.define("DSAparam", function() {
        this.int();
    });
    var u = e.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        });
    }), f = e.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(u), this.key("publicKey").optional().explicit(1).bitstr());
    });
    return Xo.ECPrivateKey = f, Xo.signature = e.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
    }), Xo;
}
const jX = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var Y2, $T;
function HX() {
    if ($T) return Y2;
    $T = 1;
    var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, n = xb(), i = $3(), o = Ar().Buffer;
    return Y2 = function(s, a) {
        var u = s.toString(), f = u.match(e), c;
        if (f) {
            var p = "aes" + f[1], y = o.from(f[2], "hex"), _ = o.from(f[3].replace(/[\r\n]/g, ""), "base64"), A = n(a, y.slice(0, 8), parseInt(f[1], 10)).key, O = [], N = i.createDecipheriv(p, A, y);
            O.push(N.update(_)), O.push(N.final()), c = o.concat(O);
        } else {
            var l = u.match(r);
            c = o.from(l[2].replace(/[\r\n]/g, ""), "base64");
        }
        var U = u.match(t)[1];
        return {
            tag: U,
            data: c
        };
    }, Y2;
}
var X2, LT;
function kb() {
    if (LT) return X2;
    LT = 1;
    var e = zX(), t = jX, r = HX(), n = $3(), i = hO(), o = Ar().Buffer;
    function s(u, f) {
        var c = u.algorithm.decrypt.kde.kdeparams.salt, l = parseInt(u.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), p = t[u.algorithm.decrypt.cipher.algo.join(".")], y = u.algorithm.decrypt.cipher.iv, _ = u.subjectPrivateKey, A = parseInt(p.split("-")[1], 10) / 8, O = i.pbkdf2Sync(f, c, l, A, "sha1"), N = n.createDecipheriv(p, O, y), U = [];
        return U.push(N.update(_)), U.push(N.final()), o.concat(U);
    }
    function a(u) {
        var f;
        typeof u == "object" && !o.isBuffer(u) && (f = u.passphrase, u = u.key), typeof u == "string" && (u = o.from(u));
        var c = r(u, f), l = c.tag, p = c.data, y, _;
        switch(l){
            case "CERTIFICATE":
                _ = e.certificate.decode(p, "der").tbsCertificate.subjectPublicKeyInfo;
            case "PUBLIC KEY":
                switch(_ || (_ = e.PublicKey.decode(p, "der")), y = _.algorithm.algorithm.join("."), y){
                    case "1.2.840.113549.1.1.1":
                        return e.RSAPublicKey.decode(_.subjectPublicKey.data, "der");
                    case "1.2.840.10045.2.1":
                        return _.subjectPrivateKey = _.subjectPublicKey, {
                            type: "ec",
                            data: _
                        };
                    case "1.2.840.10040.4.1":
                        return _.algorithm.params.pub_key = e.DSAparam.decode(_.subjectPublicKey.data, "der"), {
                            type: "dsa",
                            data: _.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + y);
                }
            case "ENCRYPTED PRIVATE KEY":
                p = e.EncryptedPrivateKey.decode(p, "der"), p = s(p, f);
            case "PRIVATE KEY":
                switch(_ = e.PrivateKey.decode(p, "der"), y = _.algorithm.algorithm.join("."), y){
                    case "1.2.840.113549.1.1.1":
                        return e.RSAPrivateKey.decode(_.subjectPrivateKey, "der");
                    case "1.2.840.10045.2.1":
                        return {
                            curve: _.algorithm.curve,
                            privateKey: e.ECPrivateKey.decode(_.subjectPrivateKey, "der").privateKey
                        };
                    case "1.2.840.10040.4.1":
                        return _.algorithm.params.priv_key = e.DSAparam.decode(_.subjectPrivateKey, "der"), {
                            type: "dsa",
                            params: _.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + y);
                }
            case "RSA PUBLIC KEY":
                return e.RSAPublicKey.decode(p, "der");
            case "RSA PRIVATE KEY":
                return e.RSAPrivateKey.decode(p, "der");
            case "DSA PRIVATE KEY":
                return {
                    type: "dsa",
                    params: e.DSAPrivateKey.decode(p, "der")
                };
            case "EC PRIVATE KEY":
                return p = e.ECPrivateKey.decode(p, "der"), {
                    curve: p.parameters.value,
                    privateKey: p.privateKey
                };
            default:
                throw new Error("unknown key type " + l);
        }
    }
    return a.signature = e.signature, X2 = a, X2;
}
const UO = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var DT;
function qX() {
    if (DT) return dh.exports;
    DT = 1;
    var e = Ar().Buffer, t = aO(), r = F3(), n = H3().ec, i = D3(), o = kb(), s = UO, a = 1;
    function u(N, U, D, H, K) {
        var re = o(U);
        if (re.curve) {
            if (H !== "ecdsa" && H !== "ecdsa/rsa") throw new Error("wrong private key type");
            return f(N, re);
        } else if (re.type === "dsa") {
            if (H !== "dsa") throw new Error("wrong private key type");
            return c(N, re, D);
        }
        if (H !== "rsa" && H !== "ecdsa/rsa") throw new Error("wrong private key type");
        if (U.padding !== void 0 && U.padding !== a) throw new Error("illegal or unsupported padding mode");
        N = e.concat([
            K,
            N
        ]);
        for(var Q = re.modulus.byteLength(), G = [
            0,
            1
        ]; N.length + G.length + 1 < Q;)G.push(255);
        G.push(0);
        for(var R = -1; ++R < N.length;)G.push(N[R]);
        var X = r(G, re);
        return X;
    }
    function f(N, U) {
        var D = s[U.curve.join(".")];
        if (!D) throw new Error("unknown curve " + U.curve.join("."));
        var H = new n(D), K = H.keyFromPrivate(U.privateKey), re = K.sign(N);
        return e.from(re.toDER());
    }
    function c(N, U, D) {
        for(var H = U.params.priv_key, K = U.params.p, re = U.params.q, Q = U.params.g, G = new i(0), R, X = y(N, re).mod(re), $ = !1, S = p(H, re, N, D); $ === !1;)R = A(re, S, D), G = O(Q, R, K, re), $ = R.invm(re).imul(X.add(H.mul(G))).mod(re), $.cmpn(0) === 0 && ($ = !1, G = new i(0));
        return l(G, $);
    }
    function l(N, U) {
        N = N.toArray(), U = U.toArray(), N[0] & 128 && (N = [
            0
        ].concat(N)), U[0] & 128 && (U = [
            0
        ].concat(U));
        var D = N.length + U.length + 4, H = [
            48,
            D,
            2,
            N.length
        ];
        return H = H.concat(N, [
            2,
            U.length
        ], U), e.from(H);
    }
    function p(N, U, D, H) {
        if (N = e.from(N.toArray()), N.length < U.byteLength()) {
            var K = e.alloc(U.byteLength() - N.length);
            N = e.concat([
                K,
                N
            ]);
        }
        var re = D.length, Q = _(D, U), G = e.alloc(re);
        G.fill(1);
        var R = e.alloc(re);
        return R = t(H, R).update(G).update(e.from([
            0
        ])).update(N).update(Q).digest(), G = t(H, R).update(G).digest(), R = t(H, R).update(G).update(e.from([
            1
        ])).update(N).update(Q).digest(), G = t(H, R).update(G).digest(), {
            k: R,
            v: G
        };
    }
    function y(N, U) {
        var D = new i(N), H = (N.length << 3) - U.bitLength();
        return H > 0 && D.ishrn(H), D;
    }
    function _(N, U) {
        N = y(N, U), N = N.mod(U);
        var D = e.from(N.toArray());
        if (D.length < U.byteLength()) {
            var H = e.alloc(U.byteLength() - D.length);
            D = e.concat([
                H,
                D
            ]);
        }
        return D;
    }
    function A(N, U, D) {
        var H, K;
        do {
            for(H = e.alloc(0); H.length * 8 < N.bitLength();)U.v = t(D, U.k).update(U.v).digest(), H = e.concat([
                H,
                U.v
            ]);
            K = y(H, N), U.k = t(D, U.k).update(U.v).update(e.from([
                0
            ])).digest(), U.v = t(D, U.k).update(U.v).digest();
        }while (K.cmp(N) !== -1)
        return K;
    }
    function O(N, U, D, H) {
        return N.toRed(i.mont(D)).redPow(U).fromRed().mod(H);
    }
    return dh.exports = u, dh.exports.getKey = p, dh.exports.makeKey = A, dh.exports;
}
var J2, FT;
function KX() {
    if (FT) return J2;
    FT = 1;
    var e = Ar().Buffer, t = D3(), r = H3().ec, n = kb(), i = UO;
    function o(f, c, l, p, y) {
        var _ = n(l);
        if (_.type === "ec") {
            if (p !== "ecdsa" && p !== "ecdsa/rsa") throw new Error("wrong public key type");
            return s(f, c, _);
        } else if (_.type === "dsa") {
            if (p !== "dsa") throw new Error("wrong public key type");
            return a(f, c, _);
        }
        if (p !== "rsa" && p !== "ecdsa/rsa") throw new Error("wrong public key type");
        c = e.concat([
            y,
            c
        ]);
        for(var A = _.modulus.byteLength(), O = [
            1
        ], N = 0; c.length + O.length + 2 < A;)O.push(255), N += 1;
        O.push(0);
        for(var U = -1; ++U < c.length;)O.push(c[U]);
        O = e.from(O);
        var D = t.mont(_.modulus);
        f = new t(f).toRed(D), f = f.redPow(new t(_.publicExponent)), f = e.from(f.fromRed().toArray());
        var H = N < 8 ? 1 : 0;
        for(A = Math.min(f.length, O.length), f.length !== O.length && (H = 1), U = -1; ++U < A;)H |= f[U] ^ O[U];
        return H === 0;
    }
    function s(f, c, l) {
        var p = i[l.data.algorithm.curve.join(".")];
        if (!p) throw new Error("unknown curve " + l.data.algorithm.curve.join("."));
        var y = new r(p), _ = l.data.subjectPrivateKey.data;
        return y.verify(c, f, _);
    }
    function a(f, c, l) {
        var p = l.data.p, y = l.data.q, _ = l.data.g, A = l.data.pub_key, O = n.signature.decode(f, "der"), N = O.s, U = O.r;
        u(N, y), u(U, y);
        var D = t.mont(p), H = N.invm(y), K = _.toRed(D).redPow(new t(c).mul(H).mod(y)).fromRed().mul(A.toRed(D).redPow(U.mul(H).mod(y)).fromRed()).mod(p).mod(y);
        return K.cmp(U) === 0;
    }
    function u(f, c) {
        if (f.cmpn(0) <= 0) throw new Error("invalid sig");
        if (f.cmp(c) >= 0) throw new Error("invalid sig");
    }
    return J2 = o, J2;
}
var Q2, zT;
function WX() {
    if (zT) return Q2;
    zT = 1;
    var e = Ar().Buffer, t = n0(), r = dX(), n = Or(), i = qX(), o = KX(), s = cO;
    Object.keys(s).forEach(function(l) {
        s[l].id = e.from(s[l].id, "hex"), s[l.toLowerCase()] = s[l];
    });
    function a(l) {
        r.Writable.call(this);
        var p = s[l];
        if (!p) throw new Error("Unknown message digest");
        this._hashType = p.hash, this._hash = t(p.hash), this._tag = p.id, this._signType = p.sign;
    }
    n(a, r.Writable), a.prototype._write = function(p, y, _) {
        this._hash.update(p), _();
    }, a.prototype.update = function(p, y) {
        return this._hash.update(typeof p == "string" ? e.from(p, y) : p), this;
    }, a.prototype.sign = function(p, y) {
        this.end();
        var _ = this._hash.digest(), A = i(_, p, this._hashType, this._signType, this._tag);
        return y ? A.toString(y) : A;
    };
    function u(l) {
        r.Writable.call(this);
        var p = s[l];
        if (!p) throw new Error("Unknown message digest");
        this._hash = t(p.hash), this._tag = p.id, this._signType = p.sign;
    }
    n(u, r.Writable), u.prototype._write = function(p, y, _) {
        this._hash.update(p), _();
    }, u.prototype.update = function(p, y) {
        return this._hash.update(typeof p == "string" ? e.from(p, y) : p), this;
    }, u.prototype.verify = function(p, y, _) {
        var A = typeof y == "string" ? e.from(y, _) : y;
        this.end();
        var O = this._hash.digest();
        return o(A, O, p, this._signType, this._tag);
    };
    function f(l) {
        return new a(l);
    }
    function c(l) {
        return new u(l);
    }
    return Q2 = {
        Sign: f,
        Verify: c,
        createSign: f,
        createVerify: c
    }, Q2;
}
var e_, jT;
function VX() {
    if (jT) return e_;
    jT = 1;
    var e = H3(), t = bi();
    e_ = function(s) {
        return new n(s);
    };
    var r = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
    function n(o) {
        this.curveType = r[o], this.curveType || (this.curveType = {
            name: o
        }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
    }
    n.prototype.generateKeys = function(o, s) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(o, s);
    }, n.prototype.computeSecret = function(o, s, a) {
        s = s || "utf8", We.isBuffer(o) || (o = new We(o, s));
        var u = this.curve.keyFromPublic(o).getPublic(), f = u.mul(this.keys.getPrivate()).getX();
        return i(f, a, this.curveType.byteLength);
    }, n.prototype.getPublicKey = function(o, s) {
        var a = this.keys.getPublic(s === "compressed", !0);
        return s === "hybrid" && (a[a.length - 1] % 2 ? a[0] = 7 : a[0] = 6), i(a, o);
    }, n.prototype.getPrivateKey = function(o) {
        return i(this.keys.getPrivate(), o);
    }, n.prototype.setPublicKey = function(o, s) {
        return s = s || "utf8", We.isBuffer(o) || (o = new We(o, s)), this.keys._importPublic(o), this;
    }, n.prototype.setPrivateKey = function(o, s) {
        s = s || "utf8", We.isBuffer(o) || (o = new We(o, s));
        var a = new t(o);
        return a = a.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(a), this;
    };
    function i(o, s, a) {
        Array.isArray(o) || (o = o.toArray());
        var u = new We(o);
        if (a && u.length < a) {
            var f = new We(a - u.length);
            f.fill(0), u = We.concat([
                f,
                u
            ]);
        }
        return s ? u.toString(s) : u;
    }
    return e_;
}
var t_ = {}, r_, HT;
function $O() {
    if (HT) return r_;
    HT = 1;
    var e = n0(), t = Ar().Buffer;
    r_ = function(n, i) {
        for(var o = t.alloc(0), s = 0, a; o.length < i;)a = r(s++), o = t.concat([
            o,
            e("sha1").update(n).update(a).digest()
        ]);
        return o.slice(0, i);
    };
    function r(n) {
        var i = t.allocUnsafe(4);
        return i.writeUInt32BE(n, 0), i;
    }
    return r_;
}
var n_, qT;
function LO() {
    return qT || (qT = 1, n_ = function(t, r) {
        for(var n = t.length, i = -1; ++i < n;)t[i] ^= r[i];
        return t;
    }), n_;
}
var i_, KT;
function DO() {
    if (KT) return i_;
    KT = 1;
    var e = bi(), t = Ar().Buffer;
    function r(n, i) {
        return t.from(n.toRed(e.mont(i.modulus)).redPow(new e(i.publicExponent)).fromRed().toArray());
    }
    return i_ = r, i_;
}
var o_, WT;
function GX() {
    if (WT) return o_;
    WT = 1;
    var e = kb(), t = kd(), r = n0(), n = $O(), i = LO(), o = bi(), s = DO(), a = F3(), u = Ar().Buffer;
    o_ = function(y, _, A) {
        var O;
        y.padding ? O = y.padding : A ? O = 1 : O = 4;
        var N = e(y), U;
        if (O === 4) U = f(N, _);
        else if (O === 1) U = c(N, _, A);
        else if (O === 3) {
            if (U = new o(_), U.cmp(N.modulus) >= 0) throw new Error("data too long for modulus");
        } else throw new Error("unknown padding");
        return A ? a(U, N) : s(U, N);
    };
    function f(p, y) {
        var _ = p.modulus.byteLength(), A = y.length, O = r("sha1").update(u.alloc(0)).digest(), N = O.length, U = 2 * N;
        if (A > _ - U - 2) throw new Error("message too long");
        var D = u.alloc(_ - A - U - 2), H = _ - N - 1, K = t(N), re = i(u.concat([
            O,
            D,
            u.alloc(1, 1),
            y
        ], H), n(K, H)), Q = i(K, n(re, N));
        return new o(u.concat([
            u.alloc(1),
            Q,
            re
        ], _));
    }
    function c(p, y, _) {
        var A = y.length, O = p.modulus.byteLength();
        if (A > O - 11) throw new Error("message too long");
        var N;
        return _ ? N = u.alloc(O - A - 3, 255) : N = l(O - A - 3), new o(u.concat([
            u.from([
                0,
                _ ? 1 : 2
            ]),
            N,
            u.alloc(1),
            y
        ], O));
    }
    function l(p) {
        for(var y = u.allocUnsafe(p), _ = 0, A = t(p * 2), O = 0, N; _ < p;)O === A.length && (A = t(p * 2), O = 0), N = A[O++], N && (y[_++] = N);
        return y;
    }
    return o_;
}
var s_, VT;
function ZX() {
    if (VT) return s_;
    VT = 1;
    var e = kb(), t = $O(), r = LO(), n = bi(), i = F3(), o = n0(), s = DO(), a = Ar().Buffer;
    s_ = function(p, y, _) {
        var A;
        p.padding ? A = p.padding : _ ? A = 1 : A = 4;
        var O = e(p), N = O.modulus.byteLength();
        if (y.length > N || new n(y).cmp(O.modulus) >= 0) throw new Error("decryption error");
        var U;
        _ ? U = s(new n(y), O) : U = i(y, O);
        var D = a.alloc(N - U.length);
        if (U = a.concat([
            D,
            U
        ], N), A === 4) return u(O, U);
        if (A === 1) return f(O, U, _);
        if (A === 3) return U;
        throw new Error("unknown padding");
    };
    function u(l, p) {
        var y = l.modulus.byteLength(), _ = o("sha1").update(a.alloc(0)).digest(), A = _.length;
        if (p[0] !== 0) throw new Error("decryption error");
        var O = p.slice(1, A + 1), N = p.slice(A + 1), U = r(O, t(N, A)), D = r(N, t(U, y - A - 1));
        if (c(_, D.slice(0, A))) throw new Error("decryption error");
        for(var H = A; D[H] === 0;)H++;
        if (D[H++] !== 1) throw new Error("decryption error");
        return D.slice(H);
    }
    function f(l, p, y) {
        for(var _ = p.slice(0, 2), A = 2, O = 0; p[A++] !== 0;)if (A >= p.length) {
            O++;
            break;
        }
        var N = p.slice(2, A - 1);
        if ((_.toString("hex") !== "0002" && !y || _.toString("hex") !== "0001" && y) && O++, N.length < 8 && O++, O) throw new Error("decryption error");
        return p.slice(A);
    }
    function c(l, p) {
        l = a.from(l), p = a.from(p);
        var y = 0, _ = l.length;
        l.length !== p.length && (y++, _ = Math.min(l.length, p.length));
        for(var A = -1; ++A < _;)y += l[A] ^ p[A];
        return y;
    }
    return s_;
}
var GT;
function YX() {
    return GT || (GT = 1, function(e) {
        e.publicEncrypt = GX(), e.privateDecrypt = ZX(), e.privateEncrypt = function(r, n) {
            return e.publicEncrypt(r, n, !0);
        }, e.publicDecrypt = function(r, n) {
            return e.privateDecrypt(r, n, !0);
        };
    }(t_)), t_;
}
var hl = {}, ZT;
function XX() {
    if (ZT) return hl;
    ZT = 1;
    function e() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var t = Ar(), r = kd(), n = t.Buffer, i = t.kMaxLength, o = Ge.crypto || Ge.msCrypto, s = Math.pow(2, 32) - 1;
    function a(p, y) {
        if (typeof p != "number" || p !== p) throw new TypeError("offset must be a number");
        if (p > s || p < 0) throw new TypeError("offset must be a uint32");
        if (p > i || p > y) throw new RangeError("offset out of range");
    }
    function u(p, y, _) {
        if (typeof p != "number" || p !== p) throw new TypeError("size must be a number");
        if (p > s || p < 0) throw new TypeError("size must be a uint32");
        if (p + y > _ || p > i) throw new RangeError("buffer too small");
    }
    o && o.getRandomValues || !bn.browser ? (hl.randomFill = f, hl.randomFillSync = l) : (hl.randomFill = e, hl.randomFillSync = e);
    function f(p, y, _, A) {
        if (!n.isBuffer(p) && !(p instanceof Ge.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof y == "function") A = y, y = 0, _ = p.length;
        else if (typeof _ == "function") A = _, _ = p.length - y;
        else if (typeof A != "function") throw new TypeError('"cb" argument must be a function');
        return a(y, p.length), u(_, y, p.length), c(p, y, _, A);
    }
    function c(p, y, _, A) {
        if (bn.browser) {
            var O = p.buffer, N = new Uint8Array(O, y, _);
            if (o.getRandomValues(N), A) {
                bn.nextTick(function() {
                    A(null, p);
                });
                return;
            }
            return p;
        }
        if (A) {
            r(_, function(D, H) {
                if (D) return A(D);
                H.copy(p, y), A(null, p);
            });
            return;
        }
        var U = r(_);
        return U.copy(p, y), p;
    }
    function l(p, y, _) {
        if (typeof y > "u" && (y = 0), !n.isBuffer(p) && !(p instanceof Ge.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return a(y, p.length), _ === void 0 && (_ = p.length - y), u(_, y, p.length), c(p, y, _);
    }
    return hl;
}
var YT;
function q3() {
    if (YT) return gr;
    YT = 1, gr.randomBytes = gr.rng = gr.pseudoRandomBytes = gr.prng = kd(), gr.createHash = gr.Hash = n0(), gr.createHmac = gr.Hmac = aO();
    var e = PY(), t = Object.keys(e), r = [
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "md5",
        "rmd160"
    ].concat(t);
    gr.getHashes = function() {
        return r;
    };
    var n = hO();
    gr.pbkdf2 = n.pbkdf2, gr.pbkdf2Sync = n.pbkdf2Sync;
    var i = YY();
    gr.Cipher = i.Cipher, gr.createCipher = i.createCipher, gr.Cipheriv = i.Cipheriv, gr.createCipheriv = i.createCipheriv, gr.Decipher = i.Decipher, gr.createDecipher = i.createDecipher, gr.Decipheriv = i.Decipheriv, gr.createDecipheriv = i.createDecipheriv, gr.getCiphers = i.getCiphers, gr.listCiphers = i.listCiphers;
    var o = aX();
    gr.DiffieHellmanGroup = o.DiffieHellmanGroup, gr.createDiffieHellmanGroup = o.createDiffieHellmanGroup, gr.getDiffieHellman = o.getDiffieHellman, gr.createDiffieHellman = o.createDiffieHellman, gr.DiffieHellman = o.DiffieHellman;
    var s = WX();
    gr.createSign = s.createSign, gr.Sign = s.Sign, gr.createVerify = s.createVerify, gr.Verify = s.Verify, gr.createECDH = VX();
    var a = YX();
    gr.publicEncrypt = a.publicEncrypt, gr.privateEncrypt = a.privateEncrypt, gr.publicDecrypt = a.publicDecrypt, gr.privateDecrypt = a.privateDecrypt;
    var u = XX();
    return gr.randomFill = u.randomFill, gr.randomFillSync = u.randomFillSync, gr.createCredentials = function() {
        throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    }, gr.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    }, gr;
}
(function(e) {
    /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.hexToBytes = e.bytesToHex = e.Signature = e.Point = e.CURVE = void 0;
    const t = q3(), r = BigInt(0), n = BigInt(1), i = BigInt(2), o = BigInt(3), s = BigInt(8), a = Object.freeze({
        a: r,
        b: BigInt(7),
        P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: n,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    e.CURVE = a;
    const u = (Ae, we)=>(Ae + we / i) / we, f = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar (Ae) {
            const { n: we } = a, xe = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Me = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ze = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Ve = xe, at = BigInt("0x100000000000000000000000000000000"), ct = u(Ve * Ae, we), lt = u(-Me * Ae, we);
            let mt = ee(Ae - ct * xe - lt * ze, we), wt = ee(-ct * Me - lt * Ve, we);
            const bt = mt > at, Mt = wt > at;
            if (bt && (mt = we - mt), Mt && (wt = we - wt), mt > at || wt > at) throw new Error("splitScalarEndo: Endomorphism failed, k=" + Ae);
            return {
                k1neg: bt,
                k1: mt,
                k2neg: Mt,
                k2: wt
            };
        }
    }, c = 32, l = 32, p = 32, y = c + 1, _ = 2 * c + 1;
    function A(Ae) {
        const { a: we, b: xe } = a, Me = ee(Ae * Ae), ze = ee(Me * Ae);
        return ee(ze + we * Ae + xe);
    }
    const O = a.a === r;
    class N extends Error {
        constructor(we){
            super(we);
        }
    }
    function U(Ae) {
        if (!(Ae instanceof D)) throw new TypeError("JacobianPoint expected");
    }
    class D {
        constructor(we, xe, Me){
            this.x = we, this.y = xe, this.z = Me;
        }
        static fromAffine(we) {
            if (!(we instanceof re)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return we.equals(re.ZERO) ? D.ZERO : new D(we.x, we.y, n);
        }
        static toAffineBatch(we) {
            const xe = De(we.map((Me)=>Me.z));
            return we.map((Me, ze)=>Me.toAffine(xe[ze]));
        }
        static normalizeZ(we) {
            return D.toAffineBatch(we).map(D.fromAffine);
        }
        equals(we) {
            U(we);
            const { x: xe, y: Me, z: ze } = this, { x: Ve, y: at, z: ct } = we, lt = ee(ze * ze), mt = ee(ct * ct), wt = ee(xe * mt), bt = ee(Ve * lt), Mt = ee(ee(Me * ct) * mt), Ct = ee(ee(at * ze) * lt);
            return wt === bt && Mt === Ct;
        }
        negate() {
            return new D(this.x, ee(-this.y), this.z);
        }
        double() {
            const { x: we, y: xe, z: Me } = this, ze = ee(we * we), Ve = ee(xe * xe), at = ee(Ve * Ve), ct = we + Ve, lt = ee(i * (ee(ct * ct) - ze - at)), mt = ee(o * ze), wt = ee(mt * mt), bt = ee(wt - i * lt), Mt = ee(mt * (lt - bt) - s * at), Ct = ee(i * xe * Me);
            return new D(bt, Mt, Ct);
        }
        add(we) {
            U(we);
            const { x: xe, y: Me, z: ze } = this, { x: Ve, y: at, z: ct } = we;
            if (Ve === r || at === r) return this;
            if (xe === r || Me === r) return we;
            const lt = ee(ze * ze), mt = ee(ct * ct), wt = ee(xe * mt), bt = ee(Ve * lt), Mt = ee(ee(Me * ct) * mt), Ct = ee(ee(at * ze) * lt), Xe = ee(bt - wt), xt = ee(Ct - Mt);
            if (Xe === r) return xt === r ? this.double() : D.ZERO;
            const St = ee(Xe * Xe), Pe = ee(Xe * St), et = ee(wt * St), vt = ee(xt * xt - Pe - i * et), be = ee(xt * (et - vt) - Mt * Pe), $r = ee(ze * ct * Xe);
            return new D(vt, be, $r);
        }
        subtract(we) {
            return this.add(we.negate());
        }
        multiplyUnsafe(we) {
            const xe = D.ZERO;
            if (typeof we == "bigint" && we === r) return xe;
            let Me = he(we);
            if (Me === n) return this;
            if (!O) {
                let bt = xe, Mt = this;
                for(; Me > r;)Me & n && (bt = bt.add(Mt)), Mt = Mt.double(), Me >>= n;
                return bt;
            }
            let { k1neg: ze, k1: Ve, k2neg: at, k2: ct } = f.splitScalar(Me), lt = xe, mt = xe, wt = this;
            for(; Ve > r || ct > r;)Ve & n && (lt = lt.add(wt)), ct & n && (mt = mt.add(wt)), wt = wt.double(), Ve >>= n, ct >>= n;
            return ze && (lt = lt.negate()), at && (mt = mt.negate()), mt = new D(ee(mt.x * f.beta), mt.y, mt.z), lt.add(mt);
        }
        precomputeWindow(we) {
            const xe = O ? 128 / we + 1 : 256 / we + 1, Me = [];
            let ze = this, Ve = ze;
            for(let at = 0; at < xe; at++){
                Ve = ze, Me.push(Ve);
                for(let ct = 1; ct < 2 ** (we - 1); ct++)Ve = Ve.add(ze), Me.push(Ve);
                ze = Ve.double();
            }
            return Me;
        }
        wNAF(we, xe) {
            !xe && this.equals(D.BASE) && (xe = re.BASE);
            const Me = xe && xe._WINDOW_SIZE || 1;
            if (256 % Me) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let ze = xe && K.get(xe);
            ze || (ze = this.precomputeWindow(Me), xe && Me !== 1 && (ze = D.normalizeZ(ze), K.set(xe, ze)));
            let Ve = D.ZERO, at = D.BASE;
            const ct = 1 + (O ? 128 / Me : 256 / Me), lt = 2 ** (Me - 1), mt = BigInt(2 ** Me - 1), wt = 2 ** Me, bt = BigInt(Me);
            for(let Mt = 0; Mt < ct; Mt++){
                const Ct = Mt * lt;
                let Xe = Number(we & mt);
                we >>= bt, Xe > lt && (Xe -= wt, we += n);
                const xt = Ct, St = Ct + Math.abs(Xe) - 1, Pe = Mt % 2 !== 0, et = Xe < 0;
                Xe === 0 ? at = at.add(H(Pe, ze[xt])) : Ve = Ve.add(H(et, ze[St]));
            }
            return {
                p: Ve,
                f: at
            };
        }
        multiply(we, xe) {
            let Me = he(we), ze, Ve;
            if (O) {
                const { k1neg: at, k1: ct, k2neg: lt, k2: mt } = f.splitScalar(Me);
                let { p: wt, f: bt } = this.wNAF(ct, xe), { p: Mt, f: Ct } = this.wNAF(mt, xe);
                wt = H(at, wt), Mt = H(lt, Mt), Mt = new D(ee(Mt.x * f.beta), Mt.y, Mt.z), ze = wt.add(Mt), Ve = bt.add(Ct);
            } else {
                const { p: at, f: ct } = this.wNAF(Me, xe);
                ze = at, Ve = ct;
            }
            return D.normalizeZ([
                ze,
                Ve
            ])[0];
        }
        toAffine(we) {
            const { x: xe, y: Me, z: ze } = this, Ve = this.equals(D.ZERO);
            we == null && (we = Ve ? s : Se(ze));
            const at = we, ct = ee(at * at), lt = ee(ct * at), mt = ee(xe * ct), wt = ee(Me * lt), bt = ee(ze * at);
            if (Ve) return re.ZERO;
            if (bt !== n) throw new Error("invZ was invalid");
            return new re(mt, wt);
        }
    }
    D.BASE = new D(a.Gx, a.Gy, n), D.ZERO = new D(r, n, r);
    function H(Ae, we) {
        const xe = we.negate();
        return Ae ? xe : we;
    }
    const K = /* @__PURE__ */ new WeakMap();
    class re {
        constructor(we, xe){
            this.x = we, this.y = xe;
        }
        _setWindowSize(we) {
            this._WINDOW_SIZE = we, K.delete(this);
        }
        hasEvenY() {
            return this.y % i === r;
        }
        static fromCompressedHex(we) {
            const xe = we.length === 32, Me = ue(xe ? we : we.subarray(1));
            if (!Ie(Me)) throw new Error("Point is not on curve");
            const ze = A(Me);
            let Ve = ye(ze);
            const at = (Ve & n) === n;
            xe ? at && (Ve = ee(-Ve)) : (we[0] & 1) === 1 !== at && (Ve = ee(-Ve));
            const ct = new re(Me, Ve);
            return ct.assertValidity(), ct;
        }
        static fromUncompressedHex(we) {
            const xe = ue(we.subarray(1, c + 1)), Me = ue(we.subarray(c + 1, c * 2 + 1)), ze = new re(xe, Me);
            return ze.assertValidity(), ze;
        }
        static fromHex(we) {
            const xe = ce(we), Me = xe.length, ze = xe[0];
            if (Me === c) return this.fromCompressedHex(xe);
            if (Me === y && (ze === 2 || ze === 3)) return this.fromCompressedHex(xe);
            if (Me === _ && ze === 4) return this.fromUncompressedHex(xe);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${_} uncompressed bytes, not ${Me}`);
        }
        static fromPrivateKey(we) {
            return re.BASE.multiply(Ke(we));
        }
        static fromSignature(we, xe, Me) {
            const { r: ze, s: Ve } = h(xe);
            if (![
                0,
                1,
                2,
                3
            ].includes(Me)) throw new Error("Cannot recover: invalid recovery bit");
            const at = Ce(ce(we)), { n: ct } = a, lt = Me === 2 || Me === 3 ? ze + ct : ze, mt = Se(lt, ct), wt = ee(-at * mt, ct), bt = ee(Ve * mt, ct), Mt = Me & 1 ? "03" : "02", Ct = re.fromHex(Mt + k(lt)), Xe = re.BASE.multiplyAndAddUnsafe(Ct, wt, bt);
            if (!Xe) throw new Error("Cannot recover signature: point at infinify");
            return Xe.assertValidity(), Xe;
        }
        toRawBytes(we = !1) {
            return I(this.toHex(we));
        }
        toHex(we = !1) {
            const xe = k(this.x);
            return we ? `${this.hasEvenY() ? "02" : "03"}${xe}` : `04${xe}${k(this.y)}`;
        }
        toHexX() {
            return this.toHex(!0).slice(2);
        }
        toRawX() {
            return this.toRawBytes(!0).slice(1);
        }
        assertValidity() {
            const we = "Point is not on elliptic curve", { x: xe, y: Me } = this;
            if (!Ie(xe) || !Ie(Me)) throw new Error(we);
            const ze = ee(Me * Me), Ve = A(xe);
            if (ee(ze - Ve) !== r) throw new Error(we);
        }
        equals(we) {
            return this.x === we.x && this.y === we.y;
        }
        negate() {
            return new re(this.x, ee(-this.y));
        }
        double() {
            return D.fromAffine(this).double().toAffine();
        }
        add(we) {
            return D.fromAffine(this).add(D.fromAffine(we)).toAffine();
        }
        subtract(we) {
            return this.add(we.negate());
        }
        multiply(we) {
            return D.fromAffine(this).multiply(we, this).toAffine();
        }
        multiplyAndAddUnsafe(we, xe, Me) {
            const ze = D.fromAffine(this), Ve = xe === r || xe === n || this !== re.BASE ? ze.multiplyUnsafe(xe) : ze.multiply(xe), at = D.fromAffine(we).multiplyUnsafe(Me), ct = Ve.add(at);
            return ct.equals(D.ZERO) ? void 0 : ct.toAffine();
        }
    }
    e.Point = re, re.BASE = new re(a.Gx, a.Gy), re.ZERO = new re(r, r);
    function Q(Ae) {
        return Number.parseInt(Ae[0], 16) >= 8 ? "00" + Ae : Ae;
    }
    function G(Ae) {
        if (Ae.length < 2 || Ae[0] !== 2) throw new Error(`Invalid signature integer tag: ${m(Ae)}`);
        const we = Ae[1], xe = Ae.subarray(2, we + 2);
        if (!we || xe.length !== we) throw new Error("Invalid signature integer: wrong length");
        if (xe[0] === 0 && xe[1] <= 127) throw new Error("Invalid signature integer: trailing length");
        return {
            data: ue(xe),
            left: Ae.subarray(we + 2)
        };
    }
    function R(Ae) {
        if (Ae.length < 2 || Ae[0] != 48) throw new Error(`Invalid signature tag: ${m(Ae)}`);
        if (Ae[1] !== Ae.length - 2) throw new Error("Invalid signature: incorrect length");
        const { data: we, left: xe } = G(Ae.subarray(2)), { data: Me, left: ze } = G(xe);
        if (ze.length) throw new Error(`Invalid signature: left bytes after parsing: ${m(ze)}`);
        return {
            r: we,
            s: Me
        };
    }
    class X {
        constructor(we, xe){
            this.r = we, this.s = xe, this.assertValidity();
        }
        static fromCompact(we) {
            const xe = $(we), Me = "Signature.fromCompact";
            if (typeof we != "string" && !xe) throw new TypeError(`${Me}: Expected string or Uint8Array`);
            const ze = xe ? m(we) : we;
            if (ze.length !== 128) throw new Error(`${Me}: Expected 64-byte hex`);
            return new X(ie(ze.slice(0, 64)), ie(ze.slice(64, 128)));
        }
        static fromDER(we) {
            const xe = $(we);
            if (typeof we != "string" && !xe) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
            const { r: Me, s: ze } = R(xe ? we : I(we));
            return new X(Me, ze);
        }
        static fromHex(we) {
            return this.fromDER(we);
        }
        assertValidity() {
            const { r: we, s: xe } = this;
            if (!_e(we)) throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!_e(xe)) throw new Error("Invalid Signature: s must be 0 < s < n");
        }
        hasHighS() {
            const we = a.n >> n;
            return this.s > we;
        }
        normalizeS() {
            return this.hasHighS() ? new X(this.r, ee(-this.s, a.n)) : this;
        }
        toDERRawBytes() {
            return I(this.toDERHex());
        }
        toDERHex() {
            const we = Q(j(this.s)), xe = Q(j(this.r)), Me = we.length / 2, ze = xe.length / 2, Ve = j(Me), at = j(ze);
            return `30${j(ze + Me + 4)}02${at}${xe}02${Ve}${we}`;
        }
        toRawBytes() {
            return this.toDERRawBytes();
        }
        toHex() {
            return this.toDERHex();
        }
        toCompactRawBytes() {
            return I(this.toCompactHex());
        }
        toCompactHex() {
            return k(this.r) + k(this.s);
        }
    }
    e.Signature = X;
    function $(Ae) {
        return Ae instanceof Uint8Array || ArrayBuffer.isView(Ae) && Ae.constructor.name === "Uint8Array";
    }
    function S(Ae) {
        if (!$(Ae)) throw new Error("Uint8Array expected");
    }
    function w(...Ae) {
        if (Ae.every(S), Ae.length === 1) return Ae[0];
        const we = Ae.reduce((Me, ze)=>Me + ze.length, 0), xe = new Uint8Array(we);
        for(let Me = 0, ze = 0; Me < Ae.length; Me++){
            const Ve = Ae[Me];
            xe.set(Ve, ze), ze += Ve.length;
        }
        return xe;
    }
    const g = Array.from({
        length: 256
    }, (Ae, we)=>we.toString(16).padStart(2, "0"));
    function m(Ae) {
        S(Ae);
        let we = "";
        for(let xe = 0; xe < Ae.length; xe++)we += g[Ae[xe]];
        return we;
    }
    e.bytesToHex = m;
    const E = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function T(Ae) {
        if (Ae >= E._0 && Ae <= E._9) return Ae - E._0;
        if (Ae >= E.A && Ae <= E.F) return Ae - (E.A - 10);
        if (Ae >= E.a && Ae <= E.f) return Ae - (E.a - 10);
    }
    function I(Ae) {
        if (typeof Ae != "string") throw new Error("hex string expected, got " + typeof Ae);
        const we = Ae.length, xe = we / 2;
        if (we % 2) throw new Error("hex string expected, got unpadded hex of length " + we);
        const Me = new Uint8Array(xe);
        for(let ze = 0, Ve = 0; ze < xe; ze++, Ve += 2){
            const at = T(Ae.charCodeAt(Ve)), ct = T(Ae.charCodeAt(Ve + 1));
            if (at === void 0 || ct === void 0) {
                const lt = Ae[Ve] + Ae[Ve + 1];
                throw new Error('hex string expected, got non-hex character "' + lt + '" at index ' + Ve);
            }
            Me[ze] = at * 16 + ct;
        }
        return Me;
    }
    e.hexToBytes = I;
    const P = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function k(Ae) {
        if (typeof Ae != "bigint") throw new Error("Expected bigint");
        if (!(r <= Ae && Ae < P)) throw new Error("Expected number 0 <= n < 2^256");
        return Ae.toString(16).padStart(64, "0");
    }
    function L(Ae) {
        const we = I(k(Ae));
        if (we.length !== 32) throw new Error("Error: expected 32 bytes");
        return we;
    }
    function j(Ae) {
        const we = Ae.toString(16);
        return we.length & 1 ? `0${we}` : we;
    }
    function ie(Ae) {
        if (typeof Ae != "string") throw new TypeError("hexToNumber: expected string, got " + typeof Ae);
        return BigInt(`0x${Ae}`);
    }
    function ue(Ae) {
        return ie(m(Ae));
    }
    function ce(Ae) {
        return $(Ae) ? Uint8Array.from(Ae) : I(Ae);
    }
    function he(Ae) {
        if (typeof Ae == "number" && Number.isSafeInteger(Ae) && Ae > 0) return BigInt(Ae);
        if (typeof Ae == "bigint" && _e(Ae)) return Ae;
        throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function ee(Ae, we = a.P) {
        const xe = Ae % we;
        return xe >= r ? xe : we + xe;
    }
    function ae(Ae, we) {
        const { P: xe } = a;
        let Me = Ae;
        for(; we-- > r;)Me *= Me, Me %= xe;
        return Me;
    }
    function ye(Ae) {
        const { P: we } = a, xe = BigInt(6), Me = BigInt(11), ze = BigInt(22), Ve = BigInt(23), at = BigInt(44), ct = BigInt(88), lt = Ae * Ae * Ae % we, mt = lt * lt * Ae % we, wt = ae(mt, o) * mt % we, bt = ae(wt, o) * mt % we, Mt = ae(bt, i) * lt % we, Ct = ae(Mt, Me) * Mt % we, Xe = ae(Ct, ze) * Ct % we, xt = ae(Xe, at) * Xe % we, St = ae(xt, ct) * xt % we, Pe = ae(St, at) * Xe % we, et = ae(Pe, o) * mt % we, vt = ae(et, Ve) * Ct % we, be = ae(vt, xe) * lt % we, $r = ae(be, i);
        if ($r * $r % we !== Ae) throw new Error("Cannot find square root");
        return $r;
    }
    function Se(Ae, we = a.P) {
        if (Ae === r || we <= r) throw new Error(`invert: expected positive integers, got n=${Ae} mod=${we}`);
        let xe = ee(Ae, we), Me = we, ze = r, Ve = n;
        for(; xe !== r;){
            const ct = Me / xe, lt = Me % xe, mt = ze - Ve * ct;
            Me = xe, xe = lt, ze = Ve, Ve = mt;
        }
        if (Me !== n) throw new Error("invert: does not exist");
        return ee(ze, we);
    }
    function De(Ae, we = a.P) {
        const xe = new Array(Ae.length), Me = Ae.reduce((Ve, at, ct)=>at === r ? Ve : (xe[ct] = Ve, ee(Ve * at, we)), n), ze = Se(Me, we);
        return Ae.reduceRight((Ve, at, ct)=>at === r ? Ve : (xe[ct] = ee(Ve * xe[ct], we), ee(Ve * at, we)), ze), xe;
    }
    function Re(Ae) {
        const we = Ae.length * 8 - l * 8, xe = ue(Ae);
        return we > 0 ? xe >> BigInt(we) : xe;
    }
    function Ce(Ae, we = !1) {
        const xe = Re(Ae);
        if (we) return xe;
        const { n: Me } = a;
        return xe >= Me ? xe - Me : xe;
    }
    let M, z;
    class de {
        constructor(we, xe){
            if (this.hashLen = we, this.qByteLen = xe, typeof we != "number" || we < 2) throw new Error("hashLen must be a number");
            if (typeof xe != "number" || xe < 2) throw new Error("qByteLen must be a number");
            this.v = new Uint8Array(we).fill(1), this.k = new Uint8Array(we).fill(0), this.counter = 0;
        }
        hmac(...we) {
            return e.utils.hmacSha256(this.k, ...we);
        }
        hmacSync(...we) {
            return z(this.k, ...we);
        }
        checkSync() {
            if (typeof z != "function") throw new N("hmacSha256Sync needs to be set");
        }
        incr() {
            if (this.counter >= 1e3) throw new Error("Tried 1,000 k values for sign(), all were invalid");
            this.counter += 1;
        }
        async reseed(we = new Uint8Array()) {
            this.k = await this.hmac(this.v, Uint8Array.from([
                0
            ]), we), this.v = await this.hmac(this.v), we.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([
                1
            ]), we), this.v = await this.hmac(this.v));
        }
        reseedSync(we = new Uint8Array()) {
            this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([
                0
            ]), we), this.v = this.hmacSync(this.v), we.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([
                1
            ]), we), this.v = this.hmacSync(this.v));
        }
        async generate() {
            this.incr();
            let we = 0;
            const xe = [];
            for(; we < this.qByteLen;){
                this.v = await this.hmac(this.v);
                const Me = this.v.slice();
                xe.push(Me), we += this.v.length;
            }
            return w(...xe);
        }
        generateSync() {
            this.checkSync(), this.incr();
            let we = 0;
            const xe = [];
            for(; we < this.qByteLen;){
                this.v = this.hmacSync(this.v);
                const Me = this.v.slice();
                xe.push(Me), we += this.v.length;
            }
            return w(...xe);
        }
    }
    function _e(Ae) {
        return r < Ae && Ae < a.n;
    }
    function Ie(Ae) {
        return r < Ae && Ae < a.P;
    }
    function je(Ae, we, xe, Me = !0) {
        const { n: ze } = a, Ve = Ce(Ae, !0);
        if (!_e(Ve)) return;
        const at = Se(Ve, ze), ct = re.BASE.multiply(Ve), lt = ee(ct.x, ze);
        if (lt === r) return;
        const mt = ee(at * ee(we + xe * lt, ze), ze);
        if (mt === r) return;
        let wt = new X(lt, mt), bt = (ct.x === wt.r ? 0 : 2) | Number(ct.y & n);
        return Me && wt.hasHighS() && (wt = wt.normalizeS(), bt ^= 1), {
            sig: wt,
            recovery: bt
        };
    }
    function Ke(Ae) {
        let we;
        if (typeof Ae == "bigint") we = Ae;
        else if (typeof Ae == "number" && Number.isSafeInteger(Ae) && Ae > 0) we = BigInt(Ae);
        else if (typeof Ae == "string") {
            if (Ae.length !== 2 * l) throw new Error("Expected 32 bytes of private key");
            we = ie(Ae);
        } else if ($(Ae)) {
            if (Ae.length !== l) throw new Error("Expected 32 bytes of private key");
            we = ue(Ae);
        } else throw new TypeError("Expected valid private key");
        if (!_e(we)) throw new Error("Expected private key: 0 < key < n");
        return we;
    }
    function Ue(Ae) {
        return Ae instanceof re ? (Ae.assertValidity(), Ae) : re.fromHex(Ae);
    }
    function h(Ae) {
        if (Ae instanceof X) return Ae.assertValidity(), Ae;
        try {
            return X.fromDER(Ae);
        } catch  {
            return X.fromCompact(Ae);
        }
    }
    function x(Ae, we = !1) {
        return re.fromPrivateKey(Ae).toRawBytes(we);
    }
    e.getPublicKey = x;
    function q(Ae, we, xe, Me = !1) {
        return re.fromSignature(Ae, we, xe).toRawBytes(Me);
    }
    e.recoverPublicKey = q;
    function te(Ae) {
        const we = $(Ae), xe = typeof Ae == "string", Me = (we || xe) && Ae.length;
        return we ? Me === y || Me === _ : xe ? Me === y * 2 || Me === _ * 2 : Ae instanceof re;
    }
    function fe(Ae, we, xe = !1) {
        if (te(Ae)) throw new TypeError("getSharedSecret: first arg must be private key");
        if (!te(we)) throw new TypeError("getSharedSecret: second arg must be public key");
        const Me = Ue(we);
        return Me.assertValidity(), Me.multiply(Ke(Ae)).toRawBytes(xe);
    }
    e.getSharedSecret = fe;
    function ne(Ae) {
        const we = Ae.length > c ? Ae.slice(0, c) : Ae;
        return ue(we);
    }
    function W(Ae) {
        const we = ne(Ae), xe = ee(we, a.n);
        return J(xe < r ? we : xe);
    }
    function J(Ae) {
        return L(Ae);
    }
    function V(Ae, we, xe) {
        if (Ae == null) throw new Error(`sign: expected valid message hash, not "${Ae}"`);
        const Me = ce(Ae), ze = Ke(we), Ve = [
            J(ze),
            W(Me)
        ];
        if (xe != null) {
            xe === !0 && (xe = e.utils.randomBytes(c));
            const lt = ce(xe);
            if (lt.length !== c) throw new Error(`sign: Expected ${c} bytes of extra data`);
            Ve.push(lt);
        }
        const at = w(...Ve), ct = ne(Me);
        return {
            seed: at,
            m: ct,
            d: ze
        };
    }
    function C(Ae, we) {
        const { sig: xe, recovery: Me } = Ae, { der: ze, recovered: Ve } = Object.assign({
            canonical: !0,
            der: !0
        }, we), at = ze ? xe.toDERRawBytes() : xe.toCompactRawBytes();
        return Ve ? [
            at,
            Me
        ] : at;
    }
    async function Z(Ae, we, xe = {}) {
        const { seed: Me, m: ze, d: Ve } = V(Ae, we, xe.extraEntropy), at = new de(p, l);
        await at.reseed(Me);
        let ct;
        for(; !(ct = je(await at.generate(), ze, Ve, xe.canonical));)await at.reseed();
        return C(ct, xe);
    }
    e.sign = Z;
    function le(Ae, we, xe = {}) {
        const { seed: Me, m: ze, d: Ve } = V(Ae, we, xe.extraEntropy), at = new de(p, l);
        at.reseedSync(Me);
        let ct;
        for(; !(ct = je(at.generateSync(), ze, Ve, xe.canonical));)at.reseedSync();
        return C(ct, xe);
    }
    e.signSync = le;
    const se = {
        strict: !0
    };
    function Ne(Ae, we, xe, Me = se) {
        let ze;
        try {
            ze = h(Ae), we = ce(we);
        } catch  {
            return !1;
        }
        const { r: Ve, s: at } = ze;
        if (Me.strict && ze.hasHighS()) return !1;
        const ct = Ce(we);
        let lt;
        try {
            lt = Ue(xe);
        } catch  {
            return !1;
        }
        const { n: mt } = a, wt = Se(at, mt), bt = ee(ct * wt, mt), Mt = ee(Ve * wt, mt), Ct = re.BASE.multiplyAndAddUnsafe(lt, bt, Mt);
        return Ct ? ee(Ct.x, mt) === Ve : !1;
    }
    e.verify = Ne;
    function Le(Ae) {
        return ee(ue(Ae), a.n);
    }
    class rt {
        constructor(we, xe){
            this.r = we, this.s = xe, this.assertValidity();
        }
        static fromHex(we) {
            const xe = ce(we);
            if (xe.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${xe.length}`);
            const Me = ue(xe.subarray(0, 32)), ze = ue(xe.subarray(32, 64));
            return new rt(Me, ze);
        }
        assertValidity() {
            const { r: we, s: xe } = this;
            if (!Ie(we) || !_e(xe)) throw new Error("Invalid signature");
        }
        toHex() {
            return k(this.r) + k(this.s);
        }
        toRawBytes() {
            return I(this.toHex());
        }
    }
    function yt(Ae) {
        return re.fromPrivateKey(Ae).toRawX();
    }
    class _t {
        constructor(we, xe, Me = e.utils.randomBytes()){
            if (we == null) throw new TypeError(`sign: Expected valid message, not "${we}"`);
            this.m = ce(we);
            const { x: ze, scalar: Ve } = this.getScalar(Ke(xe));
            if (this.px = ze, this.d = Ve, this.rand = ce(Me), this.rand.length !== 32) throw new TypeError("sign: Expected 32 bytes of aux randomness");
        }
        getScalar(we) {
            const xe = re.fromPrivateKey(we), Me = xe.hasEvenY() ? we : a.n - we;
            return {
                point: xe,
                scalar: Me,
                x: xe.toRawX()
            };
        }
        initNonce(we, xe) {
            return L(we ^ ue(xe));
        }
        finalizeNonce(we) {
            const xe = ee(ue(we), a.n);
            if (xe === r) throw new Error("sign: Creation of signature failed. k is zero");
            const { point: Me, x: ze, scalar: Ve } = this.getScalar(xe);
            return {
                R: Me,
                rx: ze,
                k: Ve
            };
        }
        finalizeSig(we, xe, Me, ze) {
            return new rt(we.x, ee(xe + Me * ze, a.n)).toRawBytes();
        }
        error() {
            throw new Error("sign: Invalid signature produced");
        }
        async calc() {
            const { m: we, d: xe, px: Me, rand: ze } = this, Ve = e.utils.taggedHash, at = this.initNonce(xe, await Ve(wr.aux, ze)), { R: ct, rx: lt, k: mt } = this.finalizeNonce(await Ve(wr.nonce, at, Me, we)), wt = Le(await Ve(wr.challenge, lt, Me, we)), bt = this.finalizeSig(ct, mt, wt, xe);
            return await jr(bt, we, Me) || this.error(), bt;
        }
        calcSync() {
            const { m: we, d: xe, px: Me, rand: ze } = this, Ve = e.utils.taggedHashSync, at = this.initNonce(xe, Ve(wr.aux, ze)), { R: ct, rx: lt, k: mt } = this.finalizeNonce(Ve(wr.nonce, at, Me, we)), wt = Le(Ve(wr.challenge, lt, Me, we)), bt = this.finalizeSig(ct, mt, wt, xe);
            return Et(bt, we, Me) || this.error(), bt;
        }
    }
    async function Qe(Ae, we, xe) {
        return new _t(Ae, we, xe).calc();
    }
    function Rt(Ae, we, xe) {
        return new _t(Ae, we, xe).calcSync();
    }
    function Lt(Ae, we, xe) {
        const Me = Ae instanceof rt, ze = Me ? Ae : rt.fromHex(Ae);
        return Me && ze.assertValidity(), {
            ...ze,
            m: ce(we),
            P: Ue(xe)
        };
    }
    function Ur(Ae, we, xe, Me) {
        const ze = re.BASE.multiplyAndAddUnsafe(we, Ke(xe), ee(-Me, a.n));
        return !(!ze || !ze.hasEvenY() || ze.x !== Ae);
    }
    async function jr(Ae, we, xe) {
        try {
            const { r: Me, s: ze, m: Ve, P: at } = Lt(Ae, we, xe), ct = Le(await e.utils.taggedHash(wr.challenge, L(Me), at.toRawX(), Ve));
            return Ur(Me, at, ze, ct);
        } catch  {
            return !1;
        }
    }
    function Et(Ae, we, xe) {
        try {
            const { r: Me, s: ze, m: Ve, P: at } = Lt(Ae, we, xe), ct = Le(e.utils.taggedHashSync(wr.challenge, L(Me), at.toRawX(), Ve));
            return Ur(Me, at, ze, ct);
        } catch (Me) {
            if (Me instanceof N) throw Me;
            return !1;
        }
    }
    e.schnorr = {
        Signature: rt,
        getPublicKey: yt,
        sign: Qe,
        verify: jr,
        signSync: Rt,
        verifySync: Et
    }, re.BASE._setWindowSize(8);
    const Xt = {
        node: t,
        web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
    }, wr = {
        challenge: "BIP0340/challenge",
        aux: "BIP0340/aux",
        nonce: "BIP0340/nonce"
    }, zt = {};
    e.utils = {
        bytesToHex: m,
        hexToBytes: I,
        concatBytes: w,
        mod: ee,
        invert: Se,
        isValidPrivateKey (Ae) {
            try {
                return Ke(Ae), !0;
            } catch  {
                return !1;
            }
        },
        _bigintTo32Bytes: L,
        _normalizePrivateKey: Ke,
        hashToPrivateKey: (Ae)=>{
            Ae = ce(Ae);
            const we = l + 8;
            if (Ae.length < we || Ae.length > 1024) throw new Error("Expected valid bytes of private key as per FIPS 186");
            const xe = ee(ue(Ae), a.n - n) + n;
            return L(xe);
        },
        randomBytes: (Ae = 32)=>{
            if (Xt.web) return Xt.web.getRandomValues(new Uint8Array(Ae));
            if (Xt.node) {
                const { randomBytes: we } = Xt.node;
                return Uint8Array.from(we(Ae));
            } else throw new Error("The environment doesn't have randomBytes function");
        },
        randomPrivateKey: ()=>e.utils.hashToPrivateKey(e.utils.randomBytes(l + 8)),
        precompute (Ae = 8, we = re.BASE) {
            const xe = we === re.BASE ? we : new re(we.x, we.y);
            return xe._setWindowSize(Ae), xe.multiply(o), xe;
        },
        sha256: async (...Ae)=>{
            if (Xt.web) {
                const we = await Xt.web.subtle.digest("SHA-256", w(...Ae));
                return new Uint8Array(we);
            } else if (Xt.node) {
                const { createHash: we } = Xt.node, xe = we("sha256");
                return Ae.forEach((Me)=>xe.update(Me)), Uint8Array.from(xe.digest());
            } else throw new Error("The environment doesn't have sha256 function");
        },
        hmacSha256: async (Ae, ...we)=>{
            if (Xt.web) {
                const xe = await Xt.web.subtle.importKey("raw", Ae, {
                    name: "HMAC",
                    hash: {
                        name: "SHA-256"
                    }
                }, !1, [
                    "sign"
                ]), Me = w(...we), ze = await Xt.web.subtle.sign("HMAC", xe, Me);
                return new Uint8Array(ze);
            } else if (Xt.node) {
                const { createHmac: xe } = Xt.node, Me = xe("sha256", Ae);
                return we.forEach((ze)=>Me.update(ze)), Uint8Array.from(Me.digest());
            } else throw new Error("The environment doesn't have hmac-sha256 function");
        },
        sha256Sync: void 0,
        hmacSha256Sync: void 0,
        taggedHash: async (Ae, ...we)=>{
            let xe = zt[Ae];
            if (xe === void 0) {
                const Me = await e.utils.sha256(Uint8Array.from(Ae, (ze)=>ze.charCodeAt(0)));
                xe = w(Me, Me), zt[Ae] = xe;
            }
            return e.utils.sha256(xe, ...we);
        },
        taggedHashSync: (Ae, ...we)=>{
            if (typeof M != "function") throw new N("sha256Sync is undefined, you need to set it");
            let xe = zt[Ae];
            if (xe === void 0) {
                const Me = M(Uint8Array.from(Ae, (ze)=>ze.charCodeAt(0)));
                xe = w(Me, Me), zt[Ae] = xe;
            }
            return M(xe, ...we);
        },
        _JacobianPoint: D
    }, Object.defineProperties(e.utils, {
        sha256Sync: {
            configurable: !1,
            get () {
                return M;
            },
            set (Ae) {
                M || (M = Ae);
            }
        },
        hmacSha256Sync: {
            configurable: !1,
            get () {
                return z;
            },
            set (Ae) {
                z || (z = Ae);
            }
        }
    });
})(rO);
var nd = {};
Object.defineProperty(nd, "__esModule", {
    value: !0
});
nd.joseToDer = nd.derToJose = void 0;
const FO = Td, zO = ji;
function a_(e) {
    return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
const JX = {
    ES256: a_(256),
    ES384: a_(384),
    ES512: a_(521)
};
function jO(e) {
    const t = JX[e];
    if (t) return t;
    throw new Error(`Unknown algorithm "${e}"`);
}
const nm = 128, HO = 0, QX = 32, eJ = 16, tJ = 2, qO = eJ | QX | HO << 6, im = tJ | HO << 6;
function KO(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return (0, FO.toByteArray)((0, zO.pad)(e));
    throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function rJ(e, t) {
    const r = KO(e), n = jO(t), i = n + 1, o = r.length;
    let s = 0;
    if (r[s++] !== qO) throw new Error('Could not find expected "seq"');
    let a = r[s++];
    if (a === (nm | 1) && (a = r[s++]), o - s < a) throw new Error(`"seq" specified length of "${a}", only "${o - s}" remaining`);
    if (r[s++] !== im) throw new Error('Could not find expected "int" for "r"');
    const u = r[s++];
    if (o - s - 2 < u) throw new Error(`"r" specified length of "${u}", only "${o - s - 2}" available`);
    if (i < u) throw new Error(`"r" specified length of "${u}", max of "${i}" is acceptable`);
    const f = s;
    if (s += u, r[s++] !== im) throw new Error('Could not find expected "int" for "s"');
    const c = r[s++];
    if (o - s !== c) throw new Error(`"s" specified length of "${c}", expected "${o - s}"`);
    if (i < c) throw new Error(`"s" specified length of "${c}", max of "${i}" is acceptable`);
    const l = s;
    if (s += c, s !== o) throw new Error(`Expected to consume entire array, but "${o - s}" bytes remain`);
    const p = n - u, y = n - c, _ = new Uint8Array(p + u + y + c);
    for(s = 0; s < p; ++s)_[s] = 0;
    _.set(r.subarray(f + Math.max(-p, 0), f + u), s), s = n;
    for(const A = s; s < A + y; ++s)_[s] = 0;
    return _.set(r.subarray(l + Math.max(-y, 0), l + c), s), (0, zO.escape)((0, FO.fromByteArray)(_));
}
nd.derToJose = rJ;
function XT(e, t, r) {
    let n = 0;
    for(; t + n < r && e[t + n] === 0;)++n;
    return e[t + n] >= nm && --n, n;
}
function nJ(e, t) {
    e = KO(e);
    const r = jO(t), n = e.length;
    if (n !== r * 2) throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
    const i = XT(e, 0, r), o = XT(e, r, e.length), s = r - i, a = r - o, u = 2 + s + 1 + 1 + a, f = u < nm, c = new Uint8Array((f ? 2 : 3) + u);
    let l = 0;
    return c[l++] = qO, f ? c[l++] = u : (c[l++] = nm | 1, c[l++] = u & 255), c[l++] = im, c[l++] = s, i < 0 ? (c[l++] = 0, c.set(e.subarray(0, r), l), l += r) : (c.set(e.subarray(i, r), l), l += r - i), c[l++] = im, c[l++] = a, o < 0 ? (c[l++] = 0, c.set(e.subarray(r), l)) : c.set(e.subarray(r + o), l), c;
}
nd.joseToDer = nJ;
var cc = {};
Object.defineProperty(cc, "__esModule", {
    value: !0
});
cc.InvalidTokenError = cc.MissingParametersError = void 0;
class iJ extends Error {
    constructor(t){
        super(), this.name = "MissingParametersError", this.message = t || "";
    }
}
cc.MissingParametersError = iJ;
class oJ extends Error {
    constructor(t){
        super(), this.name = "InvalidTokenError", this.message = t || "";
    }
}
cc.InvalidTokenError = oJ;
Object.defineProperty(vb, "__esModule", {
    value: !0
});
vb.SECP256K1Client = void 0;
const sJ = Qp, aJ = us, By = rO, JT = nd, QT = cc, ek = Hr;
By.utils.hmacSha256Sync = (e, ...t)=>{
    const r = sJ.hmac.create(aJ.sha256, e);
    return t.forEach((n)=>r.update(n)), r.digest();
};
class WO {
    static derivePublicKey(t, r = !0) {
        return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, ek.bytesToHex)(By.getPublicKey(t, r));
    }
    static signHash(t, r, n = "jose") {
        if (!t || !r) throw new QT.MissingParametersError("a signing input hash and private key are all required");
        const i = By.signSync(t, r.slice(0, 64), {
            der: !0,
            canonical: !1
        });
        if (n === "der") return (0, ek.bytesToHex)(i);
        if (n === "jose") return (0, JT.derToJose)(i, "ES256");
        throw Error("Invalid signature format");
    }
    static loadSignature(t) {
        return (0, JT.joseToDer)(t, "ES256");
    }
    static verifyHash(t, r, n) {
        if (!t || !r || !n) throw new QT.MissingParametersError("a signing input hash, der signature, and public key are all required");
        return By.verify(r, t, n, {
            strict: !1
        });
    }
}
vb.SECP256K1Client = WO;
WO.algorithmName = "ES256K";
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.cryptoClients = e.SECP256K1Client = void 0;
    const t = vb;
    Object.defineProperty(e, "SECP256K1Client", {
        enumerable: !0,
        get: function() {
            return t.SECP256K1Client;
        }
    });
    const r = {
        ES256K: t.SECP256K1Client
    };
    e.cryptoClients = r;
})(wb);
var wf = {}, cJ = Ge && Ge.__awaiter || function(e, t, r, n) {
    function i(o) {
        return o instanceof r ? o : new r(function(s) {
            s(o);
        });
    }
    return new (r || (r = Promise))(function(o, s) {
        function a(c) {
            try {
                f(n.next(c));
            } catch (l) {
                s(l);
            }
        }
        function u(c) {
            try {
                f(n.throw(c));
            } catch (l) {
                s(l);
            }
        }
        function f(c) {
            c.done ? o(c.value) : i(c.value).then(a, u);
        }
        f((n = n.apply(e, t || [])).next());
    });
};
Object.defineProperty(wf, "__esModule", {
    value: !0
});
wf.hashSha256Async = wf.hashSha256 = void 0;
const uJ = us;
function VO(e) {
    return (0, uJ.sha256)(e);
}
wf.hashSha256 = VO;
function fJ(e) {
    return cJ(this, void 0, void 0, function*() {
        try {
            if (typeof crypto < "u" && typeof crypto.subtle < "u") {
                const r = typeof e == "string" ? new TextEncoder().encode(e) : e, n = yield crypto.subtle.digest("SHA-256", r);
                return new Uint8Array(n);
            } else {
                const r = q3();
                if (!r.createHash) throw new Error("`crypto` module does not contain `createHash`");
                return Promise.resolve(r.createHash("sha256").update(e).digest());
            }
        } catch (t) {
            return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(VO(e));
        }
    });
}
wf.hashSha256Async = fJ;
var lJ = Ge && Ge.__awaiter || function(e, t, r, n) {
    function i(o) {
        return o instanceof r ? o : new r(function(s) {
            s(o);
        });
    }
    return new (r || (r = Promise))(function(o, s) {
        function a(c) {
            try {
                f(n.next(c));
            } catch (l) {
                s(l);
            }
        }
        function u(c) {
            try {
                f(n.throw(c));
            } catch (l) {
                s(l);
            }
        }
        function f(c) {
            c.done ? o(c.value) : i(c.value).then(a, u);
        }
        f((n = n.apply(e, t || [])).next());
    });
};
Object.defineProperty(td, "__esModule", {
    value: !0
});
td.TokenSigner = td.createUnsecuredToken = void 0;
const LE = ji, tk = wb, dJ = cc, rk = wf;
function DE(e, t) {
    const r = [], n = LE.encode(JSON.stringify(t));
    r.push(n);
    const i = LE.encode(JSON.stringify(e));
    return r.push(i), r.join(".");
}
function hJ(e) {
    return DE(e, {
        typ: "JWT",
        alg: "none"
    }) + ".";
}
td.createUnsecuredToken = hJ;
class pJ {
    constructor(t, r){
        if (!(t && r)) throw new dJ.MissingParametersError("a signing algorithm and private key are required");
        if (typeof t != "string") throw new Error("signing algorithm parameter must be a string");
        if (t = t.toUpperCase(), !tk.cryptoClients.hasOwnProperty(t)) throw new Error("invalid signing algorithm");
        this.tokenType = "JWT", this.cryptoClient = tk.cryptoClients[t], this.rawPrivateKey = r;
    }
    header(t = {}) {
        const r = {
            typ: this.tokenType,
            alg: this.cryptoClient.algorithmName
        };
        return Object.assign({}, r, t);
    }
    sign(t, r = !1, n = {}) {
        const i = this.header(n), o = DE(t, i), s = (0, rk.hashSha256)(o);
        return this.createWithSignedHash(t, r, i, o, s);
    }
    signAsync(t, r = !1, n = {}) {
        return lJ(this, void 0, void 0, function*() {
            const i = this.header(n), o = DE(t, i), s = yield (0, rk.hashSha256Async)(o);
            return this.createWithSignedHash(t, r, i, o, s);
        });
    }
    createWithSignedHash(t, r, n, i, o) {
        const s = this.cryptoClient.signHash(o, this.rawPrivateKey);
        return r ? {
            header: [
                LE.encode(JSON.stringify(n))
            ],
            payload: JSON.stringify(t),
            signature: [
                s
            ]
        } : [
            i,
            s
        ].join(".");
    }
}
td.TokenSigner = pJ;
var Ib = {};
Object.defineProperty(Ib, "__esModule", {
    value: !0
});
Ib.TokenVerifier = void 0;
const gJ = ji, nk = wb, yJ = cc, Vg = wf;
class mJ {
    constructor(t, r){
        if (!(t && r)) throw new yJ.MissingParametersError("a signing algorithm and public key are required");
        if (typeof t != "string") throw "signing algorithm parameter must be a string";
        if (t = t.toUpperCase(), !nk.cryptoClients.hasOwnProperty(t)) throw "invalid signing algorithm";
        this.tokenType = "JWT", this.cryptoClient = nk.cryptoClients[t], this.rawPublicKey = r;
    }
    verify(t) {
        return typeof t == "string" ? this.verifyCompact(t, !1) : typeof t == "object" ? this.verifyExpanded(t, !1) : !1;
    }
    verifyAsync(t) {
        return typeof t == "string" ? this.verifyCompact(t, !0) : typeof t == "object" ? this.verifyExpanded(t, !0) : Promise.resolve(!1);
    }
    verifyCompact(t, r) {
        const n = t.split("."), i = n[0] + "." + n[1], o = (s)=>{
            const a = this.cryptoClient.loadSignature(n[2]);
            return this.cryptoClient.verifyHash(s, a, this.rawPublicKey);
        };
        if (r) return (0, Vg.hashSha256Async)(i).then((s)=>o(s));
        {
            const s = (0, Vg.hashSha256)(i);
            return o(s);
        }
    }
    verifyExpanded(t, r) {
        const n = [
            t.header.join("."),
            gJ.encode(t.payload)
        ].join(".");
        let i = !0;
        const o = (s)=>(t.signature.map((a)=>{
                const u = this.cryptoClient.loadSignature(a);
                this.cryptoClient.verifyHash(s, u, this.rawPublicKey) || (i = !1);
            }), i);
        if (r) return (0, Vg.hashSha256Async)(n).then((s)=>o(s));
        {
            const s = (0, Vg.hashSha256)(n);
            return o(s);
        }
    }
}
Ib.TokenVerifier = mJ;
var Bb = {};
Object.defineProperty(Bb, "__esModule", {
    value: !0
});
Bb.decodeToken = void 0;
const Gg = ji;
function bJ(e) {
    if (typeof e == "string") {
        const t = e.split("."), r = JSON.parse(Gg.decode(t[0])), n = JSON.parse(Gg.decode(t[1])), i = t[2];
        return {
            header: r,
            payload: n,
            signature: i
        };
    } else if (typeof e == "object") {
        if (typeof e.payload != "string") throw new Error("Expected token payload to be a base64 or json string");
        let t = e.payload;
        e.payload[0] !== "{" && (t = Gg.decode(t));
        const r = [];
        return e.header.map((n)=>{
            const i = JSON.parse(Gg.decode(n));
            r.push(i);
        }), {
            header: r,
            payload: JSON.parse(t),
            signature: e.signature
        };
    }
}
Bb.decodeToken = bJ;
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(td, e), r(Ib, e), r(Bb, e), r(cc, e), r(wb, e);
})(Lo);
var c_;
function wJ(e) {
    return c_ == null ? void 0 : c_.get(e);
}
var u_;
function vJ(e) {
    return u_ == null ? void 0 : u_.get(e);
}
var f_;
function _J(e, t) {
    var r;
    return (r = f_ == null ? void 0 : f_.get(e)) == null ? void 0 : r.get(t);
}
function Ob(e) {
    var r, n;
    const t = typeof e;
    return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function Jn(e, t, r, n, i) {
    const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? Ob(o), u = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: s,
        received: a,
        message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
        requirement: e.requirement,
        path: i == null ? void 0 : i.path,
        issues: i == null ? void 0 : i.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, f = e.kind === "schema", c = (i == null ? void 0 : i.message) ?? e.message ?? _J(e.reference, u.lang) ?? (f ? vJ(u.lang) : null) ?? n.message ?? wJ(u.lang);
    c && (u.message = typeof c == "function" ? // @ts-expect-error
    c(u) : c), f && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [
        u
    ];
}
function GO(e, t) {
    return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function Pb(e, t) {
    const r = [
        ...new Set(e)
    ];
    return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
function ZO(e, t) {
    return {
        kind: "validation",
        type: "check",
        reference: ZO,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement(r.value) && Jn(this, "input", r, n), r;
        }
    };
}
function YO(e, t) {
    return {
        kind: "validation",
        type: "max_length",
        reference: YO,
        async: !1,
        expects: `<=${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length > this.requirement && Jn(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function XO(e, t) {
    return {
        kind: "validation",
        type: "min_length",
        reference: XO,
        async: !1,
        expects: `>=${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length < this.requirement && Jn(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function JO(e, t, r) {
    return typeof e.default == "function" ? // @ts-expect-error
    e.default(t, r) : // @ts-expect-error
    e.default;
}
function ik(e, t) {
    return !e._run({
        typed: !1,
        value: t
    }, {
        abortEarly: !0
    }).issues;
}
function An(e, t) {
    return {
        kind: "schema",
        type: "array",
        reference: An,
        expects: "Array",
        async: !1,
        item: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (Array.isArray(i)) {
                r.typed = !0, r.value = [];
                for(let s = 0; s < i.length; s++){
                    const a = i[s], u = this.item._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "array",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), r.value.push(u.value);
                }
            } else Jn(this, "type", r, n);
            return r;
        }
    };
}
function Uf(e) {
    return {
        kind: "schema",
        type: "boolean",
        reference: Uf,
        expects: "boolean",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "boolean" ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function go(e, t) {
    const r = Object.entries(e).filter(([n])=>isNaN(+n)).map(([, n])=>n);
    return {
        kind: "schema",
        type: "enum",
        reference: go,
        expects: Pb(r.map(Ob), "|"),
        async: !1,
        enum: e,
        options: r,
        message: t,
        _run (n, i) {
            return this.options.includes(n.value) ? n.typed = !0 : Jn(this, "type", n, i), n;
        }
    };
}
function or(e, t) {
    return {
        kind: "schema",
        type: "literal",
        reference: or,
        expects: Ob(e),
        async: !1,
        literal: e,
        message: t,
        _run (r, n) {
            return r.value === this.literal ? r.typed = !0 : Jn(this, "type", r, n), r;
        }
    };
}
function QO(e, t) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: QO,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
                if (!r.issues || !n.abortEarly) for(const s in i)GO(i, s) && !(s in this.entries) && (r.value[s] = i[s]);
            } else Jn(this, "type", r, n);
            return r;
        }
    };
}
function K3(e, t) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: K3,
        expects: "!undefined",
        async: !1,
        wrapped: e,
        message: t,
        _run (r, n) {
            return r.value === void 0 ? (Jn(this, "type", r, n), r) : this.wrapped._run(r, n);
        }
    };
}
function $i(e) {
    return {
        kind: "schema",
        type: "null",
        reference: $i,
        expects: "null",
        async: !1,
        message: e,
        _run (t, r) {
            return t.value === null ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function ai(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullish",
        reference: ai,
        expects: `(${e.expects} | null | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return (n.value === null || n.value === void 0) && ("default" in this && (n.value = JO(this, n, i)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function zn(e) {
    return {
        kind: "schema",
        type: "number",
        reference: zn,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function ot(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: ot,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
            } else Jn(this, "type", r, n);
            return r;
        }
    };
}
function Yt(e, ...t) {
    const r = {
        kind: "schema",
        type: "optional",
        reference: Yt,
        expects: `(${e.expects} | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i) {
            return n.value === void 0 && ("default" in this && (n.value = JO(this, n, i)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function eP(e, t) {
    return {
        kind: "schema",
        type: "picklist",
        reference: eP,
        expects: Pb(e.map(Ob), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            return this.options.includes(r.value) ? r.typed = !0 : Jn(this, "type", r, n), r;
        }
    };
}
function tP(e, t, r) {
    return {
        kind: "schema",
        type: "record",
        reference: tP,
        expects: "Object",
        async: !1,
        key: e,
        value: t,
        message: r,
        _run (n, i) {
            var s, a;
            const o = n.value;
            if (o && typeof o == "object") {
                n.typed = !0, n.value = {};
                for(const u in o)if (GO(o, u)) {
                    const f = o[u], c = this.key._run({
                        typed: !1,
                        value: u
                    }, i);
                    if (c.issues) {
                        const p = {
                            type: "object",
                            origin: "key",
                            input: o,
                            key: u,
                            value: f
                        };
                        for (const y of c.issues)y.path = [
                            p
                        ], (s = n.issues) == null || s.push(y);
                        if (n.issues || (n.issues = c.issues), i.abortEarly) {
                            n.typed = !1;
                            break;
                        }
                    }
                    const l = this.value._run({
                        typed: !1,
                        value: f
                    }, i);
                    if (l.issues) {
                        const p = {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: u,
                            value: f
                        };
                        for (const y of l.issues)y.path ? y.path.unshift(p) : y.path = [
                            p
                        ], (a = n.issues) == null || a.push(y);
                        if (n.issues || (n.issues = l.issues), i.abortEarly) {
                            n.typed = !1;
                            break;
                        }
                    }
                    (!c.typed || !l.typed) && (n.typed = !1), c.typed && (n.value[c.value] = l.value);
                }
            } else Jn(this, "type", n, i);
            return n;
        }
    };
}
function nt(e) {
    return {
        kind: "schema",
        type: "string",
        reference: nt,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : Jn(this, "type", t, r), t;
        }
    };
}
function ok(e) {
    let t;
    if (e) for (const r of e)t ? t.push(...r.issues) : t = r.issues;
    return t;
}
function $f(e, t) {
    return {
        kind: "schema",
        type: "union",
        reference: $f,
        expects: Pb(e.map((r)=>r.expects), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            let i, o, s;
            for (const a of this.options){
                const u = a._run({
                    typed: !1,
                    value: r.value
                }, n);
                if (u.typed) if (u.issues) o ? o.push(u) : o = [
                    u
                ];
                else {
                    i = u;
                    break;
                }
                else s ? s.push(u) : s = [
                    u
                ];
            }
            if (i) return i;
            if (o) {
                if (o.length === 1) return o[0];
                Jn(this, "type", r, n, {
                    issues: ok(o)
                }), r.typed = !0;
            } else {
                if ((s == null ? void 0 : s.length) === 1) return s[0];
                Jn(this, "type", r, n, {
                    issues: ok(s)
                });
            }
            return r;
        }
    };
}
function Nb() {
    return {
        kind: "schema",
        type: "unknown",
        reference: Nb,
        expects: "unknown",
        async: !1,
        _run (e) {
            return e.typed = !0, e;
        }
    };
}
function rP(e, t, r) {
    return {
        kind: "schema",
        type: "variant",
        reference: rP,
        expects: "Object",
        async: !1,
        key: e,
        options: t,
        message: r,
        _run (n, i) {
            const o = n.value;
            if (o && typeof o == "object") {
                let s, a = 0, u = this.key, f = [];
                const c = (l, p)=>{
                    for (const y of l.options){
                        if (y.type === "variant") c(y, new Set(p).add(y.key));
                        else {
                            let _ = !0, A = 0;
                            for (const O of p){
                                if (y.entries[O]._run(// @ts-expect-error
                                {
                                    typed: !1,
                                    value: o[O]
                                }, i).issues) {
                                    _ = !1, u !== O && (a < A || a === A && O in o && !(u in o)) && (a = A, u = O, f = []), u === O && f.push(y.entries[O].expects);
                                    break;
                                }
                                A++;
                            }
                            if (_) {
                                const O = y._run({
                                    typed: !1,
                                    value: o
                                }, i);
                                (!s || !s.typed && O.typed) && (s = O);
                            }
                        }
                        if (s && !s.issues) break;
                    }
                };
                if (c(this, /* @__PURE__ */ new Set([
                    this.key
                ])), s) return s;
                Jn(this, "type", n, i, {
                    // @ts-expect-error
                    input: o[u],
                    expected: Pb(f, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: u,
                            // @ts-expect-error
                            value: o[u]
                        }
                    ]
                });
            } else Jn(this, "type", n, i);
            return n;
        }
    };
}
function sk(e, t) {
    const r = {
        ...e.entries
    };
    for (const n of t)delete r[n];
    return {
        ...e,
        entries: r
    };
}
function FE(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
function EJ(e) {
    return e.wrapped;
}
const xJ = globalThis || void 0 || self;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var ak = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(()=>{
    const e = Array(256).fill(-1);
    for(let t = 0; t < ak.length; ++t)e[ak.charCodeAt(t)] = t;
})();
var ck, l_, Zg, W3 = (ck = function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.bech32m = t.bech32 = void 0;
    const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
    for(let l = 0; l < 32; l++){
        const p = r.charAt(l);
        n[p] = l;
    }
    function i(l) {
        const p = l >> 25;
        return (33554431 & l) << 5 ^ 996825010 & -(p >> 0 & 1) ^ 642813549 & -(p >> 1 & 1) ^ 513874426 & -(p >> 2 & 1) ^ 1027748829 & -(p >> 3 & 1) ^ 705979059 & -(p >> 4 & 1);
    }
    function o(l) {
        let p = 1;
        for(let y = 0; y < l.length; ++y){
            const _ = l.charCodeAt(y);
            if (_ < 33 || _ > 126) return "Invalid prefix (" + l + ")";
            p = i(p) ^ _ >> 5;
        }
        p = i(p);
        for(let y = 0; y < l.length; ++y){
            const _ = l.charCodeAt(y);
            p = i(p) ^ 31 & _;
        }
        return p;
    }
    function s(l, p, y, _) {
        let A = 0, O = 0;
        const N = (1 << y) - 1, U = [];
        for(let D = 0; D < l.length; ++D)for(A = A << p | l[D], O += p; O >= y;)O -= y, U.push(A >> O & N);
        if (_) O > 0 && U.push(A << y - O & N);
        else {
            if (O >= p) return "Excess padding";
            if (A << y - O & N) return "Non-zero padding";
        }
        return U;
    }
    function a(l) {
        return s(l, 8, 5, !0);
    }
    function u(l) {
        const p = s(l, 5, 8, !1);
        if (Array.isArray(p)) return p;
    }
    function f(l) {
        const p = s(l, 5, 8, !1);
        if (Array.isArray(p)) return p;
        throw new Error(p);
    }
    function c(l) {
        let p;
        function y(_, A) {
            if (A = A || 90, _.length < 8) return _ + " too short";
            if (_.length > A) return "Exceeds length limit";
            const O = _.toLowerCase(), N = _.toUpperCase();
            if (_ !== O && _ !== N) return "Mixed-case string " + _;
            const U = (_ = O).lastIndexOf("1");
            if (U === -1) return "No separator character for " + _;
            if (U === 0) return "Missing prefix for " + _;
            const D = _.slice(0, U), H = _.slice(U + 1);
            if (H.length < 6) return "Data too short";
            let K = o(D);
            if (typeof K == "string") return K;
            const re = [];
            for(let Q = 0; Q < H.length; ++Q){
                const G = H.charAt(Q), R = n[G];
                if (R === void 0) return "Unknown character " + G;
                K = i(K) ^ R, Q + 6 >= H.length || re.push(R);
            }
            return K !== p ? "Invalid checksum for " + _ : {
                prefix: D,
                words: re
            };
        }
        return p = l === "bech32" ? 1 : 734539939, {
            decodeUnsafe: function(_, A) {
                const O = y(_, A);
                if (typeof O == "object") return O;
            },
            decode: function(_, A) {
                const O = y(_, A);
                if (typeof O == "object") return O;
                throw new Error(O);
            },
            encode: function(_, A, O) {
                if (O = O || 90, _.length + 7 + A.length > O) throw new TypeError("Exceeds length limit");
                let N = o(_ = _.toLowerCase());
                if (typeof N == "string") throw new Error(N);
                let U = _ + "1";
                for(let D = 0; D < A.length; ++D){
                    const H = A[D];
                    if (H >> 5) throw new Error("Non 5-bit word");
                    N = i(N) ^ H, U += r.charAt(H);
                }
                for(let D = 0; D < 6; ++D)N = i(N);
                N ^= p;
                for(let D = 0; D < 6; ++D)U += r.charAt(N >> 5 * (5 - D) & 31);
                return U;
            },
            toWords: a,
            fromWordsUnsafe: u,
            fromWords: f
        };
    }
    t.bech32 = c("bech32"), t.bech32m = c("bech32m");
}, ck(l_ = {
    exports: {}
}, l_.exports), l_.exports);
(Zg = W3) && Zg.__esModule && Object.prototype.hasOwnProperty.call(Zg, "default") && Zg.default;
W3.bech32m;
W3.bech32;
new Uint8Array(new Uint16Array([
    65279
]).buffer)[0];
var Cl, Ul;
(function(e) {
    e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Cl || (Cl = {})), function(e) {
    e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Ul || (Ul = {}));
Ul.p2pkh, Cl.mainnet, Ul.p2pkh, Cl.testnet, Ul.p2sh, Cl.mainnet, Ul.p2sh, Cl.testnet;
var SJ = [
    "software",
    "ledger",
    "keystone"
], nP = eP(SJ), vf = /* @__PURE__ */ ((e)=>(e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(vf || {}), iP = /* @__PURE__ */ ((e)=>(e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(iP || {}), oP = ot({
    address: nt(),
    publicKey: nt(),
    purpose: go(vf),
    addressType: go(iP),
    walletType: nP
}), AJ = async (e)=>{
    var n, i;
    const t = await Mb(e.getProvider), { purposes: r } = e.payload;
    if (!r) throw new Error("Address purposes are required");
    try {
        const o = Lo.createUnsecuredToken(e.payload), s = await t.connect(o);
        (n = e.onFinish) == null || n.call(e, s);
    } catch (o) {
        console.error("[Connect] Error during address request", o), (i = e.onCancel) == null || i.call(e);
    }
}, Mn = /* @__PURE__ */ ((e)=>(e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Testnet4 = "Testnet4", e.Signet = "Signet", e.Regtest = "Regtest", e))(Mn || {}), V3 = Yt($f([
    nt(),
    zn(),
    $i()
])), Gr = ot({
    jsonrpc: or("2.0"),
    method: nt(),
    params: Yt($f([
        An(Nb()),
        QO({}),
        // Note: This is to support current incorrect usage of RPC 2.0. Params need
        // to be either an array or an object when provided. Changing this now would
        // be a breaking change, so accepting null values for now. Tracking in
        // https://linear.app/xverseapp/issue/ENG-4538.
        $i()
    ])),
    id: EJ(V3)
}), kh = /* @__PURE__ */ ((e)=>(e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(kh || {}), sP = ot({
    jsonrpc: or("2.0"),
    result: K3(Nb()),
    id: V3
}), aP = ot({
    jsonrpc: or("2.0"),
    error: K3(Nb()),
    id: V3
});
$f([
    sP,
    aP
]);
var TJ = "accountChange";
ot({
    type: or(TJ),
    addresses: Yt(An(oP))
});
var kJ = "networkChange";
ot({
    type: or(kJ),
    bitcoin: ot({
        name: go(Mn)
    }),
    stacks: ot({
        name: nt()
    })
});
var IJ = "disconnect";
ot({
    type: or(IJ)
});
async function Mb(e) {
    var r;
    const t = await (e == null ? void 0 : e()) || ((r = window.XverseProviders) == null ? void 0 : r.BitcoinProvider) || window.BitcoinProvider;
    if (!t) throw new Error("No Bitcoin wallet installed");
    return t;
}
var BJ = "stx_callContract", OJ = ot({
    /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */ contract: nt(),
    /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */ functionName: nt(),
    /**
   * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
   */ arguments: Yt(An(nt())),
    /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */ functionArgs: Yt(An(nt())),
    /**
   * The post conditions to apply to the contract call.
   */ postConditions: Yt(An(nt())),
    /**
   * The mode to apply to the post conditions.
   */ postConditionMode: Yt($f([
        or("allow"),
        or("deny")
    ]))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(BJ),
        params: OJ,
        id: nt()
    }).entries
});
var PJ = "stx_deployContract", NJ = ot({
    /**
   * Name of the contract.
   */ name: nt(),
    /**
   * The source code of the Clarity contract.
   */ clarityCode: nt(),
    /**
   * The version of the Clarity contract.
   */ clarityVersion: Yt(nt()),
    /**
   * The post conditions to apply to the contract call.
   */ postConditions: Yt(An(nt())),
    /**
   * The mode to apply to the post conditions.
   */ postConditionMode: Yt($f([
        or("allow"),
        or("deny")
    ]))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(PJ),
        params: NJ,
        id: nt()
    }).entries
});
var MJ = ot({
    read: Yt(Uf())
}), RJ = ot({
    readNetwork: Yt(Uf())
}), CJ = ot({
    type: or("account"),
    resourceId: nt(),
    clientId: nt(),
    actions: MJ
}), UJ = ot({
    type: or("wallet"),
    resourceId: nt(),
    clientId: nt(),
    actions: RJ
}), cP = rP("type", [
    ot({
        ...sk(CJ, [
            "clientId"
        ]).entries
    }),
    ot({
        ...sk(UJ, [
            "clientId"
        ]).entries
    })
]), $J = "wallet_requestPermissions", LJ = ai(An(cP));
or(!0);
ot({
    ...Gr.entries,
    ...ot({
        method: or($J),
        params: LJ,
        id: nt()
    }).entries
});
var DJ = "wallet_renouncePermissions", FJ = ai($i());
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(DJ),
        params: FJ,
        id: nt()
    }).entries
});
var zJ = "wallet_disconnect", jJ = ai($i());
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(zJ),
        params: jJ,
        id: nt()
    }).entries
});
var HJ = "wallet_getWalletType", qJ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(HJ),
        params: qJ,
        id: nt()
    }).entries
});
var KJ = "wallet_getCurrentPermissions", WJ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(KJ),
        params: WJ,
        id: nt()
    }).entries
});
var VJ = "wallet_getNetwork", GJ = ai($i());
ot({
    bitcoin: ot({
        name: go(Mn)
    }),
    stacks: ot({
        name: nt()
    })
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(VJ),
        params: GJ,
        id: nt()
    }).entries
});
var ZJ = "wallet_changeNetwork", YJ = ot({
    name: go(Mn)
});
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(ZJ),
        params: YJ,
        id: nt()
    }).entries
});
var XJ = "wallet_getAccount", JJ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(XJ),
        params: JJ,
        id: nt()
    }).entries
});
var QJ = "wallet_connect", eQ = ai(ot({
    permissions: Yt(An(cP)),
    addresses: Yt(An(go(vf))),
    message: Yt(FE(nt(), YO(80, "The message must not exceed 80 characters."))),
    network: Yt(go(Mn))
}));
ot({
    ...Gr.entries,
    ...ot({
        method: or(QJ),
        params: eQ,
        id: nt()
    }).entries
});
var tQ = "stx_getAccounts", rQ = ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(tQ),
        params: rQ,
        id: nt()
    }).entries
});
var nQ = "stx_getAddresses", iQ = ai(ot({
    /**
     * A message to be displayed to the user in the request prompt.
     */ message: Yt(nt())
}));
ot({
    ...Gr.entries,
    ...ot({
        method: or(nQ),
        params: iQ,
        id: nt()
    }).entries
});
var oQ = "stx_signMessage", sQ = ot({
    /**
   * The message to sign.
   */ message: nt()
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(oQ),
        params: sQ,
        id: nt()
    }).entries
});
var aQ = "stx_signStructuredMessage", cQ = ot({
    /**
   * The domain to be signed.
   */ domain: nt(),
    /**
   * Message payload to be signed.
   */ message: nt(),
    /**
   * The public key to sign the message with.
   */ publicKey: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(aQ),
        params: cQ,
        id: nt()
    }).entries
});
var uQ = "stx_signTransaction", fQ = ot({
    /**
   * The transaction to sign as a hex-encoded string.
   */ transaction: nt(),
    /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */ pubkey: Yt(nt()),
    /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */ broadcast: Yt(Uf())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(uQ),
        params: fQ,
        id: nt()
    }).entries
});
var lQ = "stx_signTransactions", dQ = ot({
    /**
   * The transactions to sign as hex-encoded strings.
   */ transactions: FE(An(FE(nt(), ZO((e)=>!0, "Invalid hex-encoded Stacks transaction."))), XO(1)),
    /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */ broadcast: Yt(Uf())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(lQ),
        params: dQ,
        id: nt()
    }).entries
});
var hQ = "stx_transferStx", pQ = ot({
    /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */ amount: $f([
        zn(),
        nt()
    ]),
    /**
   * The recipeint's principal.
   */ recipient: nt(),
    /**
   * A string representing the memo.
   */ memo: Yt(nt()),
    /**
   * Version of parameter format.
   */ version: Yt(nt()),
    /**
   * The mode of the post conditions.
   */ postConditionMode: Yt(zn()),
    /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */ postConditions: Yt(An(nt())),
    /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */ pubkey: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(hQ),
        params: pQ,
        id: nt()
    }).entries
});
var gQ = "getInfo", yQ = ai($i());
ot({
    /**
   * Version of the wallet.
   */ version: nt(),
    /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */ methods: Yt(An(nt())),
    /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */ supports: An(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(gQ),
        params: yQ,
        id: nt()
    }).entries
});
var mQ = "getAddresses", bQ = ot({
    /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */ purposes: An(go(vf)),
    /**
   * A message to be displayed to the user in the request prompt.
   */ message: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(mQ),
        params: bQ,
        id: nt()
    }).entries
});
var wQ = "signMessage", _f = /* @__PURE__ */ ((e)=>(e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(_f || {}), vQ = ot({
    /**
   * The address used for signing.
   **/ address: nt(),
    /**
   * The message to sign.
   **/ message: nt(),
    /**
   * The protocol to use for signing the message.
   */ protocol: Yt(go(_f))
});
ot({
    /**
   * The signature of the message.
   */ signature: nt(),
    /**
   * hash of the message.
   */ messageHash: nt(),
    /**
   * The address used for signing.
   */ address: nt(),
    /**
   * The protocol to use for signing the message.
   */ protocol: go(_f)
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(wQ),
        params: vQ,
        id: nt()
    }).entries
});
var _Q = "sendTransfer", EQ = ot({
    /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */ recipients: An(ot({
        address: nt(),
        amount: zn()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(_Q),
        params: EQ,
        id: nt()
    }).entries
});
var xQ = "signPsbt", SQ = ot({
    /**
   * The base64 encoded PSBT to sign.
   */ psbt: nt(),
    /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */ signInputs: tP(nt(), An(zn())),
    /**
   * Whether to broadcast the transaction after signing.
   **/ broadcast: Yt(Uf())
});
ot({
    /**
   * The base64 encoded PSBT after signing.
   */ psbt: nt(),
    /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/ txid: Yt(nt())
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(xQ),
        params: SQ,
        id: nt()
    }).entries
});
var AQ = "getAccounts", TQ = ot({
    /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */ purposes: An(go(vf)),
    /**
   * A message to be displayed to the user in the request prompt.
   */ message: Yt(nt())
});
An(ot({
    ...oP.entries,
    ...ot({
        walletType: nP
    }).entries
}));
ot({
    ...Gr.entries,
    ...ot({
        method: or(AQ),
        params: TQ,
        id: nt()
    }).entries
});
var kQ = "getBalance";
ai($i());
ot({
    ...Gr.entries,
    ...ot({
        method: or(kQ),
        id: nt()
    }).entries
});
var IQ = "runes_etch", BQ = ot({
    amount: nt(),
    cap: nt(),
    heightStart: Yt(nt()),
    heightEnd: Yt(nt()),
    offsetStart: Yt(nt()),
    offsetEnd: Yt(nt())
}), OQ = ot({
    contentType: nt(),
    contentBase64: nt()
}), PQ = ot({
    runeName: nt(),
    divisibility: Yt(zn()),
    symbol: Yt(nt()),
    premine: Yt(nt()),
    isMintable: Uf(),
    delegateInscriptionId: Yt(nt()),
    destinationAddress: nt(),
    refundAddress: nt(),
    feeRate: zn(),
    appServiceFee: Yt(zn()),
    appServiceFeeAddress: Yt(nt()),
    terms: Yt(BQ),
    inscriptionDetails: Yt(OQ),
    network: Yt(go(Mn))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(IQ),
        params: PQ,
        id: nt()
    }).entries
});
var NQ = "runes_getBalance", MQ = ai($i());
ot({
    balances: An(ot({
        runeName: nt(),
        amount: nt(),
        divisibility: zn(),
        symbol: nt(),
        inscriptionId: ai(nt()),
        spendableBalance: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(NQ),
        params: MQ,
        id: nt()
    }).entries
});
var RQ = "runes_mint", CQ = ot({
    appServiceFee: Yt(zn()),
    appServiceFeeAddress: Yt(nt()),
    destinationAddress: nt(),
    feeRate: zn(),
    refundAddress: nt(),
    repeats: zn(),
    runeName: nt(),
    network: Yt(go(Mn))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(RQ),
        params: CQ,
        id: nt()
    }).entries
});
var UQ = "runes_transfer", $Q = ot({
    recipients: An(ot({
        runeName: nt(),
        amount: nt(),
        address: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(UQ),
        params: $Q,
        id: nt()
    }).entries
});
var LQ = "ord_getInscriptions", DQ = ot({
    offset: zn(),
    limit: zn()
});
ot({
    total: zn(),
    limit: zn(),
    offset: zn(),
    inscriptions: An(ot({
        inscriptionId: nt(),
        inscriptionNumber: nt(),
        address: nt(),
        collectionName: Yt(nt()),
        postage: nt(),
        contentLength: nt(),
        contentType: nt(),
        timestamp: zn(),
        offset: zn(),
        genesisTransaction: nt(),
        output: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(LQ),
        params: DQ,
        id: nt()
    }).entries
});
var FQ = "ord_sendInscriptions", zQ = ot({
    transfers: An(ot({
        address: nt(),
        inscriptionId: nt()
    }))
});
ot({
    ...Gr.entries,
    ...ot({
        method: or(FQ),
        params: zQ,
        id: nt()
    }).entries
});
var Wu = async (e, t, r)=>{
    var o;
    let n = ((o = window.XverseProviders) == null ? void 0 : o.BitcoinProvider) || window.BitcoinProvider;
    if (!n) throw new Error("no wallet provider was found");
    if (!e) throw new Error("A wallet method is required");
    const i = await n.request(e, t);
    return ik(aP, i) ? {
        status: "error",
        error: i.error
    } : ik(sP, i) ? {
        status: "success",
        result: i.result
    } : {
        status: "error",
        error: {
            code: -32603,
            message: "Received unknown response from provider.",
            data: i
        }
    };
}, uk = (e, t, r)=>{
    var i;
    let n = ((i = window.XverseProviders) == null ? void 0 : i.BitcoinProvider) || window.BitcoinProvider;
    if (!n) throw new Error("no wallet provider was found");
    return n.addListener ? n.addListener(e, t) : (console.error("The wallet provider you are using does not support the addListener method. Please update your wallet provider."), ()=>{});
}, jQ = async (e)=>{
    var i, o;
    const t = await Mb(e.getProvider), { address: r, message: n } = e.payload;
    if (!r) throw new Error("An address is required to sign a message");
    if (!n) throw new Error("A message to be signed is required");
    try {
        const s = Lo.createUnsecuredToken(e.payload), a = await t.signMessage(s);
        (i = e.onFinish) == null || i.call(e, a);
    } catch (s) {
        console.error("[Connect] Error during sign message request", s), (o = e.onCancel) == null || o.call(e);
    }
}, HQ = (e)=>e.map((t)=>{
        const { address: r, amountSats: n } = t;
        return {
            address: r,
            amountSats: n.toString()
        };
    }), qQ = async (e)=>{
    var s, a;
    const t = await Mb(e.getProvider), { recipients: r, senderAddress: n, network: i, message: o } = e.payload;
    if (!r || r.length === 0) throw new Error("At least one recipient is required");
    if (r.some((u)=>typeof u.address != "string" || typeof u.amountSats != "bigint")) throw new Error("Incorrect recipient format");
    if (!n) throw new Error("The sender address is required");
    try {
        const u = HQ(r), f = {
            network: i,
            senderAddress: n,
            message: o,
            recipients: u
        }, c = Lo.createUnsecuredToken(f), l = await t.sendBtcTransaction(c);
        (s = e.onFinish) == null || s.call(e, l);
    } catch (u) {
        console.error("[Connect] Error during send BTC transaction request", u), (a = e.onCancel) == null || a.call(e);
    }
}, KQ = async (e)=>{
    var i, o;
    const t = await Mb(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
    if (!r) throw new Error("A value for psbtBase64 representing the tx hash is required");
    if (!n) throw new Error("An array specifying the inputs to be signed by the wallet is required");
    try {
        const s = Lo.createUnsecuredToken(e.payload), a = await t.signTransaction(s);
        (i = e.onFinish) == null || i.call(e, a);
    } catch (s) {
        console.error("[Connect] Error during sign transaction request", s), (o = e.onCancel) == null || o.call(e);
    }
};
const ln = dt.MAINNET, Ro = dt.SIGNET, Ni = dt.TESTNET, ao = dt.TESTNET4, yc = dt.FRACTAL_MAINNET, co = dt.FRACTAL_TESTNET, lve = dt.REGTEST, uP = dt.OYLNET, d_ = (e)=>e === dt.MAINNET ? Mn.Mainnet : e === dt.TESTNET ? Mn.Testnet : e === dt.TESTNET4 ? Mn.Testnet4 : e === dt.SIGNET ? Mn.Signet : (e === dt.FRACTAL_MAINNET || e === dt.FRACTAL_TESTNET, Mn.Mainnet), dve = (e)=>e === dt.MAINNET ? Hl.MAINNET : e === dt.TESTNET ? Hl.TESTNET : Hl.MAINNET, fP = (e)=>e === dt.MAINNET ? ro.MAINNET : e === dt.TESTNET ? ro.TESTNET : e === dt.TESTNET4 ? ro.TESTNET4 : e === dt.SIGNET ? ro.SIGNET : e === dt.FRACTAL_MAINNET ? ro.FRACTAL_MAINNET : e === dt.FRACTAL_TESTNET ? ro.FRACTAL_TESTNET : ro.MAINNET, WQ = (e)=>e === dt.MAINNET ? cu.BITCOIN_MAINNET : e === dt.TESTNET ? cu.BITCOIN_TESTNET : e === dt.SIGNET ? cu.BITCOIN_SIGNET : cu.BITCOIN_MAINNET, hve = (e)=>e === dt.MAINNET ? ko.MAINNET : e === dt.TESTNET ? ko.TESTNET : e === dt.TESTNET4 ? ko.TESTNET4 : e === dt.SIGNET ? ko.SIGNET : e === dt.FRACTAL_TESTNET ? ko.TESTNET : (e === dt.FRACTAL_MAINNET, ko.MAINNET), h_ = (e)=>e === dt.MAINNET ? eu.MAINNET : e === dt.TESTNET || e === dt.TESTNET4 || e === dt.SIGNET ? eu.TESTNET : (e === dt.FRACTAL_MAINNET || e === dt.FRACTAL_TESTNET, eu.MAINNET), VQ = (e)=>e === dt.MAINNET ? Qc.MAINNET : e === dt.TESTNET4 || e === dt.TESTNET ? Qc.TESTNET : e === dt.SIGNET ? Qc.SIGNET : (e === dt.MAINNET || e === dt.TESTNET, Qc.MAINNET), om = (e)=>e === ro.MAINNET ? dt.MAINNET : e === ro.TESTNET ? dt.TESTNET : e === ro.TESTNET4 ? dt.TESTNET4 : e === ro.SIGNET ? dt.SIGNET : e === ro.FRACTAL_MAINNET ? dt.FRACTAL_MAINNET : e === ro.FRACTAL_TESTNET ? dt.TESTNET : dt.MAINNET, GQ = (e)=>e === cu.BITCOIN_MAINNET ? dt.MAINNET : e === cu.BITCOIN_TESTNET ? dt.TESTNET : e === cu.BITCOIN_SIGNET ? dt.SIGNET : dt.MAINNET, p_ = (e)=>e === Yu.MAINNET ? dt.MAINNET : e === Yu.TESTNET ? dt.TESTNET : e === Yu.TESTNET4 ? dt.TESTNET4 : e === Yu.SIGNET ? dt.SIGNET : e === Yu.FRACTAL_MAINNET ? dt.FRACTAL_MAINNET : e === Yu.FRACTAL_TESTNET ? dt.FRACTAL_TESTNET : dt.MAINNET, pve = (e)=>e === Hl.MAINNET ? dt.MAINNET : e === Hl.TESTNET ? dt.TESTNET : dt.MAINNET, ZQ = (e)=>e === RE.MAINNET ? dt.MAINNET : e === RE.TESTNET ? dt.TESTNET : dt.MAINNET, fk = (e)=>e === ko.MAINNET ? dt.MAINNET : e === ko.TESTNET ? dt.TESTNET : e === ko.TESTNET4 ? dt.TESTNET4 : e === ko.SIGNET ? dt.SIGNET : e === ME.TESTNET ? dt.TESTNET : (e === ME.MAINNET, dt.MAINNET);
function lP(e, t) {
    return function() {
        return e.apply(t, arguments);
    };
}
const { toString: YQ } = Object.prototype, { getPrototypeOf: G3 } = Object, { iterator: Rb, toStringTag: dP } = Symbol, Cb = /* @__PURE__ */ ((e)=>(t)=>{
        const r = YQ.call(t);
        return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null)), js = (e)=>(e = e.toLowerCase(), (t)=>Cb(t) === e), Ub = (e)=>(t)=>typeof t === e, { isArray: Bd } = Array, up = Ub("undefined");
function XQ(e) {
    return e !== null && !up(e) && e.constructor !== null && !up(e.constructor) && ho(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const hP = js("ArrayBuffer");
function JQ(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && hP(e.buffer), t;
}
const QQ = Ub("string"), ho = Ub("function"), pP = Ub("number"), $b = (e)=>e !== null && typeof e == "object", eee = (e)=>e === !0 || e === !1, Oy = (e)=>{
    if (Cb(e) !== "object") return !1;
    const t = G3(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(dP in e) && !(Rb in e);
}, tee = js("Date"), ree = js("File"), nee = js("Blob"), iee = js("FileList"), oee = (e)=>$b(e) && ho(e.pipe), see = (e)=>{
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || ho(e.append) && ((t = Cb(e)) === "formdata" || // detect form-data instance
    t === "object" && ho(e.toString) && e.toString() === "[object FormData]"));
}, aee = js("URLSearchParams"), [cee, uee, fee, lee] = [
    "ReadableStream",
    "Request",
    "Response",
    "Headers"
].map(js), dee = (e)=>e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function c0(e, t, { allOwnKeys: r = !1 } = {}) {
    if (e === null || typeof e > "u") return;
    let n, i;
    if (typeof e != "object" && (e = [
        e
    ]), Bd(e)) for(n = 0, i = e.length; n < i; n++)t.call(null, e[n], n, e);
    else {
        const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length;
        let a;
        for(n = 0; n < s; n++)a = o[n], t.call(null, e[a], a, e);
    }
}
function gP(e, t) {
    t = t.toLowerCase();
    const r = Object.keys(e);
    let n = r.length, i;
    for(; n-- > 0;)if (i = r[n], t === i.toLowerCase()) return i;
    return null;
}
const sf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : ("TURBOPACK compile-time value", "undefined") < "u" ? window : xJ, yP = (e)=>!up(e) && e !== sf;
function zE() {
    const { caseless: e } = yP(this) && this || {}, t = {}, r = (n, i)=>{
        const o = e && gP(t, i) || i;
        Oy(t[o]) && Oy(n) ? t[o] = zE(t[o], n) : Oy(n) ? t[o] = zE({}, n) : Bd(n) ? t[o] = n.slice() : t[o] = n;
    };
    for(let n = 0, i = arguments.length; n < i; n++)arguments[n] && c0(arguments[n], r);
    return t;
}
const hee = (e, t, r, { allOwnKeys: n } = {})=>(c0(t, (i, o)=>{
        r && ho(i) ? e[o] = lP(i, r) : e[o] = i;
    }, {
        allOwnKeys: n
    }), e), pee = (e)=>(e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), gee = (e, t, r, n)=>{
    e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
        value: t.prototype
    }), r && Object.assign(e.prototype, r);
}, yee = (e, t, r, n)=>{
    let i, o, s;
    const a = {};
    if (t = t || {}, e == null) return t;
    do {
        for(i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0;)s = i[o], (!n || n(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0);
        e = r !== !1 && G3(e);
    }while (e && (!r || r(e, t)) && e !== Object.prototype)
    return t;
}, mee = (e, t, r)=>{
    e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
    const n = e.indexOf(t, r);
    return n !== -1 && n === r;
}, bee = (e)=>{
    if (!e) return null;
    if (Bd(e)) return e;
    let t = e.length;
    if (!pP(t)) return null;
    const r = new Array(t);
    for(; t-- > 0;)r[t] = e[t];
    return r;
}, wee = /* @__PURE__ */ ((e)=>(t)=>e && t instanceof e)(typeof Uint8Array < "u" && G3(Uint8Array)), vee = (e, t)=>{
    const n = (e && e[Rb]).call(e);
    let i;
    for(; (i = n.next()) && !i.done;){
        const o = i.value;
        t.call(e, o[0], o[1]);
    }
}, _ee = (e, t)=>{
    let r;
    const n = [];
    for(; (r = e.exec(t)) !== null;)n.push(r);
    return n;
}, Eee = js("HTMLFormElement"), xee = (e)=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(r, n, i) {
        return n.toUpperCase() + i;
    }), lk = (({ hasOwnProperty: e })=>(t, r)=>e.call(t, r))(Object.prototype), See = js("RegExp"), mP = (e, t)=>{
    const r = Object.getOwnPropertyDescriptors(e), n = {};
    c0(r, (i, o)=>{
        let s;
        (s = t(i, o, e)) !== !1 && (n[o] = s || i);
    }), Object.defineProperties(e, n);
}, Aee = (e)=>{
    mP(e, (t, r)=>{
        if (ho(e) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(r) !== -1) return !1;
        const n = e[r];
        if (ho(n)) {
            if (t.enumerable = !1, "writable" in t) {
                t.writable = !1;
                return;
            }
            t.set || (t.set = ()=>{
                throw Error("Can not rewrite read-only method '" + r + "'");
            });
        }
    });
}, Tee = (e, t)=>{
    const r = {}, n = (i)=>{
        i.forEach((o)=>{
            r[o] = !0;
        });
    };
    return Bd(e) ? n(e) : n(String(e).split(t)), r;
}, kee = ()=>{}, Iee = (e, t)=>e != null && Number.isFinite(e = +e) ? e : t;
function Bee(e) {
    return !!(e && ho(e.append) && e[dP] === "FormData" && e[Rb]);
}
const Oee = (e)=>{
    const t = new Array(10), r = (n, i)=>{
        if ($b(n)) {
            if (t.indexOf(n) >= 0) return;
            if (!("toJSON" in n)) {
                t[i] = n;
                const o = Bd(n) ? [] : {};
                return c0(n, (s, a)=>{
                    const u = r(s, i + 1);
                    !up(u) && (o[a] = u);
                }), t[i] = void 0, o;
            }
        }
        return n;
    };
    return r(e, 0);
}, Pee = js("AsyncFunction"), Nee = (e)=>e && ($b(e) || ho(e)) && ho(e.then) && ho(e.catch), bP = ((e, t)=>e ? setImmediate : t ? ((r, n)=>(sf.addEventListener("message", ({ source: i, data: o })=>{
            i === sf && o === r && n.length && n.shift()();
        }, !1), (i)=>{
            n.push(i), sf.postMessage(r, "*");
        }))(`axios@${Math.random()}`, []) : (r)=>setTimeout(r))(typeof setImmediate == "function", ho(sf.postMessage)), Mee = typeof queueMicrotask < "u" ? queueMicrotask.bind(sf) : typeof bn < "u" && bn.nextTick || bP, Ree = (e)=>e != null && ho(e[Rb]), Je = {
    isArray: Bd,
    isArrayBuffer: hP,
    isBuffer: XQ,
    isFormData: see,
    isArrayBufferView: JQ,
    isString: QQ,
    isNumber: pP,
    isBoolean: eee,
    isObject: $b,
    isPlainObject: Oy,
    isReadableStream: cee,
    isRequest: uee,
    isResponse: fee,
    isHeaders: lee,
    isUndefined: up,
    isDate: tee,
    isFile: ree,
    isBlob: nee,
    isRegExp: See,
    isFunction: ho,
    isStream: oee,
    isURLSearchParams: aee,
    isTypedArray: wee,
    isFileList: iee,
    forEach: c0,
    merge: zE,
    extend: hee,
    trim: dee,
    stripBOM: pee,
    inherits: gee,
    toFlatObject: yee,
    kindOf: Cb,
    kindOfTest: js,
    endsWith: mee,
    toArray: bee,
    forEachEntry: vee,
    matchAll: _ee,
    isHTMLForm: Eee,
    hasOwnProperty: lk,
    hasOwnProp: lk,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: mP,
    freezeMethods: Aee,
    toObjectSet: Tee,
    toCamelCase: xee,
    noop: kee,
    toFiniteNumber: Iee,
    findKey: gP,
    global: sf,
    isContextDefined: yP,
    isSpecCompliantForm: Bee,
    toJSONObject: Oee,
    isAsyncFn: Pee,
    isThenable: Nee,
    setImmediate: bP,
    asap: Mee,
    isIterable: Ree
};
function dr(e, t, r, n, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Je.inherits(dr, Error, {
    toJSON: function() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: Je.toJSONObject(this.config),
            code: this.code,
            status: this.status
        };
    }
});
const wP = dr.prototype, vP = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((e)=>{
    vP[e] = {
        value: e
    };
});
Object.defineProperties(dr, vP);
Object.defineProperty(wP, "isAxiosError", {
    value: !0
});
dr.from = (e, t, r, n, i, o)=>{
    const s = Object.create(wP);
    return Je.toFlatObject(e, s, function(u) {
        return u !== Error.prototype;
    }, (a)=>a !== "isAxiosError"), dr.call(s, e.message, t, r, n, i), s.cause = e, s.name = e.name, o && Object.assign(s, o), s;
};
const Cee = null;
function jE(e) {
    return Je.isPlainObject(e) || Je.isArray(e);
}
function _P(e) {
    return Je.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function dk(e, t, r) {
    return e ? e.concat(t).map(function(i, o) {
        return i = _P(i), !r && o ? "[" + i + "]" : i;
    }).join(r ? "." : "") : t;
}
function Uee(e) {
    return Je.isArray(e) && !e.some(jE);
}
const $ee = Je.toFlatObject(Je, {}, null, function(t) {
    return /^is[A-Z]/.test(t);
});
function Lb(e, t, r) {
    if (!Je.isObject(e)) throw new TypeError("target must be an object");
    t = t || new FormData(), r = Je.toFlatObject(r, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(A, O) {
        return !Je.isUndefined(O[A]);
    });
    const n = r.metaTokens, i = r.visitor || c, o = r.dots, s = r.indexes, u = (r.Blob || typeof Blob < "u" && Blob) && Je.isSpecCompliantForm(t);
    if (!Je.isFunction(i)) throw new TypeError("visitor must be a function");
    function f(_) {
        if (_ === null) return "";
        if (Je.isDate(_)) return _.toISOString();
        if (Je.isBoolean(_)) return _.toString();
        if (!u && Je.isBlob(_)) throw new dr("Blob is not supported. Use a Buffer instead.");
        return Je.isArrayBuffer(_) || Je.isTypedArray(_) ? u && typeof Blob == "function" ? new Blob([
            _
        ]) : We.from(_) : _;
    }
    function c(_, A, O) {
        let N = _;
        if (_ && !O && typeof _ == "object") {
            if (Je.endsWith(A, "{}")) A = n ? A : A.slice(0, -2), _ = JSON.stringify(_);
            else if (Je.isArray(_) && Uee(_) || (Je.isFileList(_) || Je.endsWith(A, "[]")) && (N = Je.toArray(_))) return A = _P(A), N.forEach(function(D, H) {
                !(Je.isUndefined(D) || D === null) && t.append(// eslint-disable-next-line no-nested-ternary
                s === !0 ? dk([
                    A
                ], H, o) : s === null ? A : A + "[]", f(D));
            }), !1;
        }
        return jE(_) ? !0 : (t.append(dk(O, A, o), f(_)), !1);
    }
    const l = [], p = Object.assign($ee, {
        defaultVisitor: c,
        convertValue: f,
        isVisitable: jE
    });
    function y(_, A) {
        if (!Je.isUndefined(_)) {
            if (l.indexOf(_) !== -1) throw Error("Circular reference detected in " + A.join("."));
            l.push(_), Je.forEach(_, function(N, U) {
                (!(Je.isUndefined(N) || N === null) && i.call(t, N, Je.isString(U) ? U.trim() : U, A, p)) === !0 && y(N, A ? A.concat(U) : [
                    U
                ]);
            }), l.pop();
        }
    }
    if (!Je.isObject(e)) throw new TypeError("data must be an object");
    return y(e), t;
}
function hk(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
        return t[n];
    });
}
function Z3(e, t) {
    this._pairs = [], e && Lb(e, this, t);
}
const EP = Z3.prototype;
EP.append = function(t, r) {
    this._pairs.push([
        t,
        r
    ]);
};
EP.toString = function(t) {
    const r = t ? function(n) {
        return t.call(this, n, hk);
    } : hk;
    return this._pairs.map(function(i) {
        return r(i[0]) + "=" + r(i[1]);
    }, "").join("&");
};
function Lee(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function xP(e, t, r) {
    if (!t) return e;
    const n = r && r.encode || Lee;
    Je.isFunction(r) && (r = {
        serialize: r
    });
    const i = r && r.serialize;
    let o;
    if (i ? o = i(t, r) : o = Je.isURLSearchParams(t) ? t.toString() : new Z3(t, r).toString(n), o) {
        const s = e.indexOf("#");
        s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
    }
    return e;
}
class pk {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(t, r, n) {
        return this.handlers.push({
            fulfilled: t,
            rejected: r,
            synchronous: n ? n.synchronous : !1,
            runWhen: n ? n.runWhen : null
        }), this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(t) {
        this.handlers[t] && (this.handlers[t] = null);
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        this.handlers && (this.handlers = []);
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(t) {
        Je.forEach(this.handlers, function(n) {
            n !== null && t(n);
        });
    }
}
const SP = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}, Dee = typeof URLSearchParams < "u" ? URLSearchParams : Z3, Fee = typeof FormData < "u" ? FormData : null, zee = typeof Blob < "u" ? Blob : null, jee = {
    isBrowser: !0,
    classes: {
        URLSearchParams: Dee,
        FormData: Fee,
        Blob: zee
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
}, Y3 = ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u", HE = typeof navigator == "object" && navigator || void 0, Hee = Y3 && (!HE || [
    "ReactNative",
    "NativeScript",
    "NS"
].indexOf(HE.product) < 0), qee = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Kee = Y3 && window.location.href || "http://localhost", Wee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: Y3,
    hasStandardBrowserEnv: Hee,
    hasStandardBrowserWebWorkerEnv: qee,
    navigator: HE,
    origin: Kee
}, Symbol.toStringTag, {
    value: "Module"
})), Mi = {
    ...Wee,
    ...jee
};
function Vee(e, t) {
    return Lb(e, new Mi.classes.URLSearchParams(), Object.assign({
        visitor: function(r, n, i, o) {
            return Mi.isNode && Je.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
        }
    }, t));
}
function Gee(e) {
    return Je.matchAll(/\w+|\[(\w*)]/g, e).map((t)=>t[0] === "[]" ? "" : t[1] || t[0]);
}
function Zee(e) {
    const t = {}, r = Object.keys(e);
    let n;
    const i = r.length;
    let o;
    for(n = 0; n < i; n++)o = r[n], t[o] = e[o];
    return t;
}
function AP(e) {
    function t(r, n, i, o) {
        let s = r[o++];
        if (s === "__proto__") return !0;
        const a = Number.isFinite(+s), u = o >= r.length;
        return s = !s && Je.isArray(i) ? i.length : s, u ? (Je.hasOwnProp(i, s) ? i[s] = [
            i[s],
            n
        ] : i[s] = n, !a) : ((!i[s] || !Je.isObject(i[s])) && (i[s] = []), t(r, n, i[s], o) && Je.isArray(i[s]) && (i[s] = Zee(i[s])), !a);
    }
    if (Je.isFormData(e) && Je.isFunction(e.entries)) {
        const r = {};
        return Je.forEachEntry(e, (n, i)=>{
            t(Gee(n), i, r, 0);
        }), r;
    }
    return null;
}
function Yee(e, t, r) {
    if (Je.isString(e)) try {
        return (t || JSON.parse)(e), Je.trim(e);
    } catch (n) {
        if (n.name !== "SyntaxError") throw n;
    }
    return (r || JSON.stringify)(e);
}
const u0 = {
    transitional: SP,
    adapter: [
        "xhr",
        "http",
        "fetch"
    ],
    transformRequest: [
        function(t, r) {
            const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, o = Je.isObject(t);
            if (o && Je.isHTMLForm(t) && (t = new FormData(t)), Je.isFormData(t)) return i ? JSON.stringify(AP(t)) : t;
            if (Je.isArrayBuffer(t) || Je.isBuffer(t) || Je.isStream(t) || Je.isFile(t) || Je.isBlob(t) || Je.isReadableStream(t)) return t;
            if (Je.isArrayBufferView(t)) return t.buffer;
            if (Je.isURLSearchParams(t)) return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
            let a;
            if (o) {
                if (n.indexOf("application/x-www-form-urlencoded") > -1) return Vee(t, this.formSerializer).toString();
                if ((a = Je.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
                    const u = this.env && this.env.FormData;
                    return Lb(a ? {
                        "files[]": t
                    } : t, u && new u(), this.formSerializer);
                }
            }
            return o || i ? (r.setContentType("application/json", !1), Yee(t)) : t;
        }
    ],
    transformResponse: [
        function(t) {
            const r = this.transitional || u0.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
            if (Je.isResponse(t) || Je.isReadableStream(t)) return t;
            if (t && Je.isString(t) && (n && !this.responseType || i)) {
                const s = !(r && r.silentJSONParsing) && i;
                try {
                    return JSON.parse(t);
                } catch (a) {
                    if (s) throw a.name === "SyntaxError" ? dr.from(a, dr.ERR_BAD_RESPONSE, this, null, this.response) : a;
                }
            }
            return t;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: Mi.classes.FormData,
        Blob: Mi.classes.Blob
    },
    validateStatus: function(t) {
        return t >= 200 && t < 300;
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Je.forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (e)=>{
    u0.headers[e] = {};
});
const Xee = Je.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]), Jee = (e)=>{
    const t = {};
    let r, n, i;
    return e && e.split(`
`).forEach(function(s) {
        i = s.indexOf(":"), r = s.substring(0, i).trim().toLowerCase(), n = s.substring(i + 1).trim(), !(!r || t[r] && Xee[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [
            n
        ] : t[r] = t[r] ? t[r] + ", " + n : n);
    }), t;
}, gk = Symbol("internals");
function hh(e) {
    return e && String(e).trim().toLowerCase();
}
function Py(e) {
    return e === !1 || e == null ? e : Je.isArray(e) ? e.map(Py) : String(e);
}
function Qee(e) {
    const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let n;
    for(; n = r.exec(e);)t[n[1]] = n[2];
    return t;
}
const ete = (e)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function g_(e, t, r, n, i) {
    if (Je.isFunction(n)) return n.call(this, t, r);
    if (i && (t = r), !!Je.isString(t)) {
        if (Je.isString(n)) return t.indexOf(n) !== -1;
        if (Je.isRegExp(n)) return n.test(t);
    }
}
function tte(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n)=>r.toUpperCase() + n);
}
function rte(e, t) {
    const r = Je.toCamelCase(" " + t);
    [
        "get",
        "set",
        "has"
    ].forEach((n)=>{
        Object.defineProperty(e, n + r, {
            value: function(i, o, s) {
                return this[n].call(this, t, i, o, s);
            },
            configurable: !0
        });
    });
}
let po = class {
    constructor(t){
        t && this.set(t);
    }
    set(t, r, n) {
        const i = this;
        function o(a, u, f) {
            const c = hh(u);
            if (!c) throw new Error("header name must be a non-empty string");
            const l = Je.findKey(i, c);
            (!l || i[l] === void 0 || f === !0 || f === void 0 && i[l] !== !1) && (i[l || u] = Py(a));
        }
        const s = (a, u)=>Je.forEach(a, (f, c)=>o(f, c, u));
        if (Je.isPlainObject(t) || t instanceof this.constructor) s(t, r);
        else if (Je.isString(t) && (t = t.trim()) && !ete(t)) s(Jee(t), r);
        else if (Je.isObject(t) && Je.isIterable(t)) {
            let a = {}, u, f;
            for (const c of t){
                if (!Je.isArray(c)) throw TypeError("Object iterator must return a key-value pair");
                a[f = c[0]] = (u = a[f]) ? Je.isArray(u) ? [
                    ...u,
                    c[1]
                ] : [
                    u,
                    c[1]
                ] : c[1];
            }
            s(a, r);
        } else t != null && o(r, t, n);
        return this;
    }
    get(t, r) {
        if (t = hh(t), t) {
            const n = Je.findKey(this, t);
            if (n) {
                const i = this[n];
                if (!r) return i;
                if (r === !0) return Qee(i);
                if (Je.isFunction(r)) return r.call(this, i, n);
                if (Je.isRegExp(r)) return r.exec(i);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(t, r) {
        if (t = hh(t), t) {
            const n = Je.findKey(this, t);
            return !!(n && this[n] !== void 0 && (!r || g_(this, this[n], n, r)));
        }
        return !1;
    }
    delete(t, r) {
        const n = this;
        let i = !1;
        function o(s) {
            if (s = hh(s), s) {
                const a = Je.findKey(n, s);
                a && (!r || g_(n, n[a], a, r)) && (delete n[a], i = !0);
            }
        }
        return Je.isArray(t) ? t.forEach(o) : o(t), i;
    }
    clear(t) {
        const r = Object.keys(this);
        let n = r.length, i = !1;
        for(; n--;){
            const o = r[n];
            (!t || g_(this, this[o], o, t, !0)) && (delete this[o], i = !0);
        }
        return i;
    }
    normalize(t) {
        const r = this, n = {};
        return Je.forEach(this, (i, o)=>{
            const s = Je.findKey(n, o);
            if (s) {
                r[s] = Py(i), delete r[o];
                return;
            }
            const a = t ? tte(o) : String(o).trim();
            a !== o && delete r[o], r[a] = Py(i), n[a] = !0;
        }), this;
    }
    concat(...t) {
        return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
        const r = /* @__PURE__ */ Object.create(null);
        return Je.forEach(this, (n, i)=>{
            n != null && n !== !1 && (r[i] = t && Je.isArray(n) ? n.join(", ") : n);
        }), r;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([t, r])=>t + ": " + r).join(`
`);
    }
    getSetCookie() {
        return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(t) {
        return t instanceof this ? t : new this(t);
    }
    static concat(t, ...r) {
        const n = new this(t);
        return r.forEach((i)=>n.set(i)), n;
    }
    static accessor(t) {
        const n = (this[gk] = this[gk] = {
            accessors: {}
        }).accessors, i = this.prototype;
        function o(s) {
            const a = hh(s);
            n[a] || (rte(i, s), n[a] = !0);
        }
        return Je.isArray(t) ? t.forEach(o) : o(t), this;
    }
};
po.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
Je.reduceDescriptors(po.prototype, ({ value: e }, t)=>{
    let r = t[0].toUpperCase() + t.slice(1);
    return {
        get: ()=>e,
        set (n) {
            this[r] = n;
        }
    };
});
Je.freezeMethods(po);
function y_(e, t) {
    const r = this || u0, n = t || r, i = po.from(n.headers);
    let o = n.data;
    return Je.forEach(e, function(a) {
        o = a.call(r, o, i.normalize(), t ? t.status : void 0);
    }), i.normalize(), o;
}
function TP(e) {
    return !!(e && e.__CANCEL__);
}
function Od(e, t, r) {
    dr.call(this, e ?? "canceled", dr.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Je.inherits(Od, dr, {
    __CANCEL__: !0
});
function kP(e, t, r) {
    const n = r.config.validateStatus;
    !r.status || !n || n(r.status) ? e(r) : t(new dr("Request failed with status code " + r.status, [
        dr.ERR_BAD_REQUEST,
        dr.ERR_BAD_RESPONSE
    ][Math.floor(r.status / 100) - 4], r.config, r.request, r));
}
function nte(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
}
function ite(e, t) {
    e = e || 10;
    const r = new Array(e), n = new Array(e);
    let i = 0, o = 0, s;
    return t = t !== void 0 ? t : 1e3, function(u) {
        const f = Date.now(), c = n[o];
        s || (s = f), r[i] = u, n[i] = f;
        let l = o, p = 0;
        for(; l !== i;)p += r[l++], l = l % e;
        if (i = (i + 1) % e, i === o && (o = (o + 1) % e), f - s < t) return;
        const y = c && f - c;
        return y ? Math.round(p * 1e3 / y) : void 0;
    };
}
function ote(e, t) {
    let r = 0, n = 1e3 / t, i, o;
    const s = (f, c = Date.now())=>{
        r = c, i = null, o && (clearTimeout(o), o = null), e.apply(null, f);
    };
    return [
        (...f)=>{
            const c = Date.now(), l = c - r;
            l >= n ? s(f, c) : (i = f, o || (o = setTimeout(()=>{
                o = null, s(i);
            }, n - l)));
        },
        ()=>i && s(i)
    ];
}
const sm = (e, t, r = 3)=>{
    let n = 0;
    const i = ite(50, 250);
    return ote((o)=>{
        const s = o.loaded, a = o.lengthComputable ? o.total : void 0, u = s - n, f = i(u), c = s <= a;
        n = s;
        const l = {
            loaded: s,
            total: a,
            progress: a ? s / a : void 0,
            bytes: u,
            rate: f || void 0,
            estimated: f && a && c ? (a - s) / f : void 0,
            event: o,
            lengthComputable: a != null,
            [t ? "download" : "upload"]: !0
        };
        e(l);
    }, r);
}, yk = (e, t)=>{
    const r = e != null;
    return [
        (n)=>t[0]({
                lengthComputable: r,
                total: e,
                loaded: n
            }),
        t[1]
    ];
}, mk = (e)=>(...t)=>Je.asap(()=>e(...t)), ste = Mi.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t)=>(r)=>(r = new URL(r, Mi.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(new URL(Mi.origin), Mi.navigator && /(msie|trident)/i.test(Mi.navigator.userAgent)) : ()=>!0, ate = Mi.hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (e, t, r, n, i, o) {
        const s = [
            e + "=" + encodeURIComponent(t)
        ];
        Je.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), Je.isString(n) && s.push("path=" + n), Je.isString(i) && s.push("domain=" + i), o === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read (e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null;
    },
    remove (e) {
        this.write(e, "", Date.now() - 864e5);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};
function cte(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function ute(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function IP(e, t, r) {
    let n = !cte(t);
    return e && (n || r == !1) ? ute(e, t) : t;
}
const bk = (e)=>e instanceof po ? {
        ...e
    } : e;
function Ef(e, t) {
    t = t || {};
    const r = {};
    function n(f, c, l, p) {
        return Je.isPlainObject(f) && Je.isPlainObject(c) ? Je.merge.call({
            caseless: p
        }, f, c) : Je.isPlainObject(c) ? Je.merge({}, c) : Je.isArray(c) ? c.slice() : c;
    }
    function i(f, c, l, p) {
        if (Je.isUndefined(c)) {
            if (!Je.isUndefined(f)) return n(void 0, f, l, p);
        } else return n(f, c, l, p);
    }
    function o(f, c) {
        if (!Je.isUndefined(c)) return n(void 0, c);
    }
    function s(f, c) {
        if (Je.isUndefined(c)) {
            if (!Je.isUndefined(f)) return n(void 0, f);
        } else return n(void 0, c);
    }
    function a(f, c, l) {
        if (l in t) return n(f, c);
        if (l in e) return n(void 0, f);
    }
    const u = {
        url: o,
        method: o,
        data: o,
        baseURL: s,
        transformRequest: s,
        transformResponse: s,
        paramsSerializer: s,
        timeout: s,
        timeoutMessage: s,
        withCredentials: s,
        withXSRFToken: s,
        adapter: s,
        responseType: s,
        xsrfCookieName: s,
        xsrfHeaderName: s,
        onUploadProgress: s,
        onDownloadProgress: s,
        decompress: s,
        maxContentLength: s,
        maxBodyLength: s,
        beforeRedirect: s,
        transport: s,
        httpAgent: s,
        httpsAgent: s,
        cancelToken: s,
        socketPath: s,
        responseEncoding: s,
        validateStatus: a,
        headers: (f, c, l)=>i(bk(f), bk(c), l, !0)
    };
    return Je.forEach(Object.keys(Object.assign({}, e, t)), function(c) {
        const l = u[c] || i, p = l(e[c], t[c], c);
        Je.isUndefined(p) && l !== a || (r[c] = p);
    }), r;
}
const BP = (e)=>{
    const t = Ef({}, e);
    let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: a } = t;
    t.headers = s = po.from(s), t.url = xP(IP(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && s.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
    let u;
    if (Je.isFormData(r)) {
        if (Mi.hasStandardBrowserEnv || Mi.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0);
        else if ((u = s.getContentType()) !== !1) {
            const [f, ...c] = u ? u.split(";").map((l)=>l.trim()).filter(Boolean) : [];
            s.setContentType([
                f || "multipart/form-data",
                ...c
            ].join("; "));
        }
    }
    if (Mi.hasStandardBrowserEnv && (n && Je.isFunction(n) && (n = n(t)), n || n !== !1 && ste(t.url))) {
        const f = i && o && ate.read(o);
        f && s.set(i, f);
    }
    return t;
}, fte = typeof XMLHttpRequest < "u", lte = fte && function(e) {
    return new Promise(function(r, n) {
        const i = BP(e);
        let o = i.data;
        const s = po.from(i.headers).normalize();
        let { responseType: a, onUploadProgress: u, onDownloadProgress: f } = i, c, l, p, y, _;
        function A() {
            y && y(), _ && _(), i.cancelToken && i.cancelToken.unsubscribe(c), i.signal && i.signal.removeEventListener("abort", c);
        }
        let O = new XMLHttpRequest();
        O.open(i.method.toUpperCase(), i.url, !0), O.timeout = i.timeout;
        function N() {
            if (!O) return;
            const D = po.from("getAllResponseHeaders" in O && O.getAllResponseHeaders()), K = {
                data: !a || a === "text" || a === "json" ? O.responseText : O.response,
                status: O.status,
                statusText: O.statusText,
                headers: D,
                config: e,
                request: O
            };
            kP(function(Q) {
                r(Q), A();
            }, function(Q) {
                n(Q), A();
            }, K), O = null;
        }
        "onloadend" in O ? O.onloadend = N : O.onreadystatechange = function() {
            !O || O.readyState !== 4 || O.status === 0 && !(O.responseURL && O.responseURL.indexOf("file:") === 0) || setTimeout(N);
        }, O.onabort = function() {
            O && (n(new dr("Request aborted", dr.ECONNABORTED, e, O)), O = null);
        }, O.onerror = function() {
            n(new dr("Network Error", dr.ERR_NETWORK, e, O)), O = null;
        }, O.ontimeout = function() {
            let H = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
            const K = i.transitional || SP;
            i.timeoutErrorMessage && (H = i.timeoutErrorMessage), n(new dr(H, K.clarifyTimeoutError ? dr.ETIMEDOUT : dr.ECONNABORTED, e, O)), O = null;
        }, o === void 0 && s.setContentType(null), "setRequestHeader" in O && Je.forEach(s.toJSON(), function(H, K) {
            O.setRequestHeader(K, H);
        }), Je.isUndefined(i.withCredentials) || (O.withCredentials = !!i.withCredentials), a && a !== "json" && (O.responseType = i.responseType), f && ([p, _] = sm(f, !0), O.addEventListener("progress", p)), u && O.upload && ([l, y] = sm(u), O.upload.addEventListener("progress", l), O.upload.addEventListener("loadend", y)), (i.cancelToken || i.signal) && (c = (D)=>{
            O && (n(!D || D.type ? new Od(null, e, O) : D), O.abort(), O = null);
        }, i.cancelToken && i.cancelToken.subscribe(c), i.signal && (i.signal.aborted ? c() : i.signal.addEventListener("abort", c)));
        const U = nte(i.url);
        if (U && Mi.protocols.indexOf(U) === -1) {
            n(new dr("Unsupported protocol " + U + ":", dr.ERR_BAD_REQUEST, e));
            return;
        }
        O.send(o || null);
    });
}, dte = (e, t)=>{
    const { length: r } = e = e ? e.filter(Boolean) : [];
    if (t || r) {
        let n = new AbortController(), i;
        const o = function(f) {
            if (!i) {
                i = !0, a();
                const c = f instanceof Error ? f : this.reason;
                n.abort(c instanceof dr ? c : new Od(c instanceof Error ? c.message : c));
            }
        };
        let s = t && setTimeout(()=>{
            s = null, o(new dr(`timeout ${t} of ms exceeded`, dr.ETIMEDOUT));
        }, t);
        const a = ()=>{
            e && (s && clearTimeout(s), s = null, e.forEach((f)=>{
                f.unsubscribe ? f.unsubscribe(o) : f.removeEventListener("abort", o);
            }), e = null);
        };
        e.forEach((f)=>f.addEventListener("abort", o));
        const { signal: u } = n;
        return u.unsubscribe = ()=>Je.asap(a), u;
    }
}, hte = function*(e, t) {
    let r = e.byteLength;
    if (r < t) {
        yield e;
        return;
    }
    let n = 0, i;
    for(; n < r;)i = n + t, yield e.slice(n, i), n = i;
}, pte = async function*(e, t) {
    for await (const r of gte(e))yield* hte(r, t);
}, gte = async function*(e) {
    if (e[Symbol.asyncIterator]) {
        yield* e;
        return;
    }
    const t = e.getReader();
    try {
        for(;;){
            const { done: r, value: n } = await t.read();
            if (r) break;
            yield n;
        }
    } finally{
        await t.cancel();
    }
}, wk = (e, t, r, n)=>{
    const i = pte(e, t);
    let o = 0, s, a = (u)=>{
        s || (s = !0, n && n(u));
    };
    return new ReadableStream({
        async pull (u) {
            try {
                const { done: f, value: c } = await i.next();
                if (f) {
                    a(), u.close();
                    return;
                }
                let l = c.byteLength;
                if (r) {
                    let p = o += l;
                    r(p);
                }
                u.enqueue(new Uint8Array(c));
            } catch (f) {
                throw a(f), f;
            }
        },
        cancel (u) {
            return a(u), i.return();
        }
    }, {
        highWaterMark: 2
    });
}, Db = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", OP = Db && typeof ReadableStream == "function", yte = Db && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e)=>(t)=>e.encode(t))(new TextEncoder()) : async (e)=>new Uint8Array(await new Response(e).arrayBuffer())), PP = (e, ...t)=>{
    try {
        return !!e(...t);
    } catch  {
        return !1;
    }
}, mte = OP && PP(()=>{
    let e = !1;
    const t = new Request(Mi.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex () {
            return e = !0, "half";
        }
    }).headers.has("Content-Type");
    return e && !t;
}), vk = 64 * 1024, qE = OP && PP(()=>Je.isReadableStream(new Response("").body)), am = {
    stream: qE && ((e)=>e.body)
};
Db && ((e)=>{
    [
        "text",
        "arrayBuffer",
        "blob",
        "formData",
        "stream"
    ].forEach((t)=>{
        !am[t] && (am[t] = Je.isFunction(e[t]) ? (r)=>r[t]() : (r, n)=>{
            throw new dr(`Response type '${t}' is not supported`, dr.ERR_NOT_SUPPORT, n);
        });
    });
})(new Response());
const bte = async (e)=>{
    if (e == null) return 0;
    if (Je.isBlob(e)) return e.size;
    if (Je.isSpecCompliantForm(e)) return (await new Request(Mi.origin, {
        method: "POST",
        body: e
    }).arrayBuffer()).byteLength;
    if (Je.isArrayBufferView(e) || Je.isArrayBuffer(e)) return e.byteLength;
    if (Je.isURLSearchParams(e) && (e = e + ""), Je.isString(e)) return (await yte(e)).byteLength;
}, wte = async (e, t)=>{
    const r = Je.toFiniteNumber(e.getContentLength());
    return r ?? bte(t);
}, vte = Db && (async (e)=>{
    let { url: t, method: r, data: n, signal: i, cancelToken: o, timeout: s, onDownloadProgress: a, onUploadProgress: u, responseType: f, headers: c, withCredentials: l = "same-origin", fetchOptions: p } = BP(e);
    f = f ? (f + "").toLowerCase() : "text";
    let y = dte([
        i,
        o && o.toAbortSignal()
    ], s), _;
    const A = y && y.unsubscribe && (()=>{
        y.unsubscribe();
    });
    let O;
    try {
        if (u && mte && r !== "get" && r !== "head" && (O = await wte(c, n)) !== 0) {
            let K = new Request(t, {
                method: "POST",
                body: n,
                duplex: "half"
            }), re;
            if (Je.isFormData(n) && (re = K.headers.get("content-type")) && c.setContentType(re), K.body) {
                const [Q, G] = yk(O, sm(mk(u)));
                n = wk(K.body, vk, Q, G);
            }
        }
        Je.isString(l) || (l = l ? "include" : "omit");
        const N = "credentials" in Request.prototype;
        _ = new Request(t, {
            ...p,
            signal: y,
            method: r.toUpperCase(),
            headers: c.normalize().toJSON(),
            body: n,
            duplex: "half",
            credentials: N ? l : void 0
        });
        let U = await fetch(_, p);
        const D = qE && (f === "stream" || f === "response");
        if (qE && (a || D && A)) {
            const K = {};
            [
                "status",
                "statusText",
                "headers"
            ].forEach((R)=>{
                K[R] = U[R];
            });
            const re = Je.toFiniteNumber(U.headers.get("content-length")), [Q, G] = a && yk(re, sm(mk(a), !0)) || [];
            U = new Response(wk(U.body, vk, Q, ()=>{
                G && G(), A && A();
            }), K);
        }
        f = f || "text";
        let H = await am[Je.findKey(am, f) || "text"](U, e);
        return !D && A && A(), await new Promise((K, re)=>{
            kP(K, re, {
                data: H,
                headers: po.from(U.headers),
                status: U.status,
                statusText: U.statusText,
                config: e,
                request: _
            });
        });
    } catch (N) {
        throw A && A(), N && N.name === "TypeError" && /Load failed|fetch/i.test(N.message) ? Object.assign(new dr("Network Error", dr.ERR_NETWORK, e, _), {
            cause: N.cause || N
        }) : dr.from(N, N && N.code, e, _);
    }
}), KE = {
    http: Cee,
    xhr: lte,
    fetch: vte
};
Je.forEach(KE, (e, t)=>{
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            });
        } catch  {}
        Object.defineProperty(e, "adapterName", {
            value: t
        });
    }
});
const _k = (e)=>`- ${e}`, _te = (e)=>Je.isFunction(e) || e === null || e === !1, NP = {
    getAdapter: (e)=>{
        e = Je.isArray(e) ? e : [
            e
        ];
        const { length: t } = e;
        let r, n;
        const i = {};
        for(let o = 0; o < t; o++){
            r = e[o];
            let s;
            if (n = r, !_te(r) && (n = KE[(s = String(r)).toLowerCase()], n === void 0)) throw new dr(`Unknown adapter '${s}'`);
            if (n) break;
            i[s || "#" + o] = n;
        }
        if (!n) {
            const o = Object.entries(i).map(([a, u])=>`adapter ${a} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build"));
            let s = t ? o.length > 1 ? `since :
` + o.map(_k).join(`
`) : " " + _k(o[0]) : "as no adapter specified";
            throw new dr("There is no suitable adapter to dispatch the request " + s, "ERR_NOT_SUPPORT");
        }
        return n;
    },
    adapters: KE
};
function m_(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Od(null, e);
}
function Ek(e) {
    return m_(e), e.headers = po.from(e.headers), e.data = y_.call(e, e.transformRequest), [
        "post",
        "put",
        "patch"
    ].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), NP.getAdapter(e.adapter || u0.adapter)(e).then(function(n) {
        return m_(e), n.data = y_.call(e, e.transformResponse, n), n.headers = po.from(n.headers), n;
    }, function(n) {
        return TP(n) || (m_(e), n && n.response && (n.response.data = y_.call(e, e.transformResponse, n.response), n.response.headers = po.from(n.response.headers))), Promise.reject(n);
    });
}
const MP = "1.10.0", Fb = {};
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((e, t)=>{
    Fb[e] = function(n) {
        return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
    };
});
const xk = {};
Fb.transitional = function(t, r, n) {
    function i(o, s) {
        return "[Axios v" + MP + "] Transitional option '" + o + "'" + s + (n ? ". " + n : "");
    }
    return (o, s, a)=>{
        if (t === !1) throw new dr(i(s, " has been removed" + (r ? " in " + r : "")), dr.ERR_DEPRECATED);
        return r && !xk[s] && (xk[s] = !0, console.warn(i(s, " has been deprecated since v" + r + " and will be removed in the near future"))), t ? t(o, s, a) : !0;
    };
};
Fb.spelling = function(t) {
    return (r, n)=>(console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function Ete(e, t, r) {
    if (typeof e != "object") throw new dr("options must be an object", dr.ERR_BAD_OPTION_VALUE);
    const n = Object.keys(e);
    let i = n.length;
    for(; i-- > 0;){
        const o = n[i], s = t[o];
        if (s) {
            const a = e[o], u = a === void 0 || s(a, o, e);
            if (u !== !0) throw new dr("option " + o + " must be " + u, dr.ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (r !== !0) throw new dr("Unknown option " + o, dr.ERR_BAD_OPTION);
    }
}
const Ny = {
    assertOptions: Ete,
    validators: Fb
}, Ys = Ny.validators;
let hf = class {
    constructor(t){
        this.defaults = t || {}, this.interceptors = {
            request: new pk(),
            response: new pk()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(t, r) {
        try {
            return await this._request(t, r);
        } catch (n) {
            if (n instanceof Error) {
                let i = {};
                Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
                const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
                } catch  {}
            }
            throw n;
        }
    }
    _request(t, r) {
        typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = Ef(this.defaults, r);
        const { transitional: n, paramsSerializer: i, headers: o } = r;
        n !== void 0 && Ny.assertOptions(n, {
            silentJSONParsing: Ys.transitional(Ys.boolean),
            forcedJSONParsing: Ys.transitional(Ys.boolean),
            clarifyTimeoutError: Ys.transitional(Ys.boolean)
        }, !1), i != null && (Je.isFunction(i) ? r.paramsSerializer = {
            serialize: i
        } : Ny.assertOptions(i, {
            encode: Ys.function,
            serialize: Ys.function
        }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), Ny.assertOptions(r, {
            baseUrl: Ys.spelling("baseURL"),
            withXsrfToken: Ys.spelling("withXSRFToken")
        }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
        let s = o && Je.merge(o.common, o[r.method]);
        o && Je.forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (_)=>{
            delete o[_];
        }), r.headers = po.concat(s, o);
        const a = [];
        let u = !0;
        this.interceptors.request.forEach(function(A) {
            typeof A.runWhen == "function" && A.runWhen(r) === !1 || (u = u && A.synchronous, a.unshift(A.fulfilled, A.rejected));
        });
        const f = [];
        this.interceptors.response.forEach(function(A) {
            f.push(A.fulfilled, A.rejected);
        });
        let c, l = 0, p;
        if (!u) {
            const _ = [
                Ek.bind(this),
                void 0
            ];
            for(_.unshift.apply(_, a), _.push.apply(_, f), p = _.length, c = Promise.resolve(r); l < p;)c = c.then(_[l++], _[l++]);
            return c;
        }
        p = a.length;
        let y = r;
        for(l = 0; l < p;){
            const _ = a[l++], A = a[l++];
            try {
                y = _(y);
            } catch (O) {
                A.call(this, O);
                break;
            }
        }
        try {
            c = Ek.call(this, y);
        } catch (_) {
            return Promise.reject(_);
        }
        for(l = 0, p = f.length; l < p;)c = c.then(f[l++], f[l++]);
        return c;
    }
    getUri(t) {
        t = Ef(this.defaults, t);
        const r = IP(t.baseURL, t.url, t.allowAbsoluteUrls);
        return xP(r, t.params, t.paramsSerializer);
    }
};
Je.forEach([
    "delete",
    "get",
    "head",
    "options"
], function(t) {
    hf.prototype[t] = function(r, n) {
        return this.request(Ef(n || {}, {
            method: t,
            url: r,
            data: (n || {}).data
        }));
    };
});
Je.forEach([
    "post",
    "put",
    "patch"
], function(t) {
    function r(n) {
        return function(o, s, a) {
            return this.request(Ef(a || {}, {
                method: t,
                headers: n ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: o,
                data: s
            }));
        };
    }
    hf.prototype[t] = r(), hf.prototype[t + "Form"] = r(!0);
});
let xte = class RP {
    constructor(t){
        if (typeof t != "function") throw new TypeError("executor must be a function.");
        let r;
        this.promise = new Promise(function(o) {
            r = o;
        });
        const n = this;
        this.promise.then((i)=>{
            if (!n._listeners) return;
            let o = n._listeners.length;
            for(; o-- > 0;)n._listeners[o](i);
            n._listeners = null;
        }), this.promise.then = (i)=>{
            let o;
            const s = new Promise((a)=>{
                n.subscribe(a), o = a;
            }).then(i);
            return s.cancel = function() {
                n.unsubscribe(o);
            }, s;
        }, t(function(o, s, a) {
            n.reason || (n.reason = new Od(o, s, a), r(n.reason));
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(t) {
        if (this.reason) {
            t(this.reason);
            return;
        }
        this._listeners ? this._listeners.push(t) : this._listeners = [
            t
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(t) {
        if (!this._listeners) return;
        const r = this._listeners.indexOf(t);
        r !== -1 && this._listeners.splice(r, 1);
    }
    toAbortSignal() {
        const t = new AbortController(), r = (n)=>{
            t.abort(n);
        };
        return this.subscribe(r), t.signal.unsubscribe = ()=>this.unsubscribe(r), t.signal;
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let t;
        return {
            token: new RP(function(i) {
                t = i;
            }),
            cancel: t
        };
    }
};
function Ste(e) {
    return function(r) {
        return e.apply(null, r);
    };
}
function Ate(e) {
    return Je.isObject(e) && e.isAxiosError === !0;
}
const WE = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(WE).forEach(([e, t])=>{
    WE[t] = e;
});
function CP(e) {
    const t = new hf(e), r = lP(hf.prototype.request, t);
    return Je.extend(r, hf.prototype, t, {
        allOwnKeys: !0
    }), Je.extend(r, t, null, {
        allOwnKeys: !0
    }), r.create = function(i) {
        return CP(Ef(e, i));
    }, r;
}
const rn = CP(u0);
rn.Axios = hf;
rn.CanceledError = Od;
rn.CancelToken = xte;
rn.isCancel = TP;
rn.VERSION = MP;
rn.toFormData = Lb;
rn.AxiosError = dr;
rn.Cancel = rn.CanceledError;
rn.all = function(t) {
    return Promise.all(t);
};
rn.spread = Ste;
rn.isAxiosError = Ate;
rn.mergeConfig = Ef;
rn.AxiosHeaders = po;
rn.formToJSON = (e)=>AP(Je.isHTMLForm(e) ? new FormData(e) : e);
rn.getAdapter = NP.getAdapter;
rn.HttpStatusCode = WE;
rn.default = rn;
const { Axios: mve, AxiosError: bve, CanceledError: wve, isCancel: vve, CancelToken: _ve, VERSION: Eve, all: xve, Cancel: Sve, isAxiosError: Ave, spread: Tve, toFormData: kve, AxiosHeaders: Ive, HttpStatusCode: Bve, formToJSON: Ove, getAdapter: Pve, mergeConfig: Nve } = rn, UP = "https://mainnet.sandshrew.io/v2", Tte = "https://signet.sandshrew.io/v2", kte = "https://testnet.sandshrew.io/v2", Ite = "https://ladder-chain-sieve.sandshrew.io/v2", ql = "lasereyes", Bte = "VIOi9IApvUkDFWBQ7I9oHsfUMWOIfDeO", $P = "bVG4GSXShooC9f67hq5YQWAJfZyRPrEN", Ote = "https://xbt-mainnet.gomaestro-api.org/v0", Pte = "https://xbt-testnet.gomaestro-api.org/v0", Nte = "https://mempool.space", Mte = "https://mempool.space/testnet", Rte = "https://mempool.space/testnet4", Cte = "https://mempool.space/signet", Ute = "https://mempool.fractalbitcoin.io", $te = "https://mempool-testnet.fractalbitcoin.io", Lte = "https://static.unisat.io/content", Sk = "https://static-testnet.unisat.io/content", Dte = "https://ordinals-testnet4.unisat.io/content", Fte = "https://ordinals.fractalbitcoin.io/content", zte = "https://ordinals-testnet.fractalbitcoin.io/content", jte = "https://static.unisat.io/preview", Ak = "https://static-testnet.unisat.io/preview", Hte = "https://ordinals-testnet4.unisat.io/preview", qte = "https://ordinals.fractalbitcoin.io/preview", Kte = "https://ordinals-testnet.fractalbitcoin.io/preview", Bi = (e)=>{
    switch(e){
        case Ni:
            return Mte;
        case ao:
            return Rte;
        case Ro:
            return Cte;
        case yc:
            return Ute;
        case co:
            return $te;
        default:
            return Nte;
    }
}, cm = (e, t)=>e === dt.TESTNET4 ? Pte : Ote, $l = (e, t)=>{
    switch(e){
        case uP:
            return Ite;
        case Ni:
            return kte;
        case Ro:
            return Tte;
        default:
            return UP;
    }
}, Wte = (e)=>{
    switch(e){
        case Ni:
            return Sk;
        case ao:
            return Dte;
        case Ro:
            return Sk;
        case yc:
            return Fte;
        case co:
            return zte;
        default:
            return Lte;
    }
}, Vte = (e)=>{
    switch(e){
        case Ni:
            return Ak;
        case ao:
            return Hte;
        case Ro:
            return Ak;
        case yc:
            return qte;
        case co:
            return Kte;
        default:
            return jte;
    }
};
o3(bb);
const Dr = (e)=>e === Ni || e === ao || e === Ro ? $H : zs, um = (e)=>e.find(({ purpose: t })=>t === "ordinals"), fm = (e)=>e.find(({ purpose: t })=>t === "payment"), id = async (e, t)=>{
    try {
        const r = await J3(e, t);
        return r ? r.reduce((n, i)=>n + BigInt(i.value), 0n) : 0n;
    } catch (r) {
        throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
    }
};
function X3(e, t, r) {
    const a = e * 57 + t * 41, u = r * 34;
    return 10 + a + u;
}
async function J3(e, t) {
    if (e.startsWith("t")) {
        if (t === ln) return [];
        if (t === yc) return [];
        if (t === co) return [];
    }
    return console.log("address", e), console.log("network", t), e.startsWith("bcrt") && t === uP ? [] : await rn.get(`${Bi(t)}/api/address/${e}/utxo`).then((r)=>r.data);
}
async function zb(e, t, r, n, i, o, s = 7) {
    const a = e === t, u = await J3(t, o);
    if (!u) throw new Error("No UTXOs found");
    const f = u.sort((_, A)=>A.value - _.value), c = new Cr({
        network: Dr(o)
    }), l = X3(1, 0, 2), p = Math.floor(l * s) + n;
    let y = 0;
    for await (const _ of f){
        const { txid: A, vout: O, value: N } = _, U = hs(t, Dr(o));
        if (c.addInput({
            hash: A,
            index: O,
            witnessUtxo: {
                script: U,
                value: BigInt(N)
            }
        }), !a) {
            const D = d0(i, o);
            c.updateInput(O, {
                redeemScript: D
            });
        }
        if (y += N, y >= p) break;
    }
    if (y < p) throw new Error("Insufficient funds");
    return c.addOutput({
        address: r,
        value: BigInt(n)
    }), y > p && c.addOutput({
        address: t,
        value: BigInt(y - p)
    }), {
        psbtBase64: c.toBase64(),
        psbtHex: c.toHex()
    };
}
function jb(e) {
    return e == null ? void 0 : e.reduce((t, r)=>t + r.value, 0);
}
async function Hb(e, t) {
    return (await rn.post(`${Bi(t)}/api/tx`, e, {
        headers: {
            "Content-Type": "text/plain"
        }
    })).data;
}
const LP = (e)=>e === Ni || e === ao || e === Ro, qb = (e)=>e === ln || e === yc || e === co;
var Aa = {}, oi = {};
Object.defineProperty(oi, "__esModule", {
    value: !0
});
oi.sha512_256 = oi.SHA512_256 = oi.sha512_224 = oi.SHA512_224 = oi.sha384 = oi.SHA384 = oi.sha512 = oi.SHA512 = void 0;
const Ou = en;
oi.SHA512 = Ou.SHA512;
oi.sha512 = Ou.sha512;
oi.SHA384 = Ou.SHA384;
oi.sha384 = Ou.sha384;
oi.SHA512_224 = Ou.SHA512_224;
oi.sha512_224 = Ou.sha512_224;
oi.SHA512_256 = Ou.SHA512_256;
oi.sha512_256 = Ou.sha512_256;
var Kb = {};
Object.defineProperty(Kb, "__esModule", {
    value: !0
});
Kb.pbkdf2 = Zte;
Kb.pbkdf2Async = Yte;
const Gte = Qp, Bs = Hr;
function DP(e, t, r, n) {
    (0, Bs.ahash)(e);
    const i = (0, Bs.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, n), { c: o, dkLen: s, asyncTick: a } = i;
    if ((0, Bs.anumber)(o), (0, Bs.anumber)(s), (0, Bs.anumber)(a), o < 1) throw new Error("iterations (c) should be >= 1");
    const u = (0, Bs.kdfInputToBytes)(t), f = (0, Bs.kdfInputToBytes)(r), c = new Uint8Array(s), l = Gte.hmac.create(e, u), p = l._cloneInto().update(f);
    return {
        c: o,
        dkLen: s,
        asyncTick: a,
        DK: c,
        PRF: l,
        PRFSalt: p
    };
}
function FP(e, t, r, n, i) {
    return e.destroy(), t.destroy(), n && n.destroy(), (0, Bs.clean)(i), r;
}
function Zte(e, t, r, n) {
    const { c: i, dkLen: o, DK: s, PRF: a, PRFSalt: u } = DP(e, t, r, n);
    let f;
    const c = new Uint8Array(4), l = (0, Bs.createView)(c), p = new Uint8Array(a.outputLen);
    for(let y = 1, _ = 0; _ < o; y++, _ += a.outputLen){
        const A = s.subarray(_, _ + a.outputLen);
        l.setInt32(0, y, !1), (f = u._cloneInto(f)).update(c).digestInto(p), A.set(p.subarray(0, A.length));
        for(let O = 1; O < i; O++){
            a._cloneInto(f).update(p).digestInto(p);
            for(let N = 0; N < A.length; N++)A[N] ^= p[N];
        }
    }
    return FP(a, u, s, f, p);
}
async function Yte(e, t, r, n) {
    const { c: i, dkLen: o, asyncTick: s, DK: a, PRF: u, PRFSalt: f } = DP(e, t, r, n);
    let c;
    const l = new Uint8Array(4), p = (0, Bs.createView)(l), y = new Uint8Array(u.outputLen);
    for(let _ = 1, A = 0; A < o; _++, A += u.outputLen){
        const O = a.subarray(A, A + u.outputLen);
        p.setInt32(0, _, !1), (c = f._cloneInto(c)).update(l).digestInto(y), O.set(y.subarray(0, O.length)), await (0, Bs.asyncLoop)(i - 1, s, ()=>{
            u._cloneInto(c).update(y).digestInto(y);
            for(let N = 0; N < O.length; N++)O[N] ^= y[N];
        });
    }
    return FP(u, f, a, c, y);
}
var Zi = {};
const Xte = [
    "abdikace",
    "abeceda",
    "adresa",
    "agrese",
    "akce",
    "aktovka",
    "alej",
    "alkohol",
    "amputace",
    "ananas",
    "andulka",
    "anekdota",
    "anketa",
    "antika",
    "anulovat",
    "archa",
    "arogance",
    "asfalt",
    "asistent",
    "aspirace",
    "astma",
    "astronom",
    "atlas",
    "atletika",
    "atol",
    "autobus",
    "azyl",
    "babka",
    "bachor",
    "bacil",
    "baculka",
    "badatel",
    "bageta",
    "bagr",
    "bahno",
    "bakterie",
    "balada",
    "baletka",
    "balkon",
    "balonek",
    "balvan",
    "balza",
    "bambus",
    "bankomat",
    "barbar",
    "baret",
    "barman",
    "baroko",
    "barva",
    "baterka",
    "batoh",
    "bavlna",
    "bazalka",
    "bazilika",
    "bazuka",
    "bedna",
    "beran",
    "beseda",
    "bestie",
    "beton",
    "bezinka",
    "bezmoc",
    "beztak",
    "bicykl",
    "bidlo",
    "biftek",
    "bikiny",
    "bilance",
    "biograf",
    "biolog",
    "bitva",
    "bizon",
    "blahobyt",
    "blatouch",
    "blecha",
    "bledule",
    "blesk",
    "blikat",
    "blizna",
    "blokovat",
    "bloudit",
    "blud",
    "bobek",
    "bobr",
    "bodlina",
    "bodnout",
    "bohatost",
    "bojkot",
    "bojovat",
    "bokorys",
    "bolest",
    "borec",
    "borovice",
    "bota",
    "boubel",
    "bouchat",
    "bouda",
    "boule",
    "bourat",
    "boxer",
    "bradavka",
    "brambora",
    "branka",
    "bratr",
    "brepta",
    "briketa",
    "brko",
    "brloh",
    "bronz",
    "broskev",
    "brunetka",
    "brusinka",
    "brzda",
    "brzy",
    "bublina",
    "bubnovat",
    "buchta",
    "buditel",
    "budka",
    "budova",
    "bufet",
    "bujarost",
    "bukvice",
    "buldok",
    "bulva",
    "bunda",
    "bunkr",
    "burza",
    "butik",
    "buvol",
    "buzola",
    "bydlet",
    "bylina",
    "bytovka",
    "bzukot",
    "capart",
    "carevna",
    "cedr",
    "cedule",
    "cejch",
    "cejn",
    "cela",
    "celer",
    "celkem",
    "celnice",
    "cenina",
    "cennost",
    "cenovka",
    "centrum",
    "cenzor",
    "cestopis",
    "cetka",
    "chalupa",
    "chapadlo",
    "charita",
    "chata",
    "chechtat",
    "chemie",
    "chichot",
    "chirurg",
    "chlad",
    "chleba",
    "chlubit",
    "chmel",
    "chmura",
    "chobot",
    "chochol",
    "chodba",
    "cholera",
    "chomout",
    "chopit",
    "choroba",
    "chov",
    "chrapot",
    "chrlit",
    "chrt",
    "chrup",
    "chtivost",
    "chudina",
    "chutnat",
    "chvat",
    "chvilka",
    "chvost",
    "chyba",
    "chystat",
    "chytit",
    "cibule",
    "cigareta",
    "cihelna",
    "cihla",
    "cinkot",
    "cirkus",
    "cisterna",
    "citace",
    "citrus",
    "cizinec",
    "cizost",
    "clona",
    "cokoliv",
    "couvat",
    "ctitel",
    "ctnost",
    "cudnost",
    "cuketa",
    "cukr",
    "cupot",
    "cvaknout",
    "cval",
    "cvik",
    "cvrkot",
    "cyklista",
    "daleko",
    "dareba",
    "datel",
    "datum",
    "dcera",
    "debata",
    "dechovka",
    "decibel",
    "deficit",
    "deflace",
    "dekl",
    "dekret",
    "demokrat",
    "deprese",
    "derby",
    "deska",
    "detektiv",
    "dikobraz",
    "diktovat",
    "dioda",
    "diplom",
    "disk",
    "displej",
    "divadlo",
    "divoch",
    "dlaha",
    "dlouho",
    "dluhopis",
    "dnes",
    "dobro",
    "dobytek",
    "docent",
    "dochutit",
    "dodnes",
    "dohled",
    "dohoda",
    "dohra",
    "dojem",
    "dojnice",
    "doklad",
    "dokola",
    "doktor",
    "dokument",
    "dolar",
    "doleva",
    "dolina",
    "doma",
    "dominant",
    "domluvit",
    "domov",
    "donutit",
    "dopad",
    "dopis",
    "doplnit",
    "doposud",
    "doprovod",
    "dopustit",
    "dorazit",
    "dorost",
    "dort",
    "dosah",
    "doslov",
    "dostatek",
    "dosud",
    "dosyta",
    "dotaz",
    "dotek",
    "dotknout",
    "doufat",
    "doutnat",
    "dovozce",
    "dozadu",
    "doznat",
    "dozorce",
    "drahota",
    "drak",
    "dramatik",
    "dravec",
    "draze",
    "drdol",
    "drobnost",
    "drogerie",
    "drozd",
    "drsnost",
    "drtit",
    "drzost",
    "duben",
    "duchovno",
    "dudek",
    "duha",
    "duhovka",
    "dusit",
    "dusno",
    "dutost",
    "dvojice",
    "dvorec",
    "dynamit",
    "ekolog",
    "ekonomie",
    "elektron",
    "elipsa",
    "email",
    "emise",
    "emoce",
    "empatie",
    "epizoda",
    "epocha",
    "epopej",
    "epos",
    "esej",
    "esence",
    "eskorta",
    "eskymo",
    "etiketa",
    "euforie",
    "evoluce",
    "exekuce",
    "exkurze",
    "expedice",
    "exploze",
    "export",
    "extrakt",
    "facka",
    "fajfka",
    "fakulta",
    "fanatik",
    "fantazie",
    "farmacie",
    "favorit",
    "fazole",
    "federace",
    "fejeton",
    "fenka",
    "fialka",
    "figurant",
    "filozof",
    "filtr",
    "finance",
    "finta",
    "fixace",
    "fjord",
    "flanel",
    "flirt",
    "flotila",
    "fond",
    "fosfor",
    "fotbal",
    "fotka",
    "foton",
    "frakce",
    "freska",
    "fronta",
    "fukar",
    "funkce",
    "fyzika",
    "galeje",
    "garant",
    "genetika",
    "geolog",
    "gilotina",
    "glazura",
    "glejt",
    "golem",
    "golfista",
    "gotika",
    "graf",
    "gramofon",
    "granule",
    "grep",
    "gril",
    "grog",
    "groteska",
    "guma",
    "hadice",
    "hadr",
    "hala",
    "halenka",
    "hanba",
    "hanopis",
    "harfa",
    "harpuna",
    "havran",
    "hebkost",
    "hejkal",
    "hejno",
    "hejtman",
    "hektar",
    "helma",
    "hematom",
    "herec",
    "herna",
    "heslo",
    "hezky",
    "historik",
    "hladovka",
    "hlasivky",
    "hlava",
    "hledat",
    "hlen",
    "hlodavec",
    "hloh",
    "hloupost",
    "hltat",
    "hlubina",
    "hluchota",
    "hmat",
    "hmota",
    "hmyz",
    "hnis",
    "hnojivo",
    "hnout",
    "hoblina",
    "hoboj",
    "hoch",
    "hodiny",
    "hodlat",
    "hodnota",
    "hodovat",
    "hojnost",
    "hokej",
    "holinka",
    "holka",
    "holub",
    "homole",
    "honitba",
    "honorace",
    "horal",
    "horda",
    "horizont",
    "horko",
    "horlivec",
    "hormon",
    "hornina",
    "horoskop",
    "horstvo",
    "hospoda",
    "hostina",
    "hotovost",
    "houba",
    "houf",
    "houpat",
    "houska",
    "hovor",
    "hradba",
    "hranice",
    "hravost",
    "hrazda",
    "hrbolek",
    "hrdina",
    "hrdlo",
    "hrdost",
    "hrnek",
    "hrobka",
    "hromada",
    "hrot",
    "hrouda",
    "hrozen",
    "hrstka",
    "hrubost",
    "hryzat",
    "hubenost",
    "hubnout",
    "hudba",
    "hukot",
    "humr",
    "husita",
    "hustota",
    "hvozd",
    "hybnost",
    "hydrant",
    "hygiena",
    "hymna",
    "hysterik",
    "idylka",
    "ihned",
    "ikona",
    "iluze",
    "imunita",
    "infekce",
    "inflace",
    "inkaso",
    "inovace",
    "inspekce",
    "internet",
    "invalida",
    "investor",
    "inzerce",
    "ironie",
    "jablko",
    "jachta",
    "jahoda",
    "jakmile",
    "jakost",
    "jalovec",
    "jantar",
    "jarmark",
    "jaro",
    "jasan",
    "jasno",
    "jatka",
    "javor",
    "jazyk",
    "jedinec",
    "jedle",
    "jednatel",
    "jehlan",
    "jekot",
    "jelen",
    "jelito",
    "jemnost",
    "jenom",
    "jepice",
    "jeseter",
    "jevit",
    "jezdec",
    "jezero",
    "jinak",
    "jindy",
    "jinoch",
    "jiskra",
    "jistota",
    "jitrnice",
    "jizva",
    "jmenovat",
    "jogurt",
    "jurta",
    "kabaret",
    "kabel",
    "kabinet",
    "kachna",
    "kadet",
    "kadidlo",
    "kahan",
    "kajak",
    "kajuta",
    "kakao",
    "kaktus",
    "kalamita",
    "kalhoty",
    "kalibr",
    "kalnost",
    "kamera",
    "kamkoliv",
    "kamna",
    "kanibal",
    "kanoe",
    "kantor",
    "kapalina",
    "kapela",
    "kapitola",
    "kapka",
    "kaple",
    "kapota",
    "kapr",
    "kapusta",
    "kapybara",
    "karamel",
    "karotka",
    "karton",
    "kasa",
    "katalog",
    "katedra",
    "kauce",
    "kauza",
    "kavalec",
    "kazajka",
    "kazeta",
    "kazivost",
    "kdekoliv",
    "kdesi",
    "kedluben",
    "kemp",
    "keramika",
    "kino",
    "klacek",
    "kladivo",
    "klam",
    "klapot",
    "klasika",
    "klaun",
    "klec",
    "klenba",
    "klepat",
    "klesnout",
    "klid",
    "klima",
    "klisna",
    "klobouk",
    "klokan",
    "klopa",
    "kloub",
    "klubovna",
    "klusat",
    "kluzkost",
    "kmen",
    "kmitat",
    "kmotr",
    "kniha",
    "knot",
    "koalice",
    "koberec",
    "kobka",
    "kobliha",
    "kobyla",
    "kocour",
    "kohout",
    "kojenec",
    "kokos",
    "koktejl",
    "kolaps",
    "koleda",
    "kolize",
    "kolo",
    "komando",
    "kometa",
    "komik",
    "komnata",
    "komora",
    "kompas",
    "komunita",
    "konat",
    "koncept",
    "kondice",
    "konec",
    "konfese",
    "kongres",
    "konina",
    "konkurs",
    "kontakt",
    "konzerva",
    "kopanec",
    "kopie",
    "kopnout",
    "koprovka",
    "korbel",
    "korektor",
    "kormidlo",
    "koroptev",
    "korpus",
    "koruna",
    "koryto",
    "korzet",
    "kosatec",
    "kostka",
    "kotel",
    "kotleta",
    "kotoul",
    "koukat",
    "koupelna",
    "kousek",
    "kouzlo",
    "kovboj",
    "koza",
    "kozoroh",
    "krabice",
    "krach",
    "krajina",
    "kralovat",
    "krasopis",
    "kravata",
    "kredit",
    "krejcar",
    "kresba",
    "kreveta",
    "kriket",
    "kritik",
    "krize",
    "krkavec",
    "krmelec",
    "krmivo",
    "krocan",
    "krok",
    "kronika",
    "kropit",
    "kroupa",
    "krovka",
    "krtek",
    "kruhadlo",
    "krupice",
    "krutost",
    "krvinka",
    "krychle",
    "krypta",
    "krystal",
    "kryt",
    "kudlanka",
    "kufr",
    "kujnost",
    "kukla",
    "kulajda",
    "kulich",
    "kulka",
    "kulomet",
    "kultura",
    "kuna",
    "kupodivu",
    "kurt",
    "kurzor",
    "kutil",
    "kvalita",
    "kvasinka",
    "kvestor",
    "kynolog",
    "kyselina",
    "kytara",
    "kytice",
    "kytka",
    "kytovec",
    "kyvadlo",
    "labrador",
    "lachtan",
    "ladnost",
    "laik",
    "lakomec",
    "lamela",
    "lampa",
    "lanovka",
    "lasice",
    "laso",
    "lastura",
    "latinka",
    "lavina",
    "lebka",
    "leckdy",
    "leden",
    "lednice",
    "ledovka",
    "ledvina",
    "legenda",
    "legie",
    "legrace",
    "lehce",
    "lehkost",
    "lehnout",
    "lektvar",
    "lenochod",
    "lentilka",
    "lepenka",
    "lepidlo",
    "letadlo",
    "letec",
    "letmo",
    "letokruh",
    "levhart",
    "levitace",
    "levobok",
    "libra",
    "lichotka",
    "lidojed",
    "lidskost",
    "lihovina",
    "lijavec",
    "lilek",
    "limetka",
    "linie",
    "linka",
    "linoleum",
    "listopad",
    "litina",
    "litovat",
    "lobista",
    "lodivod",
    "logika",
    "logoped",
    "lokalita",
    "loket",
    "lomcovat",
    "lopata",
    "lopuch",
    "lord",
    "losos",
    "lotr",
    "loudal",
    "louh",
    "louka",
    "louskat",
    "lovec",
    "lstivost",
    "lucerna",
    "lucifer",
    "lump",
    "lusk",
    "lustrace",
    "lvice",
    "lyra",
    "lyrika",
    "lysina",
    "madam",
    "madlo",
    "magistr",
    "mahagon",
    "majetek",
    "majitel",
    "majorita",
    "makak",
    "makovice",
    "makrela",
    "malba",
    "malina",
    "malovat",
    "malvice",
    "maminka",
    "mandle",
    "manko",
    "marnost",
    "masakr",
    "maskot",
    "masopust",
    "matice",
    "matrika",
    "maturita",
    "mazanec",
    "mazivo",
    "mazlit",
    "mazurka",
    "mdloba",
    "mechanik",
    "meditace",
    "medovina",
    "melasa",
    "meloun",
    "mentolka",
    "metla",
    "metoda",
    "metr",
    "mezera",
    "migrace",
    "mihnout",
    "mihule",
    "mikina",
    "mikrofon",
    "milenec",
    "milimetr",
    "milost",
    "mimika",
    "mincovna",
    "minibar",
    "minomet",
    "minulost",
    "miska",
    "mistr",
    "mixovat",
    "mladost",
    "mlha",
    "mlhovina",
    "mlok",
    "mlsat",
    "mluvit",
    "mnich",
    "mnohem",
    "mobil",
    "mocnost",
    "modelka",
    "modlitba",
    "mohyla",
    "mokro",
    "molekula",
    "momentka",
    "monarcha",
    "monokl",
    "monstrum",
    "montovat",
    "monzun",
    "mosaz",
    "moskyt",
    "most",
    "motivace",
    "motorka",
    "motyka",
    "moucha",
    "moudrost",
    "mozaika",
    "mozek",
    "mozol",
    "mramor",
    "mravenec",
    "mrkev",
    "mrtvola",
    "mrzet",
    "mrzutost",
    "mstitel",
    "mudrc",
    "muflon",
    "mulat",
    "mumie",
    "munice",
    "muset",
    "mutace",
    "muzeum",
    "muzikant",
    "myslivec",
    "mzda",
    "nabourat",
    "nachytat",
    "nadace",
    "nadbytek",
    "nadhoz",
    "nadobro",
    "nadpis",
    "nahlas",
    "nahnat",
    "nahodile",
    "nahradit",
    "naivita",
    "najednou",
    "najisto",
    "najmout",
    "naklonit",
    "nakonec",
    "nakrmit",
    "nalevo",
    "namazat",
    "namluvit",
    "nanometr",
    "naoko",
    "naopak",
    "naostro",
    "napadat",
    "napevno",
    "naplnit",
    "napnout",
    "naposled",
    "naprosto",
    "narodit",
    "naruby",
    "narychlo",
    "nasadit",
    "nasekat",
    "naslepo",
    "nastat",
    "natolik",
    "navenek",
    "navrch",
    "navzdory",
    "nazvat",
    "nebe",
    "nechat",
    "necky",
    "nedaleko",
    "nedbat",
    "neduh",
    "negace",
    "nehet",
    "nehoda",
    "nejen",
    "nejprve",
    "neklid",
    "nelibost",
    "nemilost",
    "nemoc",
    "neochota",
    "neonka",
    "nepokoj",
    "nerost",
    "nerv",
    "nesmysl",
    "nesoulad",
    "netvor",
    "neuron",
    "nevina",
    "nezvykle",
    "nicota",
    "nijak",
    "nikam",
    "nikdy",
    "nikl",
    "nikterak",
    "nitro",
    "nocleh",
    "nohavice",
    "nominace",
    "nora",
    "norek",
    "nositel",
    "nosnost",
    "nouze",
    "noviny",
    "novota",
    "nozdra",
    "nuda",
    "nudle",
    "nuget",
    "nutit",
    "nutnost",
    "nutrie",
    "nymfa",
    "obal",
    "obarvit",
    "obava",
    "obdiv",
    "obec",
    "obehnat",
    "obejmout",
    "obezita",
    "obhajoba",
    "obilnice",
    "objasnit",
    "objekt",
    "obklopit",
    "oblast",
    "oblek",
    "obliba",
    "obloha",
    "obluda",
    "obnos",
    "obohatit",
    "obojek",
    "obout",
    "obrazec",
    "obrna",
    "obruba",
    "obrys",
    "obsah",
    "obsluha",
    "obstarat",
    "obuv",
    "obvaz",
    "obvinit",
    "obvod",
    "obvykle",
    "obyvatel",
    "obzor",
    "ocas",
    "ocel",
    "ocenit",
    "ochladit",
    "ochota",
    "ochrana",
    "ocitnout",
    "odboj",
    "odbyt",
    "odchod",
    "odcizit",
    "odebrat",
    "odeslat",
    "odevzdat",
    "odezva",
    "odhadce",
    "odhodit",
    "odjet",
    "odjinud",
    "odkaz",
    "odkoupit",
    "odliv",
    "odluka",
    "odmlka",
    "odolnost",
    "odpad",
    "odpis",
    "odplout",
    "odpor",
    "odpustit",
    "odpykat",
    "odrazka",
    "odsoudit",
    "odstup",
    "odsun",
    "odtok",
    "odtud",
    "odvaha",
    "odveta",
    "odvolat",
    "odvracet",
    "odznak",
    "ofina",
    "ofsajd",
    "ohlas",
    "ohnisko",
    "ohrada",
    "ohrozit",
    "ohryzek",
    "okap",
    "okenice",
    "oklika",
    "okno",
    "okouzlit",
    "okovy",
    "okrasa",
    "okres",
    "okrsek",
    "okruh",
    "okupant",
    "okurka",
    "okusit",
    "olejnina",
    "olizovat",
    "omak",
    "omeleta",
    "omezit",
    "omladina",
    "omlouvat",
    "omluva",
    "omyl",
    "onehdy",
    "opakovat",
    "opasek",
    "operace",
    "opice",
    "opilost",
    "opisovat",
    "opora",
    "opozice",
    "opravdu",
    "oproti",
    "orbital",
    "orchestr",
    "orgie",
    "orlice",
    "orloj",
    "ortel",
    "osada",
    "oschnout",
    "osika",
    "osivo",
    "oslava",
    "oslepit",
    "oslnit",
    "oslovit",
    "osnova",
    "osoba",
    "osolit",
    "ospalec",
    "osten",
    "ostraha",
    "ostuda",
    "ostych",
    "osvojit",
    "oteplit",
    "otisk",
    "otop",
    "otrhat",
    "otrlost",
    "otrok",
    "otruby",
    "otvor",
    "ovanout",
    "ovar",
    "oves",
    "ovlivnit",
    "ovoce",
    "oxid",
    "ozdoba",
    "pachatel",
    "pacient",
    "padouch",
    "pahorek",
    "pakt",
    "palanda",
    "palec",
    "palivo",
    "paluba",
    "pamflet",
    "pamlsek",
    "panenka",
    "panika",
    "panna",
    "panovat",
    "panstvo",
    "pantofle",
    "paprika",
    "parketa",
    "parodie",
    "parta",
    "paruka",
    "paryba",
    "paseka",
    "pasivita",
    "pastelka",
    "patent",
    "patrona",
    "pavouk",
    "pazneht",
    "pazourek",
    "pecka",
    "pedagog",
    "pejsek",
    "peklo",
    "peloton",
    "penalta",
    "pendrek",
    "penze",
    "periskop",
    "pero",
    "pestrost",
    "petarda",
    "petice",
    "petrolej",
    "pevnina",
    "pexeso",
    "pianista",
    "piha",
    "pijavice",
    "pikle",
    "piknik",
    "pilina",
    "pilnost",
    "pilulka",
    "pinzeta",
    "pipeta",
    "pisatel",
    "pistole",
    "pitevna",
    "pivnice",
    "pivovar",
    "placenta",
    "plakat",
    "plamen",
    "planeta",
    "plastika",
    "platit",
    "plavidlo",
    "plaz",
    "plech",
    "plemeno",
    "plenta",
    "ples",
    "pletivo",
    "plevel",
    "plivat",
    "plnit",
    "plno",
    "plocha",
    "plodina",
    "plomba",
    "plout",
    "pluk",
    "plyn",
    "pobavit",
    "pobyt",
    "pochod",
    "pocit",
    "poctivec",
    "podat",
    "podcenit",
    "podepsat",
    "podhled",
    "podivit",
    "podklad",
    "podmanit",
    "podnik",
    "podoba",
    "podpora",
    "podraz",
    "podstata",
    "podvod",
    "podzim",
    "poezie",
    "pohanka",
    "pohnutka",
    "pohovor",
    "pohroma",
    "pohyb",
    "pointa",
    "pojistka",
    "pojmout",
    "pokazit",
    "pokles",
    "pokoj",
    "pokrok",
    "pokuta",
    "pokyn",
    "poledne",
    "polibek",
    "polknout",
    "poloha",
    "polynom",
    "pomalu",
    "pominout",
    "pomlka",
    "pomoc",
    "pomsta",
    "pomyslet",
    "ponechat",
    "ponorka",
    "ponurost",
    "popadat",
    "popel",
    "popisek",
    "poplach",
    "poprosit",
    "popsat",
    "popud",
    "poradce",
    "porce",
    "porod",
    "porucha",
    "poryv",
    "posadit",
    "posed",
    "posila",
    "poskok",
    "poslanec",
    "posoudit",
    "pospolu",
    "postava",
    "posudek",
    "posyp",
    "potah",
    "potkan",
    "potlesk",
    "potomek",
    "potrava",
    "potupa",
    "potvora",
    "poukaz",
    "pouto",
    "pouzdro",
    "povaha",
    "povidla",
    "povlak",
    "povoz",
    "povrch",
    "povstat",
    "povyk",
    "povzdech",
    "pozdrav",
    "pozemek",
    "poznatek",
    "pozor",
    "pozvat",
    "pracovat",
    "prahory",
    "praktika",
    "prales",
    "praotec",
    "praporek",
    "prase",
    "pravda",
    "princip",
    "prkno",
    "probudit",
    "procento",
    "prodej",
    "profese",
    "prohra",
    "projekt",
    "prolomit",
    "promile",
    "pronikat",
    "propad",
    "prorok",
    "prosba",
    "proton",
    "proutek",
    "provaz",
    "prskavka",
    "prsten",
    "prudkost",
    "prut",
    "prvek",
    "prvohory",
    "psanec",
    "psovod",
    "pstruh",
    "ptactvo",
    "puberta",
    "puch",
    "pudl",
    "pukavec",
    "puklina",
    "pukrle",
    "pult",
    "pumpa",
    "punc",
    "pupen",
    "pusa",
    "pusinka",
    "pustina",
    "putovat",
    "putyka",
    "pyramida",
    "pysk",
    "pytel",
    "racek",
    "rachot",
    "radiace",
    "radnice",
    "radon",
    "raft",
    "ragby",
    "raketa",
    "rakovina",
    "rameno",
    "rampouch",
    "rande",
    "rarach",
    "rarita",
    "rasovna",
    "rastr",
    "ratolest",
    "razance",
    "razidlo",
    "reagovat",
    "reakce",
    "recept",
    "redaktor",
    "referent",
    "reflex",
    "rejnok",
    "reklama",
    "rekord",
    "rekrut",
    "rektor",
    "reputace",
    "revize",
    "revma",
    "revolver",
    "rezerva",
    "riskovat",
    "riziko",
    "robotika",
    "rodokmen",
    "rohovka",
    "rokle",
    "rokoko",
    "romaneto",
    "ropovod",
    "ropucha",
    "rorejs",
    "rosol",
    "rostlina",
    "rotmistr",
    "rotoped",
    "rotunda",
    "roubenka",
    "roucho",
    "roup",
    "roura",
    "rovina",
    "rovnice",
    "rozbor",
    "rozchod",
    "rozdat",
    "rozeznat",
    "rozhodce",
    "rozinka",
    "rozjezd",
    "rozkaz",
    "rozloha",
    "rozmar",
    "rozpad",
    "rozruch",
    "rozsah",
    "roztok",
    "rozum",
    "rozvod",
    "rubrika",
    "ruchadlo",
    "rukavice",
    "rukopis",
    "ryba",
    "rybolov",
    "rychlost",
    "rydlo",
    "rypadlo",
    "rytina",
    "ryzost",
    "sadista",
    "sahat",
    "sako",
    "samec",
    "samizdat",
    "samota",
    "sanitka",
    "sardinka",
    "sasanka",
    "satelit",
    "sazba",
    "sazenice",
    "sbor",
    "schovat",
    "sebranka",
    "secese",
    "sedadlo",
    "sediment",
    "sedlo",
    "sehnat",
    "sejmout",
    "sekera",
    "sekta",
    "sekunda",
    "sekvoje",
    "semeno",
    "seno",
    "servis",
    "sesadit",
    "seshora",
    "seskok",
    "seslat",
    "sestra",
    "sesuv",
    "sesypat",
    "setba",
    "setina",
    "setkat",
    "setnout",
    "setrvat",
    "sever",
    "seznam",
    "shoda",
    "shrnout",
    "sifon",
    "silnice",
    "sirka",
    "sirotek",
    "sirup",
    "situace",
    "skafandr",
    "skalisko",
    "skanzen",
    "skaut",
    "skeptik",
    "skica",
    "skladba",
    "sklenice",
    "sklo",
    "skluz",
    "skoba",
    "skokan",
    "skoro",
    "skripta",
    "skrz",
    "skupina",
    "skvost",
    "skvrna",
    "slabika",
    "sladidlo",
    "slanina",
    "slast",
    "slavnost",
    "sledovat",
    "slepec",
    "sleva",
    "slezina",
    "slib",
    "slina",
    "sliznice",
    "slon",
    "sloupek",
    "slovo",
    "sluch",
    "sluha",
    "slunce",
    "slupka",
    "slza",
    "smaragd",
    "smetana",
    "smilstvo",
    "smlouva",
    "smog",
    "smrad",
    "smrk",
    "smrtka",
    "smutek",
    "smysl",
    "snad",
    "snaha",
    "snob",
    "sobota",
    "socha",
    "sodovka",
    "sokol",
    "sopka",
    "sotva",
    "souboj",
    "soucit",
    "soudce",
    "souhlas",
    "soulad",
    "soumrak",
    "souprava",
    "soused",
    "soutok",
    "souviset",
    "spalovna",
    "spasitel",
    "spis",
    "splav",
    "spodek",
    "spojenec",
    "spolu",
    "sponzor",
    "spornost",
    "spousta",
    "sprcha",
    "spustit",
    "sranda",
    "sraz",
    "srdce",
    "srna",
    "srnec",
    "srovnat",
    "srpen",
    "srst",
    "srub",
    "stanice",
    "starosta",
    "statika",
    "stavba",
    "stehno",
    "stezka",
    "stodola",
    "stolek",
    "stopa",
    "storno",
    "stoupat",
    "strach",
    "stres",
    "strhnout",
    "strom",
    "struna",
    "studna",
    "stupnice",
    "stvol",
    "styk",
    "subjekt",
    "subtropy",
    "suchar",
    "sudost",
    "sukno",
    "sundat",
    "sunout",
    "surikata",
    "surovina",
    "svah",
    "svalstvo",
    "svetr",
    "svatba",
    "svazek",
    "svisle",
    "svitek",
    "svoboda",
    "svodidlo",
    "svorka",
    "svrab",
    "sykavka",
    "sykot",
    "synek",
    "synovec",
    "sypat",
    "sypkost",
    "syrovost",
    "sysel",
    "sytost",
    "tabletka",
    "tabule",
    "tahoun",
    "tajemno",
    "tajfun",
    "tajga",
    "tajit",
    "tajnost",
    "taktika",
    "tamhle",
    "tampon",
    "tancovat",
    "tanec",
    "tanker",
    "tapeta",
    "tavenina",
    "tazatel",
    "technika",
    "tehdy",
    "tekutina",
    "telefon",
    "temnota",
    "tendence",
    "tenista",
    "tenor",
    "teplota",
    "tepna",
    "teprve",
    "terapie",
    "termoska",
    "textil",
    "ticho",
    "tiskopis",
    "titulek",
    "tkadlec",
    "tkanina",
    "tlapka",
    "tleskat",
    "tlukot",
    "tlupa",
    "tmel",
    "toaleta",
    "topinka",
    "topol",
    "torzo",
    "touha",
    "toulec",
    "tradice",
    "traktor",
    "tramp",
    "trasa",
    "traverza",
    "trefit",
    "trest",
    "trezor",
    "trhavina",
    "trhlina",
    "trochu",
    "trojice",
    "troska",
    "trouba",
    "trpce",
    "trpitel",
    "trpkost",
    "trubec",
    "truchlit",
    "truhlice",
    "trus",
    "trvat",
    "tudy",
    "tuhnout",
    "tuhost",
    "tundra",
    "turista",
    "turnaj",
    "tuzemsko",
    "tvaroh",
    "tvorba",
    "tvrdost",
    "tvrz",
    "tygr",
    "tykev",
    "ubohost",
    "uboze",
    "ubrat",
    "ubrousek",
    "ubrus",
    "ubytovna",
    "ucho",
    "uctivost",
    "udivit",
    "uhradit",
    "ujednat",
    "ujistit",
    "ujmout",
    "ukazatel",
    "uklidnit",
    "uklonit",
    "ukotvit",
    "ukrojit",
    "ulice",
    "ulita",
    "ulovit",
    "umyvadlo",
    "unavit",
    "uniforma",
    "uniknout",
    "upadnout",
    "uplatnit",
    "uplynout",
    "upoutat",
    "upravit",
    "uran",
    "urazit",
    "usednout",
    "usilovat",
    "usmrtit",
    "usnadnit",
    "usnout",
    "usoudit",
    "ustlat",
    "ustrnout",
    "utahovat",
    "utkat",
    "utlumit",
    "utonout",
    "utopenec",
    "utrousit",
    "uvalit",
    "uvolnit",
    "uvozovka",
    "uzdravit",
    "uzel",
    "uzenina",
    "uzlina",
    "uznat",
    "vagon",
    "valcha",
    "valoun",
    "vana",
    "vandal",
    "vanilka",
    "varan",
    "varhany",
    "varovat",
    "vcelku",
    "vchod",
    "vdova",
    "vedro",
    "vegetace",
    "vejce",
    "velbloud",
    "veletrh",
    "velitel",
    "velmoc",
    "velryba",
    "venkov",
    "veranda",
    "verze",
    "veselka",
    "veskrze",
    "vesnice",
    "vespodu",
    "vesta",
    "veterina",
    "veverka",
    "vibrace",
    "vichr",
    "videohra",
    "vidina",
    "vidle",
    "vila",
    "vinice",
    "viset",
    "vitalita",
    "vize",
    "vizitka",
    "vjezd",
    "vklad",
    "vkus",
    "vlajka",
    "vlak",
    "vlasec",
    "vlevo",
    "vlhkost",
    "vliv",
    "vlnovka",
    "vloupat",
    "vnucovat",
    "vnuk",
    "voda",
    "vodivost",
    "vodoznak",
    "vodstvo",
    "vojensky",
    "vojna",
    "vojsko",
    "volant",
    "volba",
    "volit",
    "volno",
    "voskovka",
    "vozidlo",
    "vozovna",
    "vpravo",
    "vrabec",
    "vracet",
    "vrah",
    "vrata",
    "vrba",
    "vrcholek",
    "vrhat",
    "vrstva",
    "vrtule",
    "vsadit",
    "vstoupit",
    "vstup",
    "vtip",
    "vybavit",
    "vybrat",
    "vychovat",
    "vydat",
    "vydra",
    "vyfotit",
    "vyhledat",
    "vyhnout",
    "vyhodit",
    "vyhradit",
    "vyhubit",
    "vyjasnit",
    "vyjet",
    "vyjmout",
    "vyklopit",
    "vykonat",
    "vylekat",
    "vymazat",
    "vymezit",
    "vymizet",
    "vymyslet",
    "vynechat",
    "vynikat",
    "vynutit",
    "vypadat",
    "vyplatit",
    "vypravit",
    "vypustit",
    "vyrazit",
    "vyrovnat",
    "vyrvat",
    "vyslovit",
    "vysoko",
    "vystavit",
    "vysunout",
    "vysypat",
    "vytasit",
    "vytesat",
    "vytratit",
    "vyvinout",
    "vyvolat",
    "vyvrhel",
    "vyzdobit",
    "vyznat",
    "vzadu",
    "vzbudit",
    "vzchopit",
    "vzdor",
    "vzduch",
    "vzdychat",
    "vzestup",
    "vzhledem",
    "vzkaz",
    "vzlykat",
    "vznik",
    "vzorek",
    "vzpoura",
    "vztah",
    "vztek",
    "xylofon",
    "zabrat",
    "zabydlet",
    "zachovat",
    "zadarmo",
    "zadusit",
    "zafoukat",
    "zahltit",
    "zahodit",
    "zahrada",
    "zahynout",
    "zajatec",
    "zajet",
    "zajistit",
    "zaklepat",
    "zakoupit",
    "zalepit",
    "zamezit",
    "zamotat",
    "zamyslet",
    "zanechat",
    "zanikat",
    "zaplatit",
    "zapojit",
    "zapsat",
    "zarazit",
    "zastavit",
    "zasunout",
    "zatajit",
    "zatemnit",
    "zatknout",
    "zaujmout",
    "zavalit",
    "zavelet",
    "zavinit",
    "zavolat",
    "zavrtat",
    "zazvonit",
    "zbavit",
    "zbrusu",
    "zbudovat",
    "zbytek",
    "zdaleka",
    "zdarma",
    "zdatnost",
    "zdivo",
    "zdobit",
    "zdroj",
    "zdvih",
    "zdymadlo",
    "zelenina",
    "zeman",
    "zemina",
    "zeptat",
    "zezadu",
    "zezdola",
    "zhatit",
    "zhltnout",
    "zhluboka",
    "zhotovit",
    "zhruba",
    "zima",
    "zimnice",
    "zjemnit",
    "zklamat",
    "zkoumat",
    "zkratka",
    "zkumavka",
    "zlato",
    "zlehka",
    "zloba",
    "zlom",
    "zlost",
    "zlozvyk",
    "zmapovat",
    "zmar",
    "zmatek",
    "zmije",
    "zmizet",
    "zmocnit",
    "zmodrat",
    "zmrzlina",
    "zmutovat",
    "znak",
    "znalost",
    "znamenat",
    "znovu",
    "zobrazit",
    "zotavit",
    "zoubek",
    "zoufale",
    "zplodit",
    "zpomalit",
    "zprava",
    "zprostit",
    "zprudka",
    "zprvu",
    "zrada",
    "zranit",
    "zrcadlo",
    "zrnitost",
    "zrno",
    "zrovna",
    "zrychlit",
    "zrzavost",
    "zticha",
    "ztratit",
    "zubovina",
    "zubr",
    "zvednout",
    "zvenku",
    "zvesela",
    "zvon",
    "zvrat",
    "zvukovod",
    "zvyk"
], Jte = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], Qte = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], ere = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], tre = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "academie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquerir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adequat",
    "adhesif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aerer",
    "aeronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agreable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algebre",
    "algue",
    "aliener",
    "aliment",
    "alleger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alveole",
    "amateur",
    "ambigu",
    "ambre",
    "amenager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "aneantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "aperitif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "arteriel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "banniere",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "belier",
    "belote",
    "benefice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "betail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "breche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "cafeine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "camera",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cedille",
    "ceinture",
    "celeste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cerebral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chequier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimere",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinema",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohesion",
    "coiffer",
    "coincer",
    "colere",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comedie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortege",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "creature",
    "crediter",
    "cremeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critere",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillere",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "debattre",
    "debiter",
    "deborder",
    "debrider",
    "debutant",
    "decaler",
    "decembre",
    "dechirer",
    "decider",
    "declarer",
    "decorer",
    "decrire",
    "decupler",
    "dedale",
    "deductif",
    "deesse",
    "defensif",
    "defiler",
    "defrayer",
    "degager",
    "degivrer",
    "deglutir",
    "degrafer",
    "dejeuner",
    "delice",
    "deloger",
    "demander",
    "demeurer",
    "demolir",
    "denicher",
    "denouer",
    "dentelle",
    "denuder",
    "depart",
    "depenser",
    "dephaser",
    "deplacer",
    "deposer",
    "deranger",
    "derober",
    "desastre",
    "descente",
    "desert",
    "designer",
    "desobeir",
    "dessiner",
    "destrier",
    "detacher",
    "detester",
    "detourer",
    "detresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "differer",
    "digerer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "eblouir",
    "ecarter",
    "echarpe",
    "echelle",
    "eclairer",
    "eclipse",
    "eclore",
    "ecluse",
    "ecole",
    "economie",
    "ecorce",
    "ecouter",
    "ecraser",
    "ecremer",
    "ecrivain",
    "ecrou",
    "ecume",
    "ecureuil",
    "edifier",
    "eduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "egaliser",
    "egarer",
    "ejecter",
    "elaborer",
    "elargir",
    "electron",
    "elegant",
    "elephant",
    "eleve",
    "eligible",
    "elitisme",
    "eloge",
    "elucider",
    "eluder",
    "emballer",
    "embellir",
    "embryon",
    "emeraude",
    "emission",
    "emmener",
    "emotion",
    "emouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "emulsion",
    "encadrer",
    "enchere",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "energie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "enigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "enumerer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "eolien",
    "epaissir",
    "epargne",
    "epatant",
    "epaule",
    "epicerie",
    "epidemie",
    "epier",
    "epilogue",
    "epine",
    "episode",
    "epitaphe",
    "epoque",
    "epreuve",
    "eprouver",
    "epuisant",
    "equerre",
    "equipe",
    "eriger",
    "erosion",
    "erreur",
    "eruption",
    "escalier",
    "espadon",
    "espece",
    "espiegle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "etagere",
    "etaler",
    "etanche",
    "etatique",
    "eteindre",
    "etendoir",
    "eternel",
    "ethanol",
    "ethique",
    "ethnie",
    "etirer",
    "etoffer",
    "etoile",
    "etonnant",
    "etourdir",
    "etrange",
    "etroit",
    "etude",
    "euphorie",
    "evaluer",
    "evasion",
    "eventail",
    "evidence",
    "eviter",
    "evolutif",
    "evoquer",
    "exact",
    "exagerer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "executer",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expedier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "febrile",
    "feconder",
    "federer",
    "felin",
    "femme",
    "femur",
    "fendoir",
    "feodal",
    "fermer",
    "feroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "fevrier",
    "fiasco",
    "ficeler",
    "fictif",
    "fidele",
    "figure",
    "filature",
    "filetage",
    "filiere",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fleau",
    "fleche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougere",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "fregate",
    "freiner",
    "frelon",
    "fremir",
    "frenesie",
    "frere",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "geant",
    "gelatine",
    "gelule",
    "gendarme",
    "general",
    "genie",
    "genou",
    "gentil",
    "geologie",
    "geometre",
    "geranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyere",
    "guepard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "helium",
    "hematome",
    "herbe",
    "herisson",
    "hermine",
    "heron",
    "hesiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogene",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiene",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "imperial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inedit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingerer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irreel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvenile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacerer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "legal",
    "leger",
    "legume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lezard",
    "liasse",
    "liberer",
    "libre",
    "licence",
    "licorne",
    "liege",
    "lievre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "lineaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisiere",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumiere",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "malefice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "materiel",
    "matiere",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "mechant",
    "meconnu",
    "medaille",
    "medecin",
    "mediter",
    "meduse",
    "meilleur",
    "melange",
    "melodie",
    "membre",
    "memoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "merite",
    "merle",
    "messager",
    "mesure",
    "metal",
    "meteore",
    "methode",
    "metier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "mineral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murene",
    "murmure",
    "muscle",
    "museum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystere",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nebuleux",
    "nectar",
    "nefaste",
    "negation",
    "negliger",
    "negocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numero",
    "nuptial",
    "nuque",
    "nutritif",
    "obeir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "ocean",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onereux",
    "onirique",
    "opale",
    "opaque",
    "operer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygene",
    "ozone",
    "paisible",
    "palace",
    "palmares",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pasteque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pelican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "penetrer",
    "penible",
    "pensif",
    "penurie",
    "pepite",
    "peplum",
    "perdrix",
    "perforer",
    "periode",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "petale",
    "petit",
    "petrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "piece",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poesie",
    "poete",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "ponderer",
    "poney",
    "portique",
    "position",
    "posseder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "precieux",
    "predire",
    "prefixe",
    "prelude",
    "prenom",
    "presence",
    "pretexte",
    "prevoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "probleme",
    "proceder",
    "prodige",
    "profond",
    "progres",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospere",
    "proteger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quietude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "reactif",
    "reagir",
    "realiser",
    "reanimer",
    "recevoir",
    "reciter",
    "reclamer",
    "recolter",
    "recruter",
    "reculer",
    "recycler",
    "rediger",
    "redouter",
    "refaire",
    "reflexe",
    "reformer",
    "refrain",
    "refuge",
    "regalien",
    "region",
    "reglage",
    "regulier",
    "reiterer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remede",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "reserve",
    "resineux",
    "resoudre",
    "respect",
    "rester",
    "resultat",
    "retablir",
    "retenir",
    "reticule",
    "retomber",
    "retracer",
    "reunion",
    "reussir",
    "revanche",
    "revivre",
    "revolte",
    "revulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "riviere",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scelerat",
    "scenario",
    "sceptre",
    "schema",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "seance",
    "secable",
    "secher",
    "secouer",
    "secreter",
    "sedatif",
    "seduire",
    "seigneur",
    "sejour",
    "selectif",
    "semaine",
    "sembler",
    "semence",
    "seminal",
    "senateur",
    "sensible",
    "sentence",
    "separer",
    "sequence",
    "serein",
    "sergent",
    "serieux",
    "serrure",
    "serum",
    "service",
    "sesame",
    "sevir",
    "sevrage",
    "sextuple",
    "sideral",
    "siecle",
    "sieger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincere",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "special",
    "sphere",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succes",
    "sucre",
    "suffixe",
    "suggerer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symetrie",
    "synapse",
    "syntaxe",
    "systeme",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "temoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tetine",
    "texte",
    "theme",
    "theorie",
    "therapie",
    "thorax",
    "tibia",
    "tiede",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolerant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trefle",
    "tremper",
    "tresor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "vegetal",
    "vehicule",
    "veinard",
    "veloce",
    "vendredi",
    "venerer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "verin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "veteran",
    "vetuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "video",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipere",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xenon",
    "yacht",
    "zebre",
    "zenith",
    "zeste",
    "zoologie"
], rre = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
], nre = [
    "abaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "accion",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "acido",
    "aclarar",
    "acne",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aereo",
    "afectar",
    "aficion",
    "afinar",
    "afirmar",
    "agil",
    "agitar",
    "agonia",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "aguila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacran",
    "alambre",
    "alarma",
    "alba",
    "album",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodon",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almibar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ambar",
    "ambito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "anden",
    "anemia",
    "angulo",
    "anillo",
    "animo",
    "anis",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "anadir",
    "anejo",
    "ano",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "arana",
    "arar",
    "arbitro",
    "arbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "area",
    "arido",
    "aries",
    "armonia",
    "arnes",
    "aroma",
    "arpa",
    "arpon",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "aspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "atico",
    "atleta",
    "atomo",
    "atraer",
    "atroz",
    "atun",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avion",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafran",
    "azar",
    "azote",
    "azucar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahia",
    "baile",
    "bajar",
    "balanza",
    "balcon",
    "balde",
    "bambu",
    "banco",
    "banda",
    "bano",
    "barba",
    "barco",
    "barniz",
    "barro",
    "bascula",
    "baston",
    "basura",
    "batalla",
    "bateria",
    "batir",
    "batuta",
    "baul",
    "bazar",
    "bebe",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsai",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botin",
    "boveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufon",
    "buho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzon",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadaver",
    "cadena",
    "caer",
    "cafe",
    "caida",
    "caiman",
    "caja",
    "cajon",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cancer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "cana",
    "canon",
    "caoba",
    "caos",
    "capaz",
    "capitan",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbon",
    "carcel",
    "careta",
    "carga",
    "carino",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "celebre",
    "celoso",
    "celula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "cesped",
    "cetro",
    "chacal",
    "chaleco",
    "champu",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclon",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "cipres",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clinica",
    "cobre",
    "coccion",
    "cochino",
    "cocina",
    "coco",
    "codigo",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojin",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "comodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazon",
    "corbata",
    "corcho",
    "cordon",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "craneo",
    "crater",
    "crear",
    "crecer",
    "creido",
    "crema",
    "cria",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "cronica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupon",
    "cupula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "datil",
    "deber",
    "debil",
    "decada",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfin",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvio",
    "detalle",
    "detener",
    "deuda",
    "dia",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "dificil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseno",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragon",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueno",
    "dulce",
    "duo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ebano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edicion",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "elite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emocion",
    "empate",
    "empeno",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encia",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engano",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "ensenar",
    "entero",
    "entrar",
    "envase",
    "envio",
    "epoca",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espia",
    "esposa",
    "espuma",
    "esqui",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "etica",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "exito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fabrica",
    "fabula",
    "fachada",
    "facil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraon",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fertil",
    "fervor",
    "festin",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficcion",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "fluor",
    "fobia",
    "foca",
    "fogata",
    "fogon",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "fragil",
    "franja",
    "frase",
    "fraude",
    "freir",
    "freno",
    "fresa",
    "frio",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "funcion",
    "funda",
    "furgon",
    "furia",
    "fusil",
    "futbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galeria",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilan",
    "gemelo",
    "gemir",
    "gen",
    "genero",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "grafico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grua",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guia",
    "guino",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "habil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazana",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "heroe",
    "hervir",
    "hielo",
    "hierro",
    "higado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "humedo",
    "humilde",
    "humo",
    "hundir",
    "huracan",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "idolo",
    "iglesia",
    "iglu",
    "igual",
    "ilegal",
    "ilusion",
    "imagen",
    "iman",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "indice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interes",
    "intimo",
    "intuir",
    "inutil",
    "invierno",
    "ira",
    "iris",
    "ironia",
    "isla",
    "islote",
    "jabali",
    "jabon",
    "jamon",
    "jarabe",
    "jardin",
    "jarra",
    "jaula",
    "jazmin",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "jupiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladron",
    "lagarto",
    "lagrima",
    "laguna",
    "laico",
    "lamer",
    "lamina",
    "lampara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lapiz",
    "largo",
    "larva",
    "lastima",
    "lata",
    "latex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "leccion",
    "leche",
    "lector",
    "leer",
    "legion",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "lena",
    "leon",
    "leopardo",
    "lesion",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "lider",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "limite",
    "limon",
    "limpio",
    "lince",
    "lindo",
    "linea",
    "lingote",
    "lino",
    "linterna",
    "liquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "locion",
    "loco",
    "locura",
    "logica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maiz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mama",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniqui",
    "manjar",
    "mano",
    "manso",
    "manta",
    "manana",
    "mapa",
    "maquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "marmol",
    "marron",
    "martes",
    "marzo",
    "masa",
    "mascara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "maximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "medula",
    "mejilla",
    "mejor",
    "melena",
    "melon",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menu",
    "mercado",
    "merengue",
    "merito",
    "mes",
    "meson",
    "meta",
    "meter",
    "metodo",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millon",
    "mimo",
    "mina",
    "minero",
    "minimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "mocion",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "mono",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "movil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muneca",
    "mural",
    "muro",
    "musculo",
    "museo",
    "musgo",
    "musica",
    "muslo",
    "nacar",
    "nacion",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "nausea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "nectar",
    "negar",
    "negocio",
    "negro",
    "neon",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "ninez",
    "nino",
    "nitido",
    "nivel",
    "nobleza",
    "noche",
    "nomina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "nucleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "numero",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "oceano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oido",
    "oir",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opcion",
    "opera",
    "opinar",
    "oponer",
    "optar",
    "optica",
    "opuesto",
    "oracion",
    "orador",
    "oral",
    "orbita",
    "orca",
    "orden",
    "oreja",
    "organo",
    "orgia",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadia",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otono",
    "otro",
    "oveja",
    "ovulo",
    "oxido",
    "oxigeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "pagina",
    "pago",
    "pais",
    "pajaro",
    "palabra",
    "palco",
    "paleta",
    "palido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "panico",
    "pantera",
    "panuelo",
    "papa",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "parpado",
    "parque",
    "parrafo",
    "parte",
    "pasar",
    "paseo",
    "pasion",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peaton",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldano",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "penon",
    "peon",
    "peor",
    "pepino",
    "pequeno",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pesimo",
    "pestana",
    "petalo",
    "petroleo",
    "pez",
    "pezuna",
    "picar",
    "pichon",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "pina",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "piton",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesia",
    "poeta",
    "polen",
    "policia",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porcion",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "principe",
    "prision",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "proximo",
    "prueba",
    "publico",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmon",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "punal",
    "puno",
    "pupa",
    "pupila",
    "pure",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "quimica",
    "quince",
    "quitar",
    "rabano",
    "rabia",
    "rabo",
    "racion",
    "radical",
    "raiz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rapido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razon",
    "reaccion",
    "realidad",
    "rebano",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refran",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehen",
    "reino",
    "reir",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "reves",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rigido",
    "rigor",
    "rincon",
    "rinon",
    "rio",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubi",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sabado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmon",
    "salon",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sancion",
    "sandia",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sarten",
    "sastre",
    "satan",
    "sauna",
    "saxofon",
    "seccion",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "senal",
    "senor",
    "separar",
    "sepia",
    "sequia",
    "ser",
    "serie",
    "sermon",
    "servir",
    "sesenta",
    "sesion",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "silaba",
    "silbar",
    "silencio",
    "silla",
    "simbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "solido",
    "soltar",
    "solucion",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sosten",
    "sotano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueno",
    "suerte",
    "sufrir",
    "sujeto",
    "sultan",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureno",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabu",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talon",
    "tamano",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapon",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazon",
    "teatro",
    "techo",
    "tecla",
    "tecnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "telefono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoria",
    "terapia",
    "terco",
    "termino",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburon",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "timido",
    "timo",
    "tinta",
    "tio",
    "tipico",
    "tipo",
    "tira",
    "tiron",
    "titan",
    "titere",
    "titulo",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "torax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "toxico",
    "trabajo",
    "tractor",
    "traer",
    "trafico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trebol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tuberia",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "tunel",
    "tunica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "ulcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "una",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "util",
    "utopia",
    "uva",
    "vaca",
    "vacio",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "valido",
    "valle",
    "valor",
    "valvula",
    "vampiro",
    "vara",
    "variar",
    "varon",
    "vaso",
    "vecino",
    "vector",
    "vehiculo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "via",
    "viaje",
    "vibrar",
    "vicio",
    "victima",
    "vida",
    "video",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "vinedo",
    "violin",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "vispera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcan",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
], ire = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], ore = [
    "abacate",
    "abaixo",
    "abalar",
    "abater",
    "abduzir",
    "abelha",
    "aberto",
    "abismo",
    "abotoar",
    "abranger",
    "abreviar",
    "abrigar",
    "abrupto",
    "absinto",
    "absoluto",
    "absurdo",
    "abutre",
    "acabado",
    "acalmar",
    "acampar",
    "acanhar",
    "acaso",
    "aceitar",
    "acelerar",
    "acenar",
    "acervo",
    "acessar",
    "acetona",
    "achatar",
    "acidez",
    "acima",
    "acionado",
    "acirrar",
    "aclamar",
    "aclive",
    "acolhida",
    "acomodar",
    "acoplar",
    "acordar",
    "acumular",
    "acusador",
    "adaptar",
    "adega",
    "adentro",
    "adepto",
    "adequar",
    "aderente",
    "adesivo",
    "adeus",
    "adiante",
    "aditivo",
    "adjetivo",
    "adjunto",
    "admirar",
    "adorar",
    "adquirir",
    "adubo",
    "adverso",
    "advogado",
    "aeronave",
    "afastar",
    "aferir",
    "afetivo",
    "afinador",
    "afivelar",
    "aflito",
    "afluente",
    "afrontar",
    "agachar",
    "agarrar",
    "agasalho",
    "agenciar",
    "agilizar",
    "agiota",
    "agitado",
    "agora",
    "agradar",
    "agreste",
    "agrupar",
    "aguardar",
    "agulha",
    "ajoelhar",
    "ajudar",
    "ajustar",
    "alameda",
    "alarme",
    "alastrar",
    "alavanca",
    "albergue",
    "albino",
    "alcatra",
    "aldeia",
    "alecrim",
    "alegria",
    "alertar",
    "alface",
    "alfinete",
    "algum",
    "alheio",
    "aliar",
    "alicate",
    "alienar",
    "alinhar",
    "aliviar",
    "almofada",
    "alocar",
    "alpiste",
    "alterar",
    "altitude",
    "alucinar",
    "alugar",
    "aluno",
    "alusivo",
    "alvo",
    "amaciar",
    "amador",
    "amarelo",
    "amassar",
    "ambas",
    "ambiente",
    "ameixa",
    "amenizar",
    "amido",
    "amistoso",
    "amizade",
    "amolador",
    "amontoar",
    "amoroso",
    "amostra",
    "amparar",
    "ampliar",
    "ampola",
    "anagrama",
    "analisar",
    "anarquia",
    "anatomia",
    "andaime",
    "anel",
    "anexo",
    "angular",
    "animar",
    "anjo",
    "anomalia",
    "anotado",
    "ansioso",
    "anterior",
    "anuidade",
    "anunciar",
    "anzol",
    "apagador",
    "apalpar",
    "apanhado",
    "apego",
    "apelido",
    "apertada",
    "apesar",
    "apetite",
    "apito",
    "aplauso",
    "aplicada",
    "apoio",
    "apontar",
    "aposta",
    "aprendiz",
    "aprovar",
    "aquecer",
    "arame",
    "aranha",
    "arara",
    "arcada",
    "ardente",
    "areia",
    "arejar",
    "arenito",
    "aresta",
    "argiloso",
    "argola",
    "arma",
    "arquivo",
    "arraial",
    "arrebate",
    "arriscar",
    "arroba",
    "arrumar",
    "arsenal",
    "arterial",
    "artigo",
    "arvoredo",
    "asfaltar",
    "asilado",
    "aspirar",
    "assador",
    "assinar",
    "assoalho",
    "assunto",
    "astral",
    "atacado",
    "atadura",
    "atalho",
    "atarefar",
    "atear",
    "atender",
    "aterro",
    "ateu",
    "atingir",
    "atirador",
    "ativo",
    "atoleiro",
    "atracar",
    "atrevido",
    "atriz",
    "atual",
    "atum",
    "auditor",
    "aumentar",
    "aura",
    "aurora",
    "autismo",
    "autoria",
    "autuar",
    "avaliar",
    "avante",
    "avaria",
    "avental",
    "avesso",
    "aviador",
    "avisar",
    "avulso",
    "axila",
    "azarar",
    "azedo",
    "azeite",
    "azulejo",
    "babar",
    "babosa",
    "bacalhau",
    "bacharel",
    "bacia",
    "bagagem",
    "baiano",
    "bailar",
    "baioneta",
    "bairro",
    "baixista",
    "bajular",
    "baleia",
    "baliza",
    "balsa",
    "banal",
    "bandeira",
    "banho",
    "banir",
    "banquete",
    "barato",
    "barbado",
    "baronesa",
    "barraca",
    "barulho",
    "baseado",
    "bastante",
    "batata",
    "batedor",
    "batida",
    "batom",
    "batucar",
    "baunilha",
    "beber",
    "beijo",
    "beirada",
    "beisebol",
    "beldade",
    "beleza",
    "belga",
    "beliscar",
    "bendito",
    "bengala",
    "benzer",
    "berimbau",
    "berlinda",
    "berro",
    "besouro",
    "bexiga",
    "bezerro",
    "bico",
    "bicudo",
    "bienal",
    "bifocal",
    "bifurcar",
    "bigorna",
    "bilhete",
    "bimestre",
    "bimotor",
    "biologia",
    "biombo",
    "biosfera",
    "bipolar",
    "birrento",
    "biscoito",
    "bisneto",
    "bispo",
    "bissexto",
    "bitola",
    "bizarro",
    "blindado",
    "bloco",
    "bloquear",
    "boato",
    "bobagem",
    "bocado",
    "bocejo",
    "bochecha",
    "boicotar",
    "bolada",
    "boletim",
    "bolha",
    "bolo",
    "bombeiro",
    "bonde",
    "boneco",
    "bonita",
    "borbulha",
    "borda",
    "boreal",
    "borracha",
    "bovino",
    "boxeador",
    "branco",
    "brasa",
    "braveza",
    "breu",
    "briga",
    "brilho",
    "brincar",
    "broa",
    "brochura",
    "bronzear",
    "broto",
    "bruxo",
    "bucha",
    "budismo",
    "bufar",
    "bule",
    "buraco",
    "busca",
    "busto",
    "buzina",
    "cabana",
    "cabelo",
    "cabide",
    "cabo",
    "cabrito",
    "cacau",
    "cacetada",
    "cachorro",
    "cacique",
    "cadastro",
    "cadeado",
    "cafezal",
    "caiaque",
    "caipira",
    "caixote",
    "cajado",
    "caju",
    "calafrio",
    "calcular",
    "caldeira",
    "calibrar",
    "calmante",
    "calota",
    "camada",
    "cambista",
    "camisa",
    "camomila",
    "campanha",
    "camuflar",
    "canavial",
    "cancelar",
    "caneta",
    "canguru",
    "canhoto",
    "canivete",
    "canoa",
    "cansado",
    "cantar",
    "canudo",
    "capacho",
    "capela",
    "capinar",
    "capotar",
    "capricho",
    "captador",
    "capuz",
    "caracol",
    "carbono",
    "cardeal",
    "careca",
    "carimbar",
    "carneiro",
    "carpete",
    "carreira",
    "cartaz",
    "carvalho",
    "casaco",
    "casca",
    "casebre",
    "castelo",
    "casulo",
    "catarata",
    "cativar",
    "caule",
    "causador",
    "cautelar",
    "cavalo",
    "caverna",
    "cebola",
    "cedilha",
    "cegonha",
    "celebrar",
    "celular",
    "cenoura",
    "censo",
    "centeio",
    "cercar",
    "cerrado",
    "certeiro",
    "cerveja",
    "cetim",
    "cevada",
    "chacota",
    "chaleira",
    "chamado",
    "chapada",
    "charme",
    "chatice",
    "chave",
    "chefe",
    "chegada",
    "cheiro",
    "cheque",
    "chicote",
    "chifre",
    "chinelo",
    "chocalho",
    "chover",
    "chumbo",
    "chutar",
    "chuva",
    "cicatriz",
    "ciclone",
    "cidade",
    "cidreira",
    "ciente",
    "cigana",
    "cimento",
    "cinto",
    "cinza",
    "ciranda",
    "circuito",
    "cirurgia",
    "citar",
    "clareza",
    "clero",
    "clicar",
    "clone",
    "clube",
    "coado",
    "coagir",
    "cobaia",
    "cobertor",
    "cobrar",
    "cocada",
    "coelho",
    "coentro",
    "coeso",
    "cogumelo",
    "coibir",
    "coifa",
    "coiote",
    "colar",
    "coleira",
    "colher",
    "colidir",
    "colmeia",
    "colono",
    "coluna",
    "comando",
    "combinar",
    "comentar",
    "comitiva",
    "comover",
    "complexo",
    "comum",
    "concha",
    "condor",
    "conectar",
    "confuso",
    "congelar",
    "conhecer",
    "conjugar",
    "consumir",
    "contrato",
    "convite",
    "cooperar",
    "copeiro",
    "copiador",
    "copo",
    "coquetel",
    "coragem",
    "cordial",
    "corneta",
    "coronha",
    "corporal",
    "correio",
    "cortejo",
    "coruja",
    "corvo",
    "cosseno",
    "costela",
    "cotonete",
    "couro",
    "couve",
    "covil",
    "cozinha",
    "cratera",
    "cravo",
    "creche",
    "credor",
    "creme",
    "crer",
    "crespo",
    "criada",
    "criminal",
    "crioulo",
    "crise",
    "criticar",
    "crosta",
    "crua",
    "cruzeiro",
    "cubano",
    "cueca",
    "cuidado",
    "cujo",
    "culatra",
    "culminar",
    "culpar",
    "cultura",
    "cumprir",
    "cunhado",
    "cupido",
    "curativo",
    "curral",
    "cursar",
    "curto",
    "cuspir",
    "custear",
    "cutelo",
    "damasco",
    "datar",
    "debater",
    "debitar",
    "deboche",
    "debulhar",
    "decalque",
    "decimal",
    "declive",
    "decote",
    "decretar",
    "dedal",
    "dedicado",
    "deduzir",
    "defesa",
    "defumar",
    "degelo",
    "degrau",
    "degustar",
    "deitado",
    "deixar",
    "delator",
    "delegado",
    "delinear",
    "delonga",
    "demanda",
    "demitir",
    "demolido",
    "dentista",
    "depenado",
    "depilar",
    "depois",
    "depressa",
    "depurar",
    "deriva",
    "derramar",
    "desafio",
    "desbotar",
    "descanso",
    "desenho",
    "desfiado",
    "desgaste",
    "desigual",
    "deslize",
    "desmamar",
    "desova",
    "despesa",
    "destaque",
    "desviar",
    "detalhar",
    "detentor",
    "detonar",
    "detrito",
    "deusa",
    "dever",
    "devido",
    "devotado",
    "dezena",
    "diagrama",
    "dialeto",
    "didata",
    "difuso",
    "digitar",
    "dilatado",
    "diluente",
    "diminuir",
    "dinastia",
    "dinheiro",
    "diocese",
    "direto",
    "discreta",
    "disfarce",
    "disparo",
    "disquete",
    "dissipar",
    "distante",
    "ditador",
    "diurno",
    "diverso",
    "divisor",
    "divulgar",
    "dizer",
    "dobrador",
    "dolorido",
    "domador",
    "dominado",
    "donativo",
    "donzela",
    "dormente",
    "dorsal",
    "dosagem",
    "dourado",
    "doutor",
    "drenagem",
    "drible",
    "drogaria",
    "duelar",
    "duende",
    "dueto",
    "duplo",
    "duquesa",
    "durante",
    "duvidoso",
    "eclodir",
    "ecoar",
    "ecologia",
    "edificar",
    "edital",
    "educado",
    "efeito",
    "efetivar",
    "ejetar",
    "elaborar",
    "eleger",
    "eleitor",
    "elenco",
    "elevador",
    "eliminar",
    "elogiar",
    "embargo",
    "embolado",
    "embrulho",
    "embutido",
    "emenda",
    "emergir",
    "emissor",
    "empatia",
    "empenho",
    "empinado",
    "empolgar",
    "emprego",
    "empurrar",
    "emulador",
    "encaixe",
    "encenado",
    "enchente",
    "encontro",
    "endeusar",
    "endossar",
    "enfaixar",
    "enfeite",
    "enfim",
    "engajado",
    "engenho",
    "englobar",
    "engomado",
    "engraxar",
    "enguia",
    "enjoar",
    "enlatar",
    "enquanto",
    "enraizar",
    "enrolado",
    "enrugar",
    "ensaio",
    "enseada",
    "ensino",
    "ensopado",
    "entanto",
    "enteado",
    "entidade",
    "entortar",
    "entrada",
    "entulho",
    "envergar",
    "enviado",
    "envolver",
    "enxame",
    "enxerto",
    "enxofre",
    "enxuto",
    "epiderme",
    "equipar",
    "ereto",
    "erguido",
    "errata",
    "erva",
    "ervilha",
    "esbanjar",
    "esbelto",
    "escama",
    "escola",
    "escrita",
    "escuta",
    "esfinge",
    "esfolar",
    "esfregar",
    "esfumado",
    "esgrima",
    "esmalte",
    "espanto",
    "espelho",
    "espiga",
    "esponja",
    "espreita",
    "espumar",
    "esquerda",
    "estaca",
    "esteira",
    "esticar",
    "estofado",
    "estrela",
    "estudo",
    "esvaziar",
    "etanol",
    "etiqueta",
    "euforia",
    "europeu",
    "evacuar",
    "evaporar",
    "evasivo",
    "eventual",
    "evidente",
    "evoluir",
    "exagero",
    "exalar",
    "examinar",
    "exato",
    "exausto",
    "excesso",
    "excitar",
    "exclamar",
    "executar",
    "exemplo",
    "exibir",
    "exigente",
    "exonerar",
    "expandir",
    "expelir",
    "expirar",
    "explanar",
    "exposto",
    "expresso",
    "expulsar",
    "externo",
    "extinto",
    "extrato",
    "fabricar",
    "fabuloso",
    "faceta",
    "facial",
    "fada",
    "fadiga",
    "faixa",
    "falar",
    "falta",
    "familiar",
    "fandango",
    "fanfarra",
    "fantoche",
    "fardado",
    "farelo",
    "farinha",
    "farofa",
    "farpa",
    "fartura",
    "fatia",
    "fator",
    "favorita",
    "faxina",
    "fazenda",
    "fechado",
    "feijoada",
    "feirante",
    "felino",
    "feminino",
    "fenda",
    "feno",
    "fera",
    "feriado",
    "ferrugem",
    "ferver",
    "festejar",
    "fetal",
    "feudal",
    "fiapo",
    "fibrose",
    "ficar",
    "ficheiro",
    "figurado",
    "fileira",
    "filho",
    "filme",
    "filtrar",
    "firmeza",
    "fisgada",
    "fissura",
    "fita",
    "fivela",
    "fixador",
    "fixo",
    "flacidez",
    "flamingo",
    "flanela",
    "flechada",
    "flora",
    "flutuar",
    "fluxo",
    "focal",
    "focinho",
    "fofocar",
    "fogo",
    "foguete",
    "foice",
    "folgado",
    "folheto",
    "forjar",
    "formiga",
    "forno",
    "forte",
    "fosco",
    "fossa",
    "fragata",
    "fralda",
    "frango",
    "frasco",
    "fraterno",
    "freira",
    "frente",
    "fretar",
    "frieza",
    "friso",
    "fritura",
    "fronha",
    "frustrar",
    "fruteira",
    "fugir",
    "fulano",
    "fuligem",
    "fundar",
    "fungo",
    "funil",
    "furador",
    "furioso",
    "futebol",
    "gabarito",
    "gabinete",
    "gado",
    "gaiato",
    "gaiola",
    "gaivota",
    "galega",
    "galho",
    "galinha",
    "galocha",
    "ganhar",
    "garagem",
    "garfo",
    "gargalo",
    "garimpo",
    "garoupa",
    "garrafa",
    "gasoduto",
    "gasto",
    "gata",
    "gatilho",
    "gaveta",
    "gazela",
    "gelado",
    "geleia",
    "gelo",
    "gemada",
    "gemer",
    "gemido",
    "generoso",
    "gengiva",
    "genial",
    "genoma",
    "genro",
    "geologia",
    "gerador",
    "germinar",
    "gesso",
    "gestor",
    "ginasta",
    "gincana",
    "gingado",
    "girafa",
    "girino",
    "glacial",
    "glicose",
    "global",
    "glorioso",
    "goela",
    "goiaba",
    "golfe",
    "golpear",
    "gordura",
    "gorjeta",
    "gorro",
    "gostoso",
    "goteira",
    "governar",
    "gracejo",
    "gradual",
    "grafite",
    "gralha",
    "grampo",
    "granada",
    "gratuito",
    "graveto",
    "graxa",
    "grego",
    "grelhar",
    "greve",
    "grilo",
    "grisalho",
    "gritaria",
    "grosso",
    "grotesco",
    "grudado",
    "grunhido",
    "gruta",
    "guache",
    "guarani",
    "guaxinim",
    "guerrear",
    "guiar",
    "guincho",
    "guisado",
    "gula",
    "guloso",
    "guru",
    "habitar",
    "harmonia",
    "haste",
    "haver",
    "hectare",
    "herdar",
    "heresia",
    "hesitar",
    "hiato",
    "hibernar",
    "hidratar",
    "hiena",
    "hino",
    "hipismo",
    "hipnose",
    "hipoteca",
    "hoje",
    "holofote",
    "homem",
    "honesto",
    "honrado",
    "hormonal",
    "hospedar",
    "humorado",
    "iate",
    "ideia",
    "idoso",
    "ignorado",
    "igreja",
    "iguana",
    "ileso",
    "ilha",
    "iludido",
    "iluminar",
    "ilustrar",
    "imagem",
    "imediato",
    "imenso",
    "imersivo",
    "iminente",
    "imitador",
    "imortal",
    "impacto",
    "impedir",
    "implante",
    "impor",
    "imprensa",
    "impune",
    "imunizar",
    "inalador",
    "inapto",
    "inativo",
    "incenso",
    "inchar",
    "incidir",
    "incluir",
    "incolor",
    "indeciso",
    "indireto",
    "indutor",
    "ineficaz",
    "inerente",
    "infantil",
    "infestar",
    "infinito",
    "inflamar",
    "informal",
    "infrator",
    "ingerir",
    "inibido",
    "inicial",
    "inimigo",
    "injetar",
    "inocente",
    "inodoro",
    "inovador",
    "inox",
    "inquieto",
    "inscrito",
    "inseto",
    "insistir",
    "inspetor",
    "instalar",
    "insulto",
    "intacto",
    "integral",
    "intimar",
    "intocado",
    "intriga",
    "invasor",
    "inverno",
    "invicto",
    "invocar",
    "iogurte",
    "iraniano",
    "ironizar",
    "irreal",
    "irritado",
    "isca",
    "isento",
    "isolado",
    "isqueiro",
    "italiano",
    "janeiro",
    "jangada",
    "janta",
    "jararaca",
    "jardim",
    "jarro",
    "jasmim",
    "jato",
    "javali",
    "jazida",
    "jejum",
    "joaninha",
    "joelhada",
    "jogador",
    "joia",
    "jornal",
    "jorrar",
    "jovem",
    "juba",
    "judeu",
    "judoca",
    "juiz",
    "julgador",
    "julho",
    "jurado",
    "jurista",
    "juro",
    "justa",
    "labareda",
    "laboral",
    "lacre",
    "lactante",
    "ladrilho",
    "lagarta",
    "lagoa",
    "laje",
    "lamber",
    "lamentar",
    "laminar",
    "lampejo",
    "lanche",
    "lapidar",
    "lapso",
    "laranja",
    "lareira",
    "largura",
    "lasanha",
    "lastro",
    "lateral",
    "latido",
    "lavanda",
    "lavoura",
    "lavrador",
    "laxante",
    "lazer",
    "lealdade",
    "lebre",
    "legado",
    "legendar",
    "legista",
    "leigo",
    "leiloar",
    "leitura",
    "lembrete",
    "leme",
    "lenhador",
    "lentilha",
    "leoa",
    "lesma",
    "leste",
    "letivo",
    "letreiro",
    "levar",
    "leveza",
    "levitar",
    "liberal",
    "libido",
    "liderar",
    "ligar",
    "ligeiro",
    "limitar",
    "limoeiro",
    "limpador",
    "linda",
    "linear",
    "linhagem",
    "liquidez",
    "listagem",
    "lisura",
    "litoral",
    "livro",
    "lixa",
    "lixeira",
    "locador",
    "locutor",
    "lojista",
    "lombo",
    "lona",
    "longe",
    "lontra",
    "lorde",
    "lotado",
    "loteria",
    "loucura",
    "lousa",
    "louvar",
    "luar",
    "lucidez",
    "lucro",
    "luneta",
    "lustre",
    "lutador",
    "luva",
    "macaco",
    "macete",
    "machado",
    "macio",
    "madeira",
    "madrinha",
    "magnata",
    "magreza",
    "maior",
    "mais",
    "malandro",
    "malha",
    "malote",
    "maluco",
    "mamilo",
    "mamoeiro",
    "mamute",
    "manada",
    "mancha",
    "mandato",
    "manequim",
    "manhoso",
    "manivela",
    "manobrar",
    "mansa",
    "manter",
    "manusear",
    "mapeado",
    "maquinar",
    "marcador",
    "maresia",
    "marfim",
    "margem",
    "marinho",
    "marmita",
    "maroto",
    "marquise",
    "marreco",
    "martelo",
    "marujo",
    "mascote",
    "masmorra",
    "massagem",
    "mastigar",
    "matagal",
    "materno",
    "matinal",
    "matutar",
    "maxilar",
    "medalha",
    "medida",
    "medusa",
    "megafone",
    "meiga",
    "melancia",
    "melhor",
    "membro",
    "memorial",
    "menino",
    "menos",
    "mensagem",
    "mental",
    "merecer",
    "mergulho",
    "mesada",
    "mesclar",
    "mesmo",
    "mesquita",
    "mestre",
    "metade",
    "meteoro",
    "metragem",
    "mexer",
    "mexicano",
    "micro",
    "migalha",
    "migrar",
    "milagre",
    "milenar",
    "milhar",
    "mimado",
    "minerar",
    "minhoca",
    "ministro",
    "minoria",
    "miolo",
    "mirante",
    "mirtilo",
    "misturar",
    "mocidade",
    "moderno",
    "modular",
    "moeda",
    "moer",
    "moinho",
    "moita",
    "moldura",
    "moleza",
    "molho",
    "molinete",
    "molusco",
    "montanha",
    "moqueca",
    "morango",
    "morcego",
    "mordomo",
    "morena",
    "mosaico",
    "mosquete",
    "mostarda",
    "motel",
    "motim",
    "moto",
    "motriz",
    "muda",
    "muito",
    "mulata",
    "mulher",
    "multar",
    "mundial",
    "munido",
    "muralha",
    "murcho",
    "muscular",
    "museu",
    "musical",
    "nacional",
    "nadador",
    "naja",
    "namoro",
    "narina",
    "narrado",
    "nascer",
    "nativa",
    "natureza",
    "navalha",
    "navegar",
    "navio",
    "neblina",
    "nebuloso",
    "negativa",
    "negociar",
    "negrito",
    "nervoso",
    "neta",
    "neural",
    "nevasca",
    "nevoeiro",
    "ninar",
    "ninho",
    "nitidez",
    "nivelar",
    "nobreza",
    "noite",
    "noiva",
    "nomear",
    "nominal",
    "nordeste",
    "nortear",
    "notar",
    "noticiar",
    "noturno",
    "novelo",
    "novilho",
    "novo",
    "nublado",
    "nudez",
    "numeral",
    "nupcial",
    "nutrir",
    "nuvem",
    "obcecado",
    "obedecer",
    "objetivo",
    "obrigado",
    "obscuro",
    "obstetra",
    "obter",
    "obturar",
    "ocidente",
    "ocioso",
    "ocorrer",
    "oculista",
    "ocupado",
    "ofegante",
    "ofensiva",
    "oferenda",
    "oficina",
    "ofuscado",
    "ogiva",
    "olaria",
    "oleoso",
    "olhar",
    "oliveira",
    "ombro",
    "omelete",
    "omisso",
    "omitir",
    "ondulado",
    "oneroso",
    "ontem",
    "opcional",
    "operador",
    "oponente",
    "oportuno",
    "oposto",
    "orar",
    "orbitar",
    "ordem",
    "ordinal",
    "orfanato",
    "orgasmo",
    "orgulho",
    "oriental",
    "origem",
    "oriundo",
    "orla",
    "ortodoxo",
    "orvalho",
    "oscilar",
    "ossada",
    "osso",
    "ostentar",
    "otimismo",
    "ousadia",
    "outono",
    "outubro",
    "ouvido",
    "ovelha",
    "ovular",
    "oxidar",
    "oxigenar",
    "pacato",
    "paciente",
    "pacote",
    "pactuar",
    "padaria",
    "padrinho",
    "pagar",
    "pagode",
    "painel",
    "pairar",
    "paisagem",
    "palavra",
    "palestra",
    "palheta",
    "palito",
    "palmada",
    "palpitar",
    "pancada",
    "panela",
    "panfleto",
    "panqueca",
    "pantanal",
    "papagaio",
    "papelada",
    "papiro",
    "parafina",
    "parcial",
    "pardal",
    "parede",
    "partida",
    "pasmo",
    "passado",
    "pastel",
    "patamar",
    "patente",
    "patinar",
    "patrono",
    "paulada",
    "pausar",
    "peculiar",
    "pedalar",
    "pedestre",
    "pediatra",
    "pedra",
    "pegada",
    "peitoral",
    "peixe",
    "pele",
    "pelicano",
    "penca",
    "pendurar",
    "peneira",
    "penhasco",
    "pensador",
    "pente",
    "perceber",
    "perfeito",
    "pergunta",
    "perito",
    "permitir",
    "perna",
    "perplexo",
    "persiana",
    "pertence",
    "peruca",
    "pescado",
    "pesquisa",
    "pessoa",
    "petiscar",
    "piada",
    "picado",
    "piedade",
    "pigmento",
    "pilastra",
    "pilhado",
    "pilotar",
    "pimenta",
    "pincel",
    "pinguim",
    "pinha",
    "pinote",
    "pintar",
    "pioneiro",
    "pipoca",
    "piquete",
    "piranha",
    "pires",
    "pirueta",
    "piscar",
    "pistola",
    "pitanga",
    "pivete",
    "planta",
    "plaqueta",
    "platina",
    "plebeu",
    "plumagem",
    "pluvial",
    "pneu",
    "poda",
    "poeira",
    "poetisa",
    "polegada",
    "policiar",
    "poluente",
    "polvilho",
    "pomar",
    "pomba",
    "ponderar",
    "pontaria",
    "populoso",
    "porta",
    "possuir",
    "postal",
    "pote",
    "poupar",
    "pouso",
    "povoar",
    "praia",
    "prancha",
    "prato",
    "praxe",
    "prece",
    "predador",
    "prefeito",
    "premiar",
    "prensar",
    "preparar",
    "presilha",
    "pretexto",
    "prevenir",
    "prezar",
    "primata",
    "princesa",
    "prisma",
    "privado",
    "processo",
    "produto",
    "profeta",
    "proibido",
    "projeto",
    "prometer",
    "propagar",
    "prosa",
    "protetor",
    "provador",
    "publicar",
    "pudim",
    "pular",
    "pulmonar",
    "pulseira",
    "punhal",
    "punir",
    "pupilo",
    "pureza",
    "puxador",
    "quadra",
    "quantia",
    "quarto",
    "quase",
    "quebrar",
    "queda",
    "queijo",
    "quente",
    "querido",
    "quimono",
    "quina",
    "quiosque",
    "rabanada",
    "rabisco",
    "rachar",
    "racionar",
    "radial",
    "raiar",
    "rainha",
    "raio",
    "raiva",
    "rajada",
    "ralado",
    "ramal",
    "ranger",
    "ranhura",
    "rapadura",
    "rapel",
    "rapidez",
    "raposa",
    "raquete",
    "raridade",
    "rasante",
    "rascunho",
    "rasgar",
    "raspador",
    "rasteira",
    "rasurar",
    "ratazana",
    "ratoeira",
    "realeza",
    "reanimar",
    "reaver",
    "rebaixar",
    "rebelde",
    "rebolar",
    "recado",
    "recente",
    "recheio",
    "recibo",
    "recordar",
    "recrutar",
    "recuar",
    "rede",
    "redimir",
    "redonda",
    "reduzida",
    "reenvio",
    "refinar",
    "refletir",
    "refogar",
    "refresco",
    "refugiar",
    "regalia",
    "regime",
    "regra",
    "reinado",
    "reitor",
    "rejeitar",
    "relativo",
    "remador",
    "remendo",
    "remorso",
    "renovado",
    "reparo",
    "repelir",
    "repleto",
    "repolho",
    "represa",
    "repudiar",
    "requerer",
    "resenha",
    "resfriar",
    "resgatar",
    "residir",
    "resolver",
    "respeito",
    "ressaca",
    "restante",
    "resumir",
    "retalho",
    "reter",
    "retirar",
    "retomada",
    "retratar",
    "revelar",
    "revisor",
    "revolta",
    "riacho",
    "rica",
    "rigidez",
    "rigoroso",
    "rimar",
    "ringue",
    "risada",
    "risco",
    "risonho",
    "robalo",
    "rochedo",
    "rodada",
    "rodeio",
    "rodovia",
    "roedor",
    "roleta",
    "romano",
    "roncar",
    "rosado",
    "roseira",
    "rosto",
    "rota",
    "roteiro",
    "rotina",
    "rotular",
    "rouco",
    "roupa",
    "roxo",
    "rubro",
    "rugido",
    "rugoso",
    "ruivo",
    "rumo",
    "rupestre",
    "russo",
    "sabor",
    "saciar",
    "sacola",
    "sacudir",
    "sadio",
    "safira",
    "saga",
    "sagrada",
    "saibro",
    "salada",
    "saleiro",
    "salgado",
    "saliva",
    "salpicar",
    "salsicha",
    "saltar",
    "salvador",
    "sambar",
    "samurai",
    "sanar",
    "sanfona",
    "sangue",
    "sanidade",
    "sapato",
    "sarda",
    "sargento",
    "sarjeta",
    "saturar",
    "saudade",
    "saxofone",
    "sazonal",
    "secar",
    "secular",
    "seda",
    "sedento",
    "sediado",
    "sedoso",
    "sedutor",
    "segmento",
    "segredo",
    "segundo",
    "seiva",
    "seleto",
    "selvagem",
    "semanal",
    "semente",
    "senador",
    "senhor",
    "sensual",
    "sentado",
    "separado",
    "sereia",
    "seringa",
    "serra",
    "servo",
    "setembro",
    "setor",
    "sigilo",
    "silhueta",
    "silicone",
    "simetria",
    "simpatia",
    "simular",
    "sinal",
    "sincero",
    "singular",
    "sinopse",
    "sintonia",
    "sirene",
    "siri",
    "situado",
    "soberano",
    "sobra",
    "socorro",
    "sogro",
    "soja",
    "solda",
    "soletrar",
    "solteiro",
    "sombrio",
    "sonata",
    "sondar",
    "sonegar",
    "sonhador",
    "sono",
    "soprano",
    "soquete",
    "sorrir",
    "sorteio",
    "sossego",
    "sotaque",
    "soterrar",
    "sovado",
    "sozinho",
    "suavizar",
    "subida",
    "submerso",
    "subsolo",
    "subtrair",
    "sucata",
    "sucesso",
    "suco",
    "sudeste",
    "sufixo",
    "sugador",
    "sugerir",
    "sujeito",
    "sulfato",
    "sumir",
    "suor",
    "superior",
    "suplicar",
    "suposto",
    "suprimir",
    "surdina",
    "surfista",
    "surpresa",
    "surreal",
    "surtir",
    "suspiro",
    "sustento",
    "tabela",
    "tablete",
    "tabuada",
    "tacho",
    "tagarela",
    "talher",
    "talo",
    "talvez",
    "tamanho",
    "tamborim",
    "tampa",
    "tangente",
    "tanto",
    "tapar",
    "tapioca",
    "tardio",
    "tarefa",
    "tarja",
    "tarraxa",
    "tatuagem",
    "taurino",
    "taxativo",
    "taxista",
    "teatral",
    "tecer",
    "tecido",
    "teclado",
    "tedioso",
    "teia",
    "teimar",
    "telefone",
    "telhado",
    "tempero",
    "tenente",
    "tensor",
    "tentar",
    "termal",
    "terno",
    "terreno",
    "tese",
    "tesoura",
    "testado",
    "teto",
    "textura",
    "texugo",
    "tiara",
    "tigela",
    "tijolo",
    "timbrar",
    "timidez",
    "tingido",
    "tinteiro",
    "tiragem",
    "titular",
    "toalha",
    "tocha",
    "tolerar",
    "tolice",
    "tomada",
    "tomilho",
    "tonel",
    "tontura",
    "topete",
    "tora",
    "torcido",
    "torneio",
    "torque",
    "torrada",
    "torto",
    "tostar",
    "touca",
    "toupeira",
    "toxina",
    "trabalho",
    "tracejar",
    "tradutor",
    "trafegar",
    "trajeto",
    "trama",
    "trancar",
    "trapo",
    "traseiro",
    "tratador",
    "travar",
    "treino",
    "tremer",
    "trepidar",
    "trevo",
    "triagem",
    "tribo",
    "triciclo",
    "tridente",
    "trilogia",
    "trindade",
    "triplo",
    "triturar",
    "triunfal",
    "trocar",
    "trombeta",
    "trova",
    "trunfo",
    "truque",
    "tubular",
    "tucano",
    "tudo",
    "tulipa",
    "tupi",
    "turbo",
    "turma",
    "turquesa",
    "tutelar",
    "tutorial",
    "uivar",
    "umbigo",
    "unha",
    "unidade",
    "uniforme",
    "urologia",
    "urso",
    "urtiga",
    "urubu",
    "usado",
    "usina",
    "usufruir",
    "vacina",
    "vadiar",
    "vagaroso",
    "vaidoso",
    "vala",
    "valente",
    "validade",
    "valores",
    "vantagem",
    "vaqueiro",
    "varanda",
    "vareta",
    "varrer",
    "vascular",
    "vasilha",
    "vassoura",
    "vazar",
    "vazio",
    "veado",
    "vedar",
    "vegetar",
    "veicular",
    "veleiro",
    "velhice",
    "veludo",
    "vencedor",
    "vendaval",
    "venerar",
    "ventre",
    "verbal",
    "verdade",
    "vereador",
    "vergonha",
    "vermelho",
    "verniz",
    "versar",
    "vertente",
    "vespa",
    "vestido",
    "vetorial",
    "viaduto",
    "viagem",
    "viajar",
    "viatura",
    "vibrador",
    "videira",
    "vidraria",
    "viela",
    "viga",
    "vigente",
    "vigiar",
    "vigorar",
    "vilarejo",
    "vinco",
    "vinheta",
    "vinil",
    "violeta",
    "virada",
    "virtude",
    "visitar",
    "visto",
    "vitral",
    "viveiro",
    "vizinho",
    "voador",
    "voar",
    "vogal",
    "volante",
    "voleibol",
    "voltagem",
    "volumoso",
    "vontade",
    "vulto",
    "vuvuzela",
    "xadrez",
    "xarope",
    "xeque",
    "xeretar",
    "xerife",
    "xingar",
    "zangado",
    "zarpar",
    "zebu",
    "zelador",
    "zombar",
    "zoologia",
    "zumbido"
], sre = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];
Object.defineProperty(Zi, "__esModule", {
    value: !0
});
const Uo = {};
Zi.wordlists = Uo;
let Tn;
var Ta = Zi._default = Tn;
try {
    Ta = Zi._default = Tn = Xte, Uo.czech = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = Jte, Uo.chinese_simplified = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = Qte, Uo.chinese_traditional = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = ere, Uo.korean = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = tre, Uo.french = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = rre, Uo.italian = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = nre, Uo.spanish = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = ire, Uo.japanese = Tn, Uo.JA = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = ore, Uo.portuguese = Tn;
} catch  {}
try {
    Ta = Zi._default = Tn = sre, Uo.english = Tn, Uo.EN = Tn;
} catch  {}
Object.defineProperty(Aa, "__esModule", {
    value: !0
});
const are = us, zP = oi, jP = Kb, cre = Hr, lm = Zi;
let fp = lm._default;
const Tk = "Invalid mnemonic", pf = "Invalid entropy", ure = "Invalid mnemonic checksum", HP = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function lp(e) {
    return (e || "").normalize("NFKD");
}
function qP(e, t, r) {
    for(; e.length < r;)e = t + e;
    return e;
}
function KP(e) {
    return parseInt(e, 2);
}
function WP(e) {
    return e.map((t)=>qP(t.toString(2), "0", 8)).join("");
}
function VP(e) {
    const r = e.length * 8 / 32, n = are.sha256(Uint8Array.from(e));
    return WP(Array.from(n)).slice(0, r);
}
function GP(e) {
    return "mnemonic" + (e || "");
}
function fre(e, t) {
    const r = Uint8Array.from(We.from(lp(e), "utf8")), n = Uint8Array.from(We.from(GP(lp(t)), "utf8")), i = jP.pbkdf2(zP.sha512, r, n, {
        c: 2048,
        dkLen: 64
    });
    return We.from(i);
}
Aa.mnemonicToSeedSync = fre;
function lre(e, t) {
    const r = Uint8Array.from(We.from(lp(e), "utf8")), n = Uint8Array.from(We.from(GP(lp(t)), "utf8"));
    return jP.pbkdf2Async(zP.sha512, r, n, {
        c: 2048,
        dkLen: 64
    }).then((i)=>We.from(i));
}
var dre = Aa.mnemonicToSeed = lre;
function ZP(e, t) {
    if (t = t || fp, !t) throw new Error(HP);
    const r = lp(e).split(" ");
    if (r.length % 3 !== 0) throw new Error(Tk);
    const n = r.map((c)=>{
        const l = t.indexOf(c);
        if (l === -1) throw new Error(Tk);
        return qP(l.toString(2), "0", 11);
    }).join(""), i = Math.floor(n.length / 33) * 32, o = n.slice(0, i), s = n.slice(i), a = o.match(/(.{1,8})/g).map(KP);
    if (a.length < 16) throw new Error(pf);
    if (a.length > 32) throw new Error(pf);
    if (a.length % 4 !== 0) throw new Error(pf);
    const u = We.from(a);
    if (VP(u) !== s) throw new Error(ure);
    return u.toString("hex");
}
Aa.mnemonicToEntropy = ZP;
function YP(e, t) {
    if (We.isBuffer(e) || (e = We.from(e, "hex")), t = t || fp, !t) throw new Error(HP);
    if (e.length < 16) throw new TypeError(pf);
    if (e.length > 32) throw new TypeError(pf);
    if (e.length % 4 !== 0) throw new TypeError(pf);
    const r = WP(Array.from(e)), n = VP(e), s = (r + n).match(/(.{1,11})/g).map((a)=>{
        const u = KP(a);
        return t[u];
    });
    return t[0] === "" ? s.join("") : s.join(" ");
}
var hre = Aa.entropyToMnemonic = YP;
function pre(e, t, r) {
    if (e = e || 128, e % 32 !== 0) throw new TypeError(pf);
    return t = t || ((n)=>We.from(cre.randomBytes(n))), YP(t(e / 8), r);
}
Aa.generateMnemonic = pre;
function gre(e, t) {
    try {
        ZP(e, t);
    } catch  {
        return !1;
    }
    return !0;
}
Aa.validateMnemonic = gre;
function yre(e) {
    const t = lm.wordlists[e];
    if (t) fp = t;
    else throw new Error('Could not find wordlist for language "' + e + '"');
}
Aa.setDefaultWordlist = yre;
function mre() {
    if (!fp) throw new Error("No Default Wordlist set");
    return Object.keys(lm.wordlists).filter((e)=>e === "JA" || e === "EN" ? !1 : lm.wordlists[e].every((t, r)=>t === fp[r]))[0];
}
Aa.getDefaultWordlist = mre;
var bre = Zi;
Aa.wordlists = bre.wordlists;
let XP = class extends e7 {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, bq(t);
        const n = t3(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen, o = new Uint8Array(i);
        o.set(n.length > i ? t.create().update(n).digest() : n);
        for(let s = 0; s < o.length; s++)o[s] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let s = 0; s < o.length; s++)o[s] ^= 106;
        this.oHash.update(o), hu(o);
    }
    update(t) {
        return Zy(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        Zy(this), cb(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const JP = (e, t, r)=>new XP(e, t).update(r).digest();
JP.create = (e, t)=>new XP(e, t);
const wre = Wq;
function vre(e) {
    return s7(pi(e));
}
function kk(e, t) {
    return JP(wre, e, t);
}
const yr = (e)=>aK(e);
function _re(e) {
    if (Wn(e.isPoint(yr("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Wn(!e.isPoint(yr("030000000000000000000000000000000000000000000000000000000000000005"))), Wn(e.isPrivate(yr("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Wn(e.isPrivate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), Wn(!e.isPrivate(yr("0000000000000000000000000000000000000000000000000000000000000000"))), Wn(!e.isPrivate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), Wn(!e.isPrivate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), Wn(ja(e.pointFromScalar(yr("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), yr("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
        Wn(e.xOnlyPointAddTweak(yr("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
        let t = e.xOnlyPointAddTweak(yr("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), yr("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
        Wn(ja(t.xOnlyPubkey, yr("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(yr("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), yr("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    Wn(ja(e.pointAddScalar(yr("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), yr("0000000000000000000000000000000000000000000000000000000000000003")), yr("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), Wn(ja(e.privateAdd(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), yr("0000000000000000000000000000000000000000000000000000000000000002")), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (Wn(ja(e.privateNegate(yr("0000000000000000000000000000000000000000000000000000000000000001")), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), Wn(ja(e.privateNegate(yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), yr("0000000000000000000000000000000000000000000000000000000000000003")) === 0), Wn(ja(e.privateNegate(yr("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), yr("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), Wn(ja(e.sign(yr("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), yr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), yr("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), Wn(e.verify(yr("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), yr("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), yr("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && Wn(ja(e.signSchnorr(yr("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), yr("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), yr("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), yr("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && Wn(e.verifySchnorr(yr("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), yr("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), yr("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function Wn(e) {
    if (!e) throw new Error("ecc library invalid");
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function VE(e) {
    return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function QP(e, t) {
    return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((r)=>typeof r == "string") : t.every((r)=>Number.isSafeInteger(r)) : !1;
}
function Ere(e) {
    if (typeof e != "function") throw new Error("function expected");
    return !0;
}
function GE(e, t) {
    if (typeof t != "string") throw new Error(`${e}: string expected`);
    return !0;
}
function Q3(e) {
    if (!Number.isSafeInteger(e)) throw new Error(`invalid integer: ${e}`);
}
function ZE(e) {
    if (!Array.isArray(e)) throw new Error("array expected");
}
function eN(e, t) {
    if (!QP(!0, t)) throw new Error(`${e}: array of strings expected`);
}
function xre(e, t) {
    if (!QP(!1, t)) throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function tN(...e) {
    const t = (o)=>o, r = (o, s)=>(a)=>o(s(a)), n = e.map((o)=>o.encode).reduceRight(r, t), i = e.map((o)=>o.decode).reduce(r, t);
    return {
        encode: n,
        decode: i
    };
}
// @__NO_SIDE_EFFECTS__
function Sre(e) {
    const t = typeof e == "string" ? e.split("") : e, r = t.length;
    eN("alphabet", t);
    const n = new Map(t.map((i, o)=>[
            i,
            o
        ]));
    return {
        encode: (i)=>(ZE(i), i.map((o)=>{
                if (!Number.isSafeInteger(o) || o < 0 || o >= r) throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);
                return t[o];
            })),
        decode: (i)=>(ZE(i), i.map((o)=>{
                GE("alphabet.decode", o);
                const s = n.get(o);
                if (s === void 0) throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);
                return s;
            }))
    };
}
// @__NO_SIDE_EFFECTS__
function Are(e = "") {
    return GE("join", e), {
        encode: (t)=>(eN("join.decode", t), t.join(e)),
        decode: (t)=>(GE("join.decode", t), t.split(e))
    };
}
function Ik(e, t, r) {
    if (t < 2) throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
    if (ZE(e), !e.length) return [];
    let n = 0;
    const i = [], o = Array.from(e, (a)=>{
        if (Q3(a), a < 0 || a >= t) throw new Error(`invalid integer: ${a}`);
        return a;
    }), s = o.length;
    for(;;){
        let a = 0, u = !0;
        for(let f = n; f < s; f++){
            const c = o[f], l = t * a, p = l + c;
            if (!Number.isSafeInteger(p) || l / t !== a || p - c !== l) throw new Error("convertRadix: carry overflow");
            const y = p / r;
            a = p % r;
            const _ = Math.floor(y);
            if (o[f] = _, !Number.isSafeInteger(_) || _ * r + a !== p) throw new Error("convertRadix: carry overflow");
            if (u) _ ? u = !1 : n = f;
            else continue;
        }
        if (i.push(a), u) break;
    }
    for(let a = 0; a < e.length - 1 && e[a] === 0; a++)i.push(0);
    return i.reverse();
}
// @__NO_SIDE_EFFECTS__
function Tre(e) {
    Q3(e);
    const t = 2 ** 8;
    return {
        encode: (r)=>{
            if (!VE(r)) throw new Error("radix.encode input should be Uint8Array");
            return Ik(Array.from(r), t, e);
        },
        decode: (r)=>(xre("radix.decode", r), Uint8Array.from(Ik(r, e, t)))
    };
}
function kre(e, t) {
    return Q3(e), Ere(t), {
        encode (r) {
            if (!VE(r)) throw new Error("checksum.encode: input should be Uint8Array");
            const n = t(r).slice(0, e), i = new Uint8Array(r.length + e);
            return i.set(r), i.set(n, r.length), i;
        },
        decode (r) {
            if (!VE(r)) throw new Error("checksum.decode: input should be Uint8Array");
            const n = r.slice(0, -e), i = r.slice(-e), o = t(n).slice(0, e);
            for(let s = 0; s < e; s++)if (o[s] !== i[s]) throw new Error("Invalid checksum");
            return n;
        }
    };
}
const Ire = /* @__NO_SIDE_EFFECTS__ */ (e)=>/* @__PURE__ */ tN(/* @__PURE__ */ Tre(58), /* @__PURE__ */ Sre(e), /* @__PURE__ */ Are("")), Bre = /* @__PURE__ */ Ire("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Ore = (e)=>/* @__PURE__ */ tN(kre(4, (t)=>e(e(t))), Bre), Pre = Ore;
var Ha;
function Nre(e) {
    return {
        lang: (e == null ? void 0 : e.lang) ?? (Ha == null ? void 0 : Ha.lang),
        message: e == null ? void 0 : e.message,
        abortEarly: (e == null ? void 0 : e.abortEarly) ?? (Ha == null ? void 0 : Ha.abortEarly),
        abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (Ha == null ? void 0 : Ha.abortPipeEarly)
    };
}
var b_;
function Mre(e) {
    return b_ == null ? void 0 : b_.get(e);
}
var w_;
function Rre(e) {
    return w_ == null ? void 0 : w_.get(e);
}
var v_;
function Cre(e, t) {
    var r;
    return (r = v_ == null ? void 0 : v_.get(e)) == null ? void 0 : r.get(t);
}
function dp(e) {
    var r, n;
    const t = typeof e;
    return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function mc(e, t, r, n, i) {
    const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? dp(o), u = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: s,
        received: a,
        message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
        // @ts-expect-error
        requirement: e.requirement,
        path: i == null ? void 0 : i.path,
        issues: i == null ? void 0 : i.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, f = e.kind === "schema", c = (i == null ? void 0 : i.message) ?? // @ts-expect-error
    e.message ?? Cre(e.reference, u.lang) ?? (f ? Rre(u.lang) : null) ?? n.message ?? Mre(u.lang);
    c && (u.message = typeof c == "function" ? c(u) : c), f && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [
        u
    ];
}
var Ure = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(t){
        super(t[0].message);
        /**
     * The error issues.
     */ pt(this, "issues");
        this.name = "ValiError", this.issues = t;
    }
};
function Wb(e) {
    return {
        kind: "validation",
        type: "integer",
        reference: Wb,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run (t, r) {
            return t.typed && !this.requirement(t.value) && mc(this, "integer", t, r), t;
        }
    };
}
function eS(e, t) {
    return {
        kind: "validation",
        type: "length",
        reference: eS,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length !== this.requirement && mc(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function Vb(e, t) {
    return {
        kind: "validation",
        type: "max_value",
        reference: Vb,
        async: !1,
        expects: `<=${e instanceof Date ? e.toJSON() : dp(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value > this.requirement && mc(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : dp(r.value)
            }), r;
        }
    };
}
function Gb(e, t) {
    return {
        kind: "validation",
        type: "min_value",
        reference: Gb,
        async: !1,
        expects: `>=${e instanceof Date ? e.toJSON() : dp(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value < this.requirement && mc(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : dp(r.value)
            }), r;
        }
    };
}
function rN(e, t) {
    return {
        kind: "validation",
        type: "regex",
        reference: rN,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement.test(r.value) && mc(this, "format", r, n), r;
        }
    };
}
function Zb(e, t) {
    return {
        kind: "schema",
        type: "instance",
        reference: Zb,
        expects: e.name,
        async: !1,
        class: e,
        message: t,
        _run (r, n) {
            return r.value instanceof this.class ? r.typed = !0 : mc(this, "type", r, n), r;
        }
    };
}
function Yb(e) {
    return {
        kind: "schema",
        type: "number",
        reference: Yb,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : mc(this, "type", t, r), t;
        }
    };
}
function YE(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: YE,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var o;
            const i = r.value;
            if (i && typeof i == "object") {
                r.typed = !0, r.value = {};
                for(const s in this.entries){
                    const a = i[s], u = this.entries[s]._run({
                        typed: !1,
                        value: a
                    }, n);
                    if (u.issues) {
                        const f = {
                            type: "object",
                            origin: "value",
                            input: i,
                            key: s,
                            value: a
                        };
                        for (const c of u.issues)c.path ? c.path.unshift(f) : c.path = [
                            f
                        ], (o = r.issues) == null || o.push(c);
                        if (r.issues || (r.issues = u.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    u.typed || (r.typed = !1), (u.value !== void 0 || s in i) && (r.value[s] = u.value);
                }
            } else mc(this, "type", r, n);
            return r;
        }
    };
}
function nN(e) {
    return {
        kind: "schema",
        type: "string",
        reference: nN,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : mc(this, "type", t, r), t;
        }
    };
}
function qa(e, t, r) {
    const n = e._run({
        typed: !1,
        value: t
    }, Nre(r));
    if (n.issues) throw new Ure(n.issues);
    return n.value;
}
function Pd(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
const XE = Pd(Yb(), Wb(), Gb(0), Vb(4294967295)), $re = Pd(Yb(), Wb(), Gb(0), Vb(2147483647)), Lre = Pd(Yb(), Wb(), Gb(0), Vb(255)), __ = Pd(Zb(Uint8Array), eS(32)), Dre = Pd(Zb(Uint8Array), eS(33)), Fre = YE({
    wif: Lre,
    bip32: YE({
        public: XE,
        private: XE
    })
}), zre = Pd(nN(), rN(/^(m\/)?(\d+'?\/)*\d+'?$/));
function jre(e, t, r) {
    if (t.length !== 32) throw new TypeError("Invalid privateKey length");
    var n = new Uint8Array(34), i = new DataView(n.buffer);
    return i.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function Hre(e) {
    return Ql.encode(jre(e.version, e.privateKey));
}
const Bk = Pre(pi), Ok = {
    encode: (e)=>Bk.encode(e),
    decode: (e)=>Bk.decode(e)
};
function qre(e) {
    _re(e);
    const t = {
        messagePrefix: `Bitcoin Signed Message:
`,
        bech32: "bc",
        bip32: {
            public: 76067358,
            private: 76066276
        },
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
    }, r = 2147483648;
    function n(p) {
        return p.length === 32 ? p : p.slice(1, 33);
    }
    class i {
        constructor(y, _){
            pt(this, "__D");
            pt(this, "__Q");
            pt(this, "lowR", !1);
            this.__D = y, this.__Q = _;
        }
        get publicKey() {
            return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, !0)), this.__Q;
        }
        get privateKey() {
            return this.__D;
        }
        sign(y, _) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (_ === void 0 && (_ = this.lowR), _ === !1) return e.sign(y, this.privateKey);
            {
                let A = e.sign(y, this.privateKey);
                const O = new Uint8Array(32);
                let N = 0;
                for(; A[0] > 127;)N++, Zu(O, 0, N, "LE"), A = e.sign(y, this.privateKey, O);
                return A;
            }
        }
        signSchnorr(y) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (!e.signSchnorr) throw new Error("signSchnorr not supported by ecc library");
            return e.signSchnorr(y, this.privateKey);
        }
        verify(y, _) {
            return e.verify(y, this.publicKey, _);
        }
        verifySchnorr(y, _) {
            if (!e.verifySchnorr) throw new Error("verifySchnorr not supported by ecc library");
            return e.verifySchnorr(y, this.publicKey.subarray(1, 33), _);
        }
    }
    class o extends i {
        constructor(_, A, O, N, U = 0, D = 0, H = 0){
            super(_, A);
            pt(this, "chainCode");
            pt(this, "network");
            pt(this, "__DEPTH");
            pt(this, "__INDEX");
            pt(this, "__PARENT_FINGERPRINT");
            this.chainCode = O, this.network = N, this.__DEPTH = U, this.__INDEX = D, this.__PARENT_FINGERPRINT = H, qa(Fre, N);
        }
        get depth() {
            return this.__DEPTH;
        }
        get index() {
            return this.__INDEX;
        }
        get parentFingerprint() {
            return this.__PARENT_FINGERPRINT;
        }
        get identifier() {
            return vre(this.publicKey);
        }
        get fingerprint() {
            return this.identifier.slice(0, 4);
        }
        get compressed() {
            return !0;
        }
        // Private === not neutered
        // Public === neutered
        isNeutered() {
            return this.__D === void 0;
        }
        neutered() {
            return c(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
        }
        toBase58() {
            const _ = this.network, A = this.isNeutered() ? _.bip32.public : _.bip32.private, O = new Uint8Array(78);
            return Zu(O, 0, A, "BE"), W4(O, 4, this.depth), Zu(O, 5, this.parentFingerprint, "BE"), Zu(O, 9, this.index, "BE"), O.set(this.chainCode, 13), this.isNeutered() ? O.set(this.publicKey, 45) : (W4(O, 45, 0), O.set(this.privateKey, 46)), Ok.encode(O);
        }
        toWIF() {
            if (!this.privateKey) throw new TypeError("Missing private key");
            return Hre({
                version: this.network.wif,
                privateKey: this.privateKey
            });
        }
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
        derive(_) {
            qa(XE, _);
            const A = _ >= r, O = new Uint8Array(37);
            if (A) {
                if (this.isNeutered()) throw new TypeError("Missing private key for hardened child key");
                O[0] = 0, O.set(this.privateKey, 1), Zu(O, 33, _, "BE");
            } else O.set(this.publicKey, 0), Zu(O, 33, _, "BE");
            const N = kk(this.chainCode, O), U = N.slice(0, 32), D = N.slice(32);
            if (!e.isPrivate(U)) return this.derive(_ + 1);
            let H;
            if (this.isNeutered()) {
                const K = e.pointAddScalar(this.publicKey, U, !0);
                if (K === null) return this.derive(_ + 1);
                H = c(K, D, this.network, this.depth + 1, _, xl(this.fingerprint, 0, "BE"));
            } else {
                const K = e.privateAdd(this.privateKey, U);
                if (K == null) return this.derive(_ + 1);
                H = u(K, D, this.network, this.depth + 1, _, xl(this.fingerprint, 0, "BE"));
            }
            return H;
        }
        deriveHardened(_) {
            if (typeof qa($re, _) == "number") return this.derive(_ + r);
            throw new TypeError("Expected UInt31, got " + _);
        }
        derivePath(_) {
            qa(zre, _);
            let A = _.split("/");
            if (A[0] === "m") {
                if (this.parentFingerprint) throw new TypeError("Expected master, got child");
                A = A.slice(1);
            }
            return A.reduce((O, N)=>{
                let U;
                return N.slice(-1) === "'" ? (U = parseInt(N.slice(0, -1), 10), O.deriveHardened(U)) : (U = parseInt(N, 10), O.derive(U));
            }, this);
        }
        tweak(_) {
            return this.privateKey ? this.tweakFromPrivateKey(_) : this.tweakFromPublicKey(_);
        }
        tweakFromPublicKey(_) {
            const A = n(this.publicKey);
            if (!e.xOnlyPointAddTweak) throw new Error("xOnlyPointAddTweak not supported by ecc library");
            const O = e.xOnlyPointAddTweak(A, _);
            if (!O || O.xOnlyPubkey === null) throw new Error("Cannot tweak public key!");
            const N = Uint8Array.from([
                O.parity === 0 ? 2 : 3
            ]), U = sK([
                N,
                O.xOnlyPubkey
            ]);
            return new i(void 0, U);
        }
        tweakFromPrivateKey(_) {
            const A = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, O = (()=>{
                if (A) {
                    if (e.privateNegate) return e.privateNegate(this.privateKey);
                    throw new Error("privateNegate not supported by ecc library");
                } else return this.privateKey;
            })(), N = e.privateAdd(O, _);
            if (!N) throw new Error("Invalid tweaked private key!");
            return new i(N, void 0);
        }
    }
    function s(p, y) {
        const _ = Ok.decode(p);
        if (_.length !== 78) throw new TypeError("Invalid buffer length");
        y = y || t;
        const A = xl(_, 0, "BE");
        if (A !== y.bip32.private && A !== y.bip32.public) throw new TypeError("Invalid network version");
        const O = _[4], N = xl(_, 5, "BE");
        if (O === 0 && N !== 0) throw new TypeError("Invalid parent fingerprint");
        const U = xl(_, 9, "BE");
        if (O === 0 && U !== 0) throw new TypeError("Invalid index");
        const D = _.slice(13, 45);
        let H;
        if (A === y.bip32.private) {
            if (_[45] !== 0) throw new TypeError("Invalid private key");
            const K = _.slice(46, 78);
            H = u(K, D, y, O, U, N);
        } else {
            const K = _.slice(45, 78);
            H = c(K, D, y, O, U, N);
        }
        return H;
    }
    function a(p, y, _) {
        return u(p, y, _);
    }
    function u(p, y, _, A, O, N) {
        if (qa(__, p), qa(__, y), _ = _ || t, !e.isPrivate(p)) throw new TypeError("Private key not in range [1, n)");
        return new o(p, void 0, y, _, A, O, N);
    }
    function f(p, y, _) {
        return c(p, y, _);
    }
    function c(p, y, _, A, O, N) {
        if (qa(Dre, p), qa(__, y), _ = _ || t, !e.isPoint(p)) throw new TypeError("Point is not on the curve");
        return new o(void 0, p, y, _, A, O, N);
    }
    function l(p, y) {
        if (qa(Zb(Uint8Array), p), p.length < 16) throw new TypeError("Seed should be at least 128 bits");
        if (p.length > 64) throw new TypeError("Seed should be at most 512 bits");
        y = y || t;
        const _ = kk(oK("Bitcoin seed"), p), A = _.slice(0, 32), O = _.slice(32);
        return a(A, O, y);
    }
    return {
        fromSeed: l,
        fromBase58: s,
        fromPublicKey: f,
        fromPrivateKey: a
    };
}
const Rve = "text/html", Cve = "text/css", Kre = "text/plain", Uve = "text/javascript", $ve = "text/markdown", Lve = "application/json", Dve = "application/javascript", Fve = "application/xml", zve = "application/pdf", jve = "application/zip", Hve = "application/gzip", qve = "application/xhtml+xml", Kve = "application/rss+xml", Wve = "application/atom+xml", Vve = "application/x-www-form-urlencoded", Gve = "application/octet-stream", Zve = "image/jpeg", Yve = "image/png", Xve = "image/gif", Jve = "image/svg+xml", Qve = "image/webp", e2e = "image/x-icon", t2e = "video/mp4", r2e = "video/webm", n2e = "video/ogg", i2e = "audio/mpeg", o2e = "audio/wav", s2e = "audio/ogg", a2e = "multipart/form-data", Pk = "btc", Nk = "brc20", Mk = "runes", Rk = "alkanes", Xb = "bip322", f0 = "ecdsa", l0 = "bip322-simple", iN = async (e = ln)=>await rn.get(`${Bi(e)}/api/v1/fees/recommended`, {
        headers: {
            "Content-Type": "application/json"
        }
    }).then((t)=>t.data), Wre = qre(bb);
o3(bb);
async function Vre(e) {
    const t = crypto.getRandomValues(new Uint8Array(32)), r = hre(We.from(t)), n = await dre(r);
    return Wre.fromSeed(n, Dr(e)).derivePath("m/44'/0'/0'/0/0").privateKey;
}
const Jb = (e, t)=>{
    try {
        const r = Dr(t), n = _7(e);
        if (n.version === r.pubKeyHash) return uG;
        if (n.version === r.scriptHash) {
            const i = Sn(n.hash);
            return i && i.length === 2 && i[0] === Kr.OP_0 ? fG : Xp;
        }
    } catch  {
        try {
            const r = a3(e);
            if (r.version === 0 && r.data.length === 20) return Ay;
            if (r.version === 0 && r.data.length === 32) return lG;
            if (r.version === 1 && r.data.length === 32) return df;
        } catch  {
            return "unknown";
        }
    }
    return "unknown";
}, Gre = (e, t)=>{
    const r = Dr(t);
    return hs(e, r);
};
function oN(e, t) {
    const r = Dr(t);
    return hs(e, r);
}
function d0(e, t) {
    var i;
    const r = Gp({
        pubkey: We.from(e, "hex"),
        network: Dr(t)
    }), n = _d({
        redeem: r,
        network: Dr(t)
    });
    return (i = n == null ? void 0 : n.redeem) == null ? void 0 : i.output;
}
function di(e, t, r) {
    var n;
    if (!e || typeof e != "object") return r;
    for (const i of t)if (e[i] !== void 0) return ((n = e[i]) == null ? void 0 : n.toString()) || r;
    return r;
}
function Yg(e, t, r) {
    if (!e || typeof e != "object") return r;
    for (const n of t)if (e[n] !== void 0) {
        const i = Number(e[n]);
        return isNaN(i) ? r : i;
    }
    return r;
}
function Kl(e, t = "unknown", r) {
    var _, A;
    if (!e) return console.warn(`Invalid inscription data from source: ${t}`), {
        id: "",
        inscriptionId: "",
        content: "",
        number: 0,
        address: "",
        contentType: "unknown",
        output: "",
        location: "",
        preview: "",
        genesisTransaction: "",
        height: 0,
        outputValue: 0
    };
    const n = di(e, [
        "id",
        "inscription_id",
        "inscriptionId"
    ], ""), i = Yg(e, [
        "num",
        "number",
        "inscriptionNumber"
    ], 0), o = di(e, [
        "address",
        "owner",
        "ownerAddress"
    ], ""), s = di(e, [
        "content_type",
        "contentType",
        "mime",
        "mimeType"
    ], "unknown");
    let a = di(e, [
        "utxo_txid",
        "txid",
        "transaction_id"
    ], ""), u = Yg(e, [
        "vout",
        "utxo_vout"
    ], 0), f = di(e, [
        "output"
    ], "");
    f || a && (f = `${a}:${u}`), f && (!a || !u) && (console.warn(`Invalid inscription location from source: ${t}`), a = f.split(":")[0], u = Number.parseInt(f.split(":")[1]));
    const c = Yg(e, [
        "output_value",
        "value",
        "outputValue",
        "postage",
        "satoshis"
    ], 0), l = Yg(e, [
        "height",
        "block_height"
    ], 0);
    let p = di(e, [
        "genesis_tx_id",
        "genesisTx",
        "genesis_txid",
        "genesisTransaction"
    ], ((A = (_ = e.inscription_id) == null ? void 0 : _.split("i")) == null ? void 0 : A[0]) || e.txid || "");
    const y = e.utxo_sat_offset !== void 0 ? e.utxo_sat_offset : 0;
    if (!n) throw console.warn(`Invalid inscription data from source: ${t}`), new Error(`Invalid inscription data from source: ${t}`);
    if (!o) throw console.warn(`Invalid inscription address from source: ${t}`), new Error(`Invalid inscription address from source: ${t}`);
    if (!f) throw console.warn(`Invalid inscription output from source: ${t}`), new Error(`Invalid inscription output from source: ${t}`);
    if (!s) throw console.warn(`Invalid inscription content type from source: ${t}`), new Error(`Invalid inscription content type from source: ${t}`);
    return p || (p = n.split("i")[0]), {
        address: o,
        id: n,
        inscriptionId: n,
        number: i,
        outputValue: c,
        contentType: s,
        output: f,
        location: `${a}:${u}:${y}`,
        content: `${Wte(r)}/${n}`,
        preview: `${Vte(r)}/${n}`,
        genesisTransaction: p,
        height: l,
        offset: y
    };
}
function Zre(e, t = "unknown") {
    const r = [];
    if (!e) return console.warn(`Invalid BRC20 balance data from source: ${t}`), r;
    if (e.data && typeof e.data == "object") return Object.entries(e.data).forEach(([n, i])=>{
        const o = di(i, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), s = di(i, [
            "transferable",
            "transferableBalance"
        ], "na"), a = di(i, [
            "available",
            "availableBalance"
        ], "0");
        if (!o || !a) {
            console.warn(`Invalid BRC20 balance data from source: ${t}`);
            return;
        }
        const u = {
            ticker: n,
            overall: o,
            transferable: s ?? "na",
            available: a
        };
        r.push(u);
    }), r;
    if (Array.isArray(e)) return e.forEach((n)=>{
        const i = di(n, [
            "ticker",
            "tick",
            "token"
        ], "");
        if (!i) {
            console.warn(`Missing ticker in BRC20 balance from source: ${t}`);
            return;
        }
        const o = di(n, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), s = di(n, [
            "transferable",
            "transferableBalance"
        ], "0"), a = di(n, [
            "available",
            "availableBalance"
        ], "0");
        if (!o || !a) {
            console.warn(`Invalid BRC20 balance data from source: ${t}`);
            return;
        }
        const u = {
            ticker: i,
            overall: o,
            transferable: s ?? "na",
            available: a
        };
        r.push(u);
    }), r;
    if (typeof e == "object" && !Array.isArray(e)) {
        const n = di(e, [
            "ticker",
            "tick",
            "token"
        ], "");
        if (!n) return console.warn(`Missing ticker in BRC20 balance from source: ${t}`), r;
        const i = di(e, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), o = di(e, [
            "transferable",
            "transferableBalance"
        ], "0"), s = di(e, [
            "available",
            "availableBalance"
        ], "0");
        if (!i || !s) throw console.warn(`Invalid BRC20 balance data from source: ${t}`), new Error(`Invalid BRC20 balance data from source: ${t}`);
        const a = {
            ticker: n,
            overall: i,
            transferable: o ?? "na",
            available: s
        };
        return r.push(a), r;
    }
    return console.warn(`Unrecognized BRC20 balance format from source: ${t}`), r;
}
class Yre {
    constructor(t, r){
        pt(this, "apiUrl", "");
        pt(this, "apiKey", "");
        pt(this, "networks");
        this.networks = {
            [ao]: {
                apiKey: $P,
                apiUrl: cm(dt.TESTNET4)
            },
            ...r == null ? void 0 : r.networks
        }, this.setNetwork(t);
    }
    getName() {
        return t9;
    }
    setNetwork(t) {
        this.networks[t] ? (this.apiUrl = this.networks[t].apiUrl, this.apiKey = this.networks[t].apiKey) : (this.apiUrl = cm(t), this.apiKey = this.networks.mainnet.apiKey);
    }
    async call(t, r, n) {
        const i = `${this.apiUrl}${r}`;
        try {
            const o = {
                headers: {
                    "Content-Type": "application/json",
                    "api-key": this.apiKey
                }
            }, s = t === "get" ? await rn.get(i, o) : await rn.post(i, n, o);
            if (!s || !s.data) throw new Error(`Invalid response from Maestro API: ${JSON.stringify(s)}`);
            return s.data;
        } catch (o) {
            throw console.error("MaestroDataSource.call error:", o), o;
        }
    }
    async getAddressBtcBalance(t) {
        return (await this.call("get", `/addresses/${t}/balance`)).data;
    }
    async getAddressBrc20Balances(t) {
        return await this.call("get", `/addresses/${t}/brc20`);
    }
    async getAddressInscriptions(t, r = 0, n = 10) {
        let i, o = r, s = 100, a = null;
        for(; o > 0;){
            const p = Math.min(s, o), y = new URLSearchParams();
            y.append("count", p.toString()), i && y.append("cursor", i);
            const _ = `/addresses/${t}/inscriptions?${y.toString()}`;
            if (a = await this.call("get", _), !a.next_cursor && o > p) return {
                ...a,
                data: []
            };
            i = a.next_cursor, o -= p;
        }
        const u = new URLSearchParams();
        u.append("count", n.toString()), i && u.append("cursor", i);
        const f = `/addresses/${t}/inscriptions?${u.toString()}`, c = await this.call("get", f);
        return {
            ...c,
            data: c.data.map((p)=>({
                    ...p,
                    address: t
                }))
        };
    }
    async getInscriptionInfo(t) {
        return await this.call("get", `/assets/inscriptions/${t}`);
    }
    async getBrc20ByTicker(t) {
        return this.call("get", `/assets/brc20/${t}`);
    }
    async getRuneById(t) {
        return this.call("get", `/assets/runes/${t}`);
    }
    async getRuneByName(t) {
        return this.call("get", `/assets/runes/${t}`);
    }
    async getTransactionInfo(t) {
        return this.call("get", `/rpc/transaction/${t}`);
    }
    async broadcastTransaction(t) {
        return await this.call("post", "/arpc/transaction/submit", t);
    }
    async getRawTransaction(t) {
        return this.call("get", `/raw-transactions/${t}`);
    }
    async getRecommendedFees() {
        const r = (await this.call("get", "/mempool/fee_rates")).data[0].sats_per_vb, n = r.median, i = r.min;
        return {
            fastFee: n,
            minFee: i
        };
    }
    async getOrdAddress(t) {
        return this.call("get", `/inscriptions/${t}`);
    }
}
class Xre {
    constructor(t, r){
        pt(this, "apiUrl", "");
        pt(this, "networks");
        pt(this, "network");
        this.networks = {
            [ln]: {
                apiUrl: Bi("mainnet")
            },
            [Ni]: {
                apiUrl: Bi("testnet")
            },
            [ao]: {
                apiUrl: Bi("testnet4")
            },
            [Ro]: {
                apiUrl: Bi("signet")
            },
            [yc]: {
                apiUrl: Bi("fractal-mainnet")
            },
            [co]: {
                apiUrl: Bi("fractal-testnet")
            },
            ...r == null ? void 0 : r.networks
        }, this.network = t, this.setNetwork(t);
    }
    getName() {
        return vG;
    }
    setNetwork(t) {
        this.networks[t] ? this.apiUrl = this.networks[t].apiUrl : this.apiUrl = Bi(t), this.network = t;
    }
    async call(t, r, n) {
        try {
            const i = `${this.apiUrl}${r}`, o = {
                headers: {
                    "Content-Type": t === "post" ? "text/plain" : "application/json"
                }
            };
            return (t === "get" ? await rn.get(i, o) : await rn.post(i, n, o)).data;
        } catch (i) {
            throw console.error("MempoolSpaceDataSource.call error:", i), i;
        }
    }
    async getOutputValueByVOutIndex(t, r) {
        const i = Date.now();
        for(;;)try {
            const o = await this.getTransaction(t);
            if (o != null && o.vout && o.vout.length > 0) return Math.floor(o.vout[r].value);
            if (Date.now() - i > 6e4) return null;
            await new Promise((s)=>setTimeout(s, 5e3));
        } catch (o) {
            if (console.error("Error fetching transaction output value:", o), Date.now() - i > 6e4) return null;
            await new Promise((s)=>setTimeout(s, 5e3));
        }
    }
    async waitForTransaction(t) {
        const n = Date.now();
        for(;;)try {
            if (await this.getTransaction(t)) return console.log("Transaction found in mempool:", t), !0;
            if (Date.now() - n > 6e4) return !1;
            await new Promise((o)=>setTimeout(o, 5e3));
        } catch  {
            if (Date.now() - n > 6e4) return !1;
            await new Promise((o)=>setTimeout(o, 5e3));
        }
    }
    async getAddressUtxos(t) {
        if (t.startsWith("bcrt")) return [];
        const r = await this.call("get", `/api/address/${t}/utxo`), n = hs(t, Dr(this.network));
        return r.map((i)=>({
                ...i,
                scriptPk: We.from(n).toString("hex")
            }));
    }
    async getTransaction(t) {
        return await this.call("get", `/api/tx/${t}`);
    }
    async getRecommendedFees() {
        const t = await this.call("get", "/api/v1/fees/recommended"), r = t.fastestFee, n = t.minimumFee;
        return {
            fastFee: r,
            minFee: n
        };
    }
    async broadcastTransaction(t) {
        return await this.call("post", "/api/tx", t);
    }
}
async function* Jre(e, t, r) {
    const n = /* @__PURE__ */ new Set();
    async function i() {
        const [o, s] = await Promise.race(n);
        return n.delete(o), s;
    }
    for (const o of t){
        const s = (async ()=>await r(o, t))().then((a)=>[
                s,
                a
            ]);
        n.add(s), n.size >= e && (yield await i());
    }
    for(; n.size;)yield await i();
}
var Qre = Jre;
const ene = /* @__PURE__ */ c7(Qre);
var tS = {}, ka = {}, mo = {}, Lf = {}, rS = {};
(function(e) {
    var t = typeof Object.defineProperties == "function" ? Object.defineProperty : function(v, B, Y) {
        v != Array.prototype && v != Object.prototype && (v[B] = Y.value);
    }, r = (("TURBOPACK compile-time value", "undefined") < "u" && window === Ge || typeof Ge < "u" && Ge != null, Ge);
    function n(v, B) {
        if (B) {
            var Y = r;
            v = v.split(".");
            for(var pe = 0; pe < v.length - 1; pe++){
                var ke = v[pe];
                ke in Y || (Y[ke] = {}), Y = Y[ke];
            }
            v = v[v.length - 1], pe = Y[v], B = B(pe), B != pe && B != null && t(Y, v, {
                configurable: !0,
                writable: !0,
                value: B
            });
        }
    }
    function i(v) {
        var B = 0;
        return function() {
            return B < v.length ? {
                done: !1,
                value: v[B++]
            } : {
                done: !0
            };
        };
    }
    function o() {
        o = function() {}, r.Symbol || (r.Symbol = a);
    }
    function s(v, B) {
        this.a = v, t(this, "description", {
            configurable: !0,
            writable: !0,
            value: B
        });
    }
    s.prototype.toString = function() {
        return this.a;
    };
    var a = /* @__PURE__ */ function() {
        function v(Y) {
            if (this instanceof v) throw new TypeError("Symbol is not a constructor");
            return new s("jscomp_symbol_" + (Y || "") + "_" + B++, Y);
        }
        var B = 0;
        return v;
    }();
    function u() {
        o();
        var v = r.Symbol.iterator;
        v || (v = r.Symbol.iterator = r.Symbol("Symbol.iterator")), typeof Array.prototype[v] != "function" && t(Array.prototype, v, {
            configurable: !0,
            writable: !0,
            value: function() {
                return f(i(this));
            }
        }), u = function() {};
    }
    function f(v) {
        return u(), v = {
            next: v
        }, v[r.Symbol.iterator] = function() {
            return this;
        }, v;
    }
    function c(v, B) {
        u(), v instanceof String && (v += "");
        var Y = 0, pe = {
            next: function() {
                if (Y < v.length) {
                    var ke = Y++;
                    return {
                        value: B(ke, v[ke]),
                        done: !1
                    };
                }
                return pe.next = function() {
                    return {
                        done: !0,
                        value: void 0
                    };
                }, pe.next();
            }
        };
        return pe[Symbol.iterator] = function() {
            return pe;
        }, pe;
    }
    n("Array.prototype.entries", function(v) {
        return v || function() {
            return c(this, function(B, Y) {
                return [
                    B,
                    Y
                ];
            });
        };
    });
    var l = Ge || self;
    function p(v, B, Y) {
        v = v.split("."), Y = Y || l, v[0] in Y || typeof Y.execScript > "u" || Y.execScript("var " + v[0]);
        for(var pe; v.length && (pe = v.shift());)v.length || B === void 0 ? Y[pe] && Y[pe] !== Object.prototype[pe] ? Y = Y[pe] : Y = Y[pe] = {} : Y[pe] = B;
    }
    function y(v) {
        var B = typeof v;
        if (B == "object") if (v) {
            if (v instanceof Array) return "array";
            if (v instanceof Object) return B;
            var Y = Object.prototype.toString.call(v);
            if (Y == "[object Window]") return "object";
            if (Y == "[object Array]" || typeof v.length == "number" && typeof v.splice < "u" && typeof v.propertyIsEnumerable < "u" && !v.propertyIsEnumerable("splice")) return "array";
            if (Y == "[object Function]" || typeof v.call < "u" && typeof v.propertyIsEnumerable < "u" && !v.propertyIsEnumerable("call")) return "function";
        } else return "null";
        else if (B == "function" && typeof v.call > "u") return "object";
        return B;
    }
    function _(v) {
        var B = typeof v;
        return B == "object" && v != null || B == "function";
    }
    function A(v, B, Y) {
        p(v, B, Y);
    }
    function O(v, B) {
        function Y() {}
        Y.prototype = B.prototype, v.prototype = new Y(), v.prototype.constructor = v;
    }
    var N = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    function U(v, B) {
        for(var Y, pe, ke = 1; ke < arguments.length; ke++){
            pe = arguments[ke];
            for(Y in pe)v[Y] = pe[Y];
            for(var qe = 0; qe < N.length; qe++)Y = N[qe], Object.prototype.hasOwnProperty.call(pe, Y) && (v[Y] = pe[Y]);
        }
    }
    var D = Array.prototype.forEach ? function(v, B) {
        Array.prototype.forEach.call(v, B, void 0);
    } : function(v, B) {
        for(var Y = v.length, pe = typeof v == "string" ? v.split("") : v, ke = 0; ke < Y; ke++)ke in pe && B.call(void 0, pe[ke], ke, v);
    }, H = Array.prototype.map ? function(v, B) {
        return Array.prototype.map.call(v, B, void 0);
    } : function(v, B) {
        for(var Y = v.length, pe = Array(Y), ke = typeof v == "string" ? v.split("") : v, qe = 0; qe < Y; qe++)qe in ke && (pe[qe] = B.call(void 0, ke[qe], qe, v));
        return pe;
    };
    function K(v, B, Y) {
        return 2 >= arguments.length ? Array.prototype.slice.call(v, B) : Array.prototype.slice.call(v, B, Y);
    }
    function re(v, B, Y, pe) {
        var ke = "Assertion failed";
        if (Y) {
            ke += ": " + Y;
            var qe = pe;
        } else v && (ke += ": " + v, qe = B);
        throw Error(ke, qe || []);
    }
    function Q(v, B, Y) {
        for(var pe = [], ke = 2; ke < arguments.length; ++ke)pe[ke - 2] = arguments[ke];
        return v || re("", null, B, pe), v;
    }
    function G(v, B, Y) {
        for(var pe = [], ke = 2; ke < arguments.length; ++ke)pe[ke - 2] = arguments[ke];
        typeof v != "string" && re("Expected string but got %s: %s.", [
            y(v),
            v
        ], B, pe);
    }
    function R(v, B, Y) {
        for(var pe = [], ke = 2; ke < arguments.length; ++ke)pe[ke - 2] = arguments[ke];
        Array.isArray(v) || re("Expected array but got %s: %s.", [
            y(v),
            v
        ], B, pe);
    }
    function X(v, B) {
        for(var Y = [], pe = 1; pe < arguments.length; ++pe)Y[pe - 1] = arguments[pe];
        throw Error("Failure" + (v ? ": " + v : ""), Y);
    }
    function $(v, B, Y, pe) {
        for(var ke = [], qe = 3; qe < arguments.length; ++qe)ke[qe - 3] = arguments[qe];
        v instanceof B || re("Expected instanceof %s but got %s.", [
            S(B),
            S(v)
        ], Y, ke);
    }
    function S(v) {
        return v instanceof Function ? v.displayName || v.name || "unknown type name" : v instanceof Object ? v.constructor.displayName || v.constructor.name || Object.prototype.toString.call(v) : v === null ? "null" : typeof v;
    }
    function w(v, B) {
        if (this.c = v, this.b = B, this.a = {}, this.arrClean = !0, 0 < this.c.length) {
            for(v = 0; v < this.c.length; v++){
                B = this.c[v];
                var Y = B[0];
                this.a[Y.toString()] = new T(Y, B[1]);
            }
            this.arrClean = !0;
        }
    }
    p("jspb.Map", w, void 0), w.prototype.g = function() {
        if (this.arrClean) {
            if (this.b) {
                var v = this.a, B;
                for(B in v)if (Object.prototype.hasOwnProperty.call(v, B)) {
                    var Y = v[B].a;
                    Y && Y.g();
                }
            }
        } else {
            for(this.c.length = 0, v = E(this), v.sort(), B = 0; B < v.length; B++){
                var pe = this.a[v[B]];
                (Y = pe.a) && Y.g(), this.c.push([
                    pe.key,
                    pe.value
                ]);
            }
            this.arrClean = !0;
        }
        return this.c;
    }, w.prototype.toArray = w.prototype.g, w.prototype.Mc = function(v, B) {
        for(var Y = this.g(), pe = [], ke = 0; ke < Y.length; ke++){
            var qe = this.a[Y[ke][0].toString()];
            m(this, qe);
            var ut = qe.a;
            ut ? (Q(B), pe.push([
                qe.key,
                B(v, ut)
            ])) : pe.push([
                qe.key,
                qe.value
            ]);
        }
        return pe;
    }, w.prototype.toObject = w.prototype.Mc, w.fromObject = function(v, B, Y) {
        B = new w([], B);
        for(var pe = 0; pe < v.length; pe++){
            var ke = v[pe][0], qe = Y(v[pe][1]);
            B.set(ke, qe);
        }
        return B;
    };
    function g(v) {
        this.a = 0, this.b = v;
    }
    g.prototype.next = function() {
        return this.a < this.b.length ? {
            done: !1,
            value: this.b[this.a++]
        } : {
            done: !0,
            value: void 0
        };
    }, typeof Symbol < "u" && (g.prototype[Symbol.iterator] = function() {
        return this;
    }), w.prototype.Jb = function() {
        return E(this).length;
    }, w.prototype.getLength = w.prototype.Jb, w.prototype.clear = function() {
        this.a = {}, this.arrClean = !1;
    }, w.prototype.clear = w.prototype.clear, w.prototype.Cb = function(v) {
        v = v.toString();
        var B = this.a.hasOwnProperty(v);
        return delete this.a[v], this.arrClean = !1, B;
    }, w.prototype.del = w.prototype.Cb, w.prototype.Eb = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++){
            var pe = this.a[B[Y]];
            v.push([
                pe.key,
                pe.value
            ]);
        }
        return v;
    }, w.prototype.getEntryList = w.prototype.Eb, w.prototype.entries = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++){
            var pe = this.a[B[Y]];
            v.push([
                pe.key,
                m(this, pe)
            ]);
        }
        return new g(v);
    }, w.prototype.entries = w.prototype.entries, w.prototype.keys = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++)v.push(this.a[B[Y]].key);
        return new g(v);
    }, w.prototype.keys = w.prototype.keys, w.prototype.values = function() {
        var v = [], B = E(this);
        B.sort();
        for(var Y = 0; Y < B.length; Y++)v.push(m(this, this.a[B[Y]]));
        return new g(v);
    }, w.prototype.values = w.prototype.values, w.prototype.forEach = function(v, B) {
        var Y = E(this);
        Y.sort();
        for(var pe = 0; pe < Y.length; pe++){
            var ke = this.a[Y[pe]];
            v.call(B, m(this, ke), ke.key, this);
        }
    }, w.prototype.forEach = w.prototype.forEach, w.prototype.set = function(v, B) {
        var Y = new T(v);
        return this.b ? (Y.a = B, Y.value = B.g()) : Y.value = B, this.a[v.toString()] = Y, this.arrClean = !1, this;
    }, w.prototype.set = w.prototype.set;
    function m(v, B) {
        return v.b ? (B.a || (B.a = new v.b(B.value)), B.a) : B.value;
    }
    w.prototype.get = function(v) {
        if (v = this.a[v.toString()]) return m(this, v);
    }, w.prototype.get = w.prototype.get, w.prototype.has = function(v) {
        return v.toString() in this.a;
    }, w.prototype.has = w.prototype.has, w.prototype.Jc = function(v, B, Y, pe, ke) {
        var qe = E(this);
        qe.sort();
        for(var ut = 0; ut < qe.length; ut++){
            var Ft = this.a[qe[ut]];
            B.Va(v), Y.call(B, 1, Ft.key), this.b ? pe.call(B, 2, m(this, Ft), ke) : pe.call(B, 2, Ft.value), B.Ya();
        }
    }, w.prototype.serializeBinary = w.prototype.Jc, w.deserializeBinary = function(v, B, Y, pe, ke, qe, ut) {
        for(; B.oa() && !B.bb();){
            var Ft = B.c;
            Ft == 1 ? qe = Y.call(B) : Ft == 2 && (v.b ? (Q(ke), ut || (ut = new v.b()), pe.call(B, ut, ke)) : ut = pe.call(B));
        }
        Q(qe != null), Q(ut != null), v.set(qe, ut);
    };
    function E(v) {
        v = v.a;
        var B = [], Y;
        for(Y in v)Object.prototype.hasOwnProperty.call(v, Y) && B.push(Y);
        return B;
    }
    function T(v, B) {
        this.key = v, this.value = B, this.a = void 0;
    }
    function I(v) {
        if (8192 >= v.length) return String.fromCharCode.apply(null, v);
        for(var B = "", Y = 0; Y < v.length; Y += 8192)B += String.fromCharCode.apply(null, K(v, Y, Y + 8192));
        return B;
    }
    var P = {
        "\0": "\\0",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\x0B",
        '"': '\\"',
        "\\": "\\\\",
        "<": "\\u003C"
    }, k = {
        "'": "\\'"
    }, L = {}, j = null;
    function ie(v, B) {
        B === void 0 && (B = 0), he(), B = L[B];
        for(var Y = [], pe = 0; pe < v.length; pe += 3){
            var ke = v[pe], qe = pe + 1 < v.length, ut = qe ? v[pe + 1] : 0, Ft = pe + 2 < v.length, pn = Ft ? v[pe + 2] : 0, bs = ke >> 2;
            ke = (ke & 3) << 4 | ut >> 4, ut = (ut & 15) << 2 | pn >> 6, pn &= 63, Ft || (pn = 64, qe || (ut = 64)), Y.push(B[bs], B[ke], B[ut] || "", B[pn] || "");
        }
        return Y.join("");
    }
    function ue(v) {
        var B = v.length, Y = 3 * B / 4;
        Y % 3 ? Y = Math.floor(Y) : "=.".indexOf(v[B - 1]) != -1 && (Y = "=.".indexOf(v[B - 2]) != -1 ? Y - 2 : Y - 1);
        var pe = new Uint8Array(Y), ke = 0;
        return ce(v, function(qe) {
            pe[ke++] = qe;
        }), pe.subarray(0, ke);
    }
    function ce(v, B) {
        function Y(pn) {
            for(; pe < v.length;){
                var bs = v.charAt(pe++), M0 = j[bs];
                if (M0 != null) return M0;
                if (!/^[\s\xa0]*$/.test(bs)) throw Error("Unknown base64 encoding at char: " + bs);
            }
            return pn;
        }
        he();
        for(var pe = 0;;){
            var ke = Y(-1), qe = Y(0), ut = Y(64), Ft = Y(64);
            if (Ft === 64 && ke === -1) break;
            B(ke << 2 | qe >> 4), ut != 64 && (B(qe << 4 & 240 | ut >> 2), Ft != 64 && B(ut << 6 & 192 | Ft));
        }
    }
    function he() {
        if (!j) {
            j = {};
            for(var v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), B = [
                "+/=",
                "+/",
                "-_=",
                "-_.",
                "-_"
            ], Y = 0; 5 > Y; Y++){
                var pe = v.concat(B[Y].split(""));
                L[Y] = pe;
                for(var ke = 0; ke < pe.length; ke++){
                    var qe = pe[ke];
                    j[qe] === void 0 && (j[qe] = ke);
                }
            }
        }
    }
    p("jspb.ConstBinaryMessage", function() {}, void 0), p("jspb.BinaryMessage", function() {}, void 0), p("jspb.BinaryConstants.FieldType", {
        yb: -1,
        ee: 1,
        FLOAT: 2,
        ke: 3,
        te: 4,
        je: 5,
        xb: 6,
        wb: 7,
        BOOL: 8,
        re: 9,
        ie: 10,
        le: 11,
        ce: 12,
        se: 13,
        ge: 14,
        me: 15,
        ne: 16,
        oe: 17,
        pe: 18,
        he: 30,
        ve: 31
    }, void 0), p("jspb.BinaryConstants.WireType", {
        yb: -1,
        ue: 0,
        xb: 1,
        de: 2,
        qe: 3,
        fe: 4,
        wb: 5
    }, void 0), p("jspb.BinaryConstants.FieldTypeToWireType", function(v) {
        switch(v){
            case 5:
            case 3:
            case 13:
            case 4:
            case 17:
            case 18:
            case 8:
            case 14:
            case 31:
                return 0;
            case 1:
            case 6:
            case 16:
            case 30:
                return 1;
            case 9:
            case 11:
            case 12:
                return 2;
            case 2:
            case 7:
            case 15:
                return 5;
            default:
                return -1;
        }
    }, void 0), p("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0), p("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0), p("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0), p("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0), p("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0), p("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0), p("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0), p("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0), p("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0), p("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0), p("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0), p("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0), p("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0), p("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0), p("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
    var ee = 0, ae = 0;
    p("jspb.utils.getSplit64Low", function() {
        return ee;
    }, void 0), p("jspb.utils.getSplit64High", function() {
        return ae;
    }, void 0);
    function ye(v) {
        var B = v >>> 0;
        v = Math.floor((v - B) / 4294967296) >>> 0, ee = B, ae = v;
    }
    p("jspb.utils.splitUint64", ye, void 0);
    function Se(v) {
        var B = 0 > v;
        v = Math.abs(v);
        var Y = v >>> 0;
        v = Math.floor((v - Y) / 4294967296), v >>>= 0, B && (v = ~v >>> 0, Y = (~Y >>> 0) + 1, 4294967295 < Y && (Y = 0, v++, 4294967295 < v && (v = 0))), ee = Y, ae = v;
    }
    p("jspb.utils.splitInt64", Se, void 0);
    function De(v) {
        var B = 0 > v;
        v = 2 * Math.abs(v), ye(v), v = ee;
        var Y = ae;
        B && (v == 0 ? Y == 0 ? Y = v = 4294967295 : (Y--, v = 4294967295) : v--), ee = v, ae = Y;
    }
    p("jspb.utils.splitZigzag64", De, void 0);
    function Re(v) {
        var B = 0 > v ? 1 : 0;
        if (v = B ? -v : v, v === 0) 0 < 1 / v ? ee = ae = 0 : (ae = 0, ee = 2147483648);
        else if (isNaN(v)) ae = 0, ee = 2147483647;
        else if (34028234663852886e22 < v) ae = 0, ee = (B << 31 | 2139095040) >>> 0;
        else if (11754943508222875e-54 > v) v = Math.round(v / Math.pow(2, -149)), ae = 0, ee = (B << 31 | v) >>> 0;
        else {
            var Y = Math.floor(Math.log(v) / Math.LN2);
            v *= Math.pow(2, -Y), v = Math.round(8388608 * v), 16777216 <= v && ++Y, ae = 0, ee = (B << 31 | Y + 127 << 23 | v & 8388607) >>> 0;
        }
    }
    p("jspb.utils.splitFloat32", Re, void 0);
    function Ce(v) {
        var B = 0 > v ? 1 : 0;
        if (v = B ? -v : v, v === 0) ae = 0 < 1 / v ? 0 : 2147483648, ee = 0;
        else if (isNaN(v)) ae = 2147483647, ee = 4294967295;
        else if (17976931348623157e292 < v) ae = (B << 31 | 2146435072) >>> 0, ee = 0;
        else if (22250738585072014e-324 > v) v /= Math.pow(2, -1074), ae = (B << 31 | v / 4294967296) >>> 0, ee = v >>> 0;
        else {
            var Y = v, pe = 0;
            if (2 <= Y) for(; 2 <= Y && 1023 > pe;)pe++, Y /= 2;
            else for(; 1 > Y && -1022 < pe;)Y *= 2, pe--;
            v *= Math.pow(2, -pe), ae = (B << 31 | pe + 1023 << 20 | 1048576 * v & 1048575) >>> 0, ee = 4503599627370496 * v >>> 0;
        }
    }
    p("jspb.utils.splitFloat64", Ce, void 0);
    function M(v) {
        var B = v.charCodeAt(4), Y = v.charCodeAt(5), pe = v.charCodeAt(6), ke = v.charCodeAt(7);
        ee = v.charCodeAt(0) + (v.charCodeAt(1) << 8) + (v.charCodeAt(2) << 16) + (v.charCodeAt(3) << 24) >>> 0, ae = B + (Y << 8) + (pe << 16) + (ke << 24) >>> 0;
    }
    p("jspb.utils.splitHash64", M, void 0);
    function z(v, B) {
        return 4294967296 * B + (v >>> 0);
    }
    p("jspb.utils.joinUint64", z, void 0);
    function de(v, B) {
        var Y = B & 2147483648;
        return Y && (v = ~v + 1 >>> 0, B = ~B >>> 0, v == 0 && (B = B + 1 >>> 0)), v = z(v, B), Y ? -v : v;
    }
    p("jspb.utils.joinInt64", de, void 0);
    function _e(v, B, Y) {
        var pe = B >> 31;
        return Y(v << 1 ^ pe, (B << 1 | v >>> 31) ^ pe);
    }
    p("jspb.utils.toZigzag64", _e, void 0);
    function Ie(v, B) {
        return je(v, B, de);
    }
    p("jspb.utils.joinZigzag64", Ie, void 0);
    function je(v, B, Y) {
        var pe = -(v & 1);
        return Y((v >>> 1 | B << 31) ^ pe, B >>> 1 ^ pe);
    }
    p("jspb.utils.fromZigzag64", je, void 0);
    function Ke(v) {
        var B = 2 * (v >> 31) + 1, Y = v >>> 23 & 255;
        return v &= 8388607, Y == 255 ? v ? NaN : 1 / 0 * B : Y == 0 ? B * Math.pow(2, -149) * v : B * Math.pow(2, Y - 150) * (v + Math.pow(2, 23));
    }
    p("jspb.utils.joinFloat32", Ke, void 0);
    function Ue(v, B) {
        var Y = 2 * (B >> 31) + 1, pe = B >>> 20 & 2047;
        return v = 4294967296 * (B & 1048575) + v, pe == 2047 ? v ? NaN : 1 / 0 * Y : pe == 0 ? Y * Math.pow(2, -1074) * v : Y * Math.pow(2, pe - 1075) * (v + 4503599627370496);
    }
    p("jspb.utils.joinFloat64", Ue, void 0);
    function h(v, B) {
        return String.fromCharCode(v >>> 0 & 255, v >>> 8 & 255, v >>> 16 & 255, v >>> 24 & 255, B >>> 0 & 255, B >>> 8 & 255, B >>> 16 & 255, B >>> 24 & 255);
    }
    p("jspb.utils.joinHash64", h, void 0), p("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
    function x(v, B) {
        function Y(ke, qe) {
            return ke = ke ? String(ke) : "", qe ? "0000000".slice(ke.length) + ke : ke;
        }
        if (2097151 >= B) return "" + z(v, B);
        var pe = (v >>> 24 | B << 8) >>> 0 & 16777215;
        return B = B >> 16 & 65535, v = (v & 16777215) + 6777216 * pe + 6710656 * B, pe += 8147497 * B, B *= 2, 1e7 <= v && (pe += Math.floor(v / 1e7), v %= 1e7), 1e7 <= pe && (B += Math.floor(pe / 1e7), pe %= 1e7), Y(B, 0) + Y(pe, B) + Y(v, 1);
    }
    p("jspb.utils.joinUnsignedDecimalString", x, void 0);
    function q(v, B) {
        var Y = B & 2147483648;
        return Y && (v = ~v + 1 >>> 0, B = ~B + (v == 0 ? 1 : 0) >>> 0), v = x(v, B), Y ? "-" + v : v;
    }
    p("jspb.utils.joinSignedDecimalString", q, void 0);
    function te(v, B) {
        M(v), v = ee;
        var Y = ae;
        return B ? q(v, Y) : x(v, Y);
    }
    p("jspb.utils.hash64ToDecimalString", te, void 0), p("jspb.utils.hash64ArrayToDecimalStrings", function(v, B) {
        for(var Y = Array(v.length), pe = 0; pe < v.length; pe++)Y[pe] = te(v[pe], B);
        return Y;
    }, void 0);
    function fe(v) {
        function B(ut, Ft) {
            for(var pn = 0; 8 > pn && (ut !== 1 || 0 < Ft); pn++)Ft = ut * ke[pn] + Ft, ke[pn] = Ft & 255, Ft >>>= 8;
        }
        function Y() {
            for(var ut = 0; 8 > ut; ut++)ke[ut] = ~ke[ut] & 255;
        }
        Q(0 < v.length);
        var pe = !1;
        v[0] === "-" && (pe = !0, v = v.slice(1));
        for(var ke = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ], qe = 0; qe < v.length; qe++)B(10, v.charCodeAt(qe) - 48);
        return pe && (Y(), B(1, 1)), I(ke);
    }
    p("jspb.utils.decimalStringToHash64", fe, void 0), p("jspb.utils.splitDecimalString", function(v) {
        M(fe(v));
    }, void 0);
    function ne(v) {
        return String.fromCharCode(10 > v ? 48 + v : 87 + v);
    }
    function W(v) {
        return 97 <= v ? v - 97 + 10 : v - 48;
    }
    p("jspb.utils.hash64ToHexString", function(v) {
        var B = Array(18);
        B[0] = "0", B[1] = "x";
        for(var Y = 0; 8 > Y; Y++){
            var pe = v.charCodeAt(7 - Y);
            B[2 * Y + 2] = ne(pe >> 4), B[2 * Y + 3] = ne(pe & 15);
        }
        return B.join("");
    }, void 0), p("jspb.utils.hexStringToHash64", function(v) {
        v = v.toLowerCase(), Q(v.length == 18), Q(v[0] == "0"), Q(v[1] == "x");
        for(var B = "", Y = 0; 8 > Y; Y++)B = String.fromCharCode(16 * W(v.charCodeAt(2 * Y + 2)) + W(v.charCodeAt(2 * Y + 3))) + B;
        return B;
    }, void 0), p("jspb.utils.hash64ToNumber", function(v, B) {
        M(v), v = ee;
        var Y = ae;
        return B ? de(v, Y) : z(v, Y);
    }, void 0), p("jspb.utils.numberToHash64", function(v) {
        return Se(v), h(ee, ae);
    }, void 0), p("jspb.utils.countVarints", function(v, B, Y) {
        for(var pe = 0, ke = B; ke < Y; ke++)pe += v[ke] >> 7;
        return Y - B - pe;
    }, void 0), p("jspb.utils.countVarintFields", function(v, B, Y, pe) {
        var ke = 0;
        if (pe *= 8, 128 > pe) for(; B < Y && v[B++] == pe;)for(ke++;;){
            var qe = v[B++];
            if (!(qe & 128)) break;
        }
        else for(; B < Y;){
            for(qe = pe; 128 < qe;){
                if (v[B] != (qe & 127 | 128)) return ke;
                B++, qe >>= 7;
            }
            if (v[B++] != qe) break;
            for(ke++; qe = v[B++], (qe & 128) != 0;);
        }
        return ke;
    }, void 0);
    function J(v, B, Y, pe, ke) {
        var qe = 0;
        if (128 > pe) for(; B < Y && v[B++] == pe;)qe++, B += ke;
        else for(; B < Y;){
            for(var ut = pe; 128 < ut;){
                if (v[B++] != (ut & 127 | 128)) return qe;
                ut >>= 7;
            }
            if (v[B++] != ut) break;
            qe++, B += ke;
        }
        return qe;
    }
    p("jspb.utils.countFixed32Fields", function(v, B, Y, pe) {
        return J(v, B, Y, 8 * pe + 5, 4);
    }, void 0), p("jspb.utils.countFixed64Fields", function(v, B, Y, pe) {
        return J(v, B, Y, 8 * pe + 1, 8);
    }, void 0), p("jspb.utils.countDelimitedFields", function(v, B, Y, pe) {
        var ke = 0;
        for(pe = 8 * pe + 2; B < Y;){
            for(var qe = pe; 128 < qe;){
                if (v[B++] != (qe & 127 | 128)) return ke;
                qe >>= 7;
            }
            if (v[B++] != qe) break;
            ke++;
            for(var ut = 0, Ft = 1; qe = v[B++], ut += (qe & 127) * Ft, Ft *= 128, (qe & 128) != 0;);
            B += ut;
        }
        return ke;
    }, void 0), p("jspb.utils.debugBytesToTextFormat", function(v) {
        var B = '"';
        if (v) {
            v = V(v);
            for(var Y = 0; Y < v.length; Y++)B += "\\x", 16 > v[Y] && (B += "0"), B += v[Y].toString(16);
        }
        return B + '"';
    }, void 0), p("jspb.utils.debugScalarToTextFormat", function(v) {
        if (typeof v == "string") {
            v = String(v);
            for(var B = [
                '"'
            ], Y = 0; Y < v.length; Y++){
                var pe = v.charAt(Y), ke = pe.charCodeAt(0), qe = Y + 1, ut;
                (ut = P[pe]) || (31 < ke && 127 > ke || (ke = pe, ke in k ? pe = k[ke] : ke in P ? pe = k[ke] = P[ke] : (ut = ke.charCodeAt(0), 31 < ut && 127 > ut ? pe = ke : (256 > ut ? (pe = "\\x", (16 > ut || 256 < ut) && (pe += "0")) : (pe = "\\u", 4096 > ut && (pe += "0")), pe += ut.toString(16).toUpperCase()), pe = k[ke] = pe)), ut = pe), B[qe] = ut;
            }
            B.push('"'), v = B.join("");
        } else v = v.toString();
        return v;
    }, void 0), p("jspb.utils.stringToByteArray", function(v) {
        for(var B = new Uint8Array(v.length), Y = 0; Y < v.length; Y++){
            var pe = v.charCodeAt(Y);
            if (255 < pe) throw Error("Conversion error: string contains codepoint outside of byte range");
            B[Y] = pe;
        }
        return B;
    }, void 0);
    function V(v) {
        return v.constructor === Uint8Array ? v : v.constructor === ArrayBuffer ? new Uint8Array(v) : v.constructor === Array ? new Uint8Array(v) : v.constructor === String ? ue(v) : v instanceof Uint8Array ? new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : (X("Type not convertible to Uint8Array."), new Uint8Array(0));
    }
    p("jspb.utils.byteSourceToUint8Array", V, void 0);
    function C(v, B, Y) {
        this.b = null, this.a = this.c = this.h = 0, this.v = !1, v && this.H(v, B, Y);
    }
    p("jspb.BinaryDecoder", C, void 0);
    var Z = [];
    C.getInstanceCacheLength = function() {
        return Z.length;
    };
    function le(v, B, Y) {
        if (Z.length) {
            var pe = Z.pop();
            return v && pe.H(v, B, Y), pe;
        }
        return new C(v, B, Y);
    }
    C.alloc = le, C.prototype.Ca = function() {
        this.clear(), 100 > Z.length && Z.push(this);
    }, C.prototype.free = C.prototype.Ca, C.prototype.clone = function() {
        return le(this.b, this.h, this.c - this.h);
    }, C.prototype.clone = C.prototype.clone, C.prototype.clear = function() {
        this.b = null, this.a = this.c = this.h = 0, this.v = !1;
    }, C.prototype.clear = C.prototype.clear, C.prototype.Y = function() {
        return this.b;
    }, C.prototype.getBuffer = C.prototype.Y, C.prototype.H = function(v, B, Y) {
        this.b = V(v), this.h = B !== void 0 ? B : 0, this.c = Y !== void 0 ? this.h + Y : this.b.length, this.a = this.h;
    }, C.prototype.setBlock = C.prototype.H, C.prototype.Db = function() {
        return this.c;
    }, C.prototype.getEnd = C.prototype.Db, C.prototype.setEnd = function(v) {
        this.c = v;
    }, C.prototype.setEnd = C.prototype.setEnd, C.prototype.reset = function() {
        this.a = this.h;
    }, C.prototype.reset = C.prototype.reset, C.prototype.B = function() {
        return this.a;
    }, C.prototype.getCursor = C.prototype.B, C.prototype.Ma = function(v) {
        this.a = v;
    }, C.prototype.setCursor = C.prototype.Ma, C.prototype.advance = function(v) {
        this.a += v, Q(this.a <= this.c);
    }, C.prototype.advance = C.prototype.advance, C.prototype.ya = function() {
        return this.a == this.c;
    }, C.prototype.atEnd = C.prototype.ya, C.prototype.Qb = function() {
        return this.a > this.c;
    }, C.prototype.pastEnd = C.prototype.Qb, C.prototype.getError = function() {
        return this.v || 0 > this.a || this.a > this.c;
    }, C.prototype.getError = C.prototype.getError, C.prototype.w = function(v) {
        for(var B = 128, Y = 0, pe = 0, ke = 0; 4 > ke && 128 <= B; ke++)B = this.b[this.a++], Y |= (B & 127) << 7 * ke;
        if (128 <= B && (B = this.b[this.a++], Y |= (B & 127) << 28, pe |= (B & 127) >> 4), 128 <= B) for(ke = 0; 5 > ke && 128 <= B; ke++)B = this.b[this.a++], pe |= (B & 127) << 7 * ke + 3;
        if (128 > B) return v(Y >>> 0, pe >>> 0);
        X("Failed to read varint, encoding is invalid."), this.v = !0;
    }, C.prototype.readSplitVarint64 = C.prototype.w, C.prototype.ea = function(v) {
        return this.w(function(B, Y) {
            return je(B, Y, v);
        });
    }, C.prototype.readSplitZigzagVarint64 = C.prototype.ea, C.prototype.ta = function(v) {
        var B = this.b, Y = this.a;
        this.a += 8;
        for(var pe = 0, ke = 0, qe = Y + 7; qe >= Y; qe--)pe = pe << 8 | B[qe], ke = ke << 8 | B[qe + 4];
        return v(pe, ke);
    }, C.prototype.readSplitFixed64 = C.prototype.ta, C.prototype.kb = function() {
        for(; this.b[this.a] & 128;)this.a++;
        this.a++;
    }, C.prototype.skipVarint = C.prototype.kb, C.prototype.mb = function(v) {
        for(; 128 < v;)this.a--, v >>>= 7;
        this.a--;
    }, C.prototype.unskipVarint = C.prototype.mb, C.prototype.o = function() {
        var v = this.b, B = v[this.a], Y = B & 127;
        return 128 > B ? (this.a += 1, Q(this.a <= this.c), Y) : (B = v[this.a + 1], Y |= (B & 127) << 7, 128 > B ? (this.a += 2, Q(this.a <= this.c), Y) : (B = v[this.a + 2], Y |= (B & 127) << 14, 128 > B ? (this.a += 3, Q(this.a <= this.c), Y) : (B = v[this.a + 3], Y |= (B & 127) << 21, 128 > B ? (this.a += 4, Q(this.a <= this.c), Y) : (B = v[this.a + 4], Y |= (B & 15) << 28, 128 > B ? (this.a += 5, Q(this.a <= this.c), Y >>> 0) : (this.a += 5, 128 <= v[this.a++] && 128 <= v[this.a++] && 128 <= v[this.a++] && 128 <= v[this.a++] && 128 <= v[this.a++] && Q(!1), Q(this.a <= this.c), Y)))));
    }, C.prototype.readUnsignedVarint32 = C.prototype.o, C.prototype.da = function() {
        return ~~this.o();
    }, C.prototype.readSignedVarint32 = C.prototype.da, C.prototype.O = function() {
        return this.o().toString();
    }, C.prototype.Ea = function() {
        return this.da().toString();
    }, C.prototype.readSignedVarint32String = C.prototype.Ea, C.prototype.Ia = function() {
        var v = this.o();
        return v >>> 1 ^ -(v & 1);
    }, C.prototype.readZigzagVarint32 = C.prototype.Ia, C.prototype.Ga = function() {
        return this.w(z);
    }, C.prototype.readUnsignedVarint64 = C.prototype.Ga, C.prototype.Ha = function() {
        return this.w(x);
    }, C.prototype.readUnsignedVarint64String = C.prototype.Ha, C.prototype.sa = function() {
        return this.w(de);
    }, C.prototype.readSignedVarint64 = C.prototype.sa, C.prototype.Fa = function() {
        return this.w(q);
    }, C.prototype.readSignedVarint64String = C.prototype.Fa, C.prototype.Ja = function() {
        return this.w(Ie);
    }, C.prototype.readZigzagVarint64 = C.prototype.Ja, C.prototype.fb = function() {
        return this.ea(h);
    }, C.prototype.readZigzagVarintHash64 = C.prototype.fb, C.prototype.Ka = function() {
        return this.ea(q);
    }, C.prototype.readZigzagVarint64String = C.prototype.Ka, C.prototype.Gc = function() {
        var v = this.b[this.a];
        return this.a += 1, Q(this.a <= this.c), v;
    }, C.prototype.readUint8 = C.prototype.Gc, C.prototype.Ec = function() {
        var v = this.b[this.a], B = this.b[this.a + 1];
        return this.a += 2, Q(this.a <= this.c), v << 0 | B << 8;
    }, C.prototype.readUint16 = C.prototype.Ec, C.prototype.m = function() {
        var v = this.b[this.a], B = this.b[this.a + 1], Y = this.b[this.a + 2], pe = this.b[this.a + 3];
        return this.a += 4, Q(this.a <= this.c), (v << 0 | B << 8 | Y << 16 | pe << 24) >>> 0;
    }, C.prototype.readUint32 = C.prototype.m, C.prototype.ga = function() {
        var v = this.m(), B = this.m();
        return z(v, B);
    }, C.prototype.readUint64 = C.prototype.ga, C.prototype.ha = function() {
        var v = this.m(), B = this.m();
        return x(v, B);
    }, C.prototype.readUint64String = C.prototype.ha, C.prototype.Xb = function() {
        var v = this.b[this.a];
        return this.a += 1, Q(this.a <= this.c), v << 24 >> 24;
    }, C.prototype.readInt8 = C.prototype.Xb, C.prototype.Vb = function() {
        var v = this.b[this.a], B = this.b[this.a + 1];
        return this.a += 2, Q(this.a <= this.c), (v << 0 | B << 8) << 16 >> 16;
    }, C.prototype.readInt16 = C.prototype.Vb, C.prototype.P = function() {
        var v = this.b[this.a], B = this.b[this.a + 1], Y = this.b[this.a + 2], pe = this.b[this.a + 3];
        return this.a += 4, Q(this.a <= this.c), v << 0 | B << 8 | Y << 16 | pe << 24;
    }, C.prototype.readInt32 = C.prototype.P, C.prototype.ba = function() {
        var v = this.m(), B = this.m();
        return de(v, B);
    }, C.prototype.readInt64 = C.prototype.ba, C.prototype.ca = function() {
        var v = this.m(), B = this.m();
        return q(v, B);
    }, C.prototype.readInt64String = C.prototype.ca, C.prototype.aa = function() {
        var v = this.m();
        return Ke(v);
    }, C.prototype.readFloat = C.prototype.aa, C.prototype.Z = function() {
        var v = this.m(), B = this.m();
        return Ue(v, B);
    }, C.prototype.readDouble = C.prototype.Z, C.prototype.pa = function() {
        return !!this.b[this.a++];
    }, C.prototype.readBool = C.prototype.pa, C.prototype.ra = function() {
        return this.da();
    }, C.prototype.readEnum = C.prototype.ra, C.prototype.fa = function(v) {
        var B = this.b, Y = this.a;
        v = Y + v;
        for(var pe = [], ke = ""; Y < v;){
            var qe = B[Y++];
            if (128 > qe) pe.push(qe);
            else {
                if (192 > qe) continue;
                if (224 > qe) {
                    var ut = B[Y++];
                    pe.push((qe & 31) << 6 | ut & 63);
                } else if (240 > qe) {
                    ut = B[Y++];
                    var Ft = B[Y++];
                    pe.push((qe & 15) << 12 | (ut & 63) << 6 | Ft & 63);
                } else if (248 > qe) {
                    ut = B[Y++], Ft = B[Y++];
                    var pn = B[Y++];
                    qe = (qe & 7) << 18 | (ut & 63) << 12 | (Ft & 63) << 6 | pn & 63, qe -= 65536, pe.push((qe >> 10 & 1023) + 55296, (qe & 1023) + 56320);
                }
            }
            8192 <= pe.length && (ke += String.fromCharCode.apply(null, pe), pe.length = 0);
        }
        return ke += I(pe), this.a = Y, ke;
    }, C.prototype.readString = C.prototype.fa, C.prototype.Dc = function() {
        var v = this.o();
        return this.fa(v);
    }, C.prototype.readStringWithLength = C.prototype.Dc, C.prototype.qa = function(v) {
        if (0 > v || this.a + v > this.b.length) return this.v = !0, X("Invalid byte length!"), new Uint8Array(0);
        var B = this.b.subarray(this.a, this.a + v);
        return this.a += v, Q(this.a <= this.c), B;
    }, C.prototype.readBytes = C.prototype.qa, C.prototype.ia = function() {
        return this.w(h);
    }, C.prototype.readVarintHash64 = C.prototype.ia, C.prototype.$ = function() {
        var v = this.b, B = this.a, Y = v[B], pe = v[B + 1], ke = v[B + 2], qe = v[B + 3], ut = v[B + 4], Ft = v[B + 5], pn = v[B + 6];
        return v = v[B + 7], this.a += 8, String.fromCharCode(Y, pe, ke, qe, ut, Ft, pn, v);
    }, C.prototype.readFixedHash64 = C.prototype.$;
    function se(v, B, Y) {
        this.a = le(v, B, Y), this.O = this.a.B(), this.b = this.c = -1, this.h = !1, this.v = null;
    }
    p("jspb.BinaryReader", se, void 0);
    var Ne = [];
    se.clearInstanceCache = function() {
        Ne = [];
    }, se.getInstanceCacheLength = function() {
        return Ne.length;
    };
    function Le(v, B, Y) {
        if (Ne.length) {
            var pe = Ne.pop();
            return v && pe.a.H(v, B, Y), pe;
        }
        return new se(v, B, Y);
    }
    se.alloc = Le, se.prototype.zb = Le, se.prototype.alloc = se.prototype.zb, se.prototype.Ca = function() {
        this.a.clear(), this.b = this.c = -1, this.h = !1, this.v = null, 100 > Ne.length && Ne.push(this);
    }, se.prototype.free = se.prototype.Ca, se.prototype.Fb = function() {
        return this.O;
    }, se.prototype.getFieldCursor = se.prototype.Fb, se.prototype.B = function() {
        return this.a.B();
    }, se.prototype.getCursor = se.prototype.B, se.prototype.Y = function() {
        return this.a.Y();
    }, se.prototype.getBuffer = se.prototype.Y, se.prototype.Hb = function() {
        return this.c;
    }, se.prototype.getFieldNumber = se.prototype.Hb, se.prototype.Lb = function() {
        return this.b;
    }, se.prototype.getWireType = se.prototype.Lb, se.prototype.Mb = function() {
        return this.b == 2;
    }, se.prototype.isDelimited = se.prototype.Mb, se.prototype.bb = function() {
        return this.b == 4;
    }, se.prototype.isEndGroup = se.prototype.bb, se.prototype.getError = function() {
        return this.h || this.a.getError();
    }, se.prototype.getError = se.prototype.getError, se.prototype.H = function(v, B, Y) {
        this.a.H(v, B, Y), this.b = this.c = -1;
    }, se.prototype.setBlock = se.prototype.H, se.prototype.reset = function() {
        this.a.reset(), this.b = this.c = -1;
    }, se.prototype.reset = se.prototype.reset, se.prototype.advance = function(v) {
        this.a.advance(v);
    }, se.prototype.advance = se.prototype.advance, se.prototype.oa = function() {
        if (this.a.ya()) return !1;
        if (this.getError()) return X("Decoder hit an error"), !1;
        this.O = this.a.B();
        var v = this.a.o(), B = v >>> 3;
        return v &= 7, v != 0 && v != 5 && v != 1 && v != 2 && v != 3 && v != 4 ? (X("Invalid wire type: %s (at position %s)", v, this.O), this.h = !0, !1) : (this.c = B, this.b = v, !0);
    }, se.prototype.nextField = se.prototype.oa, se.prototype.Oa = function() {
        this.a.mb(this.c << 3 | this.b);
    }, se.prototype.unskipHeader = se.prototype.Oa, se.prototype.Lc = function() {
        var v = this.c;
        for(this.Oa(); this.oa() && this.c == v;)this.C();
        this.a.ya() || this.Oa();
    }, se.prototype.skipMatchingFields = se.prototype.Lc, se.prototype.lb = function() {
        this.b != 0 ? (X("Invalid wire type for skipVarintField"), this.C()) : this.a.kb();
    }, se.prototype.skipVarintField = se.prototype.lb, se.prototype.gb = function() {
        if (this.b != 2) X("Invalid wire type for skipDelimitedField"), this.C();
        else {
            var v = this.a.o();
            this.a.advance(v);
        }
    }, se.prototype.skipDelimitedField = se.prototype.gb, se.prototype.hb = function() {
        this.b != 5 ? (X("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4);
    }, se.prototype.skipFixed32Field = se.prototype.hb, se.prototype.ib = function() {
        this.b != 1 ? (X("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8);
    }, se.prototype.skipFixed64Field = se.prototype.ib, se.prototype.jb = function() {
        var v = this.c;
        do {
            if (!this.oa()) {
                X("Unmatched start-group tag: stream EOF"), this.h = !0;
                break;
            }
            if (this.b == 4) {
                this.c != v && (X("Unmatched end-group tag"), this.h = !0);
                break;
            }
            this.C();
        }while (!0)
    }, se.prototype.skipGroup = se.prototype.jb, se.prototype.C = function() {
        switch(this.b){
            case 0:
                this.lb();
                break;
            case 1:
                this.ib();
                break;
            case 2:
                this.gb();
                break;
            case 5:
                this.hb();
                break;
            case 3:
                this.jb();
                break;
            default:
                X("Invalid wire encoding for field.");
        }
    }, se.prototype.skipField = se.prototype.C, se.prototype.Hc = function(v, B) {
        this.v === null && (this.v = {}), Q(!this.v[v]), this.v[v] = B;
    }, se.prototype.registerReadCallback = se.prototype.Hc, se.prototype.Ic = function(v) {
        return Q(this.v !== null), v = this.v[v], Q(v), v(this);
    }, se.prototype.runReadCallback = se.prototype.Ic, se.prototype.Yb = function(v, B) {
        Q(this.b == 2);
        var Y = this.a.c, pe = this.a.o();
        pe = this.a.B() + pe, this.a.setEnd(pe), B(v, this), this.a.Ma(pe), this.a.setEnd(Y);
    }, se.prototype.readMessage = se.prototype.Yb, se.prototype.Ub = function(v, B, Y) {
        Q(this.b == 3), Q(this.c == v), Y(B, this), this.h || this.b == 4 || (X("Group submessage did not end with an END_GROUP tag"), this.h = !0);
    }, se.prototype.readGroup = se.prototype.Ub, se.prototype.Gb = function() {
        Q(this.b == 2);
        var v = this.a.o(), B = this.a.B(), Y = B + v;
        return v = le(this.a.Y(), B, v), this.a.Ma(Y), v;
    }, se.prototype.getFieldDecoder = se.prototype.Gb, se.prototype.P = function() {
        return Q(this.b == 0), this.a.da();
    }, se.prototype.readInt32 = se.prototype.P, se.prototype.Wb = function() {
        return Q(this.b == 0), this.a.Ea();
    }, se.prototype.readInt32String = se.prototype.Wb, se.prototype.ba = function() {
        return Q(this.b == 0), this.a.sa();
    }, se.prototype.readInt64 = se.prototype.ba, se.prototype.ca = function() {
        return Q(this.b == 0), this.a.Fa();
    }, se.prototype.readInt64String = se.prototype.ca, se.prototype.m = function() {
        return Q(this.b == 0), this.a.o();
    }, se.prototype.readUint32 = se.prototype.m, se.prototype.Fc = function() {
        return Q(this.b == 0), this.a.O();
    }, se.prototype.readUint32String = se.prototype.Fc, se.prototype.ga = function() {
        return Q(this.b == 0), this.a.Ga();
    }, se.prototype.readUint64 = se.prototype.ga, se.prototype.ha = function() {
        return Q(this.b == 0), this.a.Ha();
    }, se.prototype.readUint64String = se.prototype.ha, se.prototype.zc = function() {
        return Q(this.b == 0), this.a.Ia();
    }, se.prototype.readSint32 = se.prototype.zc, se.prototype.Ac = function() {
        return Q(this.b == 0), this.a.Ja();
    }, se.prototype.readSint64 = se.prototype.Ac, se.prototype.Bc = function() {
        return Q(this.b == 0), this.a.Ka();
    }, se.prototype.readSint64String = se.prototype.Bc, se.prototype.Rb = function() {
        return Q(this.b == 5), this.a.m();
    }, se.prototype.readFixed32 = se.prototype.Rb, se.prototype.Sb = function() {
        return Q(this.b == 1), this.a.ga();
    }, se.prototype.readFixed64 = se.prototype.Sb, se.prototype.Tb = function() {
        return Q(this.b == 1), this.a.ha();
    }, se.prototype.readFixed64String = se.prototype.Tb, se.prototype.vc = function() {
        return Q(this.b == 5), this.a.P();
    }, se.prototype.readSfixed32 = se.prototype.vc, se.prototype.wc = function() {
        return Q(this.b == 5), this.a.P().toString();
    }, se.prototype.readSfixed32String = se.prototype.wc, se.prototype.xc = function() {
        return Q(this.b == 1), this.a.ba();
    }, se.prototype.readSfixed64 = se.prototype.xc, se.prototype.yc = function() {
        return Q(this.b == 1), this.a.ca();
    }, se.prototype.readSfixed64String = se.prototype.yc, se.prototype.aa = function() {
        return Q(this.b == 5), this.a.aa();
    }, se.prototype.readFloat = se.prototype.aa, se.prototype.Z = function() {
        return Q(this.b == 1), this.a.Z();
    }, se.prototype.readDouble = se.prototype.Z, se.prototype.pa = function() {
        return Q(this.b == 0), !!this.a.o();
    }, se.prototype.readBool = se.prototype.pa, se.prototype.ra = function() {
        return Q(this.b == 0), this.a.sa();
    }, se.prototype.readEnum = se.prototype.ra, se.prototype.fa = function() {
        Q(this.b == 2);
        var v = this.a.o();
        return this.a.fa(v);
    }, se.prototype.readString = se.prototype.fa, se.prototype.qa = function() {
        Q(this.b == 2);
        var v = this.a.o();
        return this.a.qa(v);
    }, se.prototype.readBytes = se.prototype.qa, se.prototype.ia = function() {
        return Q(this.b == 0), this.a.ia();
    }, se.prototype.readVarintHash64 = se.prototype.ia, se.prototype.Cc = function() {
        return Q(this.b == 0), this.a.fb();
    }, se.prototype.readSintHash64 = se.prototype.Cc, se.prototype.w = function(v) {
        return Q(this.b == 0), this.a.w(v);
    }, se.prototype.readSplitVarint64 = se.prototype.w, se.prototype.ea = function(v) {
        return Q(this.b == 0), this.a.w(function(B, Y) {
            return je(B, Y, v);
        });
    }, se.prototype.readSplitZigzagVarint64 = se.prototype.ea, se.prototype.$ = function() {
        return Q(this.b == 1), this.a.$();
    }, se.prototype.readFixedHash64 = se.prototype.$, se.prototype.ta = function(v) {
        return Q(this.b == 1), this.a.ta(v);
    }, se.prototype.readSplitFixed64 = se.prototype.ta;
    function rt(v, B) {
        Q(v.b == 2);
        var Y = v.a.o();
        Y = v.a.B() + Y;
        for(var pe = []; v.a.B() < Y;)pe.push(B.call(v.a));
        return pe;
    }
    se.prototype.gc = function() {
        return rt(this, this.a.da);
    }, se.prototype.readPackedInt32 = se.prototype.gc, se.prototype.hc = function() {
        return rt(this, this.a.Ea);
    }, se.prototype.readPackedInt32String = se.prototype.hc, se.prototype.ic = function() {
        return rt(this, this.a.sa);
    }, se.prototype.readPackedInt64 = se.prototype.ic, se.prototype.jc = function() {
        return rt(this, this.a.Fa);
    }, se.prototype.readPackedInt64String = se.prototype.jc, se.prototype.qc = function() {
        return rt(this, this.a.o);
    }, se.prototype.readPackedUint32 = se.prototype.qc, se.prototype.rc = function() {
        return rt(this, this.a.O);
    }, se.prototype.readPackedUint32String = se.prototype.rc, se.prototype.sc = function() {
        return rt(this, this.a.Ga);
    }, se.prototype.readPackedUint64 = se.prototype.sc, se.prototype.tc = function() {
        return rt(this, this.a.Ha);
    }, se.prototype.readPackedUint64String = se.prototype.tc, se.prototype.nc = function() {
        return rt(this, this.a.Ia);
    }, se.prototype.readPackedSint32 = se.prototype.nc, se.prototype.oc = function() {
        return rt(this, this.a.Ja);
    }, se.prototype.readPackedSint64 = se.prototype.oc, se.prototype.pc = function() {
        return rt(this, this.a.Ka);
    }, se.prototype.readPackedSint64String = se.prototype.pc, se.prototype.bc = function() {
        return rt(this, this.a.m);
    }, se.prototype.readPackedFixed32 = se.prototype.bc, se.prototype.cc = function() {
        return rt(this, this.a.ga);
    }, se.prototype.readPackedFixed64 = se.prototype.cc, se.prototype.dc = function() {
        return rt(this, this.a.ha);
    }, se.prototype.readPackedFixed64String = se.prototype.dc, se.prototype.kc = function() {
        return rt(this, this.a.P);
    }, se.prototype.readPackedSfixed32 = se.prototype.kc, se.prototype.lc = function() {
        return rt(this, this.a.ba);
    }, se.prototype.readPackedSfixed64 = se.prototype.lc, se.prototype.mc = function() {
        return rt(this, this.a.ca);
    }, se.prototype.readPackedSfixed64String = se.prototype.mc, se.prototype.fc = function() {
        return rt(this, this.a.aa);
    }, se.prototype.readPackedFloat = se.prototype.fc, se.prototype.$b = function() {
        return rt(this, this.a.Z);
    }, se.prototype.readPackedDouble = se.prototype.$b, se.prototype.Zb = function() {
        return rt(this, this.a.pa);
    }, se.prototype.readPackedBool = se.prototype.Zb, se.prototype.ac = function() {
        return rt(this, this.a.ra);
    }, se.prototype.readPackedEnum = se.prototype.ac, se.prototype.uc = function() {
        return rt(this, this.a.ia);
    }, se.prototype.readPackedVarintHash64 = se.prototype.uc, se.prototype.ec = function() {
        return rt(this, this.a.$);
    }, se.prototype.readPackedFixedHash64 = se.prototype.ec;
    function yt(v, B, Y, pe, ke) {
        this.ma = v, this.Ba = B, this.la = Y, this.Na = pe, this.na = ke;
    }
    p("jspb.ExtensionFieldInfo", yt, void 0);
    function _t(v, B, Y, pe, ke, qe) {
        this.Za = v, this.za = B, this.Aa = Y, this.Wa = pe, this.Ab = ke, this.Nb = qe;
    }
    p("jspb.ExtensionFieldBinaryInfo", _t, void 0), yt.prototype.F = function() {
        return !!this.la;
    }, yt.prototype.isMessageType = yt.prototype.F;
    function Qe() {}
    p("jspb.Message", Qe, void 0), Qe.GENERATE_TO_OBJECT = !0, Qe.GENERATE_FROM_OBJECT = !0;
    var Rt = typeof Uint8Array == "function";
    Qe.prototype.Ib = function() {
        return this.b;
    }, Qe.prototype.getJsPbMessageId = Qe.prototype.Ib, Qe.initialize = function(v, B, Y, pe, ke, qe) {
        v.f = null, B || (B = Y ? [
            Y
        ] : []), v.b = Y ? String(Y) : void 0, v.D = Y === 0 ? -1 : 0, v.u = B;
        e: {
            if (Y = v.u.length, B = -1, Y && (B = Y - 1, Y = v.u[B], !(Y === null || typeof Y != "object" || Array.isArray(Y) || Rt && Y instanceof Uint8Array))) {
                v.G = B - v.D, v.i = Y;
                break e;
            }
            -1 < pe ? (v.G = Math.max(pe, B + 1 - v.D), v.i = null) : v.G = Number.MAX_VALUE;
        }
        if (v.a = {}, ke) for(pe = 0; pe < ke.length; pe++)B = ke[pe], B < v.G ? (B += v.D, v.u[B] = v.u[B] || Lt) : (Ur(v), v.i[B] = v.i[B] || Lt);
        if (qe && qe.length) for(pe = 0; pe < qe.length; pe++)at(v, qe[pe]);
    };
    var Lt = Object.freeze ? Object.freeze([]) : [];
    function Ur(v) {
        var B = v.G + v.D;
        v.u[B] || (v.i = v.u[B] = {});
    }
    function jr(v, B, Y) {
        for(var pe = [], ke = 0; ke < v.length; ke++)pe[ke] = B.call(v[ke], Y, v[ke]);
        return pe;
    }
    Qe.toObjectList = jr, Qe.toObjectExtension = function(v, B, Y, pe, ke) {
        for(var qe in Y){
            var ut = Y[qe], Ft = pe.call(v, ut);
            if (Ft != null) {
                for(var pn in ut.Ba)if (ut.Ba.hasOwnProperty(pn)) break;
                B[pn] = ut.Na ? ut.na ? jr(Ft, ut.Na, ke) : ut.Na(ke, Ft) : Ft;
            }
        }
    }, Qe.serializeBinaryExtensions = function(v, B, Y, pe) {
        for(var ke in Y){
            var qe = Y[ke], ut = qe.Za;
            if (!qe.Aa) throw Error("Message extension present that was generated without binary serialization support");
            var Ft = pe.call(v, ut);
            if (Ft != null) if (ut.F()) if (qe.Wa) qe.Aa.call(B, ut.ma, Ft, qe.Wa);
            else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
            else qe.Aa.call(B, ut.ma, Ft);
        }
    }, Qe.readBinaryExtension = function(v, B, Y, pe, ke) {
        var qe = Y[B.c];
        if (qe) {
            if (Y = qe.Za, !qe.za) throw Error("Deserializing extension whose generated code does not support binary format");
            if (Y.F()) {
                var ut = new Y.la();
                qe.za.call(B, ut, qe.Ab);
            } else ut = qe.za.call(B);
            Y.na && !qe.Nb ? (B = pe.call(v, Y)) ? B.push(ut) : ke.call(v, Y, [
                ut
            ]) : ke.call(v, Y, ut);
        } else B.C();
    };
    function Et(v, B) {
        if (B < v.G) {
            B += v.D;
            var Y = v.u[B];
            return Y === Lt ? v.u[B] = [] : Y;
        }
        if (v.i) return Y = v.i[B], Y === Lt ? v.i[B] = [] : Y;
    }
    Qe.getField = Et, Qe.getRepeatedField = function(v, B) {
        return Et(v, B);
    };
    function Xt(v, B) {
        return v = Et(v, B), v == null ? v : +v;
    }
    Qe.getOptionalFloatingPointField = Xt;
    function wr(v, B) {
        return v = Et(v, B), v == null ? v : !!v;
    }
    Qe.getBooleanField = wr, Qe.getRepeatedFloatingPointField = function(v, B) {
        var Y = Et(v, B);
        if (v.a || (v.a = {}), !v.a[B]) {
            for(var pe = 0; pe < Y.length; pe++)Y[pe] = +Y[pe];
            v.a[B] = !0;
        }
        return Y;
    }, Qe.getRepeatedBooleanField = function(v, B) {
        var Y = Et(v, B);
        if (v.a || (v.a = {}), !v.a[B]) {
            for(var pe = 0; pe < Y.length; pe++)Y[pe] = !!Y[pe];
            v.a[B] = !0;
        }
        return Y;
    };
    function zt(v) {
        return v == null || typeof v == "string" ? v : Rt && v instanceof Uint8Array ? ie(v) : (X("Cannot coerce to b64 string: " + y(v)), null);
    }
    Qe.bytesAsB64 = zt;
    function Ae(v) {
        return v == null || v instanceof Uint8Array ? v : typeof v == "string" ? ue(v) : (X("Cannot coerce to Uint8Array: " + y(v)), null);
    }
    Qe.bytesAsU8 = Ae, Qe.bytesListAsB64 = function(v) {
        return we(v), v.length && typeof v[0] != "string" ? H(v, zt) : v;
    }, Qe.bytesListAsU8 = function(v) {
        return we(v), !v.length || v[0] instanceof Uint8Array ? v : H(v, Ae);
    };
    function we(v) {
        if (v && 1 < v.length) {
            var B = y(v[0]);
            D(v, function(Y) {
                y(Y) != B && X("Inconsistent type in JSPB repeated field array. Got " + y(Y) + " expected " + B);
            });
        }
    }
    function xe(v, B, Y) {
        return v = Et(v, B), v ?? Y;
    }
    Qe.getFieldWithDefault = xe, Qe.getBooleanFieldWithDefault = function(v, B, Y) {
        return v = wr(v, B), v ?? Y;
    }, Qe.getFloatingPointFieldWithDefault = function(v, B, Y) {
        return v = Xt(v, B), v ?? Y;
    }, Qe.getFieldProto3 = xe, Qe.getMapField = function(v, B, Y, pe) {
        if (v.f || (v.f = {}), B in v.f) return v.f[B];
        var ke = Et(v, B);
        if (!ke) {
            if (Y) return;
            ke = [], Me(v, B, ke);
        }
        return v.f[B] = new w(ke, pe);
    };
    function Me(v, B, Y) {
        return $(v, Qe), B < v.G ? v.u[B + v.D] = Y : (Ur(v), v.i[B] = Y), v;
    }
    Qe.setField = Me, Qe.setProto3IntField = function(v, B, Y) {
        return ze(v, B, Y, 0);
    }, Qe.setProto3FloatField = function(v, B, Y) {
        return ze(v, B, Y, 0);
    }, Qe.setProto3BooleanField = function(v, B, Y) {
        return ze(v, B, Y, !1);
    }, Qe.setProto3StringField = function(v, B, Y) {
        return ze(v, B, Y, "");
    }, Qe.setProto3BytesField = function(v, B, Y) {
        return ze(v, B, Y, "");
    }, Qe.setProto3EnumField = function(v, B, Y) {
        return ze(v, B, Y, 0);
    }, Qe.setProto3StringIntField = function(v, B, Y) {
        return ze(v, B, Y, "0");
    };
    function ze(v, B, Y, pe) {
        return $(v, Qe), Y !== pe ? Me(v, B, Y) : B < v.G ? v.u[B + v.D] = null : (Ur(v), delete v.i[B]), v;
    }
    Qe.addToRepeatedField = function(v, B, Y, pe) {
        return $(v, Qe), B = Et(v, B), pe != null ? B.splice(pe, 0, Y) : B.push(Y), v;
    };
    function Ve(v, B, Y, pe) {
        return $(v, Qe), (Y = at(v, Y)) && Y !== B && pe !== void 0 && (v.f && Y in v.f && (v.f[Y] = void 0), Me(v, Y, void 0)), Me(v, B, pe);
    }
    Qe.setOneofField = Ve;
    function at(v, B) {
        for(var Y, pe, ke = 0; ke < B.length; ke++){
            var qe = B[ke], ut = Et(v, qe);
            ut != null && (Y = qe, pe = ut, Me(v, qe, void 0));
        }
        return Y ? (Me(v, Y, pe), Y) : 0;
    }
    Qe.computeOneofCase = at, Qe.getWrapperField = function(v, B, Y, pe) {
        if (v.f || (v.f = {}), !v.f[Y]) {
            var ke = Et(v, Y);
            (pe || ke) && (v.f[Y] = new B(ke));
        }
        return v.f[Y];
    }, Qe.getRepeatedWrapperField = function(v, B, Y) {
        return ct(v, B, Y), B = v.f[Y], B == Lt && (B = v.f[Y] = []), B;
    };
    function ct(v, B, Y) {
        if (v.f || (v.f = {}), !v.f[Y]) {
            for(var pe = Et(v, Y), ke = [], qe = 0; qe < pe.length; qe++)ke[qe] = new B(pe[qe]);
            v.f[Y] = ke;
        }
    }
    Qe.setWrapperField = function(v, B, Y) {
        $(v, Qe), v.f || (v.f = {});
        var pe = Y && Y.g();
        return v.f[B] = Y, Me(v, B, pe);
    }, Qe.setOneofWrapperField = function(v, B, Y, pe) {
        $(v, Qe), v.f || (v.f = {});
        var ke = pe && pe.g();
        return v.f[B] = pe, Ve(v, B, Y, ke);
    }, Qe.setRepeatedWrapperField = function(v, B, Y) {
        $(v, Qe), v.f || (v.f = {}), Y = Y || [];
        for(var pe = [], ke = 0; ke < Y.length; ke++)pe[ke] = Y[ke].g();
        return v.f[B] = Y, Me(v, B, pe);
    }, Qe.addToRepeatedWrapperField = function(v, B, Y, pe, ke) {
        ct(v, pe, B);
        var qe = v.f[B];
        return qe || (qe = v.f[B] = []), Y = Y || new pe(), v = Et(v, B), ke != null ? (qe.splice(ke, 0, Y), v.splice(ke, 0, Y.g())) : (qe.push(Y), v.push(Y.g())), Y;
    }, Qe.toMap = function(v, B, Y, pe) {
        for(var ke = {}, qe = 0; qe < v.length; qe++)ke[B.call(v[qe])] = Y ? Y.call(v[qe], pe, v[qe]) : v[qe];
        return ke;
    };
    function lt(v) {
        if (v.f) for(var B in v.f){
            var Y = v.f[B];
            if (Array.isArray(Y)) for(var pe = 0; pe < Y.length; pe++)Y[pe] && Y[pe].g();
            else Y && Y.g();
        }
    }
    Qe.prototype.g = function() {
        return lt(this), this.u;
    }, Qe.prototype.toArray = Qe.prototype.g, Qe.prototype.toString = function() {
        return lt(this), this.u.toString();
    }, Qe.prototype.getExtension = function(v) {
        if (this.i) {
            this.f || (this.f = {});
            var B = v.ma;
            if (v.na) {
                if (v.F()) return this.f[B] || (this.f[B] = H(this.i[B] || [], function(Y) {
                    return new v.la(Y);
                })), this.f[B];
            } else if (v.F()) return !this.f[B] && this.i[B] && (this.f[B] = new v.la(this.i[B])), this.f[B];
            return this.i[B];
        }
    }, Qe.prototype.getExtension = Qe.prototype.getExtension, Qe.prototype.Kc = function(v, B) {
        this.f || (this.f = {}), Ur(this);
        var Y = v.ma;
        return v.na ? (B = B || [], v.F() ? (this.f[Y] = B, this.i[Y] = H(B, function(pe) {
            return pe.g();
        })) : this.i[Y] = B) : v.F() ? (this.f[Y] = B, this.i[Y] = B && B.g()) : this.i[Y] = B, this;
    }, Qe.prototype.setExtension = Qe.prototype.Kc, Qe.difference = function(v, B) {
        if (!(v instanceof B.constructor)) throw Error("Messages have different types.");
        var Y = v.g();
        B = B.g();
        var pe = [], ke = 0, qe = Y.length > B.length ? Y.length : B.length;
        for(v.b && (pe[0] = v.b, ke = 1); ke < qe; ke++)wt(Y[ke], B[ke]) || (pe[ke] = B[ke]);
        return new v.constructor(pe);
    }, Qe.equals = function(v, B) {
        return v == B || !(!v || !B) && v instanceof B.constructor && wt(v.g(), B.g());
    };
    function mt(v, B) {
        v = v || {}, B = B || {};
        var Y = {}, pe;
        for(pe in v)Y[pe] = 0;
        for(pe in B)Y[pe] = 0;
        for(pe in Y)if (!wt(v[pe], B[pe])) return !1;
        return !0;
    }
    Qe.compareExtensions = mt;
    function wt(v, B) {
        if (v == B) return !0;
        if (!_(v) || !_(B)) return typeof v == "number" && isNaN(v) || typeof B == "number" && isNaN(B) ? String(v) == String(B) : !1;
        if (v.constructor != B.constructor) return !1;
        if (Rt && v.constructor === Uint8Array) {
            if (v.length != B.length) return !1;
            for(var Y = 0; Y < v.length; Y++)if (v[Y] != B[Y]) return !1;
            return !0;
        }
        if (v.constructor === Array) {
            var pe = void 0, ke = void 0, qe = Math.max(v.length, B.length);
            for(Y = 0; Y < qe; Y++){
                var ut = v[Y], Ft = B[Y];
                if (ut && ut.constructor == Object && (Q(pe === void 0), Q(Y === v.length - 1), pe = ut, ut = void 0), Ft && Ft.constructor == Object && (Q(ke === void 0), Q(Y === B.length - 1), ke = Ft, Ft = void 0), !wt(ut, Ft)) return !1;
            }
            return pe || ke ? (pe = pe || {}, ke = ke || {}, mt(pe, ke)) : !0;
        }
        if (v.constructor === Object) return mt(v, B);
        throw Error("Invalid type in JSPB array");
    }
    Qe.compareFields = wt, Qe.prototype.Bb = function() {
        return bt(this);
    }, Qe.prototype.cloneMessage = Qe.prototype.Bb, Qe.prototype.clone = function() {
        return bt(this);
    }, Qe.prototype.clone = Qe.prototype.clone, Qe.clone = function(v) {
        return bt(v);
    };
    function bt(v) {
        return new v.constructor(Mt(v.g()));
    }
    Qe.copyInto = function(v, B) {
        $(v, Qe), $(B, Qe), Q(v.constructor == B.constructor, "Copy source and target message should have the same type."), v = bt(v);
        for(var Y = B.g(), pe = v.g(), ke = Y.length = 0; ke < pe.length; ke++)Y[ke] = pe[ke];
        B.f = v.f, B.i = v.i;
    };
    function Mt(v) {
        if (Array.isArray(v)) {
            for(var B = Array(v.length), Y = 0; Y < v.length; Y++){
                var pe = v[Y];
                pe != null && (B[Y] = typeof pe == "object" ? Mt(Q(pe)) : pe);
            }
            return B;
        }
        if (Rt && v instanceof Uint8Array) return new Uint8Array(v);
        B = {};
        for(Y in v)pe = v[Y], pe != null && (B[Y] = typeof pe == "object" ? Mt(Q(pe)) : pe);
        return B;
    }
    Qe.registerMessageType = function(v, B) {
        B.we = v;
    };
    var Ct = {
        dump: function(v) {
            return $(v, Qe, "jspb.Message instance expected"), Q(v.getExtension, "Only unobfuscated and unoptimized compilation modes supported."), Ct.X(v);
        }
    };
    p("jspb.debug.dump", Ct.dump, void 0), Ct.X = function(v) {
        var B = y(v);
        if (B == "number" || B == "string" || B == "boolean" || B == "null" || B == "undefined" || typeof Uint8Array < "u" && v instanceof Uint8Array) return v;
        if (B == "array") return R(v), H(v, Ct.X);
        if (v instanceof w) {
            var Y = {};
            v = v.entries();
            for(var pe = v.next(); !pe.done; pe = v.next())Y[pe.value[0]] = Ct.X(pe.value[1]);
            return Y;
        }
        $(v, Qe, "Only messages expected: " + v), B = v.constructor;
        var ke = {
            $name: B.name || B.displayName
        };
        for(Ft in B.prototype){
            var qe = /^get([A-Z]\w*)/.exec(Ft);
            if (qe && Ft != "getExtension" && Ft != "getJsPbMessageId") {
                var ut = "has" + qe[1];
                (!v[ut] || v[ut]()) && (ut = v[Ft](), ke[Ct.$a(qe[1])] = Ct.X(ut));
            }
        }
        if (v.extensionObject_) return ke.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", ke;
        for(pe in B.extensions)if (/^\d+$/.test(pe)) {
            ut = B.extensions[pe];
            var Ft = v.getExtension(ut);
            qe = void 0, ut = ut.Ba;
            var pn = [], bs = 0;
            for(qe in ut)pn[bs++] = qe;
            qe = pn[0], Ft != null && (Y || (Y = ke.$extensions = {}), Y[Ct.$a(qe)] = Ct.X(Ft));
        }
        return ke;
    }, Ct.$a = function(v) {
        return v.replace(/^[A-Z]/, function(B) {
            return B.toLowerCase();
        });
    };
    function Xe() {
        this.a = [];
    }
    p("jspb.BinaryEncoder", Xe, void 0), Xe.prototype.length = function() {
        return this.a.length;
    }, Xe.prototype.length = Xe.prototype.length, Xe.prototype.end = function() {
        var v = this.a;
        return this.a = [], v;
    }, Xe.prototype.end = Xe.prototype.end, Xe.prototype.l = function(v, B) {
        for(Q(v == Math.floor(v)), Q(B == Math.floor(B)), Q(0 <= v && 4294967296 > v), Q(0 <= B && 4294967296 > B); 0 < B || 127 < v;)this.a.push(v & 127 | 128), v = (v >>> 7 | B << 25) >>> 0, B >>>= 7;
        this.a.push(v);
    }, Xe.prototype.writeSplitVarint64 = Xe.prototype.l, Xe.prototype.A = function(v, B) {
        Q(v == Math.floor(v)), Q(B == Math.floor(B)), Q(0 <= v && 4294967296 > v), Q(0 <= B && 4294967296 > B), this.s(v), this.s(B);
    }, Xe.prototype.writeSplitFixed64 = Xe.prototype.A, Xe.prototype.j = function(v) {
        for(Q(v == Math.floor(v)), Q(0 <= v && 4294967296 > v); 127 < v;)this.a.push(v & 127 | 128), v >>>= 7;
        this.a.push(v);
    }, Xe.prototype.writeUnsignedVarint32 = Xe.prototype.j, Xe.prototype.M = function(v) {
        if (Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), 0 <= v) this.j(v);
        else {
            for(var B = 0; 9 > B; B++)this.a.push(v & 127 | 128), v >>= 7;
            this.a.push(1);
        }
    }, Xe.prototype.writeSignedVarint32 = Xe.prototype.M, Xe.prototype.va = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 18446744073709552e3 > v), Se(v), this.l(ee, ae);
    }, Xe.prototype.writeUnsignedVarint64 = Xe.prototype.va, Xe.prototype.ua = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= v && 9223372036854776e3 > v), Se(v), this.l(ee, ae);
    }, Xe.prototype.writeSignedVarint64 = Xe.prototype.ua, Xe.prototype.wa = function(v) {
        Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), this.j((v << 1 ^ v >> 31) >>> 0);
    }, Xe.prototype.writeZigzagVarint32 = Xe.prototype.wa, Xe.prototype.xa = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= v && 9223372036854776e3 > v), De(v), this.l(ee, ae);
    }, Xe.prototype.writeZigzagVarint64 = Xe.prototype.xa, Xe.prototype.Ta = function(v) {
        this.W(fe(v));
    }, Xe.prototype.writeZigzagVarint64String = Xe.prototype.Ta, Xe.prototype.W = function(v) {
        var B = this;
        M(v), _e(ee, ae, function(Y, pe) {
            B.l(Y >>> 0, pe >>> 0);
        });
    }, Xe.prototype.writeZigzagVarintHash64 = Xe.prototype.W, Xe.prototype.be = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 256 > v), this.a.push(v >>> 0 & 255);
    }, Xe.prototype.writeUint8 = Xe.prototype.be, Xe.prototype.ae = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 65536 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255);
    }, Xe.prototype.writeUint16 = Xe.prototype.ae, Xe.prototype.s = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 4294967296 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255), this.a.push(v >>> 16 & 255), this.a.push(v >>> 24 & 255);
    }, Xe.prototype.writeUint32 = Xe.prototype.s, Xe.prototype.V = function(v) {
        Q(v == Math.floor(v)), Q(0 <= v && 18446744073709552e3 > v), ye(v), this.s(ee), this.s(ae);
    }, Xe.prototype.writeUint64 = Xe.prototype.V, Xe.prototype.Qc = function(v) {
        Q(v == Math.floor(v)), Q(-128 <= v && 128 > v), this.a.push(v >>> 0 & 255);
    }, Xe.prototype.writeInt8 = Xe.prototype.Qc, Xe.prototype.Pc = function(v) {
        Q(v == Math.floor(v)), Q(-32768 <= v && 32768 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255);
    }, Xe.prototype.writeInt16 = Xe.prototype.Pc, Xe.prototype.S = function(v) {
        Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), this.a.push(v >>> 0 & 255), this.a.push(v >>> 8 & 255), this.a.push(v >>> 16 & 255), this.a.push(v >>> 24 & 255);
    }, Xe.prototype.writeInt32 = Xe.prototype.S, Xe.prototype.T = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= v && 9223372036854776e3 > v), Se(v), this.A(ee, ae);
    }, Xe.prototype.writeInt64 = Xe.prototype.T, Xe.prototype.ka = function(v) {
        Q(v == Math.floor(v)), Q(-9223372036854776e3 <= +v && 9223372036854776e3 > +v), M(fe(v)), this.A(ee, ae);
    }, Xe.prototype.writeInt64String = Xe.prototype.ka, Xe.prototype.L = function(v) {
        Q(v === 1 / 0 || v === -1 / 0 || isNaN(v) || -34028234663852886e22 <= v && 34028234663852886e22 >= v), Re(v), this.s(ee);
    }, Xe.prototype.writeFloat = Xe.prototype.L, Xe.prototype.J = function(v) {
        Q(v === 1 / 0 || v === -1 / 0 || isNaN(v) || -17976931348623157e292 <= v && 17976931348623157e292 >= v), Ce(v), this.s(ee), this.s(ae);
    }, Xe.prototype.writeDouble = Xe.prototype.J, Xe.prototype.I = function(v) {
        Q(typeof v == "boolean" || typeof v == "number"), this.a.push(v ? 1 : 0);
    }, Xe.prototype.writeBool = Xe.prototype.I, Xe.prototype.R = function(v) {
        Q(v == Math.floor(v)), Q(-2147483648 <= v && 2147483648 > v), this.M(v);
    }, Xe.prototype.writeEnum = Xe.prototype.R, Xe.prototype.ja = function(v) {
        this.a.push.apply(this.a, v);
    }, Xe.prototype.writeBytes = Xe.prototype.ja, Xe.prototype.N = function(v) {
        M(v), this.l(ee, ae);
    }, Xe.prototype.writeVarintHash64 = Xe.prototype.N, Xe.prototype.K = function(v) {
        M(v), this.s(ee), this.s(ae);
    }, Xe.prototype.writeFixedHash64 = Xe.prototype.K, Xe.prototype.U = function(v) {
        var B = this.a.length;
        G(v);
        for(var Y = 0; Y < v.length; Y++){
            var pe = v.charCodeAt(Y);
            if (128 > pe) this.a.push(pe);
            else if (2048 > pe) this.a.push(pe >> 6 | 192), this.a.push(pe & 63 | 128);
            else if (65536 > pe) if (55296 <= pe && 56319 >= pe && Y + 1 < v.length) {
                var ke = v.charCodeAt(Y + 1);
                56320 <= ke && 57343 >= ke && (pe = 1024 * (pe - 55296) + ke - 56320 + 65536, this.a.push(pe >> 18 | 240), this.a.push(pe >> 12 & 63 | 128), this.a.push(pe >> 6 & 63 | 128), this.a.push(pe & 63 | 128), Y++);
            } else this.a.push(pe >> 12 | 224), this.a.push(pe >> 6 & 63 | 128), this.a.push(pe & 63 | 128);
        }
        return this.a.length - B;
    }, Xe.prototype.writeString = Xe.prototype.U;
    function xt(v, B) {
        this.lo = v, this.hi = B;
    }
    p("jspb.arith.UInt64", xt, void 0), xt.prototype.cmp = function(v) {
        return this.hi < v.hi || this.hi == v.hi && this.lo < v.lo ? -1 : this.hi == v.hi && this.lo == v.lo ? 0 : 1;
    }, xt.prototype.cmp = xt.prototype.cmp, xt.prototype.La = function() {
        return new xt((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
    }, xt.prototype.rightShift = xt.prototype.La, xt.prototype.Da = function() {
        return new xt(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
    }, xt.prototype.leftShift = xt.prototype.Da, xt.prototype.cb = function() {
        return !!(this.hi & 2147483648);
    }, xt.prototype.msb = xt.prototype.cb, xt.prototype.Ob = function() {
        return !!(this.lo & 1);
    }, xt.prototype.lsb = xt.prototype.Ob, xt.prototype.Ua = function() {
        return this.lo == 0 && this.hi == 0;
    }, xt.prototype.zero = xt.prototype.Ua, xt.prototype.add = function(v) {
        return new xt((this.lo + v.lo & 4294967295) >>> 0 >>> 0, ((this.hi + v.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + v.lo ? 1 : 0) >>> 0);
    }, xt.prototype.add = xt.prototype.add, xt.prototype.sub = function(v) {
        return new xt((this.lo - v.lo & 4294967295) >>> 0 >>> 0, ((this.hi - v.hi & 4294967295) >>> 0) - (0 > this.lo - v.lo ? 1 : 0) >>> 0);
    }, xt.prototype.sub = xt.prototype.sub;
    function St(v, B) {
        var Y = v & 65535;
        v >>>= 16;
        var pe = B & 65535, ke = B >>> 16;
        for(B = Y * pe + 65536 * (Y * ke & 65535) + 65536 * (v * pe & 65535), Y = v * ke + (Y * ke >>> 16) + (v * pe >>> 16); 4294967296 <= B;)B -= 4294967296, Y += 1;
        return new xt(B >>> 0, Y >>> 0);
    }
    xt.mul32x32 = St, xt.prototype.eb = function(v) {
        var B = St(this.lo, v);
        return v = St(this.hi, v), v.hi = v.lo, v.lo = 0, B.add(v);
    }, xt.prototype.mul = xt.prototype.eb, xt.prototype.Xa = function(v) {
        if (v == 0) return [];
        var B = new xt(0, 0), Y = new xt(this.lo, this.hi);
        v = new xt(v, 0);
        for(var pe = new xt(1, 0); !v.cb();)v = v.Da(), pe = pe.Da();
        for(; !pe.Ua();)0 >= v.cmp(Y) && (B = B.add(pe), Y = Y.sub(v)), v = v.La(), pe = pe.La();
        return [
            B,
            Y
        ];
    }, xt.prototype.div = xt.prototype.Xa, xt.prototype.toString = function() {
        for(var v = "", B = this; !B.Ua();){
            B = B.Xa(10);
            var Y = B[0];
            v = B[1].lo + v, B = Y;
        }
        return v == "" && (v = "0"), v;
    }, xt.prototype.toString = xt.prototype.toString;
    function Pe(v) {
        for(var B = new xt(0, 0), Y = new xt(0, 0), pe = 0; pe < v.length; pe++){
            if ("0" > v[pe] || "9" < v[pe]) return null;
            Y.lo = parseInt(v[pe], 10), B = B.eb(10).add(Y);
        }
        return B;
    }
    xt.fromString = Pe, xt.prototype.clone = function() {
        return new xt(this.lo, this.hi);
    }, xt.prototype.clone = xt.prototype.clone;
    function et(v, B) {
        this.lo = v, this.hi = B;
    }
    p("jspb.arith.Int64", et, void 0), et.prototype.add = function(v) {
        return new et((this.lo + v.lo & 4294967295) >>> 0 >>> 0, ((this.hi + v.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + v.lo ? 1 : 0) >>> 0);
    }, et.prototype.add = et.prototype.add, et.prototype.sub = function(v) {
        return new et((this.lo - v.lo & 4294967295) >>> 0 >>> 0, ((this.hi - v.hi & 4294967295) >>> 0) - (0 > this.lo - v.lo ? 1 : 0) >>> 0);
    }, et.prototype.sub = et.prototype.sub, et.prototype.clone = function() {
        return new et(this.lo, this.hi);
    }, et.prototype.clone = et.prototype.clone, et.prototype.toString = function() {
        var v = (this.hi & 2147483648) != 0, B = new xt(this.lo, this.hi);
        return v && (B = new xt(0, 0).sub(B)), (v ? "-" : "") + B.toString();
    }, et.prototype.toString = et.prototype.toString;
    function vt(v) {
        var B = 0 < v.length && v[0] == "-";
        return B && (v = v.substring(1)), v = Pe(v), v === null ? null : (B && (v = new xt(0, 0).sub(v)), new et(v.lo, v.hi));
    }
    et.fromString = vt;
    function be() {
        this.c = [], this.b = 0, this.a = new Xe(), this.h = [];
    }
    p("jspb.BinaryWriter", be, void 0);
    function $r(v, B) {
        var Y = v.a.end();
        v.c.push(Y), v.c.push(B), v.b += Y.length + B.length;
    }
    function jt(v, B) {
        return kt(v, B, 2), B = v.a.end(), v.c.push(B), v.b += B.length, B.push(v.b), B;
    }
    function nr(v, B) {
        var Y = B.pop();
        for(Y = v.b + v.a.length() - Y, Q(0 <= Y); 127 < Y;)B.push(Y & 127 | 128), Y >>>= 7, v.b++;
        B.push(Y), v.b++;
    }
    be.prototype.pb = function(v, B, Y) {
        $r(this, v.subarray(B, Y));
    }, be.prototype.writeSerializedMessage = be.prototype.pb, be.prototype.Pb = function(v, B, Y) {
        v != null && B != null && Y != null && this.pb(v, B, Y);
    }, be.prototype.maybeWriteSerializedMessage = be.prototype.Pb, be.prototype.reset = function() {
        this.c = [], this.a.end(), this.b = 0, this.h = [];
    }, be.prototype.reset = be.prototype.reset, be.prototype.ab = function() {
        Q(this.h.length == 0);
        for(var v = new Uint8Array(this.b + this.a.length()), B = this.c, Y = B.length, pe = 0, ke = 0; ke < Y; ke++){
            var qe = B[ke];
            v.set(qe, pe), pe += qe.length;
        }
        return B = this.a.end(), v.set(B, pe), pe += B.length, Q(pe == v.length), this.c = [
            v
        ], v;
    }, be.prototype.getResultBuffer = be.prototype.ab, be.prototype.Kb = function(v) {
        return ie(this.ab(), v);
    }, be.prototype.getResultBase64String = be.prototype.Kb, be.prototype.Va = function(v) {
        this.h.push(jt(this, v));
    }, be.prototype.beginSubMessage = be.prototype.Va, be.prototype.Ya = function() {
        Q(0 <= this.h.length), nr(this, this.h.pop());
    }, be.prototype.endSubMessage = be.prototype.Ya;
    function kt(v, B, Y) {
        Q(1 <= B && B == Math.floor(B)), v.a.j(8 * B + Y);
    }
    be.prototype.Nc = function(v, B, Y) {
        switch(v){
            case 1:
                this.J(B, Y);
                break;
            case 2:
                this.L(B, Y);
                break;
            case 3:
                this.T(B, Y);
                break;
            case 4:
                this.V(B, Y);
                break;
            case 5:
                this.S(B, Y);
                break;
            case 6:
                this.Qa(B, Y);
                break;
            case 7:
                this.Pa(B, Y);
                break;
            case 8:
                this.I(B, Y);
                break;
            case 9:
                this.U(B, Y);
                break;
            case 10:
                X("Group field type not supported in writeAny()");
                break;
            case 11:
                X("Message field type not supported in writeAny()");
                break;
            case 12:
                this.ja(B, Y);
                break;
            case 13:
                this.s(B, Y);
                break;
            case 14:
                this.R(B, Y);
                break;
            case 15:
                this.Ra(B, Y);
                break;
            case 16:
                this.Sa(B, Y);
                break;
            case 17:
                this.rb(B, Y);
                break;
            case 18:
                this.sb(B, Y);
                break;
            case 30:
                this.K(B, Y);
                break;
            case 31:
                this.N(B, Y);
                break;
            default:
                X("Invalid field type in writeAny()");
        }
    }, be.prototype.writeAny = be.prototype.Nc;
    function Hn(v, B, Y) {
        Y != null && (kt(v, B, 0), v.a.j(Y));
    }
    function Zr(v, B, Y) {
        Y != null && (kt(v, B, 0), v.a.M(Y));
    }
    be.prototype.S = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), Zr(this, v, B));
    }, be.prototype.writeInt32 = be.prototype.S, be.prototype.ob = function(v, B) {
        B != null && (B = parseInt(B, 10), Q(-2147483648 <= B && 2147483648 > B), Zr(this, v, B));
    }, be.prototype.writeInt32String = be.prototype.ob, be.prototype.T = function(v, B) {
        B != null && (Q(-9223372036854776e3 <= B && 9223372036854776e3 > B), B != null && (kt(this, v, 0), this.a.ua(B)));
    }, be.prototype.writeInt64 = be.prototype.T, be.prototype.ka = function(v, B) {
        B != null && (B = vt(B), kt(this, v, 0), this.a.l(B.lo, B.hi));
    }, be.prototype.writeInt64String = be.prototype.ka, be.prototype.s = function(v, B) {
        B != null && (Q(0 <= B && 4294967296 > B), Hn(this, v, B));
    }, be.prototype.writeUint32 = be.prototype.s, be.prototype.ub = function(v, B) {
        B != null && (B = parseInt(B, 10), Q(0 <= B && 4294967296 > B), Hn(this, v, B));
    }, be.prototype.writeUint32String = be.prototype.ub, be.prototype.V = function(v, B) {
        B != null && (Q(0 <= B && 18446744073709552e3 > B), B != null && (kt(this, v, 0), this.a.va(B)));
    }, be.prototype.writeUint64 = be.prototype.V, be.prototype.vb = function(v, B) {
        B != null && (B = Pe(B), kt(this, v, 0), this.a.l(B.lo, B.hi));
    }, be.prototype.writeUint64String = be.prototype.vb, be.prototype.rb = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), B != null && (kt(this, v, 0), this.a.wa(B)));
    }, be.prototype.writeSint32 = be.prototype.rb, be.prototype.sb = function(v, B) {
        B != null && (Q(-9223372036854776e3 <= B && 9223372036854776e3 > B), B != null && (kt(this, v, 0), this.a.xa(B)));
    }, be.prototype.writeSint64 = be.prototype.sb, be.prototype.$d = function(v, B) {
        B != null && B != null && (kt(this, v, 0), this.a.W(B));
    }, be.prototype.writeSintHash64 = be.prototype.$d, be.prototype.Zd = function(v, B) {
        B != null && B != null && (kt(this, v, 0), this.a.Ta(B));
    }, be.prototype.writeSint64String = be.prototype.Zd, be.prototype.Pa = function(v, B) {
        B != null && (Q(0 <= B && 4294967296 > B), kt(this, v, 5), this.a.s(B));
    }, be.prototype.writeFixed32 = be.prototype.Pa, be.prototype.Qa = function(v, B) {
        B != null && (Q(0 <= B && 18446744073709552e3 > B), kt(this, v, 1), this.a.V(B));
    }, be.prototype.writeFixed64 = be.prototype.Qa, be.prototype.nb = function(v, B) {
        B != null && (B = Pe(B), kt(this, v, 1), this.a.A(B.lo, B.hi));
    }, be.prototype.writeFixed64String = be.prototype.nb, be.prototype.Ra = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), kt(this, v, 5), this.a.S(B));
    }, be.prototype.writeSfixed32 = be.prototype.Ra, be.prototype.Sa = function(v, B) {
        B != null && (Q(-9223372036854776e3 <= B && 9223372036854776e3 > B), kt(this, v, 1), this.a.T(B));
    }, be.prototype.writeSfixed64 = be.prototype.Sa, be.prototype.qb = function(v, B) {
        B != null && (B = vt(B), kt(this, v, 1), this.a.A(B.lo, B.hi));
    }, be.prototype.writeSfixed64String = be.prototype.qb, be.prototype.L = function(v, B) {
        B != null && (kt(this, v, 5), this.a.L(B));
    }, be.prototype.writeFloat = be.prototype.L, be.prototype.J = function(v, B) {
        B != null && (kt(this, v, 1), this.a.J(B));
    }, be.prototype.writeDouble = be.prototype.J, be.prototype.I = function(v, B) {
        B != null && (Q(typeof B == "boolean" || typeof B == "number"), kt(this, v, 0), this.a.I(B));
    }, be.prototype.writeBool = be.prototype.I, be.prototype.R = function(v, B) {
        B != null && (Q(-2147483648 <= B && 2147483648 > B), kt(this, v, 0), this.a.M(B));
    }, be.prototype.writeEnum = be.prototype.R, be.prototype.U = function(v, B) {
        B != null && (v = jt(this, v), this.a.U(B), nr(this, v));
    }, be.prototype.writeString = be.prototype.U, be.prototype.ja = function(v, B) {
        B != null && (B = V(B), kt(this, v, 2), this.a.j(B.length), $r(this, B));
    }, be.prototype.writeBytes = be.prototype.ja, be.prototype.Rc = function(v, B, Y) {
        B != null && (v = jt(this, v), Y(B, this), nr(this, v));
    }, be.prototype.writeMessage = be.prototype.Rc, be.prototype.Sc = function(v, B, Y) {
        B != null && (kt(this, 1, 3), kt(this, 2, 0), this.a.M(v), v = jt(this, 3), Y(B, this), nr(this, v), kt(this, 1, 4));
    }, be.prototype.writeMessageSet = be.prototype.Sc, be.prototype.Oc = function(v, B, Y) {
        B != null && (kt(this, v, 3), Y(B, this), kt(this, v, 4));
    }, be.prototype.writeGroup = be.prototype.Oc, be.prototype.K = function(v, B) {
        B != null && (Q(B.length == 8), kt(this, v, 1), this.a.K(B));
    }, be.prototype.writeFixedHash64 = be.prototype.K, be.prototype.N = function(v, B) {
        B != null && (Q(B.length == 8), kt(this, v, 0), this.a.N(B));
    }, be.prototype.writeVarintHash64 = be.prototype.N, be.prototype.A = function(v, B, Y) {
        kt(this, v, 1), this.a.A(B, Y);
    }, be.prototype.writeSplitFixed64 = be.prototype.A, be.prototype.l = function(v, B, Y) {
        kt(this, v, 0), this.a.l(B, Y);
    }, be.prototype.writeSplitVarint64 = be.prototype.l, be.prototype.tb = function(v, B, Y) {
        kt(this, v, 0);
        var pe = this.a;
        _e(B, Y, function(ke, qe) {
            pe.l(ke >>> 0, qe >>> 0);
        });
    }, be.prototype.writeSplitZigzagVarint64 = be.prototype.tb, be.prototype.Ed = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)Zr(this, v, B[Y]);
    }, be.prototype.writeRepeatedInt32 = be.prototype.Ed, be.prototype.Fd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ob(v, B[Y]);
    }, be.prototype.writeRepeatedInt32String = be.prototype.Fd, be.prototype.Gd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.ua(pe));
        }
    }, be.prototype.writeRepeatedInt64 = be.prototype.Gd, be.prototype.Qd = function(v, B, Y, pe) {
        if (B != null) for(var ke = 0; ke < B.length; ke++)this.A(v, Y(B[ke]), pe(B[ke]));
    }, be.prototype.writeRepeatedSplitFixed64 = be.prototype.Qd, be.prototype.Rd = function(v, B, Y, pe) {
        if (B != null) for(var ke = 0; ke < B.length; ke++)this.l(v, Y(B[ke]), pe(B[ke]));
    }, be.prototype.writeRepeatedSplitVarint64 = be.prototype.Rd, be.prototype.Sd = function(v, B, Y, pe) {
        if (B != null) for(var ke = 0; ke < B.length; ke++)this.tb(v, Y(B[ke]), pe(B[ke]));
    }, be.prototype.writeRepeatedSplitZigzagVarint64 = be.prototype.Sd, be.prototype.Hd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ka(v, B[Y]);
    }, be.prototype.writeRepeatedInt64String = be.prototype.Hd, be.prototype.Ud = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)Hn(this, v, B[Y]);
    }, be.prototype.writeRepeatedUint32 = be.prototype.Ud, be.prototype.Vd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ub(v, B[Y]);
    }, be.prototype.writeRepeatedUint32String = be.prototype.Vd, be.prototype.Wd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.va(pe));
        }
    }, be.prototype.writeRepeatedUint64 = be.prototype.Wd, be.prototype.Xd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.vb(v, B[Y]);
    }, be.prototype.writeRepeatedUint64String = be.prototype.Xd, be.prototype.Md = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.wa(pe));
        }
    }, be.prototype.writeRepeatedSint32 = be.prototype.Md, be.prototype.Nd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.xa(pe));
        }
    }, be.prototype.writeRepeatedSint64 = be.prototype.Nd, be.prototype.Od = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.Ta(pe));
        }
    }, be.prototype.writeRepeatedSint64String = be.prototype.Od, be.prototype.Pd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++){
            var pe = B[Y];
            pe != null && (kt(this, v, 0), this.a.W(pe));
        }
    }, be.prototype.writeRepeatedSintHash64 = be.prototype.Pd, be.prototype.yd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Pa(v, B[Y]);
    }, be.prototype.writeRepeatedFixed32 = be.prototype.yd, be.prototype.zd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Qa(v, B[Y]);
    }, be.prototype.writeRepeatedFixed64 = be.prototype.zd, be.prototype.Ad = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.nb(v, B[Y]);
    }, be.prototype.writeRepeatedFixed64String = be.prototype.Ad, be.prototype.Jd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Ra(v, B[Y]);
    }, be.prototype.writeRepeatedSfixed32 = be.prototype.Jd, be.prototype.Kd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.Sa(v, B[Y]);
    }, be.prototype.writeRepeatedSfixed64 = be.prototype.Kd, be.prototype.Ld = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.qb(v, B[Y]);
    }, be.prototype.writeRepeatedSfixed64String = be.prototype.Ld, be.prototype.Cd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.L(v, B[Y]);
    }, be.prototype.writeRepeatedFloat = be.prototype.Cd, be.prototype.wd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.J(v, B[Y]);
    }, be.prototype.writeRepeatedDouble = be.prototype.wd, be.prototype.ud = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.I(v, B[Y]);
    }, be.prototype.writeRepeatedBool = be.prototype.ud, be.prototype.xd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.R(v, B[Y]);
    }, be.prototype.writeRepeatedEnum = be.prototype.xd, be.prototype.Td = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.U(v, B[Y]);
    }, be.prototype.writeRepeatedString = be.prototype.Td, be.prototype.vd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.ja(v, B[Y]);
    }, be.prototype.writeRepeatedBytes = be.prototype.vd, be.prototype.Id = function(v, B, Y) {
        if (B != null) for(var pe = 0; pe < B.length; pe++){
            var ke = jt(this, v);
            Y(B[pe], this), nr(this, ke);
        }
    }, be.prototype.writeRepeatedMessage = be.prototype.Id, be.prototype.Dd = function(v, B, Y) {
        if (B != null) for(var pe = 0; pe < B.length; pe++)kt(this, v, 3), Y(B[pe], this), kt(this, v, 4);
    }, be.prototype.writeRepeatedGroup = be.prototype.Dd, be.prototype.Bd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.K(v, B[Y]);
    }, be.prototype.writeRepeatedFixedHash64 = be.prototype.Bd, be.prototype.Yd = function(v, B) {
        if (B != null) for(var Y = 0; Y < B.length; Y++)this.N(v, B[Y]);
    }, be.prototype.writeRepeatedVarintHash64 = be.prototype.Yd, be.prototype.ad = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.M(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedInt32 = be.prototype.ad, be.prototype.bd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.M(parseInt(B[Y], 10));
            nr(this, v);
        }
    }, be.prototype.writePackedInt32String = be.prototype.bd, be.prototype.cd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.ua(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedInt64 = be.prototype.cd, be.prototype.md = function(v, B, Y, pe) {
        if (B != null) {
            v = jt(this, v);
            for(var ke = 0; ke < B.length; ke++)this.a.A(Y(B[ke]), pe(B[ke]));
            nr(this, v);
        }
    }, be.prototype.writePackedSplitFixed64 = be.prototype.md, be.prototype.nd = function(v, B, Y, pe) {
        if (B != null) {
            v = jt(this, v);
            for(var ke = 0; ke < B.length; ke++)this.a.l(Y(B[ke]), pe(B[ke]));
            nr(this, v);
        }
    }, be.prototype.writePackedSplitVarint64 = be.prototype.nd, be.prototype.od = function(v, B, Y, pe) {
        if (B != null) {
            v = jt(this, v);
            for(var ke = this.a, qe = 0; qe < B.length; qe++)_e(Y(B[qe]), pe(B[qe]), function(ut, Ft) {
                ke.l(ut >>> 0, Ft >>> 0);
            });
            nr(this, v);
        }
    }, be.prototype.writePackedSplitZigzagVarint64 = be.prototype.od, be.prototype.dd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++){
                var pe = vt(B[Y]);
                this.a.l(pe.lo, pe.hi);
            }
            nr(this, v);
        }
    }, be.prototype.writePackedInt64String = be.prototype.dd, be.prototype.pd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.j(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedUint32 = be.prototype.pd, be.prototype.qd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.j(parseInt(B[Y], 10));
            nr(this, v);
        }
    }, be.prototype.writePackedUint32String = be.prototype.qd, be.prototype.rd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.va(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedUint64 = be.prototype.rd, be.prototype.sd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++){
                var pe = Pe(B[Y]);
                this.a.l(pe.lo, pe.hi);
            }
            nr(this, v);
        }
    }, be.prototype.writePackedUint64String = be.prototype.sd, be.prototype.hd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.wa(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedSint32 = be.prototype.hd, be.prototype.jd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.xa(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedSint64 = be.prototype.jd, be.prototype.kd = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.W(fe(B[Y]));
            nr(this, v);
        }
    }, be.prototype.writePackedSint64String = be.prototype.kd, be.prototype.ld = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.W(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedSintHash64 = be.prototype.ld, be.prototype.Wc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(4 * B.length), v = 0; v < B.length; v++)this.a.s(B[v]);
    }, be.prototype.writePackedFixed32 = be.prototype.Wc, be.prototype.Xc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.V(B[v]);
    }, be.prototype.writePackedFixed64 = be.prototype.Xc, be.prototype.Yc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++){
            var Y = Pe(B[v]);
            this.a.A(Y.lo, Y.hi);
        }
    }, be.prototype.writePackedFixed64String = be.prototype.Yc, be.prototype.ed = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(4 * B.length), v = 0; v < B.length; v++)this.a.S(B[v]);
    }, be.prototype.writePackedSfixed32 = be.prototype.ed, be.prototype.fd = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.T(B[v]);
    }, be.prototype.writePackedSfixed64 = be.prototype.fd, be.prototype.gd = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.ka(B[v]);
    }, be.prototype.writePackedSfixed64String = be.prototype.gd, be.prototype.$c = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(4 * B.length), v = 0; v < B.length; v++)this.a.L(B[v]);
    }, be.prototype.writePackedFloat = be.prototype.$c, be.prototype.Uc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.J(B[v]);
    }, be.prototype.writePackedDouble = be.prototype.Uc, be.prototype.Tc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(B.length), v = 0; v < B.length; v++)this.a.I(B[v]);
    }, be.prototype.writePackedBool = be.prototype.Tc, be.prototype.Vc = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.R(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedEnum = be.prototype.Vc, be.prototype.Zc = function(v, B) {
        if (B != null && B.length) for(kt(this, v, 2), this.a.j(8 * B.length), v = 0; v < B.length; v++)this.a.K(B[v]);
    }, be.prototype.writePackedFixedHash64 = be.prototype.Zc, be.prototype.td = function(v, B) {
        if (B != null && B.length) {
            v = jt(this, v);
            for(var Y = 0; Y < B.length; Y++)this.a.N(B[Y]);
            nr(this, v);
        }
    }, be.prototype.writePackedVarintHash64 = be.prototype.td, e.debug = Ct, e.Map = w, e.Message = Qe, e.BinaryReader = se, e.BinaryWriter = be, e.ExtensionFieldInfo = yt, e.ExtensionFieldBinaryInfo = _t, e.exportSymbol = A, e.inherits = O, e.object = {
        extend: U
    }, e.typeOf = y;
})(rS);
var tne = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), rne = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), nne = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && tne(t, e, r);
    return rne(t, e), t;
}, yn = Ge && Ge.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
};
Object.defineProperty(Lf, "__esModule", {
    value: !0
});
Lf.protorune = void 0;
const Be = nne(rS);
var Ck;
(function(e) {
    var t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U, D, H, K, re, Q, G;
    class R extends Be.Message {
        constructor(M){
            super(), t.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, t, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "txindex" in M && M.txindex != null && (this.txindex = M.txindex));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        get txindex() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set txindex(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new R({});
            return M.height != null && (z.height = M.height), M.txindex != null && (z.txindex = M.txindex), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), this.txindex != null && (M.txindex = this.txindex), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint32(1, this.height), this.txindex != 0 && z.writeUint32(2, this.txindex), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new R();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint32();
                    break;
                case 2:
                    de.txindex = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return R.deserialize(M);
        }
    }
    t = /* @__PURE__ */ new WeakMap(), e.RuneId = R;
    class X extends Be.Message {
        constructor(M){
            super(), r.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, r, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "transaction" in M && M.transaction != null && (this.transaction = M.transaction));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        get transaction() {
            return Be.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set transaction(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new X({});
            return M.height != null && (z.height = M.height), M.transaction != null && (z.transaction = M.transaction), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), this.transaction != null && (M.transaction = this.transaction), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint64(1, this.height), this.transaction.length && z.writeBytes(2, this.transaction), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new X();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint64();
                    break;
                case 2:
                    de.transaction = z.readBytes();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return X.deserialize(M);
        }
    }
    r = /* @__PURE__ */ new WeakMap(), e.TransactionRecord = X;
    class $ extends Be.Message {
        constructor(M){
            super(), n.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, n, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "txindex" in M && M.txindex != null && (this.txindex = M.txindex));
        }
        get height() {
            return Be.Message.getWrapperField(this, he, 1);
        }
        set height(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_height() {
            return Be.Message.getField(this, 1) != null;
        }
        get txindex() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set txindex(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_txindex() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new $({});
            return M.height != null && (z.height = he.fromObject(M.height)), M.txindex != null && (z.txindex = he.fromObject(M.txindex)), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height.toObject()), this.txindex != null && (M.txindex = this.txindex.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_height && z.writeMessage(1, this.height, ()=>this.height.serialize(z)), this.has_txindex && z.writeMessage(2, this.txindex, ()=>this.txindex.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new $();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.height, ()=>de.height = he.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.txindex, ()=>de.txindex = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return $.deserialize(M);
        }
    }
    n = /* @__PURE__ */ new WeakMap(), e.ProtoruneRuneId = $;
    class S extends Be.Message {
        constructor(M){
            super(), i.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, i, "f")), !Array.isArray(M) && typeof M == "object" && ("runeId" in M && M.runeId != null && (this.runeId = M.runeId), "name" in M && M.name != null && (this.name = M.name), "divisibility" in M && M.divisibility != null && (this.divisibility = M.divisibility), "spacers" in M && M.spacers != null && (this.spacers = M.spacers), "symbol" in M && M.symbol != null && (this.symbol = M.symbol), "runes_symbol" in M && M.runes_symbol != null && (this.runes_symbol = M.runes_symbol));
        }
        get runeId() {
            return Be.Message.getWrapperField(this, $, 1);
        }
        set runeId(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_runeId() {
            return Be.Message.getField(this, 1) != null;
        }
        get name() {
            return Be.Message.getFieldWithDefault(this, 2, "");
        }
        set name(M) {
            Be.Message.setField(this, 2, M);
        }
        get divisibility() {
            return Be.Message.getFieldWithDefault(this, 3, 0);
        }
        set divisibility(M) {
            Be.Message.setField(this, 3, M);
        }
        get spacers() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set spacers(M) {
            Be.Message.setField(this, 4, M);
        }
        get symbol() {
            return Be.Message.getFieldWithDefault(this, 5, "");
        }
        set symbol(M) {
            Be.Message.setField(this, 5, M);
        }
        get runes_symbol() {
            return Be.Message.getFieldWithDefault(this, 6, 0);
        }
        set runes_symbol(M) {
            Be.Message.setField(this, 6, M);
        }
        static fromObject(M) {
            const z = new S({});
            return M.runeId != null && (z.runeId = $.fromObject(M.runeId)), M.name != null && (z.name = M.name), M.divisibility != null && (z.divisibility = M.divisibility), M.spacers != null && (z.spacers = M.spacers), M.symbol != null && (z.symbol = M.symbol), M.runes_symbol != null && (z.runes_symbol = M.runes_symbol), z;
        }
        toObject() {
            const M = {};
            return this.runeId != null && (M.runeId = this.runeId.toObject()), this.name != null && (M.name = this.name), this.divisibility != null && (M.divisibility = this.divisibility), this.spacers != null && (M.spacers = this.spacers), this.symbol != null && (M.symbol = this.symbol), this.runes_symbol != null && (M.runes_symbol = this.runes_symbol), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_runeId && z.writeMessage(1, this.runeId, ()=>this.runeId.serialize(z)), this.name.length && z.writeString(2, this.name), this.divisibility != 0 && z.writeUint32(3, this.divisibility), this.spacers != 0 && z.writeUint32(4, this.spacers), this.symbol.length && z.writeString(5, this.symbol), this.runes_symbol != 0 && z.writeUint32(6, this.runes_symbol), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new S();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.runeId, ()=>de.runeId = $.deserialize(z));
                    break;
                case 2:
                    de.name = z.readString();
                    break;
                case 3:
                    de.divisibility = z.readUint32();
                    break;
                case 4:
                    de.spacers = z.readUint32();
                    break;
                case 5:
                    de.symbol = z.readString();
                    break;
                case 6:
                    de.runes_symbol = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return S.deserialize(M);
        }
    }
    i = /* @__PURE__ */ new WeakMap(), e.Rune = S;
    class w extends Be.Message {
        constructor(M){
            super(), o.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, o, "f")), !Array.isArray(M) && typeof M == "object" && ("rune" in M && M.rune != null && (this.rune = M.rune), "balance" in M && M.balance != null && (this.balance = M.balance));
        }
        get rune() {
            return Be.Message.getWrapperField(this, S, 1);
        }
        set rune(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_rune() {
            return Be.Message.getField(this, 1) != null;
        }
        get balance() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set balance(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_balance() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new w({});
            return M.rune != null && (z.rune = S.fromObject(M.rune)), M.balance != null && (z.balance = he.fromObject(M.balance)), z;
        }
        toObject() {
            const M = {};
            return this.rune != null && (M.rune = this.rune.toObject()), this.balance != null && (M.balance = this.balance.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_rune && z.writeMessage(1, this.rune, ()=>this.rune.serialize(z)), this.has_balance && z.writeMessage(2, this.balance, ()=>this.balance.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new w();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.rune, ()=>de.rune = S.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.balance, ()=>de.balance = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return w.deserialize(M);
        }
    }
    o = /* @__PURE__ */ new WeakMap(), e.BalanceSheetItem = w;
    class g extends Be.Message {
        constructor(M){
            super(), s.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, s, "f")), !Array.isArray(M) && typeof M == "object" && "entries" in M && M.entries != null && (this.entries = M.entries);
        }
        get entries() {
            return Be.Message.getRepeatedWrapperField(this, w, 1);
        }
        set entries(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        static fromObject(M) {
            const z = new g({});
            return M.entries != null && (z.entries = M.entries.map((de)=>w.fromObject(de))), z;
        }
        toObject() {
            const M = {};
            return this.entries != null && (M.entries = this.entries.map((z)=>z.toObject())), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.entries.length && z.writeRepeatedMessage(1, this.entries, (de)=>de.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new g();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.entries, ()=>Be.Message.addToRepeatedWrapperField(de, 1, w.deserialize(z), w));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return g.deserialize(M);
        }
    }
    s = /* @__PURE__ */ new WeakMap(), e.BalanceSheet = g;
    class m extends Be.Message {
        constructor(M){
            super(), a.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, a, "f")), !Array.isArray(M) && typeof M == "object" && ("txid" in M && M.txid != null && (this.txid = M.txid), "vout" in M && M.vout != null && (this.vout = M.vout));
        }
        get txid() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(M) {
            Be.Message.setField(this, 1, M);
        }
        get vout() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new m({});
            return M.txid != null && (z.txid = M.txid), M.vout != null && (z.vout = M.vout), z;
        }
        toObject() {
            const M = {};
            return this.txid != null && (M.txid = this.txid), this.vout != null && (M.vout = this.vout), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.txid.length && z.writeBytes(1, this.txid), this.vout != 0 && z.writeUint32(2, this.vout), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new m();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.txid = z.readBytes();
                    break;
                case 2:
                    de.vout = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return m.deserialize(M);
        }
    }
    a = /* @__PURE__ */ new WeakMap(), e.Outpoint = m;
    class E extends Be.Message {
        constructor(M){
            super(), u.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, u, "f")), !Array.isArray(M) && typeof M == "object" && ("txid" in M && M.txid != null && (this.txid = M.txid), "vout" in M && M.vout != null && (this.vout = M.vout), "protocol" in M && M.protocol != null && (this.protocol = M.protocol));
        }
        get txid() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(M) {
            Be.Message.setField(this, 1, M);
        }
        get vout() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(M) {
            Be.Message.setField(this, 2, M);
        }
        get protocol() {
            return Be.Message.getWrapperField(this, he, 3);
        }
        set protocol(M) {
            Be.Message.setWrapperField(this, 3, M);
        }
        get has_protocol() {
            return Be.Message.getField(this, 3) != null;
        }
        static fromObject(M) {
            const z = new E({});
            return M.txid != null && (z.txid = M.txid), M.vout != null && (z.vout = M.vout), M.protocol != null && (z.protocol = he.fromObject(M.protocol)), z;
        }
        toObject() {
            const M = {};
            return this.txid != null && (M.txid = this.txid), this.vout != null && (M.vout = this.vout), this.protocol != null && (M.protocol = this.protocol.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.txid.length && z.writeBytes(1, this.txid), this.vout != 0 && z.writeUint32(2, this.vout), this.has_protocol && z.writeMessage(3, this.protocol, ()=>this.protocol.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new E();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.txid = z.readBytes();
                    break;
                case 2:
                    de.vout = z.readUint32();
                    break;
                case 3:
                    z.readMessage(de.protocol, ()=>de.protocol = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return E.deserialize(M);
        }
    }
    u = /* @__PURE__ */ new WeakMap(), e.OutpointWithProtocol = E;
    class T extends Be.Message {
        constructor(M){
            super(), f.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, f, "f")), !Array.isArray(M) && typeof M == "object" && ("script" in M && M.script != null && (this.script = M.script), "value" in M && M.value != null && (this.value = M.value));
        }
        get script() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set script(M) {
            Be.Message.setField(this, 1, M);
        }
        get value() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set value(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new T({});
            return M.script != null && (z.script = M.script), M.value != null && (z.value = M.value), z;
        }
        toObject() {
            const M = {};
            return this.script != null && (M.script = this.script), this.value != null && (M.value = this.value), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.script.length && z.writeBytes(1, this.script), this.value != 0 && z.writeUint64(2, this.value), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new T();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.script = z.readBytes();
                    break;
                case 2:
                    de.value = z.readUint64();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return T.deserialize(M);
        }
    }
    f = /* @__PURE__ */ new WeakMap(), e.Output = T;
    class I extends Be.Message {
        constructor(M){
            super(), c.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, c, "f")), !Array.isArray(M) && typeof M == "object" && ("balances" in M && M.balances != null && (this.balances = M.balances), "outpoint" in M && M.outpoint != null && (this.outpoint = M.outpoint), "output" in M && M.output != null && (this.output = M.output), "height" in M && M.height != null && (this.height = M.height), "txindex" in M && M.txindex != null && (this.txindex = M.txindex));
        }
        get balances() {
            return Be.Message.getWrapperField(this, g, 1);
        }
        set balances(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_balances() {
            return Be.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return Be.Message.getWrapperField(this, m, 2);
        }
        set outpoint(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_outpoint() {
            return Be.Message.getField(this, 2) != null;
        }
        get output() {
            return Be.Message.getWrapperField(this, T, 3);
        }
        set output(M) {
            Be.Message.setWrapperField(this, 3, M);
        }
        get has_output() {
            return Be.Message.getField(this, 3) != null;
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set height(M) {
            Be.Message.setField(this, 4, M);
        }
        get txindex() {
            return Be.Message.getFieldWithDefault(this, 5, 0);
        }
        set txindex(M) {
            Be.Message.setField(this, 5, M);
        }
        static fromObject(M) {
            const z = new I({});
            return M.balances != null && (z.balances = g.fromObject(M.balances)), M.outpoint != null && (z.outpoint = m.fromObject(M.outpoint)), M.output != null && (z.output = T.fromObject(M.output)), M.height != null && (z.height = M.height), M.txindex != null && (z.txindex = M.txindex), z;
        }
        toObject() {
            const M = {};
            return this.balances != null && (M.balances = this.balances.toObject()), this.outpoint != null && (M.outpoint = this.outpoint.toObject()), this.output != null && (M.output = this.output.toObject()), this.height != null && (M.height = this.height), this.txindex != null && (M.txindex = this.txindex), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_balances && z.writeMessage(1, this.balances, ()=>this.balances.serialize(z)), this.has_outpoint && z.writeMessage(2, this.outpoint, ()=>this.outpoint.serialize(z)), this.has_output && z.writeMessage(3, this.output, ()=>this.output.serialize(z)), this.height != 0 && z.writeUint32(4, this.height), this.txindex != 0 && z.writeUint32(5, this.txindex), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new I();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.balances, ()=>de.balances = g.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.outpoint, ()=>de.outpoint = m.deserialize(z));
                    break;
                case 3:
                    z.readMessage(de.output, ()=>de.output = T.deserialize(z));
                    break;
                case 4:
                    de.height = z.readUint32();
                    break;
                case 5:
                    de.txindex = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return I.deserialize(M);
        }
    }
    c = /* @__PURE__ */ new WeakMap(), e.OutpointResponse = I;
    class P extends Be.Message {
        constructor(M){
            super(), l.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, l, "f")), !Array.isArray(M) && typeof M == "object" && ("start" in M && M.start != null && (this.start = M.start), "end" in M && M.end != null && (this.end = M.end));
        }
        get start() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set start(M) {
            Be.Message.setField(this, 1, M);
        }
        get end() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set end(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new P({});
            return M.start != null && (z.start = M.start), M.end != null && (z.end = M.end), z;
        }
        toObject() {
            const M = {};
            return this.start != null && (M.start = this.start), this.end != null && (M.end = this.end), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.start != 0 && z.writeUint32(1, this.start), this.end != 0 && z.writeUint32(2, this.end), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new P();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.start = z.readUint32();
                    break;
                case 2:
                    de.end = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return P.deserialize(M);
        }
    }
    l = /* @__PURE__ */ new WeakMap(), e.PaginationInput = P;
    class k extends Be.Message {
        constructor(M){
            super(), p.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, p, "f")), !Array.isArray(M) && typeof M == "object" && "wallet" in M && M.wallet != null && (this.wallet = M.wallet);
        }
        get wallet() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set wallet(M) {
            Be.Message.setField(this, 1, M);
        }
        static fromObject(M) {
            const z = new k({});
            return M.wallet != null && (z.wallet = M.wallet), z;
        }
        toObject() {
            const M = {};
            return this.wallet != null && (M.wallet = this.wallet), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.wallet.length && z.writeBytes(1, this.wallet), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new k();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.wallet = z.readBytes();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return k.deserialize(M);
        }
    }
    p = /* @__PURE__ */ new WeakMap(), e.WalletRequest = k;
    class L extends Be.Message {
        constructor(M){
            super(), y.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, y, "f")), !Array.isArray(M) && typeof M == "object" && ("outpoints" in M && M.outpoints != null && (this.outpoints = M.outpoints), "balances" in M && M.balances != null && (this.balances = M.balances));
        }
        get outpoints() {
            return Be.Message.getRepeatedWrapperField(this, I, 1);
        }
        set outpoints(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        get balances() {
            return Be.Message.getWrapperField(this, g, 2);
        }
        set balances(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_balances() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new L({});
            return M.outpoints != null && (z.outpoints = M.outpoints.map((de)=>I.fromObject(de))), M.balances != null && (z.balances = g.fromObject(M.balances)), z;
        }
        toObject() {
            const M = {};
            return this.outpoints != null && (M.outpoints = this.outpoints.map((z)=>z.toObject())), this.balances != null && (M.balances = this.balances.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.outpoints.length && z.writeRepeatedMessage(1, this.outpoints, (de)=>de.serialize(z)), this.has_balances && z.writeMessage(2, this.balances, ()=>this.balances.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new L();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.outpoints, ()=>Be.Message.addToRepeatedWrapperField(de, 1, I.deserialize(z), I));
                    break;
                case 2:
                    z.readMessage(de.balances, ()=>de.balances = g.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return L.deserialize(M);
        }
    }
    y = /* @__PURE__ */ new WeakMap(), e.WalletResponse = L;
    class j extends Be.Message {
        constructor(M){
            super(), _.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, _, "f")), !Array.isArray(M) && typeof M == "object" && ("wallet" in M && M.wallet != null && (this.wallet = M.wallet), "protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag));
        }
        get wallet() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set wallet(M) {
            Be.Message.setField(this, 1, M);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new j({});
            return M.wallet != null && (z.wallet = M.wallet), M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), z;
        }
        toObject() {
            const M = {};
            return this.wallet != null && (M.wallet = this.wallet), this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.wallet.length && z.writeBytes(1, this.wallet), this.has_protocol_tag && z.writeMessage(2, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new j();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.wallet = z.readBytes();
                    break;
                case 2:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return j.deserialize(M);
        }
    }
    _ = /* @__PURE__ */ new WeakMap(), e.ProtorunesWalletRequest = j;
    class ie extends Be.Message {
        constructor(M){
            super(), A.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, A, "f")), !Array.isArray(M) && typeof M == "object" && "height" in M && M.height != null && (this.height = M.height);
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        static fromObject(M) {
            const z = new ie({});
            return M.height != null && (z.height = M.height), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint64(1, this.height), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ie();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint64();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ie.deserialize(M);
        }
    }
    A = /* @__PURE__ */ new WeakMap(), e.RunesByHeightRequest = ie;
    class ue extends Be.Message {
        constructor(M){
            super(), O.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, O, "f")), !Array.isArray(M) && typeof M == "object" && "runes" in M && M.runes != null && (this.runes = M.runes);
        }
        get runes() {
            return Be.Message.getRepeatedWrapperField(this, S, 1);
        }
        set runes(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        static fromObject(M) {
            const z = new ue({});
            return M.runes != null && (z.runes = M.runes.map((de)=>S.fromObject(de))), z;
        }
        toObject() {
            const M = {};
            return this.runes != null && (M.runes = this.runes.map((z)=>z.toObject())), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.runes.length && z.writeRepeatedMessage(1, this.runes, (de)=>de.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ue();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.runes, ()=>Be.Message.addToRepeatedWrapperField(de, 1, S.deserialize(z), S));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ue.deserialize(M);
        }
    }
    O = /* @__PURE__ */ new WeakMap(), e.RunesResponse = ue;
    class ce extends Be.Message {
        constructor(M){
            super(), N.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, N, "f")), !Array.isArray(M) && typeof M == "object" && ("protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag), "pointer" in M && M.pointer != null && (this.pointer = M.pointer));
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 1);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 1) != null;
        }
        get pointer() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set pointer(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new ce({});
            return M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), M.pointer != null && (z.pointer = M.pointer), z;
        }
        toObject() {
            const M = {};
            return this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), this.pointer != null && (M.pointer = this.pointer), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_protocol_tag && z.writeMessage(1, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), this.pointer != 0 && z.writeUint32(2, this.pointer), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ce();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                case 2:
                    de.pointer = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ce.deserialize(M);
        }
    }
    N = /* @__PURE__ */ new WeakMap(), e.ProtoBurn = ce;
    class he extends Be.Message {
        constructor(M){
            super(), U.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, U, "f")), !Array.isArray(M) && typeof M == "object" && ("lo" in M && M.lo != null && (this.lo = M.lo), "hi" in M && M.hi != null && (this.hi = M.hi));
        }
        get lo() {
            return Be.Message.getFieldWithDefault(this, 1, "0");
        }
        set lo(M) {
            Be.Message.setField(this, 1, M);
        }
        get hi() {
            return Be.Message.getFieldWithDefault(this, 2, "0");
        }
        set hi(M) {
            Be.Message.setField(this, 2, M);
        }
        static fromObject(M) {
            const z = new he({});
            return M.lo != null && (z.lo = M.lo), M.hi != null && (z.hi = M.hi), z;
        }
        toObject() {
            const M = {};
            return this.lo != null && (M.lo = this.lo), this.hi != null && (M.hi = this.hi), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.lo != "0" && z.writeUint64String(1, this.lo), this.hi != "0" && z.writeUint64String(2, this.hi), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new he();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.lo = z.readUint64String();
                    break;
                case 2:
                    de.hi = z.readUint64String();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return he.deserialize(M);
        }
    }
    U = /* @__PURE__ */ new WeakMap(), e.uint128 = he;
    class ee extends Be.Message {
        constructor(M){
            super(), D.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, D, "f")), !Array.isArray(M) && typeof M == "object" && ("rune" in M && M.rune != null && (this.rune = M.rune), "amount" in M && M.amount != null && (this.amount = M.amount));
        }
        get rune() {
            return Be.Message.getWrapperField(this, $, 1);
        }
        set rune(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_rune() {
            return Be.Message.getField(this, 1) != null;
        }
        get amount() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set amount(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_amount() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new ee({});
            return M.rune != null && (z.rune = $.fromObject(M.rune)), M.amount != null && (z.amount = he.fromObject(M.amount)), z;
        }
        toObject() {
            const M = {};
            return this.rune != null && (M.rune = this.rune.toObject()), this.amount != null && (M.amount = this.amount.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_rune && z.writeMessage(1, this.rune, ()=>this.rune.serialize(z)), this.has_amount && z.writeMessage(2, this.amount, ()=>this.amount.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ee();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.rune, ()=>de.rune = $.deserialize(z));
                    break;
                case 2:
                    z.readMessage(de.amount, ()=>de.amount = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ee.deserialize(M);
        }
    }
    D = /* @__PURE__ */ new WeakMap(), e.Clause = ee;
    class ae extends Be.Message {
        constructor(M){
            super(), H.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [
                1
            ], yn(this, H, "f")), !Array.isArray(M) && typeof M == "object" && "clauses" in M && M.clauses != null && (this.clauses = M.clauses);
        }
        get clauses() {
            return Be.Message.getRepeatedWrapperField(this, ee, 1);
        }
        set clauses(M) {
            Be.Message.setRepeatedWrapperField(this, 1, M);
        }
        static fromObject(M) {
            const z = new ae({});
            return M.clauses != null && (z.clauses = M.clauses.map((de)=>ee.fromObject(de))), z;
        }
        toObject() {
            const M = {};
            return this.clauses != null && (M.clauses = this.clauses.map((z)=>z.toObject())), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.clauses.length && z.writeRepeatedMessage(1, this.clauses, (de)=>de.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ae();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.clauses, ()=>Be.Message.addToRepeatedWrapperField(de, 1, ee.deserialize(z), ee));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ae.deserialize(M);
        }
    }
    H = /* @__PURE__ */ new WeakMap(), e.Predicate = ae;
    class ye extends Be.Message {
        constructor(M){
            super(), K.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, K, "f")), !Array.isArray(M) && typeof M == "object" && ("calldata" in M && M.calldata != null && (this.calldata = M.calldata), "predicate" in M && M.predicate != null && (this.predicate = M.predicate), "pointer" in M && M.pointer != null && (this.pointer = M.pointer), "refund_pointer" in M && M.refund_pointer != null && (this.refund_pointer = M.refund_pointer));
        }
        get calldata() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set calldata(M) {
            Be.Message.setField(this, 1, M);
        }
        get predicate() {
            return Be.Message.getWrapperField(this, ae, 2);
        }
        set predicate(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_predicate() {
            return Be.Message.getField(this, 2) != null;
        }
        get pointer() {
            return Be.Message.getFieldWithDefault(this, 3, 0);
        }
        set pointer(M) {
            Be.Message.setField(this, 3, M);
        }
        get refund_pointer() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set refund_pointer(M) {
            Be.Message.setField(this, 4, M);
        }
        static fromObject(M) {
            const z = new ye({});
            return M.calldata != null && (z.calldata = M.calldata), M.predicate != null && (z.predicate = ae.fromObject(M.predicate)), M.pointer != null && (z.pointer = M.pointer), M.refund_pointer != null && (z.refund_pointer = M.refund_pointer), z;
        }
        toObject() {
            const M = {};
            return this.calldata != null && (M.calldata = this.calldata), this.predicate != null && (M.predicate = this.predicate.toObject()), this.pointer != null && (M.pointer = this.pointer), this.refund_pointer != null && (M.refund_pointer = this.refund_pointer), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.calldata.length && z.writeBytes(1, this.calldata), this.has_predicate && z.writeMessage(2, this.predicate, ()=>this.predicate.serialize(z)), this.pointer != 0 && z.writeUint32(3, this.pointer), this.refund_pointer != 0 && z.writeUint32(4, this.refund_pointer), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new ye();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.calldata = z.readBytes();
                    break;
                case 2:
                    z.readMessage(de.predicate, ()=>de.predicate = ae.deserialize(z));
                    break;
                case 3:
                    de.pointer = z.readUint32();
                    break;
                case 4:
                    de.refund_pointer = z.readUint32();
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return ye.deserialize(M);
        }
    }
    K = /* @__PURE__ */ new WeakMap(), e.ProtoMessage = ye;
    class Se extends Be.Message {
        constructor(M){
            super(), re.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, re, "f")), !Array.isArray(M) && typeof M == "object" && "protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 1);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 1) != null;
        }
        static fromObject(M) {
            const z = new Se({});
            return M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), z;
        }
        toObject() {
            const M = {};
            return this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_protocol_tag && z.writeMessage(1, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new Se();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return Se.deserialize(M);
        }
    }
    re = /* @__PURE__ */ new WeakMap(), e.RuntimeInput = Se;
    class De extends Be.Message {
        constructor(M){
            super(), Q.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, Q, "f")), !Array.isArray(M) && typeof M == "object" && "balances" in M && M.balances != null && (this.balances = M.balances);
        }
        get balances() {
            return Be.Message.getWrapperField(this, g, 1);
        }
        set balances(M) {
            Be.Message.setWrapperField(this, 1, M);
        }
        get has_balances() {
            return Be.Message.getField(this, 1) != null;
        }
        static fromObject(M) {
            const z = new De({});
            return M.balances != null && (z.balances = g.fromObject(M.balances)), z;
        }
        toObject() {
            const M = {};
            return this.balances != null && (M.balances = this.balances.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.has_balances && z.writeMessage(1, this.balances, ()=>this.balances.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new De();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    z.readMessage(de.balances, ()=>de.balances = g.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return De.deserialize(M);
        }
    }
    Q = /* @__PURE__ */ new WeakMap(), e.Runtime = De;
    class Re extends Be.Message {
        constructor(M){
            super(), G.set(this, []), Be.Message.initialize(this, Array.isArray(M) ? M : [], 0, -1, [], yn(this, G, "f")), !Array.isArray(M) && typeof M == "object" && ("height" in M && M.height != null && (this.height = M.height), "protocol_tag" in M && M.protocol_tag != null && (this.protocol_tag = M.protocol_tag));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(M) {
            Be.Message.setField(this, 1, M);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, he, 2);
        }
        set protocol_tag(M) {
            Be.Message.setWrapperField(this, 2, M);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(M) {
            const z = new Re({});
            return M.height != null && (z.height = M.height), M.protocol_tag != null && (z.protocol_tag = he.fromObject(M.protocol_tag)), z;
        }
        toObject() {
            const M = {};
            return this.height != null && (M.height = this.height), this.protocol_tag != null && (M.protocol_tag = this.protocol_tag.toObject()), M;
        }
        serialize(M) {
            const z = M || new Be.BinaryWriter();
            if (this.height != 0 && z.writeUint64(1, this.height), this.has_protocol_tag && z.writeMessage(2, this.protocol_tag, ()=>this.protocol_tag.serialize(z)), !M) return z.getResultBuffer();
        }
        static deserialize(M) {
            const z = M instanceof Be.BinaryReader ? M : new Be.BinaryReader(M), de = new Re();
            for(; z.nextField() && !z.isEndGroup();)switch(z.getFieldNumber()){
                case 1:
                    de.height = z.readUint64();
                    break;
                case 2:
                    z.readMessage(de.protocol_tag, ()=>de.protocol_tag = he.deserialize(z));
                    break;
                default:
                    z.skipField();
            }
            return de;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(M) {
            return Re.deserialize(M);
        }
    }
    G = /* @__PURE__ */ new WeakMap(), e.ProtorunesByHeightRequest = Re;
})(Ck || (Lf.protorune = Ck = {}));
var h0 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.addHexPrefix = e.stripHexPrefix = void 0;
    const t = (n)=>n.slice(0, 2) == "0x" ? n.slice(2) : n;
    e.stripHexPrefix = t;
    const r = (n)=>"0x" + (0, e.stripHexPrefix)(n);
    e.addHexPrefix = r;
})(h0);
var Jr = {}, Qb = {};
Object.defineProperty(Qb, "__esModule", {
    value: !0
});
Qb.SeekBuffer = void 0;
let ine = class {
    constructor(t){
        this.buffer = t, this.seekIndex = 0;
    }
    readUInt8() {
        if (!this.isFinished()) return this.buffer.readUInt8(this.seekIndex++);
    }
    isFinished() {
        return this.seekIndex >= this.buffer.length;
    }
};
Qb.SeekBuffer = ine;
var Nd = {}, one = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), sne = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), ane = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && one(t, e, r);
    return sne(t, e), t;
}, Xr = Ge && Ge.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
};
Object.defineProperty(Nd, "__esModule", {
    value: !0
});
Nd.alkanes = void 0;
const Ee = ane(rS);
var Uk;
(function(e) {
    var t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U, D, H, K, re, Q, G, R, X, $;
    let S;
    (function(Ue) {
        Ue[Ue.NONE = 0] = "NONE", Ue[Ue.CALL = 1] = "CALL", Ue[Ue.DELEGATECALL = 2] = "DELEGATECALL", Ue[Ue.STATICCALL = 3] = "STATICCALL";
    })(S = e.AlkanesTraceCallType || (e.AlkanesTraceCallType = {}));
    let w;
    (function(Ue) {
        Ue[Ue.SUCCESS = 0] = "SUCCESS", Ue[Ue.FAILURE = 1] = "FAILURE";
    })(w = e.AlkanesTraceStatusFlag || (e.AlkanesTraceStatusFlag = {}));
    class g extends Ee.Message {
        constructor(h){
            super(), t.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, t, "f")), !Array.isArray(h) && typeof h == "object" && ("lo" in h && h.lo != null && (this.lo = h.lo), "hi" in h && h.hi != null && (this.hi = h.hi));
        }
        get lo() {
            return Ee.Message.getFieldWithDefault(this, 1, "0");
        }
        set lo(h) {
            Ee.Message.setField(this, 1, h);
        }
        get hi() {
            return Ee.Message.getFieldWithDefault(this, 2, "0");
        }
        set hi(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new g({});
            return h.lo != null && (x.lo = h.lo), h.hi != null && (x.hi = h.hi), x;
        }
        toObject() {
            const h = {};
            return this.lo != null && (h.lo = this.lo), this.hi != null && (h.hi = this.hi), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.lo != "0" && x.writeUint64String(1, this.lo), this.hi != "0" && x.writeUint64String(2, this.hi), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new g();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.lo = x.readUint64String();
                    break;
                case 2:
                    q.hi = x.readUint64String();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return g.deserialize(h);
        }
    }
    t = /* @__PURE__ */ new WeakMap(), e.uint128 = g;
    class m extends Ee.Message {
        constructor(h){
            super(), r.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, r, "f")), !Array.isArray(h) && typeof h == "object" && "id" in h && h.id != null && (this.id = h.id);
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new m({});
            return h.id != null && (x.id = E.fromObject(h.id)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new m();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return m.deserialize(h);
        }
    }
    r = /* @__PURE__ */ new WeakMap(), e.BytecodeRequest = m;
    class E extends Ee.Message {
        constructor(h){
            super(), n.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, n, "f")), !Array.isArray(h) && typeof h == "object" && ("block" in h && h.block != null && (this.block = h.block), "tx" in h && h.tx != null && (this.tx = h.tx));
        }
        get block() {
            return Ee.Message.getWrapperField(this, g, 1);
        }
        set block(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_block() {
            return Ee.Message.getField(this, 1) != null;
        }
        get tx() {
            return Ee.Message.getWrapperField(this, g, 2);
        }
        set tx(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_tx() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new E({});
            return h.block != null && (x.block = g.fromObject(h.block)), h.tx != null && (x.tx = g.fromObject(h.tx)), x;
        }
        toObject() {
            const h = {};
            return this.block != null && (h.block = this.block.toObject()), this.tx != null && (h.tx = this.tx.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_block && x.writeMessage(1, this.block, ()=>this.block.serialize(x)), this.has_tx && x.writeMessage(2, this.tx, ()=>this.tx.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new E();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.block, ()=>q.block = g.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.tx, ()=>q.tx = g.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return E.deserialize(h);
        }
    }
    n = /* @__PURE__ */ new WeakMap(), e.AlkaneId = E;
    class T extends Ee.Message {
        constructor(h){
            super(), i.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, i, "f")), !Array.isArray(h) && typeof h == "object" && ("id" in h && h.id != null && (this.id = h.id), "value" in h && h.value != null && (this.value = h.value));
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        get value() {
            return Ee.Message.getWrapperField(this, g, 2);
        }
        set value(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_value() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new T({});
            return h.id != null && (x.id = E.fromObject(h.id)), h.value != null && (x.value = g.fromObject(h.value)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), this.value != null && (h.value = this.value.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), this.has_value && x.writeMessage(2, this.value, ()=>this.value.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new T();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.value, ()=>q.value = g.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return T.deserialize(h);
        }
    }
    i = /* @__PURE__ */ new WeakMap(), e.AlkaneTransfer = T;
    class I extends Ee.Message {
        constructor(h){
            super(), o.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, o, "f")), !Array.isArray(h) && typeof h == "object" && ("alkanes" in h && h.alkanes != null && (this.alkanes = h.alkanes), "transaction" in h && h.transaction != null && (this.transaction = h.transaction), "block" in h && h.block != null && (this.block = h.block), "height" in h && h.height != null && (this.height = h.height), "txindex" in h && h.txindex != null && (this.txindex = h.txindex), "calldata" in h && h.calldata != null && (this.calldata = h.calldata), "vout" in h && h.vout != null && (this.vout = h.vout), "pointer" in h && h.pointer != null && (this.pointer = h.pointer), "refund_pointer" in h && h.refund_pointer != null && (this.refund_pointer = h.refund_pointer));
        }
        get alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 1);
        }
        set alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        get transaction() {
            return Ee.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set transaction(h) {
            Ee.Message.setField(this, 2, h);
        }
        get block() {
            return Ee.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
        }
        set block(h) {
            Ee.Message.setField(this, 3, h);
        }
        get height() {
            return Ee.Message.getFieldWithDefault(this, 4, 0);
        }
        set height(h) {
            Ee.Message.setField(this, 4, h);
        }
        get txindex() {
            return Ee.Message.getFieldWithDefault(this, 6, 0);
        }
        set txindex(h) {
            Ee.Message.setField(this, 6, h);
        }
        get calldata() {
            return Ee.Message.getFieldWithDefault(this, 5, new Uint8Array(0));
        }
        set calldata(h) {
            Ee.Message.setField(this, 5, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 7, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 7, h);
        }
        get pointer() {
            return Ee.Message.getFieldWithDefault(this, 8, 0);
        }
        set pointer(h) {
            Ee.Message.setField(this, 8, h);
        }
        get refund_pointer() {
            return Ee.Message.getFieldWithDefault(this, 9, 0);
        }
        set refund_pointer(h) {
            Ee.Message.setField(this, 9, h);
        }
        static fromObject(h) {
            const x = new I({});
            return h.alkanes != null && (x.alkanes = h.alkanes.map((q)=>T.fromObject(q))), h.transaction != null && (x.transaction = h.transaction), h.block != null && (x.block = h.block), h.height != null && (x.height = h.height), h.txindex != null && (x.txindex = h.txindex), h.calldata != null && (x.calldata = h.calldata), h.vout != null && (x.vout = h.vout), h.pointer != null && (x.pointer = h.pointer), h.refund_pointer != null && (x.refund_pointer = h.refund_pointer), x;
        }
        toObject() {
            const h = {};
            return this.alkanes != null && (h.alkanes = this.alkanes.map((x)=>x.toObject())), this.transaction != null && (h.transaction = this.transaction), this.block != null && (h.block = this.block), this.height != null && (h.height = this.height), this.txindex != null && (h.txindex = this.txindex), this.calldata != null && (h.calldata = this.calldata), this.vout != null && (h.vout = this.vout), this.pointer != null && (h.pointer = this.pointer), this.refund_pointer != null && (h.refund_pointer = this.refund_pointer), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.alkanes.length && x.writeRepeatedMessage(1, this.alkanes, (q)=>q.serialize(x)), this.transaction.length && x.writeBytes(2, this.transaction), this.block.length && x.writeBytes(3, this.block), this.height != 0 && x.writeUint64(4, this.height), this.txindex != 0 && x.writeUint32(6, this.txindex), this.calldata.length && x.writeBytes(5, this.calldata), this.vout != 0 && x.writeUint32(7, this.vout), this.pointer != 0 && x.writeUint32(8, this.pointer), this.refund_pointer != 0 && x.writeUint32(9, this.refund_pointer), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new I();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, T.deserialize(x), T));
                    break;
                case 2:
                    q.transaction = x.readBytes();
                    break;
                case 3:
                    q.block = x.readBytes();
                    break;
                case 4:
                    q.height = x.readUint64();
                    break;
                case 6:
                    q.txindex = x.readUint32();
                    break;
                case 5:
                    q.calldata = x.readBytes();
                    break;
                case 7:
                    q.vout = x.readUint32();
                    break;
                case 8:
                    q.pointer = x.readUint32();
                    break;
                case 9:
                    q.refund_pointer = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return I.deserialize(h);
        }
    }
    o = /* @__PURE__ */ new WeakMap(), e.MessageContextParcel = I;
    class P extends Ee.Message {
        constructor(h){
            super(), s.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, s, "f")), !Array.isArray(h) && typeof h == "object" && ("key" in h && h.key != null && (this.key = h.key), "value" in h && h.value != null && (this.value = h.value));
        }
        get key() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set key(h) {
            Ee.Message.setField(this, 1, h);
        }
        get value() {
            return Ee.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set value(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new P({});
            return h.key != null && (x.key = h.key), h.value != null && (x.value = h.value), x;
        }
        toObject() {
            const h = {};
            return this.key != null && (h.key = this.key), this.value != null && (h.value = this.value), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.key.length && x.writeBytes(1, this.key), this.value.length && x.writeBytes(2, this.value), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new P();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.key = x.readBytes();
                    break;
                case 2:
                    q.value = x.readBytes();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return P.deserialize(h);
        }
    }
    s = /* @__PURE__ */ new WeakMap(), e.KeyValuePair = P;
    class k extends Ee.Message {
        constructor(h){
            super(), a.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1,
                2
            ], Xr(this, a, "f")), !Array.isArray(h) && typeof h == "object" && ("alkanes" in h && h.alkanes != null && (this.alkanes = h.alkanes), "storage" in h && h.storage != null && (this.storage = h.storage), "data" in h && h.data != null && (this.data = h.data));
        }
        get alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 1);
        }
        set alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        get storage() {
            return Ee.Message.getRepeatedWrapperField(this, P, 2);
        }
        set storage(h) {
            Ee.Message.setRepeatedWrapperField(this, 2, h);
        }
        get data() {
            return Ee.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
        }
        set data(h) {
            Ee.Message.setField(this, 3, h);
        }
        static fromObject(h) {
            const x = new k({});
            return h.alkanes != null && (x.alkanes = h.alkanes.map((q)=>T.fromObject(q))), h.storage != null && (x.storage = h.storage.map((q)=>P.fromObject(q))), h.data != null && (x.data = h.data), x;
        }
        toObject() {
            const h = {};
            return this.alkanes != null && (h.alkanes = this.alkanes.map((x)=>x.toObject())), this.storage != null && (h.storage = this.storage.map((x)=>x.toObject())), this.data != null && (h.data = this.data), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.alkanes.length && x.writeRepeatedMessage(1, this.alkanes, (q)=>q.serialize(x)), this.storage.length && x.writeRepeatedMessage(2, this.storage, (q)=>q.serialize(x)), this.data.length && x.writeBytes(3, this.data), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new k();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, T.deserialize(x), T));
                    break;
                case 2:
                    x.readMessage(q.storage, ()=>Ee.Message.addToRepeatedWrapperField(q, 2, P.deserialize(x), P));
                    break;
                case 3:
                    q.data = x.readBytes();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return k.deserialize(h);
        }
    }
    a = /* @__PURE__ */ new WeakMap(), e.ExtendedCallResponse = k;
    class L extends Ee.Message {
        constructor(h){
            super(), u.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                3,
                5
            ], Xr(this, u, "f")), !Array.isArray(h) && typeof h == "object" && ("myself" in h && h.myself != null && (this.myself = h.myself), "caller" in h && h.caller != null && (this.caller = h.caller), "inputs" in h && h.inputs != null && (this.inputs = h.inputs), "vout" in h && h.vout != null && (this.vout = h.vout), "incoming_alkanes" in h && h.incoming_alkanes != null && (this.incoming_alkanes = h.incoming_alkanes));
        }
        get myself() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set myself(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_myself() {
            return Ee.Message.getField(this, 1) != null;
        }
        get caller() {
            return Ee.Message.getWrapperField(this, E, 2);
        }
        set caller(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_caller() {
            return Ee.Message.getField(this, 2) != null;
        }
        get inputs() {
            return Ee.Message.getRepeatedWrapperField(this, g, 3);
        }
        set inputs(h) {
            Ee.Message.setRepeatedWrapperField(this, 3, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 4, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 4, h);
        }
        get incoming_alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 5);
        }
        set incoming_alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 5, h);
        }
        static fromObject(h) {
            const x = new L({});
            return h.myself != null && (x.myself = E.fromObject(h.myself)), h.caller != null && (x.caller = E.fromObject(h.caller)), h.inputs != null && (x.inputs = h.inputs.map((q)=>g.fromObject(q))), h.vout != null && (x.vout = h.vout), h.incoming_alkanes != null && (x.incoming_alkanes = h.incoming_alkanes.map((q)=>T.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.myself != null && (h.myself = this.myself.toObject()), this.caller != null && (h.caller = this.caller.toObject()), this.inputs != null && (h.inputs = this.inputs.map((x)=>x.toObject())), this.vout != null && (h.vout = this.vout), this.incoming_alkanes != null && (h.incoming_alkanes = this.incoming_alkanes.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_myself && x.writeMessage(1, this.myself, ()=>this.myself.serialize(x)), this.has_caller && x.writeMessage(2, this.caller, ()=>this.caller.serialize(x)), this.inputs.length && x.writeRepeatedMessage(3, this.inputs, (q)=>q.serialize(x)), this.vout != 0 && x.writeUint32(4, this.vout), this.incoming_alkanes.length && x.writeRepeatedMessage(5, this.incoming_alkanes, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new L();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.myself, ()=>q.myself = E.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.caller, ()=>q.caller = E.deserialize(x));
                    break;
                case 3:
                    x.readMessage(q.inputs, ()=>Ee.Message.addToRepeatedWrapperField(q, 3, g.deserialize(x), g));
                    break;
                case 4:
                    q.vout = x.readUint32();
                    break;
                case 5:
                    x.readMessage(q.incoming_alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 5, T.deserialize(x), T));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return L.deserialize(h);
        }
    }
    u = /* @__PURE__ */ new WeakMap(), e.Context = L;
    class j extends Ee.Message {
        constructor(h){
            super(), f.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, f, "f")), !Array.isArray(h) && typeof h == "object" && ("inner" in h && h.inner != null && (this.inner = h.inner), "fuel" in h && h.fuel != null && (this.fuel = h.fuel));
        }
        get inner() {
            return Ee.Message.getWrapperField(this, L, 1);
        }
        set inner(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_inner() {
            return Ee.Message.getField(this, 1) != null;
        }
        get fuel() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set fuel(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new j({});
            return h.inner != null && (x.inner = L.fromObject(h.inner)), h.fuel != null && (x.fuel = h.fuel), x;
        }
        toObject() {
            const h = {};
            return this.inner != null && (h.inner = this.inner.toObject()), this.fuel != null && (h.fuel = this.fuel), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_inner && x.writeMessage(1, this.inner, ()=>this.inner.serialize(x)), this.fuel != 0 && x.writeUint64(2, this.fuel), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new j();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.inner, ()=>q.inner = L.deserialize(x));
                    break;
                case 2:
                    q.fuel = x.readUint64();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return j.deserialize(h);
        }
    }
    f = /* @__PURE__ */ new WeakMap(), e.TraceContext = j;
    class ie extends Ee.Message {
        constructor(h){
            super(), c.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, c, "f")), !Array.isArray(h) && typeof h == "object" && ("call_type" in h && h.call_type != null && (this.call_type = h.call_type), "context" in h && h.context != null && (this.context = h.context));
        }
        get call_type() {
            return Ee.Message.getFieldWithDefault(this, 1, S.NONE);
        }
        set call_type(h) {
            Ee.Message.setField(this, 1, h);
        }
        get context() {
            return Ee.Message.getWrapperField(this, j, 2);
        }
        set context(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_context() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new ie({});
            return h.call_type != null && (x.call_type = h.call_type), h.context != null && (x.context = j.fromObject(h.context)), x;
        }
        toObject() {
            const h = {};
            return this.call_type != null && (h.call_type = this.call_type), this.context != null && (h.context = this.context.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.call_type != S.NONE && x.writeEnum(1, this.call_type), this.has_context && x.writeMessage(2, this.context, ()=>this.context.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ie();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.call_type = x.readEnum();
                    break;
                case 2:
                    x.readMessage(q.context, ()=>q.context = j.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ie.deserialize(h);
        }
    }
    c = /* @__PURE__ */ new WeakMap(), e.AlkanesEnterContext = ie;
    class ue extends Ee.Message {
        constructor(h){
            super(), l.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, l, "f")), !Array.isArray(h) && typeof h == "object" && ("status" in h && h.status != null && (this.status = h.status), "response" in h && h.response != null && (this.response = h.response));
        }
        get status() {
            return Ee.Message.getFieldWithDefault(this, 1, w.SUCCESS);
        }
        set status(h) {
            Ee.Message.setField(this, 1, h);
        }
        get response() {
            return Ee.Message.getWrapperField(this, k, 2);
        }
        set response(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_response() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new ue({});
            return h.status != null && (x.status = h.status), h.response != null && (x.response = k.fromObject(h.response)), x;
        }
        toObject() {
            const h = {};
            return this.status != null && (h.status = this.status), this.response != null && (h.response = this.response.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.status != w.SUCCESS && x.writeEnum(1, this.status), this.has_response && x.writeMessage(2, this.response, ()=>this.response.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ue();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.status = x.readEnum();
                    break;
                case 2:
                    x.readMessage(q.response, ()=>q.response = k.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ue.deserialize(h);
        }
    }
    l = /* @__PURE__ */ new WeakMap(), e.AlkanesExitContext = ue;
    class ce extends Ee.Message {
        constructor(h){
            super(), p.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, p, "f")), !Array.isArray(h) && typeof h == "object" && "new_alkane" in h && h.new_alkane != null && (this.new_alkane = h.new_alkane);
        }
        get new_alkane() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set new_alkane(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_new_alkane() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new ce({});
            return h.new_alkane != null && (x.new_alkane = E.fromObject(h.new_alkane)), x;
        }
        toObject() {
            const h = {};
            return this.new_alkane != null && (h.new_alkane = this.new_alkane.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_new_alkane && x.writeMessage(1, this.new_alkane, ()=>this.new_alkane.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ce();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.new_alkane, ()=>q.new_alkane = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ce.deserialize(h);
        }
    }
    p = /* @__PURE__ */ new WeakMap(), e.AlkanesCreate = ce;
    class he extends Ee.Message {
        constructor(h){
            super(), y.set(this, [
                [
                    1,
                    2,
                    3
                ]
            ]), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, y, "f")), !Array.isArray(h) && typeof h == "object" && ("enter_context" in h && h.enter_context != null && (this.enter_context = h.enter_context), "exit_context" in h && h.exit_context != null && (this.exit_context = h.exit_context), "create_alkane" in h && h.create_alkane != null && (this.create_alkane = h.create_alkane));
        }
        get enter_context() {
            return Ee.Message.getWrapperField(this, ie, 1);
        }
        set enter_context(h) {
            Ee.Message.setOneofWrapperField(this, 1, Xr(this, y, "f")[0], h);
        }
        get has_enter_context() {
            return Ee.Message.getField(this, 1) != null;
        }
        get exit_context() {
            return Ee.Message.getWrapperField(this, ue, 2);
        }
        set exit_context(h) {
            Ee.Message.setOneofWrapperField(this, 2, Xr(this, y, "f")[0], h);
        }
        get has_exit_context() {
            return Ee.Message.getField(this, 2) != null;
        }
        get create_alkane() {
            return Ee.Message.getWrapperField(this, ce, 3);
        }
        set create_alkane(h) {
            Ee.Message.setOneofWrapperField(this, 3, Xr(this, y, "f")[0], h);
        }
        get has_create_alkane() {
            return Ee.Message.getField(this, 3) != null;
        }
        get event() {
            return ({
                0: "none",
                1: "enter_context",
                2: "exit_context",
                3: "create_alkane"
            })[Ee.Message.computeOneofCase(this, [
                1,
                2,
                3
            ])];
        }
        static fromObject(h) {
            const x = new he({});
            return h.enter_context != null && (x.enter_context = ie.fromObject(h.enter_context)), h.exit_context != null && (x.exit_context = ue.fromObject(h.exit_context)), h.create_alkane != null && (x.create_alkane = ce.fromObject(h.create_alkane)), x;
        }
        toObject() {
            const h = {};
            return this.enter_context != null && (h.enter_context = this.enter_context.toObject()), this.exit_context != null && (h.exit_context = this.exit_context.toObject()), this.create_alkane != null && (h.create_alkane = this.create_alkane.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_enter_context && x.writeMessage(1, this.enter_context, ()=>this.enter_context.serialize(x)), this.has_exit_context && x.writeMessage(2, this.exit_context, ()=>this.exit_context.serialize(x)), this.has_create_alkane && x.writeMessage(3, this.create_alkane, ()=>this.create_alkane.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new he();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.enter_context, ()=>q.enter_context = ie.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.exit_context, ()=>q.exit_context = ue.deserialize(x));
                    break;
                case 3:
                    x.readMessage(q.create_alkane, ()=>q.create_alkane = ce.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return he.deserialize(h);
        }
    }
    y = /* @__PURE__ */ new WeakMap(), e.AlkanesTraceEvent = he;
    class ee extends Ee.Message {
        constructor(h){
            super(), _.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, _, "f")), !Array.isArray(h) && typeof h == "object" && ("traces" in h && h.traces != null && (this.traces = h.traces), "outpoint" in h && h.outpoint != null && (this.outpoint = h.outpoint), "txindex" in h && h.txindex != null && (this.txindex = h.txindex));
        }
        get traces() {
            return Ee.Message.getWrapperField(this, ye, 1);
        }
        set traces(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_traces() {
            return Ee.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return Ee.Message.getWrapperField(this, z, 2);
        }
        set outpoint(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_outpoint() {
            return Ee.Message.getField(this, 2) != null;
        }
        get txindex() {
            return Ee.Message.getFieldWithDefault(this, 3, 0);
        }
        set txindex(h) {
            Ee.Message.setField(this, 3, h);
        }
        static fromObject(h) {
            const x = new ee({});
            return h.traces != null && (x.traces = ye.fromObject(h.traces)), h.outpoint != null && (x.outpoint = z.fromObject(h.outpoint)), h.txindex != null && (x.txindex = h.txindex), x;
        }
        toObject() {
            const h = {};
            return this.traces != null && (h.traces = this.traces.toObject()), this.outpoint != null && (h.outpoint = this.outpoint.toObject()), this.txindex != null && (h.txindex = this.txindex), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_traces && x.writeMessage(1, this.traces, ()=>this.traces.serialize(x)), this.has_outpoint && x.writeMessage(2, this.outpoint, ()=>this.outpoint.serialize(x)), this.txindex != 0 && x.writeUint64(3, this.txindex), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ee();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.traces, ()=>q.traces = ye.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.outpoint, ()=>q.outpoint = z.deserialize(x));
                    break;
                case 3:
                    q.txindex = x.readUint64();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ee.deserialize(h);
        }
    }
    _ = /* @__PURE__ */ new WeakMap(), e.AlkanesBlockEvent = ee;
    class ae extends Ee.Message {
        constructor(h){
            super(), A.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, A, "f")), !Array.isArray(h) && typeof h == "object" && "events" in h && h.events != null && (this.events = h.events);
        }
        get events() {
            return Ee.Message.getRepeatedWrapperField(this, ee, 1);
        }
        set events(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new ae({});
            return h.events != null && (x.events = h.events.map((q)=>ee.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.events != null && (h.events = this.events.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.events.length && x.writeRepeatedMessage(1, this.events, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ae();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.events, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, ee.deserialize(x), ee));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ae.deserialize(h);
        }
    }
    A = /* @__PURE__ */ new WeakMap(), e.AlkanesBlockTraceEvent = ae;
    class ye extends Ee.Message {
        constructor(h){
            super(), O.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, O, "f")), !Array.isArray(h) && typeof h == "object" && "events" in h && h.events != null && (this.events = h.events);
        }
        get events() {
            return Ee.Message.getRepeatedWrapperField(this, he, 1);
        }
        set events(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new ye({});
            return h.events != null && (x.events = h.events.map((q)=>he.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.events != null && (h.events = this.events.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.events.length && x.writeRepeatedMessage(1, this.events, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new ye();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.events, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, he.deserialize(x), he));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return ye.deserialize(h);
        }
    }
    O = /* @__PURE__ */ new WeakMap(), e.AlkanesTrace = ye;
    class Se extends Ee.Message {
        constructor(h){
            super(), N.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, N, "f")), !Array.isArray(h) && typeof h == "object" && ("execution" in h && h.execution != null && (this.execution = h.execution), "gas_used" in h && h.gas_used != null && (this.gas_used = h.gas_used), "error" in h && h.error != null && (this.error = h.error));
        }
        get execution() {
            return Ee.Message.getWrapperField(this, k, 1);
        }
        set execution(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_execution() {
            return Ee.Message.getField(this, 1) != null;
        }
        get gas_used() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set gas_used(h) {
            Ee.Message.setField(this, 2, h);
        }
        get error() {
            return Ee.Message.getFieldWithDefault(this, 3, "");
        }
        set error(h) {
            Ee.Message.setField(this, 3, h);
        }
        static fromObject(h) {
            const x = new Se({});
            return h.execution != null && (x.execution = k.fromObject(h.execution)), h.gas_used != null && (x.gas_used = h.gas_used), h.error != null && (x.error = h.error), x;
        }
        toObject() {
            const h = {};
            return this.execution != null && (h.execution = this.execution.toObject()), this.gas_used != null && (h.gas_used = this.gas_used), this.error != null && (h.error = this.error), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_execution && x.writeMessage(1, this.execution, ()=>this.execution.serialize(x)), this.gas_used != 0 && x.writeUint64(2, this.gas_used), this.error.length && x.writeString(3, this.error), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Se();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.execution, ()=>q.execution = k.deserialize(x));
                    break;
                case 2:
                    q.gas_used = x.readUint64();
                    break;
                case 3:
                    q.error = x.readString();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Se.deserialize(h);
        }
    }
    N = /* @__PURE__ */ new WeakMap(), e.SimulateResponse = Se;
    class De extends Ee.Message {
        constructor(h){
            super(), U.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, U, "f")), !Array.isArray(h) && typeof h == "object" && "id" in h && h.id != null && (this.id = h.id);
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new De({});
            return h.id != null && (x.id = E.fromObject(h.id)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new De();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return De.deserialize(h);
        }
    }
    U = /* @__PURE__ */ new WeakMap(), e.AlkaneInventoryRequest = De;
    class Re extends Ee.Message {
        constructor(h){
            super(), D.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, D, "f")), !Array.isArray(h) && typeof h == "object" && "alkanes" in h && h.alkanes != null && (this.alkanes = h.alkanes);
        }
        get alkanes() {
            return Ee.Message.getRepeatedWrapperField(this, T, 1);
        }
        set alkanes(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new Re({});
            return h.alkanes != null && (x.alkanes = h.alkanes.map((q)=>T.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.alkanes != null && (h.alkanes = this.alkanes.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.alkanes.length && x.writeRepeatedMessage(1, this.alkanes, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Re();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.alkanes, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, T.deserialize(x), T));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Re.deserialize(h);
        }
    }
    D = /* @__PURE__ */ new WeakMap(), e.AlkaneInventoryResponse = Re;
    class Ce extends Ee.Message {
        constructor(h){
            super(), H.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, H, "f")), !Array.isArray(h) && typeof h == "object" && "id" in h && h.id != null && (this.id = h.id);
        }
        get id() {
            return Ee.Message.getWrapperField(this, E, 1);
        }
        set id(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_id() {
            return Ee.Message.getField(this, 1) != null;
        }
        static fromObject(h) {
            const x = new Ce({});
            return h.id != null && (x.id = E.fromObject(h.id)), x;
        }
        toObject() {
            const h = {};
            return this.id != null && (h.id = this.id.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_id && x.writeMessage(1, this.id, ()=>this.id.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Ce();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.id, ()=>q.id = E.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Ce.deserialize(h);
        }
    }
    H = /* @__PURE__ */ new WeakMap(), e.AlkaneIdToOutpointRequest = Ce;
    class M extends Ee.Message {
        constructor(h){
            super(), K.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, K, "f")), !Array.isArray(h) && typeof h == "object" && ("txid" in h && h.txid != null && (this.txid = h.txid), "vout" in h && h.vout != null && (this.vout = h.vout));
        }
        get txid() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(h) {
            Ee.Message.setField(this, 1, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new M({});
            return h.txid != null && (x.txid = h.txid), h.vout != null && (x.vout = h.vout), x;
        }
        toObject() {
            const h = {};
            return this.txid != null && (h.txid = this.txid), this.vout != null && (h.vout = this.vout), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.txid.length && x.writeBytes(1, this.txid), this.vout != 0 && x.writeUint32(2, this.vout), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new M();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.txid = x.readBytes();
                    break;
                case 2:
                    q.vout = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return M.deserialize(h);
        }
    }
    K = /* @__PURE__ */ new WeakMap(), e.AlkaneIdToOutpointResponse = M;
    class z extends Ee.Message {
        constructor(h){
            super(), re.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, re, "f")), !Array.isArray(h) && typeof h == "object" && ("txid" in h && h.txid != null && (this.txid = h.txid), "vout" in h && h.vout != null && (this.vout = h.vout));
        }
        get txid() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(h) {
            Ee.Message.setField(this, 1, h);
        }
        get vout() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new z({});
            return h.txid != null && (x.txid = h.txid), h.vout != null && (x.vout = h.vout), x;
        }
        toObject() {
            const h = {};
            return this.txid != null && (h.txid = this.txid), this.vout != null && (h.vout = this.vout), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.txid.length && x.writeBytes(1, this.txid), this.vout != 0 && x.writeUint32(2, this.vout), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new z();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.txid = x.readBytes();
                    break;
                case 2:
                    q.vout = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return z.deserialize(h);
        }
    }
    re = /* @__PURE__ */ new WeakMap(), e.Outpoint = z;
    class de extends Ee.Message {
        constructor(h){
            super(), Q.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, Q, "f")), !Array.isArray(h) && typeof h == "object" && ("outpoint" in h && h.outpoint != null && (this.outpoint = h.outpoint), "trace" in h && h.trace != null && (this.trace = h.trace));
        }
        get outpoint() {
            return Ee.Message.getWrapperField(this, z, 1);
        }
        set outpoint(h) {
            Ee.Message.setWrapperField(this, 1, h);
        }
        get has_outpoint() {
            return Ee.Message.getField(this, 1) != null;
        }
        get trace() {
            return Ee.Message.getWrapperField(this, ye, 2);
        }
        set trace(h) {
            Ee.Message.setWrapperField(this, 2, h);
        }
        get has_trace() {
            return Ee.Message.getField(this, 2) != null;
        }
        static fromObject(h) {
            const x = new de({});
            return h.outpoint != null && (x.outpoint = z.fromObject(h.outpoint)), h.trace != null && (x.trace = ye.fromObject(h.trace)), x;
        }
        toObject() {
            const h = {};
            return this.outpoint != null && (h.outpoint = this.outpoint.toObject()), this.trace != null && (h.trace = this.trace.toObject()), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.has_outpoint && x.writeMessage(1, this.outpoint, ()=>this.outpoint.serialize(x)), this.has_trace && x.writeMessage(2, this.trace, ()=>this.trace.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new de();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.outpoint, ()=>q.outpoint = z.deserialize(x));
                    break;
                case 2:
                    x.readMessage(q.trace, ()=>q.trace = ye.deserialize(x));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return de.deserialize(h);
        }
    }
    Q = /* @__PURE__ */ new WeakMap(), e.Trace = de;
    class _e extends Ee.Message {
        constructor(h){
            super(), G.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, G, "f")), !Array.isArray(h) && typeof h == "object" && "block" in h && h.block != null && (this.block = h.block);
        }
        get block() {
            return Ee.Message.getFieldWithDefault(this, 1, 0);
        }
        set block(h) {
            Ee.Message.setField(this, 1, h);
        }
        static fromObject(h) {
            const x = new _e({});
            return h.block != null && (x.block = h.block), x;
        }
        toObject() {
            const h = {};
            return this.block != null && (h.block = this.block), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.block != 0 && x.writeUint64(1, this.block), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new _e();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.block = x.readUint64();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return _e.deserialize(h);
        }
    }
    G = /* @__PURE__ */ new WeakMap(), e.TraceBlockRequest = _e;
    class Ie extends Ee.Message {
        constructor(h){
            super(), R.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, R, "f")), !Array.isArray(h) && typeof h == "object" && "height" in h && h.height != null && (this.height = h.height);
        }
        get height() {
            return Ee.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(h) {
            Ee.Message.setField(this, 1, h);
        }
        static fromObject(h) {
            const x = new Ie({});
            return h.height != null && (x.height = h.height), x;
        }
        toObject() {
            const h = {};
            return this.height != null && (h.height = this.height), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.height != 0 && x.writeUint32(1, this.height), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Ie();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.height = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Ie.deserialize(h);
        }
    }
    R = /* @__PURE__ */ new WeakMap(), e.BlockRequest = Ie;
    class je extends Ee.Message {
        constructor(h){
            super(), X.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [], Xr(this, X, "f")), !Array.isArray(h) && typeof h == "object" && ("block" in h && h.block != null && (this.block = h.block), "height" in h && h.height != null && (this.height = h.height));
        }
        get block() {
            return Ee.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set block(h) {
            Ee.Message.setField(this, 1, h);
        }
        get height() {
            return Ee.Message.getFieldWithDefault(this, 2, 0);
        }
        set height(h) {
            Ee.Message.setField(this, 2, h);
        }
        static fromObject(h) {
            const x = new je({});
            return h.block != null && (x.block = h.block), h.height != null && (x.height = h.height), x;
        }
        toObject() {
            const h = {};
            return this.block != null && (h.block = this.block), this.height != null && (h.height = this.height), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.block.length && x.writeBytes(1, this.block), this.height != 0 && x.writeUint32(2, this.height), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new je();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    q.block = x.readBytes();
                    break;
                case 2:
                    q.height = x.readUint32();
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return je.deserialize(h);
        }
    }
    X = /* @__PURE__ */ new WeakMap(), e.BlockResponse = je;
    class Ke extends Ee.Message {
        constructor(h){
            super(), $.set(this, []), Ee.Message.initialize(this, Array.isArray(h) ? h : [], 0, -1, [
                1
            ], Xr(this, $, "f")), !Array.isArray(h) && typeof h == "object" && "traces" in h && h.traces != null && (this.traces = h.traces);
        }
        get traces() {
            return Ee.Message.getRepeatedWrapperField(this, de, 1);
        }
        set traces(h) {
            Ee.Message.setRepeatedWrapperField(this, 1, h);
        }
        static fromObject(h) {
            const x = new Ke({});
            return h.traces != null && (x.traces = h.traces.map((q)=>de.fromObject(q))), x;
        }
        toObject() {
            const h = {};
            return this.traces != null && (h.traces = this.traces.map((x)=>x.toObject())), h;
        }
        serialize(h) {
            const x = h || new Ee.BinaryWriter();
            if (this.traces.length && x.writeRepeatedMessage(1, this.traces, (q)=>q.serialize(x)), !h) return x.getResultBuffer();
        }
        static deserialize(h) {
            const x = h instanceof Ee.BinaryReader ? h : new Ee.BinaryReader(h), q = new Ke();
            for(; x.nextField() && !x.isEndGroup();)switch(x.getFieldNumber()){
                case 1:
                    x.readMessage(q.traces, ()=>Ee.Message.addToRepeatedWrapperField(q, 1, de.deserialize(x), de));
                    break;
                default:
                    x.skipField();
            }
            return q;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(h) {
            return Ke.deserialize(h);
        }
    }
    $ = /* @__PURE__ */ new WeakMap(), e.TraceBlockResponse = Ke;
})(Uk || (Nd.alkanes = Uk = {}));
Object.defineProperty(Jr, "__esModule", {
    value: !0
});
Jr.fromBuffer = Jr.toBuffer = void 0;
Jr.toProtobufAlkaneTransfer = une;
Jr.unpack = fne;
Jr.leftPad15 = sN;
Jr.leftPadByte = nS;
Jr.rightPadByte = lne;
Jr.leftPad16 = iS;
Jr.leftPad8 = QE;
Jr.toUint128 = My;
Jr.fromUint128 = dne;
Jr.toHexString = ex;
Jr.u128ToBuffer = aN;
Jr.encodeVarInt = cN;
Jr.encipher = hne;
Jr.decipher = uN;
Jr.decodeVarInt = fN;
Jr.tryDecodeVarInt = lN;
Jr.pack = yne;
Jr.decipherPacked = mne;
const cne = Qb, JE = Nd;
function une(e) {
    return new JE.alkanes.AlkaneTransfer({
        id: new JE.alkanes.AlkaneId({
            block: My(e.id.block),
            tx: My(e.id.tx)
        }),
        value: My(e.value)
    });
}
function fne(e) {
    return Array.from(e).reduce((t, r, n)=>(n % 15 === 0 && t.push([]), t[t.length - 1].push(r), t), []).map((t)=>BigInt("0x" + We.from(t.reverse()).toString("hex")));
}
function sN(e) {
    if (e.length > 30) throw Error("varint in encoding cannot exceed 15 bytes");
    return "0".repeat(30 - e.length) + e;
}
function nS(e) {
    return e.length % 2 ? "0" + e : e;
}
function lne(e) {
    return e.length % 2 ? e + "0" : e;
}
function iS(e) {
    if (e.length > 16) throw Error("varint in encoding cannot exceed 15 bytes");
    return "0".repeat(32 - e.length) + e;
}
function QE(e) {
    return "0".repeat(16 - e.length) + e;
}
function My(e) {
    let t = iS(e.toString(16));
    return new JE.alkanes.uint128({
        hi: BigInt("0x" + t.substr(0, 16)).toString(10),
        lo: BigInt("0x" + t.substr(16, 32)).toString(10)
    });
}
function dne(e) {
    return aN(e);
}
function ex(e) {
    return BigInt(e).toString(16);
}
function aN(e) {
    return BigInt("0x" + We.from(QE(ex(e.hi)) + QE(ex(e.lo)), "hex").toString("hex"));
}
function cN(e) {
    const t = [];
    for(; e >> 7n > 0n;)t.push(Number(e & 0xffn) | 128), e = BigInt(e >> 7n);
    return t.push(Number(e & 0xffn)), We.from(t);
}
function hne(e) {
    return We.concat(e.map((t)=>cN(t)));
}
const pne = (e)=>We.from(Array.from(We.from(iS(e.toString(16)), "hex")).reverse());
Jr.toBuffer = pne;
const gne = (e)=>BigInt("0x" + We.from(Array.from(e).reverse()).toString("hex"));
Jr.fromBuffer = gne;
function uN(e) {
    let t = new cne.SeekBuffer(e), r = null;
    const n = [];
    for(; (r = fN(t)) !== BigInt(-1);)n.push(r);
    return n;
}
function fN(e) {
    try {
        return lN(e);
    } catch  {
        return BigInt(-1);
    }
}
function lN(e) {
    let t = BigInt(0);
    for(let r = 0; r <= 18; r++){
        const n = e.readUInt8();
        if (n === void 0) throw new Error("Unterminated");
        const i = BigInt(n) & 127n;
        if (r === 18 && (i & 124n) !== 0n) throw new Error("Overflow");
        if (t = BigInt(t | i << BigInt(7 * r)), !(n & 128)) return t;
    }
    throw new Error("Overlong");
}
function yne(e) {
    return We.concat(e.map((t)=>We.from(sN(We.from(Array.from(We.from(nS(t.toString(16)), "hex")).reverse()).toString("hex")), "hex")));
}
function mne(e) {
    return uN(We.concat(e.map((t)=>We.from(Array.from(We.from(nS(t.toString(16)), "hex")).reverse()))));
}
Object.defineProperty(mo, "__esModule", {
    value: !0
});
mo.encodeOutpointInput = Sne;
mo.decodeRunes = dN;
mo.decodeOutpointViewBase = hN;
mo.decodeOutpointView = Ane;
mo.decodeRunesResponse = Tne;
mo.encodeBlockHeightInput = kne;
mo.encodeProtorunesByHeightInput = Ine;
mo.encodeAlkanesIdToOutpointInput = Bne;
mo.decodeAlkanesIdToOutpointResponse = One;
const bne = Lf, oS = h0, Wl = Jr, { OutpointResponse: wne, Outpoint: vne, BalanceSheet: u2e, RunesResponse: _ne, ProtorunesByHeightRequest: Ene, RunesByHeightRequest: xne } = bne.protorune, tx = Nd;
function Sne(e, t) {
    const r = {
        txid: We.from(e, "hex"),
        vout: t
    };
    return "0x" + We.from(new vne(r).serializeBinary()).toString("hex");
}
function dN(e) {
    return e ? e.entries.map((t)=>{
        const r = t.balance, n = t.rune, i = "", o = n.spacers.toString(2);
        let s = n.name, a = s;
        const u = n.symbol;
        let f = 0;
        return o.split("").reverse().map((l, p)=>{
            l == "1" && (a = `${a.slice(0, p + 1 + f)}${i}${a.slice(p + 1 + f)}`, f++);
        }), {
            rune: {
                id: {
                    block: (0, Wl.fromUint128)(n.runeId.height),
                    tx: (0, Wl.fromUint128)(n.runeId.txindex)
                },
                name: s,
                spacedName: a,
                divisibility: n.divisibility,
                spacers: n.spacers,
                symbol: u
            },
            balance: (0, Wl.fromUint128)(r)
        };
    }) : [];
}
function hN(e) {
    return {
        runes: dN(e.balances),
        outpoint: {
            txid: We.from(e.outpoint.txid).toString("hex"),
            vout: e.outpoint.vout
        },
        output: e.output ? {
            value: e.output.value,
            script: We.from(e.output.script).toString("hex")
        } : {
            value: "",
            script: ""
        },
        height: e.height,
        txindex: e.txindex
    };
}
function Ane(e) {
    const t = Uint8Array.from(We.from((0, oS.stripHexPrefix)(e), "hex")), r = wne.deserializeBinary(t);
    return hN(r);
}
function Tne(e) {
    if (!e || e === "0x") return {
        runes: []
    };
    const t = We.from((0, oS.stripHexPrefix)(e), "hex");
    return t.length === 0 ? {
        runes: []
    } : {
        runes: _ne.deserializeBinary(t).runes.map((n)=>{
            var i, o;
            return {
                runeId: `${((i = n.runeId) == null ? void 0 : i.height) || 0}:${((o = n.runeId) == null ? void 0 : o.txindex) || 0}`,
                name: We.from(n.name).toString("utf8"),
                divisibility: n.divisibility,
                spacers: n.spacers,
                symbol: n.symbol
            };
        })
    };
}
function kne(e) {
    const t = {
        height: e
    };
    return "0x" + We.from(new xne(t).serializeBinary()).toString("hex");
}
function Ine(e, t) {
    const r = {
        height: e,
        protocol_tag: (0, Wl.toUint128)(t)
    };
    return "0x" + We.from(new Ene(r).serializeBinary()).toString("hex");
}
function Bne(e, t) {
    const r = new tx.alkanes.AlkaneId({
        block: (0, Wl.toUint128)(e),
        tx: (0, Wl.toUint128)(t)
    });
    return "0x" + We.from(new tx.alkanes.AlkaneIdToOutpointRequest({
        id: r
    }).serializeBinary()).toString("hex");
}
function One(e) {
    if (!e || e === "0x") return {
        outpoint: {}
    };
    const t = We.from((0, oS.stripHexPrefix)(e), "hex");
    if (t.length === 0) return {
        outpoint: {}
    };
    const r = tx.alkanes.AlkaneIdToOutpointResponse.deserializeBinary(t);
    return {
        outpoint: {
            txid: We.from(r.txid).toString("hex"),
            vout: r.vout
        }
    };
}
Object.defineProperty(ka, "__esModule", {
    value: !0
});
ka.encodeProtorunesWalletInput = Fne;
ka.encodeTransactionId = zne;
ka.encodeWalletInput = jne;
ka.decodeTransactionResult = Hne;
ka.decodeWalletOutput = qne;
ka.encodeRuntimeInput = Kne;
ka.decodeRuntimeOutput = Wne;
const pN = mo, Pne = Lf, Nne = mo, hp = h0, Mne = Jr, { ProtorunesWalletRequest: Rne, TransactionRecord: Cne, WalletRequest: Une, WalletResponse: $ne, RuntimeInput: Lne, Runtime: Dne, Outpoint: f2e } = Pne.protorune;
function gN(e) {
    return (0, Mne.toUint128)(e);
}
function Fne(e, t) {
    const r = {
        wallet: Uint8Array.from(We.from(e, "utf-8")),
        protocol_tag: gN(t)
    };
    return "0x" + We.from(new Rne(r).serializeBinary()).toString("hex");
}
function zne(e) {
    return We.from((0, hp.stripHexPrefix)(e), "hex");
}
function jne(e) {
    const t = {
        wallet: Uint8Array.from(We.from(e, "utf-8"))
    };
    return "0x" + We.from(new Une(t).serializeBinary()).toString("hex");
}
function Hne(e) {
    const { transaction: t, height: r } = Cne.deserializeBinary(Uint8Array.from(We.from((0, hp.stripHexPrefix)(e), "hex")));
    return {
        transaction: (0, hp.addHexPrefix)(We.from(t).toString("hex")),
        height: Number(r)
    };
}
function qne(e) {
    const t = $ne.deserializeBinary(Uint8Array.from(We.from((0, hp.stripHexPrefix)(e), "hex")));
    return {
        outpoints: t.outpoints.map((r)=>(0, Nne.decodeOutpointViewBase)(r)),
        balanceSheet: (0, pN.decodeRunes)(t.balances)
    };
}
function Kne(e) {
    const t = {
        protocolTag: gN(e)
    };
    return "0x" + We.from(new Lne(t).serializeBinary()).toString("hex");
}
function Wne(e) {
    const t = Dne.deserializeBinary(Uint8Array.from(We.from((0, hp.stripHexPrefix)(e), "hex")));
    return {
        balances: (0, pN.decodeRunes)(t.balances)
    };
}
var Bn = {};
Object.defineProperty(Bn, "__esModule", {
    value: !0
});
Bn.formatKey = mN;
Bn.toAlkaneTransfer = e1;
Bn.toBytecodeRequest = bN;
Bn.encodeBlockRequest = Gne;
Bn.encodeGetBytecodeRequest = Zne;
Bn.fromCallType = wN;
Bn.toAlkaneId = pp;
Bn.toStorageSlot = sS;
Bn.toContext = vN;
Bn.toResponse = _N;
Bn.toEvent = aS;
Bn.encodeTraceRequest = Yne;
Bn.encodeTraceBlockRequest = Xne;
Bn.decodeBlockResponse = Jne;
Bn.decodeTraceBlockResponse = Qne;
Bn.decodeTraceResponse = eie;
Bn.encodeSimulateRequest = tie;
Bn.decodeSimulateResponse = rie;
Bn.outpointResponseToObject = EN;
Bn.decodeOutpointResponse = nie;
Bn.decodeMetaResponse = iie;
const Cs = Jr, ba = Nd, mu = h0, yN = Lf, { SimulateResponse: l2e, MessageContextParcel: d2e, AlkanesTrace: h2e } = ba.alkanes, Vne = 47;
function mN(e) {
    return Array.from(e).reduce((t, r)=>r === Vne ? (t.push([]), t) : (t[t.length - 1].push(r), t), [
        []
    ]).map((t)=>{
        const r = We.from(t).toString("utf8");
        return /^\w+$/.test(r) ? r : We.from(t).toString("hex");
    }).join("/");
}
function e1(e) {
    return {
        id: pp(e.id),
        value: (0, Cs.fromUint128)(e.value)
    };
}
function bN({ block: e, tx: t }) {
    return new ba.alkanes.BytecodeRequest({
        id: new ba.alkanes.AlkaneId({
            block: (0, Cs.toUint128)(e),
            tx: (0, Cs.toUint128)(t)
        })
    });
}
function Gne({ height: e }) {
    return new ba.alkanes.BlockRequest({
        height: e
    });
}
function Zne(e) {
    const t = bN(e);
    return (0, mu.addHexPrefix)(We.from(t.serializeBinary()).toString("hex"));
}
function wN(e) {
    switch(e){
        case 1:
            return "call";
        case 2:
            return "delegatecall";
        case 3:
            return "staticcall";
        default:
            return "unknowncall";
    }
}
function pp(e) {
    return {
        block: typeof e.block == "bigint" ? e.block : (0, Cs.fromUint128)(e.block),
        tx: typeof e.tx == "bigint" ? e.tx : (0, Cs.fromUint128)(e.tx)
    };
}
function sS(e) {
    return {
        key: mN(e.key),
        value: "0x" + We.from(e.value).toString("hex")
    };
}
function vN(e) {
    return {
        myself: pp(e.myself),
        caller: pp(e.caller),
        inputs: e.inputs.map((t)=>(0, Cs.fromUint128)(t)),
        incomingAlkanes: e.incoming_alkanes.map((t)=>e1(t)),
        vout: e.vout
    };
}
function _N(e) {
    return {
        alkanes: e.alkanes.map((t)=>e1(t)),
        data: "0x" + We.from(e.data).toString("hex"),
        storage: e.storage.map((t)=>sS(t))
    };
}
function aS(e) {
    let t = Object.keys(e)[0];
    switch(t){
        case "create_alkane":
            return {
                event: "create",
                data: pp(e[t].new_alkane)
            };
        case "enter_context":
            return {
                event: "invoke",
                data: {
                    type: wN(e[t].call_type),
                    context: vN(e[t].context.inner),
                    fuel: e[t].context.fuel
                }
            };
        case "exit_context":
            return {
                event: "return",
                data: {
                    status: e[t].status == 0 ? "success" : "revert",
                    response: _N(e[t].response)
                }
            };
    }
}
function Yne({ txid: e, vout: t }) {
    const r = {
        txid: We.from((0, mu.stripHexPrefix)(e), "hex"),
        vout: t
    };
    return "0x" + We.from(new yN.protorune.Outpoint(r).serializeBinary()).toString("hex");
}
function Xne({ block: e }) {
    const t = {
        block: Number(e)
    };
    return "0x" + We.from(new ba.alkanes.TraceBlockRequest(t).serializeBinary()).toString("hex");
}
function Jne(e) {
    return (0, mu.addHexPrefix)(We.from(ba.alkanes.BlockResponse.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex")).block).toString("hex"));
}
function Qne(e) {
    return ba.alkanes.TraceBlockResponse.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex")).traces.map(({ outpoint: t, trace: r })=>({
            outpoint: {
                txid: We.from(t.txid).toString("hex"),
                vout: t.vout
            },
            trace: r.events.map((n)=>aS(n))
        }));
}
function eie(e) {
    return ba.alkanes.AlkanesTrace.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex")).toObject().events.map((r)=>aS(r));
}
function tie({ alkanes: e, transaction: t, height: r, block: n, inputs: i, target: o, txindex: s, vout: a, pointer: u, refundPointer: f }) {
    const c = {
        alkanes: e.map((l)=>(0, Cs.toProtobufAlkaneTransfer)(l)),
        transaction: Uint8Array.from(We.from(t, "hex")),
        height: Number(r),
        txindex: s,
        calldata: (0, Cs.encipher)([
            o.block,
            o.tx,
            ...i
        ]),
        block: Uint8Array.from(We.from(n, "hex")),
        vout: a,
        pointer: u,
        refund_pointer: f
    };
    return "0x" + We.from(new ba.alkanes.MessageContextParcel(c).serializeBinary()).toString("hex");
}
class dm {
    constructor(){}
}
dm.SUCCESS = 0;
dm.REVERT = 1;
function rie(e) {
    const t = ba.alkanes.SimulateResponse.deserializeBinary(We.from((0, mu.stripHexPrefix)(e), "hex"));
    return t.error || !t.execution ? {
        status: dm.REVERT,
        gasUsed: 0,
        execution: {
            alkanes: [],
            storage: [],
            data: "0x",
            error: t.error
        }
    } : {
        status: dm.SUCCESS,
        gasUsed: t.gas_used,
        execution: {
            alkanes: t.execution.alkanes.map(e1),
            storage: t.execution.storage.map(sS),
            error: null,
            data: "0x" + We.from(t.execution.data).toString("hex")
        }
    };
}
function EN(e) {
    return e.map((t)=>({
            token: {
                id: {
                    block: (0, Cs.fromUint128)(t.rune.runeId.height),
                    tx: (0, Cs.fromUint128)(t.rune.runeId.txindex)
                },
                name: t.rune.name,
                symbol: t.rune.symbol
            },
            value: (0, Cs.fromUint128)(t.balance)
        }));
}
function nie(e) {
    return EN(((yN.protorune.OutpointResponse.deserializeBinary(We.from(e.substr(2), "hex")).toObject() || {}).balances || {}).entries || []);
}
function iie(e) {
    if (!e || e === "0x") return null;
    const t = We.from((0, mu.stripHexPrefix)(e), "hex");
    try {
        return JSON.parse(t.toString("utf8"));
    } catch (r) {
        return console.error("Failed to parse meta response as JSON:", r), null;
    }
}
var t1 = {}, Md = {}, hm = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */ hm.exports;
(function(e, t) {
    (function(r) {
        var n = t && !t.nodeType && t, i = e && !e.nodeType && e, o = typeof Ge == "object" && Ge;
        (o.global === o || o.window === o || o.self === o) && (r = o);
        var s, a = 2147483647, u = 36, f = 1, c = 26, l = 38, p = 700, y = 72, _ = 128, A = "-", O = /^xn--/, N = /[^\x20-\x7E]/, U = /[\x2E\u3002\uFF0E\uFF61]/g, D = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, H = u - f, K = Math.floor, re = String.fromCharCode, Q;
        function G(k) {
            throw new RangeError(D[k]);
        }
        function R(k, L) {
            for(var j = k.length, ie = []; j--;)ie[j] = L(k[j]);
            return ie;
        }
        function X(k, L) {
            var j = k.split("@"), ie = "";
            j.length > 1 && (ie = j[0] + "@", k = j[1]), k = k.replace(U, ".");
            var ue = k.split("."), ce = R(ue, L).join(".");
            return ie + ce;
        }
        function $(k) {
            for(var L = [], j = 0, ie = k.length, ue, ce; j < ie;)ue = k.charCodeAt(j++), ue >= 55296 && ue <= 56319 && j < ie ? (ce = k.charCodeAt(j++), (ce & 64512) == 56320 ? L.push(((ue & 1023) << 10) + (ce & 1023) + 65536) : (L.push(ue), j--)) : L.push(ue);
            return L;
        }
        function S(k) {
            return R(k, function(L) {
                var j = "";
                return L > 65535 && (L -= 65536, j += re(L >>> 10 & 1023 | 55296), L = 56320 | L & 1023), j += re(L), j;
            }).join("");
        }
        function w(k) {
            return k - 48 < 10 ? k - 22 : k - 65 < 26 ? k - 65 : k - 97 < 26 ? k - 97 : u;
        }
        function g(k, L) {
            return k + 22 + 75 * (k < 26) - ((L != 0) << 5);
        }
        function m(k, L, j) {
            var ie = 0;
            for(k = j ? K(k / p) : k >> 1, k += K(k / L); k > H * c >> 1; ie += u)k = K(k / H);
            return K(ie + (H + 1) * k / (k + l));
        }
        function E(k) {
            var L = [], j = k.length, ie, ue = 0, ce = _, he = y, ee, ae, ye, Se, De, Re, Ce, M, z;
            for(ee = k.lastIndexOf(A), ee < 0 && (ee = 0), ae = 0; ae < ee; ++ae)k.charCodeAt(ae) >= 128 && G("not-basic"), L.push(k.charCodeAt(ae));
            for(ye = ee > 0 ? ee + 1 : 0; ye < j;){
                for(Se = ue, De = 1, Re = u; ye >= j && G("invalid-input"), Ce = w(k.charCodeAt(ye++)), (Ce >= u || Ce > K((a - ue) / De)) && G("overflow"), ue += Ce * De, M = Re <= he ? f : Re >= he + c ? c : Re - he, !(Ce < M); Re += u)z = u - M, De > K(a / z) && G("overflow"), De *= z;
                ie = L.length + 1, he = m(ue - Se, ie, Se == 0), K(ue / ie) > a - ce && G("overflow"), ce += K(ue / ie), ue %= ie, L.splice(ue++, 0, ce);
            }
            return S(L);
        }
        function T(k) {
            var L, j, ie, ue, ce, he, ee, ae, ye, Se, De, Re = [], Ce, M, z, de;
            for(k = $(k), Ce = k.length, L = _, j = 0, ce = y, he = 0; he < Ce; ++he)De = k[he], De < 128 && Re.push(re(De));
            for(ie = ue = Re.length, ue && Re.push(A); ie < Ce;){
                for(ee = a, he = 0; he < Ce; ++he)De = k[he], De >= L && De < ee && (ee = De);
                for(M = ie + 1, ee - L > K((a - j) / M) && G("overflow"), j += (ee - L) * M, L = ee, he = 0; he < Ce; ++he)if (De = k[he], De < L && ++j > a && G("overflow"), De == L) {
                    for(ae = j, ye = u; Se = ye <= ce ? f : ye >= ce + c ? c : ye - ce, !(ae < Se); ye += u)de = ae - Se, z = u - Se, Re.push(re(g(Se + de % z, 0))), ae = K(de / z);
                    Re.push(re(g(ae, 0))), ce = m(j, M, ie == ue), j = 0, ++ie;
                }
                ++j, ++L;
            }
            return Re.join("");
        }
        function I(k) {
            return X(k, function(L) {
                return O.test(L) ? E(L.slice(4).toLowerCase()) : L;
            });
        }
        function P(k) {
            return X(k, function(L) {
                return N.test(L) ? "xn--" + T(L) : L;
            });
        }
        if (s = {
            /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */ version: "1.4.1",
            /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */ ucs2: {
                decode: $,
                encode: S
            },
            decode: E,
            encode: T,
            toASCII: P,
            toUnicode: I
        }, n && i) if (e.exports == n) i.exports = s;
        else for(Q in s)s.hasOwnProperty(Q) && (n[Q] = s[Q]);
        else r.punycode = s;
    })(Ge);
})(hm, hm.exports);
var oie = hm.exports, Rd = TypeError, cS = typeof Map == "function" && Map.prototype, E_ = Object.getOwnPropertyDescriptor && cS ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, pm = cS && E_ && typeof E_.get == "function" ? E_.get : null, $k = cS && Map.prototype.forEach, uS = typeof Set == "function" && Set.prototype, x_ = Object.getOwnPropertyDescriptor && uS ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, gm = uS && x_ && typeof x_.get == "function" ? x_.get : null, Lk = uS && Set.prototype.forEach, sie = typeof WeakMap == "function" && WeakMap.prototype, Fh = sie ? WeakMap.prototype.has : null, aie = typeof WeakSet == "function" && WeakSet.prototype, zh = aie ? WeakSet.prototype.has : null, cie = typeof WeakRef == "function" && WeakRef.prototype, Dk = cie ? WeakRef.prototype.deref : null, uie = Boolean.prototype.valueOf, fie = Object.prototype.toString, lie = Function.prototype.toString, die = String.prototype.match, fS = String.prototype.slice, uu = String.prototype.replace, hie = String.prototype.toUpperCase, Fk = String.prototype.toLowerCase, xN = RegExp.prototype.test, zk = Array.prototype.concat, da = Array.prototype.join, pie = Array.prototype.slice, jk = Math.floor, rx = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, S_ = Object.getOwnPropertySymbols, nx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, od = typeof Symbol == "function" && typeof Symbol.iterator == "object", jh = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === od || !0) ? Symbol.toStringTag : null, SN = Object.prototype.propertyIsEnumerable, Hk = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
    return e.__proto__;
} : null);
function qk(e, t) {
    if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || xN.call(/e/, t)) return t;
    var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof e == "number") {
        var n = e < 0 ? -jk(-e) : jk(e);
        if (n !== e) {
            var i = String(n), o = fS.call(t, i.length + 1);
            return uu.call(i, r, "$&_") + "." + uu.call(uu.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
    }
    return uu.call(t, r, "$&_");
}
var ix = Iu, Kk = ix.custom, Wk = kN(Kk) ? Kk : null, AN = {
    __proto__: null,
    double: '"',
    single: "'"
}, gie = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
}, r1 = function e(t, r, n, i) {
    var o = r || {};
    if (Xa(o, "quoteStyle") && !Xa(AN, o.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Xa(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var s = Xa(o, "customInspect") ? o.customInspect : !0;
    if (typeof s != "boolean" && s !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Xa(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Xa(o, "numericSeparator") && typeof o.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var a = o.numericSeparator;
    if (typeof t > "u") return "undefined";
    if (t === null) return "null";
    if (typeof t == "boolean") return t ? "true" : "false";
    if (typeof t == "string") return BN(t, o);
    if (typeof t == "number") {
        if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
        var u = String(t);
        return a ? qk(t, u) : u;
    }
    if (typeof t == "bigint") {
        var f = String(t) + "n";
        return a ? qk(t, f) : f;
    }
    var c = typeof o.depth > "u" ? 5 : o.depth;
    if (typeof n > "u" && (n = 0), n >= c && c > 0 && typeof t == "object") return ox(t) ? "[Array]" : "[Object]";
    var l = Mie(o, n);
    if (typeof i > "u") i = [];
    else if (IN(i, t) >= 0) return "[Circular]";
    function p(w, g, m) {
        if (g && (i = pie.call(i), i.push(g)), m) {
            var E = {
                depth: o.depth
            };
            return Xa(o, "quoteStyle") && (E.quoteStyle = o.quoteStyle), e(w, E, n + 1, i);
        }
        return e(w, o, n + 1, i);
    }
    if (typeof t == "function" && !Vk(t)) {
        var y = Sie(t), _ = Xg(t, p);
        return "[Function" + (y ? ": " + y : " (anonymous)") + "]" + (_.length > 0 ? " { " + da.call(_, ", ") + " }" : "");
    }
    if (kN(t)) {
        var A = od ? uu.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : nx.call(t);
        return typeof t == "object" && !od ? ph(A) : A;
    }
    if (Oie(t)) {
        for(var O = "<" + Fk.call(String(t.nodeName)), N = t.attributes || [], U = 0; U < N.length; U++)O += " " + N[U].name + "=" + TN(yie(N[U].value), "double", o);
        return O += ">", t.childNodes && t.childNodes.length && (O += "..."), O += "</" + Fk.call(String(t.nodeName)) + ">", O;
    }
    if (ox(t)) {
        if (t.length === 0) return "[]";
        var D = Xg(t, p);
        return l && !Nie(D) ? "[" + sx(D, l) + "]" : "[ " + da.call(D, ", ") + " ]";
    }
    if (bie(t)) {
        var H = Xg(t, p);
        return !("cause" in Error.prototype) && "cause" in t && !SN.call(t, "cause") ? "{ [" + String(t) + "] " + da.call(zk.call("[cause]: " + p(t.cause), H), ", ") + " }" : H.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + da.call(H, ", ") + " }";
    }
    if (typeof t == "object" && s) {
        if (Wk && typeof t[Wk] == "function" && ix) return ix(t, {
            depth: c - n
        });
        if (s !== "symbol" && typeof t.inspect == "function") return t.inspect();
    }
    if (Aie(t)) {
        var K = [];
        return $k && $k.call(t, function(w, g) {
            K.push(p(g, t, !0) + " => " + p(w, t));
        }), Gk("Map", pm.call(t), K, l);
    }
    if (Iie(t)) {
        var re = [];
        return Lk && Lk.call(t, function(w) {
            re.push(p(w, t));
        }), Gk("Set", gm.call(t), re, l);
    }
    if (Tie(t)) return A_("WeakMap");
    if (Bie(t)) return A_("WeakSet");
    if (kie(t)) return A_("WeakRef");
    if (vie(t)) return ph(p(Number(t)));
    if (Eie(t)) return ph(p(rx.call(t)));
    if (_ie(t)) return ph(uie.call(t));
    if (wie(t)) return ph(p(String(t)));
    if (("TURBOPACK compile-time value", "undefined") < "u" && t === window) return "{ [object Window] }";
    if (typeof globalThis < "u" && t === globalThis || typeof Ge < "u" && t === Ge) return "{ [object globalThis] }";
    if (!mie(t) && !Vk(t)) {
        var Q = Xg(t, p), G = Hk ? Hk(t) === Object.prototype : t instanceof Object || t.constructor === Object, R = t instanceof Object ? "" : "null prototype", X = !G && jh && Object(t) === t && jh in t ? fS.call(Pu(t), 8, -1) : R ? "Object" : "", $ = G || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", S = $ + (X || R ? "[" + da.call(zk.call([], X || [], R || []), ": ") + "] " : "");
        return Q.length === 0 ? S + "{}" : l ? S + "{" + sx(Q, l) + "}" : S + "{ " + da.call(Q, ", ") + " }";
    }
    return String(t);
};
function TN(e, t, r) {
    var n = r.quoteStyle || t, i = AN[n];
    return i + e + i;
}
function yie(e) {
    return uu.call(String(e), /"/g, "&quot;");
}
function Df(e) {
    return !jh || !(typeof e == "object" && (jh in e || typeof e[jh] < "u"));
}
function ox(e) {
    return Pu(e) === "[object Array]" && Df(e);
}
function mie(e) {
    return Pu(e) === "[object Date]" && Df(e);
}
function Vk(e) {
    return Pu(e) === "[object RegExp]" && Df(e);
}
function bie(e) {
    return Pu(e) === "[object Error]" && Df(e);
}
function wie(e) {
    return Pu(e) === "[object String]" && Df(e);
}
function vie(e) {
    return Pu(e) === "[object Number]" && Df(e);
}
function _ie(e) {
    return Pu(e) === "[object Boolean]" && Df(e);
}
function kN(e) {
    if (od) return e && typeof e == "object" && e instanceof Symbol;
    if (typeof e == "symbol") return !0;
    if (!e || typeof e != "object" || !nx) return !1;
    try {
        return nx.call(e), !0;
    } catch  {}
    return !1;
}
function Eie(e) {
    if (!e || typeof e != "object" || !rx) return !1;
    try {
        return rx.call(e), !0;
    } catch  {}
    return !1;
}
var xie = Object.prototype.hasOwnProperty || function(e) {
    return e in this;
};
function Xa(e, t) {
    return xie.call(e, t);
}
function Pu(e) {
    return fie.call(e);
}
function Sie(e) {
    if (e.name) return e.name;
    var t = die.call(lie.call(e), /^function\s*([\w$]+)/);
    return t ? t[1] : null;
}
function IN(e, t) {
    if (e.indexOf) return e.indexOf(t);
    for(var r = 0, n = e.length; r < n; r++)if (e[r] === t) return r;
    return -1;
}
function Aie(e) {
    if (!pm || !e || typeof e != "object") return !1;
    try {
        pm.call(e);
        try {
            gm.call(e);
        } catch  {
            return !0;
        }
        return e instanceof Map;
    } catch  {}
    return !1;
}
function Tie(e) {
    if (!Fh || !e || typeof e != "object") return !1;
    try {
        Fh.call(e, Fh);
        try {
            zh.call(e, zh);
        } catch  {
            return !0;
        }
        return e instanceof WeakMap;
    } catch  {}
    return !1;
}
function kie(e) {
    if (!Dk || !e || typeof e != "object") return !1;
    try {
        return Dk.call(e), !0;
    } catch  {}
    return !1;
}
function Iie(e) {
    if (!gm || !e || typeof e != "object") return !1;
    try {
        gm.call(e);
        try {
            pm.call(e);
        } catch  {
            return !0;
        }
        return e instanceof Set;
    } catch  {}
    return !1;
}
function Bie(e) {
    if (!zh || !e || typeof e != "object") return !1;
    try {
        zh.call(e, zh);
        try {
            Fh.call(e, Fh);
        } catch  {
            return !0;
        }
        return e instanceof WeakSet;
    } catch  {}
    return !1;
}
function Oie(e) {
    return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function BN(e, t) {
    if (e.length > t.maxStringLength) {
        var r = e.length - t.maxStringLength, n = "... " + r + " more character" + (r > 1 ? "s" : "");
        return BN(fS.call(e, 0, t.maxStringLength), t) + n;
    }
    var i = gie[t.quoteStyle || "single"];
    i.lastIndex = 0;
    var o = uu.call(uu.call(e, i, "\\$1"), /[\x00-\x1f]/g, Pie);
    return TN(o, "single", t);
}
function Pie(e) {
    var t = e.charCodeAt(0), r = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + hie.call(t.toString(16));
}
function ph(e) {
    return "Object(" + e + ")";
}
function A_(e) {
    return e + " { ? }";
}
function Gk(e, t, r, n) {
    var i = n ? sx(r, n) : da.call(r, ", ");
    return e + " (" + t + ") {" + i + "}";
}
function Nie(e) {
    for(var t = 0; t < e.length; t++)if (IN(e[t], `
`) >= 0) return !1;
    return !0;
}
function Mie(e, t) {
    var r;
    if (e.indent === "	") r = "	";
    else if (typeof e.indent == "number" && e.indent > 0) r = da.call(Array(e.indent + 1), " ");
    else return null;
    return {
        base: r,
        prev: da.call(Array(t + 1), r)
    };
}
function sx(e, t) {
    if (e.length === 0) return "";
    var r = `
` + t.prev + t.base;
    return r + da.call(e, "," + r) + `
` + t.prev;
}
function Xg(e, t) {
    var r = ox(e), n = [];
    if (r) {
        n.length = e.length;
        for(var i = 0; i < e.length; i++)n[i] = Xa(e, i) ? t(e[i], e) : "";
    }
    var o = typeof S_ == "function" ? S_(e) : [], s;
    if (od) {
        s = {};
        for(var a = 0; a < o.length; a++)s["$" + o[a]] = o[a];
    }
    for(var u in e)Xa(e, u) && (r && String(Number(u)) === u && u < e.length || od && s["$" + u] instanceof Symbol || (xN.call(/[^\w$]/, u) ? n.push(t(u, e) + ": " + t(e[u], e)) : n.push(u + ": " + t(e[u], e))));
    if (typeof S_ == "function") for(var f = 0; f < o.length; f++)SN.call(e, o[f]) && n.push("[" + t(o[f]) + "]: " + t(e[o[f]], e));
    return n;
}
var Rie = r1, Cie = Rd, n1 = function(e, t, r) {
    for(var n = e, i; (i = n.next) != null; n = i)if (i.key === t) return n.next = i.next, r || (i.next = /** @type {NonNullable<typeof list.next>} */ e.next, e.next = i), i;
}, Uie = function(e, t) {
    if (e) {
        var r = n1(e, t);
        return r && r.value;
    }
}, $ie = function(e, t, r) {
    var n = n1(e, t);
    n ? n.value = r : e.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: t,
        next: e.next,
        value: r
    };
}, Lie = function(e, t) {
    return e ? !!n1(e, t) : !1;
}, Die = function(e, t) {
    if (e) return n1(e, t, !0);
}, Fie = function() {
    var t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new Cie("Side channel does not contain " + Rie(n));
        },
        delete: function(n) {
            var i = t && t.next, o = Die(t, n);
            return o && i && i === o && (t = void 0), !!o;
        },
        get: function(n) {
            return Uie(t, n);
        },
        has: function(n) {
            return Lie(t, n);
        },
        set: function(n, i) {
            t || (t = {
                next: void 0
            }), $ie(/** @type {NonNullable<typeof $o>} */ t, n, i);
        }
    };
    return r;
}, ON = Object, zie = Error, jie = EvalError, Hie = RangeError, qie = ReferenceError, Kie = SyntaxError, Wie = URIError, Vie = Math.abs, Gie = Math.floor, Zie = Math.max, Yie = Math.min, Xie = Math.pow, Jie = Math.round, Qie = Number.isNaN || function(t) {
    return t !== t;
}, eoe = Qie, toe = function(t) {
    return eoe(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, roe = Object.getOwnPropertyDescriptor, Ry = roe;
if (Ry) try {
    Ry([], "length");
} catch  {
    Ry = null;
}
var PN = Ry, Cy = Object.defineProperty || !1;
if (Cy) try {
    Cy({}, "a", {
        value: 1
    });
} catch  {
    Cy = !1;
}
var noe = Cy, T_, Zk;
function ioe() {
    return Zk || (Zk = 1, T_ = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var t = {}, r = Symbol("test"), n = Object(r);
        if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]") return !1;
        var i = 42;
        t[r] = i;
        for(var o in t)return !1;
        if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(t);
        if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var a = /** @type {PropertyDescriptor} */ Object.getOwnPropertyDescriptor(t, r);
            if (a.value !== i || a.enumerable !== !0) return !1;
        }
        return !0;
    }), T_;
}
var k_, Yk;
function ooe() {
    if (Yk) return k_;
    Yk = 1;
    var e = typeof Symbol < "u" && Symbol, t = ioe();
    return k_ = function() {
        return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
    }, k_;
}
var I_, Xk;
function NN() {
    return Xk || (Xk = 1, I_ = typeof Reflect < "u" && Reflect.getPrototypeOf || null), I_;
}
var B_, Jk;
function MN() {
    if (Jk) return B_;
    Jk = 1;
    var e = ON;
    return B_ = e.getPrototypeOf || null, B_;
}
var soe = "Function.prototype.bind called on incompatible ", aoe = Object.prototype.toString, coe = Math.max, uoe = "[object Function]", Qk = function(t, r) {
    for(var n = [], i = 0; i < t.length; i += 1)n[i] = t[i];
    for(var o = 0; o < r.length; o += 1)n[o + t.length] = r[o];
    return n;
}, foe = function(t, r) {
    for(var n = [], i = r, o = 0; i < t.length; i += 1, o += 1)n[o] = t[i];
    return n;
}, loe = function(e, t) {
    for(var r = "", n = 0; n < e.length; n += 1)r += e[n], n + 1 < e.length && (r += t);
    return r;
}, doe = function(t) {
    var r = this;
    if (typeof r != "function" || aoe.apply(r) !== uoe) throw new TypeError(soe + r);
    for(var n = foe(arguments, 1), i, o = function() {
        if (this instanceof i) {
            var c = r.apply(this, Qk(n, arguments));
            return Object(c) === c ? c : this;
        }
        return r.apply(t, Qk(n, arguments));
    }, s = coe(0, r.length - n.length), a = [], u = 0; u < s; u++)a[u] = "$" + u;
    if (i = Function("binder", "return function (" + loe(a, ",") + "){ return binder.apply(this,arguments); }")(o), r.prototype) {
        var f = function() {};
        f.prototype = r.prototype, i.prototype = new f(), f.prototype = null;
    }
    return i;
}, hoe = doe, i1 = Function.prototype.bind || hoe, lS = Function.prototype.call, O_, eI;
function RN() {
    return eI || (eI = 1, O_ = Function.prototype.apply), O_;
}
var poe = typeof Reflect < "u" && Reflect && Reflect.apply, goe = i1, yoe = RN(), moe = lS, boe = poe, woe = boe || goe.call(moe, yoe), voe = i1, _oe = Rd, Eoe = lS, xoe = woe, CN = function(t) {
    if (t.length < 1 || typeof t[0] != "function") throw new _oe("a function is required");
    return xoe(voe, Eoe, t);
}, P_, tI;
function Soe() {
    if (tI) return P_;
    tI = 1;
    var e = CN, t = PN, r;
    try {
        r = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
    } catch (s) {
        if (!s || typeof s != "object" || !("code" in s) || s.code !== "ERR_PROTO_ACCESS") throw s;
    }
    var n = !!r && t && t(Object.prototype, /** @type {keyof typeof Object.prototype} */ "__proto__"), i = Object, o = i.getPrototypeOf;
    return P_ = n && typeof n.get == "function" ? e([
        n.get
    ]) : typeof o == "function" ? /** @type {import('./get')} */ function(a) {
        return o(a == null ? a : i(a));
    } : !1, P_;
}
var N_, rI;
function Aoe() {
    if (rI) return N_;
    rI = 1;
    var e = NN(), t = MN(), r = Soe();
    return N_ = e ? function(i) {
        return e(i);
    } : t ? function(i) {
        if (!i || typeof i != "object" && typeof i != "function") throw new TypeError("getProto: not an object");
        return t(i);
    } : r ? function(i) {
        return r(i);
    } : null, N_;
}
var M_, nI;
function Toe() {
    if (nI) return M_;
    nI = 1;
    var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = i1;
    return M_ = r.call(e, t), M_;
}
var Mr, koe = ON, Ioe = zie, Boe = jie, Ooe = Hie, Poe = qie, sd = Kie, Vl = Rd, Noe = Wie, Moe = Vie, Roe = Gie, Coe = Zie, Uoe = Yie, $oe = Xie, Loe = Jie, Doe = toe, UN = Function, R_ = function(e) {
    try {
        return UN('"use strict"; return (' + e + ").constructor;")();
    } catch  {}
}, gp = PN, Foe = noe, C_ = function() {
    throw new Vl();
}, zoe = gp ? function() {
    try {
        return arguments.callee, C_;
    } catch  {
        try {
            return gp(arguments, "callee").get;
        } catch  {
            return C_;
        }
    }
}() : C_, pl = ooe()(), ni = Aoe(), joe = MN(), Hoe = NN(), $N = RN(), p0 = lS, Sl = {}, qoe = typeof Uint8Array > "u" || !ni ? Mr : ni(Uint8Array), gf = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Mr : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Mr : ArrayBuffer,
    "%ArrayIteratorPrototype%": pl && ni ? ni([][Symbol.iterator]()) : Mr,
    "%AsyncFromSyncIteratorPrototype%": Mr,
    "%AsyncFunction%": Sl,
    "%AsyncGenerator%": Sl,
    "%AsyncGeneratorFunction%": Sl,
    "%AsyncIteratorPrototype%": Sl,
    "%Atomics%": typeof Atomics > "u" ? Mr : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Mr : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Mr : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Mr : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Mr : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Ioe,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": Boe,
    "%Float16Array%": typeof Float16Array > "u" ? Mr : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? Mr : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Mr : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Mr : FinalizationRegistry,
    "%Function%": UN,
    "%GeneratorFunction%": Sl,
    "%Int8Array%": typeof Int8Array > "u" ? Mr : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Mr : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Mr : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": pl && ni ? ni(ni([][Symbol.iterator]())) : Mr,
    "%JSON%": typeof JSON == "object" ? JSON : Mr,
    "%Map%": typeof Map > "u" ? Mr : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !pl || !ni ? Mr : ni(/* @__PURE__ */ new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": koe,
    "%Object.getOwnPropertyDescriptor%": gp,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Mr : Promise,
    "%Proxy%": typeof Proxy > "u" ? Mr : Proxy,
    "%RangeError%": Ooe,
    "%ReferenceError%": Poe,
    "%Reflect%": typeof Reflect > "u" ? Mr : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Mr : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !pl || !ni ? Mr : ni(/* @__PURE__ */ new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Mr : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": pl && ni ? ni(""[Symbol.iterator]()) : Mr,
    "%Symbol%": pl ? Symbol : Mr,
    "%SyntaxError%": sd,
    "%ThrowTypeError%": zoe,
    "%TypedArray%": qoe,
    "%TypeError%": Vl,
    "%Uint8Array%": typeof Uint8Array > "u" ? Mr : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Mr : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Mr : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Mr : Uint32Array,
    "%URIError%": Noe,
    "%WeakMap%": typeof WeakMap > "u" ? Mr : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Mr : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Mr : WeakSet,
    "%Function.prototype.call%": p0,
    "%Function.prototype.apply%": $N,
    "%Object.defineProperty%": Foe,
    "%Object.getPrototypeOf%": joe,
    "%Math.abs%": Moe,
    "%Math.floor%": Roe,
    "%Math.max%": Coe,
    "%Math.min%": Uoe,
    "%Math.pow%": $oe,
    "%Math.round%": Loe,
    "%Math.sign%": Doe,
    "%Reflect.getPrototypeOf%": Hoe
};
if (ni) try {
    null.error;
} catch (e) {
    var Koe = ni(ni(e));
    gf["%Error.prototype%"] = Koe;
}
var Woe = function e(t) {
    var r;
    if (t === "%AsyncFunction%") r = R_("async function () {}");
    else if (t === "%GeneratorFunction%") r = R_("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") r = R_("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var n = e("%AsyncGeneratorFunction%");
        n && (r = n.prototype);
    } else if (t === "%AsyncIteratorPrototype%") {
        var i = e("%AsyncGenerator%");
        i && ni && (r = ni(i.prototype));
    }
    return gf[t] = r, r;
}, iI = {
    __proto__: null,
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
}, g0 = i1, ym = Toe(), Voe = g0.call(p0, Array.prototype.concat), Goe = g0.call($N, Array.prototype.splice), oI = g0.call(p0, String.prototype.replace), mm = g0.call(p0, String.prototype.slice), Zoe = g0.call(p0, RegExp.prototype.exec), Yoe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Xoe = /\\(\\)?/g, Joe = function(t) {
    var r = mm(t, 0, 1), n = mm(t, -1);
    if (r === "%" && n !== "%") throw new sd("invalid intrinsic syntax, expected closing `%`");
    if (n === "%" && r !== "%") throw new sd("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return oI(t, Yoe, function(o, s, a, u) {
        i[i.length] = a ? oI(u, Xoe, "$1") : s || o;
    }), i;
}, Qoe = function(t, r) {
    var n = t, i;
    if (ym(iI, n) && (i = iI[n], n = "%" + i[0] + "%"), ym(gf, n)) {
        var o = gf[n];
        if (o === Sl && (o = Woe(n)), typeof o > "u" && !r) throw new Vl("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return {
            alias: i,
            name: n,
            value: o
        };
    }
    throw new sd("intrinsic " + t + " does not exist!");
}, dS = function(t, r) {
    if (typeof t != "string" || t.length === 0) throw new Vl("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r != "boolean") throw new Vl('"allowMissing" argument must be a boolean');
    if (Zoe(/^%?[^%]*%?$/, t) === null) throw new sd("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var n = Joe(t), i = n.length > 0 ? n[0] : "", o = Qoe("%" + i + "%", r), s = o.name, a = o.value, u = !1, f = o.alias;
    f && (i = f[0], Goe(n, Voe([
        0,
        1
    ], f)));
    for(var c = 1, l = !0; c < n.length; c += 1){
        var p = n[c], y = mm(p, 0, 1), _ = mm(p, -1);
        if ((y === '"' || y === "'" || y === "`" || _ === '"' || _ === "'" || _ === "`") && y !== _) throw new sd("property names with quotes must have matching quotes");
        if ((p === "constructor" || !l) && (u = !0), i += "." + p, s = "%" + i + "%", ym(gf, s)) a = gf[s];
        else if (a != null) {
            if (!(p in a)) {
                if (!r) throw new Vl("base intrinsic for " + t + " exists, but the property is not available.");
                return;
            }
            if (gp && c + 1 >= n.length) {
                var A = gp(a, p);
                l = !!A, l && "get" in A && !("originalValue" in A.get) ? a = A.get : a = a[p];
            } else l = ym(a, p), a = a[p];
            l && !u && (gf[s] = a);
        }
    }
    return a;
}, LN = dS, DN = CN, ese = DN([
    LN("%String.prototype.indexOf%")
]), FN = function(t, r) {
    var n = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ LN(t, !!r);
    return typeof n == "function" && ese(t, ".prototype.") > -1 ? DN(/** @type {const} */ [
        n
    ]) : n;
}, tse = dS, y0 = FN, rse = r1, nse = Rd, sI = tse("%Map%", !0), ise = y0("Map.prototype.get", !0), ose = y0("Map.prototype.set", !0), sse = y0("Map.prototype.has", !0), ase = y0("Map.prototype.delete", !0), cse = y0("Map.prototype.size", !0), zN = !!sI && /** @type {Exclude<import('.'), false>} */ function() {
    var t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new nse("Side channel does not contain " + rse(n));
        },
        delete: function(n) {
            if (t) {
                var i = ase(t, n);
                return cse(t) === 0 && (t = void 0), i;
            }
            return !1;
        },
        get: function(n) {
            if (t) return ise(t, n);
        },
        has: function(n) {
            return t ? sse(t, n) : !1;
        },
        set: function(n, i) {
            t || (t = new sI()), ose(t, n, i);
        }
    };
    return r;
}, use = dS, o1 = FN, fse = r1, Jg = zN, lse = Rd, gl = use("%WeakMap%", !0), dse = o1("WeakMap.prototype.get", !0), hse = o1("WeakMap.prototype.set", !0), pse = o1("WeakMap.prototype.has", !0), gse = o1("WeakMap.prototype.delete", !0), yse = gl ? /** @type {Exclude<import('.'), false>} */ function() {
    var t, r, n = {
        assert: function(i) {
            if (!n.has(i)) throw new lse("Side channel does not contain " + fse(i));
        },
        delete: function(i) {
            if (gl && i && (typeof i == "object" || typeof i == "function")) {
                if (t) return gse(t, i);
            } else if (Jg && r) return r.delete(i);
            return !1;
        },
        get: function(i) {
            return gl && i && (typeof i == "object" || typeof i == "function") && t ? dse(t, i) : r && r.get(i);
        },
        has: function(i) {
            return gl && i && (typeof i == "object" || typeof i == "function") && t ? pse(t, i) : !!r && r.has(i);
        },
        set: function(i, o) {
            gl && i && (typeof i == "object" || typeof i == "function") ? (t || (t = new gl()), hse(t, i, o)) : Jg && (r || (r = Jg()), r.set(i, o));
        }
    };
    return n;
} : Jg, mse = Rd, bse = r1, wse = Fie, vse = zN, _se = yse, Ese = _se || vse || wse, xse = function() {
    var t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new mse("Side channel does not contain " + bse(n));
        },
        delete: function(n) {
            return !!t && t.delete(n);
        },
        get: function(n) {
            return t && t.get(n);
        },
        has: function(n) {
            return !!t && t.has(n);
        },
        set: function(n, i) {
            t || (t = Ese()), t.set(n, i);
        }
    };
    return r;
}, Sse = String.prototype.replace, Ase = /%20/g, U_ = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}, hS = {
    default: U_.RFC3986,
    formatters: {
        RFC1738: function(e) {
            return Sse.call(e, Ase, "+");
        },
        RFC3986: function(e) {
            return String(e);
        }
    },
    RFC1738: U_.RFC1738,
    RFC3986: U_.RFC3986
}, Tse = hS, $_ = Object.prototype.hasOwnProperty, ef = Array.isArray, Xs = function() {
    for(var e = [], t = 0; t < 256; ++t)e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e;
}(), kse = function(t) {
    for(; t.length > 1;){
        var r = t.pop(), n = r.obj[r.prop];
        if (ef(n)) {
            for(var i = [], o = 0; o < n.length; ++o)typeof n[o] < "u" && i.push(n[o]);
            r.obj[r.prop] = i;
        }
    }
}, jN = function(t, r) {
    for(var n = r && r.plainObjects ? {
        __proto__: null
    } : {}, i = 0; i < t.length; ++i)typeof t[i] < "u" && (n[i] = t[i]);
    return n;
}, Ise = function e(t, r, n) {
    if (!r) return t;
    if (typeof r != "object" && typeof r != "function") {
        if (ef(t)) t.push(r);
        else if (t && typeof t == "object") (n && (n.plainObjects || n.allowPrototypes) || !$_.call(Object.prototype, r)) && (t[r] = !0);
        else return [
            t,
            r
        ];
        return t;
    }
    if (!t || typeof t != "object") return [
        t
    ].concat(r);
    var i = t;
    return ef(t) && !ef(r) && (i = jN(t, n)), ef(t) && ef(r) ? (r.forEach(function(o, s) {
        if ($_.call(t, s)) {
            var a = t[s];
            a && typeof a == "object" && o && typeof o == "object" ? t[s] = e(a, o, n) : t.push(o);
        } else t[s] = o;
    }), t) : Object.keys(r).reduce(function(o, s) {
        var a = r[s];
        return $_.call(o, s) ? o[s] = e(o[s], a, n) : o[s] = a, o;
    }, i);
}, Bse = function(t, r) {
    return Object.keys(r).reduce(function(n, i) {
        return n[i] = r[i], n;
    }, t);
}, Ose = function(e, t, r) {
    var n = e.replace(/\+/g, " ");
    if (r === "iso-8859-1") return n.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(n);
    } catch  {
        return n;
    }
}, L_ = 1024, Pse = function(t, r, n, i, o) {
    if (t.length === 0) return t;
    var s = t;
    if (typeof t == "symbol" ? s = Symbol.prototype.toString.call(t) : typeof t != "string" && (s = String(t)), n === "iso-8859-1") return escape(s).replace(/%u[0-9a-f]{4}/gi, function(y) {
        return "%26%23" + parseInt(y.slice(2), 16) + "%3B";
    });
    for(var a = "", u = 0; u < s.length; u += L_){
        for(var f = s.length >= L_ ? s.slice(u, u + L_) : s, c = [], l = 0; l < f.length; ++l){
            var p = f.charCodeAt(l);
            if (p === 45 || p === 46 || p === 95 || p === 126 || p >= 48 && p <= 57 || p >= 65 && p <= 90 || p >= 97 && p <= 122 || o === Tse.RFC1738 && (p === 40 || p === 41)) {
                c[c.length] = f.charAt(l);
                continue;
            }
            if (p < 128) {
                c[c.length] = Xs[p];
                continue;
            }
            if (p < 2048) {
                c[c.length] = Xs[192 | p >> 6] + Xs[128 | p & 63];
                continue;
            }
            if (p < 55296 || p >= 57344) {
                c[c.length] = Xs[224 | p >> 12] + Xs[128 | p >> 6 & 63] + Xs[128 | p & 63];
                continue;
            }
            l += 1, p = 65536 + ((p & 1023) << 10 | f.charCodeAt(l) & 1023), c[c.length] = Xs[240 | p >> 18] + Xs[128 | p >> 12 & 63] + Xs[128 | p >> 6 & 63] + Xs[128 | p & 63];
        }
        a += c.join("");
    }
    return a;
}, Nse = function(t) {
    for(var r = [
        {
            obj: {
                o: t
            },
            prop: "o"
        }
    ], n = [], i = 0; i < r.length; ++i)for(var o = r[i], s = o.obj[o.prop], a = Object.keys(s), u = 0; u < a.length; ++u){
        var f = a[u], c = s[f];
        typeof c == "object" && c !== null && n.indexOf(c) === -1 && (r.push({
            obj: s,
            prop: f
        }), n.push(c));
    }
    return kse(r), t;
}, Mse = function(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]";
}, Rse = function(t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, Cse = function(t, r) {
    return [].concat(t, r);
}, Use = function(t, r) {
    if (ef(t)) {
        for(var n = [], i = 0; i < t.length; i += 1)n.push(r(t[i]));
        return n;
    }
    return r(t);
}, HN = {
    arrayToObject: jN,
    assign: Bse,
    combine: Cse,
    compact: Nse,
    decode: Ose,
    encode: Pse,
    isBuffer: Rse,
    isRegExp: Mse,
    maybeMap: Use,
    merge: Ise
}, qN = xse, Uy = HN, Hh = hS, $se = Object.prototype.hasOwnProperty, KN = {
    brackets: function(t) {
        return t + "[]";
    },
    comma: "comma",
    indices: function(t, r) {
        return t + "[" + r + "]";
    },
    repeat: function(t) {
        return t;
    }
}, la = Array.isArray, Lse = Array.prototype.push, WN = function(e, t) {
    Lse.apply(e, la(t) ? t : [
        t
    ]);
}, Dse = Date.prototype.toISOString, aI = Hh.default, Gn = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    commaRoundTrip: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: Uy.encode,
    encodeValuesOnly: !1,
    filter: void 0,
    format: aI,
    formatter: Hh.formatters[aI],
    // deprecated
    indices: !1,
    serializeDate: function(t) {
        return Dse.call(t);
    },
    skipNulls: !1,
    strictNullHandling: !1
}, Fse = function(t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, D_ = {}, zse = function e(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U) {
    for(var D = t, H = U, K = 0, re = !1; (H = H.get(D_)) !== void 0 && !re;){
        var Q = H.get(t);
        if (K += 1, typeof Q < "u") {
            if (Q === K) throw new RangeError("Cyclic object value");
            re = !0;
        }
        typeof H.get(D_) > "u" && (K = 0);
    }
    if (typeof c == "function" ? D = c(r, D) : D instanceof Date ? D = y(D) : n === "comma" && la(D) && (D = Uy.maybeMap(D, function(k) {
        return k instanceof Date ? y(k) : k;
    })), D === null) {
        if (s) return f && !O ? f(r, Gn.encoder, N, "key", _) : r;
        D = "";
    }
    if (Fse(D) || Uy.isBuffer(D)) {
        if (f) {
            var G = O ? r : f(r, Gn.encoder, N, "key", _);
            return [
                A(G) + "=" + A(f(D, Gn.encoder, N, "value", _))
            ];
        }
        return [
            A(r) + "=" + A(String(D))
        ];
    }
    var R = [];
    if (typeof D > "u") return R;
    var X;
    if (n === "comma" && la(D)) O && f && (D = Uy.maybeMap(D, f)), X = [
        {
            value: D.length > 0 ? D.join(",") || null : void 0
        }
    ];
    else if (la(c)) X = c;
    else {
        var $ = Object.keys(D);
        X = l ? $.sort(l) : $;
    }
    var S = u ? String(r).replace(/\./g, "%2E") : String(r), w = i && la(D) && D.length === 1 ? S + "[]" : S;
    if (o && la(D) && D.length === 0) return w + "[]";
    for(var g = 0; g < X.length; ++g){
        var m = X[g], E = typeof m == "object" && m && typeof m.value < "u" ? m.value : D[m];
        if (!(a && E === null)) {
            var T = p && u ? String(m).replace(/\./g, "%2E") : String(m), I = la(D) ? typeof n == "function" ? n(w, T) : w : w + (p ? "." + T : "[" + T + "]");
            U.set(t, K);
            var P = qN();
            P.set(D_, U), WN(R, e(E, I, n, i, o, s, a, u, n === "comma" && O && la(D) ? null : f, c, l, p, y, _, A, O, N, P));
        }
    }
    return R;
}, jse = function(t) {
    if (!t) return Gn;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function") throw new TypeError("Encoder has to be a function.");
    var r = t.charset || Gn.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var n = Hh.default;
    if (typeof t.format < "u") {
        if (!$se.call(Hh.formatters, t.format)) throw new TypeError("Unknown format option provided.");
        n = t.format;
    }
    var i = Hh.formatters[n], o = Gn.filter;
    (typeof t.filter == "function" || la(t.filter)) && (o = t.filter);
    var s;
    if (t.arrayFormat in KN ? s = t.arrayFormat : "indices" in t ? s = t.indices ? "indices" : "repeat" : s = Gn.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var a = typeof t.allowDots > "u" ? t.encodeDotInKeys === !0 ? !0 : Gn.allowDots : !!t.allowDots;
    return {
        addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Gn.addQueryPrefix,
        allowDots: a,
        allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Gn.allowEmptyArrays,
        arrayFormat: s,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Gn.charsetSentinel,
        commaRoundTrip: !!t.commaRoundTrip,
        delimiter: typeof t.delimiter > "u" ? Gn.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : Gn.encode,
        encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Gn.encodeDotInKeys,
        encoder: typeof t.encoder == "function" ? t.encoder : Gn.encoder,
        encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Gn.encodeValuesOnly,
        filter: o,
        format: n,
        formatter: i,
        serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Gn.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Gn.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Gn.strictNullHandling
    };
}, Hse = function(e, t) {
    var r = e, n = jse(t), i, o;
    typeof n.filter == "function" ? (o = n.filter, r = o("", r)) : la(n.filter) && (o = n.filter, i = o);
    var s = [];
    if (typeof r != "object" || r === null) return "";
    var a = KN[n.arrayFormat], u = a === "comma" && n.commaRoundTrip;
    i || (i = Object.keys(r)), n.sort && i.sort(n.sort);
    for(var f = qN(), c = 0; c < i.length; ++c){
        var l = i[c], p = r[l];
        n.skipNulls && p === null || WN(s, zse(p, l, a, u, n.allowEmptyArrays, n.strictNullHandling, n.skipNulls, n.encodeDotInKeys, n.encode ? n.encoder : null, n.filter, n.sort, n.allowDots, n.serializeDate, n.format, n.formatter, n.encodeValuesOnly, n.charset, f));
    }
    var y = s.join(n.delimiter), _ = n.addQueryPrefix === !0 ? "?" : "";
    return n.charsetSentinel && (n.charset === "iso-8859-1" ? _ += "utf8=%26%2310003%3B&" : _ += "utf8=%E2%9C%93&"), y.length > 0 ? _ + y : "";
}, xf = HN, ax = Object.prototype.hasOwnProperty, cI = Array.isArray, Nn = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: xf.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1,
    throwOnLimitExceeded: !1
}, qse = function(e) {
    return e.replace(/&#(\d+);/g, function(t, r) {
        return String.fromCharCode(parseInt(r, 10));
    });
}, VN = function(e, t, r) {
    if (e && typeof e == "string" && t.comma && e.indexOf(",") > -1) return e.split(",");
    if (t.throwOnLimitExceeded && r >= t.arrayLimit) throw new RangeError("Array limit exceeded. Only " + t.arrayLimit + " element" + (t.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return e;
}, Kse = "utf8=%26%2310003%3B", Wse = "utf8=%E2%9C%93", Vse = function(t, r) {
    var n = {
        __proto__: null
    }, i = r.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
    i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var o = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, s = i.split(r.delimiter, r.throwOnLimitExceeded ? o + 1 : o);
    if (r.throwOnLimitExceeded && s.length > o) throw new RangeError("Parameter limit exceeded. Only " + o + " parameter" + (o === 1 ? "" : "s") + " allowed.");
    var a = -1, u, f = r.charset;
    if (r.charsetSentinel) for(u = 0; u < s.length; ++u)s[u].indexOf("utf8=") === 0 && (s[u] === Wse ? f = "utf-8" : s[u] === Kse && (f = "iso-8859-1"), a = u, u = s.length);
    for(u = 0; u < s.length; ++u)if (u !== a) {
        var c = s[u], l = c.indexOf("]="), p = l === -1 ? c.indexOf("=") : l + 1, y, _;
        p === -1 ? (y = r.decoder(c, Nn.decoder, f, "key"), _ = r.strictNullHandling ? null : "") : (y = r.decoder(c.slice(0, p), Nn.decoder, f, "key"), _ = xf.maybeMap(VN(c.slice(p + 1), r, cI(n[y]) ? n[y].length : 0), function(O) {
            return r.decoder(O, Nn.decoder, f, "value");
        })), _ && r.interpretNumericEntities && f === "iso-8859-1" && (_ = qse(String(_))), c.indexOf("[]=") > -1 && (_ = cI(_) ? [
            _
        ] : _);
        var A = ax.call(n, y);
        A && r.duplicates === "combine" ? n[y] = xf.combine(n[y], _) : (!A || r.duplicates === "last") && (n[y] = _);
    }
    return n;
}, Gse = function(e, t, r, n) {
    var i = 0;
    if (e.length > 0 && e[e.length - 1] === "[]") {
        var o = e.slice(0, -1).join("");
        i = Array.isArray(t) && t[o] ? t[o].length : 0;
    }
    for(var s = n ? t : VN(t, r, i), a = e.length - 1; a >= 0; --a){
        var u, f = e[a];
        if (f === "[]" && r.parseArrays) u = r.allowEmptyArrays && (s === "" || r.strictNullHandling && s === null) ? [] : xf.combine([], s);
        else {
            u = r.plainObjects ? {
                __proto__: null
            } : {};
            var c = f.charAt(0) === "[" && f.charAt(f.length - 1) === "]" ? f.slice(1, -1) : f, l = r.decodeDotInKeys ? c.replace(/%2E/g, ".") : c, p = parseInt(l, 10);
            !r.parseArrays && l === "" ? u = {
                0: s
            } : !isNaN(p) && f !== l && String(p) === l && p >= 0 && r.parseArrays && p <= r.arrayLimit ? (u = [], u[p] = s) : l !== "__proto__" && (u[l] = s);
        }
        s = u;
    }
    return s;
}, Zse = function(t, r, n, i) {
    if (t) {
        var o = n.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, s = /(\[[^[\]]*])/, a = /(\[[^[\]]*])/g, u = n.depth > 0 && s.exec(o), f = u ? o.slice(0, u.index) : o, c = [];
        if (f) {
            if (!n.plainObjects && ax.call(Object.prototype, f) && !n.allowPrototypes) return;
            c.push(f);
        }
        for(var l = 0; n.depth > 0 && (u = a.exec(o)) !== null && l < n.depth;){
            if (l += 1, !n.plainObjects && ax.call(Object.prototype, u[1].slice(1, -1)) && !n.allowPrototypes) return;
            c.push(u[1]);
        }
        if (u) {
            if (n.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + n.depth + " and strictDepth is true");
            c.push("[" + o.slice(u.index) + "]");
        }
        return Gse(c, r, n, i);
    }
}, Yse = function(t) {
    if (!t) return Nn;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.decodeDotInKeys < "u" && typeof t.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.decoder !== null && typeof t.decoder < "u" && typeof t.decoder != "function") throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof t.throwOnLimitExceeded < "u" && typeof t.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var r = typeof t.charset > "u" ? Nn.charset : t.charset, n = typeof t.duplicates > "u" ? Nn.duplicates : t.duplicates;
    if (n !== "combine" && n !== "first" && n !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
    var i = typeof t.allowDots > "u" ? t.decodeDotInKeys === !0 ? !0 : Nn.allowDots : !!t.allowDots;
    return {
        allowDots: i,
        allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Nn.allowEmptyArrays,
        allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Nn.allowPrototypes,
        allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Nn.allowSparse,
        arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Nn.arrayLimit,
        charset: r,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Nn.charsetSentinel,
        comma: typeof t.comma == "boolean" ? t.comma : Nn.comma,
        decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Nn.decodeDotInKeys,
        decoder: typeof t.decoder == "function" ? t.decoder : Nn.decoder,
        delimiter: typeof t.delimiter == "string" || xf.isRegExp(t.delimiter) ? t.delimiter : Nn.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Nn.depth,
        duplicates: n,
        ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Nn.interpretNumericEntities,
        parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Nn.parameterLimit,
        parseArrays: t.parseArrays !== !1,
        plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Nn.plainObjects,
        strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Nn.strictDepth,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Nn.strictNullHandling,
        throwOnLimitExceeded: typeof t.throwOnLimitExceeded == "boolean" ? t.throwOnLimitExceeded : !1
    };
}, Xse = function(e, t) {
    var r = Yse(t);
    if (e === "" || e === null || typeof e > "u") return r.plainObjects ? {
        __proto__: null
    } : {};
    for(var n = typeof e == "string" ? Vse(e, r) : e, i = r.plainObjects ? {
        __proto__: null
    } : {}, o = Object.keys(n), s = 0; s < o.length; ++s){
        var a = o[s], u = Zse(a, n[a], r, typeof e == "string");
        i = xf.merge(i, u, r);
    }
    return r.allowSparse === !0 ? i : xf.compact(i);
}, Jse = Hse, Qse = Xse, eae = hS, tae = {
    formats: eae,
    parse: Qse,
    stringify: Jse
}, rae = oie;
function ls() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var nae = /^([a-z0-9.+-]+:)/i, iae = /:[0-9]*$/, oae = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, sae = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
], aae = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
].concat(sae), cx = [
    "'"
].concat(aae), uI = [
    "%",
    "/",
    "?",
    ";",
    "#"
].concat(cx), fI = [
    "/",
    "?",
    "#"
], cae = 255, lI = /^[+a-z0-9A-Z_-]{0,63}$/, uae = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, fae = {
    javascript: !0,
    "javascript:": !0
}, ux = {
    javascript: !0,
    "javascript:": !0
}, Gl = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}, fx = tae;
function m0(e, t, r) {
    if (e && typeof e == "object" && e instanceof ls) return e;
    var n = new ls();
    return n.parse(e, t, r), n;
}
ls.prototype.parse = function(e, t, r) {
    if (typeof e != "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o = e.split(i), s = /\\/g;
    o[0] = o[0].replace(s, "/"), e = o.join(i);
    var a = e;
    if (a = a.trim(), !r && e.split("#").length === 1) {
        var u = oae.exec(a);
        if (u) return this.path = a, this.href = a, this.pathname = u[1], u[2] ? (this.search = u[2], t ? this.query = fx.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
    }
    var f = nae.exec(a);
    if (f) {
        f = f[0];
        var c = f.toLowerCase();
        this.protocol = c, a = a.substr(f.length);
    }
    if (r || f || a.match(/^\/\/[^@/]+@[^@/]+/)) {
        var l = a.substr(0, 2) === "//";
        l && !(f && ux[f]) && (a = a.substr(2), this.slashes = !0);
    }
    if (!ux[f] && (l || f && !Gl[f])) {
        for(var p = -1, y = 0; y < fI.length; y++){
            var _ = a.indexOf(fI[y]);
            _ !== -1 && (p === -1 || _ < p) && (p = _);
        }
        var A, O;
        p === -1 ? O = a.lastIndexOf("@") : O = a.lastIndexOf("@", p), O !== -1 && (A = a.slice(0, O), a = a.slice(O + 1), this.auth = decodeURIComponent(A)), p = -1;
        for(var y = 0; y < uI.length; y++){
            var _ = a.indexOf(uI[y]);
            _ !== -1 && (p === -1 || _ < p) && (p = _);
        }
        p === -1 && (p = a.length), this.host = a.slice(0, p), a = a.slice(p), this.parseHost(), this.hostname = this.hostname || "";
        var N = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!N) for(var U = this.hostname.split(/\./), y = 0, D = U.length; y < D; y++){
            var H = U[y];
            if (H && !H.match(lI)) {
                for(var K = "", re = 0, Q = H.length; re < Q; re++)H.charCodeAt(re) > 127 ? K += "x" : K += H[re];
                if (!K.match(lI)) {
                    var G = U.slice(0, y), R = U.slice(y + 1), X = H.match(uae);
                    X && (G.push(X[1]), R.unshift(X[2])), R.length && (a = "/" + R.join(".") + a), this.hostname = G.join(".");
                    break;
                }
            }
        }
        this.hostname.length > cae ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), N || (this.hostname = rae.toASCII(this.hostname));
        var $ = this.port ? ":" + this.port : "", S = this.hostname || "";
        this.host = S + $, this.href += this.host, N && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a));
    }
    if (!fae[c]) for(var y = 0, D = cx.length; y < D; y++){
        var w = cx[y];
        if (a.indexOf(w) !== -1) {
            var g = encodeURIComponent(w);
            g === w && (g = escape(w)), a = a.split(w).join(g);
        }
    }
    var m = a.indexOf("#");
    m !== -1 && (this.hash = a.substr(m), a = a.slice(0, m));
    var E = a.indexOf("?");
    if (E !== -1 ? (this.search = a.substr(E), this.query = a.substr(E + 1), t && (this.query = fx.parse(this.query)), a = a.slice(0, E)) : t && (this.search = "", this.query = {}), a && (this.pathname = a), Gl[c] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var $ = this.pathname || "", T = this.search || "";
        this.path = $ + T;
    }
    return this.href = this.format(), this;
};
function lae(e) {
    return typeof e == "string" && (e = m0(e)), e instanceof ls ? e.format() : ls.prototype.format.call(e);
}
ls.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = !1, o = "";
    this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (o = fx.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1
    }));
    var s = this.search || o && "?" + o || "";
    return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Gl[t]) && i !== !1 ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), s && s.charAt(0) !== "?" && (s = "?" + s), r = r.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a);
    }), s = s.replace("#", "%23"), t + i + r + s + n;
};
function dae(e, t) {
    return m0(e, !1, !0).resolve(t);
}
ls.prototype.resolve = function(e) {
    return this.resolveObject(m0(e, !1, !0)).format();
};
function hae(e, t) {
    return e ? m0(e, !1, !0).resolveObject(t) : t;
}
ls.prototype.resolveObject = function(e) {
    if (typeof e == "string") {
        var t = new ls();
        t.parse(e, !1, !0), e = t;
    }
    for(var r = new ls(), n = Object.keys(this), i = 0; i < n.length; i++){
        var o = n[i];
        r[o] = this[o];
    }
    if (r.hash = e.hash, e.href === "") return r.href = r.format(), r;
    if (e.slashes && !e.protocol) {
        for(var s = Object.keys(e), a = 0; a < s.length; a++){
            var u = s[a];
            u !== "protocol" && (r[u] = e[u]);
        }
        return Gl[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
    }
    if (e.protocol && e.protocol !== r.protocol) {
        if (!Gl[e.protocol]) {
            for(var f = Object.keys(e), c = 0; c < f.length; c++){
                var l = f[c];
                r[l] = e[l];
            }
            return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !ux[e.protocol]) {
            for(var D = (e.pathname || "").split("/"); D.length && !(e.host = D.shift()););
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), D[0] !== "" && D.unshift(""), D.length < 2 && D.unshift(""), r.pathname = D.join("/");
        } else r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
            var p = r.pathname || "", y = r.search || "";
            r.path = p + y;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    }
    var _ = r.pathname && r.pathname.charAt(0) === "/", A = e.host || e.pathname && e.pathname.charAt(0) === "/", O = A || _ || r.host && e.pathname, N = O, U = r.pathname && r.pathname.split("/") || [], D = e.pathname && e.pathname.split("/") || [], H = r.protocol && !Gl[r.protocol];
    if (H && (r.hostname = "", r.port = null, r.host && (U[0] === "" ? U[0] = r.host : U.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (D[0] === "" ? D[0] = e.host : D.unshift(e.host)), e.host = null), O = O && (D[0] === "" || U[0] === "")), A) r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, U = D;
    else if (D.length) U || (U = []), U.pop(), U = U.concat(D), r.search = e.search, r.query = e.query;
    else if (e.search != null) {
        if (H) {
            r.host = U.shift(), r.hostname = r.host;
            var K = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            K && (r.auth = K.shift(), r.hostname = K.shift(), r.host = r.hostname);
        }
        return r.search = e.search, r.query = e.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
    }
    if (!U.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
    for(var re = U.slice(-1)[0], Q = (r.host || e.host || U.length > 1) && (re === "." || re === "..") || re === "", G = 0, R = U.length; R >= 0; R--)re = U[R], re === "." ? U.splice(R, 1) : re === ".." ? (U.splice(R, 1), G++) : G && (U.splice(R, 1), G--);
    if (!O && !N) for(; G--; G)U.unshift("..");
    O && U[0] !== "" && (!U[0] || U[0].charAt(0) !== "/") && U.unshift(""), Q && U.join("/").substr(-1) !== "/" && U.push("");
    var X = U[0] === "" || U[0] && U[0].charAt(0) === "/";
    if (H) {
        r.hostname = X ? "" : U.length ? U.shift() : "", r.host = r.hostname;
        var K = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
        K && (r.auth = K.shift(), r.hostname = K.shift(), r.host = r.hostname);
    }
    return O = O || r.host && U.length, O && !X && U.unshift(""), U.length > 0 ? r.pathname = U.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
ls.prototype.parseHost = function() {
    var e = this.host, t = iae.exec(e);
    t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
Md.parse = m0;
Md.resolve = dae;
Md.resolveObject = hae;
Md.format = lae;
Md.Url = ls;
var pae = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), gae = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), yae = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && pae(t, e, r);
    return gae(t, e), t;
}, mae = Ge && Ge.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    };
};
Object.defineProperty(t1, "__esModule", {
    value: !0
});
t1.BaseRpc = void 0;
const dI = yae(ka), Qg = mae(Md), hI = mo, pI = (e)=>e.substr(0, 2) === "0x" ? e : "0x" + e;
let gI = 0;
class bae {
    constructor({ baseUrl: t, memshrewUrl: r, headers: n, blockTag: i }){
        this.baseUrl = t || "http://localhost:8080", this.memshrewUrl = r || t, this.blockTag = i || "latest", this.headers = n || {};
    }
    async _preview({ method: t, input: r }) {
        const n = await (await fetch(Qg.default.format({
            ...Qg.default.parse(this.memshrewUrl || this.baseUrl),
            pathname: "/"
        }), {})).json();
        if (n.error) {
            const s = new Error(n.error.message);
            throw s.code = n.error.code, s;
        }
        if (n.length === 0) throw Error("no mempool block built by memshrew");
        const i = n.result[0], o = await (await fetch(Qg.default.format({
            ...Qg.default.parse(this.baseUrl),
            pathname: "/"
        }), {
            method: "POST",
            body: JSON.stringify({
                id: gI++,
                jsonrpc: "2.0",
                method: "metashrew_preview",
                params: [
                    i,
                    t,
                    r,
                    "latest"
                ]
            }),
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        })).json();
        return pI(o.result);
    }
    async _call({ method: t, input: r }, n = "latest") {
        if (n === "pending") return await this._preview({
            method: t,
            input: r
        });
        const i = await (await fetch(this.baseUrl, {
            method: "POST",
            body: JSON.stringify({
                id: gI++,
                jsonrpc: "2.0",
                method: "metashrew_view",
                params: [
                    t,
                    r,
                    n || this.blockTag
                ]
            }),
            headers: Object.assign({}, {
                "Content-Type": "application/json",
                Accept: "application/json"
            }, this.headers)
        })).json();
        return pI(i.result);
    }
    async runesbyaddress({ address: t }, r = "latest") {
        const n = dI.encodeWalletInput(t), i = await this._call({
            method: "runesbyaddress",
            input: n
        }, r);
        return dI.decodeWalletOutput(i);
    }
    async runesbyheight({ height: t }, r = "latest") {
        const n = (0, hI.encodeBlockHeightInput)(t), i = await this._call({
            method: "runesbyheight",
            input: n
        }, r);
        return (0, hI.decodeRunesResponse)(i);
    }
}
t1.BaseRpc = bae;
var uo = {}, hn = {}, Qn = {}, pS = {}, wi = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.isNone = e.isSome = e.None = e.Some = e.OptionType = void 0, e.OptionType = {
        Some: Symbol(":some"),
        None: Symbol(":none")
    };
    class t {
        constructor(a){
            this.val = a;
        }
        get type() {
            return e.OptionType.Some;
        }
        isSome() {
            return !0;
        }
        isNone() {
            return !1;
        }
        match(a) {
            return a.some(this.val);
        }
        map(a) {
            return n(a(this.val));
        }
        inspect(a) {
            return a(this.val), this;
        }
        andThen(a) {
            return a(this.val);
        }
        or(a) {
            return this;
        }
        orElse(a) {
            return this;
        }
        and(a) {
            return a;
        }
        unwrapOr(a) {
            return this.val;
        }
        unwrap() {
            return this.val;
        }
    }
    class r {
        get type() {
            return e.OptionType.None;
        }
        isSome() {
            return !1;
        }
        isNone() {
            return !0;
        }
        match({ none: a }) {
            return typeof a == "function" ? a() : a;
        }
        map(a) {
            return new r();
        }
        inspect(a) {
            return this;
        }
        andThen(a) {
            return new r();
        }
        or(a) {
            return a;
        }
        orElse(a) {
            return a();
        }
        and(a) {
            return new r();
        }
        unwrapOr(a) {
            return a;
        }
        unwrap() {
            throw new ReferenceError("Trying to unwrap None.");
        }
    }
    function n(s) {
        return new t(s);
    }
    e.Some = n, e.None = new r();
    function i(s) {
        return s.isSome();
    }
    e.isSome = i;
    function o(s) {
        return s.isNone();
    }
    e.isNone = o;
})(wi);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u8 = e.U8_MAX_BIGINT = void 0;
    const t = wi;
    e.U8_MAX_BIGINT = 0xffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U8_MAX_BIGINT;
    }
    e.u8 = r, function(n) {
        n.MAX = n(e.U8_MAX_BIGINT);
        function i(s, a) {
            const u = s + a;
            return u > n.MAX ? t.None : (0, t.Some)(n(u));
        }
        n.checkedAdd = i;
        function o(s, a) {
            const u = s - a;
            return u < 0n ? t.None : (0, t.Some)(n(u));
        }
        n.checkedSub = o;
    }(r || (e.u8 = r = {}));
})(pS);
var gS = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u32 = e.U32_MAX_BIGINT = void 0;
    const t = wi;
    e.U32_MAX_BIGINT = 0xffffffffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U32_MAX_BIGINT;
    }
    e.u32 = r, function(n) {
        n.MAX = n(e.U32_MAX_BIGINT);
        function i(s, a) {
            const u = s + a;
            return u > n.MAX ? t.None : (0, t.Some)(n(u));
        }
        n.checkedAdd = i;
        function o(s, a) {
            const u = s - a;
            return u < 0n ? t.None : (0, t.Some)(n(u));
        }
        n.checkedSub = o;
    }(r || (e.u32 = r = {}));
})(gS);
var yS = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u64 = e.U64_MAX_BIGINT = void 0;
    const t = wi;
    e.U64_MAX_BIGINT = 0xffffffffffffffffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U64_MAX_BIGINT;
    }
    e.u64 = r, function(n) {
        n.MAX = n(e.U64_MAX_BIGINT);
        function i(s, a) {
            const u = s + a;
            return u > n.MAX ? t.None : (0, t.Some)(n(u));
        }
        n.checkedAdd = i;
        function o(s, a) {
            const u = s - a;
            return u < 0n ? t.None : (0, t.Some)(n(u));
        }
        n.checkedSub = o;
    }(r || (e.u64 = r = {}));
})(yS);
var qh = {}, b0 = {};
Object.defineProperty(b0, "__esModule", {
    value: !0
});
b0.SeekBuffer = void 0;
class wae {
    constructor(t){
        this.buffer = t, this.seekIndex = 0;
    }
    readUInt8() {
        if (!this.isFinished()) return this.buffer.readUInt8(this.seekIndex++);
    }
    isFinished() {
        return this.seekIndex >= this.buffer.length;
    }
}
b0.SeekBuffer = wae;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getAllU128 = e.u128 = e.U128_MAX_BIGINT = void 0;
    const t = wi, r = b0, n = yS, i = gS, o = pS;
    e.U128_MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
    function s(u) {
        return (typeof u == "bigint" ? u : BigInt(u)) & e.U128_MAX_BIGINT;
    }
    e.u128 = s, function(u) {
        u.MAX = u(e.U128_MAX_BIGINT);
        function f(Q, G) {
            const R = Q + G;
            return R > u.MAX ? t.None : (0, t.Some)(u(R));
        }
        u.checkedAdd = f;
        function c(Q, G) {
            const R = u.checkedAdd(Q, G);
            if (R.isNone()) throw new Error("checked add overflow");
            return R.unwrap();
        }
        u.checkedAddThrow = c;
        function l(Q, G) {
            const R = Q - G;
            return R < 0n ? t.None : (0, t.Some)(u(R));
        }
        u.checkedSub = l;
        function p(Q, G) {
            const R = u.checkedSub(Q, G);
            if (R.isNone()) throw new Error("checked sub overflow");
            return R.unwrap();
        }
        u.checkedSubThrow = p;
        function y(Q, G) {
            const R = Q * G;
            return R > u.MAX ? t.None : (0, t.Some)(u(R));
        }
        u.checkedMultiply = y;
        function _(Q, G) {
            const R = Q + G;
            return R > u.MAX ? u.MAX : u(R);
        }
        u.saturatingAdd = _;
        function A(Q, G) {
            const R = Q * G;
            return R > u.MAX ? u.MAX : u(R);
        }
        u.saturatingMultiply = A;
        function O(Q, G) {
            return u(Q < G ? 0 : Q - G);
        }
        u.saturatingSub = O;
        function N(Q) {
            try {
                return (0, t.Some)(U(Q));
            } catch  {
                return t.None;
            }
        }
        u.decodeVarInt = N;
        function U(Q) {
            let G = u(0);
            for(let R = 0; R <= 18; R++){
                const X = Q.readUInt8();
                if (X === void 0) throw new Error("Unterminated");
                const $ = u(X) & 127n;
                if (R === 18 && ($ & 124n) !== 0n) throw new Error("Overflow");
                if (G = u(G | $ << u(7 * R)), !(X & 128)) return G;
            }
            throw new Error("Overlong");
        }
        u.tryDecodeVarInt = U;
        function D(Q) {
            const G = [];
            for(; Q >> 7n > 0n;)G.push(Number(Q & 0xffn) | 128), Q = u(Q >> 7n);
            return G.push(Number(Q & 0xffn)), We.from(G);
        }
        u.encodeVarInt = D;
        function H(Q) {
            return Q > n.u64.MAX ? t.None : (0, t.Some)((0, n.u64)(Q));
        }
        u.tryIntoU64 = H;
        function K(Q) {
            return Q > i.u32.MAX ? t.None : (0, t.Some)((0, i.u32)(Q));
        }
        u.tryIntoU32 = K;
        function re(Q) {
            return Q > o.u8.MAX ? t.None : (0, t.Some)((0, o.u8)(Q));
        }
        u.tryIntoU8 = re;
    }(s || (e.u128 = s = {}));
    function* a(u) {
        const f = new r.SeekBuffer(u);
        for(; !f.isFinished();){
            const c = s.tryDecodeVarInt(f);
            if (c === void 0) return;
            yield c;
        }
    }
    e.getAllU128 = a;
})(qh);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u128 = e.u64 = e.u32 = e.u8 = void 0;
    var t = pS;
    Object.defineProperty(e, "u8", {
        enumerable: !0,
        get: function() {
            return t.u8;
        }
    });
    var r = gS;
    Object.defineProperty(e, "u32", {
        enumerable: !0,
        get: function() {
            return r.u32;
        }
    });
    var n = yS;
    Object.defineProperty(e, "u64", {
        enumerable: !0,
        get: function() {
            return n.u64;
        }
    });
    var i = qh;
    Object.defineProperty(e, "u128", {
        enumerable: !0,
        get: function() {
            return i.u128;
        }
    });
})(Qn);
var uc = {};
Object.defineProperty(uc, "__esModule", {
    value: !0
});
uc.script = uc.opcodes = void 0;
var Kh;
(function(e) {
    function t(i) {
        return i < as.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
    }
    e.encodingLength = t;
    function r(i, o, s) {
        const a = t(o);
        return a === 1 ? i.writeUInt8(o, s) : a === 2 ? (i.writeUInt8(as.OP_PUSHDATA1, s), i.writeUInt8(o, s + 1)) : a === 3 ? (i.writeUInt8(as.OP_PUSHDATA2, s), i.writeUInt16LE(o, s + 1)) : (i.writeUInt8(as.OP_PUSHDATA4, s), i.writeUInt32LE(o, s + 1)), a;
    }
    e.encode = r;
    function n(i, o) {
        const s = i.readUInt8(o);
        let a, u;
        if (s < as.OP_PUSHDATA1) a = s, u = 1;
        else if (s === as.OP_PUSHDATA1) {
            if (o + 2 > i.length) return null;
            a = i.readUInt8(o + 1), u = 2;
        } else if (s === as.OP_PUSHDATA2) {
            if (o + 3 > i.length) return null;
            a = i.readUInt16LE(o + 1), u = 3;
        } else {
            if (o + 5 > i.length) return null;
            if (s !== as.OP_PUSHDATA4) throw new Error("Unexpected opcode");
            a = i.readUInt32LE(o + 1), u = 5;
        }
        return {
            opcode: s,
            number: a,
            size: u
        };
    }
    e.decode = n;
})(Kh || (Kh = {}));
const as = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
};
uc.opcodes = as;
as.OP_RESERVED;
function yI(e) {
    return We.isBuffer(e);
}
var mI;
(function(e) {
    function t(n) {
        const i = n.reduce((a, u)=>yI(u) ? a + Kh.encodingLength(u.length) + u.length : a + 1, 0), o = We.allocUnsafe(i);
        let s = 0;
        if (n.forEach((a)=>{
            yI(a) ? (s += Kh.encode(o, a.length, s), a.copy(o, s), s += a.length) : (o.writeUInt8(a, s), s += 1);
        }), s !== o.length) throw new Error("Could not decode chunks");
        return o;
    }
    e.compile = t;
    function* r(n) {
        let i = 0;
        for(; i < n.length;){
            const o = n[i];
            if (o >= as.OP_0 && o <= as.OP_PUSHDATA4) {
                const s = Kh.decode(n, i);
                if (s === null || (i += s.size, i + s.number > n.length)) return !1;
                const a = n.slice(i, i + s.number);
                i += s.number, yield a;
            } else yield o, i += 1;
        }
        return !0;
    }
    e.decompile = r;
})(mI || (uc.script = mI = {}));
Object.defineProperty(hn, "__esModule", {
    value: !0
});
hn.TAPROOT_SCRIPT_PUBKEY_TYPE = hn.COMMIT_CONFIRMATIONS = hn.TAPROOT_ANNEX_PREFIX = hn.MAGIC_NUMBER = hn.OP_RETURN = hn.MAX_SCRIPT_ELEMENT_SIZE = hn.SUBSIDY_HALVING_INTERVAL = hn.RESERVED = hn.MAX_DIVISIBILITY = void 0;
const GN = Qn, ZN = uc;
hn.MAX_DIVISIBILITY = (0, GN.u8)(38);
hn.RESERVED = (0, GN.u128)(6402364363415443603228541259936211926n);
hn.SUBSIDY_HALVING_INTERVAL = 21e4;
hn.MAX_SCRIPT_ELEMENT_SIZE = 520;
hn.OP_RETURN = ZN.opcodes.OP_RETURN;
hn.MAGIC_NUMBER = ZN.opcodes.OP_13;
hn.TAPROOT_ANNEX_PREFIX = 80;
hn.COMMIT_CONFIRMATIONS = 6;
hn.TAPROOT_SCRIPT_PUBKEY_TYPE = "witness_v1_taproot";
var Cd = {};
Object.defineProperty(Cd, "__esModule", {
    value: !0
});
var YN = Cd.ProtoruneRuneId = void 0;
const Js = wi, Qs = Qn;
class Wh {
    constructor(t, r){
        this.block = t, this.tx = r;
    }
    static new(t, r) {
        const n = new Wh(t, r);
        return n.block === (0, Qs.u128)(0) && n.tx > (0, Qs.u128)(0) ? Js.None : (0, Js.Some)(n);
    }
    static sort(t) {
        return [
            ...t
        ].sort((r, n)=>Number(r.block - n.block || r.tx - n.tx));
    }
    delta(t) {
        const r = Qs.u128.checkedSub(t.block, this.block);
        if (r.isNone()) return Js.None;
        const n = r.unwrap();
        let i;
        if (n === 0n) {
            const o = Qs.u128.checkedSub(t.tx, this.tx);
            if (o.isNone()) return Js.None;
            i = o.unwrap();
        } else i = t.tx;
        return (0, Js.Some)([
            (0, Qs.u128)(n),
            (0, Qs.u128)(i)
        ]);
    }
    next(t, r) {
        const n = (0, Js.Some)(t), i = (0, Js.Some)(r);
        if (n.isNone() || i.isNone()) return Js.None;
        const o = n.unwrap(), s = i.unwrap(), a = Qs.u128.checkedAdd(this.block, o);
        if (a.isNone()) return Js.None;
        let u;
        if (o === 0n) {
            const f = Qs.u128.checkedAdd(this.tx, s);
            if (f.isNone()) return Js.None;
            u = f.unwrap();
        } else u = s;
        return Wh.new(a.unwrap(), u);
    }
    toString() {
        return `${this.block}:${this.tx}`;
    }
    static fromString(t) {
        const r = t.split(":");
        if (r.length !== 2) throw new Error(`invalid rune ID: ${t}`);
        const [n, i] = r;
        if (!/^\d+$/.test(n) || !/^\d+$/.test(i)) throw new Error(`invalid rune ID: ${t}`);
        return new Wh((0, Qs.u128)(BigInt(n)), (0, Qs.u128)(BigInt(i)));
    }
}
YN = Cd.ProtoruneRuneId = Wh;
var Ud = {};
Object.defineProperty(Ud, "__esModule", {
    value: !0
});
Ud.Etching = void 0;
const bI = wi, gh = Qn;
class vae {
    constructor(t, r, n, i, o, s, a){
        this.divisibility = t, this.rune = r, this.spacers = n, this.terms = o, this.premine = s, this.turbo = a, this.symbol = i.andThen((u)=>{
            const f = u.codePointAt(0);
            return f !== void 0 ? (0, bI.Some)(String.fromCodePoint(f)) : bI.None;
        });
    }
    get supply() {
        const t = this.premine.unwrapOr((0, gh.u128)(0)), r = this.terms.andThen((i)=>i.cap).unwrapOr((0, gh.u128)(0)), n = this.terms.andThen((i)=>i.amount).unwrapOr((0, gh.u128)(0));
        return gh.u128.checkedMultiply(r, n).andThen((i)=>gh.u128.checkedAdd(t, i));
    }
}
Ud.Etching = vae;
var Ff = {};
Object.defineProperty(Ff, "__esModule", {
    value: !0
});
Ff.Tag = void 0;
const ey = wi, yl = Qn;
var bm;
(function(e) {
    e[e.BODY = 0] = "BODY", e[e.FLAGS = 2] = "FLAGS", e[e.RUNE = 4] = "RUNE", e[e.PREMINE = 6] = "PREMINE", e[e.CAP = 8] = "CAP", e[e.AMOUNT = 10] = "AMOUNT", e[e.HEIGHT_START = 12] = "HEIGHT_START", e[e.HEIGHT_END = 14] = "HEIGHT_END", e[e.OFFSET_START = 16] = "OFFSET_START", e[e.OFFSET_END = 18] = "OFFSET_END", e[e.MINT = 20] = "MINT", e[e.POINTER = 22] = "POINTER", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.DIVISIBILITY = 1] = "DIVISIBILITY", e[e.SPACERS = 3] = "SPACERS", e[e.SYMBOL = 5] = "SYMBOL", e[e.NOP = 127] = "NOP";
})(bm || (Ff.Tag = bm = {}));
(function(e) {
    function t(i, o, s, a) {
        const u = o.get((0, yl.u128)(i));
        if (u === void 0) return ey.None;
        const f = [];
        for (const l of [
            ...Array(s).keys()
        ]){
            if (u[l] === void 0) return ey.None;
            f[l] = u[l];
        }
        const c = a(f);
        return c.isNone() ? ey.None : (u.splice(0, s), u.length === 0 && o.delete((0, yl.u128)(i)), (0, ey.Some)(c.unwrap()));
    }
    e.take = t;
    function r(i, o) {
        return We.concat(o.map((s)=>[
                yl.u128.encodeVarInt((0, yl.u128)(i)),
                yl.u128.encodeVarInt(s)
            ]).flat());
    }
    e.encode = r;
    function n(i, o) {
        return o.map((s)=>e.encode(i, [
                (0, yl.u128)(s)
            ])).unwrapOr(We.alloc(0));
    }
    e.encodeOptionInt = n;
})(bm || (Ff.Tag = bm = {}));
var $d = {};
Object.defineProperty($d, "__esModule", {
    value: !0
});
$d.Tag = void 0;
const ml = Qn, ty = wi;
var wm;
(function(e) {
    e[e.BODY = 0] = "BODY", e[e.PROTOCOL = 16383] = "PROTOCOL", e[e.MESSAGE = 81] = "MESSAGE", e[e.BURN = 83] = "BURN", e[e.SPLIT = 85] = "SPLIT", e[e.POINTER = 91] = "POINTER", e[e.REFUND = 93] = "REFUND", e[e.FROM = 95] = "FROM", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.NOP = 127] = "NOP";
})(wm || ($d.Tag = wm = {}));
(function(e) {
    function t(i, o, s, a) {
        const u = o.get((0, ml.u128)(i));
        if (u === void 0) return ty.None;
        const f = [];
        for (const l of [
            ...Array(s).keys()
        ]){
            if (u[l] === void 0) return ty.None;
            f[l] = u[l];
        }
        const c = a(f);
        return c.isNone() ? ty.None : (u.splice(0, s), u.length === 0 && o.delete((0, ml.u128)(i)), (0, ty.Some)(c.unwrap()));
    }
    e.take = t;
    function r(i, o) {
        return We.concat(o.map((s)=>[
                ml.u128.encodeVarInt((0, ml.u128)(i)),
                ml.u128.encodeVarInt(s)
            ]).flat());
    }
    e.encode = r;
    function n(i, o) {
        return o.map((s)=>e.encode(i, [
                (0, ml.u128)(s)
            ])).unwrapOr(We.alloc(0));
    }
    e.encodeOptionInt = n;
})(wm || ($d.Tag = wm = {}));
var Ld = {};
Object.defineProperty(Ld, "__esModule", {
    value: !0
});
Ld.Flag = void 0;
const F_ = Qn;
var vm;
(function(e) {
    e[e.ETCHING = 0] = "ETCHING", e[e.TERMS = 1] = "TERMS", e[e.TURBO = 2] = "TURBO", e[e.CENOTAPH = 127] = "CENOTAPH";
})(vm || (Ld.Flag = vm = {}));
(function(e) {
    function t(i) {
        return (0, F_.u128)(1n << BigInt(i));
    }
    e.mask = t;
    function r(i, o) {
        const s = e.mask(o), a = (i & s) !== 0n;
        return {
            set: a,
            flags: a ? (0, F_.u128)(i - s) : i
        };
    }
    e.take = r;
    function n(i, o) {
        return (0, F_.u128)(i | e.mask(o));
    }
    e.set = n;
})(vm || (Ld.Flag = vm = {}));
var Dd = {}, Fd = {}, zf = {};
Object.defineProperty(zf, "__esModule", {
    value: !0
});
zf.Network = void 0;
const ry = hn;
var _m;
(function(e) {
    e[e.MAINNET = 0] = "MAINNET", e[e.SIGNET = 1] = "SIGNET", e[e.TESTNET = 2] = "TESTNET", e[e.REGTEST = 3] = "REGTEST";
})(_m || (zf.Network = _m = {}));
(function(e) {
    function t(r) {
        switch(r){
            case e.MAINNET:
                return ry.SUBSIDY_HALVING_INTERVAL * 4;
            case e.REGTEST:
                return ry.SUBSIDY_HALVING_INTERVAL * 0;
            case e.SIGNET:
                return ry.SUBSIDY_HALVING_INTERVAL * 0;
            case e.TESTNET:
                return ry.SUBSIDY_HALVING_INTERVAL * 12;
        }
    }
    e.getFirstRuneHeight = t;
})(_m || (zf.Network = _m = {}));
Object.defineProperty(Fd, "__esModule", {
    value: !0
});
Fd.Rune = void 0;
const _ae = zf, ny = hn, Ht = Qn;
class ks {
    constructor(t){
        this.value = t;
    }
    static getMinimumAtHeight(t, r) {
        let n = Ht.u128.saturatingAdd(r, (0, Ht.u128)(1));
        const i = (0, Ht.u128)(ny.SUBSIDY_HALVING_INTERVAL / 12);
        let o = (0, Ht.u128)(_ae.Network.getFirstRuneHeight(t)), s = Ht.u128.saturatingAdd(o, (0, Ht.u128)(ny.SUBSIDY_HALVING_INTERVAL));
        if (n < o) return new ks(ks.STEPS[12]);
        if (n >= s) return new ks((0, Ht.u128)(0));
        let a = Ht.u128.saturatingSub(n, o), u = Ht.u128.saturatingSub((0, Ht.u128)(12n), (0, Ht.u128)(a / i)), f = Number(u & (0, Ht.u128)(Ht.u32.MAX)), c = ks.STEPS[f], l = ks.STEPS[f - 1], p = (0, Ht.u128)(a % i);
        return new ks((0, Ht.u128)(c - (c - l) * p / i));
    }
    get reserved() {
        return this.value >= ny.RESERVED;
    }
    get commitment() {
        const t = We.alloc(16);
        t.writeBigUInt64LE(0xffffffffffffffffn & this.value, 0), t.writeBigUInt64LE(this.value >> 64n, 8);
        let r = t.length;
        for(; r > 0 && t.at(r - 1) === 0;)r--;
        return t.subarray(0, r);
    }
    static getReserved(t, r) {
        return new ks(Ht.u128.checkedAdd(ny.RESERVED, (0, Ht.u128)(t << 32n | r)).unwrap());
    }
    toString() {
        let t = this.value;
        if (t === Ht.u128.MAX) return "BCGDENLQRQWDSLRUGSNLBTMFIJAV";
        t = (0, Ht.u128)(t + 1n);
        let r = "";
        for(; t > 0;)r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Number((t - 1n) % 26n)] + r, t = (0, Ht.u128)((t - 1n) / 26n);
        return r;
    }
    static fromString(t) {
        let r = (0, Ht.u128)(0);
        for (const n of [
            ...Array(t.length).keys()
        ]){
            const i = t[n];
            if (n > 0 && (r = (0, Ht.u128)(r + 1n)), r = Ht.u128.checkedMultiply(r, (0, Ht.u128)(26)).unwrap(), "A" <= i && i <= "Z") r = Ht.u128.checkedAdd(r, (0, Ht.u128)(i.charCodeAt(0) - 65)).unwrap();
            else throw new Error(`invalid character in rune name: ${i}`);
        }
        return new ks(r);
    }
}
Fd.Rune = ks;
ks.STEPS = [
    (0, Ht.u128)(0n),
    (0, Ht.u128)(26n),
    (0, Ht.u128)(702n),
    (0, Ht.u128)(18278n),
    (0, Ht.u128)(475254n),
    (0, Ht.u128)(12356630n),
    (0, Ht.u128)(321272406n),
    (0, Ht.u128)(8353082582n),
    (0, Ht.u128)(217180147158n),
    (0, Ht.u128)(5646683826134n),
    (0, Ht.u128)(146813779479510n),
    (0, Ht.u128)(3817158266467286n),
    (0, Ht.u128)(99246114928149462n),
    (0, Ht.u128)(2580398988131886038n),
    (0, Ht.u128)(67090373691429037014n),
    (0, Ht.u128)(1744349715977154962390n),
    (0, Ht.u128)(45353092615406029022166n),
    (0, Ht.u128)(1179180408000556754576342n),
    (0, Ht.u128)(30658690608014475618984918n),
    (0, Ht.u128)(797125955808376366093607894n),
    (0, Ht.u128)(20725274851017785518433805270n),
    (0, Ht.u128)(538857146126462423479278937046n),
    (0, Ht.u128)(14010285799288023010461252363222n),
    (0, Ht.u128)(364267430781488598271992561443798n),
    (0, Ht.u128)(9470953200318703555071806597538774n),
    (0, Ht.u128)(246244783208286292431866971536008150n),
    (0, Ht.u128)(6402364363415443603228541259936211926n),
    (0, Ht.u128)(166461473448801533683942072758341510102n)
];
Object.defineProperty(Dd, "__esModule", {
    value: !0
});
Dd.SpacedRune = void 0;
const Eae = Fd;
class mS {
    constructor(t, r){
        this.rune = t, this.spacers = r;
    }
    static fromString(t) {
        let r = "", n = 0;
        for (const i of t)if ("A" <= i && i <= "Z") r += i;
        else if (i === "." || i === "") {
            if (r.length === 0) throw new Error("leading spacer");
            const o = 1 << r.length - 1;
            if (n & o) throw new Error("double spacer");
            n |= o;
        } else throw new Error("invalid character");
        if (n >= 1 << r.length - 1) throw new Error("trailing spacer");
        return new mS(Eae.Rune.fromString(r), n);
    }
    toString() {
        const t = this.rune.toString();
        let r = 0, n = "";
        for (const i of t)n += i, r < t.length - 1 && this.spacers & 1 << r && (n += ""), r++;
        return n;
    }
}
Dd.SpacedRune = mS;
Object.defineProperty(uo, "__esModule", {
    value: !0
});
uo.RunestoneProtostoneUpgrade = uo.MAX_U128_BYTES_COMPAT_W_RUNES = uo.MAX_LEB128_BYTES_IN_U128 = uo.MAX_SPACERS = void 0;
uo.isValidPayload = kae;
uo.encodeOptionInt = To;
uo.encodeRunestoneProtostone = Bae;
const Ll = hn, lx = Cd, xae = Ud, Ti = Ff, Sae = $d, fn = Qn, Fr = wi, bl = Ld, Aae = uc, Tae = Dd, z_ = Jr;
uo.MAX_SPACERS = 134217727;
function kae(e) {
    return We.isBuffer(e);
}
function To(e, t, r) {
    r.isSome() && (e.push(t), e.push(r.unwrap()));
}
uo.MAX_LEB128_BYTES_IN_U128 = 18;
uo.MAX_U128_BYTES_COMPAT_W_RUNES = 15;
class XN {
    constructor(t, r, n, i, o){
        this.mint = t, this.pointer = r, this.edicts = n, this.etching = i, this.protostones = o;
    }
    // removed decipher function -- can add it back if needed
    encipher() {
        const t = [];
        if (this.etching.isSome()) {
            const i = this.etching.unwrap();
            let o = (0, fn.u128)(0);
            if (o = bl.Flag.set(o, bl.Flag.ETCHING), i.terms.isSome() && (o = bl.Flag.set(o, bl.Flag.TERMS)), i.turbo && (o = bl.Flag.set(o, bl.Flag.TURBO)), t.push(Ti.Tag.FLAGS), t.push(o), To(t, Ti.Tag.RUNE, i.rune.map((s)=>s.value)), To(t, Ti.Tag.DIVISIBILITY, i.divisibility.map(fn.u128)), To(t, Ti.Tag.SYMBOL, i.spacers.map(fn.u128)), To(t, Ti.Tag.SYMBOL, i.symbol.map((s)=>(0, fn.u128)(s.codePointAt(0)))), To(t, Ti.Tag.PREMINE, i.premine), i.terms.isSome()) {
                const s = i.terms.unwrap();
                To(t, Ti.Tag.AMOUNT, s.amount), To(t, Ti.Tag.CAP, s.cap), To(t, Ti.Tag.HEIGHT_START, s.height[0]), To(t, Ti.Tag.HEIGHT_END, s.height[1]), To(t, Ti.Tag.OFFSET_START, s.offset[0]), To(t, Ti.Tag.OFFSET_END, s.offset[1]);
            }
        }
        if (this.mint.isSome()) {
            const i = this.mint.unwrap();
            t.push(Ti.Tag.MINT), t.push((0, fn.u128)(i.block)), t.push(Ti.Tag.MINT), t.push((0, fn.u128)(i.tx));
        }
        if (To(t, Ti.Tag.POINTER, this.pointer.map(fn.u128)), this.protostones.length) {
            let i = [];
            this.protostones.forEach((o)=>{
                o.encipher_payloads().forEach((s)=>i.push(s));
            }), (0, z_.unpack)((0, z_.encipher)(i)).forEach((o)=>{
                t.push((0, fn.u128)(Sae.Tag.PROTOCOL)), t.push((0, fn.u128)(o));
            });
        }
        if (this.edicts.length) {
            t.push((0, fn.u128)(Ti.Tag.BODY));
            const i = [
                ...this.edicts
            ].sort((s, a)=>Number(s.id.block - a.id.block || s.id.tx - a.id.tx));
            let o = new lx.ProtoruneRuneId((0, fn.u128)(0), (0, fn.u128)(0));
            for (const s of i){
                const [a, u] = o.delta(s.id).unwrap();
                t.push(a), t.push(u), t.push(s.amount), t.push((0, fn.u128)(s.output)), o = s.id;
            }
        }
        const r = [];
        r.push(Ll.OP_RETURN), r.push(Ll.MAGIC_NUMBER);
        const n = (0, z_.encipher)(t);
        for(let i = 0; i < n.length; i += Ll.MAX_SCRIPT_ELEMENT_SIZE)r.push(n.subarray(i, i + Ll.MAX_SCRIPT_ELEMENT_SIZE));
        return Aae.script.compile(r);
    }
}
uo.RunestoneProtostoneUpgrade = XN;
const Iae = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u8.MAX) throw Error("u8 overflow");
    return (0, fn.u8)(t);
}, wI = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u32.MAX) throw Error("u32 overflow");
    return (0, fn.u32)(t);
}, iy = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u64.MAX) throw Error("u64 overflow");
    return (0, fn.u64)(t);
}, oy = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > fn.u128.MAX) throw Error("u128 overflow");
    return (0, fn.u128)(t);
};
function Bae(e) {
    const t = e.mint ? (0, Fr.Some)(new lx.ProtoruneRuneId((0, fn.u128)(e.mint.block), (0, fn.u128)(e.mint.tx))) : Fr.None, r = e.pointer !== void 0 ? (0, Fr.Some)(e.pointer).map(wI) : Fr.None, n = (e.edicts ?? []).map((a)=>({
            id: new lx.ProtoruneRuneId((0, fn.u128)(a.id.block), (0, fn.u128)(a.id.tx)),
            amount: oy(a.amount),
            output: a.output
        })), i = e.protostones ?? [];
    let o = Fr.None, s;
    if (e.etching) {
        const a = e.etching, u = a.runeName ? Tae.SpacedRune.fromString(a.runeName) : void 0, f = (u == null ? void 0 : u.rune) !== void 0 ? (0, Fr.Some)(u.rune) : Fr.None;
        if (a.symbol && !(a.symbol.length === 1 || a.symbol.length === 2 && a.symbol.codePointAt(0) >= 65536)) throw Error("Symbol must be one code point");
        const c = a.divisibility !== void 0 ? (0, Fr.Some)(a.divisibility).map(Iae) : Fr.None, l = a.premine !== void 0 ? (0, Fr.Some)(a.premine).map(oy) : Fr.None, p = (u == null ? void 0 : u.spacers) !== void 0 && u.spacers !== 0 ? (0, Fr.Some)(wI(u.spacers)) : Fr.None, y = a.symbol ? (0, Fr.Some)(a.symbol) : Fr.None;
        if (c.isSome() && c.unwrap() > Ll.MAX_DIVISIBILITY) throw Error(`Divisibility is greater than protocol max ${Ll.MAX_DIVISIBILITY}`);
        let _ = Fr.None;
        if (a.terms) {
            const O = a.terms, N = O.amount !== void 0 ? (0, Fr.Some)(O.amount).map(oy) : Fr.None, U = O.cap !== void 0 ? (0, Fr.Some)(O.cap).map(oy) : Fr.None, D = O.height ? [
                O.height.start !== void 0 ? (0, Fr.Some)(O.height.start).map(iy) : Fr.None,
                O.height.end !== void 0 ? (0, Fr.Some)(O.height.end).map(iy) : Fr.None
            ] : [
                Fr.None,
                Fr.None
            ], H = O.offset ? [
                O.offset.start !== void 0 ? (0, Fr.Some)(O.offset.start).map(iy) : Fr.None,
                O.offset.end !== void 0 ? (0, Fr.Some)(O.offset.end).map(iy) : Fr.None
            ] : [
                Fr.None,
                Fr.None
            ];
            if (N.isSome() && U.isSome() && N.unwrap() * U.unwrap() > fn.u128.MAX) throw Error("Terms overflow with amount times cap");
            _ = (0, Fr.Some)({
                amount: N,
                cap: U,
                height: D,
                offset: H
            });
        }
        const A = a.turbo ?? !1;
        o = (0, Fr.Some)(new xae.Etching(c, f, p, y, _, l, A)), s = f.isSome() ? f.unwrap().commitment : void 0;
    }
    return {
        encodedRunestone: new XN(t, r, n, o, i).encipher(),
        etchingCommitment: s
    };
}
var w0 = {};
Object.defineProperty(w0, "__esModule", {
    value: !0
});
w0.ProtoStone = void 0;
const Pn = Qn, wl = $d, j_ = wi, Oae = Cd, Pae = Jr;
class Vh {
    constructor({ burn: t, message: r, protocolTag: n, edicts: i }){
        this.protocolTag = (0, Pn.u128)(n), this.edicts = i, t && (this.burn = {
            pointer: (0, j_.Some)((0, Pn.u32)(t.pointer)),
            from: t.from
        }), r && (this.message = {
            calldata: r.calldata,
            pointer: (0, j_.Some)((0, Pn.u32)(r.pointer)),
            refundPointer: (0, j_.Some)((0, Pn.u32)(r.refundPointer))
        });
    }
    // Enciphering a protostone doesn't make sense, removed this functionality
    // encipher() {
    //   const stack: (Buffer | number)[] = [];
    //   let payloads: Buffer[] = [];
    //   stack.push(OP_RETURN);
    //   if (this.burn) {
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.POINTER, this.burn.pointer.map(u128)),
    //     );
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.BURN, Some<u128>(this.protocolTag)),
    //     );
    //     stack.push(opcodes.OP_14);
    //   } else if (this.message) {
    //     payloads.push(u128.encodeVarInt(this.protocolTag));
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.POINTER, this.message.pointer.map(u128)),
    //     );
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.REFUND, this.message.refundPointer.map(u128)),
    //     );
    //     payloads.push(Tag.encode(Tag.MESSAGE, this.message.calldata));
    //     stack.push(opcodes.OP_16);
    //   } else if (this.split) {
    //     payloads.push(Tag.encode(Tag.SPLIT, this.split.order.map(u128)));
    //     stack.push(opcodes.OP_16);
    //   } else if (this.chunk) {
    //     payloads.push(this.chunk);
    //     stack.push(opcodes.OP_15);
    //   }
    //   const payload = Buffer.concat(payloads);
    //   for (let i = 0; i < payload.length; i += MAX_SCRIPT_ELEMENT_SIZE) {
    //     stack.push(payload.subarray(i, i + MAX_SCRIPT_ELEMENT_SIZE));
    //   }
    //   return script.compile(stack);
    // }
    encipher_payloads() {
        let t = [];
        if (this.burn ? (t.push((0, Pn.u128)(wl.Tag.POINTER)), t.push(this.burn.pointer.map(Pn.u128).unwrap()), this.burn.from && (t.push((0, Pn.u128)(wl.Tag.FROM)), t.push(this.burn.from.map(Pn.u128)[0]))) : this.message && (this.message.pointer.isSome() && (t.push((0, Pn.u128)(wl.Tag.POINTER)), t.push((0, Pn.u128)(this.message.pointer.map(Pn.u128).unwrap()))), this.message.refundPointer.isSome() && (t.push((0, Pn.u128)(wl.Tag.REFUND)), t.push((0, Pn.u128)(this.message.refundPointer.map(Pn.u128).unwrap()))), this.message.calldata.length && (0, Pae.unpack)(this.message.calldata).forEach((n)=>{
            t.push((0, Pn.u128)(wl.Tag.MESSAGE)), t.push((0, Pn.u128)(n));
        })), this.edicts && this.edicts.length) {
            t.push((0, Pn.u128)(wl.Tag.BODY));
            const n = [
                ...this.edicts
            ].sort((o, s)=>Number(o.id.block - s.id.block || o.id.tx - s.id.tx));
            let i = new Oae.ProtoruneRuneId((0, Pn.u128)(0), (0, Pn.u128)(0));
            for (const o of n){
                const [s, a] = i.delta(o.id).unwrap();
                t.push(s), t.push(a), t.push(o.amount), t.push((0, Pn.u128)(o.output)), i = o.id;
            }
        }
        const r = t.length;
        return t.unshift((0, Pn.u128)(r)), t.unshift((0, Pn.u128)(this.protocolTag)), t;
    }
    static burn({ protocolTag: t, edicts: r, ...n }) {
        return new Vh({
            burn: n,
            protocolTag: t,
            edicts: r
        });
    }
    static message({ protocolTag: t, edicts: r, ...n }) {
        return new Vh({
            message: n,
            protocolTag: t,
            edicts: r
        });
    }
    static edicts({ protocolTag: t, edicts: r }) {
        return new Vh({
            edicts: r,
            protocolTag: t
        });
    }
}
w0.ProtoStone = Vh;
var Nae = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), Mae = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), JN = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Nae(t, e, r);
    return Mae(t, e), t;
};
Object.defineProperty(tS, "__esModule", {
    value: !0
});
var QN = tS.AlkanesRpc = void 0;
const ea = JN(ka), Ao = JN(Bn), vl = mo, Rae = t1, vI = Lf, Cae = uo, sy = Qn, Uae = Cd, $ae = w0, Lae = Jr;
let Dae = class extends Rae.BaseRpc {
    async getbytecode({ block: t, tx: r }, n = "latest") {
        return await this._call({
            method: "getbytecode",
            input: Ao.encodeGetBytecodeRequest({
                block: t,
                tx: r
            })
        }, n);
    }
    async getblock(t, r = "latest") {
        return Ao.decodeBlockResponse(await this._call({
            method: "getblock",
            input: Ao.encodeBlockRequest({
                height: t
            })
        }, r));
    }
    async protorunesbyaddress({ address: t, protocolTag: r }, n = "latest") {
        const i = ea.encodeProtorunesWalletInput(t, r), o = await this._call({
            method: "protorunesbyaddress",
            input: i
        }, n);
        return console.log(o), ea.decodeWalletOutput(o);
    }
    async transactionbyid({ txid: t }, r = "latest") {
        const n = ea.encodeTransactionId(t), i = await this._call({
            method: "transactionbyid",
            input: n
        }, r);
        return ea.decodeTransactionResult(i);
    }
    async spendablesbyaddress({ address: t, protocolTag: r }, n = "latest") {
        const i = ea.encodeProtorunesWalletInput(t, r), o = await this._call({
            method: "spendablesbyaddress",
            input: i
        }, n);
        return ea.decodeWalletOutput(o);
    }
    async runesbyaddress({ address: t }, r = "latest") {
        const n = ea.encodeWalletInput(t), i = await this._call({
            method: "runesbyaddress",
            input: n
        }, r);
        return ea.decodeWalletOutput(i);
    }
    async runesbyheight({ height: t }, r = "latest") {
        const n = (0, vl.encodeBlockHeightInput)(t), i = await this._call({
            method: "runesbyheight",
            input: n
        }, r);
        return (0, vl.decodeRunesResponse)(i);
    }
    async protorunesbyheight({ height: t, protocolTag: r }, n = "latest") {
        const i = (0, vl.encodeProtorunesByHeightInput)(t, r), o = await this._call({
            method: "protorunesbyheight",
            input: i
        }, n);
        return (0, vl.decodeRunesResponse)(o);
    }
    async protorunesbyoutpoint({ txid: t, vout: r, protocolTag: n }, i = "latest") {
        const o = "0x" + We.from(new vI.protorune.OutpointWithProtocol({
            protocol: (0, Lae.toUint128)(n),
            txid: We.from(t, "hex"),
            vout: r
        }).serializeBinary()).toString("hex");
        return Ao.decodeOutpointResponse(await this._call({
            method: "protorunesbyoutpoint",
            input: o
        }, i));
    }
    async runesbyoutpoint({ txid: t, vout: r }, n = "latest") {
        const i = "0x" + We.from(new vI.protorune.Outpoint({
            txid: We.from(t, "hex"),
            vout: r
        }).serializeBinary()).toString("hex");
        return Ao.decodeOutpointResponse(await this._call({
            method: "protorunesbyoutpoint",
            input: i
        }, n));
    }
    async alkanesidtooutpoint({ block: t, tx: r }, n = "latest") {
        const i = (0, vl.encodeAlkanesIdToOutpointInput)(t, r), o = await this._call({
            method: "alkanes_id_to_outpoint",
            input: i
        }, n);
        return (0, vl.decodeAlkanesIdToOutpointResponse)(o);
    }
    async traceblock({ block: t }, r = "latest") {
        const n = Ao.encodeTraceBlockRequest({
            block: t
        }), i = await this._call({
            method: "traceblock",
            input: n
        }, r);
        return Ao.decodeTraceBlockResponse(i);
    }
    async trace({ txid: t, vout: r }, n = "latest") {
        const i = Ao.encodeTraceRequest({
            txid: t,
            vout: r
        }), o = await this._call({
            method: "trace",
            input: i
        }, n);
        return Ao.decodeTraceResponse(o);
    }
    async simulate({ alkanes: t, transaction: r, height: n, block: i, txindex: o, target: s, inputs: a, vout: u, pointer: f, refundPointer: c }, l = "latest") {
        const p = Ao.encodeSimulateRequest({
            alkanes: t,
            transaction: r,
            height: n,
            txindex: o,
            target: s,
            block: i,
            inputs: a,
            vout: u,
            pointer: f,
            refundPointer: c
        }), y = await this._call({
            method: "simulate",
            input: p
        }, l);
        return Ao.decodeSimulateResponse(y);
    }
    async meta({ alkanes: t, transaction: r, height: n, block: i, txindex: o, target: s, inputs: a, vout: u, pointer: f, refundPointer: c }, l = "latest") {
        const p = Ao.encodeSimulateRequest({
            alkanes: t,
            transaction: r,
            height: n,
            txindex: o,
            target: s,
            block: i,
            inputs: a,
            vout: u,
            pointer: f,
            refundPointer: c
        }), y = await this._call({
            method: "meta",
            input: p
        }, l);
        return Ao.decodeMetaResponse(y);
    }
    async runtime({ protocolTag: t }, r = "latest") {
        const n = ea.encodeRuntimeInput(t), i = await this._call({
            method: "protorunesbyaddress",
            input: n
        }, r);
        return ea.decodeRuntimeOutput(i);
    }
    async pack({ runes: t, cellpack: r, pointer: n, refundPointer: i, edicts: o }) {
        const s = new $ae.ProtoStone({
            message: {
                calldata: r,
                pointer: n,
                refundPointer: i
            },
            protocolTag: BigInt(1),
            edicts: o
        });
        return (0, Cae.encodeRunestoneProtostone)({
            edicts: t.map((a)=>({
                    id: new Uae.ProtoruneRuneId((0, sy.u128)(a.id.block), (0, sy.u128)(a.id.tx)),
                    output: (0, sy.u32)(2),
                    amount: (0, sy.u128)(a.value)
                })),
            pointer: 3,
            protostones: [
                s
            ]
        }).encodedRunestone;
    }
};
QN = tS.AlkanesRpc = Dae;
class Fae {
    constructor(){
        pt(this, "override");
        this.override = null;
    }
    set(t) {
        this.override = t;
    }
    exists() {
        return this.override !== null;
    }
    get() {
        return this.override;
    }
}
const _I = new Fae(), zae = (e)=>e.substr(0, 2) === "0x" ? e.substr(2) : e;
let jae = 0;
function dx(e) {
    switch(typeof e){
        case "bigint":
            return "0x" + e.toString(16);
        case "object":
            return e === null ? null : We.isBuffer(e) ? "0x" + e.toString("hex") : Array.isArray(e) ? e.map((t)=>dx(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
                    t,
                    dx(r)
                ]));
        default:
            return e;
    }
}
function hx(e) {
    switch(typeof e){
        case "string":
            return e !== "0x" && !isNaN(e) ? BigInt(e) : e.substr(0, 2) === "0x" || /^[0-9a-f]+$/.test(e) ? We.from(zae(e), "hex") : e;
        case "object":
            return e === null ? null : Array.isArray(e) ? e.map((t)=>hx(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
                    t,
                    hx(r)
                ]));
        default:
            return e;
    }
}
const H_ = [
    "99",
    "100",
    "101",
    "102",
    "103",
    "104",
    "1000"
], _l = [
    "name",
    "symbol",
    "totalSupply",
    "cap",
    "minted",
    "mintAmount",
    "data"
];
class EI {
    constructor(t){
        pt(this, "alkanesUrl");
        this.alkanesUrl = t;
    }
    async _metashrewCall(t, r = []) {
        const n = new QN({
            baseUrl: _I.get()
        });
        return dx(await n[t.split("_")[1]](hx(r[0] || {})));
    }
    async _call(t, r = []) {
        if (_I.get() !== null && t.match("alkanes_")) return await this._metashrewCall(t, r);
        const n = {
            jsonrpc: "2.0",
            method: t,
            params: r,
            id: jae++
        }, i = {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(n),
            cache: "no-cache"
        };
        try {
            const s = await (await fetch(this.alkanesUrl, i)).json();
            if (s.error) throw new Error(s.error.message);
            return s.result;
        } catch (o) {
            throw o instanceof Error && o.name === "AbortError" ? (console.error("Request Timeout:", o), new Error("Request timed out")) : (console.error("Request Error:", o), o);
        }
    }
    async metashrewHeight() {
        return await this._call("metashrew_height", []);
    }
    async getAlkanesByHeight({ height: t, protocolTag: r = "1" }) {
        return await this._call("alkanes_protorunesbyheight", [
            {
                height: t,
                protocolTag: r
            }
        ]);
    }
    async getAlkanesByAddress({ address: t, protocolTag: r = "1" }) {
        try {
            return (await this._call("alkanes_protorunesbyaddress", [
                {
                    address: t,
                    protocolTag: r
                }
            ])).outpoints.filter((o)=>o.runes.length > 0).map((o)=>({
                    ...o,
                    outpoint: {
                        vout: o.outpoint.vout,
                        txid: We.from(o.outpoint.txid, "hex").reverse().toString("hex")
                    },
                    runes: o.runes.map((s)=>({
                            ...s,
                            balance: parseInt(s.balance, 16).toString(),
                            rune: {
                                ...s.rune,
                                id: {
                                    block: parseInt(s.rune.id.block, 16).toString(),
                                    tx: parseInt(s.rune.id.tx, 16).toString()
                                }
                            }
                        }))
                }));
        } catch (n) {
            throw console.error("Error in getAlkanesByAddress:", n), n;
        }
    }
    async trace(t) {
        return t.txid = We.from(t.txid, "hex").reverse().toString("hex"), await await this._call("alkanes_trace", [
            t
        ]);
    }
    parsePoolInfo(t) {
        function r(i) {
            if (i.startsWith("0x") && (i = i.slice(2)), i.length % 32 !== 0) throw new Error("Invalid hex length. Expected multiples of 128-bit (32 hex chars).");
            const o = (u)=>{
                var c, l;
                const f = (l = (c = u.match(/.{2}/g)) == null ? void 0 : c.reverse()) == null ? void 0 : l.join("");
                if (!f) throw new Error("Failed to process hex segment.");
                return BigInt("0x" + f);
            };
            return (i.match(/.{32}/g) || []).map(o).map((u)=>u.toString());
        }
        const n = r(t);
        return {
            tokenA: {
                block: n[0],
                tx: n[1]
            },
            tokenB: {
                block: n[2],
                tx: n[3]
            },
            reserveA: n[4],
            reserveB: n[5]
        };
    }
    async simulate(t, r) {
        var i;
        const n = await this._call("alkanes_simulate", [
            {
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "20000",
                txindex: 0,
                inputs: [],
                pointer: 0,
                refundPointer: 0,
                vout: 0,
                ...t
            }
        ]);
        if (r) {
            const o = Number((i = t.inputs) == null ? void 0 : i[0]);
            n.parsed = r(n, o);
        } else n.parsed = this.parseSimulateReturn(n.execution.data);
        return n;
    }
    async simulatePoolInfo(t) {
        const r = await this._call("alkanes_simulate", [
            t
        ]), n = this.parsePoolInfo(r.execution.data);
        return r.parsed = n, r;
    }
    async getAlkanesByOutpoint({ txid: t, vout: r, protocolTag: n = "1", height: i = "latest" }) {
        return (await this._call("alkanes_protorunesbyoutpoint", [
            {
                txid: We.from(t, "hex").reverse().toString("hex"),
                vout: r,
                protocolTag: n
            },
            i
        ])).map((s)=>({
                ...s,
                token: {
                    ...s.token,
                    id: {
                        block: parseInt(s.token.id.block, 16).toString(),
                        tx: parseInt(s.token.id.tx, 16).toString()
                    }
                },
                value: parseInt(s.value, 16).toString()
            }));
    }
    async getAlkaneById({ block: t, tx: r }) {
        var i, o;
        const n = {
            id: {
                block: t,
                tx: r
            },
            data: "",
            name: "",
            mintActive: !1,
            percentageMinted: 0,
            symbol: "",
            totalSupply: 0,
            cap: 0,
            minted: 0,
            mintAmount: 0
        };
        for(let s = 0; s < H_.length; s++)try {
            const a = await this.simulate({
                target: {
                    block: t,
                    tx: r
                },
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "20000",
                txindex: 0,
                inputs: [
                    H_[s]
                ],
                pointer: 0,
                refundPointer: 0,
                vout: 0
            });
            a.status === 0 && (n[_l[s]] = Number(((i = a.parsed) == null ? void 0 : i.le) || 0), (_l[s] === "name" || _l[s] === "symbol" || _l[s] === "data") && (n[_l[s]] = ((o = a.parsed) == null ? void 0 : o.string) || ""), n.mintActive = Number(n.minted) < Number(n.cap), n.percentageMinted = Math.floor(n.minted / n.cap * 100));
        } catch (a) {
            console.log(a);
        }
        return n;
    }
    async getAlkanes({ limit: t, offset: r = 0 }) {
        if (t > 1e3) throw new Error("Max limit reached. Request fewer than 1000 alkanes per call");
        const n = Array.from({
            length: t
        }, (s, a)=>a + r), i = async (s)=>{
            const a = {
                id: {
                    block: "2",
                    tx: s.toString()
                }
            };
            let u = !1;
            const f = H_.filter((c)=>c !== void 0);
            try {
                if ((await Promise.all(f.map(async (p, y)=>{
                    if (!p) return null;
                    try {
                        const _ = await this.simulate({
                            target: {
                                block: "2",
                                tx: s.toString()
                            },
                            alkanes: [],
                            transaction: "0x",
                            block: "0x",
                            height: "20000",
                            txindex: 0,
                            inputs: [
                                p
                            ],
                            pointer: 0,
                            refundPointer: 0,
                            vout: 0
                        });
                        if ((_ == null ? void 0 : _.status) === 0) return {
                            opcode: p,
                            result: _,
                            opcodeIndex: y,
                            opcodeHRV: _l[y]
                        };
                    } catch  {
                        return null;
                    }
                }))).filter((p)=>p != null && p.opcodeHRV !== void 0).forEach(({ result: p, opcodeHRV: y })=>{
                    var _, A;
                    y && ([
                        "name",
                        "symbol",
                        "data"
                    ].includes(y) ? a[y] = ((_ = p.parsed) == null ? void 0 : _.string) || "" : a[y] = Number(((A = p.parsed) == null ? void 0 : A.le) || 0), u = !0);
                }), u) return a.mintActive = Number(a.minted || 0) < Number(a.cap || 0), a.percentageMinted = Math.floor((a.minted || 0) / (a.cap || 1) * 100), a;
            } catch (c) {
                return console.log(`Error processing alkane at index ${s}:`, c), null;
            }
            return null;
        }, o = [];
        for await (const s of ene(10, n, i))s !== null && o.push(s);
        return o;
    }
    async meta(t) {
        return await this._call("alkanes_meta", [
            {
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "0x",
                txindex: 0,
                inputs: [],
                pointer: 0,
                refundPointer: 0,
                vout: 0,
                ...t
            }
        ]);
    }
    parseSimulateReturn(t) {
        if (t === "0x") return;
        const r = (o)=>o.startsWith("0x") ? o.slice(2) : o, n = (o)=>"0x" + r(o);
        let i;
        try {
            if (i = We.from(r(t), "hex").toString("utf8"), /[\uFFFD]/.test(i)) throw new Error("Invalid UTF-8 string");
        } catch  {
            i = n(t);
        }
        return {
            string: i,
            bytes: n(t),
            le: BigInt(n(We.from(Array.from(We.from(r(t), "hex")).reverse()).toString("hex"))).toString(),
            be: BigInt(n(t)).toString()
        };
    }
}
function Hae({ block: e, tx: t }) {
    return `${e}:${t}`;
}
class qae {
    constructor(t, r){
        pt(this, "apiUrl", "");
        pt(this, "apiKey", "");
        pt(this, "networks");
        pt(this, "alkanesRpc");
        pt(this, "network");
        this.networks = {
            mainnet: {
                apiUrl: $l("mainnet"),
                apiKey: (r == null ? void 0 : r.apiKey) || ql
            },
            signet: {
                apiUrl: $l("signet"),
                apiKey: (r == null ? void 0 : r.apiKey) || ql
            },
            oylnet: {
                apiUrl: $l("oylnet"),
                apiKey: (r == null ? void 0 : r.apiKey) || "regtest"
            },
            ...r == null ? void 0 : r.networks
        }, this.setNetwork(t), this.alkanesRpc = new EI(`${this.apiUrl}/${this.apiKey}`), this.network = t;
    }
    getName() {
        return _G;
    }
    setNetwork(t) {
        if (this.networks[t]) this.apiUrl = this.networks[t].apiUrl, this.apiKey = this.networks[t].apiKey;
        else {
            const n = t === dt.TESTNET || t === dt.TESTNET4 || t === dt.SIGNET || t === dt.FRACTAL_TESTNET ? dt.SIGNET : dt.MAINNET;
            this.networks[n] ? (this.apiUrl = this.networks[n].apiUrl, this.apiKey = this.networks[n].apiKey) : (this.apiUrl = $l(t), this.apiKey = ql);
        }
        this.alkanesRpc = new EI(`${this.apiUrl}/${this.apiKey}`), this.network = t;
    }
    async call(t, r) {
        console.log("SandshrewDataSource.call", t, r), console.log("SandshrewDataSource.apiUrl", this.apiUrl), console.log("SandshrewDataSource.apiKey", this.apiKey);
        try {
            const n = `${this.apiUrl}/${this.apiKey}`;
            return (await rn.post(n, {
                jsonrpc: "2.0",
                id: t,
                method: t,
                params: r
            }, {
                headers: {
                    "Content-Type": "application/json"
                }
            })).data;
        } catch (n) {
            throw console.error("SandshrewDataSource.callRPC error:", n), n;
        }
    }
    async multicall(t) {
        return (await this.call("sandshrew_multicall", t)).result;
    }
    async getAlkanesByAddress(t) {
        return await this.alkanesRpc.getAlkanesByAddress({
            address: t
        });
    }
    async getAddressBtcBalance(t) {
        const n = (await this.call("esplora_address", [
            t
        ])).result;
        return (BigInt(n.chain_stats.funded_txo_sum) - BigInt(n.chain_stats.spent_txo_sum)).toString();
    }
    async getAddressUtxos(t) {
        const r = await this.call("esplora_address::utxo", [
            t
        ]), n = hs(t, Dr(this.network));
        return r.result.map((o)=>({
                ...o,
                scriptPk: We.from(n).toString("hex")
            }));
    }
    async getOutputValueByVOutIndex(t, r) {
        var o;
        return ((o = (await this.call("esplora_tx", [
            t
        ])).result.vout[r]) == null ? void 0 : o.value) ?? null;
    }
    async getAddressAlkanesBalances(t) {
        const r = await this.getAlkanesByAddress(t), n = {};
        for (const i of r)for (const o of i.runes){
            const s = Hae(o.rune.id);
            n[s] ? n[s].balance += BigInt(o.balance) : n[s] = {
                id: s,
                balance: BigInt(o.balance),
                name: o.rune.name,
                symbol: o.rune.symbol
            };
        }
        return Object.values(n);
    }
    async getTransaction(t) {
        return (await this.call("esplora_tx", [
            t
        ])).result;
    }
    async getRuneById(t) {
        return (await this.call("ord_rune", [
            t
        ])).result;
    }
    async getRuneByName(t) {
        return (await this.call("ord_rune", [
            t
        ])).result;
    }
    async broadcastTransaction(t) {
        return await this.call("broadcast_tx", [
            t
        ]);
    }
    async getOrdAddress(t) {
        return (await this.call("ord_address", [
            t
        ])).result;
    }
    async getTxInfo(t) {
        return (await this.call("esplora_tx", [
            t
        ])).result;
    }
    async batchOrdOutput({ outpoints: t, rune_name: r }) {
        const i = [];
        for(let o = 0; o < t.length; o += 1e3){
            const s = t.slice(o, o + 1e3), a = s.map((c)=>[
                    "ord_output",
                    [
                        c
                    ]
                ]), { result: u } = await this.call("sandshrew_multicall", a);
            for(let c = 0; c < u.length; c++)u[c].result.output = s[c];
            const f = u.filter((c)=>Object.keys(c.result.runes).includes(r));
            i.push(...f);
        }
        return i;
    }
    async batchOrdInscriptionInfo(t) {
        const n = [];
        for(let i = 0; i < t.length; i += 1e3){
            const s = t.slice(i, i + 1e3).map((u)=>[
                    "ord_inscription",
                    [
                        u
                    ]
                ]), { result: a } = await this.call("sandshrew_multicall", s);
            for(let u = 0; u < a.length; u++)n.push(a[u].result);
        }
        return n;
    }
    async getAddressRunesBalances(t) {
        try {
            const n = (await this.getOrdAddress(t)).runes_balances;
            if (!n) throw new Error("No runes data found");
            return n.map((i)=>({
                    name: i[0],
                    balance: i[1],
                    symbol: i[2]
                }));
        } catch (r) {
            throw console.error("Error fetching ord address:", r), r;
        }
    }
    async getInscriptionInfo(t) {
        const n = (await this.call("ord_inscription", [
            t
        ])).result;
        return {
            data: {
                inscription_id: n.id || t,
                inscription_number: n.number || 0,
                created_at: n.timestamp || 0,
                content_type: n.effective_content_type || "",
                content_body_preview: "",
                content_length: n.content_length || 0,
                collection_symbol: null
            },
            last_updated: {
                block_hash: "",
                block_height: n.height || 0
            }
        };
    }
    async getRecommendedFees() {
        const r = (await this.call("esplora_fee-estimates", [])).result, n = r[1] || 0, i = Math.min(...Object.values(r));
        return {
            fastFee: Math.round(n),
            minFee: Math.round(i)
        };
    }
    async getBalances(t) {
        if (Array.isArray(t)) {
            const n = t.map((o)=>[
                    "sandshrew_balances",
                    [
                        {
                            address: o
                        }
                    ]
                ]);
            return (await this.multicall(n)).map((o)=>o.result);
        }
        return [
            (await this.call("sandshrew_balances", [
                {
                    address: t
                }
            ])).result
        ];
    }
    async getRuneOutpoints({ address: t, runeId: r }) {
        const n = await this.getOrdAddress(t), { entry: i } = await this.getRuneById(r), o = i.spaced_rune, s = await this.batchOrdOutput({
            outpoints: n.outputs,
            rune_name: o
        });
        return await this.mapRuneBalances({
            ordOutputs: s
        });
    }
    async mapRuneBalances({ ordOutputs: t }) {
        var n;
        const r = [];
        for(let i = 0; i < t.length; i++){
            const o = t[i], { result: s } = o;
            if (!((n = s.output) != null && n.split(":"))) throw new Error("No output found");
            const { output: a, address: u, runes: f } = s, c = {
                output: a,
                wallet_addr: u,
                script: "",
                balances: [],
                decimals: [],
                rune_ids: [],
                value: s.value
            };
            if (c.script = We.from(oN(u, ln)).toString("hex"), typeof f == "object" && !Array.isArray(f)) for(const l in f)c.balances.push(f[l].amount), c.decimals.push(f[l].divisibility), c.rune_ids.push((await this.getRuneByName(l)).id);
            r.push(c);
        }
        return r;
    }
}
const eo = "Method not available on any data source", su = class su {
    constructor(t){
        pt(this, "dataSources", /* @__PURE__ */ new Map());
        pt(this, "network");
        pt(this, "customNetworks", /* @__PURE__ */ new Map());
        var n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U, D, H;
        const r = (t == null ? void 0 : t.network) || dt.MAINNET;
        this.network = r, this.customNetworks = new Map(Object.entries((t == null ? void 0 : t.customNetworks) || {})), this.dataSources.set("mempool", new Xre(r, {
            networks: {
                mainnet: {
                    apiUrl: ((i = (n = t == null ? void 0 : t.dataSources) == null ? void 0 : n.mempool) == null ? void 0 : i.url) || Bi(dt.MAINNET)
                },
                testnet: {
                    apiUrl: Bi(dt.TESTNET)
                },
                testnet4: {
                    apiUrl: Bi(dt.TESTNET4)
                },
                signet: {
                    apiUrl: Bi(dt.SIGNET)
                },
                "fractal-mainnet": {
                    apiUrl: Bi(dt.FRACTAL_MAINNET)
                },
                "fractal-testnet": {
                    apiUrl: Bi(dt.FRACTAL_TESTNET)
                },
                ...(s = (o = t == null ? void 0 : t.dataSources) == null ? void 0 : o.mempool) == null ? void 0 : s.networks
            }
        })), this.dataSources.set("sandshrew", new qae(r, {
            apiKey: (u = (a = t == null ? void 0 : t.dataSources) == null ? void 0 : a.sandshrew) == null ? void 0 : u.apiKey,
            networks: {
                mainnet: {
                    apiKey: ((c = (f = t == null ? void 0 : t.dataSources) == null ? void 0 : f.sandshrew) == null ? void 0 : c.apiKey) || ql,
                    apiUrl: $l(dt.MAINNET)
                },
                testnet: {
                    apiKey: ((p = (l = t == null ? void 0 : t.dataSources) == null ? void 0 : l.sandshrew) == null ? void 0 : p.apiKey) || ql,
                    apiUrl: $l(dt.TESTNET)
                },
                ...(_ = (y = t == null ? void 0 : t.dataSources) == null ? void 0 : y.sandshrew) == null ? void 0 : _.networks
            }
        })), this.dataSources.set("maestro", new Yre(r, {
            networks: {
                mainnet: {
                    apiKey: ((O = (A = t == null ? void 0 : t.dataSources) == null ? void 0 : A.maestro) == null ? void 0 : O.apiKey) || Bte,
                    apiUrl: cm(dt.MAINNET)
                },
                testnet4: {
                    apiKey: ((U = (N = t == null ? void 0 : t.dataSources) == null ? void 0 : N.maestro) == null ? void 0 : U.testnetApiKey) || $P,
                    apiUrl: cm(dt.TESTNET4)
                },
                ...(H = (D = t == null ? void 0 : t.dataSources) == null ? void 0 : D.maestro) == null ? void 0 : H.networks
            }
        }));
    }
    static init(t) {
        su.instance || (su.instance = new su(t));
    }
    static getInstance() {
        if (!su.instance) throw new Error("DataSourceManager has not been initialized");
        return su.instance;
    }
    updateNetwork(t) {
        var n, i;
        this.network = t;
        const r = (n = this.customNetworks.get(t)) == null ? void 0 : n.baseNetwork;
        for (const o of this.dataSources.values())(i = o.setNetwork) == null || i.call(o, t, r);
    }
    registerDataSource(t, r) {
        var n, i, o;
        this.dataSources.set(t, r), (o = (n = this.dataSources.get(t)) == null ? void 0 : n.setNetwork) == null || o.call(n, this.network, (i = this.customNetworks.get(this.network)) == null ? void 0 : i.baseNetwork);
    }
    getSource(t) {
        return this.dataSources.get(t);
    }
    async getAddressAlkanesBalances(t) {
        const r = this.findAvailableSource("getAddressAlkanesBalances");
        if (!r || !r.getAddressAlkanesBalances) throw new Error(eo);
        return await r.getAddressAlkanesBalances(t);
    }
    async getAlkanesByAddress(t) {
        const r = this.findAvailableSource("getAlkanesByAddress");
        if (!r || !r.getAlkanesByAddress) throw new Error(eo);
        return await r.getAlkanesByAddress(t);
    }
    async getAddressBtcBalance(t) {
        const r = this.findAvailableSource("getAddressBtcBalance");
        if (!r || !r.getAddressBtcBalance) throw new Error(eo);
        const n = await this.withFallback("sandshrew", async (i)=>{
            var o;
            return await ((o = i.getAddressBtcBalance) == null ? void 0 : o.call(i, t));
        });
        if (n === void 0) throw new Error("Unable to get balance from any data source");
        return n;
    }
    async getAddressBrc20Balances(t) {
        const r = this.findAvailableSource("getAddressBrc20Balances");
        if (!r || !r.getAddressBrc20Balances) throw new Error(eo);
        const n = await r.getAddressBrc20Balances(t);
        return Zre(n);
    }
    async getAddressInscriptions(t, r, n) {
        const i = this.findAvailableSource("getAddressInscriptions");
        if (!i || !i.getAddressInscriptions) throw new Error(eo);
        if (!i.getInscriptionInfo) throw new Error(eo);
        const o = dt.MAINNET, s = await i.getAddressInscriptions(t, r, n), a = i.getName();
        return a === t9 && s.data ? (await Promise.all(s.data.map(async (f)=>{
            try {
                if (!i.getInscriptionInfo) throw new Error(eo);
                const c = await i.getInscriptionInfo(f.inscription_id);
                return {
                    ...f,
                    ...c.data
                };
            } catch (c) {
                return console.error(`Failed to fetch details for inscription ${f.inscription_id}:`, c), f;
            }
        }))).map((f)=>Kl(f, a, o)) : s.inscriptions ? s.inscriptions.map((u)=>Kl(u, a, o)) : Array.isArray(s) ? s.map((u)=>Kl(u, a, o)) : (console.warn("Unable to normalize inscriptions from data source", a), []);
    }
    async getInscriptionInfo(t) {
        const r = this.findAvailableSource("getInscriptionInfo");
        if (!r || !r.getInscriptionInfo) throw new Error(eo);
        return await r.getInscriptionInfo(t);
    }
    async getRecommendedFees() {
        const t = this.findAvailableSource("getRecommendedFees");
        if (!t || !t.getRecommendedFees) throw new Error(eo);
        console.log("getting recommended fees");
        const r = await this.withFallback("sandshrew", async (n)=>{
            var i;
            return await ((i = n.getRecommendedFees) == null ? void 0 : i.call(n));
        });
        if (r === void 0) throw new Error("Unable to get recommended fees from any data source");
        return {
            fastFee: r.fastFee,
            minFee: r.minFee
        };
    }
    async getAddressUtxos(t) {
        const r = this.findAvailableSource("getAddressUtxos");
        if (!r || !r.getAddressUtxos) throw new Error(eo);
        const n = await this.withFallback("sandshrew", async (i)=>{
            var o;
            return await ((o = i.getAddressUtxos) == null ? void 0 : o.call(i, t));
        });
        if (n === void 0) throw new Error("Unable to get utxos from any data source");
        return n;
    }
    async getOutputValueByVOutIndex(t, r) {
        const n = this.findAvailableSource("getOutputValueByVOutIndex");
        if (!n || !n.getOutputValueByVOutIndex) throw new Error(eo);
        const i = await this.withFallback("sandshrew", async (o)=>{
            var s;
            return await ((s = o.getOutputValueByVOutIndex) == null ? void 0 : s.call(o, t, r));
        });
        if (i === void 0) throw new Error("Unable to get output value from any data source");
        return i;
    }
    async waitForTransaction(t) {
        const r = this.findAvailableSource("waitForTransaction");
        if (!r || !r.waitForTransaction) throw new Error(eo);
        return !!await r.waitForTransaction(t);
    }
    async getAddressRunesBalances(t) {
        const r = this.findAvailableSource("getAddressRunesBalances");
        if (!r || !r.getAddressRunesBalances) throw new Error(eo);
        return await r.getAddressRunesBalances(t);
    }
    async broadcastTransaction(t) {
        const r = this.findAvailableSource("broadcastTransaction");
        if (!r || !r.broadcastTransaction) throw new Error(eo);
        return await r.broadcastTransaction(t);
    }
    async withFallback(t, r) {
        const n = [
            t,
            ...Array.from(this.dataSources.keys()).filter((i)=>i !== t)
        ];
        for (const i of n)try {
            const o = this.getSource(i);
            if (!o) continue;
            return await r(o);
        } catch (o) {
            console.warn(`Fallback: ${i} failed`, o);
        }
        throw new Error("All data sources failed");
    }
    findAvailableSource(t) {
        const r = this.customNetworks.get(this.network);
        if (r) {
            const n = this.getSource(r.preferredDataSource);
            if (n && typeof n[t] == "function") return n;
        }
        for (const n of this.dataSources.values())if (typeof n[t] == "function") return n;
    }
    async getFormattedUTXOs(t) {
        const r = this.getSource("sandshrew");
        if (!r || !r.getBalances) throw new Error("Sandshrew data source with getBalances method is required");
        const n = await r.getBalances(t), i = [], o = Array.isArray(t) ? [
            ...new Set(t)
        ] : [
            t
        ];
        for(let s = 0; s < n.length; s++){
            const a = n[s], u = o[s], f = a.metashrewHeight, c = We.from(Gre(u, this.network)).toString("hex");
            for (const l of a.spendable){
                const [p, y] = l.outpoint.split(":");
                i.push({
                    txHash: p,
                    txOutputIndex: parseInt(y),
                    btcValue: l.value,
                    scriptPubKey: c,
                    address: u,
                    hasRunes: !1,
                    runes: [],
                    hasAlkanes: !1,
                    // No alkanes info in sandshrew_balances
                    alkanes: [],
                    hasInscriptions: !1,
                    inscriptions: [],
                    confirmations: l.height ? f - l.height : void 0
                });
            }
            for (const l of a.assets){
                const [p, y] = l.outpoint.split(":"), _ = (l.inscriptions || []).map((N)=>({
                        inscriptionId: N
                    })), A = [];
                if (l.ord_runes) for (const [N, U] of Object.entries(l.ord_runes))A.push({
                    runeId: N,
                    // Using name as ID
                    amount: U.amount
                });
                const O = [];
                if (l.runes) for (const N of l.runes)O.push({
                    id: parseInt(N.rune.id.block, 16) + ":" + parseInt(N.rune.id.tx, 16),
                    amount: parseInt(N.balance, 16),
                    // Convert hex to number
                    name: N.rune.name,
                    symbol: N.rune.symbol
                });
                i.push({
                    txHash: p,
                    txOutputIndex: parseInt(y),
                    btcValue: l.value,
                    scriptPubKey: c,
                    address: u,
                    hasRunes: A.length > 0,
                    runes: A,
                    hasAlkanes: O.length > 0,
                    alkanes: O,
                    hasInscriptions: _.length > 0,
                    inscriptions: _,
                    confirmations: l.height ? f - l.height : void 0
                });
            }
        }
        return i.sort((s, a)=>s.btcValue - a.btcValue), i;
    }
};
pt(su, "instance");
let nc = su;
const Kae = (e)=>/^(?:[A-Za-z0-9+/]{4})*?(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e), Wae = (e)=>/^[a-fA-F0-9]+$/.test(e), Vu = (e)=>{
    const t = [];
    let r = e;
    do {
        let n = r & BigInt(127);
        r >>= BigInt(7), r !== BigInt(0) && (n |= BigInt(128)), t.push(Number(n));
    }while (r !== BigInt(0))
    return {
        varint: We.from(t)
    };
};
function Sf(e) {
    return Object.fromEntries(Object.entries(e).filter(([t, r])=>r !== void 0));
}
const Vae = (e)=>{
    let t = 0n;
    const r = [];
    for (const n of e)n.inscriptions.length <= 0 && n.runes.length <= 0 && n.alkanes.length <= 0 && n.btcValue !== 546 && n.btcValue !== 330 && (r.push(n), t += BigInt(n.btcValue));
    return {
        utxos: r,
        totalAmount: t
    };
};
var ec = {}, eM = {}, bS = {};
(function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0, e.assertNumber = t;
    // @__NO_SIDE_EFFECTS__
    function t(S) {
        if (!Number.isSafeInteger(S)) throw new Error(`Wrong integer: ${S}`);
    }
    function r(S) {
        return S instanceof Uint8Array || S != null && typeof S == "object" && S.constructor.name === "Uint8Array";
    }
    // @__NO_SIDE_EFFECTS__
    function n(...S) {
        const w = (T)=>T, g = (T, I)=>(P)=>T(I(P)), m = S.map((T)=>T.encode).reduceRight(g, w), E = S.map((T)=>T.decode).reduce(g, w);
        return {
            encode: m,
            decode: E
        };
    }
    // @__NO_SIDE_EFFECTS__
    function i(S) {
        return {
            encode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
                return w.map((g)=>{
                    if (g < 0 || g >= S.length) throw new Error(`Digit index outside alphabet: ${g} (alphabet: ${S.length})`);
                    return S[g];
                });
            },
            decode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "string") throw new Error("alphabet.decode input should be array of strings");
                return w.map((g)=>{
                    if (typeof g != "string") throw new Error(`alphabet.decode: not string element=${g}`);
                    const m = S.indexOf(g);
                    if (m === -1) throw new Error(`Unknown letter: "${g}". Allowed: ${S}`);
                    return m;
                });
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function o(S = "") {
        if (typeof S != "string") throw new Error("join separator should be string");
        return {
            encode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "string") throw new Error("join.encode input should be array of strings");
                for (let g of w)if (typeof g != "string") throw new Error(`join.encode: non-string input=${g}`);
                return w.join(S);
            },
            decode: (w)=>{
                if (typeof w != "string") throw new Error("join.decode input should be string");
                return w.split(S);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function s(S, w = "=") {
        if (typeof w != "string") throw new Error("padding chr should be string");
        return {
            encode (g) {
                if (!Array.isArray(g) || g.length && typeof g[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let m of g)if (typeof m != "string") throw new Error(`padding.encode: non-string input=${m}`);
                for(; g.length * S % 8;)g.push(w);
                return g;
            },
            decode (g) {
                if (!Array.isArray(g) || g.length && typeof g[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let E of g)if (typeof E != "string") throw new Error(`padding.decode: non-string input=${E}`);
                let m = g.length;
                if (m * S % 8) throw new Error("Invalid padding: string should have whole number of bytes");
                for(; m > 0 && g[m - 1] === w; m--)if (!((m - 1) * S % 8)) throw new Error("Invalid padding: string has too much padding");
                return g.slice(0, m);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function a(S) {
        if (typeof S != "function") throw new Error("normalize fn should be function");
        return {
            encode: (w)=>w,
            decode: (w)=>S(w)
        };
    }
    // @__NO_SIDE_EFFECTS__
    function u(S, w, g) {
        if (w < 2) throw new Error(`convertRadix: wrong from=${w}, base cannot be less than 2`);
        if (g < 2) throw new Error(`convertRadix: wrong to=${g}, base cannot be less than 2`);
        if (!Array.isArray(S)) throw new Error("convertRadix: data should be array");
        if (!S.length) return [];
        let m = 0;
        const E = [], T = Array.from(S);
        for(T.forEach((I)=>{
            if (I < 0 || I >= w) throw new Error(`Wrong integer: ${I}`);
        });;){
            let I = 0, P = !0;
            for(let k = m; k < T.length; k++){
                const L = T[k], j = w * I + L;
                if (!Number.isSafeInteger(j) || w * I / w !== I || j - L !== w * I) throw new Error("convertRadix: carry overflow");
                I = j % g;
                const ie = Math.floor(j / g);
                if (T[k] = ie, !Number.isSafeInteger(ie) || ie * g + I !== j) throw new Error("convertRadix: carry overflow");
                if (P) ie ? P = !1 : m = k;
                else continue;
            }
            if (E.push(I), P) break;
        }
        for(let I = 0; I < S.length - 1 && S[I] === 0; I++)E.push(0);
        return E.reverse();
    }
    const f = /* @__NO_SIDE_EFFECTS__ */ (S, w)=>w ? /* @__PURE__ */ f(w, S % w) : S, c = /* @__NO_SIDE_EFFECTS__ */ (S, w)=>S + (w - /* @__PURE__ */ f(S, w));
    // @__NO_SIDE_EFFECTS__
    function l(S, w, g, m) {
        if (!Array.isArray(S)) throw new Error("convertRadix2: data should be array");
        if (w <= 0 || w > 32) throw new Error(`convertRadix2: wrong from=${w}`);
        if (g <= 0 || g > 32) throw new Error(`convertRadix2: wrong to=${g}`);
        if (/* @__PURE__ */ c(w, g) > 32) throw new Error(`convertRadix2: carry overflow from=${w} to=${g} carryBits=${/* @__PURE__ */ c(w, g)}`);
        let E = 0, T = 0;
        const I = 2 ** g - 1, P = [];
        for (const k of S){
            if (k >= 2 ** w) throw new Error(`convertRadix2: invalid data word=${k} from=${w}`);
            if (E = E << w | k, T + w > 32) throw new Error(`convertRadix2: carry overflow pos=${T} from=${w}`);
            for(T += w; T >= g; T -= g)P.push((E >> T - g & I) >>> 0);
            E &= 2 ** T - 1;
        }
        if (E = E << g - T & I, !m && T >= w) throw new Error("Excess padding");
        if (!m && E) throw new Error(`Non-zero padding: ${E}`);
        return m && T > 0 && P.push(E >>> 0), P;
    }
    // @__NO_SIDE_EFFECTS__
    function p(S) {
        return {
            encode: (w)=>{
                if (!r(w)) throw new Error("radix.encode input should be Uint8Array");
                return /* @__PURE__ */ u(Array.from(w), 2 ** 8, S);
            },
            decode: (w)=>{
                if (!Array.isArray(w) || w.length && typeof w[0] != "number") throw new Error("radix.decode input should be array of numbers");
                return Uint8Array.from(/* @__PURE__ */ u(w, S, 2 ** 8));
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function y(S, w = !1) {
        if (S <= 0 || S > 32) throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ c(8, S) > 32 || /* @__PURE__ */ c(S, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (g)=>{
                if (!r(g)) throw new Error("radix2.encode input should be Uint8Array");
                return /* @__PURE__ */ l(Array.from(g), 8, S, !w);
            },
            decode: (g)=>{
                if (!Array.isArray(g) || g.length && typeof g[0] != "number") throw new Error("radix2.decode input should be array of numbers");
                return Uint8Array.from(/* @__PURE__ */ l(g, S, 8, w));
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function _(S) {
        if (typeof S != "function") throw new Error("unsafeWrapper fn should be function");
        return function(...w) {
            try {
                return S.apply(null, w);
            } catch  {}
        };
    }
    // @__NO_SIDE_EFFECTS__
    function A(S, w) {
        if (typeof w != "function") throw new Error("checksum fn should be function");
        return {
            encode (g) {
                if (!r(g)) throw new Error("checksum.encode: input should be Uint8Array");
                const m = w(g).slice(0, S), E = new Uint8Array(g.length + S);
                return E.set(g), E.set(m, g.length), E;
            },
            decode (g) {
                if (!r(g)) throw new Error("checksum.decode: input should be Uint8Array");
                const m = g.slice(0, -S), E = w(m).slice(0, S), T = g.slice(-S);
                for(let I = 0; I < S; I++)if (E[I] !== T[I]) throw new Error("Invalid checksum");
                return m;
            }
        };
    }
    e.utils = {
        alphabet: i,
        chain: n,
        checksum: A,
        convertRadix: u,
        convertRadix2: l,
        radix: p,
        radix2: y,
        join: o,
        padding: s
    }, e.base16 = /* @__PURE__ */ n(/* @__PURE__ */ y(4), /* @__PURE__ */ i("0123456789ABCDEF"), /* @__PURE__ */ o("")), e.base32 = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ s(5), /* @__PURE__ */ o("")), e.base32nopad = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ o("")), e.base32hex = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ s(5), /* @__PURE__ */ o("")), e.base32hexnopad = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ o("")), e.base32crockford = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ o(""), /* @__PURE__ */ a((S)=>S.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ s(6), /* @__PURE__ */ o("")), e.base64nopad = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ o("")), e.base64url = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ s(6), /* @__PURE__ */ o("")), e.base64urlnopad = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ o(""));
    const O = (S)=>/* @__PURE__ */ n(/* @__PURE__ */ p(58), /* @__PURE__ */ i(S), /* @__PURE__ */ o(""));
    e.base58 = O("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = O("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = O("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const N = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    e.base58xmr = {
        encode (S) {
            let w = "";
            for(let g = 0; g < S.length; g += 8){
                const m = S.subarray(g, g + 8);
                w += e.base58.encode(m).padStart(N[m.length], "1");
            }
            return w;
        },
        decode (S) {
            let w = [];
            for(let g = 0; g < S.length; g += 11){
                const m = S.slice(g, g + 11), E = N.indexOf(m.length), T = e.base58.decode(m);
                for(let I = 0; I < T.length - E; I++)if (T[I] !== 0) throw new Error("base58xmr: wrong padding");
                w = w.concat(Array.from(T.slice(T.length - E)));
            }
            return Uint8Array.from(w);
        }
    };
    const U = (S)=>/* @__PURE__ */ n(/* @__PURE__ */ A(4, (w)=>S(S(w))), e.base58);
    e.createBase58check = U, e.base58check = e.createBase58check;
    const D = /* @__PURE__ */ n(/* @__PURE__ */ i("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ o("")), H = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    // @__NO_SIDE_EFFECTS__
    function K(S) {
        const w = S >> 25;
        let g = (S & 33554431) << 5;
        for(let m = 0; m < H.length; m++)(w >> m & 1) === 1 && (g ^= H[m]);
        return g;
    }
    // @__NO_SIDE_EFFECTS__
    function re(S, w, g = 1) {
        const m = S.length;
        let E = 1;
        for(let T = 0; T < m; T++){
            const I = S.charCodeAt(T);
            if (I < 33 || I > 126) throw new Error(`Invalid prefix (${S})`);
            E = /* @__PURE__ */ K(E) ^ I >> 5;
        }
        E = /* @__PURE__ */ K(E);
        for(let T = 0; T < m; T++)E = /* @__PURE__ */ K(E) ^ S.charCodeAt(T) & 31;
        for (let T of w)E = /* @__PURE__ */ K(E) ^ T;
        for(let T = 0; T < 6; T++)E = /* @__PURE__ */ K(E);
        return E ^= g, D.encode(/* @__PURE__ */ l([
            E % 2 ** 30
        ], 30, 5, !1));
    }
    // @__NO_SIDE_EFFECTS__
    function Q(S) {
        const w = S === "bech32" ? 1 : 734539939, g = /* @__PURE__ */ y(5), m = g.decode, E = g.encode, T = /* @__PURE__ */ _(m);
        function I(ie, ue, ce = 90) {
            if (typeof ie != "string") throw new Error(`bech32.encode prefix should be string, not ${typeof ie}`);
            if (ue instanceof Uint8Array && (ue = Array.from(ue)), !Array.isArray(ue) || ue.length && typeof ue[0] != "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof ue}`);
            if (ie.length === 0) throw new TypeError(`Invalid prefix length ${ie.length}`);
            const he = ie.length + 7 + ue.length;
            if (ce !== !1 && he > ce) throw new TypeError(`Length ${he} exceeds limit ${ce}`);
            const ee = ie.toLowerCase(), ae = /* @__PURE__ */ re(ee, ue, w);
            return `${ee}1${D.encode(ue)}${ae}`;
        }
        function P(ie, ue = 90) {
            if (typeof ie != "string") throw new Error(`bech32.decode input should be string, not ${typeof ie}`);
            if (ie.length < 8 || ue !== !1 && ie.length > ue) throw new TypeError(`Wrong string length: ${ie.length} (${ie}). Expected (8..${ue})`);
            const ce = ie.toLowerCase();
            if (ie !== ce && ie !== ie.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const he = ce.lastIndexOf("1");
            if (he === 0 || he === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const ee = ce.slice(0, he), ae = ce.slice(he + 1);
            if (ae.length < 6) throw new Error("Data must be at least 6 characters long");
            const ye = D.decode(ae).slice(0, -6), Se = /* @__PURE__ */ re(ee, ye, w);
            if (!ae.endsWith(Se)) throw new Error(`Invalid checksum in ${ie}: expected "${Se}"`);
            return {
                prefix: ee,
                words: ye
            };
        }
        const k = /* @__PURE__ */ _(P);
        function L(ie) {
            const { prefix: ue, words: ce } = P(ie, !1);
            return {
                prefix: ue,
                words: ce,
                bytes: m(ce)
            };
        }
        function j(ie, ue) {
            return I(ie, E(ue));
        }
        return {
            encode: I,
            decode: P,
            encodeFromBytes: j,
            decodeToBytes: L,
            decodeUnsafe: k,
            fromWords: m,
            fromWordsUnsafe: T,
            toWords: E
        };
    }
    e.bech32 = /* @__PURE__ */ Q("bech32"), e.bech32m = /* @__PURE__ */ Q("bech32m"), e.utf8 = {
        encode: (S)=>new TextDecoder().decode(S),
        decode: (S)=>new TextEncoder().encode(S)
    }, e.hex = /* @__PURE__ */ n(/* @__PURE__ */ y(4), /* @__PURE__ */ i("0123456789abcdef"), /* @__PURE__ */ o(""), /* @__PURE__ */ a((S)=>{
        if (typeof S != "string" || S.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof S} with length ${S.length}`);
        return S.toLowerCase();
    }));
    const G = {
        utf8: e.utf8,
        hex: e.hex,
        base16: e.base16,
        base32: e.base32,
        base64: e.base64,
        base64url: e.base64url,
        base58: e.base58,
        base58xmr: e.base58xmr
    }, R = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", X = (S, w)=>{
        if (typeof S != "string" || !G.hasOwnProperty(S)) throw new TypeError(R);
        if (!r(w)) throw new TypeError("bytesToString() expects Uint8Array");
        return G[S].encode(w);
    };
    e.bytesToString = X, e.str = e.bytesToString;
    const $ = (S, w)=>{
        if (!G.hasOwnProperty(S)) throw new TypeError(R);
        if (typeof w != "string") throw new TypeError("stringToBytes() expects string");
        return G[S].decode(w);
    };
    e.stringToBytes = $, e.bytes = e.stringToBytes;
})(bS);
var wS = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.constant = e.magicBytes = e.magic = e.optional = e.flagged = e.flag = e.lazy = e.apply = e.hex = e.cstring = e.string = e.prefix = e.bytes = e.bool = e.F64LE = e.F64BE = e.F32LE = e.F32BE = e.I8 = e.U8 = e.I16BE = e.I16LE = e.U16BE = e.U16LE = e.I32BE = e.I32LE = e.U32BE = e.U32LE = e.int = e.I64BE = e.I64LE = e.U64BE = e.U64LE = e.I128BE = e.I128LE = e.U128BE = e.U128LE = e.I256BE = e.I256LE = e.U256BE = e.U256LE = e.bigint = e.bits = e.coders = e.isCoder = e.wrap = e.validate = e.utils = e.NULL = e.EMPTY = void 0, e._TEST = e.pointer = e.padRight = e.padLeft = e.ZeroPad = e.bitset = e.mappedTag = e.tag = e.map = e.array = e.tuple = e.struct = void 0;
    const t = bS;
    e.EMPTY = new Uint8Array(), e.NULL = new Uint8Array([
        0
    ]);
    function r(h, x) {
        if (h.length !== x.length) return !1;
        for(let q = 0; q < h.length; q++)if (h[q] !== x[q]) return !1;
        return !0;
    }
    function n(h) {
        return h instanceof Uint8Array || h != null && typeof h == "object" && h.constructor.name === "Uint8Array";
    }
    function i(...h) {
        let x = 0;
        for(let te = 0; te < h.length; te++){
            const fe = h[te];
            if (!n(fe)) throw new Error("Uint8Array expected");
            x += fe.length;
        }
        const q = new Uint8Array(x);
        for(let te = 0, fe = 0; te < h.length; te++){
            const ne = h[te];
            q.set(ne, fe), fe += ne.length;
        }
        return q;
    }
    const o = (h)=>new DataView(h.buffer, h.byteOffset, h.byteLength);
    function s(h) {
        return Object.prototype.toString.call(h) === "[object Object]";
    }
    function a(h) {
        return Number.isSafeInteger(h);
    }
    e.utils = {
        equalBytes: r,
        isBytes: n,
        isCoder: D,
        checkBounds: _,
        concatBytes: i,
        createView: o,
        isPlainObject: s
    };
    const u = (h)=>{
        if (h !== null && typeof h != "string" && !D(h) && !n(h) && !a(h)) throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${h} (${typeof h})`);
        return {
            encodeStream (x, q) {
                if (h === null) return;
                if (D(h)) return h.encodeStream(x, q);
                let te;
                if (typeof h == "number" ? te = h : typeof h == "string" && (te = c.resolve(x.stack, h)), typeof te == "bigint" && (te = Number(te)), te === void 0 || te !== q) throw x.err(`Wrong length: ${te} len=${h} exp=${q} (${typeof q})`);
            },
            decodeStream (x) {
                let q;
                if (D(h) ? q = Number(h.decodeStream(x)) : typeof h == "number" ? q = h : typeof h == "string" && (q = c.resolve(x.stack, h)), typeof q == "bigint" && (q = Number(q)), typeof q != "number") throw x.err(`Wrong length: ${q}`);
                return q;
            }
        };
    }, f = {
        BITS: 32,
        FULL_MASK: -1 >>> 0,
        // 1<<32 will overflow
        len: (h)=>Math.ceil(h / 32),
        create: (h)=>new Uint32Array(f.len(h)),
        clean: (h)=>h.fill(0),
        debug: (h)=>Array.from(h).map((x)=>(x >>> 0).toString(2).padStart(32, "0")),
        checkLen: (h, x)=>{
            if (f.len(x) !== h.length) throw new Error(`wrong length=${h.length}. Expected: ${f.len(x)}`);
        },
        chunkLen: (h, x, q)=>{
            if (x < 0) throw new Error(`wrong pos=${x}`);
            if (x + q > h) throw new Error(`wrong range=${x}/${q} of ${h}`);
        },
        set: (h, x, q, te = !0)=>!te && h[x] & q ? !1 : (h[x] |= q, !0),
        pos: (h, x)=>({
                chunk: Math.floor((h + x) / 32),
                mask: 1 << 32 - (h + x) % 32 - 1
            }),
        indices: (h, x, q = !1)=>{
            f.checkLen(h, x);
            const { FULL_MASK: te, BITS: fe } = f, ne = fe - x % fe, W = ne ? te >>> ne << ne : te, J = [];
            for(let V = 0; V < h.length; V++){
                let C = h[V];
                if (q && (C = ~C), V === h.length - 1 && (C &= W), C !== 0) for(let Z = 0; Z < fe; Z++){
                    const le = 1 << fe - Z - 1;
                    C & le && J.push(V * fe + Z);
                }
            }
            return J;
        },
        range: (h)=>{
            const x = [];
            let q;
            for (const te of h)q === void 0 || te !== q.pos + q.length ? x.push(q = {
                pos: te,
                length: 1
            }) : q.length += 1;
            return x;
        },
        rangeDebug: (h, x, q = !1)=>`[${f.range(f.indices(h, x, q)).map((te)=>`(${te.pos}/${te.length})`).join(", ")}]`,
        setRange: (h, x, q, te, fe = !0)=>{
            f.chunkLen(x, q, te);
            const { FULL_MASK: ne, BITS: W } = f, J = q % W ? Math.floor(q / W) : void 0, V = q + te, C = V % W ? Math.floor(V / W) : void 0;
            if (J !== void 0 && J === C) return f.set(h, J, ne >>> W - te << W - te - q, fe);
            if (J !== void 0 && !f.set(h, J, ne >>> q % W, fe)) return !1;
            const Z = J !== void 0 ? J + 1 : q / W, le = C !== void 0 ? C : V / W;
            for(let se = Z; se < le; se++)if (!f.set(h, se, ne, fe)) return !1;
            return !(C !== void 0 && J !== C && !f.set(h, C, ne << W - V % W, fe));
        }
    }, c = {
        /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */ pushObj: (h, x, q)=>{
            const te = {
                obj: x
            };
            h.push(te), q((fe, ne)=>{
                te.field = fe, ne(), te.field = void 0;
            }), h.pop();
        },
        path: (h)=>{
            const x = [];
            for (const q of h)q.field !== void 0 && x.push(q.field);
            return x.join("/");
        },
        err (h, x, q) {
            const te = new Error(`${h}(${c.path(x)}): ${typeof q == "string" ? q : q.message}`);
            return q instanceof Error && q.stack && (te.stack = q.stack), te;
        },
        resolve: (h, x)=>{
            const q = x.split("/"), te = h.map((W)=>W.obj);
            let fe = 0;
            for(; fe < q.length && q[fe] === ".."; fe++)te.pop();
            let ne = te.pop();
            for(; fe < q.length; fe++){
                if (!ne || ne[q[fe]] === void 0) return;
                ne = ne[q[fe]];
            }
            return ne;
        }
    };
    class l {
        constructor(x, q = {}, te = [], fe = void 0, ne = 0){
            this.data = x, this.opts = q, this.stack = te, this.parent = fe, this.parentOffset = ne, this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.view = o(x);
        }
        /**
     * Internal method for pointers.
     */ _enablePointers() {
            if (this.parent) return this.parent._enablePointers();
            this.bs || (this.bs = f.create(this.data.length), f.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
        }
        markBytesBS(x, q) {
            return this.parent ? this.parent.markBytesBS(this.parentOffset + x, q) : !q || !this.bs ? !0 : f.setRange(this.bs, this.data.length, x, q, !1);
        }
        markBytes(x) {
            const q = this.pos;
            this.pos += x;
            const te = this.markBytesBS(q, x);
            if (!this.opts.allowMultipleReads && !te) throw this.err(`multiple read pos=${this.pos} len=${x}`);
            return te;
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        readView(x, q) {
            if (!Number.isFinite(x)) throw this.err(`readView: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readView: Unexpected end of buffer");
            const te = q(this.view, this.pos);
            return this.markBytes(x), te;
        }
        // read bytes by absolute offset
        absBytes(x) {
            if (x > this.data.length) throw new Error("Unexpected end of buffer");
            return this.data.subarray(x);
        }
        finish() {
            if (!this.opts.allowUnreadBytes) {
                if (this.bitPos) throw this.err(`${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
                if (this.bs && !this.parent) {
                    const x = f.indices(this.bs, this.data.length, !0);
                    if (x.length) {
                        const q = f.range(x).map(({ pos: te, length: fe })=>`(${te}/${fe})[${t.hex.encode(this.data.subarray(te, te + fe))}]`).join(", ");
                        throw this.err(`unread byte ranges: ${q} (total=${this.data.length})`);
                    } else return;
                }
                if (!this.isEnd()) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
            }
        }
        // User methods
        err(x) {
            return c.err("Reader", this.stack, x);
        }
        offsetReader(x) {
            if (x > this.data.length) throw this.err("offsetReader: Unexpected end of buffer");
            return new l(this.absBytes(x), this.opts, this.stack, this, x);
        }
        bytes(x, q = !1) {
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(x)) throw this.err(`readBytes: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const te = this.data.subarray(this.pos, this.pos + x);
            return q || this.markBytes(x), te;
        }
        byte(x = !1) {
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            if (this.pos + 1 > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const q = this.data[this.pos];
            return x || this.markBytes(1), q;
        }
        get leftBytes() {
            return this.data.length - this.pos;
        }
        get totalBytes() {
            return this.data.length;
        }
        isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
        }
        // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
        bits(x) {
            if (x > 32) throw this.err("BitReader: cannot read more than 32 bits in single call");
            let q = 0;
            for(; x;){
                this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
                const te = Math.min(x, this.bitPos);
                this.bitPos -= te, q = q << te | this.bitBuf >> this.bitPos & 2 ** te - 1, this.bitBuf &= 2 ** this.bitPos - 1, x -= te;
            }
            return q >>> 0;
        }
        find(x, q = this.pos) {
            if (!n(x)) throw this.err(`find: needle is not bytes! ${x}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!x.length) throw this.err("find: needle is empty");
            for(let te = q; (te = this.data.indexOf(x[0], te)) !== -1; te++){
                if (te === -1 || this.data.length - te < x.length) return;
                if (r(x, this.data.subarray(te, te + x.length))) return te;
            }
        }
    }
    class p {
        constructor(x = []){
            this.stack = x, this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = !1, this.view = o(this.viewBuf);
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        writeView(x, q) {
            if (this.finished) throw this.err("buffer: finished");
            if (!a(x) || x > 8) throw new Error(`wrong writeView length=${x}`);
            q(this.view), this.bytes(this.viewBuf.slice(0, x)), this.viewBuf.fill(0);
        }
        // User methods
        err(x) {
            if (this.finished) throw this.err("buffer: finished");
            return c.err("Reader", this.stack, x);
        }
        bytes(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(x), this.pos += x.length;
        }
        byte(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([
                x
            ])), this.pos++;
        }
        finish(x = !0) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("buffer: ends with non-empty bit buffer");
            const q = this.buffers.concat(this.ptrs.map((ne)=>ne.buffer)), te = q.map((ne)=>ne.length).reduce((ne, W)=>ne + W, 0), fe = new Uint8Array(te);
            for(let ne = 0, W = 0; ne < q.length; ne++){
                const J = q[ne];
                fe.set(J, W), W += J.length;
            }
            for(let ne = this.pos, W = 0; W < this.ptrs.length; W++){
                const J = this.ptrs[W];
                fe.set(J.ptr.encode(ne), J.pos), ne += J.buffer.length;
            }
            if (x) {
                this.buffers = [];
                for (const ne of this.ptrs)ne.buffer.fill(0);
                this.ptrs = [], this.finished = !0, this.bitBuf = 0;
            }
            return fe;
        }
        bits(x, q) {
            if (q > 32) throw this.err("writeBits: cannot write more than 32 bits in single call");
            if (x >= 2 ** q) throw this.err(`writeBits: value (${x}) >= 2**bits (${q})`);
            for(; q;){
                const te = Math.min(q, 8 - this.bitPos);
                this.bitBuf = this.bitBuf << te | x >> q - te, this.bitPos += te, q -= te, x &= 2 ** q - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([
                    this.bitBuf
                ])), this.pos++);
            }
        }
    }
    const y = (h)=>Uint8Array.from(h).reverse();
    function _(h, x, q) {
        if (q) {
            const te = 2n ** (x - 1n);
            if (h < -te || h >= te) throw new Error(`value out of signed bounds. Expected ${-te} <= ${h} < ${te}`);
        } else if (0n > h || h >= 2n ** x) throw new Error(`value out of unsigned bounds. Expected 0 <= ${h} < ${2n ** x}`);
    }
    function A(h) {
        return {
            // NOTE: we cannot export validate here, since it is likely mistake.
            encodeStream: h.encodeStream,
            decodeStream: h.decodeStream,
            size: h.size,
            encode: (x)=>{
                const q = new p();
                return h.encodeStream(q, x), q.finish();
            },
            decode: (x, q = {})=>{
                const te = new l(x, q), fe = h.decodeStream(te);
                return te.finish(), fe;
            }
        };
    }
    function O(h, x) {
        if (!D(h)) throw new Error(`validate: invalid inner value ${h}`);
        if (typeof x != "function") throw new Error("validate: fn should be function");
        return A({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x(te);
                } catch (ne) {
                    throw q.err(ne);
                }
                h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x(te);
                } catch (fe) {
                    throw q.err(fe);
                }
            }
        });
    }
    e.validate = O;
    const N = (h)=>{
        const x = A(h);
        return h.validate ? O(x, h.validate) : x;
    };
    e.wrap = N;
    const U = (h)=>s(h) && typeof h.decode == "function" && typeof h.encode == "function";
    function D(h) {
        return s(h) && U(h) && typeof h.encodeStream == "function" && typeof h.decodeStream == "function" && (h.size === void 0 || a(h.size));
    }
    e.isCoder = D;
    function H() {
        return {
            encode: (h)=>{
                if (!Array.isArray(h)) throw new Error("array expected");
                const x = {};
                for (const q of h){
                    if (!Array.isArray(q) || q.length !== 2) throw new Error("array of two elements expected");
                    const te = q[0], fe = q[1];
                    if (x[te] !== void 0) throw new Error(`key(${te}) appears twice in struct`);
                    x[te] = fe;
                }
                return x;
            },
            decode: (h)=>{
                if (!s(h)) throw new Error(`expected plain object, got ${h}`);
                return Object.entries(h);
            }
        };
    }
    const K = {
        encode: (h)=>{
            if (typeof h != "bigint") throw new Error(`expected bigint, got ${typeof h}`);
            if (h > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`element bigger than MAX_SAFE_INTEGER=${h}`);
            return Number(h);
        },
        decode: (h)=>{
            if (!a(h)) throw new Error("element is not a safe integer");
            return BigInt(h);
        }
    };
    function re(h) {
        if (!s(h)) throw new Error("plain object expected");
        return {
            encode: (x)=>{
                if (!a(x) || !(x in h)) throw new Error(`wrong value ${x}`);
                return h[x];
            },
            decode: (x)=>{
                if (typeof x != "string") throw new Error(`wrong value ${typeof x}`);
                return h[x];
            }
        };
    }
    function Q(h, x = !1) {
        if (!a(h)) throw new Error(`decimal/precision: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`decimal/round: expected boolean, got ${typeof x}`);
        const q = 10n ** BigInt(h);
        return {
            encode: (te)=>{
                if (typeof te != "bigint") throw new Error(`expected bigint, got ${typeof te}`);
                let fe = (te < 0n ? -te : te).toString(10), ne = fe.length - h;
                ne < 0 && (fe = fe.padStart(fe.length - ne, "0"), ne = 0);
                let W = fe.length - 1;
                for(; W >= ne && fe[W] === "0"; W--);
                let J = fe.slice(0, ne), V = fe.slice(ne, W + 1);
                return J || (J = "0"), te < 0n && (J = "-" + J), V ? `${J}.${V}` : J;
            },
            decode: (te)=>{
                if (typeof te != "string") throw new Error(`expected string, got ${typeof te}`);
                if (te === "-0") throw new Error("negative zero is not allowed");
                let fe = !1;
                if (te.startsWith("-") && (fe = !0, te = te.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(te)) throw new Error(`wrong string value=${te}`);
                let ne = te.indexOf(".");
                ne = ne === -1 ? te.length : ne;
                const W = te.slice(0, ne), J = te.slice(ne + 1).replace(/0+$/, ""), V = BigInt(W) * q;
                if (!x && J.length > h) throw new Error(`fractional part cannot be represented with this precision (num=${te}, prec=${h})`);
                const C = Math.min(J.length, h), Z = BigInt(J.slice(0, C)) * 10n ** BigInt(h - C), le = V + Z;
                return fe ? -le : le;
            }
        };
    }
    function G(h) {
        if (!Array.isArray(h)) throw new Error(`expected array, got ${typeof h}`);
        for (const x of h)if (!U(x)) throw new Error(`wrong base coder ${x}`);
        return {
            encode: (x)=>{
                for (const q of h){
                    const te = q.encode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/encode: cannot find match in ${x}`);
            },
            decode: (x)=>{
                for (const q of h){
                    const te = q.decode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/decode: cannot find match in ${x}`);
            }
        };
    }
    const R = (h)=>{
        if (!U(h)) throw new Error("BaseCoder expected");
        return {
            encode: h.decode,
            decode: h.encode
        };
    };
    e.coders = {
        dict: H,
        numberBigint: K,
        tsEnum: re,
        decimal: Q,
        match: G,
        reverse: R
    };
    const X = (h)=>{
        if (!a(h)) throw new Error(`bits: wrong length ${h} (${typeof h})`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>x.bits(q, h),
            decodeStream: (x)=>x.bits(h),
            validate: (x)=>{
                if (!a(x)) throw new Error(`bits: wrong value ${x}`);
                return x;
            }
        });
    };
    e.bits = X;
    const $ = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`bigint/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`bigint/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`bigint/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`bigint/sized: expected boolean, got ${typeof te}`);
        const fe = BigInt(h), ne = 2n ** (8n * fe - 1n);
        return (0, e.wrap)({
            size: te ? h : void 0,
            encodeStream: (W, J)=>{
                q && J < 0 && (J = J | ne);
                const V = [];
                for(let Z = 0; Z < h; Z++)V.push(Number(J & 255n)), J >>= 8n;
                let C = new Uint8Array(V).reverse();
                if (!te) {
                    let Z = 0;
                    for(Z = 0; Z < C.length && C[Z] === 0; Z++);
                    C = C.subarray(Z);
                }
                W.bytes(x ? C.reverse() : C);
            },
            decodeStream: (W)=>{
                const J = W.bytes(te ? h : Math.min(h, W.leftBytes)), V = x ? J : y(J);
                let C = 0n;
                for(let Z = 0; Z < V.length; Z++)C |= BigInt(V[Z]) << 8n * BigInt(Z);
                return q && C & ne && (C = (C ^ ne) - ne), C;
            },
            validate: (W)=>{
                if (typeof W != "bigint") throw new Error(`bigint: invalid value: ${W}`);
                return _(W, 8n * fe, !!q), W;
            }
        });
    };
    e.bigint = $, e.U256LE = (0, e.bigint)(32, !0), e.U256BE = (0, e.bigint)(32, !1), e.I256LE = (0, e.bigint)(32, !0, !0), e.I256BE = (0, e.bigint)(32, !1, !0), e.U128LE = (0, e.bigint)(16, !0), e.U128BE = (0, e.bigint)(16, !1), e.I128LE = (0, e.bigint)(16, !0, !0), e.I128BE = (0, e.bigint)(16, !1, !0), e.U64LE = (0, e.bigint)(8, !0), e.U64BE = (0, e.bigint)(8, !1), e.I64LE = (0, e.bigint)(8, !0, !0), e.I64BE = (0, e.bigint)(8, !1, !0);
    const S = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`int/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`int/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`int/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`int/sized: expected boolean, got ${typeof te}`);
        if (h > 6) throw new Error("int supports size up to 6 bytes (48 bits): use bigints instead");
        return L((0, e.bigint)(h, x, q, te), e.coders.numberBigint);
    };
    e.int = S;
    const w = (h, x)=>(0, e.wrap)({
            size: h,
            encodeStream: (q, te)=>q.writeView(h, (fe)=>x.write(fe, te)),
            decodeStream: (q)=>q.readView(h, x.read),
            validate: (q)=>{
                if (typeof q != "number") throw new Error(`viewCoder: expected number, got ${typeof q}`);
                return x.validate && x.validate(q), q;
            }
        }), g = (h, x, q)=>{
        const te = h * 8, fe = 2 ** (te - 1), ne = (V)=>{
            if (!a(V)) throw new Error(`sintView: value is not safe integer: ${V}`);
            if (V < -fe || V >= fe) throw new Error(`sintView: value out of bounds. Expected ${-fe} <= ${V} < ${fe}`);
        }, W = 2 ** te, J = (V)=>{
            if (!a(V)) throw new Error(`uintView: value is not safe integer: ${V}`);
            if (0 > V || V >= W) throw new Error(`uintView: value out of bounds. Expected 0 <= ${V} < ${W}`);
        };
        return w(h, {
            write: q.write,
            read: q.read,
            validate: x ? ne : J
        });
    };
    e.U32LE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !0),
        write: (h, x)=>h.setUint32(0, x, !0)
    }), e.U32BE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !1),
        write: (h, x)=>h.setUint32(0, x, !1)
    }), e.I32LE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !0),
        write: (h, x)=>h.setInt32(0, x, !0)
    }), e.I32BE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !1),
        write: (h, x)=>h.setInt32(0, x, !1)
    }), e.U16LE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !0),
        write: (h, x)=>h.setUint16(0, x, !0)
    }), e.U16BE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !1),
        write: (h, x)=>h.setUint16(0, x, !1)
    }), e.I16LE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !0),
        write: (h, x)=>h.setInt16(0, x, !0)
    }), e.I16BE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !1),
        write: (h, x)=>h.setInt16(0, x, !1)
    }), e.U8 = g(1, !1, {
        read: (h, x)=>h.getUint8(x),
        write: (h, x)=>h.setUint8(0, x)
    }), e.I8 = g(1, !0, {
        read: (h, x)=>h.getInt8(x),
        write: (h, x)=>h.setInt8(0, x)
    });
    const m = (h)=>w(4, {
            read: (x, q)=>x.getFloat32(q, h),
            write: (x, q)=>x.setFloat32(0, q, h),
            validate: (x)=>{
                if (Math.fround(x) !== x && !Number.isNaN(x)) throw new Error(`f32: wrong value=${x}`);
            }
        }), E = (h)=>w(8, {
            read: (x, q)=>x.getFloat64(q, h),
            write: (x, q)=>x.setFloat64(0, q, h)
        });
    e.F32BE = m(!1), e.F32LE = m(!0), e.F64BE = E(!1), e.F64LE = E(!0), e.bool = (0, e.wrap)({
        size: 1,
        encodeStream: (h, x)=>h.byte(x ? 1 : 0),
        decodeStream: (h)=>{
            const x = h.byte();
            if (x !== 0 && x !== 1) throw h.err(`bool: invalid value ${x}`);
            return x === 1;
        },
        validate: (h)=>{
            if (typeof h != "boolean") throw new Error(`bool: invalid value ${h}`);
            return h;
        }
    });
    const T = (h, x = !1)=>{
        if (typeof x != "boolean") throw new Error(`bytes/le: expected boolean, got ${typeof x}`);
        const q = u(h), te = n(h);
        return (0, e.wrap)({
            size: typeof h == "number" ? h : void 0,
            encodeStream: (fe, ne)=>{
                te || q.encodeStream(fe, ne.length), fe.bytes(x ? y(ne) : ne), te && fe.bytes(h);
            },
            decodeStream: (fe)=>{
                let ne;
                if (te) {
                    const W = fe.find(h);
                    if (!W) throw fe.err("bytes: cannot find terminator");
                    ne = fe.bytes(W - fe.pos), fe.bytes(h.length);
                } else ne = fe.bytes(h === null ? fe.leftBytes : q.decodeStream(fe));
                return x ? y(ne) : ne;
            },
            validate: (fe)=>{
                if (!n(fe)) throw new Error(`bytes: invalid value ${fe}`);
                return fe;
            }
        });
    };
    e.bytes = T;
    function I(h, x) {
        if (!D(x)) throw new Error(`prefix: invalid inner value ${x}`);
        return L((0, e.bytes)(h), R(x));
    }
    e.prefix = I;
    const P = (h, x = !1)=>O(L((0, e.bytes)(h, x), t.utf8), (q)=>{
            if (typeof q != "string") throw new Error(`expected string, got ${typeof q}`);
            return q;
        });
    e.string = P, e.cstring = (0, e.string)(e.NULL);
    const k = (h, x = {
        isLE: !1,
        with0x: !1
    })=>{
        let q = L((0, e.bytes)(h, x.isLE), t.hex);
        if (typeof x.with0x != "boolean") throw new Error(`hex/with0x: expected boolean, got ${typeof x.with0x}`);
        return x.with0x && (q = L(q, {
            encode: (te)=>`0x${te}`,
            decode: (te)=>{
                if (!te.startsWith("0x")) throw new Error("hex(with0x=true).encode input should start with 0x");
                return te.slice(2);
            }
        })), q;
    };
    e.hex = k;
    function L(h, x) {
        if (!D(h)) throw new Error(`apply: invalid inner value ${h}`);
        if (!U(x)) throw new Error(`apply: invalid base value ${h}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x.decode(te);
                } catch (ne) {
                    throw q.err("" + ne);
                }
                return h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x.encode(te);
                } catch (fe) {
                    throw q.err("" + fe);
                }
            }
        });
    }
    e.apply = L;
    function j(h) {
        if (typeof h != "function") throw new Error(`lazy: expected function, got ${typeof h}`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>h().encodeStream(x, q),
            decodeStream: (x)=>h().decodeStream(x)
        });
    }
    e.lazy = j;
    const ie = (h, x = !1)=>{
        if (!n(h)) throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof h}`);
        if (typeof x != "boolean") throw new Error(`flag/xor: expected boolean, got ${typeof x}`);
        return (0, e.wrap)({
            size: h.length,
            encodeStream: (q, te)=>{
                !!te !== x && q.bytes(h);
            },
            decodeStream: (q)=>{
                let te = q.leftBytes >= h.length;
                return te && (te = r(q.bytes(h.length, !0), h), te && q.bytes(h.length)), te !== x;
            },
            validate: (q)=>{
                if (q !== void 0 && typeof q != "boolean") throw new Error(`flag: expected boolean value or undefined, got ${typeof q}`);
                return q;
            }
        });
    };
    e.flag = ie;
    function ue(h, x, q) {
        if (!D(x)) throw new Error(`flagged: invalid inner value ${x}`);
        if (typeof h != "string" && !D(x)) throw new Error(`flagged: wrong path=${h}`);
        return (0, e.wrap)({
            encodeStream: (te, fe)=>{
                typeof h == "string" ? c.resolve(te.stack, h) ? x.encodeStream(te, fe) : q && x.encodeStream(te, q) : (h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q && x.encodeStream(te, q));
            },
            decodeStream: (te)=>{
                let fe = !1;
                if (typeof h == "string" ? fe = !!c.resolve(te.stack, h) : fe = h.decodeStream(te), fe) return x.decodeStream(te);
                q && x.decodeStream(te);
            }
        });
    }
    e.flagged = ue;
    function ce(h, x, q) {
        if (!D(h) || !D(x)) throw new Error(`optional: invalid flag or inner value flag=${h} inner=${x}`);
        return (0, e.wrap)({
            size: q !== void 0 && h.size && x.size ? h.size + x.size : void 0,
            encodeStream: (te, fe)=>{
                h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q !== void 0 && x.encodeStream(te, q);
            },
            decodeStream: (te)=>{
                if (h.decodeStream(te)) return x.decodeStream(te);
                q !== void 0 && x.decodeStream(te);
            }
        });
    }
    e.optional = ce;
    function he(h, x, q = !0) {
        if (!D(h)) throw new Error(`magic: invalid inner value ${h}`);
        if (typeof q != "boolean") throw new Error(`magic: expected boolean, got ${typeof q}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                if (q && typeof fe != "object" && fe !== x || n(x) && !r(x, fe)) throw te.err(`magic: invalid value: ${fe} !== ${x}`);
            },
            validate: (te)=>{
                if (te !== void 0) throw new Error(`magic: wrong value=${typeof te}`);
                return te;
            }
        });
    }
    e.magic = he;
    const ee = (h)=>{
        const x = typeof h == "string" ? t.utf8.decode(h) : h;
        return he((0, e.bytes)(x.length), x);
    };
    e.magicBytes = ee;
    function ae(h) {
        return (0, e.wrap)({
            encodeStream: (x, q)=>{
                if (q !== h) throw new Error(`constant: invalid value ${q} (exp: ${h})`);
            },
            decodeStream: (x)=>h
        });
    }
    e.constant = ae;
    function ye(h) {
        let x = 0;
        for (const q of h){
            if (q.size === void 0) return;
            if (!a(q.size)) throw new Error(`sizeof: wrong element size=${x}`);
            x += q.size;
        }
        return x;
    }
    function Se(h) {
        if (!s(h)) throw new Error(`struct: expected plain object, got ${h}`);
        for(const x in h)if (!D(h[x])) throw new Error(`struct: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(Object.values(h)),
            encodeStream: (x, q)=>{
                x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = {};
                return x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>q[fe] = h[fe].decodeStream(x));
                }), q;
            },
            validate: (x)=>{
                if (typeof x != "object" || x === null) throw new Error(`struct: invalid value ${x}`);
                return x;
            }
        });
    }
    e.struct = Se;
    function De(h) {
        if (!Array.isArray(h)) throw new Error(`Packed.Tuple: got ${typeof h} instead of array`);
        for(let x = 0; x < h.length; x++)if (!D(h[x])) throw new Error(`tuple: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(h),
            encodeStream: (x, q)=>{
                if (!Array.isArray(q)) throw x.err(`tuple: invalid value ${q}`);
                x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = [];
                return x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>q.push(h[fe].decodeStream(x)));
                }), q;
            },
            validate: (x)=>{
                if (!Array.isArray(x)) throw new Error(`tuple: invalid value ${x}`);
                if (x.length !== h.length) throw new Error(`tuple: wrong length=${x.length}, expected ${h.length}`);
                return x;
            }
        });
    }
    e.tuple = De;
    function Re(h, x) {
        if (!D(x)) throw new Error(`array: invalid inner value ${x}`);
        const q = u(typeof h == "string" ? `../${h}` : h);
        return (0, e.wrap)({
            size: typeof h == "number" && x.size ? h * x.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te;
                ne.pushObj(fe, (W)=>{
                    n(h) || q.encodeStream(te, fe.length);
                    for(let J = 0; J < fe.length; J++)W(`${J}`, ()=>{
                        const V = fe[J], C = te.pos;
                        if (x.encodeStream(te, V), n(h)) {
                            if (h.length > ne.pos - C) return;
                            const Z = ne.finish(!1).subarray(C, ne.pos);
                            if (r(Z.subarray(0, h.length), h)) throw ne.err(`array: inner element encoding same as separator. elm=${V} data=${Z}`);
                        }
                    });
                }), n(h) && te.bytes(h);
            },
            decodeStream: (te)=>{
                const fe = [];
                return te.pushObj(fe, (ne)=>{
                    if (h === null) for(let W = 0; !te.isEnd() && (ne(`${W}`, ()=>fe.push(x.decodeStream(te))), !(x.size && te.leftBytes < x.size)); W++);
                    else if (n(h)) for(let W = 0;; W++){
                        if (r(te.bytes(h.length, !0), h)) {
                            te.bytes(h.length);
                            break;
                        }
                        ne(`${W}`, ()=>fe.push(x.decodeStream(te)));
                    }
                    else {
                        let W;
                        ne("arrayLen", ()=>W = q.decodeStream(te));
                        for(let J = 0; J < W; J++)ne(`${J}`, ()=>fe.push(x.decodeStream(te)));
                    }
                }), fe;
            },
            validate: (te)=>{
                if (!Array.isArray(te)) throw new Error(`array: invalid value ${te}`);
                return te;
            }
        });
    }
    e.array = Re;
    function Ce(h, x) {
        if (!D(h)) throw new Error(`map: invalid inner value ${h}`);
        if (!s(x)) throw new Error("map: variants should be plain object");
        const q = /* @__PURE__ */ new Map();
        for(const te in x)q.set(x[te], te);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x[fe]),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te), ne = q.get(fe);
                if (ne === void 0) throw te.err(`Enum: unknown value: ${fe} ${Array.from(q.keys())}`);
                return ne;
            },
            validate: (te)=>{
                if (typeof te != "string") throw new Error(`map: invalid value ${te}`);
                if (!(te in x)) throw new Error(`Map: unknown variant: ${te}`);
                return te;
            }
        });
    }
    e.map = Ce;
    function M(h, x) {
        if (!D(h)) throw new Error(`tag: invalid tag value ${h}`);
        if (!s(x)) throw new Error("tag: variants should be plain object");
        for(const q in x)if (!D(x[q])) throw new Error(`tag: variant ${q} is not CoderType`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                const { TAG: fe, data: ne } = te, W = x[fe];
                h.encodeStream(q, fe), W.encodeStream(q, ne);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q), fe = x[te];
                if (!fe) throw q.err(`Tag: invalid tag ${te}`);
                return {
                    TAG: te,
                    data: fe.decodeStream(q)
                };
            },
            validate: (q)=>{
                const { TAG: te } = q;
                if (!x[te]) throw new Error(`Tag: invalid tag ${te.toString()}`);
                return q;
            }
        });
    }
    e.tag = M;
    function z(h, x) {
        if (!D(h)) throw new Error(`mappedTag: invalid tag value ${M}`);
        if (!s(x)) throw new Error("mappedTag: variants should be plain object");
        const q = {}, te = {};
        for(const fe in x){
            const ne = x[fe];
            q[fe] = ne[0], te[fe] = ne[1];
        }
        return M(Ce(h, q), te);
    }
    e.mappedTag = z;
    function de(h, x = !1) {
        if (typeof x != "boolean") throw new Error(`bitset/pad: expected boolean, got ${typeof x}`);
        if (!Array.isArray(h)) throw new Error("bitset/names: expected array");
        for (const q of h)if (typeof q != "string") throw new Error("bitset/names: expected array of strings");
        return (0, e.wrap)({
            encodeStream: (q, te)=>{
                for(let fe = 0; fe < h.length; fe++)q.bits(+te[h[fe]], 1);
                x && h.length % 8 && q.bits(0, 8 - h.length % 8);
            },
            decodeStream: (q)=>{
                const te = {};
                for(let fe = 0; fe < h.length; fe++)te[h[fe]] = !!q.bits(1);
                return x && h.length % 8 && q.bits(8 - h.length % 8), te;
            },
            validate: (q)=>{
                if (!s(q)) throw new Error(`bitset: invalid value ${q}`);
                for (const te of Object.values(q))if (typeof te != "boolean") throw new Error("expected boolean");
                return q;
            }
        });
    }
    e.bitset = de;
    const _e = (h)=>0;
    e.ZeroPad = _e;
    function Ie(h, x) {
        return x % h === 0 ? 0 : h - x % h;
    }
    function je(h, x, q) {
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (!D(x)) throw new Error(`padLeft: invalid inner value ${x}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padLeft: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        if (!x.size) throw new Error("padLeft cannot have dynamic size");
        return (0, e.wrap)({
            size: x.size + Ie(h, x.size),
            encodeStream: (fe, ne)=>{
                const W = Ie(h, x.size);
                for(let J = 0; J < W; J++)fe.byte(te(J));
                x.encodeStream(fe, ne);
            },
            decodeStream: (fe)=>(fe.bytes(Ie(h, x.size)), x.decodeStream(fe))
        });
    }
    e.padLeft = je;
    function Ke(h, x, q) {
        if (!D(x)) throw new Error(`padRight: invalid inner value ${x}`);
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padRight: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        return (0, e.wrap)({
            size: x.size ? x.size + Ie(h, x.size) : void 0,
            encodeStream: (fe, ne)=>{
                const W = fe, J = W.pos;
                x.encodeStream(fe, ne);
                const V = Ie(h, W.pos - J);
                for(let C = 0; C < V; C++)fe.byte(te(C));
            },
            decodeStream: (fe)=>{
                const ne = fe.pos, W = x.decodeStream(fe);
                return fe.bytes(Ie(h, fe.pos - ne)), W;
            }
        });
    }
    e.padRight = Ke;
    function Ue(h, x, q = !1) {
        if (!D(h)) throw new Error(`pointer: invalid ptr value ${h}`);
        if (!D(x)) throw new Error(`pointer: invalid inner value ${x}`);
        if (typeof q != "boolean") throw new Error(`pointer/sized: expected boolean, got ${typeof q}`);
        if (!h.size) throw new Error("unsized pointer");
        return (0, e.wrap)({
            size: q ? h.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te, W = ne.pos;
                h.encodeStream(te, 0), ne.ptrs.push({
                    pos: W,
                    ptr: h,
                    buffer: x.encode(fe)
                });
            },
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                return te._enablePointers(), x.decodeStream(te.offsetReader(fe));
            }
        });
    }
    e.pointer = Ue, e._TEST = {
        _bitset: f,
        _Reader: l,
        _Writer: p,
        Path: c
    };
})(wS);
var vS = {}, wa = {}, no = {};
Object.defineProperty(no, "__esModule", {
    value: !0
});
no.ripemd160 = no.RIPEMD160 = no.md5 = no.MD5 = no.sha1 = no.SHA1 = void 0;
const yf = Pi, gi = Hr, Al = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
]), $c = /* @__PURE__ */ new Uint32Array(80);
class tM extends yf.HashMD {
    constructor(){
        super(64, 20, 8, !1), this.A = Al[0] | 0, this.B = Al[1] | 0, this.C = Al[2] | 0, this.D = Al[3] | 0, this.E = Al[4] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0;
    }
    process(t, r) {
        for(let u = 0; u < 16; u++, r += 4)$c[u] = t.getUint32(r, !1);
        for(let u = 16; u < 80; u++)$c[u] = (0, gi.rotl)($c[u - 3] ^ $c[u - 8] ^ $c[u - 14] ^ $c[u - 16], 1);
        let { A: n, B: i, C: o, D: s, E: a } = this;
        for(let u = 0; u < 80; u++){
            let f, c;
            u < 20 ? (f = (0, yf.Chi)(i, o, s), c = 1518500249) : u < 40 ? (f = i ^ o ^ s, c = 1859775393) : u < 60 ? (f = (0, yf.Maj)(i, o, s), c = 2400959708) : (f = i ^ o ^ s, c = 3395469782);
            const l = (0, gi.rotl)(n, 5) + f + a + c + $c[u] | 0;
            a = s, s = o, o = (0, gi.rotl)(i, 30), i = n, n = l;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, this.set(n, i, o, s, a);
    }
    roundClean() {
        (0, gi.clean)($c);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0), (0, gi.clean)(this.buffer);
    }
}
no.SHA1 = tM;
no.sha1 = (0, gi.createHasher)(()=>new tM());
const Gae = /* @__PURE__ */ Math.pow(2, 32), Zae = /* @__PURE__ */ Array.from({
    length: 64
}, (e, t)=>Math.floor(Gae * Math.abs(Math.sin(t + 1)))), ay = /* @__PURE__ */ Al.slice(0, 4), q_ = /* @__PURE__ */ new Uint32Array(16);
class rM extends yf.HashMD {
    constructor(){
        super(64, 16, 8, !0), this.A = ay[0] | 0, this.B = ay[1] | 0, this.C = ay[2] | 0, this.D = ay[3] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i } = this;
        return [
            t,
            r,
            n,
            i
        ];
    }
    set(t, r, n, i) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0;
    }
    process(t, r) {
        for(let a = 0; a < 16; a++, r += 4)q_[a] = t.getUint32(r, !0);
        let { A: n, B: i, C: o, D: s } = this;
        for(let a = 0; a < 64; a++){
            let u, f, c;
            a < 16 ? (u = (0, yf.Chi)(i, o, s), f = a, c = [
                7,
                12,
                17,
                22
            ]) : a < 32 ? (u = (0, yf.Chi)(s, i, o), f = (5 * a + 1) % 16, c = [
                5,
                9,
                14,
                20
            ]) : a < 48 ? (u = i ^ o ^ s, f = (3 * a + 5) % 16, c = [
                4,
                11,
                16,
                23
            ]) : (u = o ^ (i | ~s), f = 7 * a % 16, c = [
                6,
                10,
                15,
                21
            ]), u = u + n + Zae[a] + q_[f], n = s, s = o, o = i, i = i + (0, gi.rotl)(u, c[a % 4]);
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, this.set(n, i, o, s);
    }
    roundClean() {
        (0, gi.clean)(q_);
    }
    destroy() {
        this.set(0, 0, 0, 0), (0, gi.clean)(this.buffer);
    }
}
no.MD5 = rM;
no.md5 = (0, gi.createHasher)(()=>new rM());
const Yae = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), nM = Uint8Array.from(new Array(16).fill(0).map((e, t)=>t)), Xae = nM.map((e)=>(9 * e + 5) % 16), iM = /* @__PURE__ */ (()=>{
    const r = [
        [
            nM
        ],
        [
            Xae
        ]
    ];
    for(let n = 0; n < 4; n++)for (let i of r)i.push(i[n].map((o)=>Yae[o]));
    return r;
})(), oM = iM[0], sM = iM[1], aM = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>Uint8Array.from(e)), Jae = /* @__PURE__ */ oM.map((e, t)=>e.map((r)=>aM[t][r])), Qae = /* @__PURE__ */ sM.map((e, t)=>e.map((r)=>aM[t][r])), ece = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), tce = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]);
function xI(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const cy = /* @__PURE__ */ new Uint32Array(16);
let cM = class extends yf.HashMD {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)cy[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, u = a, f = this.h3 | 0, c = f, l = this.h4 | 0, p = l;
        for(let y = 0; y < 5; y++){
            const _ = 4 - y, A = ece[y], O = tce[y], N = oM[y], U = sM[y], D = Jae[y], H = Qae[y];
            for(let K = 0; K < 16; K++){
                const re = (0, gi.rotl)(n + xI(y, o, a, f) + cy[N[K]] + A, D[K]) + l | 0;
                n = l, l = f, f = (0, gi.rotl)(a, 10) | 0, a = o, o = re;
            }
            for(let K = 0; K < 16; K++){
                const re = (0, gi.rotl)(i + xI(_, s, u, c) + cy[U[K]] + O, H[K]) + p | 0;
                i = p, p = c, c = (0, gi.rotl)(u, 10) | 0, u = s, s = re;
            }
        }
        this.set(this.h1 + a + c | 0, this.h2 + f + p | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + u | 0);
    }
    roundClean() {
        (0, gi.clean)(cy);
    }
    destroy() {
        this.destroyed = !0, (0, gi.clean)(this.buffer), this.set(0, 0, 0, 0, 0);
    }
};
no.RIPEMD160 = cM;
no.ripemd160 = (0, gi.createHasher)(()=>new cM());
var jf = {}, zd = {};
(function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0;
    function t(ue) {
        return ue instanceof Uint8Array || ArrayBuffer.isView(ue) && ue.constructor.name === "Uint8Array";
    }
    function r(ue, ...ce) {
        if (!t(ue)) throw new Error("Uint8Array expected");
        if (ce.length > 0 && !ce.includes(ue.length)) throw new Error("Uint8Array expected of length " + ce + ", got length=" + ue.length);
    }
    function n(ue, ce) {
        return Array.isArray(ce) ? ce.length === 0 ? !0 : ue ? ce.every((he)=>typeof he == "string") : ce.every((he)=>Number.isSafeInteger(he)) : !1;
    }
    function i(ue) {
        if (typeof ue != "function") throw new Error("function expected");
        return !0;
    }
    function o(ue, ce) {
        if (typeof ce != "string") throw new Error(`${ue}: string expected`);
        return !0;
    }
    function s(ue) {
        if (!Number.isSafeInteger(ue)) throw new Error(`invalid integer: ${ue}`);
    }
    function a(ue) {
        if (!Array.isArray(ue)) throw new Error("array expected");
    }
    function u(ue, ce) {
        if (!n(!0, ce)) throw new Error(`${ue}: array of strings expected`);
    }
    function f(ue, ce) {
        if (!n(!1, ce)) throw new Error(`${ue}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function c(...ue) {
        const ce = (ye)=>ye, he = (ye, Se)=>(De)=>ye(Se(De)), ee = ue.map((ye)=>ye.encode).reduceRight(he, ce), ae = ue.map((ye)=>ye.decode).reduce(he, ce);
        return {
            encode: ee,
            decode: ae
        };
    }
    // @__NO_SIDE_EFFECTS__
    function l(ue) {
        const ce = typeof ue == "string" ? ue.split("") : ue, he = ce.length;
        u("alphabet", ce);
        const ee = new Map(ce.map((ae, ye)=>[
                ae,
                ye
            ]));
        return {
            encode: (ae)=>(a(ae), ae.map((ye)=>{
                    if (!Number.isSafeInteger(ye) || ye < 0 || ye >= he) throw new Error(`alphabet.encode: digit index outside alphabet "${ye}". Allowed: ${ue}`);
                    return ce[ye];
                })),
            decode: (ae)=>(a(ae), ae.map((ye)=>{
                    o("alphabet.decode", ye);
                    const Se = ee.get(ye);
                    if (Se === void 0) throw new Error(`Unknown letter: "${ye}". Allowed: ${ue}`);
                    return Se;
                }))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function p(ue = "") {
        return o("join", ue), {
            encode: (ce)=>(u("join.decode", ce), ce.join(ue)),
            decode: (ce)=>(o("join.decode", ce), ce.split(ue))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function y(ue, ce = "=") {
        return s(ue), o("padding", ce), {
            encode (he) {
                for(u("padding.encode", he); he.length * ue % 8;)he.push(ce);
                return he;
            },
            decode (he) {
                u("padding.decode", he);
                let ee = he.length;
                if (ee * ue % 8) throw new Error("padding: invalid, string should have whole number of bytes");
                for(; ee > 0 && he[ee - 1] === ce; ee--)if ((ee - 1) * ue % 8 === 0) throw new Error("padding: invalid, string has too much padding");
                return he.slice(0, ee);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function _(ue) {
        return i(ue), {
            encode: (ce)=>ce,
            decode: (ce)=>ue(ce)
        };
    }
    function A(ue, ce, he) {
        if (ce < 2) throw new Error(`convertRadix: invalid from=${ce}, base cannot be less than 2`);
        if (he < 2) throw new Error(`convertRadix: invalid to=${he}, base cannot be less than 2`);
        if (a(ue), !ue.length) return [];
        let ee = 0;
        const ae = [], ye = Array.from(ue, (De)=>{
            if (s(De), De < 0 || De >= ce) throw new Error(`invalid integer: ${De}`);
            return De;
        }), Se = ye.length;
        for(;;){
            let De = 0, Re = !0;
            for(let Ce = ee; Ce < Se; Ce++){
                const M = ye[Ce], z = ce * De, de = z + M;
                if (!Number.isSafeInteger(de) || z / ce !== De || de - M !== z) throw new Error("convertRadix: carry overflow");
                const _e = de / he;
                De = de % he;
                const Ie = Math.floor(_e);
                if (ye[Ce] = Ie, !Number.isSafeInteger(Ie) || Ie * he + De !== de) throw new Error("convertRadix: carry overflow");
                if (Re) Ie ? Re = !1 : ee = Ce;
                else continue;
            }
            if (ae.push(De), Re) break;
        }
        for(let De = 0; De < ue.length - 1 && ue[De] === 0; De++)ae.push(0);
        return ae.reverse();
    }
    const O = (ue, ce)=>ce === 0 ? ue : O(ce, ue % ce), N = /* @__NO_SIDE_EFFECTS__ */ (ue, ce)=>ue + (ce - O(ue, ce)), U = /* @__PURE__ */ (()=>{
        let ue = [];
        for(let ce = 0; ce < 40; ce++)ue.push(2 ** ce);
        return ue;
    })();
    function D(ue, ce, he, ee) {
        if (a(ue), ce <= 0 || ce > 32) throw new Error(`convertRadix2: wrong from=${ce}`);
        if (he <= 0 || he > 32) throw new Error(`convertRadix2: wrong to=${he}`);
        if (/* @__PURE__ */ N(ce, he) > 32) throw new Error(`convertRadix2: carry overflow from=${ce} to=${he} carryBits=${/* @__PURE__ */ N(ce, he)}`);
        let ae = 0, ye = 0;
        const Se = U[ce], De = U[he] - 1, Re = [];
        for (const Ce of ue){
            if (s(Ce), Ce >= Se) throw new Error(`convertRadix2: invalid data word=${Ce} from=${ce}`);
            if (ae = ae << ce | Ce, ye + ce > 32) throw new Error(`convertRadix2: carry overflow pos=${ye} from=${ce}`);
            for(ye += ce; ye >= he; ye -= he)Re.push((ae >> ye - he & De) >>> 0);
            const M = U[ye];
            if (M === void 0) throw new Error("invalid carry");
            ae &= M - 1;
        }
        if (ae = ae << he - ye & De, !ee && ye >= ce) throw new Error("Excess padding");
        if (!ee && ae > 0) throw new Error(`Non-zero padding: ${ae}`);
        return ee && ye > 0 && Re.push(ae >>> 0), Re;
    }
    // @__NO_SIDE_EFFECTS__
    function H(ue) {
        s(ue);
        const ce = 2 ** 8;
        return {
            encode: (he)=>{
                if (!t(he)) throw new Error("radix.encode input should be Uint8Array");
                return A(Array.from(he), ce, ue);
            },
            decode: (he)=>(f("radix.decode", he), Uint8Array.from(A(he, ue, ce)))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function K(ue, ce = !1) {
        if (s(ue), ue <= 0 || ue > 32) throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ N(8, ue) > 32 || /* @__PURE__ */ N(ue, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (he)=>{
                if (!t(he)) throw new Error("radix2.encode input should be Uint8Array");
                return D(Array.from(he), 8, ue, !ce);
            },
            decode: (he)=>(f("radix2.decode", he), Uint8Array.from(D(he, ue, 8, ce)))
        };
    }
    function re(ue) {
        return i(ue), function(...ce) {
            try {
                return ue.apply(null, ce);
            } catch  {}
        };
    }
    function Q(ue, ce) {
        return s(ue), i(ce), {
            encode (he) {
                if (!t(he)) throw new Error("checksum.encode: input should be Uint8Array");
                const ee = ce(he).slice(0, ue), ae = new Uint8Array(he.length + ue);
                return ae.set(he), ae.set(ee, he.length), ae;
            },
            decode (he) {
                if (!t(he)) throw new Error("checksum.decode: input should be Uint8Array");
                const ee = he.slice(0, -ue), ae = he.slice(-ue), ye = ce(ee).slice(0, ue);
                for(let Se = 0; Se < ue; Se++)if (ye[Se] !== ae[Se]) throw new Error("Invalid checksum");
                return ee;
            }
        };
    }
    e.utils = {
        alphabet: l,
        chain: c,
        checksum: Q,
        convertRadix: A,
        convertRadix2: D,
        radix: H,
        radix2: K,
        join: p,
        padding: y
    }, e.base16 = /* @__PURE__ */ c(/* @__PURE__ */ K(4), /* @__PURE__ */ l("0123456789ABCDEF"), /* @__PURE__ */ p("")), e.base32 = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ y(5), /* @__PURE__ */ p("")), e.base32nopad = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ p("")), e.base32hex = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ y(5), /* @__PURE__ */ p("")), e.base32hexnopad = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ p("")), e.base32crockford = /* @__PURE__ */ c(/* @__PURE__ */ K(5), /* @__PURE__ */ l("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ p(""), /* @__PURE__ */ _((ue)=>ue.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    const G = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function", R = (ue, ce)=>{
        o("base64", ue);
        const he = ce ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/, ee = ce ? "base64url" : "base64";
        if (ue.length > 0 && !he.test(ue)) throw new Error("invalid base64");
        return Uint8Array.fromBase64(ue, {
            alphabet: ee,
            lastChunkHandling: "strict"
        });
    };
    e.base64 = G ? {
        encode (ue) {
            return r(ue), ue.toBase64();
        },
        decode (ue) {
            return R(ue, !1);
        }
    } : /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ y(6), /* @__PURE__ */ p("")), e.base64nopad = /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ p("")), e.base64url = G ? {
        encode (ue) {
            return r(ue), ue.toBase64({
                alphabet: "base64url"
            });
        },
        decode (ue) {
            return R(ue, !0);
        }
    } : /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ y(6), /* @__PURE__ */ p("")), e.base64urlnopad = /* @__PURE__ */ c(/* @__PURE__ */ K(6), /* @__PURE__ */ l("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ p(""));
    const X = /* @__NO_SIDE_EFFECTS__ */ (ue)=>/* @__PURE__ */ c(/* @__PURE__ */ H(58), /* @__PURE__ */ l(ue), /* @__PURE__ */ p(""));
    e.base58 = /* @__PURE__ */ X("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = /* @__PURE__ */ X("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = /* @__PURE__ */ X("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const $ = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    e.base58xmr = {
        encode (ue) {
            let ce = "";
            for(let he = 0; he < ue.length; he += 8){
                const ee = ue.subarray(he, he + 8);
                ce += e.base58.encode(ee).padStart($[ee.length], "1");
            }
            return ce;
        },
        decode (ue) {
            let ce = [];
            for(let he = 0; he < ue.length; he += 11){
                const ee = ue.slice(he, he + 11), ae = $.indexOf(ee.length), ye = e.base58.decode(ee);
                for(let Se = 0; Se < ye.length - ae; Se++)if (ye[Se] !== 0) throw new Error("base58xmr: wrong padding");
                ce = ce.concat(Array.from(ye.slice(ye.length - ae)));
            }
            return Uint8Array.from(ce);
        }
    };
    const S = (ue)=>/* @__PURE__ */ c(Q(4, (ce)=>ue(ue(ce))), e.base58);
    e.createBase58check = S, e.base58check = e.createBase58check;
    const w = /* @__PURE__ */ c(/* @__PURE__ */ l("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ p("")), g = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    function m(ue) {
        const ce = ue >> 25;
        let he = (ue & 33554431) << 5;
        for(let ee = 0; ee < g.length; ee++)(ce >> ee & 1) === 1 && (he ^= g[ee]);
        return he;
    }
    function E(ue, ce, he = 1) {
        const ee = ue.length;
        let ae = 1;
        for(let ye = 0; ye < ee; ye++){
            const Se = ue.charCodeAt(ye);
            if (Se < 33 || Se > 126) throw new Error(`Invalid prefix (${ue})`);
            ae = m(ae) ^ Se >> 5;
        }
        ae = m(ae);
        for(let ye = 0; ye < ee; ye++)ae = m(ae) ^ ue.charCodeAt(ye) & 31;
        for (let ye of ce)ae = m(ae) ^ ye;
        for(let ye = 0; ye < 6; ye++)ae = m(ae);
        return ae ^= he, w.encode(D([
            ae % U[30]
        ], 30, 5, !1));
    }
    // @__NO_SIDE_EFFECTS__
    function T(ue) {
        const ce = ue === "bech32" ? 1 : 734539939, he = /* @__PURE__ */ K(5), ee = he.decode, ae = he.encode, ye = re(ee);
        function Se(z, de, _e = 90) {
            o("bech32.encode prefix", z), t(de) && (de = Array.from(de)), f("bech32.encode", de);
            const Ie = z.length;
            if (Ie === 0) throw new TypeError(`Invalid prefix length ${Ie}`);
            const je = Ie + 7 + de.length;
            if (_e !== !1 && je > _e) throw new TypeError(`Length ${je} exceeds limit ${_e}`);
            const Ke = z.toLowerCase(), Ue = E(Ke, de, ce);
            return `${Ke}1${w.encode(de)}${Ue}`;
        }
        function De(z, de = 90) {
            o("bech32.decode input", z);
            const _e = z.length;
            if (_e < 8 || de !== !1 && _e > de) throw new TypeError(`invalid string length: ${_e} (${z}). Expected (8..${de})`);
            const Ie = z.toLowerCase();
            if (z !== Ie && z !== z.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const je = Ie.lastIndexOf("1");
            if (je === 0 || je === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const Ke = Ie.slice(0, je), Ue = Ie.slice(je + 1);
            if (Ue.length < 6) throw new Error("Data must be at least 6 characters long");
            const h = w.decode(Ue).slice(0, -6), x = E(Ke, h, ce);
            if (!Ue.endsWith(x)) throw new Error(`Invalid checksum in ${z}: expected "${x}"`);
            return {
                prefix: Ke,
                words: h
            };
        }
        const Re = re(De);
        function Ce(z) {
            const { prefix: de, words: _e } = De(z, !1);
            return {
                prefix: de,
                words: _e,
                bytes: ee(_e)
            };
        }
        function M(z, de) {
            return Se(z, ae(de));
        }
        return {
            encode: Se,
            decode: De,
            encodeFromBytes: M,
            decodeToBytes: Ce,
            decodeUnsafe: Re,
            fromWords: ee,
            fromWordsUnsafe: ye,
            toWords: ae
        };
    }
    e.bech32 = /* @__PURE__ */ T("bech32"), e.bech32m = /* @__PURE__ */ T("bech32m"), e.utf8 = {
        encode: (ue)=>new TextDecoder().decode(ue),
        decode: (ue)=>new TextEncoder().encode(ue)
    };
    const I = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", P = {
        encode (ue) {
            return r(ue), ue.toHex();
        },
        decode (ue) {
            return o("hex", ue), Uint8Array.fromHex(ue);
        }
    };
    e.hex = I ? P : /* @__PURE__ */ c(/* @__PURE__ */ K(4), /* @__PURE__ */ l("0123456789abcdef"), /* @__PURE__ */ p(""), /* @__PURE__ */ _((ue)=>{
        if (typeof ue != "string" || ue.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof ue} with length ${ue.length}`);
        return ue.toLowerCase();
    }));
    const k = {
        utf8: e.utf8,
        hex: e.hex,
        base16: e.base16,
        base32: e.base32,
        base64: e.base64,
        base64url: e.base64url,
        base58: e.base58,
        base58xmr: e.base58xmr
    }, L = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", j = (ue, ce)=>{
        if (typeof ue != "string" || !k.hasOwnProperty(ue)) throw new TypeError(L);
        if (!t(ce)) throw new TypeError("bytesToString() expects Uint8Array");
        return k[ue].encode(ce);
    };
    e.bytesToString = j, e.str = e.bytesToString;
    const ie = (ue, ce)=>{
        if (!k.hasOwnProperty(ue)) throw new TypeError(L);
        if (typeof ce != "string") throw new TypeError("stringToBytes() expects string");
        return k[ue].decode(ce);
    };
    e.stringToBytes = ie, e.bytes = e.stringToBytes;
})(zd);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._TEST = e.ZeroPad = e.magicBytes = e.flag = e.cstring = e.string = e.hex = e.bytes = e.bool = e.F64LE = e.F64BE = e.F32LE = e.F32BE = e.I8 = e.U8 = e.I16BE = e.I16LE = e.U16BE = e.U16LE = e.I32BE = e.I32LE = e.U32BE = e.U32LE = e.int = e.I64BE = e.I64LE = e.U64BE = e.U64LE = e.I128BE = e.I128LE = e.U128BE = e.U128LE = e.I256BE = e.I256LE = e.U256BE = e.U256LE = e.bigint = e.bits = e.coders = e.wrap = e.utils = e.NULL = e.EMPTY = void 0, e.validate = O, e.isCoder = D, e.prefix = I, e.apply = L, e.lazy = j, e.flagged = ue, e.optional = ce, e.magic = he, e.constant = ae, e.struct = Se, e.tuple = De, e.array = Re, e.map = Ce, e.tag = M, e.mappedTag = z, e.bitset = de, e.padLeft = je, e.padRight = Ke, e.pointer = Ue;
    const t = zd;
    e.EMPTY = new Uint8Array(), e.NULL = new Uint8Array([
        0
    ]);
    function r(h, x) {
        if (h.length !== x.length) return !1;
        for(let q = 0; q < h.length; q++)if (h[q] !== x[q]) return !1;
        return !0;
    }
    function n(h) {
        return h instanceof Uint8Array || ArrayBuffer.isView(h) && h.constructor.name === "Uint8Array";
    }
    function i(...h) {
        let x = 0;
        for(let te = 0; te < h.length; te++){
            const fe = h[te];
            if (!n(fe)) throw new Error("Uint8Array expected");
            x += fe.length;
        }
        const q = new Uint8Array(x);
        for(let te = 0, fe = 0; te < h.length; te++){
            const ne = h[te];
            q.set(ne, fe), fe += ne.length;
        }
        return q;
    }
    const o = (h)=>new DataView(h.buffer, h.byteOffset, h.byteLength);
    function s(h) {
        return Object.prototype.toString.call(h) === "[object Object]";
    }
    function a(h) {
        return Number.isSafeInteger(h);
    }
    e.utils = {
        equalBytes: r,
        isBytes: n,
        isCoder: D,
        checkBounds: _,
        concatBytes: i,
        createView: o,
        isPlainObject: s
    };
    const u = (h)=>{
        if (h !== null && typeof h != "string" && !D(h) && !n(h) && !a(h)) throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${h} (${typeof h})`);
        return {
            encodeStream (x, q) {
                if (h === null) return;
                if (D(h)) return h.encodeStream(x, q);
                let te;
                if (typeof h == "number" ? te = h : typeof h == "string" && (te = c.resolve(x.stack, h)), typeof te == "bigint" && (te = Number(te)), te === void 0 || te !== q) throw x.err(`Wrong length: ${te} len=${h} exp=${q} (${typeof q})`);
            },
            decodeStream (x) {
                let q;
                if (D(h) ? q = Number(h.decodeStream(x)) : typeof h == "number" ? q = h : typeof h == "string" && (q = c.resolve(x.stack, h)), typeof q == "bigint" && (q = Number(q)), typeof q != "number") throw x.err(`Wrong length: ${q}`);
                return q;
            }
        };
    }, f = {
        BITS: 32,
        FULL_MASK: -1 >>> 0,
        // 1<<32 will overflow
        len: (h)=>Math.ceil(h / 32),
        create: (h)=>new Uint32Array(f.len(h)),
        clean: (h)=>h.fill(0),
        debug: (h)=>Array.from(h).map((x)=>(x >>> 0).toString(2).padStart(32, "0")),
        checkLen: (h, x)=>{
            if (f.len(x) !== h.length) throw new Error(`wrong length=${h.length}. Expected: ${f.len(x)}`);
        },
        chunkLen: (h, x, q)=>{
            if (x < 0) throw new Error(`wrong pos=${x}`);
            if (x + q > h) throw new Error(`wrong range=${x}/${q} of ${h}`);
        },
        set: (h, x, q, te = !0)=>!te && h[x] & q ? !1 : (h[x] |= q, !0),
        pos: (h, x)=>({
                chunk: Math.floor((h + x) / 32),
                mask: 1 << 32 - (h + x) % 32 - 1
            }),
        indices: (h, x, q = !1)=>{
            f.checkLen(h, x);
            const { FULL_MASK: te, BITS: fe } = f, ne = fe - x % fe, W = ne ? te >>> ne << ne : te, J = [];
            for(let V = 0; V < h.length; V++){
                let C = h[V];
                if (q && (C = ~C), V === h.length - 1 && (C &= W), C !== 0) for(let Z = 0; Z < fe; Z++){
                    const le = 1 << fe - Z - 1;
                    C & le && J.push(V * fe + Z);
                }
            }
            return J;
        },
        range: (h)=>{
            const x = [];
            let q;
            for (const te of h)q === void 0 || te !== q.pos + q.length ? x.push(q = {
                pos: te,
                length: 1
            }) : q.length += 1;
            return x;
        },
        rangeDebug: (h, x, q = !1)=>`[${f.range(f.indices(h, x, q)).map((te)=>`(${te.pos}/${te.length})`).join(", ")}]`,
        setRange: (h, x, q, te, fe = !0)=>{
            f.chunkLen(x, q, te);
            const { FULL_MASK: ne, BITS: W } = f, J = q % W ? Math.floor(q / W) : void 0, V = q + te, C = V % W ? Math.floor(V / W) : void 0;
            if (J !== void 0 && J === C) return f.set(h, J, ne >>> W - te << W - te - q, fe);
            if (J !== void 0 && !f.set(h, J, ne >>> q % W, fe)) return !1;
            const Z = J !== void 0 ? J + 1 : q / W, le = C !== void 0 ? C : V / W;
            for(let se = Z; se < le; se++)if (!f.set(h, se, ne, fe)) return !1;
            return !(C !== void 0 && J !== C && !f.set(h, C, ne << W - V % W, fe));
        }
    }, c = {
        /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */ pushObj: (h, x, q)=>{
            const te = {
                obj: x
            };
            h.push(te), q((fe, ne)=>{
                te.field = fe, ne(), te.field = void 0;
            }), h.pop();
        },
        path: (h)=>{
            const x = [];
            for (const q of h)q.field !== void 0 && x.push(q.field);
            return x.join("/");
        },
        err: (h, x, q)=>{
            const te = new Error(`${h}(${c.path(x)}): ${typeof q == "string" ? q : q.message}`);
            return q instanceof Error && q.stack && (te.stack = q.stack), te;
        },
        resolve: (h, x)=>{
            const q = x.split("/"), te = h.map((W)=>W.obj);
            let fe = 0;
            for(; fe < q.length && q[fe] === ".."; fe++)te.pop();
            let ne = te.pop();
            for(; fe < q.length; fe++){
                if (!ne || ne[q[fe]] === void 0) return;
                ne = ne[q[fe]];
            }
            return ne;
        }
    };
    class l {
        constructor(x, q = {}, te = [], fe = void 0, ne = 0){
            this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.data = x, this.opts = q, this.stack = te, this.parent = fe, this.parentOffset = ne, this.view = o(x);
        }
        /** Internal method for pointers. */ _enablePointers() {
            if (this.parent) return this.parent._enablePointers();
            this.bs || (this.bs = f.create(this.data.length), f.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
        }
        markBytesBS(x, q) {
            return this.parent ? this.parent.markBytesBS(this.parentOffset + x, q) : !q || !this.bs ? !0 : f.setRange(this.bs, this.data.length, x, q, !1);
        }
        markBytes(x) {
            const q = this.pos;
            this.pos += x;
            const te = this.markBytesBS(q, x);
            if (!this.opts.allowMultipleReads && !te) throw this.err(`multiple read pos=${this.pos} len=${x}`);
            return te;
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        readView(x, q) {
            if (!Number.isFinite(x)) throw this.err(`readView: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readView: Unexpected end of buffer");
            const te = q(this.view, this.pos);
            return this.markBytes(x), te;
        }
        // read bytes by absolute offset
        absBytes(x) {
            if (x > this.data.length) throw new Error("Unexpected end of buffer");
            return this.data.subarray(x);
        }
        finish() {
            if (!this.opts.allowUnreadBytes) {
                if (this.bitPos) throw this.err(`${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
                if (this.bs && !this.parent) {
                    const x = f.indices(this.bs, this.data.length, !0);
                    if (x.length) {
                        const q = f.range(x).map(({ pos: te, length: fe })=>`(${te}/${fe})[${t.hex.encode(this.data.subarray(te, te + fe))}]`).join(", ");
                        throw this.err(`unread byte ranges: ${q} (total=${this.data.length})`);
                    } else return;
                }
                if (!this.isEnd()) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
            }
        }
        // User methods
        err(x) {
            return c.err("Reader", this.stack, x);
        }
        offsetReader(x) {
            if (x > this.data.length) throw this.err("offsetReader: Unexpected end of buffer");
            return new l(this.absBytes(x), this.opts, this.stack, this, x);
        }
        bytes(x, q = !1) {
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(x)) throw this.err(`readBytes: wrong length=${x}`);
            if (this.pos + x > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const te = this.data.subarray(this.pos, this.pos + x);
            return q || this.markBytes(x), te;
        }
        byte(x = !1) {
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            if (this.pos + 1 > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const q = this.data[this.pos];
            return x || this.markBytes(1), q;
        }
        get leftBytes() {
            return this.data.length - this.pos;
        }
        get totalBytes() {
            return this.data.length;
        }
        isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
        }
        // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
        bits(x) {
            if (x > 32) throw this.err("BitReader: cannot read more than 32 bits in single call");
            let q = 0;
            for(; x;){
                this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
                const te = Math.min(x, this.bitPos);
                this.bitPos -= te, q = q << te | this.bitBuf >> this.bitPos & 2 ** te - 1, this.bitBuf &= 2 ** this.bitPos - 1, x -= te;
            }
            return q >>> 0;
        }
        find(x, q = this.pos) {
            if (!n(x)) throw this.err(`find: needle is not bytes! ${x}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!x.length) throw this.err("find: needle is empty");
            for(let te = q; (te = this.data.indexOf(x[0], te)) !== -1; te++){
                if (te === -1 || this.data.length - te < x.length) return;
                if (r(x, this.data.subarray(te, te + x.length))) return te;
            }
        }
    }
    class p {
        constructor(x = []){
            this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = !1, this.stack = x, this.view = o(this.viewBuf);
        }
        pushObj(x, q) {
            return c.pushObj(this.stack, x, q);
        }
        writeView(x, q) {
            if (this.finished) throw this.err("buffer: finished");
            if (!a(x) || x > 8) throw new Error(`wrong writeView length=${x}`);
            q(this.view), this.bytes(this.viewBuf.slice(0, x)), this.viewBuf.fill(0);
        }
        // User methods
        err(x) {
            if (this.finished) throw this.err("buffer: finished");
            return c.err("Reader", this.stack, x);
        }
        bytes(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(x), this.pos += x.length;
        }
        byte(x) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([
                x
            ])), this.pos++;
        }
        finish(x = !0) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("buffer: ends with non-empty bit buffer");
            const q = this.buffers.concat(this.ptrs.map((ne)=>ne.buffer)), te = q.map((ne)=>ne.length).reduce((ne, W)=>ne + W, 0), fe = new Uint8Array(te);
            for(let ne = 0, W = 0; ne < q.length; ne++){
                const J = q[ne];
                fe.set(J, W), W += J.length;
            }
            for(let ne = this.pos, W = 0; W < this.ptrs.length; W++){
                const J = this.ptrs[W];
                fe.set(J.ptr.encode(ne), J.pos), ne += J.buffer.length;
            }
            if (x) {
                this.buffers = [];
                for (const ne of this.ptrs)ne.buffer.fill(0);
                this.ptrs = [], this.finished = !0, this.bitBuf = 0;
            }
            return fe;
        }
        bits(x, q) {
            if (q > 32) throw this.err("writeBits: cannot write more than 32 bits in single call");
            if (x >= 2 ** q) throw this.err(`writeBits: value (${x}) >= 2**bits (${q})`);
            for(; q;){
                const te = Math.min(q, 8 - this.bitPos);
                this.bitBuf = this.bitBuf << te | x >> q - te, this.bitPos += te, q -= te, x &= 2 ** q - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([
                    this.bitBuf
                ])), this.pos++);
            }
        }
    }
    const y = (h)=>Uint8Array.from(h).reverse();
    function _(h, x, q) {
        if (q) {
            const te = 2n ** (x - 1n);
            if (h < -te || h >= te) throw new Error(`value out of signed bounds. Expected ${-te} <= ${h} < ${te}`);
        } else if (0n > h || h >= 2n ** x) throw new Error(`value out of unsigned bounds. Expected 0 <= ${h} < ${2n ** x}`);
    }
    function A(h) {
        return {
            // NOTE: we cannot export validate here, since it is likely mistake.
            encodeStream: h.encodeStream,
            decodeStream: h.decodeStream,
            size: h.size,
            encode: (x)=>{
                const q = new p();
                return h.encodeStream(q, x), q.finish();
            },
            decode: (x, q = {})=>{
                const te = new l(x, q), fe = h.decodeStream(te);
                return te.finish(), fe;
            }
        };
    }
    function O(h, x) {
        if (!D(h)) throw new Error(`validate: invalid inner value ${h}`);
        if (typeof x != "function") throw new Error("validate: fn should be function");
        return A({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x(te);
                } catch (ne) {
                    throw q.err(ne);
                }
                h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x(te);
                } catch (fe) {
                    throw q.err(fe);
                }
            }
        });
    }
    const N = (h)=>{
        const x = A(h);
        return h.validate ? O(x, h.validate) : x;
    };
    e.wrap = N;
    const U = (h)=>s(h) && typeof h.decode == "function" && typeof h.encode == "function";
    function D(h) {
        return s(h) && U(h) && typeof h.encodeStream == "function" && typeof h.decodeStream == "function" && (h.size === void 0 || a(h.size));
    }
    function H() {
        return {
            encode: (h)=>{
                if (!Array.isArray(h)) throw new Error("array expected");
                const x = {};
                for (const q of h){
                    if (!Array.isArray(q) || q.length !== 2) throw new Error("array of two elements expected");
                    const te = q[0], fe = q[1];
                    if (x[te] !== void 0) throw new Error(`key(${te}) appears twice in struct`);
                    x[te] = fe;
                }
                return x;
            },
            decode: (h)=>{
                if (!s(h)) throw new Error(`expected plain object, got ${h}`);
                return Object.entries(h);
            }
        };
    }
    const K = {
        encode: (h)=>{
            if (typeof h != "bigint") throw new Error(`expected bigint, got ${typeof h}`);
            if (h > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`element bigger than MAX_SAFE_INTEGER=${h}`);
            return Number(h);
        },
        decode: (h)=>{
            if (!a(h)) throw new Error("element is not a safe integer");
            return BigInt(h);
        }
    };
    function re(h) {
        if (!s(h)) throw new Error("plain object expected");
        return {
            encode: (x)=>{
                if (!a(x) || !(x in h)) throw new Error(`wrong value ${x}`);
                return h[x];
            },
            decode: (x)=>{
                if (typeof x != "string") throw new Error(`wrong value ${typeof x}`);
                return h[x];
            }
        };
    }
    function Q(h, x = !1) {
        if (!a(h)) throw new Error(`decimal/precision: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`decimal/round: expected boolean, got ${typeof x}`);
        const q = 10n ** BigInt(h);
        return {
            encode: (te)=>{
                if (typeof te != "bigint") throw new Error(`expected bigint, got ${typeof te}`);
                let fe = (te < 0n ? -te : te).toString(10), ne = fe.length - h;
                ne < 0 && (fe = fe.padStart(fe.length - ne, "0"), ne = 0);
                let W = fe.length - 1;
                for(; W >= ne && fe[W] === "0"; W--);
                let J = fe.slice(0, ne), V = fe.slice(ne, W + 1);
                return J || (J = "0"), te < 0n && (J = "-" + J), V ? `${J}.${V}` : J;
            },
            decode: (te)=>{
                if (typeof te != "string") throw new Error(`expected string, got ${typeof te}`);
                if (te === "-0") throw new Error("negative zero is not allowed");
                let fe = !1;
                if (te.startsWith("-") && (fe = !0, te = te.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(te)) throw new Error(`wrong string value=${te}`);
                let ne = te.indexOf(".");
                ne = ne === -1 ? te.length : ne;
                const W = te.slice(0, ne), J = te.slice(ne + 1).replace(/0+$/, ""), V = BigInt(W) * q;
                if (!x && J.length > h) throw new Error(`fractional part cannot be represented with this precision (num=${te}, prec=${h})`);
                const C = Math.min(J.length, h), Z = BigInt(J.slice(0, C)) * 10n ** BigInt(h - C), le = V + Z;
                return fe ? -le : le;
            }
        };
    }
    function G(h) {
        if (!Array.isArray(h)) throw new Error(`expected array, got ${typeof h}`);
        for (const x of h)if (!U(x)) throw new Error(`wrong base coder ${x}`);
        return {
            encode: (x)=>{
                for (const q of h){
                    const te = q.encode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/encode: cannot find match in ${x}`);
            },
            decode: (x)=>{
                for (const q of h){
                    const te = q.decode(x);
                    if (te !== void 0) return te;
                }
                throw new Error(`match/decode: cannot find match in ${x}`);
            }
        };
    }
    const R = (h)=>{
        if (!U(h)) throw new Error("BaseCoder expected");
        return {
            encode: h.decode,
            decode: h.encode
        };
    };
    e.coders = {
        dict: H,
        numberBigint: K,
        tsEnum: re,
        decimal: Q,
        match: G,
        reverse: R
    };
    const X = (h)=>{
        if (!a(h)) throw new Error(`bits: wrong length ${h} (${typeof h})`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>x.bits(q, h),
            decodeStream: (x)=>x.bits(h),
            validate: (x)=>{
                if (!a(x)) throw new Error(`bits: wrong value ${x}`);
                return x;
            }
        });
    };
    e.bits = X;
    const $ = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`bigint/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`bigint/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`bigint/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`bigint/sized: expected boolean, got ${typeof te}`);
        const fe = BigInt(h), ne = 2n ** (8n * fe - 1n);
        return (0, e.wrap)({
            size: te ? h : void 0,
            encodeStream: (W, J)=>{
                q && J < 0 && (J = J | ne);
                const V = [];
                for(let Z = 0; Z < h; Z++)V.push(Number(J & 255n)), J >>= 8n;
                let C = new Uint8Array(V).reverse();
                if (!te) {
                    let Z = 0;
                    for(Z = 0; Z < C.length && C[Z] === 0; Z++);
                    C = C.subarray(Z);
                }
                W.bytes(x ? C.reverse() : C);
            },
            decodeStream: (W)=>{
                const J = W.bytes(te ? h : Math.min(h, W.leftBytes)), V = x ? J : y(J);
                let C = 0n;
                for(let Z = 0; Z < V.length; Z++)C |= BigInt(V[Z]) << 8n * BigInt(Z);
                return q && C & ne && (C = (C ^ ne) - ne), C;
            },
            validate: (W)=>{
                if (typeof W != "bigint") throw new Error(`bigint: invalid value: ${W}`);
                return _(W, 8n * fe, !!q), W;
            }
        });
    };
    e.bigint = $, e.U256LE = (0, e.bigint)(32, !0), e.U256BE = (0, e.bigint)(32, !1), e.I256LE = (0, e.bigint)(32, !0, !0), e.I256BE = (0, e.bigint)(32, !1, !0), e.U128LE = (0, e.bigint)(16, !0), e.U128BE = (0, e.bigint)(16, !1), e.I128LE = (0, e.bigint)(16, !0, !0), e.I128BE = (0, e.bigint)(16, !1, !0), e.U64LE = (0, e.bigint)(8, !0), e.U64BE = (0, e.bigint)(8, !1), e.I64LE = (0, e.bigint)(8, !0, !0), e.I64BE = (0, e.bigint)(8, !1, !0);
    const S = (h, x = !1, q = !1, te = !0)=>{
        if (!a(h)) throw new Error(`int/size: wrong value ${h}`);
        if (typeof x != "boolean") throw new Error(`int/le: expected boolean, got ${typeof x}`);
        if (typeof q != "boolean") throw new Error(`int/signed: expected boolean, got ${typeof q}`);
        if (typeof te != "boolean") throw new Error(`int/sized: expected boolean, got ${typeof te}`);
        if (h > 6) throw new Error("int supports size up to 6 bytes (48 bits): use bigints instead");
        return L((0, e.bigint)(h, x, q, te), e.coders.numberBigint);
    };
    e.int = S;
    const w = (h, x)=>(0, e.wrap)({
            size: h,
            encodeStream: (q, te)=>q.writeView(h, (fe)=>x.write(fe, te)),
            decodeStream: (q)=>q.readView(h, x.read),
            validate: (q)=>{
                if (typeof q != "number") throw new Error(`viewCoder: expected number, got ${typeof q}`);
                return x.validate && x.validate(q), q;
            }
        }), g = (h, x, q)=>{
        const te = h * 8, fe = 2 ** (te - 1), ne = (V)=>{
            if (!a(V)) throw new Error(`sintView: value is not safe integer: ${V}`);
            if (V < -fe || V >= fe) throw new Error(`sintView: value out of bounds. Expected ${-fe} <= ${V} < ${fe}`);
        }, W = 2 ** te, J = (V)=>{
            if (!a(V)) throw new Error(`uintView: value is not safe integer: ${V}`);
            if (0 > V || V >= W) throw new Error(`uintView: value out of bounds. Expected 0 <= ${V} < ${W}`);
        };
        return w(h, {
            write: q.write,
            read: q.read,
            validate: x ? ne : J
        });
    };
    e.U32LE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !0),
        write: (h, x)=>h.setUint32(0, x, !0)
    }), e.U32BE = g(4, !1, {
        read: (h, x)=>h.getUint32(x, !1),
        write: (h, x)=>h.setUint32(0, x, !1)
    }), e.I32LE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !0),
        write: (h, x)=>h.setInt32(0, x, !0)
    }), e.I32BE = g(4, !0, {
        read: (h, x)=>h.getInt32(x, !1),
        write: (h, x)=>h.setInt32(0, x, !1)
    }), e.U16LE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !0),
        write: (h, x)=>h.setUint16(0, x, !0)
    }), e.U16BE = g(2, !1, {
        read: (h, x)=>h.getUint16(x, !1),
        write: (h, x)=>h.setUint16(0, x, !1)
    }), e.I16LE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !0),
        write: (h, x)=>h.setInt16(0, x, !0)
    }), e.I16BE = g(2, !0, {
        read: (h, x)=>h.getInt16(x, !1),
        write: (h, x)=>h.setInt16(0, x, !1)
    }), e.U8 = g(1, !1, {
        read: (h, x)=>h.getUint8(x),
        write: (h, x)=>h.setUint8(0, x)
    }), e.I8 = g(1, !0, {
        read: (h, x)=>h.getInt8(x),
        write: (h, x)=>h.setInt8(0, x)
    });
    const m = (h)=>w(4, {
            read: (x, q)=>x.getFloat32(q, h),
            write: (x, q)=>x.setFloat32(0, q, h),
            validate: (x)=>{
                if (Math.fround(x) !== x && !Number.isNaN(x)) throw new Error(`f32: wrong value=${x}`);
            }
        }), E = (h)=>w(8, {
            read: (x, q)=>x.getFloat64(q, h),
            write: (x, q)=>x.setFloat64(0, q, h)
        });
    e.F32BE = m(!1), e.F32LE = m(!0), e.F64BE = E(!1), e.F64LE = E(!0), e.bool = (0, e.wrap)({
        size: 1,
        encodeStream: (h, x)=>h.byte(x ? 1 : 0),
        decodeStream: (h)=>{
            const x = h.byte();
            if (x !== 0 && x !== 1) throw h.err(`bool: invalid value ${x}`);
            return x === 1;
        },
        validate: (h)=>{
            if (typeof h != "boolean") throw new Error(`bool: invalid value ${h}`);
            return h;
        }
    });
    const T = (h, x = !1)=>{
        if (typeof x != "boolean") throw new Error(`bytes/le: expected boolean, got ${typeof x}`);
        const q = u(h), te = n(h);
        return (0, e.wrap)({
            size: typeof h == "number" ? h : void 0,
            encodeStream: (fe, ne)=>{
                te || q.encodeStream(fe, ne.length), fe.bytes(x ? y(ne) : ne), te && fe.bytes(h);
            },
            decodeStream: (fe)=>{
                let ne;
                if (te) {
                    const W = fe.find(h);
                    if (!W) throw fe.err("bytes: cannot find terminator");
                    ne = fe.bytes(W - fe.pos), fe.bytes(h.length);
                } else ne = fe.bytes(h === null ? fe.leftBytes : q.decodeStream(fe));
                return x ? y(ne) : ne;
            },
            validate: (fe)=>{
                if (!n(fe)) throw new Error(`bytes: invalid value ${fe}`);
                return fe;
            }
        });
    };
    e.bytes = T;
    function I(h, x) {
        if (!D(x)) throw new Error(`prefix: invalid inner value ${x}`);
        return L(T(h), R(x));
    }
    const P = (h, x = !1)=>O(L(T(h, x), t.utf8), (q)=>{
            if (typeof q != "string") throw new Error(`expected string, got ${typeof q}`);
            return q;
        });
    e.string = P, e.cstring = (0, e.string)(e.NULL);
    const k = (h, x = {
        isLE: !1,
        with0x: !1
    })=>{
        let q = L(T(h, x.isLE), t.hex);
        const te = x.with0x;
        if (typeof te != "boolean") throw new Error(`hex/with0x: expected boolean, got ${typeof te}`);
        return te && (q = L(q, {
            encode: (fe)=>`0x${fe}`,
            decode: (fe)=>{
                if (!fe.startsWith("0x")) throw new Error("hex(with0x=true).encode input should start with 0x");
                return fe.slice(2);
            }
        })), q;
    };
    e.hex = k;
    function L(h, x) {
        if (!D(h)) throw new Error(`apply: invalid inner value ${h}`);
        if (!U(x)) throw new Error(`apply: invalid base value ${h}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                let fe;
                try {
                    fe = x.decode(te);
                } catch (ne) {
                    throw q.err("" + ne);
                }
                return h.encodeStream(q, fe);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q);
                try {
                    return x.encode(te);
                } catch (fe) {
                    throw q.err("" + fe);
                }
            }
        });
    }
    function j(h) {
        if (typeof h != "function") throw new Error(`lazy: expected function, got ${typeof h}`);
        return (0, e.wrap)({
            encodeStream: (x, q)=>h().encodeStream(x, q),
            decodeStream: (x)=>h().decodeStream(x)
        });
    }
    const ie = (h, x = !1)=>{
        if (!n(h)) throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof h}`);
        if (typeof x != "boolean") throw new Error(`flag/xor: expected boolean, got ${typeof x}`);
        return (0, e.wrap)({
            size: h.length,
            encodeStream: (q, te)=>{
                !!te !== x && q.bytes(h);
            },
            decodeStream: (q)=>{
                let te = q.leftBytes >= h.length;
                return te && (te = r(q.bytes(h.length, !0), h), te && q.bytes(h.length)), te !== x;
            },
            validate: (q)=>{
                if (q !== void 0 && typeof q != "boolean") throw new Error(`flag: expected boolean value or undefined, got ${typeof q}`);
                return q;
            }
        });
    };
    e.flag = ie;
    function ue(h, x, q) {
        if (!D(x)) throw new Error(`flagged: invalid inner value ${x}`);
        if (typeof h != "string" && !D(x)) throw new Error(`flagged: wrong path=${h}`);
        return (0, e.wrap)({
            encodeStream: (te, fe)=>{
                typeof h == "string" ? c.resolve(te.stack, h) ? x.encodeStream(te, fe) : q && x.encodeStream(te, q) : (h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q && x.encodeStream(te, q));
            },
            decodeStream: (te)=>{
                let fe = !1;
                if (typeof h == "string" ? fe = !!c.resolve(te.stack, h) : fe = h.decodeStream(te), fe) return x.decodeStream(te);
                q && x.decodeStream(te);
            }
        });
    }
    function ce(h, x, q) {
        if (!D(h) || !D(x)) throw new Error(`optional: invalid flag or inner value flag=${h} inner=${x}`);
        return (0, e.wrap)({
            size: q !== void 0 && h.size && x.size ? h.size + x.size : void 0,
            encodeStream: (te, fe)=>{
                h.encodeStream(te, !!fe), fe ? x.encodeStream(te, fe) : q !== void 0 && x.encodeStream(te, q);
            },
            decodeStream: (te)=>{
                if (h.decodeStream(te)) return x.decodeStream(te);
                q !== void 0 && x.decodeStream(te);
            }
        });
    }
    function he(h, x, q = !0) {
        if (!D(h)) throw new Error(`magic: invalid inner value ${h}`);
        if (typeof q != "boolean") throw new Error(`magic: expected boolean, got ${typeof q}`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                if (q && typeof fe != "object" && fe !== x || n(x) && !r(x, fe)) throw te.err(`magic: invalid value: ${fe} !== ${x}`);
            },
            validate: (te)=>{
                if (te !== void 0) throw new Error(`magic: wrong value=${typeof te}`);
                return te;
            }
        });
    }
    const ee = (h)=>{
        const x = typeof h == "string" ? t.utf8.decode(h) : h;
        return he(T(x.length), x);
    };
    e.magicBytes = ee;
    function ae(h) {
        return (0, e.wrap)({
            encodeStream: (x, q)=>{
                if (q !== h) throw new Error(`constant: invalid value ${q} (exp: ${h})`);
            },
            decodeStream: (x)=>h
        });
    }
    function ye(h) {
        let x = 0;
        for (const q of h){
            if (q.size === void 0) return;
            if (!a(q.size)) throw new Error(`sizeof: wrong element size=${x}`);
            x += q.size;
        }
        return x;
    }
    function Se(h) {
        if (!s(h)) throw new Error(`struct: expected plain object, got ${h}`);
        for(const x in h)if (!D(h[x])) throw new Error(`struct: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(Object.values(h)),
            encodeStream: (x, q)=>{
                x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = {};
                return x.pushObj(q, (te)=>{
                    for(const fe in h)te(fe, ()=>q[fe] = h[fe].decodeStream(x));
                }), q;
            },
            validate: (x)=>{
                if (typeof x != "object" || x === null) throw new Error(`struct: invalid value ${x}`);
                return x;
            }
        });
    }
    function De(h) {
        if (!Array.isArray(h)) throw new Error(`Packed.Tuple: got ${typeof h} instead of array`);
        for(let x = 0; x < h.length; x++)if (!D(h[x])) throw new Error(`tuple: field ${x} is not CoderType`);
        return (0, e.wrap)({
            size: ye(h),
            encodeStream: (x, q)=>{
                if (!Array.isArray(q)) throw x.err(`tuple: invalid value ${q}`);
                x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>h[fe].encodeStream(x, q[fe]));
                });
            },
            decodeStream: (x)=>{
                const q = [];
                return x.pushObj(q, (te)=>{
                    for(let fe = 0; fe < h.length; fe++)te(`${fe}`, ()=>q.push(h[fe].decodeStream(x)));
                }), q;
            },
            validate: (x)=>{
                if (!Array.isArray(x)) throw new Error(`tuple: invalid value ${x}`);
                if (x.length !== h.length) throw new Error(`tuple: wrong length=${x.length}, expected ${h.length}`);
                return x;
            }
        });
    }
    function Re(h, x) {
        if (!D(x)) throw new Error(`array: invalid inner value ${x}`);
        const q = u(typeof h == "string" ? `../${h}` : h);
        return (0, e.wrap)({
            size: typeof h == "number" && x.size ? h * x.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te;
                ne.pushObj(fe, (W)=>{
                    n(h) || q.encodeStream(te, fe.length);
                    for(let J = 0; J < fe.length; J++)W(`${J}`, ()=>{
                        const V = fe[J], C = te.pos;
                        if (x.encodeStream(te, V), n(h)) {
                            if (h.length > ne.pos - C) return;
                            const Z = ne.finish(!1).subarray(C, ne.pos);
                            if (r(Z.subarray(0, h.length), h)) throw ne.err(`array: inner element encoding same as separator. elm=${V} data=${Z}`);
                        }
                    });
                }), n(h) && te.bytes(h);
            },
            decodeStream: (te)=>{
                const fe = [];
                return te.pushObj(fe, (ne)=>{
                    if (h === null) for(let W = 0; !te.isEnd() && (ne(`${W}`, ()=>fe.push(x.decodeStream(te))), !(x.size && te.leftBytes < x.size)); W++);
                    else if (n(h)) for(let W = 0;; W++){
                        if (r(te.bytes(h.length, !0), h)) {
                            te.bytes(h.length);
                            break;
                        }
                        ne(`${W}`, ()=>fe.push(x.decodeStream(te)));
                    }
                    else {
                        let W;
                        ne("arrayLen", ()=>W = q.decodeStream(te));
                        for(let J = 0; J < W; J++)ne(`${J}`, ()=>fe.push(x.decodeStream(te)));
                    }
                }), fe;
            },
            validate: (te)=>{
                if (!Array.isArray(te)) throw new Error(`array: invalid value ${te}`);
                return te;
            }
        });
    }
    function Ce(h, x) {
        if (!D(h)) throw new Error(`map: invalid inner value ${h}`);
        if (!s(x)) throw new Error("map: variants should be plain object");
        const q = /* @__PURE__ */ new Map();
        for(const te in x)q.set(x[te], te);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (te, fe)=>h.encodeStream(te, x[fe]),
            decodeStream: (te)=>{
                const fe = h.decodeStream(te), ne = q.get(fe);
                if (ne === void 0) throw te.err(`Enum: unknown value: ${fe} ${Array.from(q.keys())}`);
                return ne;
            },
            validate: (te)=>{
                if (typeof te != "string") throw new Error(`map: invalid value ${te}`);
                if (!(te in x)) throw new Error(`Map: unknown variant: ${te}`);
                return te;
            }
        });
    }
    function M(h, x) {
        if (!D(h)) throw new Error(`tag: invalid tag value ${h}`);
        if (!s(x)) throw new Error("tag: variants should be plain object");
        for(const q in x)if (!D(x[q])) throw new Error(`tag: variant ${q} is not CoderType`);
        return (0, e.wrap)({
            size: h.size,
            encodeStream: (q, te)=>{
                const { TAG: fe, data: ne } = te, W = x[fe];
                h.encodeStream(q, fe), W.encodeStream(q, ne);
            },
            decodeStream: (q)=>{
                const te = h.decodeStream(q), fe = x[te];
                if (!fe) throw q.err(`Tag: invalid tag ${te}`);
                return {
                    TAG: te,
                    data: fe.decodeStream(q)
                };
            },
            validate: (q)=>{
                const { TAG: te } = q;
                if (!x[te]) throw new Error(`Tag: invalid tag ${te.toString()}`);
                return q;
            }
        });
    }
    function z(h, x) {
        if (!D(h)) throw new Error(`mappedTag: invalid tag value ${M}`);
        if (!s(x)) throw new Error("mappedTag: variants should be plain object");
        const q = {}, te = {};
        for(const fe in x){
            const ne = x[fe];
            q[fe] = ne[0], te[fe] = ne[1];
        }
        return M(Ce(h, q), te);
    }
    function de(h, x = !1) {
        if (typeof x != "boolean") throw new Error(`bitset/pad: expected boolean, got ${typeof x}`);
        if (!Array.isArray(h)) throw new Error("bitset/names: expected array");
        for (const q of h)if (typeof q != "string") throw new Error("bitset/names: expected array of strings");
        return (0, e.wrap)({
            encodeStream: (q, te)=>{
                for(let fe = 0; fe < h.length; fe++)q.bits(+te[h[fe]], 1);
                x && h.length % 8 && q.bits(0, 8 - h.length % 8);
            },
            decodeStream: (q)=>{
                const te = {};
                for(let fe = 0; fe < h.length; fe++)te[h[fe]] = !!q.bits(1);
                return x && h.length % 8 && q.bits(8 - h.length % 8), te;
            },
            validate: (q)=>{
                if (!s(q)) throw new Error(`bitset: invalid value ${q}`);
                for (const te of Object.values(q))if (typeof te != "boolean") throw new Error("expected boolean");
                return q;
            }
        });
    }
    const _e = (h)=>0;
    e.ZeroPad = _e;
    function Ie(h, x) {
        return x % h === 0 ? 0 : h - x % h;
    }
    function je(h, x, q) {
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (!D(x)) throw new Error(`padLeft: invalid inner value ${x}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padLeft: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        if (!x.size) throw new Error("padLeft cannot have dynamic size");
        return (0, e.wrap)({
            size: x.size + Ie(h, x.size),
            encodeStream: (fe, ne)=>{
                const W = Ie(h, x.size);
                for(let J = 0; J < W; J++)fe.byte(te(J));
                x.encodeStream(fe, ne);
            },
            decodeStream: (fe)=>(fe.bytes(Ie(h, x.size)), x.decodeStream(fe))
        });
    }
    function Ke(h, x, q) {
        if (!D(x)) throw new Error(`padRight: invalid inner value ${x}`);
        if (!a(h) || h <= 0) throw new Error(`padLeft: wrong blockSize=${h}`);
        if (q !== void 0 && typeof q != "function") throw new Error(`padRight: wrong padFn=${typeof q}`);
        const te = q || e.ZeroPad;
        return (0, e.wrap)({
            size: x.size ? x.size + Ie(h, x.size) : void 0,
            encodeStream: (fe, ne)=>{
                const W = fe, J = W.pos;
                x.encodeStream(fe, ne);
                const V = Ie(h, W.pos - J);
                for(let C = 0; C < V; C++)fe.byte(te(C));
            },
            decodeStream: (fe)=>{
                const ne = fe.pos, W = x.decodeStream(fe);
                return fe.bytes(Ie(h, fe.pos - ne)), W;
            }
        });
    }
    function Ue(h, x, q = !1) {
        if (!D(h)) throw new Error(`pointer: invalid ptr value ${h}`);
        if (!D(x)) throw new Error(`pointer: invalid inner value ${x}`);
        if (typeof q != "boolean") throw new Error(`pointer/sized: expected boolean, got ${typeof q}`);
        if (!h.size) throw new Error("unsized pointer");
        return (0, e.wrap)({
            size: q ? h.size : void 0,
            encodeStream: (te, fe)=>{
                const ne = te, W = ne.pos;
                h.encodeStream(te, 0), ne.ptrs.push({
                    pos: W,
                    ptr: h,
                    buffer: x.encode(fe)
                });
            },
            decodeStream: (te)=>{
                const fe = h.decodeStream(te);
                return te._enablePointers(), x.decodeStream(te.offsetReader(fe));
            }
        });
    }
    e._TEST = {
        _bitset: f,
        _Reader: l,
        _Writer: p,
        Path: c
    };
})(jf);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.TEST_NETWORK = e.NETWORK = e.TAPROOT_UNSPENDABLE_KEY = e.PubT = e.tagSchnorr = e.signSchnorr = e.pubECDSA = e.pubSchnorr = e.randomPrivateKeyBytes = e.sha256x2 = e.hash160 = e.sha256 = e.isBytes = e.equalBytes = e.concatBytes = void 0, e.signECDSA = y, e.validatePubkey = A, e.tapTweak = O, e.taprootTweakPrivKey = N, e.taprootTweakPubkey = U, e.compareBytes = D;
    const t = p3, r = no, n = en;
    Object.defineProperty(e, "sha256", {
        enumerable: !0,
        get: function() {
            return n.sha256;
        }
    });
    const i = jf, o = t.secp256k1.ProjectivePoint, s = t.secp256k1.CURVE.n, a = i.utils.isBytes;
    e.isBytes = a;
    const u = i.utils.concatBytes;
    e.concatBytes = u;
    const f = i.utils.equalBytes;
    e.equalBytes = f;
    const c = (H)=>(0, r.ripemd160)((0, n.sha256)(H));
    e.hash160 = c;
    const l = (...H)=>(0, n.sha256)((0, n.sha256)(u(...H)));
    e.sha256x2 = l, e.randomPrivateKeyBytes = t.schnorr.utils.randomPrivateKey, e.pubSchnorr = t.schnorr.getPublicKey, e.pubECDSA = t.secp256k1.getPublicKey;
    const p = (H)=>H.r < s / 2n;
    function y(H, K, re = !1) {
        let Q = t.secp256k1.sign(H, K);
        if (re && !p(Q)) {
            const G = new Uint8Array(32);
            let R = 0;
            for(; !p(Q);)if (G.set(i.U32LE.encode(R++)), Q = t.secp256k1.sign(H, K, {
                extraEntropy: G
            }), R > 4294967295) throw new Error("lowR counter overflow: report the error");
        }
        return Q.toDERRawBytes();
    }
    e.signSchnorr = t.schnorr.sign, e.tagSchnorr = t.schnorr.utils.taggedHash;
    var _;
    (function(H) {
        H[H.ecdsa = 0] = "ecdsa", H[H.schnorr = 1] = "schnorr";
    })(_ || (e.PubT = _ = {}));
    function A(H, K) {
        const re = H.length;
        if (K === _.ecdsa) {
            if (re === 32) throw new Error("Expected non-Schnorr key");
            return o.fromHex(H), H;
        } else if (K === _.schnorr) {
            if (re !== 32) throw new Error("Expected 32-byte Schnorr key");
            return t.schnorr.utils.lift_x(t.schnorr.utils.bytesToNumberBE(H)), H;
        } else throw new Error("Unknown key type");
    }
    function O(H, K) {
        const re = t.schnorr.utils, Q = re.taggedHash("TapTweak", H, K), G = re.bytesToNumberBE(Q);
        if (G >= s) throw new Error("tweak higher than curve order");
        return G;
    }
    function N(H, K = Uint8Array.of()) {
        const re = t.schnorr.utils, Q = re.bytesToNumberBE(H), G = o.fromPrivateKey(Q), R = G.hasEvenY() ? Q : re.mod(-Q, s), X = re.pointToBytes(G), $ = O(X, K);
        return re.numberToBytesBE(re.mod(R + $, s), 32);
    }
    function U(H, K) {
        const re = t.schnorr.utils, Q = O(H, K), R = re.lift_x(re.bytesToNumberBE(H)).add(o.fromPrivateKey(Q)), X = R.hasEvenY() ? 0 : 1;
        return [
            re.pointToBytes(R),
            X
        ];
    }
    e.TAPROOT_UNSPENDABLE_KEY = (0, n.sha256)(o.BASE.toRawBytes(!1)), e.NETWORK = {
        bech32: "bc",
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
    }, e.TEST_NETWORK = {
        bech32: "tb",
        pubKeyHash: 111,
        scriptHash: 196,
        wif: 239
    };
    function D(H, K) {
        if (!a(H) || !a(K)) throw new Error(`cmp: wrong type a=${typeof H} b=${typeof K}`);
        const re = Math.min(H.length, K.length);
        for(let Q = 0; Q < re; Q++)if (H[Q] != K[Q]) return Math.sign(H[Q] - K[Q]);
        return Math.sign(H.length - K.length);
    }
})(wa);
var yp = {}, v0 = {}, jd = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RawOldTx = e.RawTx = e.RawOutput = e.RawInput = e.BTCArray = e.RawWitness = e.VarBytes = e.CompactSizeLen = e.CompactSize = e.Script = e.OP = e.MAX_SCRIPT_BYTE_LENGTH = void 0, e.ScriptNum = i, e.OpToNum = o;
    const t = jf, r = wa;
    e.MAX_SCRIPT_BYTE_LENGTH = 520;
    var n;
    (function(c) {
        c[c.OP_0 = 0] = "OP_0", c[c.PUSHDATA1 = 76] = "PUSHDATA1", c[c.PUSHDATA2 = 77] = "PUSHDATA2", c[c.PUSHDATA4 = 78] = "PUSHDATA4", c[c["1NEGATE"] = 79] = "1NEGATE", c[c.RESERVED = 80] = "RESERVED", c[c.OP_1 = 81] = "OP_1", c[c.OP_2 = 82] = "OP_2", c[c.OP_3 = 83] = "OP_3", c[c.OP_4 = 84] = "OP_4", c[c.OP_5 = 85] = "OP_5", c[c.OP_6 = 86] = "OP_6", c[c.OP_7 = 87] = "OP_7", c[c.OP_8 = 88] = "OP_8", c[c.OP_9 = 89] = "OP_9", c[c.OP_10 = 90] = "OP_10", c[c.OP_11 = 91] = "OP_11", c[c.OP_12 = 92] = "OP_12", c[c.OP_13 = 93] = "OP_13", c[c.OP_14 = 94] = "OP_14", c[c.OP_15 = 95] = "OP_15", c[c.OP_16 = 96] = "OP_16", c[c.NOP = 97] = "NOP", c[c.VER = 98] = "VER", c[c.IF = 99] = "IF", c[c.NOTIF = 100] = "NOTIF", c[c.VERIF = 101] = "VERIF", c[c.VERNOTIF = 102] = "VERNOTIF", c[c.ELSE = 103] = "ELSE", c[c.ENDIF = 104] = "ENDIF", c[c.VERIFY = 105] = "VERIFY", c[c.RETURN = 106] = "RETURN", c[c.TOALTSTACK = 107] = "TOALTSTACK", c[c.FROMALTSTACK = 108] = "FROMALTSTACK", c[c["2DROP"] = 109] = "2DROP", c[c["2DUP"] = 110] = "2DUP", c[c["3DUP"] = 111] = "3DUP", c[c["2OVER"] = 112] = "2OVER", c[c["2ROT"] = 113] = "2ROT", c[c["2SWAP"] = 114] = "2SWAP", c[c.IFDUP = 115] = "IFDUP", c[c.DEPTH = 116] = "DEPTH", c[c.DROP = 117] = "DROP", c[c.DUP = 118] = "DUP", c[c.NIP = 119] = "NIP", c[c.OVER = 120] = "OVER", c[c.PICK = 121] = "PICK", c[c.ROLL = 122] = "ROLL", c[c.ROT = 123] = "ROT", c[c.SWAP = 124] = "SWAP", c[c.TUCK = 125] = "TUCK", c[c.CAT = 126] = "CAT", c[c.SUBSTR = 127] = "SUBSTR", c[c.LEFT = 128] = "LEFT", c[c.RIGHT = 129] = "RIGHT", c[c.SIZE = 130] = "SIZE", c[c.INVERT = 131] = "INVERT", c[c.AND = 132] = "AND", c[c.OR = 133] = "OR", c[c.XOR = 134] = "XOR", c[c.EQUAL = 135] = "EQUAL", c[c.EQUALVERIFY = 136] = "EQUALVERIFY", c[c.RESERVED1 = 137] = "RESERVED1", c[c.RESERVED2 = 138] = "RESERVED2", c[c["1ADD"] = 139] = "1ADD", c[c["1SUB"] = 140] = "1SUB", c[c["2MUL"] = 141] = "2MUL", c[c["2DIV"] = 142] = "2DIV", c[c.NEGATE = 143] = "NEGATE", c[c.ABS = 144] = "ABS", c[c.NOT = 145] = "NOT", c[c["0NOTEQUAL"] = 146] = "0NOTEQUAL", c[c.ADD = 147] = "ADD", c[c.SUB = 148] = "SUB", c[c.MUL = 149] = "MUL", c[c.DIV = 150] = "DIV", c[c.MOD = 151] = "MOD", c[c.LSHIFT = 152] = "LSHIFT", c[c.RSHIFT = 153] = "RSHIFT", c[c.BOOLAND = 154] = "BOOLAND", c[c.BOOLOR = 155] = "BOOLOR", c[c.NUMEQUAL = 156] = "NUMEQUAL", c[c.NUMEQUALVERIFY = 157] = "NUMEQUALVERIFY", c[c.NUMNOTEQUAL = 158] = "NUMNOTEQUAL", c[c.LESSTHAN = 159] = "LESSTHAN", c[c.GREATERTHAN = 160] = "GREATERTHAN", c[c.LESSTHANOREQUAL = 161] = "LESSTHANOREQUAL", c[c.GREATERTHANOREQUAL = 162] = "GREATERTHANOREQUAL", c[c.MIN = 163] = "MIN", c[c.MAX = 164] = "MAX", c[c.WITHIN = 165] = "WITHIN", c[c.RIPEMD160 = 166] = "RIPEMD160", c[c.SHA1 = 167] = "SHA1", c[c.SHA256 = 168] = "SHA256", c[c.HASH160 = 169] = "HASH160", c[c.HASH256 = 170] = "HASH256", c[c.CODESEPARATOR = 171] = "CODESEPARATOR", c[c.CHECKSIG = 172] = "CHECKSIG", c[c.CHECKSIGVERIFY = 173] = "CHECKSIGVERIFY", c[c.CHECKMULTISIG = 174] = "CHECKMULTISIG", c[c.CHECKMULTISIGVERIFY = 175] = "CHECKMULTISIGVERIFY", c[c.NOP1 = 176] = "NOP1", c[c.CHECKLOCKTIMEVERIFY = 177] = "CHECKLOCKTIMEVERIFY", c[c.CHECKSEQUENCEVERIFY = 178] = "CHECKSEQUENCEVERIFY", c[c.NOP4 = 179] = "NOP4", c[c.NOP5 = 180] = "NOP5", c[c.NOP6 = 181] = "NOP6", c[c.NOP7 = 182] = "NOP7", c[c.NOP8 = 183] = "NOP8", c[c.NOP9 = 184] = "NOP9", c[c.NOP10 = 185] = "NOP10", c[c.CHECKSIGADD = 186] = "CHECKSIGADD", c[c.INVALID = 255] = "INVALID";
    })(n || (e.OP = n = {}));
    function i(c = 6, l = !1) {
        return t.wrap({
            encodeStream: (p, y)=>{
                if (y === 0n) return;
                const _ = y < 0, A = BigInt(y), O = [];
                for(let N = _ ? -A : A; N; N >>= 8n)O.push(Number(N & 0xffn));
                O[O.length - 1] >= 128 ? O.push(_ ? 128 : 0) : _ && (O[O.length - 1] |= 128), p.bytes(new Uint8Array(O));
            },
            decodeStream: (p)=>{
                const y = p.leftBytes;
                if (y > c) throw new Error(`ScriptNum: number (${y}) bigger than limit=${c}`);
                if (y === 0) return 0n;
                if (l) {
                    const O = p.bytes(y, !0);
                    if (!(O[O.length - 1] & 127) && (y <= 1 || !(O[O.length - 2] & 128))) throw new Error("Non-minimally encoded ScriptNum");
                }
                let _ = 0, A = 0n;
                for(let O = 0; O < y; ++O)_ = p.byte(), A |= BigInt(_) << 8n * BigInt(O);
                return _ >= 128 && (A &= 2n ** BigInt(y * 8) - 1n >> 1n, A = -A), A;
            }
        });
    }
    function o(c, l = 4, p = !0) {
        if (typeof c == "number") return c;
        if ((0, r.isBytes)(c)) try {
            const y = i(l, p).decode(c);
            return y > Number.MAX_SAFE_INTEGER ? void 0 : Number(y);
        } catch  {
            return;
        }
    }
    e.Script = t.wrap({
        encodeStream: (c, l)=>{
            for (let p of l){
                if (typeof p == "string") {
                    if (n[p] === void 0) throw new Error(`Unknown opcode=${p}`);
                    c.byte(n[p]);
                    continue;
                } else if (typeof p == "number") {
                    if (p === 0) {
                        c.byte(0);
                        continue;
                    } else if (1 <= p && p <= 16) {
                        c.byte(n.OP_1 - 1 + p);
                        continue;
                    }
                }
                if (typeof p == "number" && (p = i().encode(BigInt(p))), !(0, r.isBytes)(p)) throw new Error(`Wrong Script OP=${p} (${typeof p})`);
                const y = p.length;
                y < n.PUSHDATA1 ? c.byte(y) : y <= 255 ? (c.byte(n.PUSHDATA1), c.byte(y)) : y <= 65535 ? (c.byte(n.PUSHDATA2), c.bytes(t.U16LE.encode(y))) : (c.byte(n.PUSHDATA4), c.bytes(t.U32LE.encode(y))), c.bytes(p);
            }
        },
        decodeStream: (c)=>{
            const l = [];
            for(; !c.isEnd();){
                const p = c.byte();
                if (n.OP_0 < p && p <= n.PUSHDATA4) {
                    let y;
                    if (p < n.PUSHDATA1) y = p;
                    else if (p === n.PUSHDATA1) y = t.U8.decodeStream(c);
                    else if (p === n.PUSHDATA2) y = t.U16LE.decodeStream(c);
                    else if (p === n.PUSHDATA4) y = t.U32LE.decodeStream(c);
                    else throw new Error("Should be not possible");
                    l.push(c.bytes(y));
                } else if (p === 0) l.push(0);
                else if (n.OP_1 <= p && p <= n.OP_16) l.push(p - (n.OP_1 - 1));
                else {
                    const y = n[p];
                    if (y === void 0) throw new Error(`Unknown opcode=${p.toString(16)}`);
                    l.push(y);
                }
            }
            return l;
        }
    });
    const s = {
        253: [
            253,
            2,
            253n,
            65535n
        ],
        254: [
            254,
            4,
            65536n,
            4294967295n
        ],
        255: [
            255,
            8,
            4294967296n,
            18446744073709551615n
        ]
    };
    e.CompactSize = t.wrap({
        encodeStream: (c, l)=>{
            if (typeof l == "number" && (l = BigInt(l)), 0n <= l && l <= 252n) return c.byte(Number(l));
            for (const [p, y, _, A] of Object.values(s))if (!(_ > l || l > A)) {
                c.byte(p);
                for(let O = 0; O < y; O++)c.byte(Number(l >> 8n * BigInt(O) & 0xffn));
                return;
            }
            throw c.err(`VarInt too big: ${l}`);
        },
        decodeStream: (c)=>{
            const l = c.byte();
            if (l <= 252) return BigInt(l);
            const [p, y, _] = s[l];
            let A = 0n;
            for(let O = 0; O < y; O++)A |= BigInt(c.byte()) << 8n * BigInt(O);
            if (A < _) throw c.err(`Wrong CompactSize(${8 * y})`);
            return A;
        }
    }), e.CompactSizeLen = t.apply(e.CompactSize, t.coders.numberBigint), e.VarBytes = t.bytes(e.CompactSize), e.RawWitness = t.array(e.CompactSizeLen, e.VarBytes);
    const a = (c)=>t.array(e.CompactSize, c);
    e.BTCArray = a, e.RawInput = t.struct({
        txid: t.bytes(32, !0),
        // hash(prev_tx),
        index: t.U32LE,
        // output number of previous tx
        finalScriptSig: e.VarBytes,
        // btc merges input and output script, executes it. If ok = tx passes
        sequence: t.U32LE
    }), e.RawOutput = t.struct({
        amount: t.U64LE,
        script: e.VarBytes
    });
    const u = t.struct({
        version: t.I32LE,
        segwitFlag: t.flag(new Uint8Array([
            0,
            1
        ])),
        inputs: (0, e.BTCArray)(e.RawInput),
        outputs: (0, e.BTCArray)(e.RawOutput),
        witnesses: t.flagged("segwitFlag", t.array("inputs/length", e.RawWitness)),
        // < 500000000	Block number at which this transaction is unlocked
        // >= 500000000	UNIX timestamp at which this transaction is unlocked
        // Handled as part of PSBTv2
        lockTime: t.U32LE
    });
    function f(c) {
        if (c.segwitFlag && c.witnesses && !c.witnesses.length) throw new Error("Segwit flag with empty witnesses array");
        return c;
    }
    e.RawTx = t.validate(u, f), e.RawOldTx = t.struct({
        version: t.I32LE,
        inputs: (0, e.BTCArray)(e.RawInput),
        outputs: (0, e.BTCArray)(e.RawOutput),
        lockTime: t.U32LE
    });
})(jd);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RawPSBTV2 = e.RawPSBTV0 = e._DebugPSBT = e._RawPSBTV2 = e._RawPSBTV0 = e.PSBTOutputCoder = e.PSBTInputCoder = e.PSBTOutputUnsignedKeys = e.PSBTOutput = e.PSBTInputUnsignedKeys = e.PSBTInputFinalKeys = e.PSBTInput = e.PSBTGlobal = e.TaprootControlBlock = void 0, e.cleanPSBTFields = re, e.mergeKeyMap = G;
    const t = zd, r = jf, n = jd, i = wa, o = r.validate(r.bytes(null), (R)=>(0, i.validatePubkey)(R, i.PubT.ecdsa)), s = r.validate(r.bytes(32), (R)=>(0, i.validatePubkey)(R, i.PubT.schnorr)), a = r.validate(r.bytes(null), (R)=>{
        if (R.length !== 64 && R.length !== 65) throw new Error("Schnorr signature should be 64 or 65 bytes long");
        return R;
    }), u = r.struct({
        fingerprint: r.U32BE,
        path: r.array(null, r.U32LE)
    }), f = r.struct({
        hashes: r.array(n.CompactSizeLen, r.bytes(32)),
        der: u
    }), c = r.bytes(78), l = r.struct({
        pubKey: s,
        leafHash: r.bytes(32)
    }), p = r.struct({
        version: r.U8,
        // With parity :(
        internalKey: r.bytes(32),
        merklePath: r.array(null, r.bytes(32))
    });
    e.TaprootControlBlock = r.validate(p, (R)=>{
        if (R.merklePath.length > 128) throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");
        return R;
    });
    const y = r.array(null, r.struct({
        depth: r.U8,
        version: r.U8,
        script: n.VarBytes
    })), _ = r.bytes(null), A = r.bytes(20), O = r.bytes(32);
    e.PSBTGlobal = {
        unsignedTx: [
            0,
            !1,
            n.RawOldTx,
            [
                0
            ],
            [
                0
            ],
            !1
        ],
        xpub: [
            1,
            c,
            u,
            [],
            [
                0,
                2
            ],
            !1
        ],
        txVersion: [
            2,
            !1,
            r.U32LE,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        fallbackLocktime: [
            3,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        inputCount: [
            4,
            !1,
            n.CompactSizeLen,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        outputCount: [
            5,
            !1,
            n.CompactSizeLen,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        txModifiable: [
            6,
            !1,
            r.U8,
            [],
            [
                2
            ],
            !1
        ],
        // TODO: bitfield
        version: [
            251,
            !1,
            r.U32LE,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            _,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTInput = {
        nonWitnessUtxo: [
            0,
            !1,
            n.RawTx,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessUtxo: [
            1,
            !1,
            n.RawOutput,
            [],
            [
                0,
                2
            ],
            !1
        ],
        partialSig: [
            2,
            o,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        sighashType: [
            3,
            !1,
            r.U32LE,
            [],
            [
                0,
                2
            ],
            !1
        ],
        redeemScript: [
            4,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessScript: [
            5,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        bip32Derivation: [
            6,
            o,
            u,
            [],
            [
                0,
                2
            ],
            !1
        ],
        finalScriptSig: [
            7,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        finalScriptWitness: [
            8,
            !1,
            n.RawWitness,
            [],
            [
                0,
                2
            ],
            !1
        ],
        porCommitment: [
            9,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        ripemd160: [
            10,
            A,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        sha256: [
            11,
            O,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        hash160: [
            12,
            A,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        hash256: [
            13,
            O,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        txid: [
            14,
            !1,
            O,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        index: [
            15,
            !1,
            r.U32LE,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        sequence: [
            16,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !0
        ],
        requiredTimeLocktime: [
            17,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        requiredHeightLocktime: [
            18,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        tapKeySig: [
            19,
            !1,
            a,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapScriptSig: [
            20,
            l,
            a,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapLeafScript: [
            21,
            e.TaprootControlBlock,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapBip32Derivation: [
            22,
            O,
            f,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapInternalKey: [
            23,
            !1,
            s,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapMerkleRoot: [
            24,
            !1,
            O,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            _,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTInputFinalKeys = [
        "txid",
        "sequence",
        "index",
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknown"
    ], e.PSBTInputUnsignedKeys = [
        "partialSig",
        "finalScriptSig",
        "finalScriptWitness",
        "tapKeySig",
        "tapScriptSig"
    ], e.PSBTOutput = {
        redeemScript: [
            0,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessScript: [
            1,
            !1,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ],
        bip32Derivation: [
            2,
            o,
            u,
            [],
            [
                0,
                2
            ],
            !1
        ],
        amount: [
            3,
            !1,
            r.I64LE,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        script: [
            4,
            !1,
            _,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        tapInternalKey: [
            5,
            !1,
            s,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapTree: [
            6,
            !1,
            y,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapBip32Derivation: [
            7,
            s,
            f,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            _,
            _,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTOutputUnsignedKeys = [];
    const N = r.array(r.NULL, r.struct({
        //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)
        key: r.prefix(n.CompactSizeLen, r.struct({
            type: n.CompactSizeLen,
            key: r.bytes(null)
        })),
        //  <value> := <valuelen> <valuedata>
        value: r.bytes(n.CompactSizeLen)
    }));
    function U(R) {
        const [X, $, S, w, g, m] = R;
        return {
            type: X,
            kc: $,
            vc: S,
            reqInc: w,
            allowInc: g,
            silentIgnore: m
        };
    }
    r.struct({
        type: n.CompactSizeLen,
        key: r.bytes(null)
    });
    function D(R) {
        const X = {};
        for(const $ in R){
            const [S, w, g] = R[$];
            X[S] = [
                $,
                w,
                g
            ];
        }
        return r.wrap({
            encodeStream: ($, S)=>{
                let w = [];
                for(const g in R){
                    const m = S[g];
                    if (m === void 0) continue;
                    const [E, T, I] = R[g];
                    if (!T) w.push({
                        key: {
                            type: E,
                            key: r.EMPTY
                        },
                        value: I.encode(m)
                    });
                    else {
                        const P = m.map(([k, L])=>[
                                T.encode(k),
                                I.encode(L)
                            ]);
                        P.sort((k, L)=>(0, i.compareBytes)(k[0], L[0]));
                        for (const [k, L] of P)w.push({
                            key: {
                                key: k,
                                type: E
                            },
                            value: L
                        });
                    }
                }
                if (S.unknown) {
                    S.unknown.sort((g, m)=>(0, i.compareBytes)(g[0].key, m[0].key));
                    for (const [g, m] of S.unknown)w.push({
                        key: g,
                        value: m
                    });
                }
                N.encodeStream($, w);
            },
            decodeStream: ($)=>{
                const S = N.decodeStream($), w = {}, g = {};
                for (const m of S){
                    let E = "unknown", T = m.key.key, I = m.value;
                    if (X[m.key.type]) {
                        const [P, k, L] = X[m.key.type];
                        if (E = P, !k && T.length) throw new Error(`PSBT: Non-empty key for ${E} (key=${t.hex.encode(T)} value=${t.hex.encode(I)}`);
                        if (T = k ? k.decode(T) : void 0, I = L.decode(I), !k) {
                            if (w[E]) throw new Error(`PSBT: Same keys: ${E} (key=${T} value=${I})`);
                            w[E] = I, g[E] = !0;
                            continue;
                        }
                    } else T = {
                        type: m.key.type,
                        key: m.key.key
                    };
                    if (g[E]) throw new Error(`PSBT: Key type with empty key and no key=${E} val=${I}`);
                    w[E] || (w[E] = []), w[E].push([
                        T,
                        I
                    ]);
                }
                return w;
            }
        });
    }
    e.PSBTInputCoder = r.validate(D(e.PSBTInput), (R)=>{
        if (R.finalScriptWitness && !R.finalScriptWitness.length) throw new Error("validateInput: empty finalScriptWitness");
        if (R.partialSig && !R.partialSig.length) throw new Error("Empty partialSig");
        if (R.partialSig) for (const [X] of R.partialSig)(0, i.validatePubkey)(X, i.PubT.ecdsa);
        if (R.bip32Derivation) for (const [X] of R.bip32Derivation)(0, i.validatePubkey)(X, i.PubT.ecdsa);
        if (R.requiredTimeLocktime !== void 0 && R.requiredTimeLocktime < 5e8) throw new Error(`validateInput: wrong timeLocktime=${R.requiredTimeLocktime}`);
        if (R.requiredHeightLocktime !== void 0 && (R.requiredHeightLocktime <= 0 || R.requiredHeightLocktime >= 5e8)) throw new Error(`validateInput: wrong heighLocktime=${R.requiredHeightLocktime}`);
        if (R.tapLeafScript) for (const [X, $] of R.tapLeafScript){
            if ((X.version & 254) !== $[$.length - 1]) throw new Error("validateInput: tapLeafScript version mimatch");
            if ($[$.length - 1] & 1) throw new Error("validateInput: tapLeafScript version has parity bit!");
        }
        return R;
    }), e.PSBTOutputCoder = r.validate(D(e.PSBTOutput), (R)=>{
        if (R.bip32Derivation) for (const [X] of R.bip32Derivation)(0, i.validatePubkey)(X, i.PubT.ecdsa);
        return R;
    });
    const H = r.validate(D(e.PSBTGlobal), (R)=>{
        if ((R.version || 0) === 0) {
            if (!R.unsignedTx) throw new Error("PSBTv0: missing unsignedTx");
            for (const $ of R.unsignedTx.inputs)if ($.finalScriptSig && $.finalScriptSig.length) throw new Error("PSBTv0: input scriptSig found in unsignedTx");
        }
        return R;
    });
    e._RawPSBTV0 = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        global: H,
        inputs: r.array("global/unsignedTx/inputs/length", e.PSBTInputCoder),
        outputs: r.array(null, e.PSBTOutputCoder)
    }), e._RawPSBTV2 = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        global: H,
        inputs: r.array("global/inputCount", e.PSBTInputCoder),
        outputs: r.array("global/outputCount", e.PSBTOutputCoder)
    }), e._DebugPSBT = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        items: r.array(null, r.apply(r.array(r.NULL, r.tuple([
            r.hex(n.CompactSizeLen),
            r.bytes(n.CompactSize)
        ])), r.coders.dict()))
    });
    function K(R, X, $) {
        for(const S in $){
            if (S === "unknown" || !X[S]) continue;
            const { allowInc: w } = U(X[S]);
            if (!w.includes(R)) throw new Error(`PSBTv${R}: field ${S} is not allowed`);
        }
        for(const S in X){
            const { reqInc: w } = U(X[S]);
            if (w.includes(R) && $[S] === void 0) throw new Error(`PSBTv${R}: missing required field ${S}`);
        }
    }
    function re(R, X, $) {
        const S = {};
        for(const w in $){
            const g = w;
            if (g !== "unknown") {
                if (!X[g]) continue;
                const { allowInc: m, silentIgnore: E } = U(X[g]);
                if (!m.includes(R)) {
                    if (E) continue;
                    throw new Error(`Failed to serialize in PSBTv${R}: ${g} but versions allows inclusion=${m}`);
                }
            }
            S[g] = $[g];
        }
        return S;
    }
    function Q(R) {
        const X = R && R.global && R.global.version || 0;
        K(X, e.PSBTGlobal, R.global);
        for (const m of R.inputs)K(X, e.PSBTInput, m);
        for (const m of R.outputs)K(X, e.PSBTOutput, m);
        const $ = X ? R.global.inputCount : R.global.unsignedTx.inputs.length;
        if (R.inputs.length < $) throw new Error("Not enough inputs");
        const S = R.inputs.slice($);
        if (S.length > 1 || S.length && Object.keys(S[0]).length) throw new Error(`Unexpected inputs left in tx=${S}`);
        const w = X ? R.global.outputCount : R.global.unsignedTx.outputs.length;
        if (R.outputs.length < w) throw new Error("Not outputs inputs");
        const g = R.outputs.slice(w);
        if (g.length > 1 || g.length && Object.keys(g[0]).length) throw new Error(`Unexpected outputs left in tx=${g}`);
        return R;
    }
    function G(R, X, $, S, w) {
        const g = {
            ...$,
            ...X
        };
        for(const m in R){
            const E = m, [T, I, P] = R[E], k = S && !S.includes(m);
            if (X[m] === void 0 && m in X) {
                if (k) throw new Error(`Cannot remove signed field=${m}`);
                delete g[m];
            } else if (I) {
                const L = $ && $[m] ? $[m] : [];
                let j = X[E];
                if (j) {
                    if (!Array.isArray(j)) throw new Error(`keyMap(${m}): KV pairs should be [k, v][]`);
                    j = j.map((ce)=>{
                        if (ce.length !== 2) throw new Error(`keyMap(${m}): KV pairs should be [k, v][]`);
                        return [
                            typeof ce[0] == "string" ? I.decode(t.hex.decode(ce[0])) : ce[0],
                            typeof ce[1] == "string" ? P.decode(t.hex.decode(ce[1])) : ce[1]
                        ];
                    });
                    const ie = {}, ue = (ce, he, ee)=>{
                        if (ie[ce] === void 0) {
                            ie[ce] = [
                                he,
                                ee
                            ];
                            return;
                        }
                        const ae = t.hex.encode(P.encode(ie[ce][1])), ye = t.hex.encode(P.encode(ee));
                        if (ae !== ye) throw new Error(`keyMap(${E}): same key=${ce} oldVal=${ae} newVal=${ye}`);
                    };
                    for (const [ce, he] of L){
                        const ee = t.hex.encode(I.encode(ce));
                        ue(ee, ce, he);
                    }
                    for (const [ce, he] of j){
                        const ee = t.hex.encode(I.encode(ce));
                        if (he === void 0) {
                            if (k) throw new Error(`Cannot remove signed field=${E}/${ce}`);
                            delete ie[ee];
                        } else ue(ee, ce, he);
                    }
                    g[E] = Object.values(ie);
                }
            } else if (typeof g[m] == "string") g[m] = P.decode(t.hex.decode(g[m]));
            else if (k && m in X && $ && $[m] !== void 0 && !(0, i.equalBytes)(P.encode(X[m]), P.encode($[m]))) throw new Error(`Cannot change signed field=${m}`);
        }
        for(const m in g)if (!R[m]) {
            if (w && m === "unknown") continue;
            delete g[m];
        }
        return g;
    }
    e.RawPSBTV0 = r.validate(e._RawPSBTV0, Q), e.RawPSBTV2 = r.validate(e._RawPSBTV2, Q);
})(v0);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._sortPubkeys = e.p2tr_pk = e.p2tr_ns = e.tapLeafHash = e.TAP_LEAF_VERSION = e.p2ms = e.p2wpkh = e.p2wsh = e.p2sh = e.p2pkh = e.p2pk = e.OutScript = void 0, e.checkScript = re, e.taprootListToTree = m, e.p2tr = k, e.combinations = L, e.p2tr_ms = ue, e.getAddress = ce, e.multisig = ee, e.sortedMultisig = ae, e.WIF = Ce, e.Address = M;
    const t = zd, r = jf, n = v0, i = jd, o = wa, s = wa, a = {
        encode (z) {
            if (!(z.length !== 2 || z[0] !== 1 || !o.isBytes(z[1]) || t.hex.encode(z[1]) !== "4e73")) return {
                type: "p2a",
                script: i.Script.encode(z)
            };
        },
        decode: (z)=>{
            if (z.type === "p2a") return [
                1,
                t.hex.decode("4e73")
            ];
        }
    };
    function u(z, de) {
        try {
            return o.validatePubkey(z, de), !0;
        } catch  {
            return !1;
        }
    }
    const D = [
        a,
        {
            encode (z) {
                if (!(z.length !== 2 || !o.isBytes(z[0]) || !u(z[0], o.PubT.ecdsa) || z[1] !== "CHECKSIG")) return {
                    type: "pk",
                    pubkey: z[0]
                };
            },
            decode: (z)=>z.type === "pk" ? [
                    z.pubkey,
                    "CHECKSIG"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 5 || z[0] !== "DUP" || z[1] !== "HASH160" || !o.isBytes(z[2])) && !(z[3] !== "EQUALVERIFY" || z[4] !== "CHECKSIG")) return {
                    type: "pkh",
                    hash: z[2]
                };
            },
            decode: (z)=>z.type === "pkh" ? [
                    "DUP",
                    "HASH160",
                    z.hash,
                    "EQUALVERIFY",
                    "CHECKSIG"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 3 || z[0] !== "HASH160" || !o.isBytes(z[1]) || z[2] !== "EQUAL")) return {
                    type: "sh",
                    hash: z[1]
                };
            },
            decode: (z)=>z.type === "sh" ? [
                    "HASH160",
                    z.hash,
                    "EQUAL"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 2 || z[0] !== 0 || !o.isBytes(z[1])) && z[1].length === 32) return {
                    type: "wsh",
                    hash: z[1]
                };
            },
            decode: (z)=>z.type === "wsh" ? [
                    0,
                    z.hash
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 2 || z[0] !== 0 || !o.isBytes(z[1])) && z[1].length === 20) return {
                    type: "wpkh",
                    hash: z[1]
                };
            },
            decode: (z)=>z.type === "wpkh" ? [
                    0,
                    z.hash
                ] : void 0
        },
        {
            encode (z) {
                const de = z.length - 1;
                if (z[de] !== "CHECKMULTISIG") return;
                const _e = z[0], Ie = z[de - 1];
                if (typeof _e != "number" || typeof Ie != "number") return;
                const je = z.slice(1, -2);
                if (Ie === je.length) {
                    for (const Ke of je)if (!o.isBytes(Ke)) return;
                    return {
                        type: "ms",
                        m: _e,
                        pubkeys: je
                    };
                }
            },
            // checkmultisig(n, ..pubkeys, m)
            decode: (z)=>z.type === "ms" ? [
                    z.m,
                    ...z.pubkeys,
                    z.pubkeys.length,
                    "CHECKMULTISIG"
                ] : void 0
        },
        {
            encode (z) {
                if (!(z.length !== 2 || z[0] !== 1 || !o.isBytes(z[1]))) return {
                    type: "tr",
                    pubkey: z[1]
                };
            },
            decode: (z)=>z.type === "tr" ? [
                    1,
                    z.pubkey
                ] : void 0
        },
        {
            encode (z) {
                const de = z.length - 1;
                if (z[de] !== "CHECKSIG") return;
                const _e = [];
                for(let Ie = 0; Ie < de; Ie++){
                    const je = z[Ie];
                    if (Ie & 1) {
                        if (je !== "CHECKSIGVERIFY" || Ie === de - 1) return;
                        continue;
                    }
                    if (!o.isBytes(je)) return;
                    _e.push(je);
                }
                return {
                    type: "tr_ns",
                    pubkeys: _e
                };
            },
            decode: (z)=>{
                if (z.type !== "tr_ns") return;
                const de = [];
                for(let _e = 0; _e < z.pubkeys.length - 1; _e++)de.push(z.pubkeys[_e], "CHECKSIGVERIFY");
                return de.push(z.pubkeys[z.pubkeys.length - 1], "CHECKSIG"), de;
            }
        },
        {
            encode (z) {
                const de = z.length - 1;
                if (z[de] !== "NUMEQUAL" || z[1] !== "CHECKSIG") return;
                const _e = [], Ie = (0, i.OpToNum)(z[de - 1]);
                if (typeof Ie == "number") {
                    for(let je = 0; je < de - 1; je++){
                        const Ke = z[je];
                        if (je & 1) {
                            if (Ke !== (je === 1 ? "CHECKSIG" : "CHECKSIGADD")) throw new Error("OutScript.encode/tr_ms: wrong element");
                            continue;
                        }
                        if (!o.isBytes(Ke)) throw new Error("OutScript.encode/tr_ms: wrong key element");
                        _e.push(Ke);
                    }
                    return {
                        type: "tr_ms",
                        pubkeys: _e,
                        m: Ie
                    };
                }
            },
            decode: (z)=>{
                if (z.type !== "tr_ms") return;
                const de = [
                    z.pubkeys[0],
                    "CHECKSIG"
                ];
                for(let _e = 1; _e < z.pubkeys.length; _e++)de.push(z.pubkeys[_e], "CHECKSIGADD");
                return de.push(z.m, "NUMEQUAL"), de;
            }
        },
        {
            encode (z) {
                return {
                    type: "unknown",
                    script: i.Script.encode(z)
                };
            },
            decode: (z)=>z.type === "unknown" ? i.Script.decode(z.script) : void 0
        }
    ], H = r.apply(i.Script, r.coders.match(D));
    e.OutScript = r.validate(H, (z)=>{
        if (z.type === "pk" && !u(z.pubkey, o.PubT.ecdsa)) throw new Error("OutScript/pk: wrong key");
        if ((z.type === "pkh" || z.type === "sh" || z.type === "wpkh") && (!o.isBytes(z.hash) || z.hash.length !== 20)) throw new Error(`OutScript/${z.type}: wrong hash`);
        if (z.type === "wsh" && (!o.isBytes(z.hash) || z.hash.length !== 32)) throw new Error("OutScript/wsh: wrong hash");
        if (z.type === "tr" && (!o.isBytes(z.pubkey) || !u(z.pubkey, o.PubT.schnorr))) throw new Error("OutScript/tr: wrong taproot public key");
        if ((z.type === "ms" || z.type === "tr_ns" || z.type === "tr_ms") && !Array.isArray(z.pubkeys)) throw new Error("OutScript/multisig: wrong pubkeys array");
        if (z.type === "ms") {
            const de = z.pubkeys.length;
            for (const _e of z.pubkeys)if (!u(_e, o.PubT.ecdsa)) throw new Error("OutScript/multisig: wrong pubkey");
            if (z.m <= 0 || de > 16 || z.m > de) throw new Error("OutScript/multisig: invalid params");
        }
        if (z.type === "tr_ns" || z.type === "tr_ms") {
            for (const de of z.pubkeys)if (!u(de, o.PubT.schnorr)) throw new Error(`OutScript/${z.type}: wrong pubkey`);
        }
        if (z.type === "tr_ms") {
            const de = z.pubkeys.length;
            if (z.m <= 0 || de > 999 || z.m > de) throw new Error("OutScript/tr_ms: invalid params");
        }
        return z;
    });
    function K(z, de) {
        if (!o.equalBytes(z.hash, o.sha256(de))) throw new Error("checkScript: wsh wrong witnessScript hash");
        const _e = e.OutScript.decode(de);
        if (_e.type === "tr" || _e.type === "tr_ns" || _e.type === "tr_ms") throw new Error(`checkScript: P2${_e.type} cannot be wrapped in P2SH`);
        if (_e.type === "wpkh" || _e.type === "sh") throw new Error(`checkScript: P2${_e.type} cannot be wrapped in P2WSH`);
    }
    function re(z, de, _e) {
        if (z) {
            const Ie = e.OutScript.decode(z);
            if (Ie.type === "tr_ns" || Ie.type === "tr_ms" || Ie.type === "ms" || Ie.type == "pk") throw new Error(`checkScript: non-wrapped ${Ie.type}`);
            if (Ie.type === "sh" && de) {
                if (!o.equalBytes(Ie.hash, o.hash160(de))) throw new Error("checkScript: sh wrong redeemScript hash");
                const je = e.OutScript.decode(de);
                if (je.type === "tr" || je.type === "tr_ns" || je.type === "tr_ms") throw new Error(`checkScript: P2${je.type} cannot be wrapped in P2SH`);
                if (je.type === "sh") throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
            }
            Ie.type === "wsh" && _e && K(Ie, _e);
        }
        if (de) {
            const Ie = e.OutScript.decode(de);
            Ie.type === "wsh" && _e && K(Ie, _e);
        }
    }
    function Q(z) {
        const de = {};
        for (const _e of z){
            const Ie = t.hex.encode(_e);
            if (de[Ie]) throw new Error(`Multisig: non-uniq pubkey: ${z.map(t.hex.encode)}`);
            de[Ie] = !0;
        }
    }
    const G = (z, de = s.NETWORK)=>{
        if (!u(z, o.PubT.ecdsa)) throw new Error("P2PK: invalid publicKey");
        return {
            type: "pk",
            script: e.OutScript.encode({
                type: "pk",
                pubkey: z
            })
        };
    };
    e.p2pk = G;
    const R = (z, de = s.NETWORK)=>{
        if (!u(z, o.PubT.ecdsa)) throw new Error("P2PKH: invalid publicKey");
        const _e = o.hash160(z);
        return {
            type: "pkh",
            script: e.OutScript.encode({
                type: "pkh",
                hash: _e
            }),
            address: M(de).encode({
                type: "pkh",
                hash: _e
            }),
            hash: _e
        };
    };
    e.p2pkh = R;
    const X = (z, de = s.NETWORK)=>{
        const _e = z.script;
        if (!o.isBytes(_e)) throw new Error(`Wrong script: ${typeof z.script}, expected Uint8Array`);
        const Ie = o.hash160(_e), je = e.OutScript.encode({
            type: "sh",
            hash: Ie
        });
        return re(je, _e, z.witnessScript), z.witnessScript ? {
            type: "sh",
            redeemScript: _e,
            script: e.OutScript.encode({
                type: "sh",
                hash: Ie
            }),
            address: M(de).encode({
                type: "sh",
                hash: Ie
            }),
            hash: Ie,
            witnessScript: z.witnessScript
        } : {
            type: "sh",
            redeemScript: _e,
            script: e.OutScript.encode({
                type: "sh",
                hash: Ie
            }),
            address: M(de).encode({
                type: "sh",
                hash: Ie
            }),
            hash: Ie
        };
    };
    e.p2sh = X;
    const $ = (z, de = s.NETWORK)=>{
        const _e = z.script;
        if (!o.isBytes(_e)) throw new Error(`Wrong script: ${typeof _e}, expected Uint8Array`);
        const Ie = o.sha256(_e), je = e.OutScript.encode({
            type: "wsh",
            hash: Ie
        });
        return re(je, void 0, _e), {
            type: "wsh",
            witnessScript: _e,
            script: e.OutScript.encode({
                type: "wsh",
                hash: Ie
            }),
            address: M(de).encode({
                type: "wsh",
                hash: Ie
            }),
            hash: Ie
        };
    };
    e.p2wsh = $;
    const S = (z, de = s.NETWORK)=>{
        if (!u(z, o.PubT.ecdsa)) throw new Error("P2WPKH: invalid publicKey");
        if (z.length === 65) throw new Error("P2WPKH: uncompressed public key");
        const _e = o.hash160(z);
        return {
            type: "wpkh",
            script: e.OutScript.encode({
                type: "wpkh",
                hash: _e
            }),
            address: M(de).encode({
                type: "wpkh",
                hash: _e
            }),
            hash: _e
        };
    };
    e.p2wpkh = S;
    const w = (z, de, _e = !1)=>(_e || Q(de), {
            type: "ms",
            script: e.OutScript.encode({
                type: "ms",
                pubkeys: de,
                m: z
            })
        });
    e.p2ms = w;
    function g(z, de, _e = !1, Ie) {
        const je = e.OutScript.decode(z);
        if (je.type === "unknown") {
            if (Ie) {
                const h = r.apply(i.Script, r.coders.match(Ie)).decode(z);
                if (h !== void 0) {
                    if (typeof h.type != "string" || !h.type.startsWith("tr_")) throw new Error(`P2TR: invalid custom type=${h.type}`);
                    return;
                }
            }
            if (_e) return;
        }
        if (![
            "tr_ns",
            "tr_ms"
        ].includes(je.type)) throw new Error(`P2TR: invalid leaf script=${je.type}`);
        const Ke = je;
        if (!_e && Ke.pubkeys) for (const Ue of Ke.pubkeys){
            if (o.equalBytes(Ue, o.TAPROOT_UNSPENDABLE_KEY)) throw new Error("Unspendable taproot key in leaf script");
            if (o.equalBytes(Ue, de)) throw new Error("Using P2TR with leaf script with same key as internal key is not supported");
        }
    }
    function m(z) {
        const de = Array.from(z);
        for(; de.length >= 2;){
            de.sort((Ue, h)=>(h.weight || 1) - (Ue.weight || 1));
            const Ie = de.pop(), je = de.pop(), Ke = ((je == null ? void 0 : je.weight) || 1) + ((Ie == null ? void 0 : Ie.weight) || 1);
            de.push({
                weight: Ke,
                // Unwrap children array
                // TODO: Very hard to remove any here
                childs: [
                    (je == null ? void 0 : je.childs) || je,
                    (Ie == null ? void 0 : Ie.childs) || Ie
                ]
            });
        }
        const _e = de[0];
        return (_e == null ? void 0 : _e.childs) || _e;
    }
    function E(z, de = []) {
        if (!z) throw new Error("taprootAddPath: empty tree");
        if (z.type === "leaf") return {
            ...z,
            path: de
        };
        if (z.type !== "branch") throw new Error(`taprootAddPath: wrong type=${z}`);
        return {
            ...z,
            path: de,
            // Left element has right hash in path and otherwise
            left: E(z.left, [
                z.right.hash,
                ...de
            ]),
            right: E(z.right, [
                z.left.hash,
                ...de
            ])
        };
    }
    function T(z) {
        if (!z) throw new Error("taprootAddPath: empty tree");
        if (z.type === "leaf") return [
            z
        ];
        if (z.type !== "branch") throw new Error(`taprootWalkTree: wrong type=${z}`);
        return [
            ...T(z.left),
            ...T(z.right)
        ];
    }
    function I(z, de, _e = !1, Ie) {
        if (!z) throw new Error("taprootHashTree: empty tree");
        if (Array.isArray(z) && z.length === 1 && (z = z[0]), !Array.isArray(z)) {
            const { leafVersion: x, script: q } = z;
            if (z.tapLeafScript || z.tapMerkleRoot && !o.equalBytes(z.tapMerkleRoot, r.EMPTY)) throw new Error("P2TR: tapRoot leafScript cannot have tree");
            const te = typeof q == "string" ? t.hex.decode(q) : q;
            if (!o.isBytes(te)) throw new Error(`checkScript: wrong script type=${te}`);
            return g(te, de, _e, Ie), {
                type: "leaf",
                version: x,
                script: te,
                hash: (0, e.tapLeafHash)(te, x)
            };
        }
        if (z.length !== 2 && (z = m(z)), z.length !== 2) throw new Error("hashTree: non binary tree!");
        const je = I(z[0], de, _e, Ie), Ke = I(z[1], de, _e, Ie);
        let [Ue, h] = [
            je.hash,
            Ke.hash
        ];
        return o.compareBytes(h, Ue) === -1 && ([Ue, h] = [
            h,
            Ue
        ]), {
            type: "branch",
            left: je,
            right: Ke,
            hash: o.tagSchnorr("TapBranch", Ue, h)
        };
    }
    e.TAP_LEAF_VERSION = 192;
    const P = (z, de = e.TAP_LEAF_VERSION)=>o.tagSchnorr("TapLeaf", new Uint8Array([
            de
        ]), i.VarBytes.encode(z));
    e.tapLeafHash = P;
    function k(z, de, _e = s.NETWORK, Ie = !1, je) {
        if (!z && !de) throw new Error("p2tr: should have pubKey or scriptTree (or both)");
        const Ke = typeof z == "string" ? t.hex.decode(z) : z || o.TAPROOT_UNSPENDABLE_KEY;
        if (!u(Ke, o.PubT.schnorr)) throw new Error("p2tr: non-schnorr pubkey");
        if (de) {
            let Ue = E(I(de, Ke, Ie, je));
            const h = Ue.hash, [x, q] = o.taprootTweakPubkey(Ke, h), te = T(Ue).map((fe)=>({
                    ...fe,
                    controlBlock: n.TaprootControlBlock.encode({
                        version: (fe.version || e.TAP_LEAF_VERSION) + q,
                        internalKey: Ke,
                        merklePath: fe.path
                    })
                }));
            return {
                type: "tr",
                script: e.OutScript.encode({
                    type: "tr",
                    pubkey: x
                }),
                address: M(_e).encode({
                    type: "tr",
                    pubkey: x
                }),
                // For tests
                tweakedPubkey: x,
                // PSBT stuff
                tapInternalKey: Ke,
                leaves: te,
                tapLeafScript: te.map((fe)=>[
                        n.TaprootControlBlock.decode(fe.controlBlock),
                        o.concatBytes(fe.script, new Uint8Array([
                            fe.version || e.TAP_LEAF_VERSION
                        ]))
                    ]),
                tapMerkleRoot: h
            };
        } else {
            const Ue = o.taprootTweakPubkey(Ke, r.EMPTY)[0];
            return {
                type: "tr",
                script: e.OutScript.encode({
                    type: "tr",
                    pubkey: Ue
                }),
                address: M(_e).encode({
                    type: "tr",
                    pubkey: Ue
                }),
                // For tests
                tweakedPubkey: Ue,
                // PSBT stuff
                tapInternalKey: Ke
            };
        }
    }
    function L(z, de) {
        const _e = [];
        if (!Array.isArray(de)) throw new Error("combinations: lst arg should be array");
        const Ie = de.length;
        if (z > Ie) throw new Error("combinations: m > lst.length, no combinations possible");
        const je = Array.from({
            length: z
        }, (Ue, h)=>h), Ke = je.length - 1;
        e: for(;;){
            _e.push(je.map((h)=>de[h])), je[Ke] += 1;
            let Ue = Ke;
            for(; Ue >= 0 && je[Ue] > Ie - z + Ue; Ue--){
                if (je[Ue] = 0, Ue === 0) break e;
                je[Ue - 1] += 1;
            }
            for(Ue += 1; Ue < je.length; Ue++)je[Ue] = je[Ue - 1] + 1;
        }
        return _e;
    }
    const j = (z, de, _e = !1)=>(_e || Q(de), L(z, de).map((Ie)=>({
                type: "tr_ns",
                script: e.OutScript.encode({
                    type: "tr_ns",
                    pubkeys: Ie
                })
            })));
    e.p2tr_ns = j;
    const ie = (z)=>(0, e.p2tr_ns)(1, [
            z
        ], void 0)[0];
    e.p2tr_pk = ie;
    function ue(z, de, _e = !1) {
        return _e || Q(de), {
            type: "tr_ms",
            script: e.OutScript.encode({
                type: "tr_ms",
                pubkeys: de,
                m: z
            })
        };
    }
    function ce(z, de, _e = s.NETWORK) {
        if (z === "tr") return k(o.pubSchnorr(de), void 0, _e).address;
        const Ie = o.pubECDSA(de);
        if (z === "pkh") return (0, e.p2pkh)(Ie, _e).address;
        if (z === "wpkh") return (0, e.p2wpkh)(Ie, _e).address;
        throw new Error(`getAddress: unknown type=${z}`);
    }
    const he = (z)=>Array.from(z).sort(o.compareBytes);
    e._sortPubkeys = he;
    function ee(z, de, _e = !1, Ie = !1, je = s.NETWORK) {
        const Ke = (0, e.p2ms)(z, _e ? (0, e._sortPubkeys)(de) : de);
        return Ie ? (0, e.p2wsh)(Ke, je) : (0, e.p2sh)(Ke, je);
    }
    function ae(z, de, _e = !1, Ie = s.NETWORK) {
        return ee(z, de, !0, _e, Ie);
    }
    const ye = (0, t.createBase58check)(o.sha256);
    function Se(z, de) {
        if (de.length < 2 || de.length > 40) throw new Error("Witness: invalid length");
        if (z > 16) throw new Error("Witness: invalid version");
        if (z === 0 && !(de.length === 20 || de.length === 32)) throw new Error("Witness: invalid length for version");
    }
    function De(z, de, _e = s.NETWORK) {
        Se(z, de);
        const Ie = z === 0 ? t.bech32 : t.bech32m;
        return Ie.encode(_e.bech32, [
            z
        ].concat(Ie.toWords(de)));
    }
    function Re(z, de) {
        return ye.encode(o.concatBytes(Uint8Array.from(de), z));
    }
    function Ce(z = s.NETWORK) {
        return {
            encode (de) {
                const _e = o.concatBytes(de, new Uint8Array([
                    1
                ]));
                return Re(_e.subarray(0, 33), [
                    z.wif
                ]);
            },
            decode (de) {
                let _e = ye.decode(de);
                if (_e[0] !== z.wif) throw new Error("Wrong WIF prefix");
                if (_e = _e.subarray(1), _e.length !== 33) throw new Error("Wrong WIF length");
                if (_e[32] !== 1) throw new Error("Wrong WIF postfix");
                return _e.subarray(0, -1);
            }
        };
    }
    function M(z = s.NETWORK) {
        return {
            encode (de) {
                const { type: _e } = de;
                if (_e === "wpkh") return De(0, de.hash, z);
                if (_e === "wsh") return De(0, de.hash, z);
                if (_e === "tr") return De(1, de.pubkey, z);
                if (_e === "pkh") return Re(de.hash, [
                    z.pubKeyHash
                ]);
                if (_e === "sh") return Re(de.hash, [
                    z.scriptHash
                ]);
                throw new Error(`Unknown address type=${_e}`);
            },
            decode (de) {
                if (de.length < 14 || de.length > 74) throw new Error("Invalid address length");
                if (z.bech32 && de.toLowerCase().startsWith(`${z.bech32}1`)) {
                    let Ie;
                    try {
                        if (Ie = t.bech32.decode(de), Ie.words[0] !== 0) throw new Error(`bech32: wrong version=${Ie.words[0]}`);
                    } catch  {
                        if (Ie = t.bech32m.decode(de), Ie.words[0] === 0) throw new Error(`bech32m: wrong version=${Ie.words[0]}`);
                    }
                    if (Ie.prefix !== z.bech32) throw new Error(`wrong bech32 prefix=${Ie.prefix}`);
                    const [je, ...Ke] = Ie.words, Ue = t.bech32.fromWords(Ke);
                    if (Se(je, Ue), je === 0 && Ue.length === 32) return {
                        type: "wsh",
                        hash: Ue
                    };
                    if (je === 0 && Ue.length === 20) return {
                        type: "wpkh",
                        hash: Ue
                    };
                    if (je === 1 && Ue.length === 32) return {
                        type: "tr",
                        pubkey: Ue
                    };
                    throw new Error("Unknown witness program");
                }
                const _e = ye.decode(de);
                if (_e.length !== 21) throw new Error("Invalid base58 address");
                if (_e[0] === z.pubKeyHash) return {
                    type: "pkh",
                    hash: _e.slice(1)
                };
                if (_e[0] === z.scriptHash) return {
                    type: "sh",
                    hash: _e.slice(1)
                };
                throw new Error(`Invalid address prefix=${_e[0]}`);
            }
        };
    }
})(yp);
var Em = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Transaction = e.SigHash = e.SignatureHash = e.def = e.Decimal = e.DEFAULT_SEQUENCE = e.DEFAULT_LOCKTIME = e.DEFAULT_VERSION = e.PRECISION = e.toVsize = void 0, e.cloneDeep = p, e.inputBeforeSign = N, e.getPrevOut = G, e.normalizeInput = R, e.getInputType = X, e.PSBTCombine = S, e.bip32Path = g;
    const t = zd, r = jf, n = yp, i = v0, o = jd, s = wa, a = wa, u = new Uint8Array(32), f = {
        amount: 0xffffffffffffffffn,
        script: r.EMPTY
    }, c = (m)=>Math.ceil(m / 4);
    e.toVsize = c, e.PRECISION = 8, e.DEFAULT_VERSION = 2, e.DEFAULT_LOCKTIME = 0, e.DEFAULT_SEQUENCE = 4294967295, e.Decimal = r.coders.decimal(e.PRECISION);
    const l = (m, E)=>m === void 0 ? E : m;
    e.def = l;
    function p(m) {
        if (Array.isArray(m)) return m.map((E)=>p(E));
        if ((0, a.isBytes)(m)) return Uint8Array.from(m);
        if ([
            "number",
            "bigint",
            "boolean",
            "string",
            "undefined"
        ].includes(typeof m)) return m;
        if (m === null) return m;
        if (typeof m == "object") return Object.fromEntries(Object.entries(m).map(([E, T])=>[
                E,
                p(T)
            ]));
        throw new Error(`cloneDeep: unknown type=${m} (${typeof m})`);
    }
    var y;
    (function(m) {
        m[m.DEFAULT = 0] = "DEFAULT", m[m.ALL = 1] = "ALL", m[m.NONE = 2] = "NONE", m[m.SINGLE = 3] = "SINGLE", m[m.ANYONECANPAY = 128] = "ANYONECANPAY";
    })(y || (e.SignatureHash = y = {}));
    var _;
    (function(m) {
        m[m.DEFAULT = 0] = "DEFAULT", m[m.ALL = 1] = "ALL", m[m.NONE = 2] = "NONE", m[m.SINGLE = 3] = "SINGLE", m[m.DEFAULT_ANYONECANPAY = 128] = "DEFAULT_ANYONECANPAY", m[m.ALL_ANYONECANPAY = 129] = "ALL_ANYONECANPAY", m[m.NONE_ANYONECANPAY = 130] = "NONE_ANYONECANPAY", m[m.SINGLE_ANYONECANPAY = 131] = "SINGLE_ANYONECANPAY";
    })(_ || (e.SigHash = _ = {}));
    function A(m, E, T, I = r.EMPTY) {
        return (0, a.equalBytes)(T, E) && (m = s.taprootTweakPrivKey(m, I), E = s.pubSchnorr(m)), {
            privKey: m,
            pubKey: E
        };
    }
    function O(m) {
        if (m.script === void 0 || m.amount === void 0) throw new Error("Transaction/output: script and amount required");
        return {
            script: m.script,
            amount: m.amount
        };
    }
    function N(m) {
        if (m.txid === void 0 || m.index === void 0) throw new Error("Transaction/input: txid and index required");
        return {
            txid: m.txid,
            index: m.index,
            sequence: (0, e.def)(m.sequence, e.DEFAULT_SEQUENCE),
            finalScriptSig: (0, e.def)(m.finalScriptSig, r.EMPTY)
        };
    }
    function U(m) {
        for(const E in m){
            const T = E;
            i.PSBTInputFinalKeys.includes(T) || delete m[T];
        }
    }
    const D = r.struct({
        txid: r.bytes(32, !0),
        index: r.U32LE
    });
    function H(m) {
        if (typeof m != "number" || typeof _[m] != "string") throw new Error(`Invalid SigHash=${m}`);
        return m;
    }
    function K(m) {
        const E = m & 31;
        return {
            isAny: !!(m & y.ANYONECANPAY),
            isNone: E === y.NONE,
            isSingle: E === y.SINGLE
        };
    }
    function re(m) {
        if (m !== void 0 && ({}).toString.call(m) !== "[object Object]") throw new Error(`Wrong object type for transaction options: ${m}`);
        const E = {
            ...m,
            // Defaults
            version: (0, e.def)(m.version, e.DEFAULT_VERSION),
            lockTime: (0, e.def)(m.lockTime, 0),
            PSBTVersion: (0, e.def)(m.PSBTVersion, 0)
        };
        if (typeof E.allowUnknowInput < "u" && (m.allowUnknownInputs = E.allowUnknowInput), typeof E.allowUnknowOutput < "u" && (m.allowUnknownOutputs = E.allowUnknowOutput), typeof E.lockTime != "number") throw new Error("Transaction lock time should be number");
        if (r.U32LE.encode(E.lockTime), E.PSBTVersion !== 0 && E.PSBTVersion !== 2) throw new Error(`Unknown PSBT version ${E.PSBTVersion}`);
        for (const T of [
            "allowUnknownVersion",
            "allowUnknownOutputs",
            "allowUnknownInputs",
            "disableScriptCheck",
            "bip174jsCompat",
            "allowLegacyWitnessUtxo",
            "lowR"
        ]){
            const I = E[T];
            if (I !== void 0 && typeof I != "boolean") throw new Error(`Transation options wrong type: ${T}=${I} (${typeof I})`);
        }
        if (E.allowUnknownVersion ? typeof E.version == "number" : ![
            -1,
            0,
            1,
            2,
            3
        ].includes(E.version)) throw new Error(`Unknown version: ${E.version}`);
        if (E.customScripts !== void 0) {
            const T = E.customScripts;
            if (!Array.isArray(T)) throw new Error(`wrong custom scripts type (expected array): customScripts=${T} (${typeof T})`);
            for (const I of T){
                if (typeof I.encode != "function" || typeof I.decode != "function") throw new Error(`wrong script=${I} (${typeof I})`);
                if (I.finalizeTaproot !== void 0 && typeof I.finalizeTaproot != "function") throw new Error(`wrong script=${I} (${typeof I})`);
            }
        }
        return Object.freeze(E);
    }
    function Q(m) {
        if (m.nonWitnessUtxo && m.index !== void 0) {
            const E = m.nonWitnessUtxo.outputs.length - 1;
            if (m.index > E) throw new Error(`validateInput: index(${m.index}) not in nonWitnessUtxo`);
            const T = m.nonWitnessUtxo.outputs[m.index];
            if (m.witnessUtxo && (!(0, a.equalBytes)(m.witnessUtxo.script, T.script) || m.witnessUtxo.amount !== T.amount)) throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo");
            if (m.txid) {
                if (m.nonWitnessUtxo.outputs.length - 1 < m.index) throw new Error("nonWitnessUtxo: incorect output index");
                const P = $.fromRaw(o.RawTx.encode(m.nonWitnessUtxo), {
                    allowUnknownOutputs: !0,
                    disableScriptCheck: !0,
                    allowUnknownInputs: !0
                }), k = t.hex.encode(m.txid);
                if (P.isFinal && P.id !== k) throw new Error(`nonWitnessUtxo: wrong txid, exp=${k} got=${P.id}`);
            }
        }
        return m;
    }
    function G(m) {
        if (m.nonWitnessUtxo) {
            if (m.index === void 0) throw new Error("Unknown input index");
            return m.nonWitnessUtxo.outputs[m.index];
        } else {
            if (m.witnessUtxo) return m.witnessUtxo;
            throw new Error("Cannot find previous output info");
        }
    }
    function R(m, E, T, I = !1, P = !1) {
        let { nonWitnessUtxo: k, txid: L } = m;
        typeof k == "string" && (k = t.hex.decode(k)), (0, a.isBytes)(k) && (k = o.RawTx.decode(k)), !("nonWitnessUtxo" in m) && k === void 0 && (k = E == null ? void 0 : E.nonWitnessUtxo), typeof L == "string" && (L = t.hex.decode(L)), L === void 0 && (L = E == null ? void 0 : E.txid);
        let j = {
            ...E,
            ...m,
            nonWitnessUtxo: k,
            txid: L
        };
        !("nonWitnessUtxo" in m) && j.nonWitnessUtxo === void 0 && delete j.nonWitnessUtxo, j.sequence === void 0 && (j.sequence = e.DEFAULT_SEQUENCE), j.tapMerkleRoot === null && delete j.tapMerkleRoot, j = i.mergeKeyMap(i.PSBTInput, j, E, T, P), i.PSBTInputCoder.encode(j);
        let ie;
        return j.nonWitnessUtxo && j.index !== void 0 ? ie = j.nonWitnessUtxo.outputs[j.index] : j.witnessUtxo && (ie = j.witnessUtxo), ie && !I && (0, n.checkScript)(ie && ie.script, j.redeemScript, j.witnessScript), j;
    }
    function X(m, E = !1) {
        let T = "legacy", I = y.ALL;
        const P = G(m), k = n.OutScript.decode(P.script);
        let L = k.type, j = k;
        const ie = [
            k
        ];
        if (k.type === "tr") return I = y.DEFAULT, {
            txType: "taproot",
            type: "tr",
            last: k,
            lastScript: P.script,
            defaultSighash: I,
            sighash: m.sighashType || I
        };
        {
            if ((k.type === "wpkh" || k.type === "wsh") && (T = "segwit"), k.type === "sh") {
                if (!m.redeemScript) throw new Error("inputType: sh without redeemScript");
                let ee = n.OutScript.decode(m.redeemScript);
                (ee.type === "wpkh" || ee.type === "wsh") && (T = "segwit"), ie.push(ee), j = ee, L += `-${ee.type}`;
            }
            if (j.type === "wsh") {
                if (!m.witnessScript) throw new Error("inputType: wsh without witnessScript");
                let ee = n.OutScript.decode(m.witnessScript);
                ee.type === "wsh" && (T = "segwit"), ie.push(ee), j = ee, L += `-${ee.type}`;
            }
            const ue = ie[ie.length - 1];
            if (ue.type === "sh" || ue.type === "wsh") throw new Error("inputType: sh/wsh cannot be terminal type");
            const ce = n.OutScript.encode(ue), he = {
                type: L,
                txType: T,
                last: ue,
                lastScript: ce,
                defaultSighash: I,
                sighash: m.sighashType || I
            };
            if (T === "legacy" && !E && !m.nonWitnessUtxo) throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");
            return he;
        }
    }
    class $ {
        constructor(E = {}){
            this.global = {}, this.inputs = [], this.outputs = [];
            const T = this.opts = re(E);
            T.lockTime !== e.DEFAULT_LOCKTIME && (this.global.fallbackLocktime = T.lockTime), this.global.txVersion = T.version;
        }
        // Import
        static fromRaw(E, T = {}) {
            const I = o.RawTx.decode(E), P = new $({
                ...T,
                version: I.version,
                lockTime: I.lockTime
            });
            for (const k of I.outputs)P.addOutput(k);
            if (P.outputs = I.outputs, P.inputs = I.inputs, I.witnesses) for(let k = 0; k < I.witnesses.length; k++)P.inputs[k].finalScriptWitness = I.witnesses[k];
            return P;
        }
        // PSBT
        static fromPSBT(E, T = {}) {
            let I;
            try {
                I = i.RawPSBTV0.decode(E);
            } catch (he) {
                try {
                    I = i.RawPSBTV2.decode(E);
                } catch  {
                    throw he;
                }
            }
            const P = I.global.version || 0;
            if (P !== 0 && P !== 2) throw new Error(`Wrong PSBT version=${P}`);
            const k = I.global.unsignedTx, L = P === 0 ? k == null ? void 0 : k.version : I.global.txVersion, j = P === 0 ? k == null ? void 0 : k.lockTime : I.global.fallbackLocktime, ie = new $({
                ...T,
                version: L,
                lockTime: j,
                PSBTVersion: P
            }), ue = P === 0 ? k == null ? void 0 : k.inputs.length : I.global.inputCount;
            ie.inputs = I.inputs.slice(0, ue).map((he, ee)=>{
                var ae;
                return Q({
                    finalScriptSig: r.EMPTY,
                    ...(ae = I.global.unsignedTx) == null ? void 0 : ae.inputs[ee],
                    ...he
                });
            });
            const ce = P === 0 ? k == null ? void 0 : k.outputs.length : I.global.outputCount;
            return ie.outputs = I.outputs.slice(0, ce).map((he, ee)=>{
                var ae;
                return {
                    ...he,
                    ...(ae = I.global.unsignedTx) == null ? void 0 : ae.outputs[ee]
                };
            }), ie.global = {
                ...I.global,
                txVersion: L
            }, j !== e.DEFAULT_LOCKTIME && (ie.global.fallbackLocktime = j), ie;
        }
        toPSBT(E = this.opts.PSBTVersion) {
            if (E !== 0 && E !== 2) throw new Error(`Wrong PSBT version=${E}`);
            const T = this.inputs.map((k)=>Q(i.cleanPSBTFields(E, i.PSBTInput, k)));
            for (const k of T)k.partialSig && !k.partialSig.length && delete k.partialSig, k.finalScriptSig && !k.finalScriptSig.length && delete k.finalScriptSig, k.finalScriptWitness && !k.finalScriptWitness.length && delete k.finalScriptWitness;
            const I = this.outputs.map((k)=>i.cleanPSBTFields(E, i.PSBTOutput, k)), P = {
                ...this.global
            };
            return E === 0 ? (P.unsignedTx = o.RawOldTx.decode(o.RawOldTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(N).map((k)=>({
                        ...k,
                        finalScriptSig: r.EMPTY
                    })),
                outputs: this.outputs.map(O)
            })), delete P.fallbackLocktime, delete P.txVersion) : (P.version = E, P.txVersion = this.version, P.inputCount = this.inputs.length, P.outputCount = this.outputs.length, P.fallbackLocktime && P.fallbackLocktime === e.DEFAULT_LOCKTIME && delete P.fallbackLocktime), this.opts.bip174jsCompat && (T.length || T.push({}), I.length || I.push({})), (E === 0 ? i.RawPSBTV0 : i.RawPSBTV2).encode({
                global: P,
                inputs: T,
                outputs: I
            });
        }
        // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)
        get lockTime() {
            let E = e.DEFAULT_LOCKTIME, T = 0, I = e.DEFAULT_LOCKTIME, P = 0;
            for (const k of this.inputs)k.requiredHeightLocktime && (E = Math.max(E, k.requiredHeightLocktime), T++), k.requiredTimeLocktime && (I = Math.max(I, k.requiredTimeLocktime), P++);
            return T && T >= P ? E : I !== e.DEFAULT_LOCKTIME ? I : this.global.fallbackLocktime || e.DEFAULT_LOCKTIME;
        }
        get version() {
            if (this.global.txVersion === void 0) throw new Error("No global.txVersion");
            return this.global.txVersion;
        }
        inputStatus(E) {
            this.checkInputIdx(E);
            const T = this.inputs[E];
            return T.finalScriptSig && T.finalScriptSig.length || T.finalScriptWitness && T.finalScriptWitness.length ? "finalized" : T.tapKeySig || T.tapScriptSig && T.tapScriptSig.length || T.partialSig && T.partialSig.length ? "signed" : "unsigned";
        }
        // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range
        // We will lose some vectors -> smaller test coverage of preimages (very important!)
        inputSighash(E) {
            this.checkInputIdx(E);
            const T = this.inputs[E].sighashType, I = T === void 0 ? y.DEFAULT : T, P = I === y.DEFAULT ? y.ALL : I & 3;
            return {
                sigInputs: I & y.ANYONECANPAY,
                sigOutputs: P
            };
        }
        // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.
        // Some cache will be nice, but there chance to have bugs with cache invalidation
        signStatus() {
            let E = !0, T = !0, I = [], P = [];
            for(let k = 0; k < this.inputs.length; k++){
                if (this.inputStatus(k) === "unsigned") continue;
                const { sigInputs: j, sigOutputs: ie } = this.inputSighash(k);
                if (j === y.ANYONECANPAY ? I.push(k) : E = !1, ie === y.ALL) T = !1;
                else if (ie === y.SINGLE) P.push(k);
                else if (ie !== y.NONE) throw new Error(`Wrong signature hash output type: ${ie}`);
            }
            return {
                addInput: E,
                addOutput: T,
                inputs: I,
                outputs: P
            };
        }
        get isFinal() {
            for(let E = 0; E < this.inputs.length; E++)if (this.inputStatus(E) !== "finalized") return !1;
            return !0;
        }
        // Info utils
        get hasWitnesses() {
            let E = !1;
            for (const T of this.inputs)T.finalScriptWitness && T.finalScriptWitness.length && (E = !0);
            return E;
        }
        // https://en.bitcoin.it/wiki/Weight_units
        get weight() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            let E = 32;
            const T = this.outputs.map(O);
            E += 4 * o.CompactSizeLen.encode(this.outputs.length).length;
            for (const I of T)E += 32 + 4 * o.VarBytes.encode(I.script).length;
            this.hasWitnesses && (E += 2), E += 4 * o.CompactSizeLen.encode(this.inputs.length).length;
            for (const I of this.inputs)E += 160 + 4 * o.VarBytes.encode(I.finalScriptSig || r.EMPTY).length, this.hasWitnesses && I.finalScriptWitness && (E += o.RawWitness.encode(I.finalScriptWitness).length);
            return E;
        }
        get vsize() {
            return (0, e.toVsize)(this.weight);
        }
        toBytes(E = !1, T = !1) {
            return o.RawTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(N).map((I)=>({
                        ...I,
                        finalScriptSig: E && I.finalScriptSig || r.EMPTY
                    })),
                outputs: this.outputs.map(O),
                witnesses: this.inputs.map((I)=>I.finalScriptWitness || []),
                segwitFlag: T && this.hasWitnesses
            });
        }
        get unsignedTx() {
            return this.toBytes(!1, !1);
        }
        get hex() {
            return t.hex.encode(this.toBytes(!0, this.hasWitnesses));
        }
        get hash() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return t.hex.encode(s.sha256x2(this.toBytes(!0)));
        }
        get id() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return t.hex.encode(s.sha256x2(this.toBytes(!0)).reverse());
        }
        // Input stuff
        checkInputIdx(E) {
            if (!Number.isSafeInteger(E) || 0 > E || E >= this.inputs.length) throw new Error(`Wrong input index=${E}`);
        }
        getInput(E) {
            return this.checkInputIdx(E), p(this.inputs[E]);
        }
        get inputsLength() {
            return this.inputs.length;
        }
        // Modification
        addInput(E, T = !1) {
            if (!T && !this.signStatus().addInput) throw new Error("Tx has signed inputs, cannot add new one");
            return this.inputs.push(R(E, void 0, void 0, this.opts.disableScriptCheck)), this.inputs.length - 1;
        }
        updateInput(E, T, I = !1) {
            this.checkInputIdx(E);
            let P;
            if (!I) {
                const k = this.signStatus();
                (!k.addInput || k.inputs.includes(E)) && (P = i.PSBTInputUnsignedKeys);
            }
            this.inputs[E] = R(T, this.inputs[E], P, this.opts.disableScriptCheck, this.opts.allowUnknown);
        }
        // Output stuff
        checkOutputIdx(E) {
            if (!Number.isSafeInteger(E) || 0 > E || E >= this.outputs.length) throw new Error(`Wrong output index=${E}`);
        }
        getOutput(E) {
            return this.checkOutputIdx(E), p(this.outputs[E]);
        }
        getOutputAddress(E, T = a.NETWORK) {
            const I = this.getOutput(E);
            if (I.script) return (0, n.Address)(T).encode(n.OutScript.decode(I.script));
        }
        get outputsLength() {
            return this.outputs.length;
        }
        normalizeOutput(E, T, I) {
            let { amount: P, script: k } = E;
            if (P === void 0 && (P = T == null ? void 0 : T.amount), typeof P != "bigint") throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${P} of type ${typeof P}`);
            typeof k == "string" && (k = t.hex.decode(k)), k === void 0 && (k = T == null ? void 0 : T.script);
            let L = {
                ...T,
                ...E,
                amount: P,
                script: k
            };
            if (L.amount === void 0 && delete L.amount, L = i.mergeKeyMap(i.PSBTOutput, L, T, I, this.opts.allowUnknown), i.PSBTOutputCoder.encode(L), L.script && !this.opts.allowUnknownOutputs && n.OutScript.decode(L.script).type === "unknown") throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
            return this.opts.disableScriptCheck || (0, n.checkScript)(L.script, L.redeemScript, L.witnessScript), L;
        }
        addOutput(E, T = !1) {
            if (!T && !this.signStatus().addOutput) throw new Error("Tx has signed outputs, cannot add new one");
            return this.outputs.push(this.normalizeOutput(E)), this.outputs.length - 1;
        }
        updateOutput(E, T, I = !1) {
            this.checkOutputIdx(E);
            let P;
            if (!I) {
                const k = this.signStatus();
                (!k.addOutput || k.outputs.includes(E)) && (P = i.PSBTOutputUnsignedKeys);
            }
            this.outputs[E] = this.normalizeOutput(T, this.outputs[E], P);
        }
        addOutputAddress(E, T, I = a.NETWORK) {
            return this.addOutput({
                script: n.OutScript.encode((0, n.Address)(I).decode(E)),
                amount: T
            });
        }
        // Utils
        get fee() {
            let E = 0n;
            for (const I of this.inputs){
                const P = G(I);
                if (!P) throw new Error("Empty input amount");
                E += P.amount;
            }
            const T = this.outputs.map(O);
            for (const I of T)E -= I.amount;
            return E;
        }
        // Signing
        // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624
        // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,
        // but we are trying to be less complicated for audit purpose for now.
        preimageLegacy(E, T, I) {
            const { isAny: P, isNone: k, isSingle: L } = K(I);
            if (E < 0 || !Number.isSafeInteger(E)) throw new Error(`Invalid input idx=${E}`);
            if (L && E >= this.outputs.length || E >= this.inputs.length) return r.U256BE.encode(1n);
            T = o.Script.encode(o.Script.decode(T).filter((ce)=>ce !== "CODESEPARATOR"));
            let j = this.inputs.map(N).map((ce, he)=>({
                    ...ce,
                    finalScriptSig: he === E ? T : r.EMPTY
                }));
            P ? j = [
                j[E]
            ] : (k || L) && (j = j.map((ce, he)=>({
                    ...ce,
                    sequence: he === E ? ce.sequence : 0
                })));
            let ie = this.outputs.map(O);
            k ? ie = [] : L && (ie = ie.slice(0, E).fill(f).concat([
                ie[E]
            ]));
            const ue = o.RawTx.encode({
                lockTime: this.lockTime,
                version: this.version,
                segwitFlag: !1,
                inputs: j,
                outputs: ie
            });
            return s.sha256x2(ue, r.I32LE.encode(I));
        }
        preimageWitnessV0(E, T, I, P) {
            const { isAny: k, isNone: L, isSingle: j } = K(I);
            let ie = u, ue = u, ce = u;
            const he = this.inputs.map(N), ee = this.outputs.map(O);
            k || (ie = s.sha256x2(...he.map(D.encode))), !k && !j && !L && (ue = s.sha256x2(...he.map((ye)=>r.U32LE.encode(ye.sequence)))), !j && !L ? ce = s.sha256x2(...ee.map(o.RawOutput.encode)) : j && E < ee.length && (ce = s.sha256x2(o.RawOutput.encode(ee[E])));
            const ae = he[E];
            return s.sha256x2(r.I32LE.encode(this.version), ie, ue, r.bytes(32, !0).encode(ae.txid), r.U32LE.encode(ae.index), o.VarBytes.encode(T), r.U64LE.encode(P), r.U32LE.encode(ae.sequence), ce, r.U32LE.encode(this.lockTime), r.U32LE.encode(I));
        }
        preimageWitnessV1(E, T, I, P, k = -1, L, j = 192, ie) {
            if (!Array.isArray(P) || this.inputs.length !== P.length) throw new Error(`Invalid amounts array=${P}`);
            if (!Array.isArray(T) || this.inputs.length !== T.length) throw new Error(`Invalid prevOutScript array=${T}`);
            const ue = [
                r.U8.encode(0),
                r.U8.encode(I),
                // U8 sigHash
                r.I32LE.encode(this.version),
                r.U32LE.encode(this.lockTime)
            ], ce = I === y.DEFAULT ? y.ALL : I & 3, he = I & y.ANYONECANPAY, ee = this.inputs.map(N), ae = this.outputs.map(O);
            he !== y.ANYONECANPAY && ue.push(...[
                ee.map(D.encode),
                P.map(r.U64LE.encode),
                T.map(o.VarBytes.encode),
                ee.map((Se)=>r.U32LE.encode(Se.sequence))
            ].map((Se)=>s.sha256((0, a.concatBytes)(...Se)))), ce === y.ALL && ue.push(s.sha256((0, a.concatBytes)(...ae.map(o.RawOutput.encode))));
            const ye = (ie ? 1 : 0) | (L ? 2 : 0);
            if (ue.push(new Uint8Array([
                ye
            ])), he === y.ANYONECANPAY) {
                const Se = ee[E];
                ue.push(D.encode(Se), r.U64LE.encode(P[E]), o.VarBytes.encode(T[E]), r.U32LE.encode(Se.sequence));
            } else ue.push(r.U32LE.encode(E));
            return ye & 1 && ue.push(s.sha256(o.VarBytes.encode(ie || r.EMPTY))), ce === y.SINGLE && ue.push(E < ae.length ? s.sha256(o.RawOutput.encode(ae[E])) : u), L && ue.push((0, n.tapLeafHash)(L, j), r.U8.encode(0), r.I32LE.encode(k)), s.tagSchnorr("TapSighash", ...ue);
        }
        // Signer can be privateKey OR instance of bip32 HD stuff
        signIdx(E, T, I, P) {
            this.checkInputIdx(T);
            const k = this.inputs[T], L = X(k, this.opts.allowLegacyWitnessUtxo);
            if (!(0, a.isBytes)(E)) {
                if (!k.bip32Derivation || !k.bip32Derivation.length) throw new Error("bip32Derivation: empty");
                const ce = k.bip32Derivation.filter((ee)=>ee[1].fingerprint == E.fingerprint).map(([ee, { path: ae }])=>{
                    let ye = E;
                    for (const Se of ae)ye = ye.deriveChild(Se);
                    if (!(0, a.equalBytes)(ye.publicKey, ee)) throw new Error("bip32Derivation: wrong pubKey");
                    if (!ye.privateKey) throw new Error("bip32Derivation: no privateKey");
                    return ye;
                });
                if (!ce.length) throw new Error(`bip32Derivation: no items with fingerprint=${E.fingerprint}`);
                let he = !1;
                for (const ee of ce)this.signIdx(ee.privateKey, T) && (he = !0);
                return he;
            }
            I ? I.forEach(H) : I = [
                L.defaultSighash
            ];
            const j = L.sighash;
            if (!I.includes(j)) throw new Error(`Input with not allowed sigHash=${j}. Allowed: ${I.join(", ")}`);
            const { sigOutputs: ie } = this.inputSighash(T);
            if (ie === y.SINGLE && T >= this.outputs.length) throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${T}`);
            const ue = G(k);
            if (L.txType === "taproot") {
                const ce = this.inputs.map(G), he = ce.map((De)=>De.script), ee = ce.map((De)=>De.amount);
                let ae = !1, ye = s.pubSchnorr(E), Se = k.tapMerkleRoot || r.EMPTY;
                if (k.tapInternalKey) {
                    const { pubKey: De, privKey: Re } = A(E, ye, k.tapInternalKey, Se), [Ce, M] = s.taprootTweakPubkey(k.tapInternalKey, Se);
                    if ((0, a.equalBytes)(Ce, De)) {
                        const z = this.preimageWitnessV1(T, he, j, ee), de = (0, a.concatBytes)(s.signSchnorr(z, Re, P), j !== y.DEFAULT ? new Uint8Array([
                            j
                        ]) : r.EMPTY);
                        this.updateInput(T, {
                            tapKeySig: de
                        }, !0), ae = !0;
                    }
                }
                if (k.tapLeafScript) {
                    k.tapScriptSig = k.tapScriptSig || [];
                    for (const [De, Re] of k.tapLeafScript){
                        const Ce = Re.subarray(0, -1), M = o.Script.decode(Ce), z = Re[Re.length - 1], de = (0, n.tapLeafHash)(Ce, z);
                        if (M.findIndex((Ke)=>(0, a.isBytes)(Ke) && (0, a.equalBytes)(Ke, ye)) === -1) continue;
                        const Ie = this.preimageWitnessV1(T, he, j, ee, void 0, Ce, z), je = (0, a.concatBytes)(s.signSchnorr(Ie, E, P), j !== y.DEFAULT ? new Uint8Array([
                            j
                        ]) : r.EMPTY);
                        this.updateInput(T, {
                            tapScriptSig: [
                                [
                                    {
                                        pubKey: ye,
                                        leafHash: de
                                    },
                                    je
                                ]
                            ]
                        }, !0), ae = !0;
                    }
                }
                if (!ae) throw new Error("No taproot scripts signed");
                return !0;
            } else {
                const ce = s.pubECDSA(E);
                let he = !1;
                const ee = s.hash160(ce);
                for (const Se of o.Script.decode(L.lastScript))(0, a.isBytes)(Se) && ((0, a.equalBytes)(Se, ce) || (0, a.equalBytes)(Se, ee)) && (he = !0);
                if (!he) throw new Error(`Input script doesn't have pubKey: ${L.lastScript}`);
                let ae;
                if (L.txType === "legacy") ae = this.preimageLegacy(T, L.lastScript, j);
                else if (L.txType === "segwit") {
                    let Se = L.lastScript;
                    L.last.type === "wpkh" && (Se = n.OutScript.encode({
                        type: "pkh",
                        hash: L.last.hash
                    })), ae = this.preimageWitnessV0(T, Se, j, ue.amount);
                } else throw new Error(`Transaction/sign: unknown tx type: ${L.txType}`);
                const ye = s.signECDSA(ae, E, this.opts.lowR);
                this.updateInput(T, {
                    partialSig: [
                        [
                            ce,
                            (0, a.concatBytes)(ye, new Uint8Array([
                                j
                            ]))
                        ]
                    ]
                }, !0);
            }
            return !0;
        }
        // This is bad API. Will work if user creates and signs tx, but if
        // there is some complex workflow with exchanging PSBT and signing them,
        // then it is better to validate which output user signs. How could a better API look like?
        // Example: user adds input, sends to another party, then signs received input (mixer etc),
        // another user can add different input for same key and user will sign it.
        // Even worse: another user can add bip32 derivation, and spend money from different address.
        // Better api: signIdx
        sign(E, T, I) {
            let P = 0;
            for(let k = 0; k < this.inputs.length; k++)try {
                this.signIdx(E, k, T, I) && P++;
            } catch  {}
            if (!P) throw new Error("No inputs signed");
            return P;
        }
        finalizeIdx(E) {
            if (this.checkInputIdx(E), this.fee < 0n) throw new Error("Outputs spends more than inputs amount");
            const T = this.inputs[E], I = X(T, this.opts.allowLegacyWitnessUtxo);
            if (I.txType === "taproot") {
                if (T.tapKeySig) T.finalScriptWitness = [
                    T.tapKeySig
                ];
                else if (T.tapLeafScript && T.tapScriptSig) {
                    const ie = T.tapLeafScript.sort((ue, ce)=>i.TaprootControlBlock.encode(ue[0]).length - i.TaprootControlBlock.encode(ce[0]).length);
                    for (const [ue, ce] of ie){
                        const he = ce.slice(0, -1), ee = ce[ce.length - 1], ae = n.OutScript.decode(he), ye = (0, n.tapLeafHash)(he, ee), Se = T.tapScriptSig.filter((Re)=>(0, a.equalBytes)(Re[0].leafHash, ye));
                        let De = [];
                        if (ae.type === "tr_ms") {
                            const Re = ae.m, Ce = ae.pubkeys;
                            let M = 0;
                            for (const z of Ce){
                                const de = Se.findIndex((_e)=>(0, a.equalBytes)(_e[0].pubKey, z));
                                if (M === Re || de === -1) {
                                    De.push(r.EMPTY);
                                    continue;
                                }
                                De.push(Se[de][1]), M++;
                            }
                            if (M !== Re) continue;
                        } else if (ae.type === "tr_ns") {
                            for (const Re of ae.pubkeys){
                                const Ce = Se.findIndex((M)=>(0, a.equalBytes)(M[0].pubKey, Re));
                                Ce !== -1 && De.push(Se[Ce][1]);
                            }
                            if (De.length !== ae.pubkeys.length) continue;
                        } else if (ae.type === "unknown" && this.opts.allowUnknownInputs) {
                            const Re = o.Script.decode(he);
                            if (De = Se.map(([{ pubKey: Ce }, M])=>{
                                const z = Re.findIndex((de)=>(0, a.isBytes)(de) && (0, a.equalBytes)(de, Ce));
                                if (z === -1) throw new Error("finalize/taproot: cannot find position of pubkey in script");
                                return {
                                    signature: M,
                                    pos: z
                                };
                            }).sort((Ce, M)=>Ce.pos - M.pos).map((Ce)=>Ce.signature), !De.length) continue;
                        } else {
                            const Re = this.opts.customScripts;
                            if (Re) for (const Ce of Re){
                                if (!Ce.finalizeTaproot) continue;
                                const M = o.Script.decode(he), z = Ce.encode(M);
                                if (z === void 0) continue;
                                const de = Ce.finalizeTaproot(he, z, Se);
                                if (de) {
                                    T.finalScriptWitness = de.concat(i.TaprootControlBlock.encode(ue)), T.finalScriptSig = r.EMPTY, U(T);
                                    return;
                                }
                            }
                            throw new Error("Finalize: Unknown tapLeafScript");
                        }
                        T.finalScriptWitness = De.reverse().concat([
                            he,
                            i.TaprootControlBlock.encode(ue)
                        ]);
                        break;
                    }
                    if (!T.finalScriptWitness) throw new Error("finalize/taproot: empty witness");
                } else throw new Error("finalize/taproot: unknown input");
                T.finalScriptSig = r.EMPTY, U(T);
                return;
            }
            if (!T.partialSig || !T.partialSig.length) throw new Error("Not enough partial sign");
            let P = r.EMPTY, k = [];
            if (I.last.type === "ms") {
                const ie = I.last.m, ue = I.last.pubkeys;
                let ce = [];
                for (const he of ue){
                    const ee = T.partialSig.find((ae)=>(0, a.equalBytes)(he, ae[0]));
                    ee && ce.push(ee[1]);
                }
                if (ce = ce.slice(0, ie), ce.length !== ie) throw new Error(`Multisig: wrong signatures count, m=${ie} n=${ue.length} signatures=${ce.length}`);
                P = o.Script.encode([
                    0,
                    ...ce
                ]);
            } else if (I.last.type === "pk") P = o.Script.encode([
                T.partialSig[0][1]
            ]);
            else if (I.last.type === "pkh") P = o.Script.encode([
                T.partialSig[0][1],
                T.partialSig[0][0]
            ]);
            else if (I.last.type === "wpkh") P = r.EMPTY, k = [
                T.partialSig[0][1],
                T.partialSig[0][0]
            ];
            else if (I.last.type === "unknown" && !this.opts.allowUnknownInputs) throw new Error("Unknown inputs not allowed");
            let L, j;
            if (I.type.includes("wsh-") && (P.length && I.lastScript.length && (k = o.Script.decode(P).map((ie)=>{
                if (ie === 0) return r.EMPTY;
                if ((0, a.isBytes)(ie)) return ie;
                throw new Error(`Wrong witness op=${ie}`);
            })), k = k.concat(I.lastScript)), I.txType === "segwit" && (j = k), I.type.startsWith("sh-wsh-") ? L = o.Script.encode([
                o.Script.encode([
                    0,
                    s.sha256(I.lastScript)
                ])
            ]) : I.type.startsWith("sh-") ? L = o.Script.encode([
                ...o.Script.decode(P),
                I.lastScript
            ]) : I.type.startsWith("wsh-") || I.txType !== "segwit" && (L = P), !L && !j) throw new Error("Unknown error finalizing input");
            L && (T.finalScriptSig = L), j && (T.finalScriptWitness = j), U(T);
        }
        finalize() {
            for(let E = 0; E < this.inputs.length; E++)this.finalizeIdx(E);
        }
        extract() {
            if (!this.isFinal) throw new Error("Transaction has unfinalized inputs");
            if (!this.outputs.length) throw new Error("Transaction has no outputs");
            if (this.fee < 0n) throw new Error("Outputs spends more than inputs amount");
            return this.toBytes(!0, !0);
        }
        combine(E) {
            for (const P of [
                "PSBTVersion",
                "version",
                "lockTime"
            ])if (this.opts[P] !== E.opts[P]) throw new Error(`Transaction/combine: different ${P} this=${this.opts[P]} other=${E.opts[P]}`);
            for (const P of [
                "inputs",
                "outputs"
            ])if (this[P].length !== E[P].length) throw new Error(`Transaction/combine: different ${P} length this=${this[P].length} other=${E[P].length}`);
            const T = this.global.unsignedTx ? o.RawOldTx.encode(this.global.unsignedTx) : r.EMPTY, I = E.global.unsignedTx ? o.RawOldTx.encode(E.global.unsignedTx) : r.EMPTY;
            if (!(0, a.equalBytes)(T, I)) throw new Error("Transaction/combine: different unsigned tx");
            this.global = i.mergeKeyMap(i.PSBTGlobal, this.global, E.global, void 0, this.opts.allowUnknown);
            for(let P = 0; P < this.inputs.length; P++)this.updateInput(P, E.inputs[P], !0);
            for(let P = 0; P < this.outputs.length; P++)this.updateOutput(P, E.outputs[P], !0);
            return this;
        }
        clone() {
            return $.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
        }
    }
    e.Transaction = $;
    function S(m) {
        if (!m || !Array.isArray(m) || !m.length) throw new Error("PSBTCombine: wrong PSBT list");
        const E = $.fromPSBT(m[0]);
        for(let T = 1; T < m.length; T++)E.combine($.fromPSBT(m[T]));
        return E.toPSBT();
    }
    const w = 2147483648;
    function g(m) {
        const E = [];
        if (!/^[mM]'?/.test(m)) throw new Error('Path must start with "m" or "M"');
        if (/^[mM]'?$/.test(m)) return E;
        const T = m.replace(/^[mM]'?\//, "").split("/");
        for (const I of T){
            const P = /^(\d+)('?)$/.exec(I);
            if (!P || P.length !== 3) throw new Error(`Invalid child index: ${I}`);
            let k = +P[1];
            if (!Number.isSafeInteger(k) || k >= w) throw new Error("Invalid index");
            P[2] === "'" && (k += w), E.push(k);
        }
        return E;
    }
})(Em);
var px = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._Estimator = e._cmpBig = void 0, e.selectUTXO = _;
    const t = zd, r = jf, n = yp, i = v0, o = jd, s = Em, a = wa, u = (A)=>i.TaprootControlBlock.encode(A);
    function f(A, O, N) {
        if (!A || !A.length) throw new Error("no leafs");
        const U = ()=>new Uint8Array(O), D = A.sort((H, K)=>u(H[0]).length - u(K[0]).length);
        for (const [H, K] of D){
            const re = K.slice(0, -1), Q = K[K.length - 1], G = n.OutScript.decode(re);
            let R = [];
            if (G.type === "tr_ms") {
                const X = G.m, $ = G.pubkeys.length - X;
                for(let S = 0; S < X; S++)R.push(U());
                for(let S = 0; S < $; S++)R.push(r.EMPTY);
            } else if (G.type === "tr_ns") for (const X of G.pubkeys)R.push(U());
            else {
                if (!N) throw new Error("Finalize: Unknown tapLeafScript");
                const X = (0, n.tapLeafHash)(re, Q);
                for (const $ of N){
                    if (!$.finalizeTaproot) continue;
                    const S = o.Script.decode(re), w = $.encode(S);
                    if (w === void 0) continue;
                    const g = S.filter((E)=>{
                        if (!(0, a.isBytes)(E)) return !1;
                        try {
                            return (0, a.validatePubkey)(E, a.PubT.schnorr), !0;
                        } catch  {
                            return !1;
                        }
                    }), m = $.finalizeTaproot(re, w, g.map((E)=>[
                            {
                                pubKey: E,
                                leafHash: X
                            },
                            U()
                        ]));
                    if (m) return m.concat(u(H));
                }
            }
            return R.reverse().concat([
                re,
                u(H)
            ]);
        }
        throw new Error("there was no witness");
    }
    function c(A, O, N) {
        let U = r.EMPTY, D;
        if (A.txType === "taproot") {
            const re = A.sighash !== s.SignatureHash.DEFAULT ? 65 : 64;
            if (O.tapInternalKey && !(0, a.equalBytes)(O.tapInternalKey, a.TAPROOT_UNSPENDABLE_KEY)) D = [
                new Uint8Array(re)
            ];
            else if (O.tapLeafScript) D = f(O.tapLeafScript, re, N.customScripts);
            else throw new Error("estimateInput/taproot: unknown input");
        } else {
            const re = ()=>new Uint8Array(72), Q = ()=>new Uint8Array(33);
            let G = r.EMPTY, R = [];
            const X = A.last.type;
            if (X === "ms") {
                const $ = A.last.m, S = [
                    0
                ];
                for(let w = 0; w < $; w++)S.push(re());
                G = o.Script.encode(S);
            } else if (X === "pk") G = o.Script.encode([
                re()
            ]);
            else if (X === "pkh") G = o.Script.encode([
                re(),
                Q()
            ]);
            else if (X === "wpkh") G = r.EMPTY, R = [
                re(),
                Q()
            ];
            else if (X === "unknown" && !N.allowUnknownInputs) throw new Error("Unknown inputs are not allowed");
            A.type.includes("wsh-") && (G.length && A.lastScript.length && (R = o.Script.decode(G).map(($)=>{
                if ($ === 0) return r.EMPTY;
                if ((0, a.isBytes)($)) return $;
                throw new Error(`Wrong witness op=${$}`);
            })), R = R.concat(A.lastScript)), A.txType === "segwit" && (D = R), A.type.startsWith("sh-wsh-") ? U = o.Script.encode([
                o.Script.encode([
                    0,
                    new Uint8Array(a.sha256.outputLen)
                ])
            ]) : A.type.startsWith("sh-") ? U = o.Script.encode([
                ...o.Script.decode(G),
                A.lastScript
            ]) : A.type.startsWith("wsh-") || A.txType !== "segwit" && (U = G);
        }
        let H = 160 + 4 * o.VarBytes.encode(U).length, K = !1;
        return D && (H += o.RawWitness.encode(D).length, K = !0), {
            weight: H,
            hasWitnesses: K
        };
    }
    const l = (A, O)=>{
        const N = A - O;
        return N < 0n ? -1 : N > 0n ? 1 : 0;
    };
    e._cmpBig = l;
    function p(A, O = {}, N = a.NETWORK) {
        let U;
        if ("script" in A && (0, a.isBytes)(A.script) && (U = A.script), "address" in A) {
            if (typeof A.address != "string") throw new Error(`Estimator: wrong output address=${A.address}`);
            U = n.OutScript.encode((0, n.Address)(N).decode(A.address));
        }
        if (!U) throw new Error("Estimator: wrong output script");
        if (typeof A.amount != "bigint") throw new Error(`Estimator: wrong output amount=${A.amount}, should be of type bigint but got ${typeof A.amount}.`);
        if (U && !O.allowUnknownOutputs && n.OutScript.decode(U).type === "unknown") throw new Error("Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
        return O.disableScriptCheck || (0, n.checkScript)(U), U;
    }
    class y {
        constructor(O, N, U){
            if (this.requiredIndices = [], this.outputs = N, this.opts = U, typeof U.feePerByte != "bigint") throw new Error(`Estimator: wrong feePerByte=${U.feePerByte}, should be of type bigint but got ${typeof U.feePerByte}.`);
            const K = U.dust === void 0 ? BigInt(148 + 34) : U.dust;
            if (typeof K != "bigint") throw new Error(`Estimator: wrong dust=${U.dust}, should be of type bigint but got ${typeof U.dust}.`);
            const re = U.dustRelayFeeRate === void 0 ? 3n : U.dustRelayFeeRate;
            if (typeof re != "bigint") throw new Error(`Estimator: wrong dustRelayFeeRate=${U.dustRelayFeeRate}, should be of type bigint but got ${typeof U.dustRelayFeeRate}.`);
            if (this.dust = K * re, U.requiredInputs !== void 0 && !Array.isArray(U.requiredInputs)) throw new Error(`Estimator: wrong required inputs=${U.requiredInputs}`);
            const Q = U.network || a.NETWORK;
            let G = 0n, R = 32;
            for (const w of N){
                const g = p(w, U, U.network);
                R += 32 + 4 * o.VarBytes.encode(g).length, G += w.amount;
            }
            if (typeof U.changeAddress != "string") throw new Error(`Estimator: wrong change address=${U.changeAddress}`);
            let X = R + 32 + 4 * o.VarBytes.encode(n.OutScript.encode((0, n.Address)(Q).decode(U.changeAddress))).length;
            R += 4 * o.CompactSizeLen.encode(N.length).length, X += 4 * o.CompactSizeLen.encode(N.length + 1).length, this.baseWeight = R, this.changeWeight = X, this.amount = G;
            const $ = Array.from(O);
            if (U.requiredInputs) for(let w = 0; w < U.requiredInputs.length; w++)this.requiredIndices.push($.push(U.requiredInputs[w]) - 1);
            const S = /* @__PURE__ */ new Set();
            this.normalizedInputs = $.map((w)=>{
                const g = (0, s.normalizeInput)(w, void 0, void 0, U.disableScriptCheck, U.allowUnknown);
                (0, s.inputBeforeSign)(g);
                const m = `${t.hex.encode(g.txid)}:${g.index}`;
                if (!U.allowSameUtxo && S.has(m)) throw new Error(`Estimator: same input passed multiple times: ${m}`);
                S.add(m);
                const E = (0, s.getInputType)(g, U.allowLegacyWitnessUtxo), T = (0, s.getPrevOut)(g), I = c(E, g, this.opts), P = T.amount - U.feePerByte * BigInt((0, s.toVsize)(I.weight));
                return {
                    inputType: E,
                    normalized: g,
                    amount: T.amount,
                    value: P,
                    estimate: I
                };
            });
        }
        checkInputIdx(O) {
            if (!Number.isSafeInteger(O) || 0 > O || O >= this.normalizedInputs.length) throw new Error(`Wrong input index=${O}`);
            return O;
        }
        sortIndices(O) {
            return O.slice().sort((N, U)=>{
                const D = this.normalizedInputs[this.checkInputIdx(N)], H = this.normalizedInputs[this.checkInputIdx(U)], K = (0, a.compareBytes)(D.normalized.txid, H.normalized.txid);
                return K !== 0 ? K : D.normalized.index - H.normalized.index;
            });
        }
        sortOutputs(O) {
            const N = O.map((D)=>p(D, this.opts, this.opts.network));
            return O.map((D, H)=>H).sort((D, H)=>{
                const K = O[D].amount, re = O[H].amount, Q = (0, e._cmpBig)(K, re);
                return Q !== 0 ? Q : (0, a.compareBytes)(N[D], N[H]);
            });
        }
        getSatoshi(O) {
            return this.opts.feePerByte * BigInt((0, s.toVsize)(O));
        }
        // Sort by value instead of amount
        get biggest() {
            return this.normalizedInputs.map((O, N)=>N).sort((O, N)=>(0, e._cmpBig)(this.normalizedInputs[N].value, this.normalizedInputs[O].value));
        }
        get smallest() {
            return this.biggest.reverse();
        }
        // These assume that UTXO array has historical order.
        // Otherwise, we have no way to know which tx is oldest
        // Explorers usually give UTXO in this order.
        get oldest() {
            return this.normalizedInputs.map((O, N)=>N);
        }
        get newest() {
            return this.oldest.reverse();
        }
        // exact - like blackjack from coinselect.
        // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.
        // If not, it will accumulate largest utxo until value is close to targetValue+dust.
        accumulate(O, N = !1, U = !0, D = !1) {
            let H = this.opts.alwaysChange ? this.changeWeight : this.baseWeight, K = !1, re = 0, Q = 0n;
            const G = this.amount, R = /* @__PURE__ */ new Set();
            let X;
            for (const $ of this.requiredIndices){
                if (this.checkInputIdx($), R.has($)) throw new Error("required input encountered multiple times");
                const { estimate: S, amount: w } = this.normalizedInputs[$];
                let g = H + S.weight;
                !K && S.hasWitnesses && (g += 2);
                const m = g + 4 * o.CompactSizeLen.encode(re).length;
                if (X = this.getSatoshi(m), H = g, S.hasWitnesses && (K = !0), re++, Q += w, R.add($), !D && G + X <= Q && re >= this.requiredIndices.length) return {
                    indices: Array.from(R),
                    fee: X,
                    weight: m,
                    total: Q
                };
            }
            for (const $ of O){
                if (this.checkInputIdx($), R.has($)) continue;
                const { estimate: S, amount: w, value: g } = this.normalizedInputs[$];
                let m = H + S.weight;
                !K && S.hasWitnesses && (m += 2);
                const E = m + 4 * o.CompactSizeLen.encode(re).length;
                if (X = this.getSatoshi(E), !(N && w + Q > G + X + this.dust) && !(U && g <= 0n) && (H = m, S.hasWitnesses && (K = !0), re++, Q += w, R.add($), !D && G + X <= Q)) return {
                    indices: Array.from(R),
                    fee: X,
                    weight: E,
                    total: Q
                };
            }
            if (D) {
                const $ = H + 4 * o.CompactSizeLen.encode(re).length;
                return {
                    indices: Array.from(R),
                    fee: X,
                    weight: $,
                    total: Q
                };
            }
        }
        // Works like coinselect default method
        default() {
            const { biggest: O } = this, N = this.accumulate(O, !0, !1);
            return N || this.accumulate(O);
        }
        select(O) {
            if (O === "all") return this.accumulate(this.normalizedInputs.map((U, D)=>D), !1, !0, !0);
            if (O === "default") return this.default();
            const N = {
                Oldest: ()=>this.oldest,
                Newest: ()=>this.newest,
                Smallest: ()=>this.smallest,
                Biggest: ()=>this.biggest
            };
            if (O.startsWith("exact")) {
                const [U, D] = O.slice(5).split("/");
                if (!N[U]) throw new Error(`Estimator.select: wrong strategy=${O}`);
                O = D;
                const H = this.accumulate(N[U](), !0, !0);
                if (H) return H;
            }
            if (O.startsWith("accum")) {
                const U = O.slice(5);
                if (!N[U]) throw new Error(`Estimator.select: wrong strategy=${O}`);
                return this.accumulate(N[U]());
            }
            throw new Error(`Estimator.select: wrong strategy=${O}`);
        }
        result(O) {
            const N = this.select(O);
            if (!N) return;
            const { indices: U, weight: D, total: H } = N;
            let K = this.opts.alwaysChange;
            const re = this.opts.alwaysChange ? D : D + (this.changeWeight - this.baseWeight), Q = this.getSatoshi(re);
            let G = N.fee;
            const R = H - this.amount - Q;
            R > this.dust && (K = !0);
            let X = U, $ = Array.from(this.outputs);
            if (K) {
                if (G = Q, R < 0n) throw new Error(`Estimator.result: negative change=${R}`);
                $.push({
                    address: this.opts.changeAddress,
                    amount: R
                });
            }
            this.opts.bip69 && (X = this.sortIndices(X), $ = this.sortOutputs($).map((g)=>$[g]));
            const S = {
                inputs: X.map((g)=>this.normalizedInputs[g].normalized),
                outputs: $,
                fee: G,
                weight: this.opts.alwaysChange ? N.weight : re,
                change: !!K
            };
            let w;
            if (this.opts.createTx) {
                const { inputs: g, outputs: m } = S;
                w = new s.Transaction(this.opts);
                for (const E of g)w.addInput(E);
                for (const E of m)w.addOutput({
                    ...E,
                    script: p(E, this.opts, this.opts.network)
                });
            }
            return Object.assign(S, {
                tx: w
            });
        }
    }
    e._Estimator = y;
    function _(A, O, N, U) {
        const D = {
            createTx: !0,
            bip69: !0,
            ...U
        };
        return new y(A, O, D).result(N);
    }
})(px);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._Estimator = e._cmpBig = e.SigHash = e.PSBTCombine = e.DEFAULT_SEQUENCE = e.Decimal = e.bip32Path = e.TaprootControlBlock = e._DebugPSBT = e.WIF = e.taprootListToTree = e.sortedMultisig = e.OutScript = e.getAddress = e.combinations = e.Address = e._sortPubkeys = e.utils = e.selectUTXO = e.TEST_NETWORK = e.TAPROOT_UNSPENDABLE_KEY = e.NETWORK = e.Transaction = e.getInputType = e.ScriptNum = e.Script = e.RawWitness = e.RawTx = e.OP = e.MAX_SCRIPT_BYTE_LENGTH = e.CompactSize = e.p2wsh = e.p2wpkh = e.p2tr_pk = e.p2tr_ns = e.p2tr_ms = e.p2tr = e.p2sh = e.p2pkh = e.p2pk = e.p2ms = e.multisig = void 0;
    /*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = wa;
    var r = yp;
    Object.defineProperty(e, "multisig", {
        enumerable: !0,
        get: function() {
            return r.multisig;
        }
    }), Object.defineProperty(e, "p2ms", {
        enumerable: !0,
        get: function() {
            return r.p2ms;
        }
    }), Object.defineProperty(e, "p2pk", {
        enumerable: !0,
        get: function() {
            return r.p2pk;
        }
    }), Object.defineProperty(e, "p2pkh", {
        enumerable: !0,
        get: function() {
            return r.p2pkh;
        }
    }), Object.defineProperty(e, "p2sh", {
        enumerable: !0,
        get: function() {
            return r.p2sh;
        }
    }), Object.defineProperty(e, "p2tr", {
        enumerable: !0,
        get: function() {
            return r.p2tr;
        }
    }), Object.defineProperty(e, "p2tr_ms", {
        enumerable: !0,
        get: function() {
            return r.p2tr_ms;
        }
    }), Object.defineProperty(e, "p2tr_ns", {
        enumerable: !0,
        get: function() {
            return r.p2tr_ns;
        }
    }), Object.defineProperty(e, "p2tr_pk", {
        enumerable: !0,
        get: function() {
            return r.p2tr_pk;
        }
    }), Object.defineProperty(e, "p2wpkh", {
        enumerable: !0,
        get: function() {
            return r.p2wpkh;
        }
    }), Object.defineProperty(e, "p2wsh", {
        enumerable: !0,
        get: function() {
            return r.p2wsh;
        }
    });
    var n = jd;
    Object.defineProperty(e, "CompactSize", {
        enumerable: !0,
        get: function() {
            return n.CompactSize;
        }
    }), Object.defineProperty(e, "MAX_SCRIPT_BYTE_LENGTH", {
        enumerable: !0,
        get: function() {
            return n.MAX_SCRIPT_BYTE_LENGTH;
        }
    }), Object.defineProperty(e, "OP", {
        enumerable: !0,
        get: function() {
            return n.OP;
        }
    }), Object.defineProperty(e, "RawTx", {
        enumerable: !0,
        get: function() {
            return n.RawTx;
        }
    }), Object.defineProperty(e, "RawWitness", {
        enumerable: !0,
        get: function() {
            return n.RawWitness;
        }
    }), Object.defineProperty(e, "Script", {
        enumerable: !0,
        get: function() {
            return n.Script;
        }
    }), Object.defineProperty(e, "ScriptNum", {
        enumerable: !0,
        get: function() {
            return n.ScriptNum;
        }
    });
    var i = Em;
    Object.defineProperty(e, "getInputType", {
        enumerable: !0,
        get: function() {
            return i.getInputType;
        }
    }), Object.defineProperty(e, "Transaction", {
        enumerable: !0,
        get: function() {
            return i.Transaction;
        }
    });
    var o = wa;
    Object.defineProperty(e, "NETWORK", {
        enumerable: !0,
        get: function() {
            return o.NETWORK;
        }
    }), Object.defineProperty(e, "TAPROOT_UNSPENDABLE_KEY", {
        enumerable: !0,
        get: function() {
            return o.TAPROOT_UNSPENDABLE_KEY;
        }
    }), Object.defineProperty(e, "TEST_NETWORK", {
        enumerable: !0,
        get: function() {
            return o.TEST_NETWORK;
        }
    });
    var s = px;
    Object.defineProperty(e, "selectUTXO", {
        enumerable: !0,
        get: function() {
            return s.selectUTXO;
        }
    }), e.utils = {
        isBytes: t.isBytes,
        concatBytes: t.concatBytes,
        compareBytes: t.compareBytes,
        pubSchnorr: t.pubSchnorr,
        randomPrivateKeyBytes: t.randomPrivateKeyBytes,
        taprootTweakPubkey: t.taprootTweakPubkey
    };
    var a = yp;
    Object.defineProperty(e, "_sortPubkeys", {
        enumerable: !0,
        get: function() {
            return a._sortPubkeys;
        }
    }), Object.defineProperty(e, "Address", {
        enumerable: !0,
        get: function() {
            return a.Address;
        }
    }), Object.defineProperty(e, "combinations", {
        enumerable: !0,
        get: function() {
            return a.combinations;
        }
    }), Object.defineProperty(e, "getAddress", {
        enumerable: !0,
        get: function() {
            return a.getAddress;
        }
    }), Object.defineProperty(e, "OutScript", {
        enumerable: !0,
        get: function() {
            return a.OutScript;
        }
    }), Object.defineProperty(e, "sortedMultisig", {
        enumerable: !0,
        get: function() {
            return a.sortedMultisig;
        }
    }), Object.defineProperty(e, "taprootListToTree", {
        enumerable: !0,
        get: function() {
            return a.taprootListToTree;
        }
    }), Object.defineProperty(e, "WIF", {
        enumerable: !0,
        get: function() {
            return a.WIF;
        }
    });
    var u = v0;
    Object.defineProperty(e, "_DebugPSBT", {
        enumerable: !0,
        get: function() {
            return u._DebugPSBT;
        }
    }), Object.defineProperty(e, "TaprootControlBlock", {
        enumerable: !0,
        get: function() {
            return u.TaprootControlBlock;
        }
    });
    var f = Em;
    Object.defineProperty(e, "bip32Path", {
        enumerable: !0,
        get: function() {
            return f.bip32Path;
        }
    }), Object.defineProperty(e, "Decimal", {
        enumerable: !0,
        get: function() {
            return f.Decimal;
        }
    }), Object.defineProperty(e, "DEFAULT_SEQUENCE", {
        enumerable: !0,
        get: function() {
            return f.DEFAULT_SEQUENCE;
        }
    }), Object.defineProperty(e, "PSBTCombine", {
        enumerable: !0,
        get: function() {
            return f.PSBTCombine;
        }
    }), Object.defineProperty(e, "SigHash", {
        enumerable: !0,
        get: function() {
            return f.SigHash;
        }
    });
    var c = px;
    Object.defineProperty(e, "_cmpBig", {
        enumerable: !0,
        get: function() {
            return c._cmpBig;
        }
    }), Object.defineProperty(e, "_Estimator", {
        enumerable: !0,
        get: function() {
            return c._Estimator;
        }
    });
})(vS);
var s1 = {}, rce = Ge && Ge.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), nce = Ge && Ge.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), ice = Ge && Ge.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && rce(t, e, r);
    return nce(t, e), t;
};
Object.defineProperty(s1, "__esModule", {
    value: !0
});
s1.CBOR = void 0;
const xr = ice(wS), uy = vS, _S = (e)=>e === 0 && 1 / e < 0, SI = xr.wrap({
    encodeStream (e, t) {
        if (t === 1 / 0) return e.bytes(new Uint8Array([
            124,
            0
        ]));
        if (t === -1 / 0) return e.bytes(new Uint8Array([
            252,
            0
        ]));
        if (Number.isNaN(t)) return e.bytes(new Uint8Array([
            126,
            0
        ]));
        if (_S(t)) return e.bytes(new Uint8Array([
            128,
            0
        ]));
        throw e.err("f16: not implemented");
    },
    decodeStream: (e)=>{
        const t = xr.U16BE.decodeStream(e), r = (t & 31744) >> 10, n = t & 1023;
        let i;
        return r === 0 ? i = 6103515625e-14 * (n / 1024) : r !== 31 ? i = Math.pow(2, r - 15) * (1 + n / 1024) : i = n ? NaN : 1 / 0, t & 32768 ? -i : i;
    }
}), hi = xr.bits(5), oce = xr.apply(xr.U64BE, xr.coders.numberBigint), ic = {
    24: [
        2 ** 8 - 1,
        xr.U8,
        xr.U8
    ],
    25: [
        2 ** 16 - 1,
        xr.U16BE,
        xr.U16BE
    ],
    26: [
        2 ** 32 - 1,
        xr.U32BE,
        xr.U32BE
    ],
    27: [
        2n ** 64n - 1n,
        xr.U64BE,
        oce
    ]
}, xm = xr.wrap({
    encodeStream (e, t) {
        if (t < 24) return hi.encodeStream(e, typeof t == "bigint" ? Number(t) : t);
        for(const r in ic){
            const [n, i, o] = ic[r];
            if (!(t > n)) return hi.encodeStream(e, Number(r)), i.encodeStream(e, t);
        }
        throw e.err(`cbor/uint: wrong value=${t}`);
    },
    decodeStream (e) {
        const t = hi.decodeStream(e);
        if (t < 24) return t;
        const r = ic[t][1];
        if (!r) throw e.err(`cbor/uint wrong additional information=${t}`);
        return r.decodeStream(e);
    }
}), sce = xr.wrap({
    encodeStream: (e, t)=>xm.encodeStream(e, typeof t == "bigint" ? -(t + 1n) : -(t + 1)),
    decodeStream (e) {
        const t = xm.decodeStream(e);
        return typeof t == "bigint" ? -1n - t : -1 - t;
    }
}), AI = (e)=>xr.wrap({
        encodeStream (t, r) {
            if (r.length < 24) {
                hi.encodeStream(t, r.length), xr.array(r.length, e).encodeStream(t, r);
                return;
            }
            for(const n in ic){
                const [i, o, s] = ic[n];
                if (r.length < i) {
                    hi.encodeStream(t, Number(n)), xr.array(s, e).encodeStream(t, r);
                    return;
                }
            }
            throw t.err(`cbor/lengthArray: wrong value=${r}`);
        },
        decodeStream (t) {
            const r = hi.decodeStream(t);
            if (r < 24) return xr.array(r, e).decodeStream(t);
            if (r === 31) return xr.array(new Uint8Array([
                255
            ]), e).decodeStream(t);
            const n = ic[r][2];
            if (!n) throw t.err(`cbor/lengthArray wrong length=${r}`);
            return xr.array(n, e).decodeStream(t);
        }
    }), TI = (e, t)=>xr.wrap({
        encodeStream (r, n) {
            if (Array.isArray(n)) throw new Error("cbor/length: encoding indefinite-length strings not supported");
            const i = e(null).encode(n);
            if (i.length < 24) {
                hi.encodeStream(r, i.length), r.bytes(i);
                return;
            }
            for(const o in ic){
                const [s, a, u] = ic[o];
                if (i.length < s) {
                    hi.encodeStream(r, Number(o)), u.encodeStream(r, i.length), r.bytes(i);
                    return;
                }
            }
            throw r.err(`cbor/lengthArray: wrong value=${n}`);
        },
        decodeStream (r) {
            const n = hi.decodeStream(r);
            if (n < 24) return e(n).decodeStream(r);
            if (n === 31) return xr.array(new Uint8Array([
                255
            ]), t).decodeStream(r);
            const i = ic[n][2];
            if (!i) throw r.err(`cbor/length wrong length=${n}`);
            return e(i).decodeStream(r);
        }
    }), ace = xr.wrap({
    encodeStream (e, t) {
        if (t === !1) return hi.encodeStream(e, 20);
        if (t === !0) return hi.encodeStream(e, 21);
        if (t === null) return hi.encodeStream(e, 22);
        if (t === void 0) return hi.encodeStream(e, 23);
        if (typeof t != "number") throw e.err(`cbor/simple: wrong value type=${typeof t}`);
        return _S(t) || Number.isNaN(t) || t === 1 / 0 || t === -1 / 0 ? (hi.encodeStream(e, 25), SI.encodeStream(e, t)) : Math.fround(t) === t ? (hi.encodeStream(e, 26), xr.F32BE.encodeStream(e, t)) : (hi.encodeStream(e, 27), xr.F64BE.encodeStream(e, t));
    },
    decodeStream (e) {
        const t = hi.decodeStream(e);
        if (t === 20) return !1;
        if (t === 21) return !0;
        if (t === 22) return null;
        if (t !== 23) {
            if (t === 25) return SI.decodeStream(e);
            if (t === 26) return xr.F32BE.decodeStream(e);
            if (t === 27) return xr.F64BE.decodeStream(e);
            throw e.err("cbor/simple: unassigned");
        }
    }
}), Xu = xr.mappedTag(xr.bits(3), {
    uint: [
        0,
        xm
    ],
    // An unsigned integer in the range 0..264-1 inclusive.
    negint: [
        1,
        sce
    ],
    // A negative integer in the range -264..-1 inclusive
    bytes: [
        2,
        xr.lazy(()=>TI(xr.bytes, Xu))
    ],
    // A byte string.
    string: [
        3,
        xr.lazy(()=>TI(xr.string, Xu))
    ],
    // A text string (utf8)
    array: [
        4,
        AI(xr.lazy(()=>Xu))
    ],
    // An array of data items
    map: [
        5,
        xr.lazy(()=>AI(xr.tuple([
                Xu,
                Xu
            ])))
    ],
    // A map of pairs of data items
    tag: [
        6,
        xr.tuple([
            xm,
            xr.lazy(()=>Xu)
        ])
    ],
    // A tagged data item ("tag") whose tag number
    simple: [
        7,
        ace
    ]
});
s1.CBOR = xr.apply(Xu, {
    encode (e) {
        let t = e.data;
        if (e.TAG === "bytes") {
            if (uy.utils.isBytes(t)) return t;
            const r = [];
            if (!Array.isArray(t)) throw new Error(`CBOR: wrong indefinite-length bytestring=${t}`);
            for (const n of t){
                if (n.TAG !== "bytes" || !uy.utils.isBytes(n.data)) throw new Error(`CBOR: wrong indefinite-length bytestring=${n}`);
                r.push(n.data);
            }
            return uy.utils.concatBytes(...r);
        }
        if (e.TAG === "string") {
            if (typeof t == "string") return t;
            if (!Array.isArray(t)) throw new Error(`CBOR: wrong indefinite-length string=${t}`);
            let r = "";
            for (const n of t){
                if (n.TAG !== "string" || typeof n.data != "string") throw new Error(`CBOR: wrong indefinite-length string=${n}`);
                r += n.data;
            }
            return r;
        }
        if (e.TAG === "array" && Array.isArray(t) && (t = t.map((r)=>this.encode(r))), e.TAG === "map" && typeof t == "object" && t !== null) return Object.fromEntries(e.data.map(([r, n])=>[
                this.encode(r),
                this.encode(n)
            ]));
        if (e.TAG === "tag") throw new Error("not implemented");
        return t;
    },
    decode (e) {
        if (typeof e == "bigint") return e < 0n ? {
            TAG: "negint",
            data: e
        } : {
            TAG: "uint",
            data: e
        };
        if (typeof e == "string") return {
            TAG: "string",
            data: e
        };
        if (uy.utils.isBytes(e)) return {
            TAG: "bytes",
            data: e
        };
        if (Array.isArray(e)) return {
            TAG: "array",
            data: e.map((t)=>this.decode(t))
        };
        if (typeof e == "number" && Number.isSafeInteger(e) && !_S(e)) return e < 0 ? {
            TAG: "negint",
            data: e
        } : {
            TAG: "uint",
            data: e
        };
        if (typeof e == "boolean" || typeof e == "number" || e === null || e === void 0) return {
            TAG: "simple",
            data: e
        };
        if (typeof e == "object") return {
            TAG: "map",
            data: Object.entries(e).map((t)=>t.map((r)=>this.decode(r)))
        };
        throw new Error("unknown type");
    }
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(D, H, K, re) {
        re === void 0 && (re = K);
        var Q = Object.getOwnPropertyDescriptor(H, K);
        (!Q || ("get" in Q ? !H.__esModule : Q.writable || Q.configurable)) && (Q = {
            enumerable: !0,
            get: function() {
                return H[K];
            }
        }), Object.defineProperty(D, re, Q);
    } : function(D, H, K, re) {
        re === void 0 && (re = K), D[re] = H[K];
    }), r = Ge && Ge.__setModuleDefault || (Object.create ? function(D, H) {
        Object.defineProperty(D, "default", {
            enumerable: !0,
            value: H
        });
    } : function(D, H) {
        D.default = H;
    }), n = Ge && Ge.__importStar || function(D) {
        if (D && D.__esModule) return D;
        var H = {};
        if (D != null) for(var K in D)K !== "default" && Object.prototype.hasOwnProperty.call(D, K) && t(H, D, K);
        return r(H, D), H;
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.__test__ = e.OutOrdinalReveal = e.InscriptionId = void 0, e.parseInscriptions = O, e.parseWitness = N, e.p2tr_ord_reveal = U;
    const i = bS, o = n(wS), s = vS, a = s1, u = /* @__PURE__ */ i.utf8.decode("BIN");
    function f(D) {
        const H = [];
        for(let K = 0; K < D.length; K += s.MAX_SCRIPT_BYTE_LENGTH)H.push(D.subarray(K, K + s.MAX_SCRIPT_BYTE_LENGTH));
        return H;
    }
    const c = /* @__PURE__ */ o.tuple([
        o.bytes(32, !0),
        o.apply(o.bigint(4, !0, !1, !1), o.coders.numberBigint)
    ]);
    e.InscriptionId = {
        encode (D) {
            const [H, K] = D.split("i", 2);
            if (`${+K}` !== K) throw new Error(`InscriptionId wrong index: ${K}`);
            return c.encode([
                i.hex.decode(H),
                +K
            ]);
        },
        decode (D) {
            const [H, K] = c.decode(D);
            return `${i.hex.encode(H)}i${K}`;
        }
    };
    const l = {
        // Would be simpler to have body tag here,
        // but body chunks don't have body tag near them
        contentType: 1,
        pointer: 2,
        parent: 3,
        metadata: 5,
        metaprotocol: 7,
        contentEncoding: 9,
        delegate: 11,
        rune: 13,
        note: 15
    }, p = /* @__PURE__ */ o.map(o.U8, l), y = {
        pointer: o.bigint(8, !0, !1, !1),
        // U64
        contentType: o.string(null),
        parent: e.InscriptionId,
        metadata: a.CBOR,
        metaprotocol: o.string(null),
        contentEncoding: o.string(null),
        delegate: e.InscriptionId,
        rune: o.bigint(16, !0, !1, !1),
        // U128
        note: o.string(null)
    }, _ = {
        encode (D) {
            const H = {}, K = [];
            for (const { tag: Q, data: G } of D)try {
                const R = p.decode(Q);
                H[R] || (H[R] = []), H[R].push(G);
            } catch  {
                K.push([
                    Q,
                    G
                ]);
            }
            const re = {};
            K.length && (re.unknown = K);
            for(const Q in H){
                if (Q === "parent" && H[Q].length > 1) {
                    re[Q] = H[Q].map((G)=>y.parent.decode(G));
                    continue;
                }
                re[Q] = y[Q].decode(s.utils.concatBytes(...H[Q]));
            }
            return re;
        },
        decode (D) {
            const H = [];
            for(const K in D){
                if (K === "unknown") continue;
                const re = p.encode(K);
                if (K === "parent" && Array.isArray(D.parent)) {
                    for (const G of D.parent)H.push({
                        tag: re,
                        data: y.parent.encode(G)
                    });
                    continue;
                }
                const Q = y[K].encode(D[K]);
                for (const G of f(Q))H.push({
                    tag: re,
                    data: G
                });
            }
            if (D.unknown) {
                if (!Array.isArray(D.unknown)) throw new Error("ordinals/TagCoder: unknown should be array");
                for (const [K, re] of D.unknown)H.push({
                    tag: K,
                    data: re
                });
            }
            return H;
        }
    }, A = (D, H = 0)=>{
        if (!Number.isSafeInteger(H)) throw new Error(`parseInscription: wrong pos=${typeof H}`);
        const K = [];
        let re = !1;
        e: for(; H < D.length; H++){
            if (D[H] !== 0) continue;
            if (D[H + 1] !== "IF") {
                D[H + 1] === 0 && (re = !0);
                continue e;
            }
            if (!s.utils.isBytes(D[H + 2]) || !o.utils.equalBytes(D[H + 2], u)) {
                D[H + 2] === 0 && (re = !0);
                continue e;
            }
            let G = !1;
            const R = [];
            for(let X = H + 3; X < D.length; X++){
                const $ = D[X];
                if ($ === "ENDIF") {
                    K.push({
                        start: H + 3,
                        end: X,
                        pushnum: G,
                        payload: R,
                        stutter: re
                    }), H = X;
                    break;
                }
                if ($ === "1NEGATE") {
                    G = !0, R.push(new Uint8Array([
                        129
                    ]));
                    continue;
                }
                if (typeof $ == "number" && 1 <= $ && $ <= 16) {
                    G = !0, R.push(new Uint8Array([
                        $
                    ]));
                    continue;
                }
                if (s.utils.isBytes($) || $ === 0) {
                    R.push($);
                    continue;
                }
                re = !1;
                break;
            }
        }
        return K;
    };
    function O(D, H = !1) {
        if (H && (!s.utils.isBytes(D[0]) || D[0].length !== 32) || H && D[1] !== "CHECKSIG") return;
        const K = A(D), re = [];
        let Q = 5;
        for (const G of K){
            if (H && (G.stutter || G.pushnum) || H && G.start !== Q) return;
            const { payload: R } = G;
            let X = 0;
            const $ = [];
            for(; X < R.length && R[X] !== 0; X += 2){
                const w = R[X], g = R[X + 1];
                if (!s.utils.isBytes(w)) throw new Error("parseInscription: non-bytes tag");
                if (!s.utils.isBytes(g)) throw new Error("parseInscription: non-bytes tag data");
                $.push({
                    tag: w,
                    data: g
                });
            }
            for(; R[X] === 0 && X < R.length;)X++;
            const S = [];
            for(; X < R.length && s.utils.isBytes(R[X]); X++)S.push(R[X]);
            re.push({
                tags: _.encode($),
                body: s.utils.concatBytes(...S),
                cursed: G.pushnum || G.stutter
            }), Q = G.end + 4;
        }
        if (Q - 3 === D.length) return re;
    }
    function N(D) {
        if (D.length !== 3) throw new Error("Wrong witness");
        return O(s.Script.decode(D[1]));
    }
    e.OutOrdinalReveal = {
        encode (D) {
            const H = {
                type: "tr_ord_reveal"
            };
            try {
                H.inscriptions = O(D, !0), H.pubkey = D[0];
            } catch  {
                return;
            }
            return H;
        },
        decode: (D)=>{
            if (D.type !== "tr_ord_reveal") return;
            const H = [
                D.pubkey,
                "CHECKSIG"
            ];
            for (const { tags: K, body: re } of D.inscriptions){
                H.push(0, "IF", u);
                const Q = _.decode(K);
                for (const G of Q)H.push(G.tag, G.data);
                H.push(0);
                for (const G of f(re))H.push(G);
                H.push("ENDIF");
            }
            return H;
        },
        finalizeTaproot: (D, H, K)=>{
            if (K.length !== 1) throw new Error("tr_ord_reveal/finalize: wrong signatures array");
            const [{ pubKey: re }, Q] = K[0];
            if (o.utils.equalBytes(re, H.pubkey)) return [
                Q,
                D
            ];
        }
    };
    function U(D, H) {
        return {
            type: "tr_ord_reveal",
            script: o.apply(s.Script, o.coders.match([
                e.OutOrdinalReveal
            ])).encode({
                type: "tr_ord_reveal",
                pubkey: D,
                inscriptions: H
            })
        };
    }
    e.__test__ = {
        TagCoders: y,
        TagCoder: _,
        parseEnvelopes: A
    };
})(eM);
var uM = {}, _0 = {};
Object.defineProperty(_0, "__esModule", {
    value: !0
});
_0.AbstractProvider = void 0;
class cce {
}
_0.AbstractProvider = cce;
var E0 = {};
Object.defineProperty(E0, "__esModule", {
    value: !0
});
E0.AbstractSigner = void 0;
class uce {
}
E0.AbstractSigner = uce;
var a1 = {};
Object.defineProperty(a1, "__esModule", {
    value: !0
});
a1.Signer = void 0;
const fce = E0;
let lce = class extends fce.AbstractSigner {
    static from(t) {
        return new this(t, null);
    }
    connect(t) {
        return new this.constructor(this._target, t);
    }
    constructor(t, r){
        super(), this._target = t, this._provider = r;
    }
    get provider() {
        return this._provider;
    }
    async signPsbt(...t) {
        return await this._target.signPsbt(...t);
    }
    async signMessage(...t) {
        return await this._target.signMessage(...t);
    }
};
a1.Signer = lce;
var c1 = {}, Sm = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ Sm.exports;
(function(e, t) {
    (function() {
        var r, n = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", a = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", f = 500, c = "__lodash_placeholder__", l = 1, p = 2, y = 4, _ = 1, A = 2, O = 1, N = 2, U = 4, D = 8, H = 16, K = 32, re = 64, Q = 128, G = 256, R = 512, X = 30, $ = "...", S = 800, w = 16, g = 1, m = 2, E = 3, T = 1 / 0, I = 9007199254740991, P = 17976931348623157e292, k = NaN, L = 4294967295, j = L - 1, ie = L >>> 1, ue = [
            [
                "ary",
                Q
            ],
            [
                "bind",
                O
            ],
            [
                "bindKey",
                N
            ],
            [
                "curry",
                D
            ],
            [
                "curryRight",
                H
            ],
            [
                "flip",
                R
            ],
            [
                "partial",
                K
            ],
            [
                "partialRight",
                re
            ],
            [
                "rearg",
                G
            ]
        ], ce = "[object Arguments]", he = "[object Array]", ee = "[object AsyncFunction]", ae = "[object Boolean]", ye = "[object Date]", Se = "[object DOMException]", De = "[object Error]", Re = "[object Function]", Ce = "[object GeneratorFunction]", M = "[object Map]", z = "[object Number]", de = "[object Null]", _e = "[object Object]", Ie = "[object Promise]", je = "[object Proxy]", Ke = "[object RegExp]", Ue = "[object Set]", h = "[object String]", x = "[object Symbol]", q = "[object Undefined]", te = "[object WeakMap]", fe = "[object WeakSet]", ne = "[object ArrayBuffer]", W = "[object DataView]", J = "[object Float32Array]", V = "[object Float64Array]", C = "[object Int8Array]", Z = "[object Int16Array]", le = "[object Int32Array]", se = "[object Uint8Array]", Ne = "[object Uint8ClampedArray]", Le = "[object Uint16Array]", rt = "[object Uint32Array]", yt = /\b__p \+= '';/g, _t = /\b(__p \+=) '' \+/g, Qe = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Rt = /&(?:amp|lt|gt|quot|#39);/g, Lt = /[&<>"']/g, Ur = RegExp(Rt.source), jr = RegExp(Lt.source), Et = /<%-([\s\S]+?)%>/g, Xt = /<%([\s\S]+?)%>/g, wr = /<%=([\s\S]+?)%>/g, zt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ae = /^\w*$/, we = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xe = /[\\^$.*+?()[\]{}|]/g, Me = RegExp(xe.source), ze = /^\s+/, Ve = /\s/, at = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ct = /\{\n\/\* \[wrapped with (.+)\] \*/, lt = /,? & /, mt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, wt = /[()=,{}\[\]\/\s]/, bt = /\\(\\)?/g, Mt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ct = /\w*$/, Xe = /^[-+]0x[0-9a-f]+$/i, xt = /^0b[01]+$/i, St = /^\[object .+?Constructor\]$/, Pe = /^0o[0-7]+$/i, et = /^(?:0|[1-9]\d*)$/, vt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, be = /($^)/, $r = /['\n\r\u2028\u2029\\]/g, jt = "\\ud800-\\udfff", nr = "\\u0300-\\u036f", kt = "\\ufe20-\\ufe2f", Hn = "\\u20d0-\\u20ff", Zr = nr + kt + Hn, v = "\\u2700-\\u27bf", B = "a-z\\xdf-\\xf6\\xf8-\\xff", Y = "\\xac\\xb1\\xd7\\xf7", pe = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ke = "\\u2000-\\u206f", qe = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ut = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ft = "\\ufe0e\\ufe0f", pn = Y + pe + ke + qe, bs = "[']", M0 = "[" + jt + "]", u8 = "[" + pn + "]", R0 = "[" + Zr + "]", f8 = "\\d+", CU = "[" + v + "]", l8 = "[" + B + "]", d8 = "[^" + jt + pn + f8 + v + B + ut + "]", O1 = "\\ud83c[\\udffb-\\udfff]", UU = "(?:" + R0 + "|" + O1 + ")", h8 = "[^" + jt + "]", P1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", N1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Vf = "[" + ut + "]", p8 = "\\u200d", g8 = "(?:" + l8 + "|" + d8 + ")", $U = "(?:" + Vf + "|" + d8 + ")", y8 = "(?:" + bs + "(?:d|ll|m|re|s|t|ve))?", m8 = "(?:" + bs + "(?:D|LL|M|RE|S|T|VE))?", b8 = UU + "?", w8 = "[" + Ft + "]?", LU = "(?:" + p8 + "(?:" + [
            h8,
            P1,
            N1
        ].join("|") + ")" + w8 + b8 + ")*", DU = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", FU = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", v8 = w8 + b8 + LU, zU = "(?:" + [
            CU,
            P1,
            N1
        ].join("|") + ")" + v8, jU = "(?:" + [
            h8 + R0 + "?",
            R0,
            P1,
            N1,
            M0
        ].join("|") + ")", HU = RegExp(bs, "g"), qU = RegExp(R0, "g"), M1 = RegExp(O1 + "(?=" + O1 + ")|" + jU + v8, "g"), KU = RegExp([
            Vf + "?" + l8 + "+" + y8 + "(?=" + [
                u8,
                Vf,
                "$"
            ].join("|") + ")",
            $U + "+" + m8 + "(?=" + [
                u8,
                Vf + g8,
                "$"
            ].join("|") + ")",
            Vf + "?" + g8 + "+" + y8,
            Vf + "+" + m8,
            FU,
            DU,
            f8,
            zU
        ].join("|"), "g"), WU = RegExp("[" + p8 + jt + Zr + Ft + "]"), VU = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, GU = [
            "Array",
            "Buffer",
            "DataView",
            "Date",
            "Error",
            "Float32Array",
            "Float64Array",
            "Function",
            "Int8Array",
            "Int16Array",
            "Int32Array",
            "Map",
            "Math",
            "Object",
            "Promise",
            "RegExp",
            "Set",
            "String",
            "Symbol",
            "TypeError",
            "Uint8Array",
            "Uint8ClampedArray",
            "Uint16Array",
            "Uint32Array",
            "WeakMap",
            "_",
            "clearTimeout",
            "isFinite",
            "parseInt",
            "setTimeout"
        ], ZU = -1, dn = {};
        dn[J] = dn[V] = dn[C] = dn[Z] = dn[le] = dn[se] = dn[Ne] = dn[Le] = dn[rt] = !0, dn[ce] = dn[he] = dn[ne] = dn[ae] = dn[W] = dn[ye] = dn[De] = dn[Re] = dn[M] = dn[z] = dn[_e] = dn[Ke] = dn[Ue] = dn[h] = dn[te] = !1;
        var cn = {};
        cn[ce] = cn[he] = cn[ne] = cn[W] = cn[ae] = cn[ye] = cn[J] = cn[V] = cn[C] = cn[Z] = cn[le] = cn[M] = cn[z] = cn[_e] = cn[Ke] = cn[Ue] = cn[h] = cn[x] = cn[se] = cn[Ne] = cn[Le] = cn[rt] = !0, cn[De] = cn[Re] = cn[te] = !1;
        var YU = {
            // Latin-1 Supplement block.
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "C",
            : "c",
            : "D",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "N",
            : "n",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "Y",
            : "y",
            : "y",
            : "Ae",
            : "ae",
            : "Th",
            : "th",
            : "ss",
            // Latin Extended-A block.
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "C",
            : "C",
            : "C",
            : "C",
            : "c",
            : "c",
            : "c",
            : "c",
            : "D",
            : "D",
            : "d",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "G",
            : "G",
            : "G",
            : "G",
            : "g",
            : "g",
            : "g",
            : "g",
            : "H",
            : "H",
            : "h",
            : "h",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "J",
            : "j",
            : "K",
            : "k",
            : "k",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "N",
            : "N",
            : "N",
            : "N",
            : "n",
            : "n",
            : "n",
            : "n",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "R",
            : "R",
            : "R",
            : "r",
            : "r",
            : "r",
            : "S",
            : "S",
            : "S",
            : "S",
            : "s",
            : "s",
            : "s",
            : "s",
            : "T",
            : "T",
            : "T",
            : "t",
            : "t",
            : "t",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "W",
            : "w",
            : "Y",
            : "y",
            : "Y",
            : "Z",
            : "Z",
            : "Z",
            : "z",
            : "z",
            : "z",
            : "IJ",
            : "ij",
            : "Oe",
            : "oe",
            : "'n",
            : "s"
        }, XU = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, JU = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        }, QU = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        }, e$ = parseFloat, t$ = parseInt, _8 = typeof Ge == "object" && Ge && Ge.Object === Object && Ge, r$ = typeof self == "object" && self && self.Object === Object && self, ci = _8 || r$ || Function("return this")(), R1 = t && !t.nodeType && t, Mu = R1 && !0 && e && !e.nodeType && e, E8 = Mu && Mu.exports === R1, C1 = E8 && _8.process, Fo = function() {
            try {
                var Fe = Mu && Mu.require && Mu.require("util").types;
                return Fe || C1 && C1.binding && C1.binding("util");
            } catch  {}
        }(), x8 = Fo && Fo.isArrayBuffer, S8 = Fo && Fo.isDate, A8 = Fo && Fo.isMap, T8 = Fo && Fo.isRegExp, k8 = Fo && Fo.isSet, I8 = Fo && Fo.isTypedArray;
        function bo(Fe, tt, Ye) {
            switch(Ye.length){
                case 0:
                    return Fe.call(tt);
                case 1:
                    return Fe.call(tt, Ye[0]);
                case 2:
                    return Fe.call(tt, Ye[0], Ye[1]);
                case 3:
                    return Fe.call(tt, Ye[0], Ye[1], Ye[2]);
            }
            return Fe.apply(tt, Ye);
        }
        function n$(Fe, tt, Ye, Pt) {
            for(var sr = -1, Wr = Fe == null ? 0 : Fe.length; ++sr < Wr;){
                var qn = Fe[sr];
                tt(Pt, qn, Ye(qn), Fe);
            }
            return Pt;
        }
        function zo(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length; ++Ye < Pt && tt(Fe[Ye], Ye, Fe) !== !1;);
            return Fe;
        }
        function i$(Fe, tt) {
            for(var Ye = Fe == null ? 0 : Fe.length; Ye-- && tt(Fe[Ye], Ye, Fe) !== !1;);
            return Fe;
        }
        function B8(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length; ++Ye < Pt;)if (!tt(Fe[Ye], Ye, Fe)) return !1;
            return !0;
        }
        function wc(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length, sr = 0, Wr = []; ++Ye < Pt;){
                var qn = Fe[Ye];
                tt(qn, Ye, Fe) && (Wr[sr++] = qn);
            }
            return Wr;
        }
        function C0(Fe, tt) {
            var Ye = Fe == null ? 0 : Fe.length;
            return !!Ye && Gf(Fe, tt, 0) > -1;
        }
        function U1(Fe, tt, Ye) {
            for(var Pt = -1, sr = Fe == null ? 0 : Fe.length; ++Pt < sr;)if (Ye(tt, Fe[Pt])) return !0;
            return !1;
        }
        function gn(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length, sr = Array(Pt); ++Ye < Pt;)sr[Ye] = tt(Fe[Ye], Ye, Fe);
            return sr;
        }
        function vc(Fe, tt) {
            for(var Ye = -1, Pt = tt.length, sr = Fe.length; ++Ye < Pt;)Fe[sr + Ye] = tt[Ye];
            return Fe;
        }
        function $1(Fe, tt, Ye, Pt) {
            var sr = -1, Wr = Fe == null ? 0 : Fe.length;
            for(Pt && Wr && (Ye = Fe[++sr]); ++sr < Wr;)Ye = tt(Ye, Fe[sr], sr, Fe);
            return Ye;
        }
        function o$(Fe, tt, Ye, Pt) {
            var sr = Fe == null ? 0 : Fe.length;
            for(Pt && sr && (Ye = Fe[--sr]); sr--;)Ye = tt(Ye, Fe[sr], sr, Fe);
            return Ye;
        }
        function L1(Fe, tt) {
            for(var Ye = -1, Pt = Fe == null ? 0 : Fe.length; ++Ye < Pt;)if (tt(Fe[Ye], Ye, Fe)) return !0;
            return !1;
        }
        var s$ = D1("length");
        function a$(Fe) {
            return Fe.split("");
        }
        function c$(Fe) {
            return Fe.match(mt) || [];
        }
        function O8(Fe, tt, Ye) {
            var Pt;
            return Ye(Fe, function(sr, Wr, qn) {
                if (tt(sr, Wr, qn)) return Pt = Wr, !1;
            }), Pt;
        }
        function U0(Fe, tt, Ye, Pt) {
            for(var sr = Fe.length, Wr = Ye + (Pt ? 1 : -1); Pt ? Wr-- : ++Wr < sr;)if (tt(Fe[Wr], Wr, Fe)) return Wr;
            return -1;
        }
        function Gf(Fe, tt, Ye) {
            return tt === tt ? v$(Fe, tt, Ye) : U0(Fe, P8, Ye);
        }
        function u$(Fe, tt, Ye, Pt) {
            for(var sr = Ye - 1, Wr = Fe.length; ++sr < Wr;)if (Pt(Fe[sr], tt)) return sr;
            return -1;
        }
        function P8(Fe) {
            return Fe !== Fe;
        }
        function N8(Fe, tt) {
            var Ye = Fe == null ? 0 : Fe.length;
            return Ye ? z1(Fe, tt) / Ye : k;
        }
        function D1(Fe) {
            return function(tt) {
                return tt == null ? r : tt[Fe];
            };
        }
        function F1(Fe) {
            return function(tt) {
                return Fe == null ? r : Fe[tt];
            };
        }
        function M8(Fe, tt, Ye, Pt, sr) {
            return sr(Fe, function(Wr, qn, an) {
                Ye = Pt ? (Pt = !1, Wr) : tt(Ye, Wr, qn, an);
            }), Ye;
        }
        function f$(Fe, tt) {
            var Ye = Fe.length;
            for(Fe.sort(tt); Ye--;)Fe[Ye] = Fe[Ye].value;
            return Fe;
        }
        function z1(Fe, tt) {
            for(var Ye, Pt = -1, sr = Fe.length; ++Pt < sr;){
                var Wr = tt(Fe[Pt]);
                Wr !== r && (Ye = Ye === r ? Wr : Ye + Wr);
            }
            return Ye;
        }
        function j1(Fe, tt) {
            for(var Ye = -1, Pt = Array(Fe); ++Ye < Fe;)Pt[Ye] = tt(Ye);
            return Pt;
        }
        function l$(Fe, tt) {
            return gn(tt, function(Ye) {
                return [
                    Ye,
                    Fe[Ye]
                ];
            });
        }
        function R8(Fe) {
            return Fe && Fe.slice(0, L8(Fe) + 1).replace(ze, "");
        }
        function wo(Fe) {
            return function(tt) {
                return Fe(tt);
            };
        }
        function H1(Fe, tt) {
            return gn(tt, function(Ye) {
                return Fe[Ye];
            });
        }
        function Gd(Fe, tt) {
            return Fe.has(tt);
        }
        function C8(Fe, tt) {
            for(var Ye = -1, Pt = Fe.length; ++Ye < Pt && Gf(tt, Fe[Ye], 0) > -1;);
            return Ye;
        }
        function U8(Fe, tt) {
            for(var Ye = Fe.length; Ye-- && Gf(tt, Fe[Ye], 0) > -1;);
            return Ye;
        }
        function d$(Fe, tt) {
            for(var Ye = Fe.length, Pt = 0; Ye--;)Fe[Ye] === tt && ++Pt;
            return Pt;
        }
        var h$ = F1(YU), p$ = F1(XU);
        function g$(Fe) {
            return "\\" + QU[Fe];
        }
        function y$(Fe, tt) {
            return Fe == null ? r : Fe[tt];
        }
        function Zf(Fe) {
            return WU.test(Fe);
        }
        function m$(Fe) {
            return VU.test(Fe);
        }
        function b$(Fe) {
            for(var tt, Ye = []; !(tt = Fe.next()).done;)Ye.push(tt.value);
            return Ye;
        }
        function q1(Fe) {
            var tt = -1, Ye = Array(Fe.size);
            return Fe.forEach(function(Pt, sr) {
                Ye[++tt] = [
                    sr,
                    Pt
                ];
            }), Ye;
        }
        function $8(Fe, tt) {
            return function(Ye) {
                return Fe(tt(Ye));
            };
        }
        function _c(Fe, tt) {
            for(var Ye = -1, Pt = Fe.length, sr = 0, Wr = []; ++Ye < Pt;){
                var qn = Fe[Ye];
                (qn === tt || qn === c) && (Fe[Ye] = c, Wr[sr++] = Ye);
            }
            return Wr;
        }
        function $0(Fe) {
            var tt = -1, Ye = Array(Fe.size);
            return Fe.forEach(function(Pt) {
                Ye[++tt] = Pt;
            }), Ye;
        }
        function w$(Fe) {
            var tt = -1, Ye = Array(Fe.size);
            return Fe.forEach(function(Pt) {
                Ye[++tt] = [
                    Pt,
                    Pt
                ];
            }), Ye;
        }
        function v$(Fe, tt, Ye) {
            for(var Pt = Ye - 1, sr = Fe.length; ++Pt < sr;)if (Fe[Pt] === tt) return Pt;
            return -1;
        }
        function _$(Fe, tt, Ye) {
            for(var Pt = Ye + 1; Pt--;)if (Fe[Pt] === tt) return Pt;
            return Pt;
        }
        function Yf(Fe) {
            return Zf(Fe) ? x$(Fe) : s$(Fe);
        }
        function ws(Fe) {
            return Zf(Fe) ? S$(Fe) : a$(Fe);
        }
        function L8(Fe) {
            for(var tt = Fe.length; tt-- && Ve.test(Fe.charAt(tt)););
            return tt;
        }
        var E$ = F1(JU);
        function x$(Fe) {
            for(var tt = M1.lastIndex = 0; M1.test(Fe);)++tt;
            return tt;
        }
        function S$(Fe) {
            return Fe.match(M1) || [];
        }
        function A$(Fe) {
            return Fe.match(KU) || [];
        }
        var T$ = function Fe(tt) {
            tt = tt == null ? ci : Xf.defaults(ci.Object(), tt, Xf.pick(ci, GU));
            var Ye = tt.Array, Pt = tt.Date, sr = tt.Error, Wr = tt.Function, qn = tt.Math, an = tt.Object, K1 = tt.RegExp, k$ = tt.String, jo = tt.TypeError, L0 = Ye.prototype, I$ = Wr.prototype, Jf = an.prototype, D0 = tt["__core-js_shared__"], F0 = I$.toString, Qr = Jf.hasOwnProperty, B$ = 0, D8 = function() {
                var d = /[^.]+$/.exec(D0 && D0.keys && D0.keys.IE_PROTO || "");
                return d ? "Symbol(src)_1." + d : "";
            }(), z0 = Jf.toString, O$ = F0.call(an), P$ = ci._, N$ = K1("^" + F0.call(Qr).replace(xe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), j0 = E8 ? tt.Buffer : r, Ec = tt.Symbol, H0 = tt.Uint8Array, F8 = j0 ? j0.allocUnsafe : r, q0 = $8(an.getPrototypeOf, an), z8 = an.create, j8 = Jf.propertyIsEnumerable, K0 = L0.splice, H8 = Ec ? Ec.isConcatSpreadable : r, Zd = Ec ? Ec.iterator : r, Ru = Ec ? Ec.toStringTag : r, W0 = function() {
                try {
                    var d = Du(an, "defineProperty");
                    return d({}, "", {}), d;
                } catch  {}
            }(), M$ = tt.clearTimeout !== ci.clearTimeout && tt.clearTimeout, R$ = Pt && Pt.now !== ci.Date.now && Pt.now, C$ = tt.setTimeout !== ci.setTimeout && tt.setTimeout, V0 = qn.ceil, G0 = qn.floor, W1 = an.getOwnPropertySymbols, U$ = j0 ? j0.isBuffer : r, q8 = tt.isFinite, $$ = L0.join, L$ = $8(an.keys, an), Kn = qn.max, vi = qn.min, D$ = Pt.now, F$ = tt.parseInt, K8 = qn.random, z$ = L0.reverse, V1 = Du(tt, "DataView"), Yd = Du(tt, "Map"), G1 = Du(tt, "Promise"), Qf = Du(tt, "Set"), Xd = Du(tt, "WeakMap"), Jd = Du(an, "create"), Z0 = Xd && new Xd(), el = {}, j$ = Fu(V1), H$ = Fu(Yd), q$ = Fu(G1), K$ = Fu(Qf), W$ = Fu(Xd), Y0 = Ec ? Ec.prototype : r, Qd = Y0 ? Y0.valueOf : r, W8 = Y0 ? Y0.toString : r;
            function me(d) {
                if (On(d) && !ur(d) && !(d instanceof Rr)) {
                    if (d instanceof Ho) return d;
                    if (Qr.call(d, "__wrapped__")) return V6(d);
                }
                return new Ho(d);
            }
            var tl = /* @__PURE__ */ function() {
                function d() {}
                return function(b) {
                    if (!wn(b)) return {};
                    if (z8) return z8(b);
                    d.prototype = b;
                    var F = new d();
                    return d.prototype = r, F;
                };
            }();
            function X0() {}
            function Ho(d, b) {
                this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!b, this.__index__ = 0, this.__values__ = r;
            }
            me.templateSettings = {
                /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ escape: Et,
                /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ evaluate: Xt,
                /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ interpolate: wr,
                /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */ variable: "",
                /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */ imports: {
                    /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */ _: me
                }
            }, me.prototype = X0.prototype, me.prototype.constructor = me, Ho.prototype = tl(X0.prototype), Ho.prototype.constructor = Ho;
            function Rr(d) {
                this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = L, this.__views__ = [];
            }
            function V$() {
                var d = new Rr(this.__wrapped__);
                return d.__actions__ = Yi(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = Yi(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = Yi(this.__views__), d;
            }
            function G$() {
                if (this.__filtered__) {
                    var d = new Rr(this);
                    d.__dir__ = -1, d.__filtered__ = !0;
                } else d = this.clone(), d.__dir__ *= -1;
                return d;
            }
            function Z$() {
                var d = this.__wrapped__.value(), b = this.__dir__, F = ur(d), oe = b < 0, ge = F ? d.length : 0, ve = aD(0, ge, this.__views__), Oe = ve.start, $e = ve.end, He = $e - Oe, it = oe ? $e : Oe - 1, st = this.__iteratees__, ft = st.length, At = 0, Ut = vi(He, this.__takeCount__);
                if (!F || !oe && ge == He && Ut == He) return y6(d, this.__actions__);
                var Vt = [];
                e: for(; He-- && At < Ut;){
                    it += b;
                    for(var vr = -1, Gt = d[it]; ++vr < ft;){
                        var Pr = st[vr], Lr = Pr.iteratee, Eo = Pr.type, Fi = Lr(Gt);
                        if (Eo == m) Gt = Fi;
                        else if (!Fi) {
                            if (Eo == g) continue e;
                            break e;
                        }
                    }
                    Vt[At++] = Gt;
                }
                return Vt;
            }
            Rr.prototype = tl(X0.prototype), Rr.prototype.constructor = Rr;
            function Cu(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++b < F;){
                    var oe = d[b];
                    this.set(oe[0], oe[1]);
                }
            }
            function Y$() {
                this.__data__ = Jd ? Jd(null) : {}, this.size = 0;
            }
            function X$(d) {
                var b = this.has(d) && delete this.__data__[d];
                return this.size -= b ? 1 : 0, b;
            }
            function J$(d) {
                var b = this.__data__;
                if (Jd) {
                    var F = b[d];
                    return F === u ? r : F;
                }
                return Qr.call(b, d) ? b[d] : r;
            }
            function Q$(d) {
                var b = this.__data__;
                return Jd ? b[d] !== r : Qr.call(b, d);
            }
            function eL(d, b) {
                var F = this.__data__;
                return this.size += this.has(d) ? 0 : 1, F[d] = Jd && b === r ? u : b, this;
            }
            Cu.prototype.clear = Y$, Cu.prototype.delete = X$, Cu.prototype.get = J$, Cu.prototype.has = Q$, Cu.prototype.set = eL;
            function Oa(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++b < F;){
                    var oe = d[b];
                    this.set(oe[0], oe[1]);
                }
            }
            function tL() {
                this.__data__ = [], this.size = 0;
            }
            function rL(d) {
                var b = this.__data__, F = J0(b, d);
                if (F < 0) return !1;
                var oe = b.length - 1;
                return F == oe ? b.pop() : K0.call(b, F, 1), --this.size, !0;
            }
            function nL(d) {
                var b = this.__data__, F = J0(b, d);
                return F < 0 ? r : b[F][1];
            }
            function iL(d) {
                return J0(this.__data__, d) > -1;
            }
            function oL(d, b) {
                var F = this.__data__, oe = J0(F, d);
                return oe < 0 ? (++this.size, F.push([
                    d,
                    b
                ])) : F[oe][1] = b, this;
            }
            Oa.prototype.clear = tL, Oa.prototype.delete = rL, Oa.prototype.get = nL, Oa.prototype.has = iL, Oa.prototype.set = oL;
            function Pa(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++b < F;){
                    var oe = d[b];
                    this.set(oe[0], oe[1]);
                }
            }
            function sL() {
                this.size = 0, this.__data__ = {
                    hash: new Cu(),
                    map: new (Yd || Oa)(),
                    string: new Cu()
                };
            }
            function aL(d) {
                var b = fg(this, d).delete(d);
                return this.size -= b ? 1 : 0, b;
            }
            function cL(d) {
                return fg(this, d).get(d);
            }
            function uL(d) {
                return fg(this, d).has(d);
            }
            function fL(d, b) {
                var F = fg(this, d), oe = F.size;
                return F.set(d, b), this.size += F.size == oe ? 0 : 1, this;
            }
            Pa.prototype.clear = sL, Pa.prototype.delete = aL, Pa.prototype.get = cL, Pa.prototype.has = uL, Pa.prototype.set = fL;
            function Uu(d) {
                var b = -1, F = d == null ? 0 : d.length;
                for(this.__data__ = new Pa(); ++b < F;)this.add(d[b]);
            }
            function lL(d) {
                return this.__data__.set(d, u), this;
            }
            function dL(d) {
                return this.__data__.has(d);
            }
            Uu.prototype.add = Uu.prototype.push = lL, Uu.prototype.has = dL;
            function vs(d) {
                var b = this.__data__ = new Oa(d);
                this.size = b.size;
            }
            function hL() {
                this.__data__ = new Oa(), this.size = 0;
            }
            function pL(d) {
                var b = this.__data__, F = b.delete(d);
                return this.size = b.size, F;
            }
            function gL(d) {
                return this.__data__.get(d);
            }
            function yL(d) {
                return this.__data__.has(d);
            }
            function mL(d, b) {
                var F = this.__data__;
                if (F instanceof Oa) {
                    var oe = F.__data__;
                    if (!Yd || oe.length < i - 1) return oe.push([
                        d,
                        b
                    ]), this.size = ++F.size, this;
                    F = this.__data__ = new Pa(oe);
                }
                return F.set(d, b), this.size = F.size, this;
            }
            vs.prototype.clear = hL, vs.prototype.delete = pL, vs.prototype.get = gL, vs.prototype.has = yL, vs.prototype.set = mL;
            function V8(d, b) {
                var F = ur(d), oe = !F && zu(d), ge = !F && !oe && kc(d), ve = !F && !oe && !ge && ol(d), Oe = F || oe || ge || ve, $e = Oe ? j1(d.length, k$) : [], He = $e.length;
                for(var it in d)(b || Qr.call(d, it)) && !(Oe && // Safari 9 has enumerable `arguments.length` in strict mode.
                (it == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                ge && (it == "offset" || it == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                ve && (it == "buffer" || it == "byteLength" || it == "byteOffset") || // Skip index properties.
                Ca(it, He))) && $e.push(it);
                return $e;
            }
            function G8(d) {
                var b = d.length;
                return b ? d[ow(0, b - 1)] : r;
            }
            function bL(d, b) {
                return lg(Yi(d), $u(b, 0, d.length));
            }
            function wL(d) {
                return lg(Yi(d));
            }
            function Z1(d, b, F) {
                (F !== r && !_s(d[b], F) || F === r && !(b in d)) && Na(d, b, F);
            }
            function eh(d, b, F) {
                var oe = d[b];
                (!(Qr.call(d, b) && _s(oe, F)) || F === r && !(b in d)) && Na(d, b, F);
            }
            function J0(d, b) {
                for(var F = d.length; F--;)if (_s(d[F][0], b)) return F;
                return -1;
            }
            function vL(d, b, F, oe) {
                return xc(d, function(ge, ve, Oe) {
                    b(oe, ge, F(ge), Oe);
                }), oe;
            }
            function Z8(d, b) {
                return d && Ks(b, ti(b), d);
            }
            function _L(d, b) {
                return d && Ks(b, Ji(b), d);
            }
            function Na(d, b, F) {
                b == "__proto__" && W0 ? W0(d, b, {
                    configurable: !0,
                    enumerable: !0,
                    value: F,
                    writable: !0
                }) : d[b] = F;
            }
            function Y1(d, b) {
                for(var F = -1, oe = b.length, ge = Ye(oe), ve = d == null; ++F < oe;)ge[F] = ve ? r : Ow(d, b[F]);
                return ge;
            }
            function $u(d, b, F) {
                return d === d && (F !== r && (d = d <= F ? d : F), b !== r && (d = d >= b ? d : b)), d;
            }
            function qo(d, b, F, oe, ge, ve) {
                var Oe, $e = b & l, He = b & p, it = b & y;
                if (F && (Oe = ge ? F(d, oe, ge, ve) : F(d)), Oe !== r) return Oe;
                if (!wn(d)) return d;
                var st = ur(d);
                if (st) {
                    if (Oe = uD(d), !$e) return Yi(d, Oe);
                } else {
                    var ft = _i(d), At = ft == Re || ft == Ce;
                    if (kc(d)) return w6(d, $e);
                    if (ft == _e || ft == ce || At && !ge) {
                        if (Oe = He || At ? {} : L6(d), !$e) return He ? JL(d, _L(Oe, d)) : XL(d, Z8(Oe, d));
                    } else {
                        if (!cn[ft]) return ge ? d : {};
                        Oe = fD(d, ft, $e);
                    }
                }
                ve || (ve = new vs());
                var Ut = ve.get(d);
                if (Ut) return Ut;
                ve.set(d, Oe), h4(d) ? d.forEach(function(Gt) {
                    Oe.add(qo(Gt, b, F, Gt, d, ve));
                }) : l4(d) && d.forEach(function(Gt, Pr) {
                    Oe.set(Pr, qo(Gt, b, F, Pr, d, ve));
                });
                var Vt = it ? He ? yw : gw : He ? Ji : ti, vr = st ? r : Vt(d);
                return zo(vr || d, function(Gt, Pr) {
                    vr && (Pr = Gt, Gt = d[Pr]), eh(Oe, Pr, qo(Gt, b, F, Pr, d, ve));
                }), Oe;
            }
            function EL(d) {
                var b = ti(d);
                return function(F) {
                    return Y8(F, d, b);
                };
            }
            function Y8(d, b, F) {
                var oe = F.length;
                if (d == null) return !oe;
                for(d = an(d); oe--;){
                    var ge = F[oe], ve = b[ge], Oe = d[ge];
                    if (Oe === r && !(ge in d) || !ve(Oe)) return !1;
                }
                return !0;
            }
            function X8(d, b, F) {
                if (typeof d != "function") throw new jo(s);
                return ah(function() {
                    d.apply(r, F);
                }, b);
            }
            function th(d, b, F, oe) {
                var ge = -1, ve = C0, Oe = !0, $e = d.length, He = [], it = b.length;
                if (!$e) return He;
                F && (b = gn(b, wo(F))), oe ? (ve = U1, Oe = !1) : b.length >= i && (ve = Gd, Oe = !1, b = new Uu(b));
                e: for(; ++ge < $e;){
                    var st = d[ge], ft = F == null ? st : F(st);
                    if (st = oe || st !== 0 ? st : 0, Oe && ft === ft) {
                        for(var At = it; At--;)if (b[At] === ft) continue e;
                        He.push(st);
                    } else ve(b, ft, oe) || He.push(st);
                }
                return He;
            }
            var xc = S6(qs), J8 = S6(J1, !0);
            function xL(d, b) {
                var F = !0;
                return xc(d, function(oe, ge, ve) {
                    return F = !!b(oe, ge, ve), F;
                }), F;
            }
            function Q0(d, b, F) {
                for(var oe = -1, ge = d.length; ++oe < ge;){
                    var ve = d[oe], Oe = b(ve);
                    if (Oe != null && ($e === r ? Oe === Oe && !_o(Oe) : F(Oe, $e))) var $e = Oe, He = ve;
                }
                return He;
            }
            function SL(d, b, F, oe) {
                var ge = d.length;
                for(F = pr(F), F < 0 && (F = -F > ge ? 0 : ge + F), oe = oe === r || oe > ge ? ge : pr(oe), oe < 0 && (oe += ge), oe = F > oe ? 0 : g4(oe); F < oe;)d[F++] = b;
                return d;
            }
            function Q8(d, b) {
                var F = [];
                return xc(d, function(oe, ge, ve) {
                    b(oe, ge, ve) && F.push(oe);
                }), F;
            }
            function ui(d, b, F, oe, ge) {
                var ve = -1, Oe = d.length;
                for(F || (F = dD), ge || (ge = []); ++ve < Oe;){
                    var $e = d[ve];
                    b > 0 && F($e) ? b > 1 ? ui($e, b - 1, F, oe, ge) : vc(ge, $e) : oe || (ge[ge.length] = $e);
                }
                return ge;
            }
            var X1 = A6(), e6 = A6(!0);
            function qs(d, b) {
                return d && X1(d, b, ti);
            }
            function J1(d, b) {
                return d && e6(d, b, ti);
            }
            function eg(d, b) {
                return wc(b, function(F) {
                    return Ua(d[F]);
                });
            }
            function Lu(d, b) {
                b = Ac(b, d);
                for(var F = 0, oe = b.length; d != null && F < oe;)d = d[Ws(b[F++])];
                return F && F == oe ? d : r;
            }
            function t6(d, b, F) {
                var oe = b(d);
                return ur(d) ? oe : vc(oe, F(d));
            }
            function Li(d) {
                return d == null ? d === r ? q : de : Ru && Ru in an(d) ? sD(d) : wD(d);
            }
            function Q1(d, b) {
                return d > b;
            }
            function AL(d, b) {
                return d != null && Qr.call(d, b);
            }
            function TL(d, b) {
                return d != null && b in an(d);
            }
            function kL(d, b, F) {
                return d >= vi(b, F) && d < Kn(b, F);
            }
            function ew(d, b, F) {
                for(var oe = F ? U1 : C0, ge = d[0].length, ve = d.length, Oe = ve, $e = Ye(ve), He = 1 / 0, it = []; Oe--;){
                    var st = d[Oe];
                    Oe && b && (st = gn(st, wo(b))), He = vi(st.length, He), $e[Oe] = !F && (b || ge >= 120 && st.length >= 120) ? new Uu(Oe && st) : r;
                }
                st = d[0];
                var ft = -1, At = $e[0];
                e: for(; ++ft < ge && it.length < He;){
                    var Ut = st[ft], Vt = b ? b(Ut) : Ut;
                    if (Ut = F || Ut !== 0 ? Ut : 0, !(At ? Gd(At, Vt) : oe(it, Vt, F))) {
                        for(Oe = ve; --Oe;){
                            var vr = $e[Oe];
                            if (!(vr ? Gd(vr, Vt) : oe(d[Oe], Vt, F))) continue e;
                        }
                        At && At.push(Vt), it.push(Ut);
                    }
                }
                return it;
            }
            function IL(d, b, F, oe) {
                return qs(d, function(ge, ve, Oe) {
                    b(oe, F(ge), ve, Oe);
                }), oe;
            }
            function rh(d, b, F) {
                b = Ac(b, d), d = j6(d, b);
                var oe = d == null ? d : d[Ws(Wo(b))];
                return oe == null ? r : bo(oe, d, F);
            }
            function r6(d) {
                return On(d) && Li(d) == ce;
            }
            function BL(d) {
                return On(d) && Li(d) == ne;
            }
            function OL(d) {
                return On(d) && Li(d) == ye;
            }
            function nh(d, b, F, oe, ge) {
                return d === b ? !0 : d == null || b == null || !On(d) && !On(b) ? d !== d && b !== b : PL(d, b, F, oe, nh, ge);
            }
            function PL(d, b, F, oe, ge, ve) {
                var Oe = ur(d), $e = ur(b), He = Oe ? he : _i(d), it = $e ? he : _i(b);
                He = He == ce ? _e : He, it = it == ce ? _e : it;
                var st = He == _e, ft = it == _e, At = He == it;
                if (At && kc(d)) {
                    if (!kc(b)) return !1;
                    Oe = !0, st = !1;
                }
                if (At && !st) return ve || (ve = new vs()), Oe || ol(d) ? C6(d, b, F, oe, ge, ve) : iD(d, b, He, F, oe, ge, ve);
                if (!(F & _)) {
                    var Ut = st && Qr.call(d, "__wrapped__"), Vt = ft && Qr.call(b, "__wrapped__");
                    if (Ut || Vt) {
                        var vr = Ut ? d.value() : d, Gt = Vt ? b.value() : b;
                        return ve || (ve = new vs()), ge(vr, Gt, F, oe, ve);
                    }
                }
                return At ? (ve || (ve = new vs()), oD(d, b, F, oe, ge, ve)) : !1;
            }
            function NL(d) {
                return On(d) && _i(d) == M;
            }
            function tw(d, b, F, oe) {
                var ge = F.length, ve = ge, Oe = !oe;
                if (d == null) return !ve;
                for(d = an(d); ge--;){
                    var $e = F[ge];
                    if (Oe && $e[2] ? $e[1] !== d[$e[0]] : !($e[0] in d)) return !1;
                }
                for(; ++ge < ve;){
                    $e = F[ge];
                    var He = $e[0], it = d[He], st = $e[1];
                    if (Oe && $e[2]) {
                        if (it === r && !(He in d)) return !1;
                    } else {
                        var ft = new vs();
                        if (oe) var At = oe(it, st, He, d, b, ft);
                        if (!(At === r ? nh(st, it, _ | A, oe, ft) : At)) return !1;
                    }
                }
                return !0;
            }
            function n6(d) {
                if (!wn(d) || pD(d)) return !1;
                var b = Ua(d) ? N$ : St;
                return b.test(Fu(d));
            }
            function ML(d) {
                return On(d) && Li(d) == Ke;
            }
            function RL(d) {
                return On(d) && _i(d) == Ue;
            }
            function CL(d) {
                return On(d) && mg(d.length) && !!dn[Li(d)];
            }
            function i6(d) {
                return typeof d == "function" ? d : d == null ? Qi : typeof d == "object" ? ur(d) ? a6(d[0], d[1]) : s6(d) : T4(d);
            }
            function rw(d) {
                if (!sh(d)) return L$(d);
                var b = [];
                for(var F in an(d))Qr.call(d, F) && F != "constructor" && b.push(F);
                return b;
            }
            function UL(d) {
                if (!wn(d)) return bD(d);
                var b = sh(d), F = [];
                for(var oe in d)oe == "constructor" && (b || !Qr.call(d, oe)) || F.push(oe);
                return F;
            }
            function nw(d, b) {
                return d < b;
            }
            function o6(d, b) {
                var F = -1, oe = Xi(d) ? Ye(d.length) : [];
                return xc(d, function(ge, ve, Oe) {
                    oe[++F] = b(ge, ve, Oe);
                }), oe;
            }
            function s6(d) {
                var b = bw(d);
                return b.length == 1 && b[0][2] ? F6(b[0][0], b[0][1]) : function(F) {
                    return F === d || tw(F, d, b);
                };
            }
            function a6(d, b) {
                return vw(d) && D6(b) ? F6(Ws(d), b) : function(F) {
                    var oe = Ow(F, d);
                    return oe === r && oe === b ? Pw(F, d) : nh(b, oe, _ | A);
                };
            }
            function tg(d, b, F, oe, ge) {
                d !== b && X1(b, function(ve, Oe) {
                    if (ge || (ge = new vs()), wn(ve)) $L(d, b, Oe, F, tg, oe, ge);
                    else {
                        var $e = oe ? oe(Ew(d, Oe), ve, Oe + "", d, b, ge) : r;
                        $e === r && ($e = ve), Z1(d, Oe, $e);
                    }
                }, Ji);
            }
            function $L(d, b, F, oe, ge, ve, Oe) {
                var $e = Ew(d, F), He = Ew(b, F), it = Oe.get(He);
                if (it) {
                    Z1(d, F, it);
                    return;
                }
                var st = ve ? ve($e, He, F + "", d, b, Oe) : r, ft = st === r;
                if (ft) {
                    var At = ur(He), Ut = !At && kc(He), Vt = !At && !Ut && ol(He);
                    st = He, At || Ut || Vt ? ur($e) ? st = $e : Rn($e) ? st = Yi($e) : Ut ? (ft = !1, st = w6(He, !0)) : Vt ? (ft = !1, st = v6(He, !0)) : st = [] : ch(He) || zu(He) ? (st = $e, zu($e) ? st = y4($e) : (!wn($e) || Ua($e)) && (st = L6(He))) : ft = !1;
                }
                ft && (Oe.set(He, st), ge(st, He, oe, ve, Oe), Oe.delete(He)), Z1(d, F, st);
            }
            function c6(d, b) {
                var F = d.length;
                if (F) return b += b < 0 ? F : 0, Ca(b, F) ? d[b] : r;
            }
            function u6(d, b, F) {
                b.length ? b = gn(b, function(ve) {
                    return ur(ve) ? function(Oe) {
                        return Lu(Oe, ve.length === 1 ? ve[0] : ve);
                    } : ve;
                }) : b = [
                    Qi
                ];
                var oe = -1;
                b = gn(b, wo(Wt()));
                var ge = o6(d, function(ve, Oe, $e) {
                    var He = gn(b, function(it) {
                        return it(ve);
                    });
                    return {
                        criteria: He,
                        index: ++oe,
                        value: ve
                    };
                });
                return f$(ge, function(ve, Oe) {
                    return YL(ve, Oe, F);
                });
            }
            function LL(d, b) {
                return f6(d, b, function(F, oe) {
                    return Pw(d, oe);
                });
            }
            function f6(d, b, F) {
                for(var oe = -1, ge = b.length, ve = {}; ++oe < ge;){
                    var Oe = b[oe], $e = Lu(d, Oe);
                    F($e, Oe) && ih(ve, Ac(Oe, d), $e);
                }
                return ve;
            }
            function DL(d) {
                return function(b) {
                    return Lu(b, d);
                };
            }
            function iw(d, b, F, oe) {
                var ge = oe ? u$ : Gf, ve = -1, Oe = b.length, $e = d;
                for(d === b && (b = Yi(b)), F && ($e = gn(d, wo(F))); ++ve < Oe;)for(var He = 0, it = b[ve], st = F ? F(it) : it; (He = ge($e, st, He, oe)) > -1;)$e !== d && K0.call($e, He, 1), K0.call(d, He, 1);
                return d;
            }
            function l6(d, b) {
                for(var F = d ? b.length : 0, oe = F - 1; F--;){
                    var ge = b[F];
                    if (F == oe || ge !== ve) {
                        var ve = ge;
                        Ca(ge) ? K0.call(d, ge, 1) : cw(d, ge);
                    }
                }
                return d;
            }
            function ow(d, b) {
                return d + G0(K8() * (b - d + 1));
            }
            function FL(d, b, F, oe) {
                for(var ge = -1, ve = Kn(V0((b - d) / (F || 1)), 0), Oe = Ye(ve); ve--;)Oe[oe ? ve : ++ge] = d, d += F;
                return Oe;
            }
            function sw(d, b) {
                var F = "";
                if (!d || b < 1 || b > I) return F;
                do b % 2 && (F += d), b = G0(b / 2), b && (d += d);
                while (b)
                return F;
            }
            function Tr(d, b) {
                return xw(z6(d, b, Qi), d + "");
            }
            function zL(d) {
                return G8(sl(d));
            }
            function jL(d, b) {
                var F = sl(d);
                return lg(F, $u(b, 0, F.length));
            }
            function ih(d, b, F, oe) {
                if (!wn(d)) return d;
                b = Ac(b, d);
                for(var ge = -1, ve = b.length, Oe = ve - 1, $e = d; $e != null && ++ge < ve;){
                    var He = Ws(b[ge]), it = F;
                    if (He === "__proto__" || He === "constructor" || He === "prototype") return d;
                    if (ge != Oe) {
                        var st = $e[He];
                        it = oe ? oe(st, He, $e) : r, it === r && (it = wn(st) ? st : Ca(b[ge + 1]) ? [] : {});
                    }
                    eh($e, He, it), $e = $e[He];
                }
                return d;
            }
            var d6 = Z0 ? function(d, b) {
                return Z0.set(d, b), d;
            } : Qi, HL = W0 ? function(d, b) {
                return W0(d, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: Mw(b),
                    writable: !0
                });
            } : Qi;
            function qL(d) {
                return lg(sl(d));
            }
            function Ko(d, b, F) {
                var oe = -1, ge = d.length;
                b < 0 && (b = -b > ge ? 0 : ge + b), F = F > ge ? ge : F, F < 0 && (F += ge), ge = b > F ? 0 : F - b >>> 0, b >>>= 0;
                for(var ve = Ye(ge); ++oe < ge;)ve[oe] = d[oe + b];
                return ve;
            }
            function KL(d, b) {
                var F;
                return xc(d, function(oe, ge, ve) {
                    return F = b(oe, ge, ve), !F;
                }), !!F;
            }
            function rg(d, b, F) {
                var oe = 0, ge = d == null ? oe : d.length;
                if (typeof b == "number" && b === b && ge <= ie) {
                    for(; oe < ge;){
                        var ve = oe + ge >>> 1, Oe = d[ve];
                        Oe !== null && !_o(Oe) && (F ? Oe <= b : Oe < b) ? oe = ve + 1 : ge = ve;
                    }
                    return ge;
                }
                return aw(d, b, Qi, F);
            }
            function aw(d, b, F, oe) {
                var ge = 0, ve = d == null ? 0 : d.length;
                if (ve === 0) return 0;
                b = F(b);
                for(var Oe = b !== b, $e = b === null, He = _o(b), it = b === r; ge < ve;){
                    var st = G0((ge + ve) / 2), ft = F(d[st]), At = ft !== r, Ut = ft === null, Vt = ft === ft, vr = _o(ft);
                    if (Oe) var Gt = oe || Vt;
                    else it ? Gt = Vt && (oe || At) : $e ? Gt = Vt && At && (oe || !Ut) : He ? Gt = Vt && At && !Ut && (oe || !vr) : Ut || vr ? Gt = !1 : Gt = oe ? ft <= b : ft < b;
                    Gt ? ge = st + 1 : ve = st;
                }
                return vi(ve, j);
            }
            function h6(d, b) {
                for(var F = -1, oe = d.length, ge = 0, ve = []; ++F < oe;){
                    var Oe = d[F], $e = b ? b(Oe) : Oe;
                    if (!F || !_s($e, He)) {
                        var He = $e;
                        ve[ge++] = Oe === 0 ? 0 : Oe;
                    }
                }
                return ve;
            }
            function p6(d) {
                return typeof d == "number" ? d : _o(d) ? k : +d;
            }
            function vo(d) {
                if (typeof d == "string") return d;
                if (ur(d)) return gn(d, vo) + "";
                if (_o(d)) return W8 ? W8.call(d) : "";
                var b = d + "";
                return b == "0" && 1 / d == -T ? "-0" : b;
            }
            function Sc(d, b, F) {
                var oe = -1, ge = C0, ve = d.length, Oe = !0, $e = [], He = $e;
                if (F) Oe = !1, ge = U1;
                else if (ve >= i) {
                    var it = b ? null : rD(d);
                    if (it) return $0(it);
                    Oe = !1, ge = Gd, He = new Uu();
                } else He = b ? [] : $e;
                e: for(; ++oe < ve;){
                    var st = d[oe], ft = b ? b(st) : st;
                    if (st = F || st !== 0 ? st : 0, Oe && ft === ft) {
                        for(var At = He.length; At--;)if (He[At] === ft) continue e;
                        b && He.push(ft), $e.push(st);
                    } else ge(He, ft, F) || (He !== $e && He.push(ft), $e.push(st));
                }
                return $e;
            }
            function cw(d, b) {
                return b = Ac(b, d), d = j6(d, b), d == null || delete d[Ws(Wo(b))];
            }
            function g6(d, b, F, oe) {
                return ih(d, b, F(Lu(d, b)), oe);
            }
            function ng(d, b, F, oe) {
                for(var ge = d.length, ve = oe ? ge : -1; (oe ? ve-- : ++ve < ge) && b(d[ve], ve, d););
                return F ? Ko(d, oe ? 0 : ve, oe ? ve + 1 : ge) : Ko(d, oe ? ve + 1 : 0, oe ? ge : ve);
            }
            function y6(d, b) {
                var F = d;
                return F instanceof Rr && (F = F.value()), $1(b, function(oe, ge) {
                    return ge.func.apply(ge.thisArg, vc([
                        oe
                    ], ge.args));
                }, F);
            }
            function uw(d, b, F) {
                var oe = d.length;
                if (oe < 2) return oe ? Sc(d[0]) : [];
                for(var ge = -1, ve = Ye(oe); ++ge < oe;)for(var Oe = d[ge], $e = -1; ++$e < oe;)$e != ge && (ve[ge] = th(ve[ge] || Oe, d[$e], b, F));
                return Sc(ui(ve, 1), b, F);
            }
            function m6(d, b, F) {
                for(var oe = -1, ge = d.length, ve = b.length, Oe = {}; ++oe < ge;){
                    var $e = oe < ve ? b[oe] : r;
                    F(Oe, d[oe], $e);
                }
                return Oe;
            }
            function fw(d) {
                return Rn(d) ? d : [];
            }
            function lw(d) {
                return typeof d == "function" ? d : Qi;
            }
            function Ac(d, b) {
                return ur(d) ? d : vw(d, b) ? [
                    d
                ] : W6(Yr(d));
            }
            var WL = Tr;
            function Tc(d, b, F) {
                var oe = d.length;
                return F = F === r ? oe : F, !b && F >= oe ? d : Ko(d, b, F);
            }
            var b6 = M$ || function(d) {
                return ci.clearTimeout(d);
            };
            function w6(d, b) {
                if (b) return d.slice();
                var F = d.length, oe = F8 ? F8(F) : new d.constructor(F);
                return d.copy(oe), oe;
            }
            function dw(d) {
                var b = new d.constructor(d.byteLength);
                return new H0(b).set(new H0(d)), b;
            }
            function VL(d, b) {
                var F = b ? dw(d.buffer) : d.buffer;
                return new d.constructor(F, d.byteOffset, d.byteLength);
            }
            function GL(d) {
                var b = new d.constructor(d.source, Ct.exec(d));
                return b.lastIndex = d.lastIndex, b;
            }
            function ZL(d) {
                return Qd ? an(Qd.call(d)) : {};
            }
            function v6(d, b) {
                var F = b ? dw(d.buffer) : d.buffer;
                return new d.constructor(F, d.byteOffset, d.length);
            }
            function _6(d, b) {
                if (d !== b) {
                    var F = d !== r, oe = d === null, ge = d === d, ve = _o(d), Oe = b !== r, $e = b === null, He = b === b, it = _o(b);
                    if (!$e && !it && !ve && d > b || ve && Oe && He && !$e && !it || oe && Oe && He || !F && He || !ge) return 1;
                    if (!oe && !ve && !it && d < b || it && F && ge && !oe && !ve || $e && F && ge || !Oe && ge || !He) return -1;
                }
                return 0;
            }
            function YL(d, b, F) {
                for(var oe = -1, ge = d.criteria, ve = b.criteria, Oe = ge.length, $e = F.length; ++oe < Oe;){
                    var He = _6(ge[oe], ve[oe]);
                    if (He) {
                        if (oe >= $e) return He;
                        var it = F[oe];
                        return He * (it == "desc" ? -1 : 1);
                    }
                }
                return d.index - b.index;
            }
            function E6(d, b, F, oe) {
                for(var ge = -1, ve = d.length, Oe = F.length, $e = -1, He = b.length, it = Kn(ve - Oe, 0), st = Ye(He + it), ft = !oe; ++$e < He;)st[$e] = b[$e];
                for(; ++ge < Oe;)(ft || ge < ve) && (st[F[ge]] = d[ge]);
                for(; it--;)st[$e++] = d[ge++];
                return st;
            }
            function x6(d, b, F, oe) {
                for(var ge = -1, ve = d.length, Oe = -1, $e = F.length, He = -1, it = b.length, st = Kn(ve - $e, 0), ft = Ye(st + it), At = !oe; ++ge < st;)ft[ge] = d[ge];
                for(var Ut = ge; ++He < it;)ft[Ut + He] = b[He];
                for(; ++Oe < $e;)(At || ge < ve) && (ft[Ut + F[Oe]] = d[ge++]);
                return ft;
            }
            function Yi(d, b) {
                var F = -1, oe = d.length;
                for(b || (b = Ye(oe)); ++F < oe;)b[F] = d[F];
                return b;
            }
            function Ks(d, b, F, oe) {
                var ge = !F;
                F || (F = {});
                for(var ve = -1, Oe = b.length; ++ve < Oe;){
                    var $e = b[ve], He = oe ? oe(F[$e], d[$e], $e, F, d) : r;
                    He === r && (He = d[$e]), ge ? Na(F, $e, He) : eh(F, $e, He);
                }
                return F;
            }
            function XL(d, b) {
                return Ks(d, ww(d), b);
            }
            function JL(d, b) {
                return Ks(d, U6(d), b);
            }
            function ig(d, b) {
                return function(F, oe) {
                    var ge = ur(F) ? n$ : vL, ve = b ? b() : {};
                    return ge(F, d, Wt(oe, 2), ve);
                };
            }
            function rl(d) {
                return Tr(function(b, F) {
                    var oe = -1, ge = F.length, ve = ge > 1 ? F[ge - 1] : r, Oe = ge > 2 ? F[2] : r;
                    for(ve = d.length > 3 && typeof ve == "function" ? (ge--, ve) : r, Oe && Di(F[0], F[1], Oe) && (ve = ge < 3 ? r : ve, ge = 1), b = an(b); ++oe < ge;){
                        var $e = F[oe];
                        $e && d(b, $e, oe, ve);
                    }
                    return b;
                });
            }
            function S6(d, b) {
                return function(F, oe) {
                    if (F == null) return F;
                    if (!Xi(F)) return d(F, oe);
                    for(var ge = F.length, ve = b ? ge : -1, Oe = an(F); (b ? ve-- : ++ve < ge) && oe(Oe[ve], ve, Oe) !== !1;);
                    return F;
                };
            }
            function A6(d) {
                return function(b, F, oe) {
                    for(var ge = -1, ve = an(b), Oe = oe(b), $e = Oe.length; $e--;){
                        var He = Oe[d ? $e : ++ge];
                        if (F(ve[He], He, ve) === !1) break;
                    }
                    return b;
                };
            }
            function QL(d, b, F) {
                var oe = b & O, ge = oh(d);
                function ve() {
                    var Oe = this && this !== ci && this instanceof ve ? ge : d;
                    return Oe.apply(oe ? F : this, arguments);
                }
                return ve;
            }
            function T6(d) {
                return function(b) {
                    b = Yr(b);
                    var F = Zf(b) ? ws(b) : r, oe = F ? F[0] : b.charAt(0), ge = F ? Tc(F, 1).join("") : b.slice(1);
                    return oe[d]() + ge;
                };
            }
            function nl(d) {
                return function(b) {
                    return $1(S4(x4(b).replace(HU, "")), d, "");
                };
            }
            function oh(d) {
                return function() {
                    var b = arguments;
                    switch(b.length){
                        case 0:
                            return new d();
                        case 1:
                            return new d(b[0]);
                        case 2:
                            return new d(b[0], b[1]);
                        case 3:
                            return new d(b[0], b[1], b[2]);
                        case 4:
                            return new d(b[0], b[1], b[2], b[3]);
                        case 5:
                            return new d(b[0], b[1], b[2], b[3], b[4]);
                        case 6:
                            return new d(b[0], b[1], b[2], b[3], b[4], b[5]);
                        case 7:
                            return new d(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);
                    }
                    var F = tl(d.prototype), oe = d.apply(F, b);
                    return wn(oe) ? oe : F;
                };
            }
            function eD(d, b, F) {
                var oe = oh(d);
                function ge() {
                    for(var ve = arguments.length, Oe = Ye(ve), $e = ve, He = il(ge); $e--;)Oe[$e] = arguments[$e];
                    var it = ve < 3 && Oe[0] !== He && Oe[ve - 1] !== He ? [] : _c(Oe, He);
                    if (ve -= it.length, ve < F) return P6(d, b, og, ge.placeholder, r, Oe, it, r, r, F - ve);
                    var st = this && this !== ci && this instanceof ge ? oe : d;
                    return bo(st, this, Oe);
                }
                return ge;
            }
            function k6(d) {
                return function(b, F, oe) {
                    var ge = an(b);
                    if (!Xi(b)) {
                        var ve = Wt(F, 3);
                        b = ti(b), F = function($e) {
                            return ve(ge[$e], $e, ge);
                        };
                    }
                    var Oe = d(b, F, oe);
                    return Oe > -1 ? ge[ve ? b[Oe] : Oe] : r;
                };
            }
            function I6(d) {
                return Ra(function(b) {
                    var F = b.length, oe = F, ge = Ho.prototype.thru;
                    for(d && b.reverse(); oe--;){
                        var ve = b[oe];
                        if (typeof ve != "function") throw new jo(s);
                        if (ge && !Oe && ug(ve) == "wrapper") var Oe = new Ho([], !0);
                    }
                    for(oe = Oe ? oe : F; ++oe < F;){
                        ve = b[oe];
                        var $e = ug(ve), He = $e == "wrapper" ? mw(ve) : r;
                        He && _w(He[0]) && He[1] == (Q | D | K | G) && !He[4].length && He[9] == 1 ? Oe = Oe[ug(He[0])].apply(Oe, He[3]) : Oe = ve.length == 1 && _w(ve) ? Oe[$e]() : Oe.thru(ve);
                    }
                    return function() {
                        var it = arguments, st = it[0];
                        if (Oe && it.length == 1 && ur(st)) return Oe.plant(st).value();
                        for(var ft = 0, At = F ? b[ft].apply(this, it) : st; ++ft < F;)At = b[ft].call(this, At);
                        return At;
                    };
                });
            }
            function og(d, b, F, oe, ge, ve, Oe, $e, He, it) {
                var st = b & Q, ft = b & O, At = b & N, Ut = b & (D | H), Vt = b & R, vr = At ? r : oh(d);
                function Gt() {
                    for(var Pr = arguments.length, Lr = Ye(Pr), Eo = Pr; Eo--;)Lr[Eo] = arguments[Eo];
                    if (Ut) var Fi = il(Gt), xo = d$(Lr, Fi);
                    if (oe && (Lr = E6(Lr, oe, ge, Ut)), ve && (Lr = x6(Lr, ve, Oe, Ut)), Pr -= xo, Ut && Pr < it) {
                        var Cn = _c(Lr, Fi);
                        return P6(d, b, og, Gt.placeholder, F, Lr, Cn, $e, He, it - Pr);
                    }
                    var Es = ft ? F : this, La = At ? Es[d] : d;
                    return Pr = Lr.length, $e ? Lr = vD(Lr, $e) : Vt && Pr > 1 && Lr.reverse(), st && He < Pr && (Lr.length = He), this && this !== ci && this instanceof Gt && (La = vr || oh(La)), La.apply(Es, Lr);
                }
                return Gt;
            }
            function B6(d, b) {
                return function(F, oe) {
                    return IL(F, d, b(oe), {});
                };
            }
            function sg(d, b) {
                return function(F, oe) {
                    var ge;
                    if (F === r && oe === r) return b;
                    if (F !== r && (ge = F), oe !== r) {
                        if (ge === r) return oe;
                        typeof F == "string" || typeof oe == "string" ? (F = vo(F), oe = vo(oe)) : (F = p6(F), oe = p6(oe)), ge = d(F, oe);
                    }
                    return ge;
                };
            }
            function hw(d) {
                return Ra(function(b) {
                    return b = gn(b, wo(Wt())), Tr(function(F) {
                        var oe = this;
                        return d(b, function(ge) {
                            return bo(ge, oe, F);
                        });
                    });
                });
            }
            function ag(d, b) {
                b = b === r ? " " : vo(b);
                var F = b.length;
                if (F < 2) return F ? sw(b, d) : b;
                var oe = sw(b, V0(d / Yf(b)));
                return Zf(b) ? Tc(ws(oe), 0, d).join("") : oe.slice(0, d);
            }
            function tD(d, b, F, oe) {
                var ge = b & O, ve = oh(d);
                function Oe() {
                    for(var $e = -1, He = arguments.length, it = -1, st = oe.length, ft = Ye(st + He), At = this && this !== ci && this instanceof Oe ? ve : d; ++it < st;)ft[it] = oe[it];
                    for(; He--;)ft[it++] = arguments[++$e];
                    return bo(At, ge ? F : this, ft);
                }
                return Oe;
            }
            function O6(d) {
                return function(b, F, oe) {
                    return oe && typeof oe != "number" && Di(b, F, oe) && (F = oe = r), b = $a(b), F === r ? (F = b, b = 0) : F = $a(F), oe = oe === r ? b < F ? 1 : -1 : $a(oe), FL(b, F, oe, d);
                };
            }
            function cg(d) {
                return function(b, F) {
                    return typeof b == "string" && typeof F == "string" || (b = Vo(b), F = Vo(F)), d(b, F);
                };
            }
            function P6(d, b, F, oe, ge, ve, Oe, $e, He, it) {
                var st = b & D, ft = st ? Oe : r, At = st ? r : Oe, Ut = st ? ve : r, Vt = st ? r : ve;
                b |= st ? K : re, b &= ~(st ? re : K), b & U || (b &= -4);
                var vr = [
                    d,
                    b,
                    ge,
                    Ut,
                    ft,
                    Vt,
                    At,
                    $e,
                    He,
                    it
                ], Gt = F.apply(r, vr);
                return _w(d) && H6(Gt, vr), Gt.placeholder = oe, q6(Gt, d, b);
            }
            function pw(d) {
                var b = qn[d];
                return function(F, oe) {
                    if (F = Vo(F), oe = oe == null ? 0 : vi(pr(oe), 292), oe && q8(F)) {
                        var ge = (Yr(F) + "e").split("e"), ve = b(ge[0] + "e" + (+ge[1] + oe));
                        return ge = (Yr(ve) + "e").split("e"), +(ge[0] + "e" + (+ge[1] - oe));
                    }
                    return b(F);
                };
            }
            var rD = Qf && 1 / $0(new Qf([
                ,
                -0
            ]))[1] == T ? function(d) {
                return new Qf(d);
            } : Uw;
            function N6(d) {
                return function(b) {
                    var F = _i(b);
                    return F == M ? q1(b) : F == Ue ? w$(b) : l$(b, d(b));
                };
            }
            function Ma(d, b, F, oe, ge, ve, Oe, $e) {
                var He = b & N;
                if (!He && typeof d != "function") throw new jo(s);
                var it = oe ? oe.length : 0;
                if (it || (b &= -97, oe = ge = r), Oe = Oe === r ? Oe : Kn(pr(Oe), 0), $e = $e === r ? $e : pr($e), it -= ge ? ge.length : 0, b & re) {
                    var st = oe, ft = ge;
                    oe = ge = r;
                }
                var At = He ? r : mw(d), Ut = [
                    d,
                    b,
                    F,
                    oe,
                    ge,
                    st,
                    ft,
                    ve,
                    Oe,
                    $e
                ];
                if (At && mD(Ut, At), d = Ut[0], b = Ut[1], F = Ut[2], oe = Ut[3], ge = Ut[4], $e = Ut[9] = Ut[9] === r ? He ? 0 : d.length : Kn(Ut[9] - it, 0), !$e && b & (D | H) && (b &= -25), !b || b == O) var Vt = QL(d, b, F);
                else b == D || b == H ? Vt = eD(d, b, $e) : (b == K || b == (O | K)) && !ge.length ? Vt = tD(d, b, F, oe) : Vt = og.apply(r, Ut);
                var vr = At ? d6 : H6;
                return q6(vr(Vt, Ut), d, b);
            }
            function M6(d, b, F, oe) {
                return d === r || _s(d, Jf[F]) && !Qr.call(oe, F) ? b : d;
            }
            function R6(d, b, F, oe, ge, ve) {
                return wn(d) && wn(b) && (ve.set(b, d), tg(d, b, r, R6, ve), ve.delete(b)), d;
            }
            function nD(d) {
                return ch(d) ? r : d;
            }
            function C6(d, b, F, oe, ge, ve) {
                var Oe = F & _, $e = d.length, He = b.length;
                if ($e != He && !(Oe && He > $e)) return !1;
                var it = ve.get(d), st = ve.get(b);
                if (it && st) return it == b && st == d;
                var ft = -1, At = !0, Ut = F & A ? new Uu() : r;
                for(ve.set(d, b), ve.set(b, d); ++ft < $e;){
                    var Vt = d[ft], vr = b[ft];
                    if (oe) var Gt = Oe ? oe(vr, Vt, ft, b, d, ve) : oe(Vt, vr, ft, d, b, ve);
                    if (Gt !== r) {
                        if (Gt) continue;
                        At = !1;
                        break;
                    }
                    if (Ut) {
                        if (!L1(b, function(Pr, Lr) {
                            if (!Gd(Ut, Lr) && (Vt === Pr || ge(Vt, Pr, F, oe, ve))) return Ut.push(Lr);
                        })) {
                            At = !1;
                            break;
                        }
                    } else if (!(Vt === vr || ge(Vt, vr, F, oe, ve))) {
                        At = !1;
                        break;
                    }
                }
                return ve.delete(d), ve.delete(b), At;
            }
            function iD(d, b, F, oe, ge, ve, Oe) {
                switch(F){
                    case W:
                        if (d.byteLength != b.byteLength || d.byteOffset != b.byteOffset) return !1;
                        d = d.buffer, b = b.buffer;
                    case ne:
                        return !(d.byteLength != b.byteLength || !ve(new H0(d), new H0(b)));
                    case ae:
                    case ye:
                    case z:
                        return _s(+d, +b);
                    case De:
                        return d.name == b.name && d.message == b.message;
                    case Ke:
                    case h:
                        return d == b + "";
                    case M:
                        var $e = q1;
                    case Ue:
                        var He = oe & _;
                        if ($e || ($e = $0), d.size != b.size && !He) return !1;
                        var it = Oe.get(d);
                        if (it) return it == b;
                        oe |= A, Oe.set(d, b);
                        var st = C6($e(d), $e(b), oe, ge, ve, Oe);
                        return Oe.delete(d), st;
                    case x:
                        if (Qd) return Qd.call(d) == Qd.call(b);
                }
                return !1;
            }
            function oD(d, b, F, oe, ge, ve) {
                var Oe = F & _, $e = gw(d), He = $e.length, it = gw(b), st = it.length;
                if (He != st && !Oe) return !1;
                for(var ft = He; ft--;){
                    var At = $e[ft];
                    if (!(Oe ? At in b : Qr.call(b, At))) return !1;
                }
                var Ut = ve.get(d), Vt = ve.get(b);
                if (Ut && Vt) return Ut == b && Vt == d;
                var vr = !0;
                ve.set(d, b), ve.set(b, d);
                for(var Gt = Oe; ++ft < He;){
                    At = $e[ft];
                    var Pr = d[At], Lr = b[At];
                    if (oe) var Eo = Oe ? oe(Lr, Pr, At, b, d, ve) : oe(Pr, Lr, At, d, b, ve);
                    if (!(Eo === r ? Pr === Lr || ge(Pr, Lr, F, oe, ve) : Eo)) {
                        vr = !1;
                        break;
                    }
                    Gt || (Gt = At == "constructor");
                }
                if (vr && !Gt) {
                    var Fi = d.constructor, xo = b.constructor;
                    Fi != xo && "constructor" in d && "constructor" in b && !(typeof Fi == "function" && Fi instanceof Fi && typeof xo == "function" && xo instanceof xo) && (vr = !1);
                }
                return ve.delete(d), ve.delete(b), vr;
            }
            function Ra(d) {
                return xw(z6(d, r, Y6), d + "");
            }
            function gw(d) {
                return t6(d, ti, ww);
            }
            function yw(d) {
                return t6(d, Ji, U6);
            }
            var mw = Z0 ? function(d) {
                return Z0.get(d);
            } : Uw;
            function ug(d) {
                for(var b = d.name + "", F = el[b], oe = Qr.call(el, b) ? F.length : 0; oe--;){
                    var ge = F[oe], ve = ge.func;
                    if (ve == null || ve == d) return ge.name;
                }
                return b;
            }
            function il(d) {
                var b = Qr.call(me, "placeholder") ? me : d;
                return b.placeholder;
            }
            function Wt() {
                var d = me.iteratee || Rw;
                return d = d === Rw ? i6 : d, arguments.length ? d(arguments[0], arguments[1]) : d;
            }
            function fg(d, b) {
                var F = d.__data__;
                return hD(b) ? F[typeof b == "string" ? "string" : "hash"] : F.map;
            }
            function bw(d) {
                for(var b = ti(d), F = b.length; F--;){
                    var oe = b[F], ge = d[oe];
                    b[F] = [
                        oe,
                        ge,
                        D6(ge)
                    ];
                }
                return b;
            }
            function Du(d, b) {
                var F = y$(d, b);
                return n6(F) ? F : r;
            }
            function sD(d) {
                var b = Qr.call(d, Ru), F = d[Ru];
                try {
                    d[Ru] = r;
                    var oe = !0;
                } catch  {}
                var ge = z0.call(d);
                return oe && (b ? d[Ru] = F : delete d[Ru]), ge;
            }
            var ww = W1 ? function(d) {
                return d == null ? [] : (d = an(d), wc(W1(d), function(b) {
                    return j8.call(d, b);
                }));
            } : $w, U6 = W1 ? function(d) {
                for(var b = []; d;)vc(b, ww(d)), d = q0(d);
                return b;
            } : $w, _i = Li;
            (V1 && _i(new V1(new ArrayBuffer(1))) != W || Yd && _i(new Yd()) != M || G1 && _i(G1.resolve()) != Ie || Qf && _i(new Qf()) != Ue || Xd && _i(new Xd()) != te) && (_i = function(d) {
                var b = Li(d), F = b == _e ? d.constructor : r, oe = F ? Fu(F) : "";
                if (oe) switch(oe){
                    case j$:
                        return W;
                    case H$:
                        return M;
                    case q$:
                        return Ie;
                    case K$:
                        return Ue;
                    case W$:
                        return te;
                }
                return b;
            });
            function aD(d, b, F) {
                for(var oe = -1, ge = F.length; ++oe < ge;){
                    var ve = F[oe], Oe = ve.size;
                    switch(ve.type){
                        case "drop":
                            d += Oe;
                            break;
                        case "dropRight":
                            b -= Oe;
                            break;
                        case "take":
                            b = vi(b, d + Oe);
                            break;
                        case "takeRight":
                            d = Kn(d, b - Oe);
                            break;
                    }
                }
                return {
                    start: d,
                    end: b
                };
            }
            function cD(d) {
                var b = d.match(ct);
                return b ? b[1].split(lt) : [];
            }
            function $6(d, b, F) {
                b = Ac(b, d);
                for(var oe = -1, ge = b.length, ve = !1; ++oe < ge;){
                    var Oe = Ws(b[oe]);
                    if (!(ve = d != null && F(d, Oe))) break;
                    d = d[Oe];
                }
                return ve || ++oe != ge ? ve : (ge = d == null ? 0 : d.length, !!ge && mg(ge) && Ca(Oe, ge) && (ur(d) || zu(d)));
            }
            function uD(d) {
                var b = d.length, F = new d.constructor(b);
                return b && typeof d[0] == "string" && Qr.call(d, "index") && (F.index = d.index, F.input = d.input), F;
            }
            function L6(d) {
                return typeof d.constructor == "function" && !sh(d) ? tl(q0(d)) : {};
            }
            function fD(d, b, F) {
                var oe = d.constructor;
                switch(b){
                    case ne:
                        return dw(d);
                    case ae:
                    case ye:
                        return new oe(+d);
                    case W:
                        return VL(d, F);
                    case J:
                    case V:
                    case C:
                    case Z:
                    case le:
                    case se:
                    case Ne:
                    case Le:
                    case rt:
                        return v6(d, F);
                    case M:
                        return new oe();
                    case z:
                    case h:
                        return new oe(d);
                    case Ke:
                        return GL(d);
                    case Ue:
                        return new oe();
                    case x:
                        return ZL(d);
                }
            }
            function lD(d, b) {
                var F = b.length;
                if (!F) return d;
                var oe = F - 1;
                return b[oe] = (F > 1 ? "& " : "") + b[oe], b = b.join(F > 2 ? ", " : " "), d.replace(at, `{
/* [wrapped with ` + b + `] */
`);
            }
            function dD(d) {
                return ur(d) || zu(d) || !!(H8 && d && d[H8]);
            }
            function Ca(d, b) {
                var F = typeof d;
                return b = b ?? I, !!b && (F == "number" || F != "symbol" && et.test(d)) && d > -1 && d % 1 == 0 && d < b;
            }
            function Di(d, b, F) {
                if (!wn(F)) return !1;
                var oe = typeof b;
                return (oe == "number" ? Xi(F) && Ca(b, F.length) : oe == "string" && b in F) ? _s(F[b], d) : !1;
            }
            function vw(d, b) {
                if (ur(d)) return !1;
                var F = typeof d;
                return F == "number" || F == "symbol" || F == "boolean" || d == null || _o(d) ? !0 : Ae.test(d) || !zt.test(d) || b != null && d in an(b);
            }
            function hD(d) {
                var b = typeof d;
                return b == "string" || b == "number" || b == "symbol" || b == "boolean" ? d !== "__proto__" : d === null;
            }
            function _w(d) {
                var b = ug(d), F = me[b];
                if (typeof F != "function" || !(b in Rr.prototype)) return !1;
                if (d === F) return !0;
                var oe = mw(F);
                return !!oe && d === oe[0];
            }
            function pD(d) {
                return !!D8 && D8 in d;
            }
            var gD = D0 ? Ua : Lw;
            function sh(d) {
                var b = d && d.constructor, F = typeof b == "function" && b.prototype || Jf;
                return d === F;
            }
            function D6(d) {
                return d === d && !wn(d);
            }
            function F6(d, b) {
                return function(F) {
                    return F == null ? !1 : F[d] === b && (b !== r || d in an(F));
                };
            }
            function yD(d) {
                var b = gg(d, function(oe) {
                    return F.size === f && F.clear(), oe;
                }), F = b.cache;
                return b;
            }
            function mD(d, b) {
                var F = d[1], oe = b[1], ge = F | oe, ve = ge < (O | N | Q), Oe = oe == Q && F == D || oe == Q && F == G && d[7].length <= b[8] || oe == (Q | G) && b[7].length <= b[8] && F == D;
                if (!(ve || Oe)) return d;
                oe & O && (d[2] = b[2], ge |= F & O ? 0 : U);
                var $e = b[3];
                if ($e) {
                    var He = d[3];
                    d[3] = He ? E6(He, $e, b[4]) : $e, d[4] = He ? _c(d[3], c) : b[4];
                }
                return $e = b[5], $e && (He = d[5], d[5] = He ? x6(He, $e, b[6]) : $e, d[6] = He ? _c(d[5], c) : b[6]), $e = b[7], $e && (d[7] = $e), oe & Q && (d[8] = d[8] == null ? b[8] : vi(d[8], b[8])), d[9] == null && (d[9] = b[9]), d[0] = b[0], d[1] = ge, d;
            }
            function bD(d) {
                var b = [];
                if (d != null) for(var F in an(d))b.push(F);
                return b;
            }
            function wD(d) {
                return z0.call(d);
            }
            function z6(d, b, F) {
                return b = Kn(b === r ? d.length - 1 : b, 0), function() {
                    for(var oe = arguments, ge = -1, ve = Kn(oe.length - b, 0), Oe = Ye(ve); ++ge < ve;)Oe[ge] = oe[b + ge];
                    ge = -1;
                    for(var $e = Ye(b + 1); ++ge < b;)$e[ge] = oe[ge];
                    return $e[b] = F(Oe), bo(d, this, $e);
                };
            }
            function j6(d, b) {
                return b.length < 2 ? d : Lu(d, Ko(b, 0, -1));
            }
            function vD(d, b) {
                for(var F = d.length, oe = vi(b.length, F), ge = Yi(d); oe--;){
                    var ve = b[oe];
                    d[oe] = Ca(ve, F) ? ge[ve] : r;
                }
                return d;
            }
            function Ew(d, b) {
                if (!(b === "constructor" && typeof d[b] == "function") && b != "__proto__") return d[b];
            }
            var H6 = K6(d6), ah = C$ || function(d, b) {
                return ci.setTimeout(d, b);
            }, xw = K6(HL);
            function q6(d, b, F) {
                var oe = b + "";
                return xw(d, lD(oe, _D(cD(oe), F)));
            }
            function K6(d) {
                var b = 0, F = 0;
                return function() {
                    var oe = D$(), ge = w - (oe - F);
                    if (F = oe, ge > 0) {
                        if (++b >= S) return arguments[0];
                    } else b = 0;
                    return d.apply(r, arguments);
                };
            }
            function lg(d, b) {
                var F = -1, oe = d.length, ge = oe - 1;
                for(b = b === r ? oe : b; ++F < b;){
                    var ve = ow(F, ge), Oe = d[ve];
                    d[ve] = d[F], d[F] = Oe;
                }
                return d.length = b, d;
            }
            var W6 = yD(function(d) {
                var b = [];
                return d.charCodeAt(0) === 46 && b.push(""), d.replace(we, function(F, oe, ge, ve) {
                    b.push(ge ? ve.replace(bt, "$1") : oe || F);
                }), b;
            });
            function Ws(d) {
                if (typeof d == "string" || _o(d)) return d;
                var b = d + "";
                return b == "0" && 1 / d == -T ? "-0" : b;
            }
            function Fu(d) {
                if (d != null) {
                    try {
                        return F0.call(d);
                    } catch  {}
                    try {
                        return d + "";
                    } catch  {}
                }
                return "";
            }
            function _D(d, b) {
                return zo(ue, function(F) {
                    var oe = "_." + F[0];
                    b & F[1] && !C0(d, oe) && d.push(oe);
                }), d.sort();
            }
            function V6(d) {
                if (d instanceof Rr) return d.clone();
                var b = new Ho(d.__wrapped__, d.__chain__);
                return b.__actions__ = Yi(d.__actions__), b.__index__ = d.__index__, b.__values__ = d.__values__, b;
            }
            function ED(d, b, F) {
                (F ? Di(d, b, F) : b === r) ? b = 1 : b = Kn(pr(b), 0);
                var oe = d == null ? 0 : d.length;
                if (!oe || b < 1) return [];
                for(var ge = 0, ve = 0, Oe = Ye(V0(oe / b)); ge < oe;)Oe[ve++] = Ko(d, ge, ge += b);
                return Oe;
            }
            function xD(d) {
                for(var b = -1, F = d == null ? 0 : d.length, oe = 0, ge = []; ++b < F;){
                    var ve = d[b];
                    ve && (ge[oe++] = ve);
                }
                return ge;
            }
            function SD() {
                var d = arguments.length;
                if (!d) return [];
                for(var b = Ye(d - 1), F = arguments[0], oe = d; oe--;)b[oe - 1] = arguments[oe];
                return vc(ur(F) ? Yi(F) : [
                    F
                ], ui(b, 1));
            }
            var AD = Tr(function(d, b) {
                return Rn(d) ? th(d, ui(b, 1, Rn, !0)) : [];
            }), TD = Tr(function(d, b) {
                var F = Wo(b);
                return Rn(F) && (F = r), Rn(d) ? th(d, ui(b, 1, Rn, !0), Wt(F, 2)) : [];
            }), kD = Tr(function(d, b) {
                var F = Wo(b);
                return Rn(F) && (F = r), Rn(d) ? th(d, ui(b, 1, Rn, !0), r, F) : [];
            });
            function ID(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (b = F || b === r ? 1 : pr(b), Ko(d, b < 0 ? 0 : b, oe)) : [];
            }
            function BD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (b = F || b === r ? 1 : pr(b), b = oe - b, Ko(d, 0, b < 0 ? 0 : b)) : [];
            }
            function OD(d, b) {
                return d && d.length ? ng(d, Wt(b, 3), !0, !0) : [];
            }
            function PD(d, b) {
                return d && d.length ? ng(d, Wt(b, 3), !0) : [];
            }
            function ND(d, b, F, oe) {
                var ge = d == null ? 0 : d.length;
                return ge ? (F && typeof F != "number" && Di(d, b, F) && (F = 0, oe = ge), SL(d, b, F, oe)) : [];
            }
            function G6(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = F == null ? 0 : pr(F);
                return ge < 0 && (ge = Kn(oe + ge, 0)), U0(d, Wt(b, 3), ge);
            }
            function Z6(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = oe - 1;
                return F !== r && (ge = pr(F), ge = F < 0 ? Kn(oe + ge, 0) : vi(ge, oe - 1)), U0(d, Wt(b, 3), ge, !0);
            }
            function Y6(d) {
                var b = d == null ? 0 : d.length;
                return b ? ui(d, 1) : [];
            }
            function MD(d) {
                var b = d == null ? 0 : d.length;
                return b ? ui(d, T) : [];
            }
            function RD(d, b) {
                var F = d == null ? 0 : d.length;
                return F ? (b = b === r ? 1 : pr(b), ui(d, b)) : [];
            }
            function CD(d) {
                for(var b = -1, F = d == null ? 0 : d.length, oe = {}; ++b < F;){
                    var ge = d[b];
                    oe[ge[0]] = ge[1];
                }
                return oe;
            }
            function X6(d) {
                return d && d.length ? d[0] : r;
            }
            function UD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = F == null ? 0 : pr(F);
                return ge < 0 && (ge = Kn(oe + ge, 0)), Gf(d, b, ge);
            }
            function $D(d) {
                var b = d == null ? 0 : d.length;
                return b ? Ko(d, 0, -1) : [];
            }
            var LD = Tr(function(d) {
                var b = gn(d, fw);
                return b.length && b[0] === d[0] ? ew(b) : [];
            }), DD = Tr(function(d) {
                var b = Wo(d), F = gn(d, fw);
                return b === Wo(F) ? b = r : F.pop(), F.length && F[0] === d[0] ? ew(F, Wt(b, 2)) : [];
            }), FD = Tr(function(d) {
                var b = Wo(d), F = gn(d, fw);
                return b = typeof b == "function" ? b : r, b && F.pop(), F.length && F[0] === d[0] ? ew(F, r, b) : [];
            });
            function zD(d, b) {
                return d == null ? "" : $$.call(d, b);
            }
            function Wo(d) {
                var b = d == null ? 0 : d.length;
                return b ? d[b - 1] : r;
            }
            function jD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var ge = oe;
                return F !== r && (ge = pr(F), ge = ge < 0 ? Kn(oe + ge, 0) : vi(ge, oe - 1)), b === b ? _$(d, b, ge) : U0(d, P8, ge, !0);
            }
            function HD(d, b) {
                return d && d.length ? c6(d, pr(b)) : r;
            }
            var qD = Tr(J6);
            function J6(d, b) {
                return d && d.length && b && b.length ? iw(d, b) : d;
            }
            function KD(d, b, F) {
                return d && d.length && b && b.length ? iw(d, b, Wt(F, 2)) : d;
            }
            function WD(d, b, F) {
                return d && d.length && b && b.length ? iw(d, b, r, F) : d;
            }
            var VD = Ra(function(d, b) {
                var F = d == null ? 0 : d.length, oe = Y1(d, b);
                return l6(d, gn(b, function(ge) {
                    return Ca(ge, F) ? +ge : ge;
                }).sort(_6)), oe;
            });
            function GD(d, b) {
                var F = [];
                if (!(d && d.length)) return F;
                var oe = -1, ge = [], ve = d.length;
                for(b = Wt(b, 3); ++oe < ve;){
                    var Oe = d[oe];
                    b(Oe, oe, d) && (F.push(Oe), ge.push(oe));
                }
                return l6(d, ge), F;
            }
            function Sw(d) {
                return d == null ? d : z$.call(d);
            }
            function ZD(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (F && typeof F != "number" && Di(d, b, F) ? (b = 0, F = oe) : (b = b == null ? 0 : pr(b), F = F === r ? oe : pr(F)), Ko(d, b, F)) : [];
            }
            function YD(d, b) {
                return rg(d, b);
            }
            function XD(d, b, F) {
                return aw(d, b, Wt(F, 2));
            }
            function JD(d, b) {
                var F = d == null ? 0 : d.length;
                if (F) {
                    var oe = rg(d, b);
                    if (oe < F && _s(d[oe], b)) return oe;
                }
                return -1;
            }
            function QD(d, b) {
                return rg(d, b, !0);
            }
            function eF(d, b, F) {
                return aw(d, b, Wt(F, 2), !0);
            }
            function tF(d, b) {
                var F = d == null ? 0 : d.length;
                if (F) {
                    var oe = rg(d, b, !0) - 1;
                    if (_s(d[oe], b)) return oe;
                }
                return -1;
            }
            function rF(d) {
                return d && d.length ? h6(d) : [];
            }
            function nF(d, b) {
                return d && d.length ? h6(d, Wt(b, 2)) : [];
            }
            function iF(d) {
                var b = d == null ? 0 : d.length;
                return b ? Ko(d, 1, b) : [];
            }
            function oF(d, b, F) {
                return d && d.length ? (b = F || b === r ? 1 : pr(b), Ko(d, 0, b < 0 ? 0 : b)) : [];
            }
            function sF(d, b, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (b = F || b === r ? 1 : pr(b), b = oe - b, Ko(d, b < 0 ? 0 : b, oe)) : [];
            }
            function aF(d, b) {
                return d && d.length ? ng(d, Wt(b, 3), !1, !0) : [];
            }
            function cF(d, b) {
                return d && d.length ? ng(d, Wt(b, 3)) : [];
            }
            var uF = Tr(function(d) {
                return Sc(ui(d, 1, Rn, !0));
            }), fF = Tr(function(d) {
                var b = Wo(d);
                return Rn(b) && (b = r), Sc(ui(d, 1, Rn, !0), Wt(b, 2));
            }), lF = Tr(function(d) {
                var b = Wo(d);
                return b = typeof b == "function" ? b : r, Sc(ui(d, 1, Rn, !0), r, b);
            });
            function dF(d) {
                return d && d.length ? Sc(d) : [];
            }
            function hF(d, b) {
                return d && d.length ? Sc(d, Wt(b, 2)) : [];
            }
            function pF(d, b) {
                return b = typeof b == "function" ? b : r, d && d.length ? Sc(d, r, b) : [];
            }
            function Aw(d) {
                if (!(d && d.length)) return [];
                var b = 0;
                return d = wc(d, function(F) {
                    if (Rn(F)) return b = Kn(F.length, b), !0;
                }), j1(b, function(F) {
                    return gn(d, D1(F));
                });
            }
            function Q6(d, b) {
                if (!(d && d.length)) return [];
                var F = Aw(d);
                return b == null ? F : gn(F, function(oe) {
                    return bo(b, r, oe);
                });
            }
            var gF = Tr(function(d, b) {
                return Rn(d) ? th(d, b) : [];
            }), yF = Tr(function(d) {
                return uw(wc(d, Rn));
            }), mF = Tr(function(d) {
                var b = Wo(d);
                return Rn(b) && (b = r), uw(wc(d, Rn), Wt(b, 2));
            }), bF = Tr(function(d) {
                var b = Wo(d);
                return b = typeof b == "function" ? b : r, uw(wc(d, Rn), r, b);
            }), wF = Tr(Aw);
            function vF(d, b) {
                return m6(d || [], b || [], eh);
            }
            function _F(d, b) {
                return m6(d || [], b || [], ih);
            }
            var EF = Tr(function(d) {
                var b = d.length, F = b > 1 ? d[b - 1] : r;
                return F = typeof F == "function" ? (d.pop(), F) : r, Q6(d, F);
            });
            function e4(d) {
                var b = me(d);
                return b.__chain__ = !0, b;
            }
            function xF(d, b) {
                return b(d), d;
            }
            function dg(d, b) {
                return b(d);
            }
            var SF = Ra(function(d) {
                var b = d.length, F = b ? d[0] : 0, oe = this.__wrapped__, ge = function(ve) {
                    return Y1(ve, d);
                };
                return b > 1 || this.__actions__.length || !(oe instanceof Rr) || !Ca(F) ? this.thru(ge) : (oe = oe.slice(F, +F + (b ? 1 : 0)), oe.__actions__.push({
                    func: dg,
                    args: [
                        ge
                    ],
                    thisArg: r
                }), new Ho(oe, this.__chain__).thru(function(ve) {
                    return b && !ve.length && ve.push(r), ve;
                }));
            });
            function AF() {
                return e4(this);
            }
            function TF() {
                return new Ho(this.value(), this.__chain__);
            }
            function kF() {
                this.__values__ === r && (this.__values__ = p4(this.value()));
                var d = this.__index__ >= this.__values__.length, b = d ? r : this.__values__[this.__index__++];
                return {
                    done: d,
                    value: b
                };
            }
            function IF() {
                return this;
            }
            function BF(d) {
                for(var b, F = this; F instanceof X0;){
                    var oe = V6(F);
                    oe.__index__ = 0, oe.__values__ = r, b ? ge.__wrapped__ = oe : b = oe;
                    var ge = oe;
                    F = F.__wrapped__;
                }
                return ge.__wrapped__ = d, b;
            }
            function OF() {
                var d = this.__wrapped__;
                if (d instanceof Rr) {
                    var b = d;
                    return this.__actions__.length && (b = new Rr(this)), b = b.reverse(), b.__actions__.push({
                        func: dg,
                        args: [
                            Sw
                        ],
                        thisArg: r
                    }), new Ho(b, this.__chain__);
                }
                return this.thru(Sw);
            }
            function PF() {
                return y6(this.__wrapped__, this.__actions__);
            }
            var NF = ig(function(d, b, F) {
                Qr.call(d, F) ? ++d[F] : Na(d, F, 1);
            });
            function MF(d, b, F) {
                var oe = ur(d) ? B8 : xL;
                return F && Di(d, b, F) && (b = r), oe(d, Wt(b, 3));
            }
            function RF(d, b) {
                var F = ur(d) ? wc : Q8;
                return F(d, Wt(b, 3));
            }
            var CF = k6(G6), UF = k6(Z6);
            function $F(d, b) {
                return ui(hg(d, b), 1);
            }
            function LF(d, b) {
                return ui(hg(d, b), T);
            }
            function DF(d, b, F) {
                return F = F === r ? 1 : pr(F), ui(hg(d, b), F);
            }
            function t4(d, b) {
                var F = ur(d) ? zo : xc;
                return F(d, Wt(b, 3));
            }
            function r4(d, b) {
                var F = ur(d) ? i$ : J8;
                return F(d, Wt(b, 3));
            }
            var FF = ig(function(d, b, F) {
                Qr.call(d, F) ? d[F].push(b) : Na(d, F, [
                    b
                ]);
            });
            function zF(d, b, F, oe) {
                d = Xi(d) ? d : sl(d), F = F && !oe ? pr(F) : 0;
                var ge = d.length;
                return F < 0 && (F = Kn(ge + F, 0)), bg(d) ? F <= ge && d.indexOf(b, F) > -1 : !!ge && Gf(d, b, F) > -1;
            }
            var jF = Tr(function(d, b, F) {
                var oe = -1, ge = typeof b == "function", ve = Xi(d) ? Ye(d.length) : [];
                return xc(d, function(Oe) {
                    ve[++oe] = ge ? bo(b, Oe, F) : rh(Oe, b, F);
                }), ve;
            }), HF = ig(function(d, b, F) {
                Na(d, F, b);
            });
            function hg(d, b) {
                var F = ur(d) ? gn : o6;
                return F(d, Wt(b, 3));
            }
            function qF(d, b, F, oe) {
                return d == null ? [] : (ur(b) || (b = b == null ? [] : [
                    b
                ]), F = oe ? r : F, ur(F) || (F = F == null ? [] : [
                    F
                ]), u6(d, b, F));
            }
            var KF = ig(function(d, b, F) {
                d[F ? 0 : 1].push(b);
            }, function() {
                return [
                    [],
                    []
                ];
            });
            function WF(d, b, F) {
                var oe = ur(d) ? $1 : M8, ge = arguments.length < 3;
                return oe(d, Wt(b, 4), F, ge, xc);
            }
            function VF(d, b, F) {
                var oe = ur(d) ? o$ : M8, ge = arguments.length < 3;
                return oe(d, Wt(b, 4), F, ge, J8);
            }
            function GF(d, b) {
                var F = ur(d) ? wc : Q8;
                return F(d, yg(Wt(b, 3)));
            }
            function ZF(d) {
                var b = ur(d) ? G8 : zL;
                return b(d);
            }
            function YF(d, b, F) {
                (F ? Di(d, b, F) : b === r) ? b = 1 : b = pr(b);
                var oe = ur(d) ? bL : jL;
                return oe(d, b);
            }
            function XF(d) {
                var b = ur(d) ? wL : qL;
                return b(d);
            }
            function JF(d) {
                if (d == null) return 0;
                if (Xi(d)) return bg(d) ? Yf(d) : d.length;
                var b = _i(d);
                return b == M || b == Ue ? d.size : rw(d).length;
            }
            function QF(d, b, F) {
                var oe = ur(d) ? L1 : KL;
                return F && Di(d, b, F) && (b = r), oe(d, Wt(b, 3));
            }
            var ez = Tr(function(d, b) {
                if (d == null) return [];
                var F = b.length;
                return F > 1 && Di(d, b[0], b[1]) ? b = [] : F > 2 && Di(b[0], b[1], b[2]) && (b = [
                    b[0]
                ]), u6(d, ui(b, 1), []);
            }), pg = R$ || function() {
                return ci.Date.now();
            };
            function tz(d, b) {
                if (typeof b != "function") throw new jo(s);
                return d = pr(d), function() {
                    if (--d < 1) return b.apply(this, arguments);
                };
            }
            function n4(d, b, F) {
                return b = F ? r : b, b = d && b == null ? d.length : b, Ma(d, Q, r, r, r, r, b);
            }
            function i4(d, b) {
                var F;
                if (typeof b != "function") throw new jo(s);
                return d = pr(d), function() {
                    return --d > 0 && (F = b.apply(this, arguments)), d <= 1 && (b = r), F;
                };
            }
            var Tw = Tr(function(d, b, F) {
                var oe = O;
                if (F.length) {
                    var ge = _c(F, il(Tw));
                    oe |= K;
                }
                return Ma(d, oe, b, F, ge);
            }), o4 = Tr(function(d, b, F) {
                var oe = O | N;
                if (F.length) {
                    var ge = _c(F, il(o4));
                    oe |= K;
                }
                return Ma(b, oe, d, F, ge);
            });
            function s4(d, b, F) {
                b = F ? r : b;
                var oe = Ma(d, D, r, r, r, r, r, b);
                return oe.placeholder = s4.placeholder, oe;
            }
            function a4(d, b, F) {
                b = F ? r : b;
                var oe = Ma(d, H, r, r, r, r, r, b);
                return oe.placeholder = a4.placeholder, oe;
            }
            function c4(d, b, F) {
                var oe, ge, ve, Oe, $e, He, it = 0, st = !1, ft = !1, At = !0;
                if (typeof d != "function") throw new jo(s);
                b = Vo(b) || 0, wn(F) && (st = !!F.leading, ft = "maxWait" in F, ve = ft ? Kn(Vo(F.maxWait) || 0, b) : ve, At = "trailing" in F ? !!F.trailing : At);
                function Ut(Cn) {
                    var Es = oe, La = ge;
                    return oe = ge = r, it = Cn, Oe = d.apply(La, Es), Oe;
                }
                function Vt(Cn) {
                    return it = Cn, $e = ah(Pr, b), st ? Ut(Cn) : Oe;
                }
                function vr(Cn) {
                    var Es = Cn - He, La = Cn - it, k4 = b - Es;
                    return ft ? vi(k4, ve - La) : k4;
                }
                function Gt(Cn) {
                    var Es = Cn - He, La = Cn - it;
                    return He === r || Es >= b || Es < 0 || ft && La >= ve;
                }
                function Pr() {
                    var Cn = pg();
                    if (Gt(Cn)) return Lr(Cn);
                    $e = ah(Pr, vr(Cn));
                }
                function Lr(Cn) {
                    return $e = r, At && oe ? Ut(Cn) : (oe = ge = r, Oe);
                }
                function Eo() {
                    $e !== r && b6($e), it = 0, oe = He = ge = $e = r;
                }
                function Fi() {
                    return $e === r ? Oe : Lr(pg());
                }
                function xo() {
                    var Cn = pg(), Es = Gt(Cn);
                    if (oe = arguments, ge = this, He = Cn, Es) {
                        if ($e === r) return Vt(He);
                        if (ft) return b6($e), $e = ah(Pr, b), Ut(He);
                    }
                    return $e === r && ($e = ah(Pr, b)), Oe;
                }
                return xo.cancel = Eo, xo.flush = Fi, xo;
            }
            var rz = Tr(function(d, b) {
                return X8(d, 1, b);
            }), nz = Tr(function(d, b, F) {
                return X8(d, Vo(b) || 0, F);
            });
            function iz(d) {
                return Ma(d, R);
            }
            function gg(d, b) {
                if (typeof d != "function" || b != null && typeof b != "function") throw new jo(s);
                var F = function() {
                    var oe = arguments, ge = b ? b.apply(this, oe) : oe[0], ve = F.cache;
                    if (ve.has(ge)) return ve.get(ge);
                    var Oe = d.apply(this, oe);
                    return F.cache = ve.set(ge, Oe) || ve, Oe;
                };
                return F.cache = new (gg.Cache || Pa)(), F;
            }
            gg.Cache = Pa;
            function yg(d) {
                if (typeof d != "function") throw new jo(s);
                return function() {
                    var b = arguments;
                    switch(b.length){
                        case 0:
                            return !d.call(this);
                        case 1:
                            return !d.call(this, b[0]);
                        case 2:
                            return !d.call(this, b[0], b[1]);
                        case 3:
                            return !d.call(this, b[0], b[1], b[2]);
                    }
                    return !d.apply(this, b);
                };
            }
            function oz(d) {
                return i4(2, d);
            }
            var sz = WL(function(d, b) {
                b = b.length == 1 && ur(b[0]) ? gn(b[0], wo(Wt())) : gn(ui(b, 1), wo(Wt()));
                var F = b.length;
                return Tr(function(oe) {
                    for(var ge = -1, ve = vi(oe.length, F); ++ge < ve;)oe[ge] = b[ge].call(this, oe[ge]);
                    return bo(d, this, oe);
                });
            }), kw = Tr(function(d, b) {
                var F = _c(b, il(kw));
                return Ma(d, K, r, b, F);
            }), u4 = Tr(function(d, b) {
                var F = _c(b, il(u4));
                return Ma(d, re, r, b, F);
            }), az = Ra(function(d, b) {
                return Ma(d, G, r, r, r, b);
            });
            function cz(d, b) {
                if (typeof d != "function") throw new jo(s);
                return b = b === r ? b : pr(b), Tr(d, b);
            }
            function uz(d, b) {
                if (typeof d != "function") throw new jo(s);
                return b = b == null ? 0 : Kn(pr(b), 0), Tr(function(F) {
                    var oe = F[b], ge = Tc(F, 0, b);
                    return oe && vc(ge, oe), bo(d, this, ge);
                });
            }
            function fz(d, b, F) {
                var oe = !0, ge = !0;
                if (typeof d != "function") throw new jo(s);
                return wn(F) && (oe = "leading" in F ? !!F.leading : oe, ge = "trailing" in F ? !!F.trailing : ge), c4(d, b, {
                    leading: oe,
                    maxWait: b,
                    trailing: ge
                });
            }
            function lz(d) {
                return n4(d, 1);
            }
            function dz(d, b) {
                return kw(lw(b), d);
            }
            function hz() {
                if (!arguments.length) return [];
                var d = arguments[0];
                return ur(d) ? d : [
                    d
                ];
            }
            function pz(d) {
                return qo(d, y);
            }
            function gz(d, b) {
                return b = typeof b == "function" ? b : r, qo(d, y, b);
            }
            function yz(d) {
                return qo(d, l | y);
            }
            function mz(d, b) {
                return b = typeof b == "function" ? b : r, qo(d, l | y, b);
            }
            function bz(d, b) {
                return b == null || Y8(d, b, ti(b));
            }
            function _s(d, b) {
                return d === b || d !== d && b !== b;
            }
            var wz = cg(Q1), vz = cg(function(d, b) {
                return d >= b;
            }), zu = r6(/* @__PURE__ */ function() {
                return arguments;
            }()) ? r6 : function(d) {
                return On(d) && Qr.call(d, "callee") && !j8.call(d, "callee");
            }, ur = Ye.isArray, _z = x8 ? wo(x8) : BL;
            function Xi(d) {
                return d != null && mg(d.length) && !Ua(d);
            }
            function Rn(d) {
                return On(d) && Xi(d);
            }
            function Ez(d) {
                return d === !0 || d === !1 || On(d) && Li(d) == ae;
            }
            var kc = U$ || Lw, xz = S8 ? wo(S8) : OL;
            function Sz(d) {
                return On(d) && d.nodeType === 1 && !ch(d);
            }
            function Az(d) {
                if (d == null) return !0;
                if (Xi(d) && (ur(d) || typeof d == "string" || typeof d.splice == "function" || kc(d) || ol(d) || zu(d))) return !d.length;
                var b = _i(d);
                if (b == M || b == Ue) return !d.size;
                if (sh(d)) return !rw(d).length;
                for(var F in d)if (Qr.call(d, F)) return !1;
                return !0;
            }
            function Tz(d, b) {
                return nh(d, b);
            }
            function kz(d, b, F) {
                F = typeof F == "function" ? F : r;
                var oe = F ? F(d, b) : r;
                return oe === r ? nh(d, b, r, F) : !!oe;
            }
            function Iw(d) {
                if (!On(d)) return !1;
                var b = Li(d);
                return b == De || b == Se || typeof d.message == "string" && typeof d.name == "string" && !ch(d);
            }
            function Iz(d) {
                return typeof d == "number" && q8(d);
            }
            function Ua(d) {
                if (!wn(d)) return !1;
                var b = Li(d);
                return b == Re || b == Ce || b == ee || b == je;
            }
            function f4(d) {
                return typeof d == "number" && d == pr(d);
            }
            function mg(d) {
                return typeof d == "number" && d > -1 && d % 1 == 0 && d <= I;
            }
            function wn(d) {
                var b = typeof d;
                return d != null && (b == "object" || b == "function");
            }
            function On(d) {
                return d != null && typeof d == "object";
            }
            var l4 = A8 ? wo(A8) : NL;
            function Bz(d, b) {
                return d === b || tw(d, b, bw(b));
            }
            function Oz(d, b, F) {
                return F = typeof F == "function" ? F : r, tw(d, b, bw(b), F);
            }
            function Pz(d) {
                return d4(d) && d != +d;
            }
            function Nz(d) {
                if (gD(d)) throw new sr(o);
                return n6(d);
            }
            function Mz(d) {
                return d === null;
            }
            function Rz(d) {
                return d == null;
            }
            function d4(d) {
                return typeof d == "number" || On(d) && Li(d) == z;
            }
            function ch(d) {
                if (!On(d) || Li(d) != _e) return !1;
                var b = q0(d);
                if (b === null) return !0;
                var F = Qr.call(b, "constructor") && b.constructor;
                return typeof F == "function" && F instanceof F && F0.call(F) == O$;
            }
            var Bw = T8 ? wo(T8) : ML;
            function Cz(d) {
                return f4(d) && d >= -I && d <= I;
            }
            var h4 = k8 ? wo(k8) : RL;
            function bg(d) {
                return typeof d == "string" || !ur(d) && On(d) && Li(d) == h;
            }
            function _o(d) {
                return typeof d == "symbol" || On(d) && Li(d) == x;
            }
            var ol = I8 ? wo(I8) : CL;
            function Uz(d) {
                return d === r;
            }
            function $z(d) {
                return On(d) && _i(d) == te;
            }
            function Lz(d) {
                return On(d) && Li(d) == fe;
            }
            var Dz = cg(nw), Fz = cg(function(d, b) {
                return d <= b;
            });
            function p4(d) {
                if (!d) return [];
                if (Xi(d)) return bg(d) ? ws(d) : Yi(d);
                if (Zd && d[Zd]) return b$(d[Zd]());
                var b = _i(d), F = b == M ? q1 : b == Ue ? $0 : sl;
                return F(d);
            }
            function $a(d) {
                if (!d) return d === 0 ? d : 0;
                if (d = Vo(d), d === T || d === -T) {
                    var b = d < 0 ? -1 : 1;
                    return b * P;
                }
                return d === d ? d : 0;
            }
            function pr(d) {
                var b = $a(d), F = b % 1;
                return b === b ? F ? b - F : b : 0;
            }
            function g4(d) {
                return d ? $u(pr(d), 0, L) : 0;
            }
            function Vo(d) {
                if (typeof d == "number") return d;
                if (_o(d)) return k;
                if (wn(d)) {
                    var b = typeof d.valueOf == "function" ? d.valueOf() : d;
                    d = wn(b) ? b + "" : b;
                }
                if (typeof d != "string") return d === 0 ? d : +d;
                d = R8(d);
                var F = xt.test(d);
                return F || Pe.test(d) ? t$(d.slice(2), F ? 2 : 8) : Xe.test(d) ? k : +d;
            }
            function y4(d) {
                return Ks(d, Ji(d));
            }
            function zz(d) {
                return d ? $u(pr(d), -I, I) : d === 0 ? d : 0;
            }
            function Yr(d) {
                return d == null ? "" : vo(d);
            }
            var jz = rl(function(d, b) {
                if (sh(b) || Xi(b)) {
                    Ks(b, ti(b), d);
                    return;
                }
                for(var F in b)Qr.call(b, F) && eh(d, F, b[F]);
            }), m4 = rl(function(d, b) {
                Ks(b, Ji(b), d);
            }), wg = rl(function(d, b, F, oe) {
                Ks(b, Ji(b), d, oe);
            }), Hz = rl(function(d, b, F, oe) {
                Ks(b, ti(b), d, oe);
            }), qz = Ra(Y1);
            function Kz(d, b) {
                var F = tl(d);
                return b == null ? F : Z8(F, b);
            }
            var Wz = Tr(function(d, b) {
                d = an(d);
                var F = -1, oe = b.length, ge = oe > 2 ? b[2] : r;
                for(ge && Di(b[0], b[1], ge) && (oe = 1); ++F < oe;)for(var ve = b[F], Oe = Ji(ve), $e = -1, He = Oe.length; ++$e < He;){
                    var it = Oe[$e], st = d[it];
                    (st === r || _s(st, Jf[it]) && !Qr.call(d, it)) && (d[it] = ve[it]);
                }
                return d;
            }), Vz = Tr(function(d) {
                return d.push(r, R6), bo(b4, r, d);
            });
            function Gz(d, b) {
                return O8(d, Wt(b, 3), qs);
            }
            function Zz(d, b) {
                return O8(d, Wt(b, 3), J1);
            }
            function Yz(d, b) {
                return d == null ? d : X1(d, Wt(b, 3), Ji);
            }
            function Xz(d, b) {
                return d == null ? d : e6(d, Wt(b, 3), Ji);
            }
            function Jz(d, b) {
                return d && qs(d, Wt(b, 3));
            }
            function Qz(d, b) {
                return d && J1(d, Wt(b, 3));
            }
            function ej(d) {
                return d == null ? [] : eg(d, ti(d));
            }
            function tj(d) {
                return d == null ? [] : eg(d, Ji(d));
            }
            function Ow(d, b, F) {
                var oe = d == null ? r : Lu(d, b);
                return oe === r ? F : oe;
            }
            function rj(d, b) {
                return d != null && $6(d, b, AL);
            }
            function Pw(d, b) {
                return d != null && $6(d, b, TL);
            }
            var nj = B6(function(d, b, F) {
                b != null && typeof b.toString != "function" && (b = z0.call(b)), d[b] = F;
            }, Mw(Qi)), ij = B6(function(d, b, F) {
                b != null && typeof b.toString != "function" && (b = z0.call(b)), Qr.call(d, b) ? d[b].push(F) : d[b] = [
                    F
                ];
            }, Wt), oj = Tr(rh);
            function ti(d) {
                return Xi(d) ? V8(d) : rw(d);
            }
            function Ji(d) {
                return Xi(d) ? V8(d, !0) : UL(d);
            }
            function sj(d, b) {
                var F = {};
                return b = Wt(b, 3), qs(d, function(oe, ge, ve) {
                    Na(F, b(oe, ge, ve), oe);
                }), F;
            }
            function aj(d, b) {
                var F = {};
                return b = Wt(b, 3), qs(d, function(oe, ge, ve) {
                    Na(F, ge, b(oe, ge, ve));
                }), F;
            }
            var cj = rl(function(d, b, F) {
                tg(d, b, F);
            }), b4 = rl(function(d, b, F, oe) {
                tg(d, b, F, oe);
            }), uj = Ra(function(d, b) {
                var F = {};
                if (d == null) return F;
                var oe = !1;
                b = gn(b, function(ve) {
                    return ve = Ac(ve, d), oe || (oe = ve.length > 1), ve;
                }), Ks(d, yw(d), F), oe && (F = qo(F, l | p | y, nD));
                for(var ge = b.length; ge--;)cw(F, b[ge]);
                return F;
            });
            function fj(d, b) {
                return w4(d, yg(Wt(b)));
            }
            var lj = Ra(function(d, b) {
                return d == null ? {} : LL(d, b);
            });
            function w4(d, b) {
                if (d == null) return {};
                var F = gn(yw(d), function(oe) {
                    return [
                        oe
                    ];
                });
                return b = Wt(b), f6(d, F, function(oe, ge) {
                    return b(oe, ge[0]);
                });
            }
            function dj(d, b, F) {
                b = Ac(b, d);
                var oe = -1, ge = b.length;
                for(ge || (ge = 1, d = r); ++oe < ge;){
                    var ve = d == null ? r : d[Ws(b[oe])];
                    ve === r && (oe = ge, ve = F), d = Ua(ve) ? ve.call(d) : ve;
                }
                return d;
            }
            function hj(d, b, F) {
                return d == null ? d : ih(d, b, F);
            }
            function pj(d, b, F, oe) {
                return oe = typeof oe == "function" ? oe : r, d == null ? d : ih(d, b, F, oe);
            }
            var v4 = N6(ti), _4 = N6(Ji);
            function gj(d, b, F) {
                var oe = ur(d), ge = oe || kc(d) || ol(d);
                if (b = Wt(b, 4), F == null) {
                    var ve = d && d.constructor;
                    ge ? F = oe ? new ve() : [] : wn(d) ? F = Ua(ve) ? tl(q0(d)) : {} : F = {};
                }
                return (ge ? zo : qs)(d, function(Oe, $e, He) {
                    return b(F, Oe, $e, He);
                }), F;
            }
            function yj(d, b) {
                return d == null ? !0 : cw(d, b);
            }
            function mj(d, b, F) {
                return d == null ? d : g6(d, b, lw(F));
            }
            function bj(d, b, F, oe) {
                return oe = typeof oe == "function" ? oe : r, d == null ? d : g6(d, b, lw(F), oe);
            }
            function sl(d) {
                return d == null ? [] : H1(d, ti(d));
            }
            function wj(d) {
                return d == null ? [] : H1(d, Ji(d));
            }
            function vj(d, b, F) {
                return F === r && (F = b, b = r), F !== r && (F = Vo(F), F = F === F ? F : 0), b !== r && (b = Vo(b), b = b === b ? b : 0), $u(Vo(d), b, F);
            }
            function _j(d, b, F) {
                return b = $a(b), F === r ? (F = b, b = 0) : F = $a(F), d = Vo(d), kL(d, b, F);
            }
            function Ej(d, b, F) {
                if (F && typeof F != "boolean" && Di(d, b, F) && (b = F = r), F === r && (typeof b == "boolean" ? (F = b, b = r) : typeof d == "boolean" && (F = d, d = r)), d === r && b === r ? (d = 0, b = 1) : (d = $a(d), b === r ? (b = d, d = 0) : b = $a(b)), d > b) {
                    var oe = d;
                    d = b, b = oe;
                }
                if (F || d % 1 || b % 1) {
                    var ge = K8();
                    return vi(d + ge * (b - d + e$("1e-" + ((ge + "").length - 1))), b);
                }
                return ow(d, b);
            }
            var xj = nl(function(d, b, F) {
                return b = b.toLowerCase(), d + (F ? E4(b) : b);
            });
            function E4(d) {
                return Nw(Yr(d).toLowerCase());
            }
            function x4(d) {
                return d = Yr(d), d && d.replace(vt, h$).replace(qU, "");
            }
            function Sj(d, b, F) {
                d = Yr(d), b = vo(b);
                var oe = d.length;
                F = F === r ? oe : $u(pr(F), 0, oe);
                var ge = F;
                return F -= b.length, F >= 0 && d.slice(F, ge) == b;
            }
            function Aj(d) {
                return d = Yr(d), d && jr.test(d) ? d.replace(Lt, p$) : d;
            }
            function Tj(d) {
                return d = Yr(d), d && Me.test(d) ? d.replace(xe, "\\$&") : d;
            }
            var kj = nl(function(d, b, F) {
                return d + (F ? "-" : "") + b.toLowerCase();
            }), Ij = nl(function(d, b, F) {
                return d + (F ? " " : "") + b.toLowerCase();
            }), Bj = T6("toLowerCase");
            function Oj(d, b, F) {
                d = Yr(d), b = pr(b);
                var oe = b ? Yf(d) : 0;
                if (!b || oe >= b) return d;
                var ge = (b - oe) / 2;
                return ag(G0(ge), F) + d + ag(V0(ge), F);
            }
            function Pj(d, b, F) {
                d = Yr(d), b = pr(b);
                var oe = b ? Yf(d) : 0;
                return b && oe < b ? d + ag(b - oe, F) : d;
            }
            function Nj(d, b, F) {
                d = Yr(d), b = pr(b);
                var oe = b ? Yf(d) : 0;
                return b && oe < b ? ag(b - oe, F) + d : d;
            }
            function Mj(d, b, F) {
                return F || b == null ? b = 0 : b && (b = +b), F$(Yr(d).replace(ze, ""), b || 0);
            }
            function Rj(d, b, F) {
                return (F ? Di(d, b, F) : b === r) ? b = 1 : b = pr(b), sw(Yr(d), b);
            }
            function Cj() {
                var d = arguments, b = Yr(d[0]);
                return d.length < 3 ? b : b.replace(d[1], d[2]);
            }
            var Uj = nl(function(d, b, F) {
                return d + (F ? "_" : "") + b.toLowerCase();
            });
            function $j(d, b, F) {
                return F && typeof F != "number" && Di(d, b, F) && (b = F = r), F = F === r ? L : F >>> 0, F ? (d = Yr(d), d && (typeof b == "string" || b != null && !Bw(b)) && (b = vo(b), !b && Zf(d)) ? Tc(ws(d), 0, F) : d.split(b, F)) : [];
            }
            var Lj = nl(function(d, b, F) {
                return d + (F ? " " : "") + Nw(b);
            });
            function Dj(d, b, F) {
                return d = Yr(d), F = F == null ? 0 : $u(pr(F), 0, d.length), b = vo(b), d.slice(F, F + b.length) == b;
            }
            function Fj(d, b, F) {
                var oe = me.templateSettings;
                F && Di(d, b, F) && (b = r), d = Yr(d), b = wg({}, b, oe, M6);
                var ge = wg({}, b.imports, oe.imports, M6), ve = ti(ge), Oe = H1(ge, ve), $e, He, it = 0, st = b.interpolate || be, ft = "__p += '", At = K1((b.escape || be).source + "|" + st.source + "|" + (st === wr ? Mt : be).source + "|" + (b.evaluate || be).source + "|$", "g"), Ut = "//# sourceURL=" + (Qr.call(b, "sourceURL") ? (b.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ZU + "]") + `
`;
                d.replace(At, function(Gt, Pr, Lr, Eo, Fi, xo) {
                    return Lr || (Lr = Eo), ft += d.slice(it, xo).replace($r, g$), Pr && ($e = !0, ft += `' +
__e(` + Pr + `) +
'`), Fi && (He = !0, ft += `';
` + Fi + `;
__p += '`), Lr && (ft += `' +
((__t = (` + Lr + `)) == null ? '' : __t) +
'`), it = xo + Gt.length, Gt;
                }), ft += `';
`;
                var Vt = Qr.call(b, "variable") && b.variable;
                if (!Vt) ft = `with (obj) {
` + ft + `
}
`;
                else if (wt.test(Vt)) throw new sr(a);
                ft = (He ? ft.replace(yt, "") : ft).replace(_t, "$1").replace(Qe, "$1;"), ft = "function(" + (Vt || "obj") + `) {
` + (Vt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + ($e ? ", __e = _.escape" : "") + (He ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ft + `return __p
}`;
                var vr = A4(function() {
                    return Wr(ve, Ut + "return " + ft).apply(r, Oe);
                });
                if (vr.source = ft, Iw(vr)) throw vr;
                return vr;
            }
            function zj(d) {
                return Yr(d).toLowerCase();
            }
            function jj(d) {
                return Yr(d).toUpperCase();
            }
            function Hj(d, b, F) {
                if (d = Yr(d), d && (F || b === r)) return R8(d);
                if (!d || !(b = vo(b))) return d;
                var oe = ws(d), ge = ws(b), ve = C8(oe, ge), Oe = U8(oe, ge) + 1;
                return Tc(oe, ve, Oe).join("");
            }
            function qj(d, b, F) {
                if (d = Yr(d), d && (F || b === r)) return d.slice(0, L8(d) + 1);
                if (!d || !(b = vo(b))) return d;
                var oe = ws(d), ge = U8(oe, ws(b)) + 1;
                return Tc(oe, 0, ge).join("");
            }
            function Kj(d, b, F) {
                if (d = Yr(d), d && (F || b === r)) return d.replace(ze, "");
                if (!d || !(b = vo(b))) return d;
                var oe = ws(d), ge = C8(oe, ws(b));
                return Tc(oe, ge).join("");
            }
            function Wj(d, b) {
                var F = X, oe = $;
                if (wn(b)) {
                    var ge = "separator" in b ? b.separator : ge;
                    F = "length" in b ? pr(b.length) : F, oe = "omission" in b ? vo(b.omission) : oe;
                }
                d = Yr(d);
                var ve = d.length;
                if (Zf(d)) {
                    var Oe = ws(d);
                    ve = Oe.length;
                }
                if (F >= ve) return d;
                var $e = F - Yf(oe);
                if ($e < 1) return oe;
                var He = Oe ? Tc(Oe, 0, $e).join("") : d.slice(0, $e);
                if (ge === r) return He + oe;
                if (Oe && ($e += He.length - $e), Bw(ge)) {
                    if (d.slice($e).search(ge)) {
                        var it, st = He;
                        for(ge.global || (ge = K1(ge.source, Yr(Ct.exec(ge)) + "g")), ge.lastIndex = 0; it = ge.exec(st);)var ft = it.index;
                        He = He.slice(0, ft === r ? $e : ft);
                    }
                } else if (d.indexOf(vo(ge), $e) != $e) {
                    var At = He.lastIndexOf(ge);
                    At > -1 && (He = He.slice(0, At));
                }
                return He + oe;
            }
            function Vj(d) {
                return d = Yr(d), d && Ur.test(d) ? d.replace(Rt, E$) : d;
            }
            var Gj = nl(function(d, b, F) {
                return d + (F ? " " : "") + b.toUpperCase();
            }), Nw = T6("toUpperCase");
            function S4(d, b, F) {
                return d = Yr(d), b = F ? r : b, b === r ? m$(d) ? A$(d) : c$(d) : d.match(b) || [];
            }
            var A4 = Tr(function(d, b) {
                try {
                    return bo(d, r, b);
                } catch (F) {
                    return Iw(F) ? F : new sr(F);
                }
            }), Zj = Ra(function(d, b) {
                return zo(b, function(F) {
                    F = Ws(F), Na(d, F, Tw(d[F], d));
                }), d;
            });
            function Yj(d) {
                var b = d == null ? 0 : d.length, F = Wt();
                return d = b ? gn(d, function(oe) {
                    if (typeof oe[1] != "function") throw new jo(s);
                    return [
                        F(oe[0]),
                        oe[1]
                    ];
                }) : [], Tr(function(oe) {
                    for(var ge = -1; ++ge < b;){
                        var ve = d[ge];
                        if (bo(ve[0], this, oe)) return bo(ve[1], this, oe);
                    }
                });
            }
            function Xj(d) {
                return EL(qo(d, l));
            }
            function Mw(d) {
                return function() {
                    return d;
                };
            }
            function Jj(d, b) {
                return d == null || d !== d ? b : d;
            }
            var Qj = I6(), eH = I6(!0);
            function Qi(d) {
                return d;
            }
            function Rw(d) {
                return i6(typeof d == "function" ? d : qo(d, l));
            }
            function tH(d) {
                return s6(qo(d, l));
            }
            function rH(d, b) {
                return a6(d, qo(b, l));
            }
            var nH = Tr(function(d, b) {
                return function(F) {
                    return rh(F, d, b);
                };
            }), iH = Tr(function(d, b) {
                return function(F) {
                    return rh(d, F, b);
                };
            });
            function Cw(d, b, F) {
                var oe = ti(b), ge = eg(b, oe);
                F == null && !(wn(b) && (ge.length || !oe.length)) && (F = b, b = d, d = this, ge = eg(b, ti(b)));
                var ve = !(wn(F) && "chain" in F) || !!F.chain, Oe = Ua(d);
                return zo(ge, function($e) {
                    var He = b[$e];
                    d[$e] = He, Oe && (d.prototype[$e] = function() {
                        var it = this.__chain__;
                        if (ve || it) {
                            var st = d(this.__wrapped__), ft = st.__actions__ = Yi(this.__actions__);
                            return ft.push({
                                func: He,
                                args: arguments,
                                thisArg: d
                            }), st.__chain__ = it, st;
                        }
                        return He.apply(d, vc([
                            this.value()
                        ], arguments));
                    });
                }), d;
            }
            function oH() {
                return ci._ === this && (ci._ = P$), this;
            }
            function Uw() {}
            function sH(d) {
                return d = pr(d), Tr(function(b) {
                    return c6(b, d);
                });
            }
            var aH = hw(gn), cH = hw(B8), uH = hw(L1);
            function T4(d) {
                return vw(d) ? D1(Ws(d)) : DL(d);
            }
            function fH(d) {
                return function(b) {
                    return d == null ? r : Lu(d, b);
                };
            }
            var lH = O6(), dH = O6(!0);
            function $w() {
                return [];
            }
            function Lw() {
                return !1;
            }
            function hH() {
                return {};
            }
            function pH() {
                return "";
            }
            function gH() {
                return !0;
            }
            function yH(d, b) {
                if (d = pr(d), d < 1 || d > I) return [];
                var F = L, oe = vi(d, L);
                b = Wt(b), d -= L;
                for(var ge = j1(oe, b); ++F < d;)b(F);
                return ge;
            }
            function mH(d) {
                return ur(d) ? gn(d, Ws) : _o(d) ? [
                    d
                ] : Yi(W6(Yr(d)));
            }
            function bH(d) {
                var b = ++B$;
                return Yr(d) + b;
            }
            var wH = sg(function(d, b) {
                return d + b;
            }, 0), vH = pw("ceil"), _H = sg(function(d, b) {
                return d / b;
            }, 1), EH = pw("floor");
            function xH(d) {
                return d && d.length ? Q0(d, Qi, Q1) : r;
            }
            function SH(d, b) {
                return d && d.length ? Q0(d, Wt(b, 2), Q1) : r;
            }
            function AH(d) {
                return N8(d, Qi);
            }
            function TH(d, b) {
                return N8(d, Wt(b, 2));
            }
            function kH(d) {
                return d && d.length ? Q0(d, Qi, nw) : r;
            }
            function IH(d, b) {
                return d && d.length ? Q0(d, Wt(b, 2), nw) : r;
            }
            var BH = sg(function(d, b) {
                return d * b;
            }, 1), OH = pw("round"), PH = sg(function(d, b) {
                return d - b;
            }, 0);
            function NH(d) {
                return d && d.length ? z1(d, Qi) : 0;
            }
            function MH(d, b) {
                return d && d.length ? z1(d, Wt(b, 2)) : 0;
            }
            return me.after = tz, me.ary = n4, me.assign = jz, me.assignIn = m4, me.assignInWith = wg, me.assignWith = Hz, me.at = qz, me.before = i4, me.bind = Tw, me.bindAll = Zj, me.bindKey = o4, me.castArray = hz, me.chain = e4, me.chunk = ED, me.compact = xD, me.concat = SD, me.cond = Yj, me.conforms = Xj, me.constant = Mw, me.countBy = NF, me.create = Kz, me.curry = s4, me.curryRight = a4, me.debounce = c4, me.defaults = Wz, me.defaultsDeep = Vz, me.defer = rz, me.delay = nz, me.difference = AD, me.differenceBy = TD, me.differenceWith = kD, me.drop = ID, me.dropRight = BD, me.dropRightWhile = OD, me.dropWhile = PD, me.fill = ND, me.filter = RF, me.flatMap = $F, me.flatMapDeep = LF, me.flatMapDepth = DF, me.flatten = Y6, me.flattenDeep = MD, me.flattenDepth = RD, me.flip = iz, me.flow = Qj, me.flowRight = eH, me.fromPairs = CD, me.functions = ej, me.functionsIn = tj, me.groupBy = FF, me.initial = $D, me.intersection = LD, me.intersectionBy = DD, me.intersectionWith = FD, me.invert = nj, me.invertBy = ij, me.invokeMap = jF, me.iteratee = Rw, me.keyBy = HF, me.keys = ti, me.keysIn = Ji, me.map = hg, me.mapKeys = sj, me.mapValues = aj, me.matches = tH, me.matchesProperty = rH, me.memoize = gg, me.merge = cj, me.mergeWith = b4, me.method = nH, me.methodOf = iH, me.mixin = Cw, me.negate = yg, me.nthArg = sH, me.omit = uj, me.omitBy = fj, me.once = oz, me.orderBy = qF, me.over = aH, me.overArgs = sz, me.overEvery = cH, me.overSome = uH, me.partial = kw, me.partialRight = u4, me.partition = KF, me.pick = lj, me.pickBy = w4, me.property = T4, me.propertyOf = fH, me.pull = qD, me.pullAll = J6, me.pullAllBy = KD, me.pullAllWith = WD, me.pullAt = VD, me.range = lH, me.rangeRight = dH, me.rearg = az, me.reject = GF, me.remove = GD, me.rest = cz, me.reverse = Sw, me.sampleSize = YF, me.set = hj, me.setWith = pj, me.shuffle = XF, me.slice = ZD, me.sortBy = ez, me.sortedUniq = rF, me.sortedUniqBy = nF, me.split = $j, me.spread = uz, me.tail = iF, me.take = oF, me.takeRight = sF, me.takeRightWhile = aF, me.takeWhile = cF, me.tap = xF, me.throttle = fz, me.thru = dg, me.toArray = p4, me.toPairs = v4, me.toPairsIn = _4, me.toPath = mH, me.toPlainObject = y4, me.transform = gj, me.unary = lz, me.union = uF, me.unionBy = fF, me.unionWith = lF, me.uniq = dF, me.uniqBy = hF, me.uniqWith = pF, me.unset = yj, me.unzip = Aw, me.unzipWith = Q6, me.update = mj, me.updateWith = bj, me.values = sl, me.valuesIn = wj, me.without = gF, me.words = S4, me.wrap = dz, me.xor = yF, me.xorBy = mF, me.xorWith = bF, me.zip = wF, me.zipObject = vF, me.zipObjectDeep = _F, me.zipWith = EF, me.entries = v4, me.entriesIn = _4, me.extend = m4, me.extendWith = wg, Cw(me, me), me.add = wH, me.attempt = A4, me.camelCase = xj, me.capitalize = E4, me.ceil = vH, me.clamp = vj, me.clone = pz, me.cloneDeep = yz, me.cloneDeepWith = mz, me.cloneWith = gz, me.conformsTo = bz, me.deburr = x4, me.defaultTo = Jj, me.divide = _H, me.endsWith = Sj, me.eq = _s, me.escape = Aj, me.escapeRegExp = Tj, me.every = MF, me.find = CF, me.findIndex = G6, me.findKey = Gz, me.findLast = UF, me.findLastIndex = Z6, me.findLastKey = Zz, me.floor = EH, me.forEach = t4, me.forEachRight = r4, me.forIn = Yz, me.forInRight = Xz, me.forOwn = Jz, me.forOwnRight = Qz, me.get = Ow, me.gt = wz, me.gte = vz, me.has = rj, me.hasIn = Pw, me.head = X6, me.identity = Qi, me.includes = zF, me.indexOf = UD, me.inRange = _j, me.invoke = oj, me.isArguments = zu, me.isArray = ur, me.isArrayBuffer = _z, me.isArrayLike = Xi, me.isArrayLikeObject = Rn, me.isBoolean = Ez, me.isBuffer = kc, me.isDate = xz, me.isElement = Sz, me.isEmpty = Az, me.isEqual = Tz, me.isEqualWith = kz, me.isError = Iw, me.isFinite = Iz, me.isFunction = Ua, me.isInteger = f4, me.isLength = mg, me.isMap = l4, me.isMatch = Bz, me.isMatchWith = Oz, me.isNaN = Pz, me.isNative = Nz, me.isNil = Rz, me.isNull = Mz, me.isNumber = d4, me.isObject = wn, me.isObjectLike = On, me.isPlainObject = ch, me.isRegExp = Bw, me.isSafeInteger = Cz, me.isSet = h4, me.isString = bg, me.isSymbol = _o, me.isTypedArray = ol, me.isUndefined = Uz, me.isWeakMap = $z, me.isWeakSet = Lz, me.join = zD, me.kebabCase = kj, me.last = Wo, me.lastIndexOf = jD, me.lowerCase = Ij, me.lowerFirst = Bj, me.lt = Dz, me.lte = Fz, me.max = xH, me.maxBy = SH, me.mean = AH, me.meanBy = TH, me.min = kH, me.minBy = IH, me.stubArray = $w, me.stubFalse = Lw, me.stubObject = hH, me.stubString = pH, me.stubTrue = gH, me.multiply = BH, me.nth = HD, me.noConflict = oH, me.noop = Uw, me.now = pg, me.pad = Oj, me.padEnd = Pj, me.padStart = Nj, me.parseInt = Mj, me.random = Ej, me.reduce = WF, me.reduceRight = VF, me.repeat = Rj, me.replace = Cj, me.result = dj, me.round = OH, me.runInContext = Fe, me.sample = ZF, me.size = JF, me.snakeCase = Uj, me.some = QF, me.sortedIndex = YD, me.sortedIndexBy = XD, me.sortedIndexOf = JD, me.sortedLastIndex = QD, me.sortedLastIndexBy = eF, me.sortedLastIndexOf = tF, me.startCase = Lj, me.startsWith = Dj, me.subtract = PH, me.sum = NH, me.sumBy = MH, me.template = Fj, me.times = yH, me.toFinite = $a, me.toInteger = pr, me.toLength = g4, me.toLower = zj, me.toNumber = Vo, me.toSafeInteger = zz, me.toString = Yr, me.toUpper = jj, me.trim = Hj, me.trimEnd = qj, me.trimStart = Kj, me.truncate = Wj, me.unescape = Vj, me.uniqueId = bH, me.upperCase = Gj, me.upperFirst = Nw, me.each = t4, me.eachRight = r4, me.first = X6, Cw(me, function() {
                var d = {};
                return qs(me, function(b, F) {
                    Qr.call(me.prototype, F) || (d[F] = b);
                }), d;
            }(), {
                chain: !1
            }), me.VERSION = n, zo([
                "bind",
                "bindKey",
                "curry",
                "curryRight",
                "partial",
                "partialRight"
            ], function(d) {
                me[d].placeholder = me;
            }), zo([
                "drop",
                "take"
            ], function(d, b) {
                Rr.prototype[d] = function(F) {
                    F = F === r ? 1 : Kn(pr(F), 0);
                    var oe = this.__filtered__ && !b ? new Rr(this) : this.clone();
                    return oe.__filtered__ ? oe.__takeCount__ = vi(F, oe.__takeCount__) : oe.__views__.push({
                        size: vi(F, L),
                        type: d + (oe.__dir__ < 0 ? "Right" : "")
                    }), oe;
                }, Rr.prototype[d + "Right"] = function(F) {
                    return this.reverse()[d](F).reverse();
                };
            }), zo([
                "filter",
                "map",
                "takeWhile"
            ], function(d, b) {
                var F = b + 1, oe = F == g || F == E;
                Rr.prototype[d] = function(ge) {
                    var ve = this.clone();
                    return ve.__iteratees__.push({
                        iteratee: Wt(ge, 3),
                        type: F
                    }), ve.__filtered__ = ve.__filtered__ || oe, ve;
                };
            }), zo([
                "head",
                "last"
            ], function(d, b) {
                var F = "take" + (b ? "Right" : "");
                Rr.prototype[d] = function() {
                    return this[F](1).value()[0];
                };
            }), zo([
                "initial",
                "tail"
            ], function(d, b) {
                var F = "drop" + (b ? "" : "Right");
                Rr.prototype[d] = function() {
                    return this.__filtered__ ? new Rr(this) : this[F](1);
                };
            }), Rr.prototype.compact = function() {
                return this.filter(Qi);
            }, Rr.prototype.find = function(d) {
                return this.filter(d).head();
            }, Rr.prototype.findLast = function(d) {
                return this.reverse().find(d);
            }, Rr.prototype.invokeMap = Tr(function(d, b) {
                return typeof d == "function" ? new Rr(this) : this.map(function(F) {
                    return rh(F, d, b);
                });
            }), Rr.prototype.reject = function(d) {
                return this.filter(yg(Wt(d)));
            }, Rr.prototype.slice = function(d, b) {
                d = pr(d);
                var F = this;
                return F.__filtered__ && (d > 0 || b < 0) ? new Rr(F) : (d < 0 ? F = F.takeRight(-d) : d && (F = F.drop(d)), b !== r && (b = pr(b), F = b < 0 ? F.dropRight(-b) : F.take(b - d)), F);
            }, Rr.prototype.takeRightWhile = function(d) {
                return this.reverse().takeWhile(d).reverse();
            }, Rr.prototype.toArray = function() {
                return this.take(L);
            }, qs(Rr.prototype, function(d, b) {
                var F = /^(?:filter|find|map|reject)|While$/.test(b), oe = /^(?:head|last)$/.test(b), ge = me[oe ? "take" + (b == "last" ? "Right" : "") : b], ve = oe || /^find/.test(b);
                ge && (me.prototype[b] = function() {
                    var Oe = this.__wrapped__, $e = oe ? [
                        1
                    ] : arguments, He = Oe instanceof Rr, it = $e[0], st = He || ur(Oe), ft = function(Pr) {
                        var Lr = ge.apply(me, vc([
                            Pr
                        ], $e));
                        return oe && At ? Lr[0] : Lr;
                    };
                    st && F && typeof it == "function" && it.length != 1 && (He = st = !1);
                    var At = this.__chain__, Ut = !!this.__actions__.length, Vt = ve && !At, vr = He && !Ut;
                    if (!ve && st) {
                        Oe = vr ? Oe : new Rr(this);
                        var Gt = d.apply(Oe, $e);
                        return Gt.__actions__.push({
                            func: dg,
                            args: [
                                ft
                            ],
                            thisArg: r
                        }), new Ho(Gt, At);
                    }
                    return Vt && vr ? d.apply(this, $e) : (Gt = this.thru(ft), Vt ? oe ? Gt.value()[0] : Gt.value() : Gt);
                });
            }), zo([
                "pop",
                "push",
                "shift",
                "sort",
                "splice",
                "unshift"
            ], function(d) {
                var b = L0[d], F = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru", oe = /^(?:pop|shift)$/.test(d);
                me.prototype[d] = function() {
                    var ge = arguments;
                    if (oe && !this.__chain__) {
                        var ve = this.value();
                        return b.apply(ur(ve) ? ve : [], ge);
                    }
                    return this[F](function(Oe) {
                        return b.apply(ur(Oe) ? Oe : [], ge);
                    });
                };
            }), qs(Rr.prototype, function(d, b) {
                var F = me[b];
                if (F) {
                    var oe = F.name + "";
                    Qr.call(el, oe) || (el[oe] = []), el[oe].push({
                        name: b,
                        func: F
                    });
                }
            }), el[og(r, N).name] = [
                {
                    name: "wrapper",
                    func: r
                }
            ], Rr.prototype.clone = V$, Rr.prototype.reverse = G$, Rr.prototype.value = Z$, me.prototype.at = SF, me.prototype.chain = AF, me.prototype.commit = TF, me.prototype.next = kF, me.prototype.plant = BF, me.prototype.reverse = OF, me.prototype.toJSON = me.prototype.valueOf = me.prototype.value = PF, me.prototype.first = me.prototype.head, Zd && (me.prototype[Zd] = IF), me;
        }, Xf = T$();
        Mu ? ((Mu.exports = Xf)._ = Xf, R1._ = Xf) : ci._ = Xf;
    }).call(Ge);
})(Sm, Sm.exports);
var dce = Sm.exports;
Object.defineProperty(c1, "__esModule", {
    value: !0
});
c1.SandshrewProvider = void 0;
const hce = _0, pce = dce;
let gce = 0;
class yce extends hce.AbstractProvider {
    constructor(t){
        super(), this.url = t;
    }
    async call(t, r) {
        const n = await (await fetch(this.url, {
            method: "POST",
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: gce++,
                params: r,
                method: t
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).text();
        return JSON.parse(n).result;
    }
    async enrichOutput({ vout: t, txid: r }) {
        return await this.call("ord_output", [
            `${r}:${t}`
        ]);
    }
    async getBTCOnlyUTXOs(t) {
        const r = await this.getUTXOs(t), { inscriptions: n } = await this.call("ord_address", [
            t
        ]), i = (0, pce.zipObject)(n, n);
        return r.filter((o)=>!i[`${o.outpoint.txid}:${o.outpoint.vout}`] && o.runes.length === 0);
    }
    async getUTXOs(t) {
        return (await this.call("alkanes_protorunesbyaddress", [
            {
                address: t,
                protocolTag: "1"
            }
        ])).outpoints;
    }
}
c1.SandshrewProvider = yce;
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(_0, e), r(E0, e), r(a1, e), r(c1, e);
})(uM);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(h0, e), r(eM, e), r(Jr, e), r(uo, e), r(w0, e), r(uM, e);
})(ec);
const kI = BigInt(546), mce = 77;
function gx(e, t, r) {
    const a = e * 64 + t * 42, u = r * 40;
    return 10 + a + u;
}
const iu = 546n, Jo = {
    mainnet: {
        p2pkh: /^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(bc1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(bc1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    },
    testnet: {
        p2pkh: /^[mn][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[2][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(tb1[qp]|bcrt1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(tb1p|bcrt1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    },
    regtest: {
        p2pkh: /^[mn][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[2][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(tb1[qp]|bcrt1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(tb1p|bcrt1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    }
};
function bce(e) {
    return Jo.mainnet.p2pkh.test(e) || Jo.testnet.p2pkh.test(e) || Jo.regtest.p2pkh.test(e) ? 0 : Jo.mainnet.p2tr.test(e) || Jo.testnet.p2tr.test(e) || Jo.regtest.p2tr.test(e) ? 1 : Jo.mainnet.p2sh.test(e) || Jo.testnet.p2sh.test(e) || Jo.regtest.p2sh.test(e) ? 2 : Jo.mainnet.p2wpkh.test(e) || Jo.testnet.p2wpkh.test(e) || Jo.regtest.p2wpkh.test(e) ? 3 : null;
}
function Am(e, t) {
    let r = 0;
    const n = [];
    for (const i of e){
        if (r >= t) break;
        n.push(i), r += i.btcValue;
    }
    return {
        utxos: n,
        totalAmount: r
    };
}
const fM = async ({ _psbt: e, senderPublicKey: t, network: r })=>{
    let n = 0;
    for await (const i of e.data.inputs){
        const o = i.finalScriptSig || i.finalScriptWitness, s = !i.tapInternalKey;
        if (!o || s) {
            const a = Mo(We.from(t, "hex")), u = xd({
                internalPubkey: a,
                network: r
            });
            (i.witnessUtxo && We.from(i.witnessUtxo.script).toString("hex")) === (u.output && We.from(u.output).toString("hex")) && e.updateInput(n, {
                tapInternalKey: a
            });
        }
        n++;
    }
    return e;
}, wce = async ({ address: e, greatestToLeast: t, client: r, alkaneId: n, targetNumberOfAlkanes: i })=>{
    const a = (await r.dataSourceManager.getAlkanesByAddress(e)).flatMap((l)=>l.runes.filter((p)=>Number(p.rune.id.block) === Number(n.block) && Number(p.rune.id.tx) === Number(n.tx)).map((p)=>({
                rune: p,
                outpoint: l
            }))).sort((l, p)=>t ? Number(p.rune.balance) - Number(l.rune.balance) : Number(l.rune.balance) - Number(p.rune.balance));
    let u = 0, f = 0;
    const c = [];
    for (const l of a)if (f < i && Number(l.rune.balance) > 0) {
        const p = Number(l.outpoint.output.value);
        c.push({
            txId: l.outpoint.outpoint.txid,
            txIndex: l.outpoint.outpoint.vout,
            script: l.outpoint.output.script,
            address: e,
            amountOfAlkanes: l.rune.balance,
            satoshis: p,
            ...l.rune.rune
        }), u += p, f += Number(l.rune.balance) / (l.rune.rune.divisibility === 1 ? 1 : 10 ** l.rune.rune.divisibility);
    }
    if (f < i) throw new Error("Insuffiecient balance of alkanes.");
    return {
        alkaneUtxos: c,
        totalSatoshis: u,
        totalBalanceBeingSent: f
    };
};
async function Tm(e, t, { pubkey: r } = {}) {
    switch(bce(t.address)){
        case 0:
            {
                e.addInput({
                    hash: t.txHash,
                    index: +t.txOutputIndex
                });
                break;
            }
        case 2:
            {
                if (!r) throw new Error("Pubkey is required for nested SegWit");
                const i = Ri([
                    Kr.OP_0,
                    Rs(We.from(r, "hex"))
                ]);
                e.addInput({
                    hash: t.txHash,
                    index: +t.txOutputIndex,
                    redeemScript: i,
                    witnessUtxo: {
                        value: BigInt(t.btcValue),
                        script: Ri([
                            Kr.OP_HASH160,
                            Rs(i),
                            Kr.OP_EQUAL
                        ])
                    }
                });
                break;
            }
        case 1:
        case 3:
        default:
            e.addInput({
                hash: t.txHash,
                index: +t.txOutputIndex,
                witnessUtxo: {
                    value: BigInt(t.btcValue),
                    script: We.from(t.scriptPubKey, "hex")
                }
            });
    }
}
const vce = async ({ utxos: e, account: t, alkaneId: r, client: n, toAddress: i, amount: o, feeRate: s, fee: a })=>{
    const u = {
        utxos: e,
        totalAmount: e.reduce((R, X)=>R + X.btcValue, 0)
    }, f = gx(2, 0, 4), c = BigInt(Math.max(f * s, 250));
    let l = a ? BigInt(a) : c, p = Am(u.utxos, Number(l) + Number(iu) * 4);
    const y = [
        BigInt(2),
        BigInt(100),
        BigInt(77)
    ], _ = ec.encodeRunestoneProtostone({
        protostones: [
            ec.ProtoStone.message({
                protocolTag: 1n,
                pointer: 0,
                refundPointer: 0,
                calldata: ec.encipher(y),
                edicts: []
            })
        ]
    }).encodedRunestone;
    if (console.log("protostone23", _.toString("hex")), p.totalAmount < l + iu) throw console.log("gatheredUtxos.totalAmount", p.totalAmount), new Error("Insufficient Balanceeeee");
    if (p.utxos.length > 1) {
        const R = gx(p.utxos.length, 0, 4);
        l = BigInt(Math.max(R * s, 250)), p = Am(u.utxos, Number(l) + Number(iu));
    }
    const A = l + iu * 2n, O = n.$network.get(), N = new Cr({
        network: Dr(O)
    }), { alkaneUtxos: U } = await wce({
        address: t.taproot.address,
        greatestToLeast: t.spendStrategy.utxoSortGreatestToLeast,
        alkaneId: r,
        client: n,
        targetNumberOfAlkanes: o
    });
    if (U.length === 0) throw new Error("No Alkane Utxos Found");
    let D = 0n;
    const H = /* @__PURE__ */ new Set();
    for await (const R of U)Tm(N, {
        txHash: R.txId,
        txOutputIndex: R.txIndex,
        btcValue: R.satoshis,
        scriptPubKey: R.script,
        address: R.address
    }), D += BigInt(R.satoshis), H.add(`${R.txId}:${R.txIndex.toString()}`);
    if (p.totalAmount < A) throw new Error("Insufficient Balance");
    for (const R of p.utxos){
        if (D > A) break;
        H.has(`${R.txHash}:${R.txOutputIndex.toString()}`) || (Tm(N, R), D += BigInt(R.btcValue), H.add(`${R.txHash}:${R.txOutputIndex.toString()}`));
    }
    const K = ec.encodeRunestoneProtostone({
        protostones: [
            ec.ProtoStone.message({
                protocolTag: 1n,
                edicts: [
                    {
                        id: new YN(qh.u128(BigInt(r.block)), qh.u128(BigInt(r.tx))),
                        amount: qh.u128(BigInt(o)),
                        output: Qn.u32(1n)
                    }
                ],
                pointer: 0,
                refundPointer: 0,
                calldata: We.from([])
            })
        ]
    }).encodedRunestone;
    N.addOutput({
        value: iu,
        address: t.taproot.address
    }), N.addOutput({
        value: iu,
        address: i
    }), N.addOutput({
        script: K,
        value: 0n
    });
    const re = N.txOutputs.reduce((R, X)=>R + X.value, 0n), Q = D - re - l;
    return N.addOutput({
        address: t[t.spendStrategy.changeAddress].address,
        value: Q
    }), {
        psbt: (await fM({
            _psbt: N,
            senderPublicKey: t.taproot.pubkey,
            network: Dr(O)
        })).toBase64()
    };
}, _ce = async ({ toAddress: e, network: t, alkaneId: r, changeAddress: n, frontendFeeAddress: i, frontendFeeAmount: o, feeRate: s = 1, spendableUtxos: a, inputAlkaneUtxos: u, senderPublicKey: f, inputData: c })=>{
    const l = [
        r.block,
        r.tx,
        BigInt(mce),
        ...c ?? []
    ], p = ec.encodeRunestoneProtostone({
        protostones: [
            ec.ProtoStone.message({
                protocolTag: 1n,
                calldata: ec.encipher(l),
                pointer: 0,
                refundPointer: 0
            })
        ]
    }).encodedRunestone, y = Dr(t), _ = new Cr({
        network: y
    }), A = i && o && o >= kI ? o : 0n, O = A + BigInt(iu);
    function N(g) {
        return gx(g, 0, 2 + (A > 0 ? 1 : 0)) + p.byteLength;
    }
    const U = N(2), D = BigInt(Math.ceil(Math.max(U * s, 250)));
    let H = {
        utxos: a,
        totalAmount: a.reduce((g, m)=>g + m.btcValue, 0)
    };
    if (H = Am(H.utxos, Number(D) + Number(O)), H.utxos.length < 1) throw new Error("Insufficient balance");
    const K = N(H.utxos.length), re = BigInt(Math.ceil(Math.max(K * s, 250)));
    H.totalAmount < re && (H = Am(H.utxos, Number(re) + Number(O)));
    const Q = N(H.utxos.length), G = BigInt(Math.ceil(Math.max(Q * s, 250)));
    if (H.totalAmount < G) throw new Error("Insufficient balance");
    for (const g of u)Tm(_, g);
    for (const g of H.utxos)Tm(_, g);
    console.log("protostone byte length", p.length), _.addOutput({
        value: BigInt(iu),
        address: e
    }), _.addOutput({
        script: p,
        value: 0n
    }), i && o && o > 0 && _.addOutput({
        value: o,
        address: i
    });
    const R = u ? u.reduce((g, m)=>g + BigInt(m.btcValue), 0n) : 0n, X = BigInt(H.totalAmount) + R, $ = _.txOutputs.reduce((g, m)=>g + m.value, 0n), S = X - $ - G;
    if (S < 0) throw new Error("Insufficient balance");
    S >= kI && _.addOutput({
        address: n,
        value: S
    });
    const w = await fM({
        _psbt: _,
        senderPublicKey: f,
        network: y
    });
    return {
        psbtBase64: w.toBase64(),
        psbtHex: w.toHex()
    };
};
class lM {
    constructor(t){
        this.client = t;
    }
    async send(t, r, n) {
        const { connected: i, address: o, publicKey: s } = this.client.$store.get();
        if (!i) throw new Error("Client is not connected");
        const a = {
            block: t.split(":")[0],
            tx: t.split(":")[1]
        };
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const u = this.client.$network.get(), c = {
            network: Dr(u),
            spendStrategy: {
                utxoSortGreatestToLeast: !0,
                changeAddress: "taproot",
                addressOrder: [
                    "taproot",
                    "nestedSegwit",
                    "legacy",
                    "nativeSegwit"
                ]
            },
            taproot: {
                address: o,
                pubkey: s,
                pubKeyXOnly: Mo(We.from(s, "hex")).toString(),
                hdPath: "m/84'/1'/0'/0/0"
            },
            nestedSegwit: {
                address: o,
                pubkey: s,
                hdPath: "m/84'/1'/0'/0/0"
            },
            legacy: {
                address: o,
                pubkey: s,
                hdPath: "m/49'/1'/0'/0/0"
            },
            nativeSegwit: {
                address: o,
                pubkey: s,
                hdPath: "m/84'/1'/0'/0/0"
            }
        }, { fastFee: l } = await this.client.dataSourceManager.getRecommendedFees(), p = await this.client.dataSourceManager.getFormattedUTXOs(o), { psbt: y } = await vce({
            utxos: p,
            account: c,
            alkaneId: a,
            client: this.client,
            toAddress: n,
            amount: r,
            feeRate: l
        }), _ = await this.client.signPsbt({
            tx: y,
            broadcast: !0,
            finalize: !0
        });
        if (!_) throw new Error("Failed to sign transaction");
        if (_.txId) return _.txId;
        const A = await this.client.pushPsbt(_.signedPsbtHex ?? _.signedPsbtBase64);
        if (A) return A;
        throw new Error("Failed to broadcast transaction");
    }
    async getAlkanes({ limit: t = 10, offset: r }) {
        return (await this.client.dataSourceManager.getSource("sandshrew").alkanesRpc.getAlkanes({
            limit: t,
            offset: r
        })).flatMap((i)=>({
                ...i
            }));
    }
    async getAlkaneById(t) {
        return await this.client.dataSourceManager.getSource("sandshrew").alkanesRpc.getAlkaneById(t);
    }
    async mintAlkane({ toAddress: t, id: r, changeAddress: n, feeRate: i, inputData: o }) {
        const s = this.client.$network.get(), { connected: a, address: u, publicKey: f } = this.client.$store.get();
        if (!a) throw new Error("Client is not connected");
        const c = await this.client.dataSourceManager.getFormattedUTXOs(u), { utxos: l } = Vae(c), p = c.filter((N)=>N.hasAlkanes && !1), { fastFee: y } = await this.client.dataSourceManager.getRecommendedFees(), { psbtBase64: _ } = await _ce({
            alkaneId: r,
            network: s,
            toAddress: t ?? u,
            changeAddress: n ?? u,
            senderPublicKey: f,
            inputAlkaneUtxos: p,
            spendableUtxos: l,
            feeRate: i ?? y,
            inputData: o
        }), A = await this.client.signPsbt({
            tx: _,
            broadcast: !0,
            finalize: !0
        });
        if (!A) throw new Error("Failed to sign transaction");
        if (A.txId) return A.txId;
        const O = await this.client.pushPsbt(A.signedPsbtHex ?? A.signedPsbtBase64);
        if (O) return O;
        throw new Error("Failed to broadcast transaction");
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ES = /* @__PURE__ */ BigInt(0), yx = /* @__PURE__ */ BigInt(1);
function km(e, t) {
    if (typeof t != "boolean") throw new Error(e + " boolean expected, got " + t);
}
function fy(e) {
    const t = e.toString(16);
    return t.length & 1 ? "0" + t : t;
}
function dM(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return e === "" ? ES : BigInt("0x" + e);
}
function u1(e) {
    return dM(Hr.bytesToHex(e));
}
function hM(e) {
    return Hr.abytes(e), dM(Hr.bytesToHex(Uint8Array.from(e).reverse()));
}
function xS(e, t) {
    return Hr.hexToBytes(e.toString(16).padStart(t * 2, "0"));
}
function pM(e, t) {
    return xS(e, t).reverse();
}
function ss(e, t, r) {
    let n;
    if (typeof t == "string") try {
        n = Hr.hexToBytes(t);
    } catch (o) {
        throw new Error(e + " must be hex string or Uint8Array, cause: " + o);
    }
    else if (Hr.isBytes(t)) n = Uint8Array.from(t);
    else throw new Error(e + " must be hex string or Uint8Array");
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(e + " of length " + r + " expected, got " + i);
    return n;
}
const K_ = (e)=>typeof e == "bigint" && ES <= e;
function Ece(e, t, r) {
    return K_(e) && K_(t) && K_(r) && t <= e && e < r;
}
function xce(e, t, r, n) {
    if (!Ece(t, r, n)) throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Sce(e) {
    let t;
    for(t = 0; e > ES; e >>= yx, t += 1);
    return t;
}
const f1 = (e)=>(yx << BigInt(e)) - yx;
function Ace(e, t, r) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    const n = (y)=>new Uint8Array(y), i = (y)=>Uint8Array.of(y);
    let o = n(e), s = n(e), a = 0;
    const u = ()=>{
        o.fill(1), s.fill(0), a = 0;
    }, f = (...y)=>r(s, o, ...y), c = (y = n(0))=>{
        s = f(i(0), y), o = f(), y.length !== 0 && (s = f(i(1), y), o = f());
    }, l = ()=>{
        if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let y = 0;
        const _ = [];
        for(; y < t;){
            o = f();
            const A = o.slice();
            _.push(A), y += o.length;
        }
        return Hr.concatBytes(..._);
    };
    return (y, _)=>{
        u(), c(y);
        let A;
        for(; !(A = _(l()));)c();
        return u(), A;
    };
}
function SS(e, t, r = {}) {
    if (!e || typeof e != "object") throw new Error("expected valid options object");
    function n(i, o, s) {
        const a = e[i];
        if (s && a === void 0) return;
        const u = typeof a;
        if (u !== o || a === null) throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`);
    }
    Object.entries(t).forEach(([i, o])=>n(i, o, !1)), Object.entries(r).forEach(([i, o])=>n(i, o, !0));
}
function II(e) {
    const t = /* @__PURE__ */ new WeakMap();
    return (r, ...n)=>{
        const i = t.get(r);
        if (i !== void 0) return i;
        const o = e(r, ...n);
        return t.set(r, o), o;
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const fo = BigInt(0), Hi = BigInt(1), af = /* @__PURE__ */ BigInt(2), Tce = /* @__PURE__ */ BigInt(3), gM = /* @__PURE__ */ BigInt(4), yM = /* @__PURE__ */ BigInt(5), mM = /* @__PURE__ */ BigInt(8);
function Bo(e, t) {
    const r = e % t;
    return r >= fo ? r : t + r;
}
function Qo(e, t, r) {
    let n = e;
    for(; t-- > fo;)n *= n, n %= r;
    return n;
}
function BI(e, t) {
    if (e === fo) throw new Error("invert: expected non-zero number");
    if (t <= fo) throw new Error("invert: expected positive modulus, got " + t);
    let r = Bo(e, t), n = t, i = fo, o = Hi;
    for(; r !== fo;){
        const a = n / r, u = n % r, f = i - o * a;
        n = r, r = u, i = o, o = f;
    }
    if (n !== Hi) throw new Error("invert: does not exist");
    return Bo(i, t);
}
function bM(e, t) {
    const r = (e.ORDER + Hi) / gM, n = e.pow(t, r);
    if (!e.eql(e.sqr(n), t)) throw new Error("Cannot find square root");
    return n;
}
function kce(e, t) {
    const r = (e.ORDER - yM) / mM, n = e.mul(t, af), i = e.pow(n, r), o = e.mul(t, i), s = e.mul(e.mul(o, af), i), a = e.mul(o, e.sub(s, e.ONE));
    if (!e.eql(e.sqr(a), t)) throw new Error("Cannot find square root");
    return a;
}
function Ice(e) {
    if (e < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let t = e - Hi, r = 0;
    for(; t % af === fo;)t /= af, r++;
    let n = af;
    const i = x0(e);
    for(; OI(i, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return bM;
    let o = i.pow(n, t);
    const s = (t + Hi) / af;
    return function(u, f) {
        if (u.is0(f)) return f;
        if (OI(u, f) !== 1) throw new Error("Cannot find square root");
        let c = r, l = u.mul(u.ONE, o), p = u.pow(f, t), y = u.pow(f, s);
        for(; !u.eql(p, u.ONE);){
            if (u.is0(p)) return u.ZERO;
            let _ = 1, A = u.sqr(p);
            for(; !u.eql(A, u.ONE);)if (_++, A = u.sqr(A), _ === c) throw new Error("Cannot find square root");
            const O = Hi << BigInt(c - _ - 1), N = u.pow(l, O);
            c = _, l = u.sqr(N), p = u.mul(p, l), y = u.mul(y, N);
        }
        return y;
    };
}
function Bce(e) {
    return e % gM === Tce ? bM : e % mM === yM ? kce : Ice(e);
}
const Oce = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function Pce(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, r = Oce.reduce((n, i)=>(n[i] = "function", n), t);
    return SS(e, r), e;
}
function Nce(e, t, r) {
    if (r < fo) throw new Error("invalid exponent, negatives unsupported");
    if (r === fo) return e.ONE;
    if (r === Hi) return t;
    let n = e.ONE, i = t;
    for(; r > fo;)r & Hi && (n = e.mul(n, i)), i = e.sqr(i), r >>= Hi;
    return n;
}
function wM(e, t, r = !1) {
    const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, a, u)=>e.is0(a) ? s : (n[u] = s, e.mul(s, a)), e.ONE), o = e.inv(i);
    return t.reduceRight((s, a, u)=>e.is0(a) ? s : (n[u] = e.mul(s, n[u]), e.mul(s, a)), o), n;
}
function OI(e, t) {
    const r = (e.ORDER - Hi) / af, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), s = e.eql(n, e.neg(e.ONE));
    if (!i && !o && !s) throw new Error("invalid Legendre symbol result");
    return i ? 1 : o ? 0 : -1;
}
function Mce(e, t) {
    t !== void 0 && Hr.anumber(t);
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function x0(e, t, r = !1, n = {}) {
    if (e <= fo) throw new Error("invalid field: expected ORDER > 0, got " + e);
    let i, o;
    if (typeof t == "object" && t != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const c = t;
        c.BITS && (i = c.BITS), c.sqrt && (o = c.sqrt), typeof c.isLE == "boolean" && (r = c.isLE);
    } else typeof t == "number" && (i = t), n.sqrt && (o = n.sqrt);
    const { nBitLength: s, nByteLength: a } = Mce(e, i);
    if (a > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const f = Object.freeze({
        ORDER: e,
        isLE: r,
        BITS: s,
        BYTES: a,
        MASK: f1(s),
        ZERO: fo,
        ONE: Hi,
        create: (c)=>Bo(c, e),
        isValid: (c)=>{
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return fo <= c && c < e;
        },
        is0: (c)=>c === fo,
        // is valid and invertible
        isValidNot0: (c)=>!f.is0(c) && f.isValid(c),
        isOdd: (c)=>(c & Hi) === Hi,
        neg: (c)=>Bo(-c, e),
        eql: (c, l)=>c === l,
        sqr: (c)=>Bo(c * c, e),
        add: (c, l)=>Bo(c + l, e),
        sub: (c, l)=>Bo(c - l, e),
        mul: (c, l)=>Bo(c * l, e),
        pow: (c, l)=>Nce(f, c, l),
        div: (c, l)=>Bo(c * BI(l, e), e),
        // Same as above, but doesn't normalize
        sqrN: (c)=>c * c,
        addN: (c, l)=>c + l,
        subN: (c, l)=>c - l,
        mulN: (c, l)=>c * l,
        inv: (c)=>BI(c, e),
        sqrt: o || ((c)=>(u || (u = Bce(e)), u(f, c))),
        toBytes: (c)=>r ? pM(c, a) : xS(c, a),
        fromBytes: (c)=>{
            if (c.length !== a) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + c.length);
            return r ? hM(c) : u1(c);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (c)=>wM(f, c),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (c, l, p)=>p ? l : c
    });
    return Object.freeze(f);
}
function vM(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function _M(e) {
    const t = vM(e);
    return t + Math.ceil(t / 2);
}
function Rce(e, t, r = !1) {
    const n = e.length, i = vM(t), o = _M(t);
    if (n < 16 || n < o || n > 1024) throw new Error("expected " + o + "-1024 bytes of input, got " + n);
    const s = r ? hM(e) : u1(e), a = Bo(s, t - Hi) + Hi;
    return r ? pM(a, i) : xS(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ad = BigInt(0), cf = BigInt(1);
function Gh(e, t) {
    const r = t.negate();
    return e ? r : t;
}
function Cce(e, t, r) {
    const n = (s)=>s.pz, i = wM(e.Fp, r.map(n));
    return r.map((s, a)=>s.toAffine(i[a])).map(e.fromAffine);
}
function EM(e, t) {
    if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function W_(e, t) {
    EM(e, t);
    const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = f1(e), s = BigInt(e);
    return {
        windows: r,
        windowSize: n,
        mask: o,
        maxNumber: i,
        shiftBy: s
    };
}
function PI(e, t, r) {
    const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = r;
    let a = Number(e & i), u = e >> s;
    a > n && (a -= o, u += cf);
    const f = t * n, c = f + Math.abs(a) - 1, l = a === 0, p = a < 0, y = t % 2 !== 0;
    return {
        nextN: u,
        offset: c,
        isZero: l,
        isNeg: p,
        isNegF: y,
        offsetF: f
    };
}
function Uce(e, t) {
    if (!Array.isArray(e)) throw new Error("array expected");
    e.forEach((r, n)=>{
        if (!(r instanceof t)) throw new Error("invalid point at index " + n);
    });
}
function $ce(e, t) {
    if (!Array.isArray(e)) throw new Error("array of scalars expected");
    e.forEach((r, n)=>{
        if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
    });
}
const V_ = /* @__PURE__ */ new WeakMap(), xM = /* @__PURE__ */ new WeakMap();
function G_(e) {
    return xM.get(e) || 1;
}
function NI(e) {
    if (e !== ad) throw new Error("invalid wNAF");
}
function Lce(e, t) {
    return {
        constTimeNegate: Gh,
        hasPrecomputes (r) {
            return G_(r) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (r, n, i = e.ZERO) {
            let o = r;
            for(; n > ad;)n & cf && (i = i.add(o)), o = o.double(), n >>= cf;
            return i;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (r, n) {
            const { windows: i, windowSize: o } = W_(n, t), s = [];
            let a = r, u = a;
            for(let f = 0; f < i; f++){
                u = a, s.push(u);
                for(let c = 1; c < o; c++)u = u.add(a), s.push(u);
                a = u.double();
            }
            return s;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (r, n, i) {
            let o = e.ZERO, s = e.BASE;
            const a = W_(r, t);
            for(let u = 0; u < a.windows; u++){
                const { nextN: f, offset: c, isZero: l, isNeg: p, isNegF: y, offsetF: _ } = PI(i, u, a);
                i = f, l ? s = s.add(Gh(y, n[_])) : o = o.add(Gh(p, n[c]));
            }
            return NI(i), {
                p: o,
                f: s
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (r, n, i, o = e.ZERO) {
            const s = W_(r, t);
            for(let a = 0; a < s.windows && i !== ad; a++){
                const { nextN: u, offset: f, isZero: c, isNeg: l } = PI(i, a, s);
                if (i = u, !c) {
                    const p = n[f];
                    o = o.add(l ? p.negate() : p);
                }
            }
            return NI(i), o;
        },
        getPrecomputes (r, n, i) {
            let o = V_.get(n);
            return o || (o = this.precomputeWindow(n, r), r !== 1 && (typeof i == "function" && (o = i(o)), V_.set(n, o))), o;
        },
        wNAFCached (r, n, i) {
            const o = G_(r);
            return this.wNAF(o, this.getPrecomputes(o, r, i), n);
        },
        wNAFCachedUnsafe (r, n, i, o) {
            const s = G_(r);
            return s === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, r, i), n, o);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (r, n) {
            EM(n, t), xM.set(r, n), V_.delete(r);
        }
    };
}
function Dce(e, t, r, n) {
    let i = t, o = e.ZERO, s = e.ZERO;
    for(; r > ad || n > ad;)r & cf && (o = o.add(i)), n & cf && (s = s.add(i)), i = i.double(), r >>= cf, n >>= cf;
    return {
        p1: o,
        p2: s
    };
}
function Fce(e, t, r, n) {
    Uce(r, e), $ce(n, t);
    const i = r.length, o = n.length;
    if (i !== o) throw new Error("arrays of points and scalars must have equal length");
    const s = e.ZERO, a = Sce(BigInt(i));
    let u = 1;
    a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
    const f = f1(u), c = new Array(Number(f) + 1).fill(s), l = Math.floor((t.BITS - 1) / u) * u;
    let p = s;
    for(let y = l; y >= 0; y -= u){
        c.fill(s);
        for(let A = 0; A < o; A++){
            const O = n[A], N = Number(O >> BigInt(y) & f);
            c[N] = c[N].add(r[A]);
        }
        let _ = s;
        for(let A = c.length - 1, O = s; A > 0; A--)O = O.add(c[A]), _ = _.add(O);
        if (p = p.add(_), y !== 0) for(let A = 0; A < u; A++)p = p.double();
    }
    return p;
}
function MI(e, t) {
    if (t) {
        if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return Pce(t), t;
    } else return x0(e);
}
function zce(e, t, r = {}) {
    if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const u = t[a];
        if (!(typeof u == "bigint" && u > ad)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const n = MI(t.p, r.Fp), i = MI(t.n, r.Fn), s = [
        "Gx",
        "Gy",
        "a",
        "b"
    ];
    for (const a of s)if (!n.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function RI(e) {
    e.lowS !== void 0 && km("lowS", e.lowS), e.prehash !== void 0 && km("prehash", e.prehash);
}
class jce extends Error {
    constructor(t = ""){
        super(t);
    }
}
const Ja = {
    // asn.1 DER encoding utils
    Err: jce,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (e, t)=>{
            const { Err: r } = Ja;
            if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
            if (t.length & 1) throw new r("tlv.encode: unpadded data");
            const n = t.length / 2, i = fy(n);
            if (i.length / 2 & 128) throw new r("tlv.encode: long form length too big");
            const o = n > 127 ? fy(i.length / 2 | 128) : "";
            return fy(e) + o + i + t;
        },
        // v - value, l - left bytes (unparsed)
        decode (e, t) {
            const { Err: r } = Ja;
            let n = 0;
            if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
            if (t.length < 2 || t[n++] !== e) throw new r("tlv.decode: wrong tlv");
            const i = t[n++], o = !!(i & 128);
            let s = 0;
            if (!o) s = i;
            else {
                const u = i & 127;
                if (!u) throw new r("tlv.decode(long): indefinite length not supported");
                if (u > 4) throw new r("tlv.decode(long): byte length is too big");
                const f = t.subarray(n, n + u);
                if (f.length !== u) throw new r("tlv.decode: length bytes not complete");
                if (f[0] === 0) throw new r("tlv.decode(long): zero leftmost byte");
                for (const c of f)s = s << 8 | c;
                if (n += u, s < 128) throw new r("tlv.decode(long): not minimal encoding");
            }
            const a = t.subarray(n, n + s);
            if (a.length !== s) throw new r("tlv.decode: wrong value length");
            return {
                v: a,
                l: t.subarray(n + s)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (e) {
            const { Err: t } = Ja;
            if (e < Zh) throw new t("integer: negative integers are not allowed");
            let r = fy(e);
            if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1) throw new t("unexpected DER parsing assertion: unpadded hex");
            return r;
        },
        decode (e) {
            const { Err: t } = Ja;
            if (e[0] & 128) throw new t("invalid signature integer: negative");
            if (e[0] === 0 && !(e[1] & 128)) throw new t("invalid signature integer: unnecessary leading zero");
            return u1(e);
        }
    },
    toSig (e) {
        const { Err: t, _int: r, _tlv: n } = Ja, i = ss("signature", e), { v: o, l: s } = n.decode(48, i);
        if (s.length) throw new t("invalid signature: left bytes after parsing");
        const { v: a, l: u } = n.decode(2, o), { v: f, l: c } = n.decode(2, u);
        if (c.length) throw new t("invalid signature: left bytes after parsing");
        return {
            r: r.decode(a),
            s: r.decode(f)
        };
    },
    hexFromSig (e) {
        const { _tlv: t, _int: r } = Ja, n = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = n + i;
        return t.encode(48, o);
    }
}, Zh = BigInt(0), Yh = BigInt(1), Hce = BigInt(2), ly = BigInt(3), qce = BigInt(4);
function Kce(e, t, r) {
    function n(i) {
        const o = e.sqr(i), s = e.mul(o, i);
        return e.add(e.add(s, e.mul(i, t)), r);
    }
    return n;
}
function SM(e, t, r) {
    const { BYTES: n } = e;
    function i(o) {
        let s;
        if (typeof o == "bigint") s = o;
        else {
            let a = ss("private key", o);
            if (t) {
                if (!t.includes(a.length * 2)) throw new Error("invalid private key");
                const u = new Uint8Array(n);
                u.set(a, u.length - a.length), a = u;
            }
            try {
                s = e.fromBytes(a);
            } catch  {
                throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof o}`);
            }
        }
        if (r && (s = e.create(s)), !e.isValidNot0(s)) throw new Error("invalid private key: out of range [1..N-1]");
        return s;
    }
    return i;
}
function Wce(e, t = {}) {
    const { Fp: r, Fn: n } = zce("weierstrass", e, t), { h: i, n: o } = e;
    SS(t, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const { endo: s } = t;
    if (s && (!r.is0(e.a) || typeof s.beta != "bigint" || typeof s.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    function a() {
        if (!r.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function u(G, R, X) {
        const { x: $, y: S } = R.toAffine(), w = r.toBytes($);
        if (km("isCompressed", X), X) {
            a();
            const g = !r.isOdd(S);
            return Hr.concatBytes(AM(g), w);
        } else return Hr.concatBytes(Uint8Array.of(4), w, r.toBytes(S));
    }
    function f(G) {
        Hr.abytes(G);
        const R = r.BYTES, X = R + 1, $ = 2 * R + 1, S = G.length, w = G[0], g = G.subarray(1);
        if (S === X && (w === 2 || w === 3)) {
            const m = r.fromBytes(g);
            if (!r.isValid(m)) throw new Error("bad point: is not on curve, wrong x");
            const E = p(m);
            let T;
            try {
                T = r.sqrt(E);
            } catch (k) {
                const L = k instanceof Error ? ": " + k.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + L);
            }
            a();
            const I = r.isOdd(T);
            return (w & 1) === 1 !== I && (T = r.neg(T)), {
                x: m,
                y: T
            };
        } else if (S === $ && w === 4) {
            const m = r.fromBytes(g.subarray(R * 0, R * 1)), E = r.fromBytes(g.subarray(R * 1, R * 2));
            if (!y(m, E)) throw new Error("bad point: is not on curve");
            return {
                x: m,
                y: E
            };
        } else throw new Error(`bad point: got length ${S}, expected compressed=${X} or uncompressed=${$}`);
    }
    const c = t.toBytes || u, l = t.fromBytes || f, p = Kce(r, e.a, e.b);
    function y(G, R) {
        const X = r.sqr(R), $ = p(G);
        return r.eql(X, $);
    }
    if (!y(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
    const _ = r.mul(r.pow(e.a, ly), qce), A = r.mul(r.sqr(e.b), BigInt(27));
    if (r.is0(r.add(_, A))) throw new Error("bad curve params: a or b");
    function O(G, R, X = !1) {
        if (!r.isValid(R) || X && r.is0(R)) throw new Error(`bad point coordinate ${G}`);
        return R;
    }
    function N(G) {
        if (!(G instanceof K)) throw new Error("ProjectivePoint expected");
    }
    const U = II((G, R)=>{
        const { px: X, py: $, pz: S } = G;
        if (r.eql(S, r.ONE)) return {
            x: X,
            y: $
        };
        const w = G.is0();
        R == null && (R = w ? r.ONE : r.inv(S));
        const g = r.mul(X, R), m = r.mul($, R), E = r.mul(S, R);
        if (w) return {
            x: r.ZERO,
            y: r.ZERO
        };
        if (!r.eql(E, r.ONE)) throw new Error("invZ was invalid");
        return {
            x: g,
            y: m
        };
    }), D = II((G)=>{
        if (G.is0()) {
            if (t.allowInfinityPoint && !r.is0(G.py)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: R, y: X } = G.toAffine();
        if (!r.isValid(R) || !r.isValid(X)) throw new Error("bad point: x or y not field elements");
        if (!y(R, X)) throw new Error("bad point: equation left != right");
        if (!G.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    function H(G, R, X, $, S) {
        return X = new K(r.mul(X.px, G), X.py, X.pz), R = Gh($, R), X = Gh(S, X), R.add(X);
    }
    class K {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(R, X, $){
            this.px = O("x", R), this.py = O("y", X, !0), this.pz = O("z", $), Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(R) {
            const { x: X, y: $ } = R || {};
            if (!R || !r.isValid(X) || !r.isValid($)) throw new Error("invalid affine point");
            if (R instanceof K) throw new Error("projective point not allowed");
            return r.is0(X) && r.is0($) ? K.ZERO : new K(X, $, r.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(R) {
            return Cce(K, "pz", R);
        }
        static fromBytes(R) {
            return Hr.abytes(R), K.fromHex(R);
        }
        /** Converts hash string or Uint8Array to Point. */ static fromHex(R) {
            const X = K.fromAffine(l(ss("pointHex", R)));
            return X.assertValidity(), X;
        }
        /** Multiplies generator point by privateKey. */ static fromPrivateKey(R) {
            const X = SM(n, t.allowedPrivateKeyLengths, t.wrapPrivateKey);
            return K.BASE.multiply(X(R));
        }
        /** Multiscalar Multiplication */ static msm(R, X) {
            return Fce(K, n, R, X);
        }
        /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */ precompute(R = 8, X = !0) {
            return Q.setWindowSize(this, R), X || this.multiply(ly), this;
        }
        /** "Private method", don't use it directly */ _setWindowSize(R) {
            this.precompute(R);
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */ assertValidity() {
            D(this);
        }
        hasEvenY() {
            const { y: R } = this.toAffine();
            if (!r.isOdd) throw new Error("Field doesn't support isOdd");
            return !r.isOdd(R);
        }
        /** Compare one point to another. */ equals(R) {
            N(R);
            const { px: X, py: $, pz: S } = this, { px: w, py: g, pz: m } = R, E = r.eql(r.mul(X, m), r.mul(w, S)), T = r.eql(r.mul($, m), r.mul(g, S));
            return E && T;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
            return new K(this.px, r.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: R, b: X } = e, $ = r.mul(X, ly), { px: S, py: w, pz: g } = this;
            let m = r.ZERO, E = r.ZERO, T = r.ZERO, I = r.mul(S, S), P = r.mul(w, w), k = r.mul(g, g), L = r.mul(S, w);
            return L = r.add(L, L), T = r.mul(S, g), T = r.add(T, T), m = r.mul(R, T), E = r.mul($, k), E = r.add(m, E), m = r.sub(P, E), E = r.add(P, E), E = r.mul(m, E), m = r.mul(L, m), T = r.mul($, T), k = r.mul(R, k), L = r.sub(I, k), L = r.mul(R, L), L = r.add(L, T), T = r.add(I, I), I = r.add(T, I), I = r.add(I, k), I = r.mul(I, L), E = r.add(E, I), k = r.mul(w, g), k = r.add(k, k), I = r.mul(k, L), m = r.sub(m, I), T = r.mul(k, P), T = r.add(T, T), T = r.add(T, T), new K(m, E, T);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(R) {
            N(R);
            const { px: X, py: $, pz: S } = this, { px: w, py: g, pz: m } = R;
            let E = r.ZERO, T = r.ZERO, I = r.ZERO;
            const P = e.a, k = r.mul(e.b, ly);
            let L = r.mul(X, w), j = r.mul($, g), ie = r.mul(S, m), ue = r.add(X, $), ce = r.add(w, g);
            ue = r.mul(ue, ce), ce = r.add(L, j), ue = r.sub(ue, ce), ce = r.add(X, S);
            let he = r.add(w, m);
            return ce = r.mul(ce, he), he = r.add(L, ie), ce = r.sub(ce, he), he = r.add($, S), E = r.add(g, m), he = r.mul(he, E), E = r.add(j, ie), he = r.sub(he, E), I = r.mul(P, ce), E = r.mul(k, ie), I = r.add(E, I), E = r.sub(j, I), I = r.add(j, I), T = r.mul(E, I), j = r.add(L, L), j = r.add(j, L), ie = r.mul(P, ie), ce = r.mul(k, ce), j = r.add(j, ie), ie = r.sub(L, ie), ie = r.mul(P, ie), ce = r.add(ce, ie), L = r.mul(j, ce), T = r.add(T, L), L = r.mul(he, ce), E = r.mul(ue, E), E = r.sub(E, L), L = r.mul(ue, j), I = r.mul(he, I), I = r.add(I, L), new K(E, T, I);
        }
        subtract(R) {
            return this.add(R.negate());
        }
        is0() {
            return this.equals(K.ZERO);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(R) {
            const { endo: X } = t;
            if (!n.isValidNot0(R)) throw new Error("invalid scalar: out of range");
            let $, S;
            const w = (g)=>Q.wNAFCached(this, g, K.normalizeZ);
            if (X) {
                const { k1neg: g, k1: m, k2neg: E, k2: T } = X.splitScalar(R), { p: I, f: P } = w(m), { p: k, f: L } = w(T);
                S = P.add(L), $ = H(X.beta, I, k, g, E);
            } else {
                const { p: g, f: m } = w(R);
                $ = g, S = m;
            }
            return K.normalizeZ([
                $,
                S
            ])[0];
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(R) {
            const { endo: X } = t, $ = this;
            if (!n.isValid(R)) throw new Error("invalid scalar: out of range");
            if (R === Zh || $.is0()) return K.ZERO;
            if (R === Yh) return $;
            if (Q.hasPrecomputes(this)) return this.multiply(R);
            if (X) {
                const { k1neg: S, k1: w, k2neg: g, k2: m } = X.splitScalar(R), { p1: E, p2: T } = Dce(K, $, w, m);
                return H(X.beta, E, T, S, g);
            } else return Q.wNAFCachedUnsafe($, R);
        }
        multiplyAndAddUnsafe(R, X, $) {
            const S = this.multiplyUnsafe(X).add(R.multiplyUnsafe($));
            return S.is0() ? void 0 : S;
        }
        /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */ toAffine(R) {
            return U(this, R);
        }
        /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */ isTorsionFree() {
            const { isTorsionFree: R } = t;
            return i === Yh ? !0 : R ? R(K, this) : Q.wNAFCachedUnsafe(this, o).is0();
        }
        clearCofactor() {
            const { clearCofactor: R } = t;
            return i === Yh ? this : R ? R(K, this) : this.multiplyUnsafe(i);
        }
        toBytes(R = !0) {
            return km("isCompressed", R), this.assertValidity(), c(K, this, R);
        }
        /** @deprecated use `toBytes` */ toRawBytes(R = !0) {
            return this.toBytes(R);
        }
        toHex(R = !0) {
            return Hr.bytesToHex(this.toBytes(R));
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
    }
    K.BASE = new K(e.Gx, e.Gy, r.ONE), K.ZERO = new K(r.ZERO, r.ONE, r.ZERO), K.Fp = r, K.Fn = n;
    const re = n.BITS, Q = Lce(K, t.endo ? Math.ceil(re / 2) : re);
    return K;
}
function AM(e) {
    return Uint8Array.of(e ? 2 : 3);
}
function Vce(e, t, r = {}) {
    SS(t, {
        hash: "function"
    }, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const n = t.randomBytes || Hr.randomBytes, i = t.hmac || (($, ...S)=>Qp.hmac(t.hash, $, Hr.concatBytes(...S))), { Fp: o, Fn: s } = e, { ORDER: a, BITS: u } = s;
    function f($) {
        const S = a >> Yh;
        return $ > S;
    }
    function c($) {
        return f($) ? s.neg($) : $;
    }
    function l($, S) {
        if (!s.isValidNot0(S)) throw new Error(`invalid signature ${$}: out of range 1..CURVE.n`);
    }
    class p {
        constructor(S, w, g){
            l("r", S), l("s", w), this.r = S, this.s = w, g != null && (this.recovery = g), Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(S) {
            const w = s.BYTES, g = ss("compactSignature", S, w * 2);
            return new p(s.fromBytes(g.subarray(0, w)), s.fromBytes(g.subarray(w, w * 2)));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(S) {
            const { r: w, s: g } = Ja.toSig(ss("DER", S));
            return new p(w, g);
        }
        /**
     * @todo remove
     * @deprecated
     */ assertValidity() {}
        addRecoveryBit(S) {
            return new p(this.r, this.s, S);
        }
        // ProjPointType<bigint>
        recoverPublicKey(S) {
            const w = o.ORDER, { r: g, s: m, recovery: E } = this;
            if (E == null || ![
                0,
                1,
                2,
                3
            ].includes(E)) throw new Error("recovery id invalid");
            if (a * Hce < w && E > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const I = E === 2 || E === 3 ? g + a : g;
            if (!o.isValid(I)) throw new Error("recovery id 2 or 3 invalid");
            const P = o.toBytes(I), k = e.fromHex(Hr.concatBytes(AM((E & 1) === 0), P)), L = s.inv(I), j = D(ss("msgHash", S)), ie = s.create(-j * L), ue = s.create(m * L), ce = e.BASE.multiplyUnsafe(ie).add(k.multiplyUnsafe(ue));
            if (ce.is0()) throw new Error("point at infinify");
            return ce.assertValidity(), ce;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return f(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new p(this.r, s.neg(this.s), this.recovery) : this;
        }
        toBytes(S) {
            if (S === "compact") return Hr.concatBytes(s.toBytes(this.r), s.toBytes(this.s));
            if (S === "der") return Hr.hexToBytes(Ja.hexFromSig(this));
            throw new Error("invalid format");
        }
        // DER-encoded
        toDERRawBytes() {
            return this.toBytes("der");
        }
        toDERHex() {
            return Hr.bytesToHex(this.toBytes("der"));
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return this.toBytes("compact");
        }
        toCompactHex() {
            return Hr.bytesToHex(this.toBytes("compact"));
        }
    }
    const y = SM(s, r.allowedPrivateKeyLengths, r.wrapPrivateKey), _ = {
        isValidPrivateKey ($) {
            try {
                return y($), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: y,
        /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */ randomPrivateKey: ()=>{
            const $ = a;
            return Rce(n(_M($)), $);
        },
        precompute ($ = 8, S = e.BASE) {
            return S.precompute($, !1);
        }
    };
    function A($, S = !0) {
        return e.fromPrivateKey($).toBytes(S);
    }
    function O($) {
        if (typeof $ == "bigint") return !1;
        if ($ instanceof e) return !0;
        const w = ss("key", $).length, g = o.BYTES, m = g + 1, E = 2 * g + 1;
        if (!(r.allowedPrivateKeyLengths || s.BYTES === m)) return w === m || w === E;
    }
    function N($, S, w = !0) {
        if (O($) === !0) throw new Error("first arg must be private key");
        if (O(S) === !1) throw new Error("second arg must be public key");
        return e.fromHex(S).multiply(y($)).toBytes(w);
    }
    const U = t.bits2int || function($) {
        if ($.length > 8192) throw new Error("input is too large");
        const S = u1($), w = $.length * 8 - u;
        return w > 0 ? S >> BigInt(w) : S;
    }, D = t.bits2int_modN || function($) {
        return s.create(U($));
    }, H = f1(u);
    function K($) {
        return xce("num < 2^" + u, $, Zh, H), s.toBytes($);
    }
    function re($, S, w = Q) {
        if ([
            "recovered",
            "canonical"
        ].some((ue)=>ue in w)) throw new Error("sign() legacy options not supported");
        const { hash: g } = t;
        let { lowS: m, prehash: E, extraEntropy: T } = w;
        m == null && (m = !0), $ = ss("msgHash", $), RI(w), E && ($ = ss("prehashed msgHash", g($)));
        const I = D($), P = y(S), k = [
            K(P),
            K(I)
        ];
        if (T != null && T !== !1) {
            const ue = T === !0 ? n(o.BYTES) : T;
            k.push(ss("extraEntropy", ue));
        }
        const L = Hr.concatBytes(...k), j = I;
        function ie(ue) {
            const ce = U(ue);
            if (!s.isValidNot0(ce)) return;
            const he = s.inv(ce), ee = e.BASE.multiply(ce).toAffine(), ae = s.create(ee.x);
            if (ae === Zh) return;
            const ye = s.create(he * s.create(j + ae * P));
            if (ye === Zh) return;
            let Se = (ee.x === ae ? 0 : 2) | Number(ee.y & Yh), De = ye;
            return m && f(ye) && (De = c(ye), Se ^= 1), new p(ae, De, Se);
        }
        return {
            seed: L,
            k2sig: ie
        };
    }
    const Q = {
        lowS: t.lowS,
        prehash: !1
    }, G = {
        lowS: t.lowS,
        prehash: !1
    };
    function R($, S, w = Q) {
        const { seed: g, k2sig: m } = re($, S, w);
        return Ace(t.hash.outputLen, s.BYTES, i)(g, m);
    }
    e.BASE.precompute(8);
    function X($, S, w, g = G) {
        const m = $;
        S = ss("msgHash", S), w = ss("publicKey", w), RI(g);
        const { lowS: E, prehash: T, format: I } = g;
        if ("strict" in g) throw new Error("options.strict was renamed to lowS");
        if (I !== void 0 && ![
            "compact",
            "der",
            "js"
        ].includes(I)) throw new Error('format must be "compact", "der" or "js"');
        const P = typeof m == "string" || Hr.isBytes(m), k = !P && !I && typeof m == "object" && m !== null && typeof m.r == "bigint" && typeof m.s == "bigint";
        if (!P && !k) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let L, j;
        try {
            if (k) if (I === void 0 || I === "js") L = new p(m.r, m.s);
            else throw new Error("invalid format");
            if (P) {
                try {
                    I !== "compact" && (L = p.fromDER(m));
                } catch (De) {
                    if (!(De instanceof Ja.Err)) throw De;
                }
                !L && I !== "der" && (L = p.fromCompact(m));
            }
            j = e.fromHex(w);
        } catch  {
            return !1;
        }
        if (!L || E && L.hasHighS()) return !1;
        T && (S = t.hash(S));
        const { r: ie, s: ue } = L, ce = D(S), he = s.inv(ue), ee = s.create(ce * he), ae = s.create(ie * he), ye = e.BASE.multiplyUnsafe(ee).add(j.multiplyUnsafe(ae));
        return ye.is0() ? !1 : s.create(ye.x) === ie;
    }
    return Object.freeze({
        getPublicKey: A,
        getSharedSecret: N,
        sign: R,
        verify: X,
        utils: _,
        Point: e,
        Signature: p
    });
}
function Gce(e) {
    const t = {
        a: e.a,
        b: e.b,
        p: e.Fp.ORDER,
        n: e.n,
        h: e.h,
        Gx: e.Gx,
        Gy: e.Gy
    }, r = e.Fp, n = x0(t.n, e.nBitLength), i = {
        Fp: r,
        Fn: n,
        allowedPrivateKeyLengths: e.allowedPrivateKeyLengths,
        allowInfinityPoint: e.allowInfinityPoint,
        endo: e.endo,
        wrapPrivateKey: e.wrapPrivateKey,
        isTorsionFree: e.isTorsionFree,
        clearCofactor: e.clearCofactor,
        fromBytes: e.fromBytes,
        toBytes: e.toBytes
    };
    return {
        CURVE: t,
        curveOpts: i
    };
}
function Zce(e) {
    const { CURVE: t, curveOpts: r } = Gce(e), n = {
        hash: e.hash,
        hmac: e.hmac,
        randomBytes: e.randomBytes,
        lowS: e.lowS,
        bits2int: e.bits2int,
        bits2int_modN: e.bits2int_modN
    };
    return {
        CURVE: t,
        curveOpts: r,
        ecdsaOpts: n
    };
}
function Yce(e, t) {
    return Object.assign({}, t, {
        ProjectivePoint: t.Point,
        CURVE: e
    });
}
function Xce(e) {
    const { CURVE: t, curveOpts: r, ecdsaOpts: n } = Zce(e), i = Wce(t, r), o = Vce(i, n, r);
    return Yce(e, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Jce(e, t) {
    const r = (n)=>Xce({
            ...e,
            hash: n
        });
    return {
        ...r(t),
        create: r
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Im = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const Qce = BigInt(1), mx = BigInt(2), CI = (e, t)=>(e + t / mx) / t;
function eue(e) {
    const t = Im.p, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), u = BigInt(88), f = e * e * e % t, c = f * f * e % t, l = Qo(c, r, t) * c % t, p = Qo(l, r, t) * c % t, y = Qo(p, mx, t) * f % t, _ = Qo(y, i, t) * y % t, A = Qo(_, o, t) * _ % t, O = Qo(A, a, t) * A % t, N = Qo(O, u, t) * O % t, U = Qo(N, a, t) * A % t, D = Qo(U, r, t) * c % t, H = Qo(D, s, t) * _ % t, K = Qo(H, n, t) * f % t, re = Qo(K, mx, t);
    if (!bx.eql(bx.sqr(re), e)) throw new Error("Cannot find square root");
    return re;
}
const bx = x0(Im.p, void 0, void 0, {
    sqrt: eue
}), mp = Jce({
    ...Im,
    Fp: bx,
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (e)=>{
            const t = Im.n, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Qce * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = BigInt("0x100000000000000000000000000000000"), a = CI(o * e, t), u = CI(-n * e, t);
            let f = Bo(e - a * r - u * i, t), c = Bo(-a * n - u * o, t);
            const l = f > s, p = c > s;
            if (l && (f = t - f), p && (c = t - c), f > s || c > s) throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: l,
                k1: f,
                k2neg: p,
                k2: c
            };
        }
    }
}, B9);
function tue(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function UI(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function rue(e, t) {
    tue(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const nue = (e)=>e instanceof Uint8Array, Z_ = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ta = (e, t)=>e << 32 - t | e >>> t, iue = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!iue) throw new Error("Non little-endian hardware is not supported");
function oue(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
}
function TM(e) {
    if (typeof e == "string" && (e = oue(e)), !nue(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e;
}
let sue = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function aue(e) {
    const t = (n)=>e().update(TM(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function cue(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let uue = class extends sue {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Z_(this.buffer);
    }
    update(t) {
        UI(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = TM(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = Z_(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        UI(this), rue(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        cue(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = Z_(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const fue = (e, t, r)=>e & t ^ ~e & r, lue = (e, t, r)=>e & t ^ e & r ^ t & r, due = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Lc = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Dc = /* @__PURE__ */ new Uint32Array(64);
let hue = class extends uue {
    constructor(){
        super(64, 32, 8, !1), this.A = Lc[0] | 0, this.B = Lc[1] | 0, this.C = Lc[2] | 0, this.D = Lc[3] | 0, this.E = Lc[4] | 0, this.F = Lc[5] | 0, this.G = Lc[6] | 0, this.H = Lc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Dc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Dc[l - 15], y = Dc[l - 2], _ = ta(p, 7) ^ ta(p, 18) ^ p >>> 3, A = ta(y, 17) ^ ta(y, 19) ^ y >>> 10;
            Dc[l] = A + Dc[l - 7] + _ + Dc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = ta(a, 6) ^ ta(a, 11) ^ ta(a, 25), y = c + p + fue(a, u, f) + due[l] + Dc[l] | 0, A = (ta(n, 2) ^ ta(n, 13) ^ ta(n, 22)) + lue(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Dc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
};
const wx = /* @__PURE__ */ aue(()=>new hue());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // @__NO_SIDE_EFFECTS__
function S0(...e) {
    const t = (i, o)=>(s)=>i(o(s)), r = Array.from(e).reverse().reduce((i, o)=>i ? t(i, o.encode) : o.encode, void 0), n = e.reduce((i, o)=>i ? t(i, o.decode) : o.decode, void 0);
    return {
        encode: r,
        decode: n
    };
}
// @__NO_SIDE_EFFECTS__
function l1(e) {
    return {
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
            return t.map((r)=>{
                if (r < 0 || r >= e.length) throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
                return e[r];
            });
        },
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("alphabet.decode input should be array of strings");
            return t.map((r)=>{
                if (typeof r != "string") throw new Error(`alphabet.decode: not string element=${r}`);
                const n = e.indexOf(r);
                if (n === -1) throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
                return n;
            });
        }
    };
}
// @__NO_SIDE_EFFECTS__
function d1(e = "") {
    if (typeof e != "string") throw new Error("join separator should be string");
    return {
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("join.encode input should be array of strings");
            for (let r of t)if (typeof r != "string") throw new Error(`join.encode: non-string input=${r}`);
            return t.join(e);
        },
        decode: (t)=>{
            if (typeof t != "string") throw new Error("join.decode input should be string");
            return t.split(e);
        }
    };
}
// @__NO_SIDE_EFFECTS__
function kM(e, t = "=") {
    if (typeof t != "string") throw new Error("padding chr should be string");
    return {
        encode (r) {
            if (!Array.isArray(r) || r.length && typeof r[0] != "string") throw new Error("padding.encode input should be array of strings");
            for (let n of r)if (typeof n != "string") throw new Error(`padding.encode: non-string input=${n}`);
            for(; r.length * e % 8;)r.push(t);
            return r;
        },
        decode (r) {
            if (!Array.isArray(r) || r.length && typeof r[0] != "string") throw new Error("padding.encode input should be array of strings");
            for (let i of r)if (typeof i != "string") throw new Error(`padding.decode: non-string input=${i}`);
            let n = r.length;
            if (n * e % 8) throw new Error("Invalid padding: string should have whole number of bytes");
            for(; n > 0 && r[n - 1] === t; n--)if (!((n - 1) * e % 8)) throw new Error("Invalid padding: string has too much padding");
            return r.slice(0, n);
        }
    };
}
// @__NO_SIDE_EFFECTS__
function $I(e, t, r) {
    if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
    if (!Array.isArray(e)) throw new Error("convertRadix: data should be array");
    if (!e.length) return [];
    let n = 0;
    const i = [], o = Array.from(e);
    for(o.forEach((s)=>{
        if (s < 0 || s >= t) throw new Error(`Wrong integer: ${s}`);
    });;){
        let s = 0, a = !0;
        for(let u = n; u < o.length; u++){
            const f = o[u], c = t * s + f;
            if (!Number.isSafeInteger(c) || t * s / t !== s || c - f !== t * s) throw new Error("convertRadix: carry overflow");
            s = c % r;
            const l = Math.floor(c / r);
            if (o[u] = l, !Number.isSafeInteger(l) || l * r + s !== c) throw new Error("convertRadix: carry overflow");
            if (a) l ? a = !1 : n = u;
            else continue;
        }
        if (i.push(s), a) break;
    }
    for(let s = 0; s < e.length - 1 && e[s] === 0; s++)i.push(0);
    return i.reverse();
}
const IM = /* @__NO_SIDE_EFFECTS__ */ (e, t)=>t ? /* @__PURE__ */ IM(t, e % t) : e, Bm = /* @__NO_SIDE_EFFECTS__ */ (e, t)=>e + (t - /* @__PURE__ */ IM(e, t));
// @__NO_SIDE_EFFECTS__
function vx(e, t, r, n) {
    if (!Array.isArray(e)) throw new Error("convertRadix2: data should be array");
    if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);
    if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
    if (/* @__PURE__ */ Bm(t, r) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ Bm(t, r)}`);
    let i = 0, o = 0;
    const s = 2 ** r - 1, a = [];
    for (const u of e){
        if (u >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);
        if (i = i << t | u, o + t > 32) throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);
        for(o += t; o >= r; o -= r)a.push((i >> o - r & s) >>> 0);
        i &= 2 ** o - 1;
    }
    if (i = i << r - o & s, !n && o >= t) throw new Error("Excess padding");
    if (!n && i) throw new Error(`Non-zero padding: ${i}`);
    return n && o > 0 && a.push(i >>> 0), a;
}
// @__NO_SIDE_EFFECTS__
function pue(e) {
    return {
        encode: (t)=>{
            if (!(t instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
            return /* @__PURE__ */ $I(Array.from(t), 2 ** 8, e);
        },
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("radix.decode input should be array of strings");
            return Uint8Array.from(/* @__PURE__ */ $I(t, e, 2 ** 8));
        }
    };
}
// @__NO_SIDE_EFFECTS__
function AS(e, t = !1) {
    if (e <= 0 || e > 32) throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ Bm(8, e) > 32 || /* @__PURE__ */ Bm(e, 8) > 32) throw new Error("radix2: carry overflow");
    return {
        encode: (r)=>{
            if (!(r instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
            return /* @__PURE__ */ vx(Array.from(r), 8, e, !t);
        },
        decode: (r)=>{
            if (!Array.isArray(r) || r.length && typeof r[0] != "number") throw new Error("radix2.decode input should be array of strings");
            return Uint8Array.from(/* @__PURE__ */ vx(r, e, 8, t));
        }
    };
}
// @__NO_SIDE_EFFECTS__
function LI(e) {
    if (typeof e != "function") throw new Error("unsafeWrapper fn should be function");
    return function(...t) {
        try {
            return e.apply(null, t);
        } catch  {}
    };
}
// @__NO_SIDE_EFFECTS__
function gue(e, t) {
    if (typeof t != "function") throw new Error("checksum fn should be function");
    return {
        encode (r) {
            if (!(r instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
            const n = t(r).slice(0, e), i = new Uint8Array(r.length + e);
            return i.set(r), i.set(n, r.length), i;
        },
        decode (r) {
            if (!(r instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
            const n = r.slice(0, -e), i = t(n).slice(0, e), o = r.slice(-e);
            for(let s = 0; s < e; s++)if (i[s] !== o[s]) throw new Error("Invalid checksum");
            return n;
        }
    };
}
const DI = /* @__PURE__ */ S0(/* @__PURE__ */ AS(6), /* @__PURE__ */ l1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ kM(6), /* @__PURE__ */ d1("")), FI = /* @__PURE__ */ S0(/* @__PURE__ */ AS(6), /* @__PURE__ */ l1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ kM(6), /* @__PURE__ */ d1("")), yue = (e)=>/* @__PURE__ */ S0(/* @__PURE__ */ pue(58), /* @__PURE__ */ l1(e), /* @__PURE__ */ d1("")), mue = /* @__PURE__ */ yue("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), zI = (e)=>/* @__PURE__ */ S0(/* @__PURE__ */ gue(4, (t)=>e(e(t))), mue), _x = /* @__PURE__ */ S0(/* @__PURE__ */ l1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ d1("")), jI = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
];
// @__NO_SIDE_EFFECTS__
function yh(e) {
    const t = e >> 25;
    let r = (e & 33554431) << 5;
    for(let n = 0; n < jI.length; n++)(t >> n & 1) === 1 && (r ^= jI[n]);
    return r;
}
// @__NO_SIDE_EFFECTS__
function HI(e, t, r = 1) {
    const n = e.length;
    let i = 1;
    for(let o = 0; o < n; o++){
        const s = e.charCodeAt(o);
        if (s < 33 || s > 126) throw new Error(`Invalid prefix (${e})`);
        i = /* @__PURE__ */ yh(i) ^ s >> 5;
    }
    i = /* @__PURE__ */ yh(i);
    for(let o = 0; o < n; o++)i = /* @__PURE__ */ yh(i) ^ e.charCodeAt(o) & 31;
    for (let o of t)i = /* @__PURE__ */ yh(i) ^ o;
    for(let o = 0; o < 6; o++)i = /* @__PURE__ */ yh(i);
    return i ^= r, _x.encode(/* @__PURE__ */ vx([
        i % 2 ** 30
    ], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function BM(e) {
    const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ AS(5), n = r.decode, i = r.encode, o = /* @__PURE__ */ LI(n);
    function s(c, l, p = 90) {
        if (typeof c != "string") throw new Error(`bech32.encode prefix should be string, not ${typeof c}`);
        if (!Array.isArray(l) || l.length && typeof l[0] != "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof l}`);
        const y = c.length + 7 + l.length;
        if (p !== !1 && y > p) throw new TypeError(`Length ${y} exceeds limit ${p}`);
        const _ = c.toLowerCase(), A = /* @__PURE__ */ HI(_, l, t);
        return `${_}1${_x.encode(l)}${A}`;
    }
    function a(c, l = 90) {
        if (typeof c != "string") throw new Error(`bech32.decode input should be string, not ${typeof c}`);
        if (c.length < 8 || l !== !1 && c.length > l) throw new TypeError(`Wrong string length: ${c.length} (${c}). Expected (8..${l})`);
        const p = c.toLowerCase();
        if (c !== p && c !== c.toUpperCase()) throw new Error("String must be lowercase or uppercase");
        c = p;
        const y = c.lastIndexOf("1");
        if (y === 0 || y === -1) throw new Error('Letter "1" must be present between prefix and data only');
        const _ = c.slice(0, y), A = c.slice(y + 1);
        if (A.length < 6) throw new Error("Data must be at least 6 characters long");
        const O = _x.decode(A).slice(0, -6), N = /* @__PURE__ */ HI(_, O, t);
        if (!A.endsWith(N)) throw new Error(`Invalid checksum in ${c}: expected "${N}"`);
        return {
            prefix: _,
            words: O
        };
    }
    const u = /* @__PURE__ */ LI(a);
    function f(c) {
        const { prefix: l, words: p } = a(c, !1);
        return {
            prefix: l,
            words: p,
            bytes: n(p)
        };
    }
    return {
        encode: s,
        decode: a,
        decodeToBytes: f,
        decodeUnsafe: u,
        fromWords: n,
        fromWordsUnsafe: o,
        toWords: i
    };
}
const dy = /* @__PURE__ */ BM("bech32"), hy = /* @__PURE__ */ BM("bech32m"), ga = {
    b58chk: {
        encode: (e)=>zI(wx).encode(e),
        decode: (e)=>zI(wx).decode(e)
    },
    base64: {
        encode: (e)=>DI.encode(e),
        decode: (e)=>DI.decode(e)
    },
    b64url: {
        encode: (e)=>FI.encode(e),
        decode: (e)=>FI.decode(e)
    },
    bech32: {
        to_words: dy.toWords,
        to_bytes: dy.fromWords,
        encode: (e, t, r = !1)=>dy.encode(e, t, r),
        decode: (e, t = !1)=>{
            const { prefix: r, words: n } = dy.decode(e, t);
            return {
                prefix: r,
                words: n
            };
        }
    },
    bech32m: {
        to_words: hy.toWords,
        to_bytes: hy.fromWords,
        encode: (e, t, r = !1)=>hy.encode(e, t, r),
        decode: (e, t = !1)=>{
            const { prefix: r, words: n } = hy.decode(e, t);
            return {
                prefix: r,
                words: n
            };
        }
    }
};
function bue(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function wue(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function vue(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
function OM(e, t) {
    if (e !== t) throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
const _ue = BigInt(0), Eue = BigInt(255), PM = BigInt(256);
function xue(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Sue(e, t, r = "be") {
    t === void 0 && (t = xue(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > _ue;){
        const a = e & Eue, u = Number(a);
        n ? o.setUint8(s++, u) : o.setUint8(s--, u), e = (e - a) / PM;
    }
    return new Uint8Array(i);
}
function Aue(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * PM + BigInt(e[r]);
    return BigInt(t);
}
function Tue(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i = 0; n < t.length; n += 8, i++){
        let o = 0;
        for(let s = 0; s < 8; s++)o |= t[n + s] << 7 - s;
        r[i] = o;
    }
    return r;
}
function kue(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i = 7; i >= 0; i--, r++)t[r] = n >> i & 1;
    }
    return t.join("");
}
function Iue(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Bue(e, t, r = "be") {
    t === void 0 && (t = Iue(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > 0;){
        const a = e & 255;
        n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
    }
    return new Uint8Array(i);
}
function Oue(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], vue(t);
    return t;
}
const Pue = new TextEncoder(), Nue = new TextDecoder();
function TS(e) {
    return Pue.encode(e);
}
function Y_(e) {
    return Nue.decode(e);
}
function Mue(e, t) {
    wue(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function Rue(e, t, r = "le") {
    t = Mue(e, t);
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(let a = 0; a < e.length; a += 2){
        const u = e.substring(a, a + 2), f = parseInt(u, 16);
        n ? o.setUint8(s++, f) : o.setUint8(s--, f);
    }
    return new Uint8Array(i);
}
function Cue(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
const { getRandomValues: Uue } = crypto ?? globalThis.crypto ?? window.crypto;
function $ue(e = 32) {
    if (typeof Uue == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function NM(e) {
    return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function Lue(e) {
    return typeof e == "string" && NM(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? !0 : !!(Array.isArray(e) && e.every((t)=>typeof t == "number"));
}
function Due(e, t, r = "be") {
    t === void 0 && (t = e.length), bue(e, t);
    const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
    return n.set(e, i), n;
}
function MM(e) {
    let t, r = 0;
    const n = e.reduce((o, s)=>o + s.length, 0), i = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i.set(o, r), r += o.length;
    }
    return i;
}
function Fue(e, t) {
    return typeof t == "bigint" ? `${t}n` : t;
}
function zue(e, t) {
    return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function jue(e, t, r) {
    const n = e.length, i = r / t;
    if (r % t !== 0) throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
    if (n !== r) throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
    if (n % t !== 0) throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
    const o = new Array(i);
    for(let s = 0; s < i; s++){
        const a = s * t;
        o[s] = e.subarray(a, a + t);
    }
    return o;
}
function kS(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return Due(e, t, r);
    if (Array.isArray(e)) {
        const n = e.map((i)=>kS(i, t, r));
        return MM(n);
    } else {
        if (typeof e == "string") return Rue(e, t, r);
        if (typeof e == "bigint") return Sue(e, t, r);
        if (typeof e == "number") return Bue(e, t, r);
        if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    }
    throw new TypeError("Unsupported format:" + typeof e);
}
var Jt;
let on = (Jt = class extends Uint8Array {
    static random(t = 32) {
        const r = $ue(t);
        return new Jt(r, t);
    }
    static now(t = 4) {
        const r = Math.floor(Date.now() / 1e3);
        return new Jt(r, t);
    }
    constructor(t, r, n){
        if (t instanceof Jt && r === void 0) return t;
        const i = kS(t, r, n);
        super(i);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.to_num();
    }
    get big() {
        return this.to_big();
    }
    get str() {
        return this.to_str();
    }
    get hex() {
        return this.to_hex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.to_bin();
    }
    get b58chk() {
        return this.to_b58chk();
    }
    get base64() {
        return this.to_base64();
    }
    get b64url() {
        return this.to_b64url();
    }
    get digest() {
        return this.to_hash();
    }
    get id() {
        return this.to_hash().hex;
    }
    get stream() {
        return new rfe(this);
    }
    to_num(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Oue(r);
    }
    to_big(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Aue(r);
    }
    to_bin() {
        return kue(this);
    }
    to_hash() {
        const t = wx(this);
        return new Jt(t);
    }
    to_json(t) {
        t === void 0 && (t = zue);
        const r = Y_(this);
        return JSON.parse(r, t);
    }
    to_bech32(t, r) {
        const { encode: n, to_words: i } = ga.bech32, o = i(this);
        return n(t, o, r);
    }
    to_bech32m(t, r) {
        const { encode: n, to_words: i } = ga.bech32m, o = i(this);
        return n(t, o, r);
    }
    to_str() {
        return Y_(this);
    }
    to_hex() {
        return Cue(this);
    }
    to_bytes() {
        return new Uint8Array(this);
    }
    to_b58chk() {
        return ga.b58chk.encode(this);
    }
    to_base64() {
        return ga.base64.encode(this);
    }
    to_b64url() {
        return ga.b64url.encode(this);
    }
    append(t) {
        return Jt.join([
            this,
            Jt.bytes(t)
        ]);
    }
    prepend(t) {
        return Jt.join([
            Jt.bytes(t),
            this
        ]);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new Jt(t);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new Jt(n);
    }
    set(t, r) {
        this.set(t, r);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new Jt(n);
    }
    write(t, r) {
        const n = Jt.bytes(t);
        this.set(n, r);
    }
    add_varint(t) {
        const r = Jt.calc_varint(this.length, t);
        return Jt.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new Jt(Uint8Array.from(t));
    }
    static of(...t) {
        return new Jt(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i)=>Jt.bytes(i)), n = MM(r);
        return new Jt(n);
    }
    static sort(t, r) {
        const n = t.map((i)=>qI(i, r).hex);
        return n.sort(), n.map((i)=>Jt.hex(i, r));
    }
    static calc_varint(t, r) {
        if (t < 253) return Jt.num(t, 1);
        if (t < 65536) return Jt.of(253, ...Jt.num(t, 2, r));
        if (t < 4294967296) return Jt.of(254, ...Jt.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return Jt.of(255, ...Jt.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
}, Jt.num = Hue, Jt.big = Kue, Jt.bin = que, Jt.raw = Wue, Jt.str = Vue, Jt.hex = Gue, Jt.bytes = qI, Jt.json = Zue, Jt.base64 = Yue, Jt.b64url = Xue, Jt.bech32 = Jue, Jt.bech32m = Que, Jt.b58chk = efe, Jt.encode = TS, Jt.decode = Y_, Jt.parse = tfe, Jt.is_bytes = Lue, Jt.is_hex = NM, Jt);
function Hue(e, t, r) {
    return new on(e, t, r);
}
function que(e, t, r) {
    return new on(Tue(e), t, r);
}
function Kue(e, t, r) {
    return new on(e, t, r);
}
function Wue(e, t, r) {
    return new on(e, t, r);
}
function Vue(e, t, r) {
    return new on(TS(e), t, r);
}
function Gue(e, t, r) {
    return new on(e, t, r);
}
function Zue(e, t) {
    t === void 0 && (t = Fue);
    const r = JSON.stringify(e, t);
    return new on(TS(r));
}
function Yue(e) {
    return new on(ga.base64.decode(e));
}
function Xue(e) {
    return new on(ga.b64url.decode(e));
}
function Jue(e, t, r) {
    const { decode: n, to_bytes: i } = ga.bech32, { prefix: o, words: s } = n(e, t), a = i(s);
    return typeof r == "string" && OM(o, r), new on(a);
}
function Que(e, t, r) {
    const { decode: n, to_bytes: i } = ga.bech32m, { prefix: o, words: s } = n(e, t), a = i(s);
    return typeof r == "string" && OM(o, r), new on(a);
}
function efe(e) {
    return new on(ga.b58chk.decode(e));
}
function tfe(e, t, r) {
    const n = kS(e);
    return jue(n, t, r).map((o)=>on.bytes(o));
}
let rfe = class {
    constructor(t){
        this.data = on.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new on(this.data.slice(0, t));
    }
    read(t) {
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    read_varint(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).to_num(t);
            case r === 254:
                return this.read(4).to_num(t);
            case r === 255:
                return this.read(8).to_num(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
};
function qI(e, t, r) {
    return new on(e, t, r);
}
const Om = mp.CURVE, h1 = Om.n, nfe = Om.p, KI = {
    x: Om.Gx,
    y: Om.Gy
}, ife = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const ofe = (e)=>Bo(e, h1);
function RM(e, t = !1) {
    if (!t) return !1;
    throw new Error(e);
}
function sfe(e, t, r) {
    const n = on.bytes(e);
    return n.length !== t ? RM(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function afe(e, t) {
    return typeof e == "bigint" && ife < e && e < h1 || RM("x value is not in the field!", t), !0;
}
const cfe = x0(h1, 32, !0), WI = mp.ProjectivePoint, mh = cfe;
var un;
let cd = (un = class extends Uint8Array {
    static add(t) {
        return t.map((r)=>un.mod(r)).reduce((r, n)=>r.add(n));
    }
    static mod(t) {
        return new un(t);
    }
    static mul(t) {
        return t.map((r)=>un.mod(r)).reduce((r, n)=>r.mul(n));
    }
    static is_valid(t, r) {
        const n = on.bytes(t, 32).big;
        return afe(n, r);
    }
    constructor(t){
        const r = ofe(ufe(t));
        un.is_valid(r, !0), super(on.big(r, 32), 32);
    }
    get buff() {
        return new on(this);
    }
    get raw() {
        return this.buff.raw;
    }
    get big() {
        return this.buff.big;
    }
    get hex() {
        return this.buff.hex;
    }
    get point() {
        return this.generate();
    }
    get hasOddY() {
        return this.point.hasOddY;
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    gt(t) {
        return new un(t).big > this.big;
    }
    lt(t) {
        return new un(t).big < this.big;
    }
    eq(t) {
        return new un(t).big === this.big;
    }
    ne(t) {
        return new un(t).big !== this.big;
    }
    add(t) {
        const r = un.mod(t), n = mh.add(this.big, r.big);
        return new un(n);
    }
    sub(t) {
        const r = un.mod(t), n = mh.sub(this.big, r.big);
        return new un(n);
    }
    mul(t) {
        const r = un.mod(t), n = mh.mul(this.big, r.big);
        return new un(n);
    }
    pow(t) {
        const r = un.mod(t), n = mh.pow(this.big, r.big);
        return new un(n);
    }
    div(t) {
        const r = un.mod(t), n = mh.div(this.big, r.big);
        return new un(n);
    }
    negate() {
        return new un(un.N - this.big);
    }
    generate() {
        const r = mp.ProjectivePoint.BASE.multiply(this.big);
        return IS.import(r);
    }
}, un.N = h1, un);
var Vr;
let IS = (Vr = class {
    static from_x(t, r = !1) {
        let n = ffe(t);
        n.length === 32 ? n = n.prepend(2) : r && (n[0] = 2), sfe(n, 33);
        const i = WI.fromHex(n.hex);
        return i.assertValidity(), new Vr(i.x, i.y);
    }
    static generate(t) {
        const r = cd.mod(t), n = Vr.base.multiply(r.big);
        return Vr.import(n);
    }
    static import(t) {
        const r = t instanceof Vr ? {
            x: t.x.big,
            y: t.y.big
        } : {
            x: t.x,
            y: t.y
        };
        return new Vr(r.x, r.y);
    }
    constructor(t, r){
        this._p = new WI(t, r, 1n), this.p.assertValidity();
    }
    get p() {
        return this._p;
    }
    get x() {
        return on.big(this.p.x, 32);
    }
    get y() {
        return on.big(this.p.y, 32);
    }
    get buff() {
        return on.raw(this.p.toRawBytes(!0));
    }
    get raw() {
        return this.buff.raw;
    }
    get hex() {
        return this.buff.hex;
    }
    get hasEvenY() {
        return this.p.hasEvenY();
    }
    get hasOddY() {
        return !this.p.hasEvenY();
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    eq(t) {
        const r = t instanceof Vr ? t : Vr.from_x(t);
        return this.x.big === r.x.big && this.y.big === r.y.big;
    }
    add(t) {
        return t instanceof Vr ? Vr.import(this.p.add(t.p)) : Vr.import(this.p.add(Vr.generate(t).p));
    }
    sub(t) {
        return t instanceof Vr ? Vr.import(this.p.subtract(t.p)) : Vr.import(this.p.subtract(Vr.generate(t).p));
    }
    mul(t) {
        return t instanceof Vr ? Vr.import(this.p.multiply(t.x.big)) : Vr.import(this.p.multiply(cd.mod(t).big));
    }
    negate() {
        return Vr.import(this.p.negate());
    }
}, Vr.P = nfe, Vr.G = new Vr(KI.x, KI.y), Vr.curve = mp.CURVE, Vr.base = mp.ProjectivePoint.BASE, Vr.mul = Vr.generate, Vr);
function ufe(e) {
    if (e instanceof cd) return e.big;
    if (e instanceof IS) return e.x.big;
    if (e instanceof Uint8Array) return on.raw(e).big;
    if (typeof e == "string") return on.hex(e).big;
    if (typeof e == "number") return on.num(e).big;
    if (typeof e == "bigint") return BigInt(e);
    throw TypeError("Invalid input type:" + typeof e);
}
function ffe(e) {
    if (e instanceof cd) return e.point.buff;
    if (e instanceof IS) return e.buff;
    if (e instanceof Uint8Array || typeof e == "string") return on.bytes(e);
    if (typeof e == "number" || typeof e == "bigint") return on.bytes(e, 32);
    throw new TypeError(`Unknown type: ${typeof e}`);
}
function lfe(e, t = !1) {
    const r = cd.mod(e);
    return t ? r.negated.buff : r.buff;
}
function CM(e, t = !1) {
    const r = cd.mod(e).point;
    return t ? r.x : r.buff;
}
function Ex(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function dfe(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function UM(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function hfe(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Ex(e.outputLen), Ex(e.blockLen);
}
function pfe(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function gfe(e, t) {
    UM(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const yfe = {
    number: Ex,
    bool: dfe,
    bytes: UM,
    hash: hfe,
    exists: pfe,
    output: gfe
};
var X_ = yfe;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const J_ = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ra = (e, t)=>e << 32 - t | e >>> t, mfe = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!mfe) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function bfe(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function $M(e) {
    if (typeof e == "string" && (e = bfe(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
let wfe = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function LM(e) {
    const t = (n)=>e().update($M(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function vfe(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let _fe = class extends wfe {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = J_(this.buffer);
    }
    update(t) {
        X_.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = $M(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = J_(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        X_.exists(this), X_.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        vfe(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = J_(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const Efe = (e, t, r)=>e & t ^ ~e & r, xfe = (e, t, r)=>e & t ^ e & r ^ t & r, Sfe = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Fc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), zc = new Uint32Array(64);
let DM = class extends _fe {
    constructor(){
        super(64, 32, 8, !1), this.A = Fc[0] | 0, this.B = Fc[1] | 0, this.C = Fc[2] | 0, this.D = Fc[3] | 0, this.E = Fc[4] | 0, this.F = Fc[5] | 0, this.G = Fc[6] | 0, this.H = Fc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)zc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = zc[l - 15], y = zc[l - 2], _ = ra(p, 7) ^ ra(p, 18) ^ p >>> 3, A = ra(y, 17) ^ ra(y, 19) ^ y >>> 10;
            zc[l] = A + zc[l - 7] + _ + zc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = ra(a, 6) ^ ra(a, 11) ^ ra(a, 25), y = c + p + Efe(a, u, f) + Sfe[l] + zc[l] | 0, A = (ra(n, 2) ^ ra(n, 13) ^ ra(n, 22)) + xfe(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        zc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Afe = class extends DM {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const xx = LM(()=>new DM());
LM(()=>new Afe());
function Tfe(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function kfe(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Ife(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Bfe } = crypto ?? globalThis.crypto ?? window.crypto;
function Ofe(e = 32) {
    if (typeof Bfe == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function Pfe(e, t, r = "be") {
    t === void 0 && (t = e.length), Tfe(e, t);
    const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
    return n.set(e, i), n;
}
function FM(e) {
    let t, r = 0;
    const n = e.reduce((o, s)=>o + s.length, 0), i = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i.set(o, r), r += o.length;
    }
    return i;
}
const Nfe = new TextEncoder(), Mfe = [
    {
        name: "base58",
        charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }
];
function zM(e) {
    for (const t of Mfe)if (t.name === e) return t.charset;
    throw TypeError("Charset does not exist: " + e);
}
function Rfe(e, t, r = !1) {
    typeof e == "string" && (e = Nfe.encode(e));
    const n = zM(t), i = n.length, o = [];
    let s = "", a, u = 0, f, c;
    for(a = 0; a < e.length; a++)for(u = 0, f = e[a], s += f > 0 || (s.length ^ a) > 0 ? "" : "1"; u in o || f > 0;)c = o[u], c = c > 0 ? c * 256 + f : f, f = c / i | 0, o[u] = c % i, u++;
    for(; u-- > 0;)s += n[o[u]];
    return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function Cfe(e, t) {
    const r = zM(t), n = r.length, i = [], o = [];
    e = e.replace("=", "");
    let s, a = 0, u, f;
    for(s = 0; s < e.length; s++){
        if (a = 0, u = r.indexOf(e[s]), u < 0) throw new Error(`Character range out of bounds: ${u}`);
        for(u > 0 || (o.length ^ s) > 0 || o.push(0); a in i || u > 0;)f = i[a], f = f > 0 ? f * n + u : u, u = f >> 8, i[a] = f % 256, a++;
    }
    for(; a-- > 0;)o.push(i[a]);
    return new Uint8Array(o);
}
function jM(e) {
    return xx(xx(e));
}
function Ufe(e) {
    const t = jM(e);
    return FM([
        e,
        t.slice(0, 4)
    ]);
}
function $fe(e) {
    const t = e.slice(0, -4), r = e.slice(-4);
    if (jM(t).slice(0, 4).toString() !== r.toString()) throw new Error("Invalid checksum!");
    return t;
}
const VI = {
    encode: Rfe,
    decode: Cfe
}, HM = {
    encode: (e)=>{
        const t = Ufe(e);
        return VI.encode(t, "base58");
    },
    decode: (e)=>{
        const t = VI.decode(e, "base58");
        return $fe(t);
    }
}, qM = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Lfe = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
], Pm = [
    {
        version: 0,
        name: "bech32",
        const: 1
    },
    {
        version: 1,
        name: "bech32m",
        const: 734539939
    }
];
function KM(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = t >> 25;
        t = (t & 33554431) << 5 ^ e[r];
        for(let i = 0; i < 5; ++i)n >> i & 1 && (t ^= Lfe[i]);
    }
    return t;
}
function WM(e) {
    const t = [];
    let r;
    for(r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) >> 5);
    for(t.push(0), r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) & 31);
    return t;
}
function Dfe(e, t, r) {
    const n = WM(e).concat(t);
    return KM(n) === r.const;
}
function Ffe(e, t, r) {
    const n = WM(e).concat(t).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ]), i = KM(n) ^ r.const, o = [];
    for(let s = 0; s < 6; ++s)o.push(i >> 5 * (5 - s) & 31);
    return o;
}
function VM(e, t, r, n = !0) {
    const i = [];
    let o = 0, s = 0;
    const a = (1 << r) - 1, u = (1 << t + r - 1) - 1;
    for (const f of e){
        if (f < 0 || f >> t > 0) throw new Error("Failed to perform base conversion. Invalid value: " + String(f));
        for(o = (o << t | f) & u, s += t; s >= r;)s -= r, i.push(o >> s & a);
    }
    if (n) s > 0 && i.push(o << r - s & a);
    else if (s >= t || (o << r - s & a) > 0) throw new Error("Failed to perform base conversion. Invalid Size!");
    return i;
}
function zfe(e, t, r) {
    const n = t.concat(Ffe(e, t, r));
    let i = e + "1";
    for(let o = 0; o < n.length; ++o)i += qM.charAt(n[o]);
    return i;
}
function GM(e) {
    if (!jfe(e)) throw new Error("Encoded string goes out of bounds!");
    if (e = e.toLowerCase(), !Hfe(e)) throw new Error("Encoded string has invalid separator!");
    const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
    for(let o = r + 1; o < e.length; ++o){
        const s = qM.indexOf(e.charAt(o));
        if (s === -1) throw new Error("Character idx out of bounds: " + String(o));
        t.push(s);
    }
    const i = Pm.find((o)=>o.version === t[0]) ?? Pm[0];
    if (!Dfe(n, t, i)) throw new Error("Checksum verification failed!");
    return [
        n,
        t.slice(0, t.length - 6)
    ];
}
function jfe(e) {
    let t, r, n = !1, i = !1;
    for(t = 0; t < e.length; ++t){
        if (r = e.charCodeAt(t), r < 33 || r > 126) return !1;
        r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i = !0);
    }
    return !(n && i);
}
function Hfe(e) {
    const t = e.lastIndexOf("1");
    return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function qfe(e, t = "bc", r = 0) {
    const n = [
        r,
        ...VM([
            ...e
        ], 8, 5)
    ], i = Pm.find((s)=>s.version === r) ?? Pm[0], o = zfe(t, n, i);
    return ZM(o), o;
}
function ZM(e) {
    e = e.toLowerCase();
    const t = e.split("1", 1)[0], [r, n] = GM(e), i = VM(n.slice(1), 5, 8, !1), o = i.length;
    switch(!0){
        case t !== r:
            throw new Error("Returned hrp string is invalid.");
        case i === null || o < 2 || o > 40:
            throw new Error("Decoded string is invalid or out of spec.");
        case n[0] > 16:
            throw new Error("Returned version bit is out of range.");
        default:
            return Uint8Array.from(i);
    }
}
function Kfe(e) {
    e = e.toLowerCase();
    const [t, r] = GM(e);
    return r[0];
}
const YM = {
    encode: qfe,
    decode: ZM,
    version: Kfe
}, XM = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", JM = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", Wfe = new TextEncoder();
function QM(e, t = !1, r = !0) {
    typeof e == "string" && (e = Wfe.encode(e));
    const n = t ? JM : XM;
    let i = "", o = 0, s = 0;
    for(let a = 0; a < e.length; a++)for(s = s << 8 | e[a], o += 8; o >= 6;)o -= 6, i += n[s >> o & 63];
    if (o > 0) for(s <<= 6 - o, i += n[s & 63]; o < 6;)i += r ? "=" : "", o += 2;
    return i;
}
function eR(e, t = !1) {
    const r = t || e.includes("-") || e.includes("_") ? JM.split("") : XM.split("");
    e = e.replace(/=+$/, "");
    const n = e.split("");
    let i = 0, o = 0;
    const s = [];
    for(let a = 0; a < n.length; a++){
        const u = n[a], f = r.indexOf(u);
        if (f === -1) throw new Error("Invalid character: " + u);
        i += 6, o <<= 6, o |= f, i >= 8 && (i -= 8, s.push(o >>> i & 255));
    }
    return new Uint8Array(s);
}
const tR = {
    encode: QM,
    decode: eR
}, rR = {
    encode: (e)=>QM(e, !0, !1),
    decode: (e)=>eR(e, !0)
}, Vfe = BigInt(0), Gfe = BigInt(255), nR = BigInt(256);
function Zfe(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Yfe(e, t, r = "be") {
    t === void 0 && (t = Zfe(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > Vfe;){
        const a = e & Gfe, u = Number(a);
        n ? o.setUint8(s++, u) : o.setUint8(s--, u), e = (e - a) / nR;
    }
    return new Uint8Array(i);
}
function Xfe(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * nR + BigInt(e[r]);
    return BigInt(t);
}
function Jfe(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i = 0; n < t.length; n += 8, i++){
        let o = 0;
        for(let s = 0; s < 8; s++)o |= t[n + s] << 7 - s;
        r[i] = o;
    }
    return r;
}
function Qfe(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i = 7; i >= 0; i--, r++)t[r] = n >> i & 1;
    }
    return t.join("");
}
function ele(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function tle(e, t, r = "be") {
    t === void 0 && (t = ele(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > 0;){
        const a = e & 255;
        n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
    }
    return new Uint8Array(i);
}
function rle(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], Ife(t);
    return t;
}
const nle = new TextEncoder(), ile = new TextDecoder();
function BS(e) {
    return nle.encode(e);
}
function Q_(e) {
    return ile.decode(e);
}
function ole(e, t) {
    kfe(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function sle(e, t, r = "le") {
    t = ole(e, t);
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(let a = 0; a < e.length; a += 2){
        const u = e.substring(a, a + 2), f = parseInt(u, 16);
        n ? o.setUint8(s++, f) : o.setUint8(s--, f);
    }
    return new Uint8Array(i);
}
function ale(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
function cle(e) {
    const t = JSON.stringify(e, (r, n)=>typeof n == "bigint" ? `${n}n` : n);
    return BS(t);
}
function ule(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return Pfe(e, t, r);
    if (typeof e == "string") return sle(e, t, r);
    if (typeof e == "bigint") return Yfe(e, t, r);
    if (typeof e == "number") return tle(e, t, r);
    if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    throw TypeError("Unsupported format:" + typeof e);
}
var lr;
let Ze = (lr = class extends Uint8Array {
    static random(t = 32) {
        const r = Ofe(t);
        return new lr(r, t);
    }
    constructor(t, r, n){
        const i = ule(t, r, n);
        super(i);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new Hd(this);
    }
    toNum(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return rle(r);
    }
    toBin() {
        return Qfe(this);
    }
    toBig(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Xfe(r);
    }
    toHash() {
        const t = xx(this);
        return new lr(t);
    }
    toJson() {
        const t = Q_(this);
        return JSON.parse(t);
    }
    toBech32(t, r = 0) {
        return YM.encode(this, t, r);
    }
    toStr() {
        return Q_(this);
    }
    toHex() {
        return ale(this);
    }
    toBytes() {
        return new Uint8Array(this);
    }
    tob58chk() {
        return HM.encode(this);
    }
    toBase64() {
        return tR.encode(this);
    }
    toB64url() {
        return rR.encode(this);
    }
    prepend(t) {
        return lr.join([
            lr.bytes(t),
            this
        ]);
    }
    append(t) {
        return lr.join([
            this,
            lr.bytes(t)
        ]);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new lr(n);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new lr(n);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new lr(t);
    }
    write(t, r) {
        const n = lr.bytes(t);
        this.set(n, r);
    }
    prefixSize(t) {
        const r = lr.varInt(this.length, t);
        return lr.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new lr(Uint8Array.from(t));
    }
    static of(...t) {
        return new lr(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i)=>lr.bytes(i)), n = FM(r);
        return new lr(n);
    }
    static varInt(t, r) {
        if (t < 253) return lr.num(t, 1);
        if (t < 65536) return lr.of(253, ...lr.num(t, 2, r));
        if (t < 4294967296) return lr.of(254, ...lr.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return lr.of(255, ...lr.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
}, lr.num = fle, lr.big = dle, lr.bin = lle, lr.raw = hle, lr.str = ple, lr.hex = gle, lr.bytes = yle, lr.json = mle, lr.base64 = ble, lr.b64url = wle, lr.bech32 = vle, lr.b58chk = _le, lr.encode = BS, lr.decode = Q_, lr);
function fle(e, t, r) {
    return new Ze(e, t, r);
}
function lle(e, t, r) {
    return new Ze(Jfe(e), t, r);
}
function dle(e, t, r) {
    return new Ze(e, t, r);
}
function hle(e, t, r) {
    return new Ze(e, t, r);
}
function ple(e, t, r) {
    return new Ze(BS(e), t, r);
}
function gle(e, t, r) {
    return new Ze(e, t, r);
}
function yle(e, t, r) {
    return new Ze(e, t, r);
}
function mle(e) {
    return new Ze(cle(e));
}
function ble(e) {
    return new Ze(tR.decode(e));
}
function wle(e) {
    return new Ze(rR.decode(e));
}
function vle(e) {
    return new Ze(YM.decode(e));
}
function _le(e) {
    return new Ze(HM.decode(e));
}
let Hd = class {
    constructor(t){
        this.data = Ze.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new Ze(this.data.slice(0, t));
    }
    read(t) {
        t = t ?? this.readSize();
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    readSize(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).toNum(t);
            case r === 254:
                return this.read(4).toNum(t);
            case r === 255:
                return this.read(8).toNum(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
};
function Ia(e, t) {
    const r = Ze.bytes(e);
    if (r.length !== t) throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function Oo(e, t) {
    if (t) throw new Error(e);
    return !1;
}
function $y(e, ...t) {
    const r = Ze.str(e).digest.raw, n = t.map((i)=>Ze.bytes(i));
    return Ze.join([
        r,
        r,
        Ze.join(n)
    ]).digest;
}
const iR = {
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_SUCCESS80: 80,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_SUCCESS98: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_SUCCESS126: 126,
    OP_SUCCESS127: 127,
    OP_SUCCESS128: 128,
    OP_SUCCESS129: 129,
    OP_SIZE: 130,
    OP_SUCCESS131: 131,
    OP_SUCCESS132: 132,
    OP_SUCCESS133: 133,
    OP_SUCCESS134: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_SUCCESS137: 137,
    OP_SUCCESS138: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_SUCCESS141: 141,
    OP_SUCCESS142: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_SUCCESS149: 149,
    OP_SUCCESS150: 150,
    OP_SUCCESS151: 151,
    OP_SUCCESS152: 152,
    OP_SUCCESS153: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_SUCCESS187: 187,
    OP_SUCCESS188: 188,
    OP_SUCCESS189: 189,
    OP_SUCCESS190: 190,
    OP_SUCCESS191: 191,
    OP_SUCCESS192: 192,
    OP_SUCCESS193: 193,
    OP_SUCCESS194: 194,
    OP_SUCCESS195: 195,
    OP_SUCCESS196: 196,
    OP_SUCCESS197: 197,
    OP_SUCCESS198: 198,
    OP_SUCCESS199: 199,
    OP_SUCCESS200: 200,
    OP_SUCCESS201: 201,
    OP_SUCCESS202: 202,
    OP_SUCCESS203: 203,
    OP_SUCCESS204: 204,
    OP_SUCCESS205: 205,
    OP_SUCCESS206: 206,
    OP_SUCCESS207: 207,
    OP_SUCCESS208: 208,
    OP_SUCCESS209: 209,
    OP_SUCCESS210: 210,
    OP_SUCCESS211: 211,
    OP_SUCCESS212: 212,
    OP_SUCCESS213: 213,
    OP_SUCCESS214: 214,
    OP_SUCCESS215: 215,
    OP_SUCCESS216: 216,
    OP_SUCCESS217: 217,
    OP_SUCCESS218: 218,
    OP_SUCCESS219: 219,
    OP_SUCCESS220: 220,
    OP_SUCCESS221: 221,
    OP_SUCCESS222: 222,
    OP_SUCCESS223: 223,
    OP_SUCCESS224: 224,
    OP_SUCCESS225: 225,
    OP_SUCCESS226: 226,
    OP_SUCCESS227: 227,
    OP_SUCCESS228: 228,
    OP_SUCCESS229: 229,
    OP_SUCCESS230: 230,
    OP_SUCCESS231: 231,
    OP_SUCCESS232: 232,
    OP_SUCCESS233: 233,
    OP_SUCCESS234: 234,
    OP_SUCCESS235: 235,
    OP_SUCCESS236: 236,
    OP_SUCCESS237: 237,
    OP_SUCCESS238: 238,
    OP_SUCCESS239: 239,
    OP_SUCCESS240: 240,
    OP_SUCCESS241: 241,
    OP_SUCCESS242: 242,
    OP_SUCCESS243: 243,
    OP_SUCCESS244: 244,
    OP_SUCCESS245: 245,
    OP_SUCCESS246: 246,
    OP_SUCCESS247: 247,
    OP_SUCCESS248: 248,
    OP_SUCCESS249: 249,
    OP_SUCCESS250: 250,
    OP_SUCCESS251: 251,
    OP_SUCCESS252: 252,
    OP_SUCCESS253: 253,
    OP_SUCCESS254: 254
};
function Ele(e) {
    if (e > 186 && e < 255) return "OP_SUCCESS" + String(e);
    for (const [t, r] of Object.entries(iR))if (r === e) return t;
    throw new Error("OPCODE not found:" + String(e));
}
function xle(e) {
    for (const [t, r] of Object.entries(iR))if (t === e) return Number(r);
    throw new Error("OPCODE not found:" + e);
}
function Sle(e) {
    switch(!0){
        case e === 0:
            return "opcode";
        case e >= 1 && e <= 75:
            return "varint";
        case e === 76:
            return "pushdata1";
        case e === 77:
            return "pushdata2";
        case e === 78:
            return "pushdata4";
        case e <= 254:
            return "opcode";
        default:
            throw new Error(`Invalid word range: ${e}`);
    }
}
function Ale(e) {
    const n = [];
    switch(!0){
        case typeof e != "number":
            return !1;
        case e === 0:
            return !0;
        case n.includes(e):
            return !1;
        case 75 < e && e < 254:
            return !0;
        default:
            return !1;
    }
}
function bc(e) {
    return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function oR(e) {
    return bc(e) || e instanceof Uint8Array;
}
const Nm = 520;
function Hf(e = [], t = !0) {
    let r = Ze.num(0);
    return Array.isArray(e) && (r = Ze.raw(sR(e))), bc(e) && (r = Ze.hex(e)), e instanceof Uint8Array && (r = Ze.raw(e)), t && (r = r.prefixSize("le")), r;
}
function sR(e) {
    const t = [];
    for (const r of e)t.push(Tle(r));
    return t.length > 0 ? Ze.join(t) : new Uint8Array();
}
function Tle(e) {
    let t = new Uint8Array();
    if (typeof e == "string") {
        if (e.startsWith("OP_")) return Ze.num(xle(e), 1);
        bc(e) ? t = Ze.hex(e) : t = Ze.str(e);
    } else t = Ze.bytes(e);
    if (t.length === 1) return t[0] !== 0 && t[0] <= 16 ? (t[0] += 80, t) : (t[0] > 128 && t[0] <= 255 && (t = new Uint8Array([
        t[0],
        0
    ])), Ze.join([
        GI(t.length),
        t
    ]));
    if (t.length > Nm) {
        const r = kle(t);
        return sR(r);
    } else return Ze.join([
        GI(t.length),
        t
    ]);
}
function GI(e) {
    const t = Ze.num(76, 1), r = Ze.num(77, 1);
    switch(!0){
        case e <= 75:
            return Ze.num(e);
        case e > 75 && e < 256:
            return Ze.join([
                t,
                Ze.num(e, 1, "le")
            ]);
        case e >= 256 && e <= Nm:
            return Ze.join([
                r,
                Ze.num(e, 2, "le")
            ]);
        default:
            throw new Error("Invalid word size:" + e.toString());
    }
}
function kle(e) {
    const t = [], r = new Hd(e);
    for(; r.size > Nm;)t.push(r.read(Nm));
    return t.push(r.read(r.size)), t;
}
function OS(e, t = !1) {
    let r = Ze.bytes(e);
    if (t) {
        const i = r.stream.readSize("le");
        if (r = r.slice(1), r.length !== i) throw new Error(`Varint does not match stream size: ${i} !== ${r.length}`);
    }
    return Ile(r);
}
function Ile(e) {
    const t = new Hd(e), r = [], n = t.size;
    let i, o, s, a = 0;
    for(; a < n;)switch(i = t.read(1).num, o = Sle(i), a++, o){
        case "varint":
            r.push(t.read(i).hex), a += i;
            break;
        case "pushdata1":
            s = t.read(1).reverse().num, r.push(t.read(s).hex), a += s + 1;
            break;
        case "pushdata2":
            s = t.read(2).reverse().num, r.push(t.read(s).hex), a += s + 2;
            break;
        case "pushdata4":
            s = t.read(4).reverse().num, r.push(t.read(s).hex), a += s + 4;
            break;
        case "opcode":
            if (!Ale(i)) throw new Error(`Invalid OPCODE: ${i}`);
            r.push(Ele(i));
            break;
        default:
            throw new Error(`Word type undefined: ${i}`);
    }
    return r;
}
function Ble(e, t) {
    if (Array.isArray(e) && (e = Hf(e, t)), e instanceof Uint8Array || bc(e)) return OS(e, t);
    throw new Error("Invalid format: " + typeof e);
}
function Ole(e, t) {
    if ((e instanceof Uint8Array || bc(e)) && (e = OS(e, t)), Array.isArray(e)) return Hf(e, t);
    throw new Error("Invalid format: " + typeof e);
}
function Ple(e) {
    if (!Array.isArray(e)) return Ze.bytes(e);
    throw new Error("Invalid format: " + typeof e);
}
const Nle = {
    toAsm: Ble,
    toBytes: Ole,
    toParam: Ple
}, Ba = {
    encode: Hf,
    decode: OS,
    fmt: Nle
};
function Sx(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Mle(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function aR(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Rle(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Sx(e.outputLen), Sx(e.blockLen);
}
function Cle(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function Ule(e, t) {
    aR(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const $le = {
    number: Sx,
    bool: Mle,
    bytes: aR,
    hash: Rle,
    exists: Cle,
    output: Ule
};
var uf = $le;
const eE = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const tE = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), na = (e, t)=>e << 32 - t | e >>> t, Lle = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!Lle) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function Dle(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function PS(e) {
    if (typeof e == "string" && (e = Dle(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
function Fle(...e) {
    if (!e.every((n)=>n instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (e.length === 1) return e[0];
    const t = e.reduce((n, i)=>n + i.length, 0), r = new Uint8Array(t);
    for(let n = 0, i = 0; n < e.length; n++){
        const o = e[n];
        r.set(o, i), i += o.length;
    }
    return r;
}
let cR = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function uR(e) {
    const t = (n)=>e().update(PS(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function zle(e = 32) {
    if (eE && typeof eE.getRandomValues == "function") return eE.getRandomValues(new Uint8Array(e));
    throw new Error("crypto.getRandomValues must be defined");
}
function jle(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let Hle = class extends cR {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = tE(this.buffer);
    }
    update(t) {
        uf.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = PS(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = tE(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        uf.exists(this), uf.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        jle(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = tE(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const qle = (e, t, r)=>e & t ^ ~e & r, Kle = (e, t, r)=>e & t ^ e & r ^ t & r, Wle = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), jc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Hc = new Uint32Array(64);
let fR = class extends Hle {
    constructor(){
        super(64, 32, 8, !1), this.A = jc[0] | 0, this.B = jc[1] | 0, this.C = jc[2] | 0, this.D = jc[3] | 0, this.E = jc[4] | 0, this.F = jc[5] | 0, this.G = jc[6] | 0, this.H = jc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Hc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Hc[l - 15], y = Hc[l - 2], _ = na(p, 7) ^ na(p, 18) ^ p >>> 3, A = na(y, 17) ^ na(y, 19) ^ y >>> 10;
            Hc[l] = A + Hc[l - 7] + _ + Hc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = na(a, 6) ^ na(a, 11) ^ na(a, 25), y = c + p + qle(a, u, f) + Wle[l] + Hc[l] | 0, A = (na(n, 2) ^ na(n, 13) ^ na(n, 22)) + Kle(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Hc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Vle = class extends fR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const lR = uR(()=>new fR());
uR(()=>new Vle());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Gle = BigInt(0), NS = BigInt(1), Zle = BigInt(2), p1 = (e)=>e instanceof Uint8Array, Yle = Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function ud(e) {
    if (!p1(e)) throw new Error("Uint8Array expected");
    let t = "";
    for(let r = 0; r < e.length; r++)t += Yle[e[r]];
    return t;
}
function dR(e) {
    const t = e.toString(16);
    return t.length & 1 ? `0${t}` : t;
}
function MS(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return BigInt(e === "" ? "0" : `0x${e}`);
}
function fd(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    if (e.length % 2) throw new Error("hex string is invalid: unpadded " + e.length);
    const t = new Uint8Array(e.length / 2);
    for(let r = 0; r < t.length; r++){
        const n = r * 2, i = e.slice(n, n + 2), o = Number.parseInt(i, 16);
        if (Number.isNaN(o) || o < 0) throw new Error("invalid byte sequence");
        t[r] = o;
    }
    return t;
}
function fu(e) {
    return MS(ud(e));
}
function RS(e) {
    if (!p1(e)) throw new Error("Uint8Array expected");
    return MS(ud(Uint8Array.from(e).reverse()));
}
const Zl = (e, t)=>fd(e.toString(16).padStart(t * 2, "0")), hR = (e, t)=>Zl(e, t).reverse(), Xle = (e)=>fd(dR(e));
function cs(e, t, r) {
    let n;
    if (typeof t == "string") try {
        n = fd(t);
    } catch (o) {
        throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
    else if (p1(t)) n = Uint8Array.from(t);
    else throw new Error(`${e} must be hex string or Uint8Array`);
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(`${e} expected ${r} bytes, got ${i}`);
    return n;
}
function Os(...e) {
    const t = new Uint8Array(e.reduce((n, i)=>n + i.length, 0));
    let r = 0;
    return e.forEach((n)=>{
        if (!p1(n)) throw new Error("Uint8Array expected");
        t.set(n, r), r += n.length;
    }), t;
}
function Jle(e, t) {
    if (e.length !== t.length) return !1;
    for(let r = 0; r < e.length; r++)if (e[r] !== t[r]) return !1;
    return !0;
}
function g1(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function Qle(e) {
    let t;
    for(t = 0; e > 0n; e >>= NS, t += 1);
    return t;
}
const ede = (e, t)=>e >> BigInt(t) & 1n, tde = (e, t, r)=>e | (r ? NS : Gle) << BigInt(t), CS = (e)=>(Zle << BigInt(e - 1)) - NS, rE = (e)=>new Uint8Array(e), ZI = (e)=>Uint8Array.from(e);
function pR(e, t, r) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    let n = rE(e), i = rE(e), o = 0;
    const s = ()=>{
        n.fill(1), i.fill(0), o = 0;
    }, a = (...l)=>r(i, n, ...l), u = (l = rE())=>{
        i = a(ZI([
            0
        ]), l), n = a(), l.length !== 0 && (i = a(ZI([
            1
        ]), l), n = a());
    }, f = ()=>{
        if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let l = 0;
        const p = [];
        for(; l < t;){
            n = a();
            const y = n.slice();
            p.push(y), l += n.length;
        }
        return Os(...p);
    };
    return (l, p)=>{
        s(), u(l);
        let y;
        for(; !(y = p(f()));)u();
        return s(), y;
    };
}
const rde = {
    bigint: (e)=>typeof e == "bigint",
    function: (e)=>typeof e == "function",
    boolean: (e)=>typeof e == "boolean",
    string: (e)=>typeof e == "string",
    isSafeInteger: (e)=>Number.isSafeInteger(e),
    array: (e)=>Array.isArray(e),
    field: (e, t)=>t.Fp.isValid(e),
    hash: (e)=>typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function qd(e, t, r = {}) {
    const n = (i, o, s)=>{
        const a = rde[o];
        if (typeof a != "function") throw new Error(`Invalid validator "${o}", expected function`);
        const u = e[i];
        if (!(s && u === void 0) && !a(u, e)) throw new Error(`Invalid param ${String(i)}=${u} (${typeof u}), expected ${o}`);
    };
    for (const [i, o] of Object.entries(t))n(i, o, !1);
    for (const [i, o] of Object.entries(r))n(i, o, !0);
    return e;
}
var nde = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    bitGet: ede,
    bitLen: Qle,
    bitMask: CS,
    bitSet: tde,
    bytesToHex: ud,
    bytesToNumberBE: fu,
    bytesToNumberLE: RS,
    concatBytes: Os,
    createHmacDrbg: pR,
    ensureBytes: cs,
    equalBytes: Jle,
    hexToBytes: fd,
    hexToNumber: MS,
    numberToBytesBE: Zl,
    numberToBytesLE: hR,
    numberToHexUnpadded: dR,
    numberToVarBytesBE: Xle,
    utf8ToBytes: g1,
    validateObject: qd
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const si = BigInt(0), Ln = BigInt(1), tf = BigInt(2), ide = BigInt(3), Ax = BigInt(4), YI = BigInt(5), XI = BigInt(8);
BigInt(9);
BigInt(16);
function Oi(e, t) {
    const r = e % t;
    return r >= si ? r : t + r;
}
function ode(e, t, r) {
    if (r <= si || t < si) throw new Error("Expected power/modulo > 0");
    if (r === Ln) return si;
    let n = Ln;
    for(; t > si;)t & Ln && (n = n * e % r), e = e * e % r, t >>= Ln;
    return n;
}
function es(e, t, r) {
    let n = e;
    for(; t-- > si;)n *= n, n %= r;
    return n;
}
function Tx(e, t) {
    if (e === si || t <= si) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
    let r = Oi(e, t), n = t, i = si, o = Ln;
    for(; r !== si;){
        const a = n / r, u = n % r, f = i - o * a;
        n = r, r = u, i = o, o = f;
    }
    if (n !== Ln) throw new Error("invert: does not exist");
    return Oi(i, t);
}
function sde(e) {
    const t = (e - Ln) / tf;
    let r, n, i;
    for(r = e - Ln, n = 0; r % tf === si; r /= tf, n++);
    for(i = tf; i < e && ode(i, t, e) !== e - Ln; i++);
    if (n === 1) {
        const s = (e + Ln) / Ax;
        return function(u, f) {
            const c = u.pow(f, s);
            if (!u.eql(u.sqr(c), f)) throw new Error("Cannot find square root");
            return c;
        };
    }
    const o = (r + Ln) / tf;
    return function(a, u) {
        if (a.pow(u, t) === a.neg(a.ONE)) throw new Error("Cannot find square root");
        let f = n, c = a.pow(a.mul(a.ONE, i), r), l = a.pow(u, o), p = a.pow(u, r);
        for(; !a.eql(p, a.ONE);){
            if (a.eql(p, a.ZERO)) return a.ZERO;
            let y = 1;
            for(let A = a.sqr(p); y < f && !a.eql(A, a.ONE); y++)A = a.sqr(A);
            const _ = a.pow(c, Ln << BigInt(f - y - 1));
            c = a.sqr(_), l = a.mul(l, _), p = a.mul(p, c), f = y;
        }
        return l;
    };
}
function ade(e) {
    if (e % Ax === ide) {
        const t = (e + Ln) / Ax;
        return function(n, i) {
            const o = n.pow(i, t);
            if (!n.eql(n.sqr(o), i)) throw new Error("Cannot find square root");
            return o;
        };
    }
    if (e % XI === YI) {
        const t = (e - YI) / XI;
        return function(n, i) {
            const o = n.mul(i, tf), s = n.pow(o, t), a = n.mul(i, s), u = n.mul(n.mul(a, tf), s), f = n.mul(a, n.sub(u, n.ONE));
            if (!n.eql(n.sqr(f), i)) throw new Error("Cannot find square root");
            return f;
        };
    }
    return sde(e);
}
const cde = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function gR(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }, r = cde.reduce((n, i)=>(n[i] = "function", n), t);
    return qd(e, r);
}
function ude(e, t, r) {
    if (r < si) throw new Error("Expected power > 0");
    if (r === si) return e.ONE;
    if (r === Ln) return t;
    let n = e.ONE, i = t;
    for(; r > si;)r & Ln && (n = e.mul(n, i)), i = e.sqr(i), r >>= Ln;
    return n;
}
function fde(e, t) {
    const r = new Array(t.length), n = t.reduce((o, s, a)=>e.is0(s) ? o : (r[a] = o, e.mul(o, s)), e.ONE), i = e.inv(n);
    return t.reduceRight((o, s, a)=>e.is0(s) ? o : (r[a] = e.mul(o, r[a]), e.mul(o, s)), i), r;
}
function US(e, t) {
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function yR(e, t, r = !1, n = {}) {
    if (e <= si) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
    const { nBitLength: i, nByteLength: o } = US(e, t);
    if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const s = ade(e), a = Object.freeze({
        ORDER: e,
        BITS: i,
        BYTES: o,
        MASK: CS(i),
        ZERO: si,
        ONE: Ln,
        create: (u)=>Oi(u, e),
        isValid: (u)=>{
            if (typeof u != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
            return si <= u && u < e;
        },
        is0: (u)=>u === si,
        isOdd: (u)=>(u & Ln) === Ln,
        neg: (u)=>Oi(-u, e),
        eql: (u, f)=>u === f,
        sqr: (u)=>Oi(u * u, e),
        add: (u, f)=>Oi(u + f, e),
        sub: (u, f)=>Oi(u - f, e),
        mul: (u, f)=>Oi(u * f, e),
        pow: (u, f)=>ude(a, u, f),
        div: (u, f)=>Oi(u * Tx(f, e), e),
        // Same as above, but doesn't normalize
        sqrN: (u)=>u * u,
        addN: (u, f)=>u + f,
        subN: (u, f)=>u - f,
        mulN: (u, f)=>u * f,
        inv: (u)=>Tx(u, e),
        sqrt: n.sqrt || ((u)=>s(a, u)),
        invertBatch: (u)=>fde(a, u),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (u, f, c)=>c ? f : u,
        toBytes: (u)=>r ? hR(u, o) : Zl(u, o),
        fromBytes: (u)=>{
            if (u.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${u.length}`);
            return r ? RS(u) : fu(u);
        }
    });
    return Object.freeze(a);
}
function lde(e, t, r = !1) {
    e = cs("privateHash", e);
    const n = e.length, i = US(t).nByteLength + 8;
    if (i < 24 || n < i || n > 1024) throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);
    const o = r ? RS(e) : fu(e);
    return Oi(o, t - Ln) + Ln;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const dde = BigInt(0), nE = BigInt(1);
function hde(e, t) {
    const r = (i, o)=>{
        const s = o.negate();
        return i ? s : o;
    }, n = (i)=>{
        const o = Math.ceil(t / i) + 1, s = 2 ** (i - 1);
        return {
            windows: o,
            windowSize: s
        };
    };
    return {
        constTimeNegate: r,
        // non-const time multiplication ladder
        unsafeLadder (i, o) {
            let s = e.ZERO, a = i;
            for(; o > dde;)o & nE && (s = s.add(a)), a = a.double(), o >>= nE;
            return s;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (i, o) {
            const { windows: s, windowSize: a } = n(o), u = [];
            let f = i, c = f;
            for(let l = 0; l < s; l++){
                c = f, u.push(c);
                for(let p = 1; p < a; p++)c = c.add(f), u.push(c);
                f = c.double();
            }
            return u;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (i, o, s) {
            const { windows: a, windowSize: u } = n(i);
            let f = e.ZERO, c = e.BASE;
            const l = BigInt(2 ** i - 1), p = 2 ** i, y = BigInt(i);
            for(let _ = 0; _ < a; _++){
                const A = _ * u;
                let O = Number(s & l);
                s >>= y, O > u && (O -= p, s += nE);
                const N = A, U = A + Math.abs(O) - 1, D = _ % 2 !== 0, H = O < 0;
                O === 0 ? c = c.add(r(D, o[N])) : f = f.add(r(H, o[U]));
            }
            return {
                p: f,
                f: c
            };
        },
        wNAFCached (i, o, s, a) {
            const u = i._WINDOW_SIZE || 1;
            let f = o.get(i);
            return f || (f = this.precomputeWindow(i, u), u !== 1 && o.set(i, a(f))), this.wNAF(u, f, s);
        }
    };
}
function mR(e) {
    return gR(e.Fp), qd(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...US(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function pde(e) {
    const t = mR(e);
    qd(t, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const { endo: r, Fp: n, a: i } = t;
    if (r) {
        if (!n.eql(i, n.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...t
    });
}
const { bytesToNumberBE: gde, hexToBytes: yde } = nde, ff = {
    // asn.1 DER encoding utils
    Err: class extends Error {
        constructor(t = ""){
            super(t);
        }
    },
    _parseInt (e) {
        const { Err: t } = ff;
        if (e.length < 2 || e[0] !== 2) throw new t("Invalid signature integer tag");
        const r = e[1], n = e.subarray(2, r + 2);
        if (!r || n.length !== r) throw new t("Invalid signature integer: wrong length");
        if (n[0] === 0 && n[1] <= 127) throw new t("Invalid signature integer: trailing length");
        return {
            d: gde(n),
            l: e.subarray(r + 2)
        };
    },
    toSig (e) {
        const { Err: t } = ff, r = typeof e == "string" ? yde(e) : e;
        if (!(r instanceof Uint8Array)) throw new Error("ui8a expected");
        let n = r.length;
        if (n < 2 || r[0] != 48) throw new t("Invalid signature tag");
        if (r[1] !== n - 2) throw new t("Invalid signature: incorrect length");
        const { d: i, l: o } = ff._parseInt(r.subarray(2)), { d: s, l: a } = ff._parseInt(o);
        if (a.length) throw new t("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s
        };
    },
    hexFromSig (e) {
        const t = (f)=>Number.parseInt(f[0], 16) >= 8 ? "00" + f : f, r = (f)=>{
            const c = f.toString(16);
            return c.length & 1 ? `0${c}` : c;
        }, n = t(r(e.s)), i = t(r(e.r)), o = n.length / 2, s = i.length / 2, a = r(o), u = r(s);
        return `30${r(s + o + 4)}02${u}${i}02${a}${n}`;
    }
}, Ps = BigInt(0), Zn = BigInt(1), Ka = BigInt(2), Mm = BigInt(3), JI = BigInt(4);
function mde(e) {
    const t = pde(e), { Fp: r } = t, n = t.toBytes || ((_, A, O)=>{
        const N = A.toAffine();
        return Os(Uint8Array.from([
            4
        ]), r.toBytes(N.x), r.toBytes(N.y));
    }), i = t.fromBytes || ((_)=>{
        const A = _.subarray(1), O = r.fromBytes(A.subarray(0, r.BYTES)), N = r.fromBytes(A.subarray(r.BYTES, 2 * r.BYTES));
        return {
            x: O,
            y: N
        };
    });
    function o(_) {
        const { a: A, b: O } = t, N = r.sqr(_), U = r.mul(N, _);
        return r.add(r.add(U, r.mul(_, A)), O);
    }
    function s(_) {
        return typeof _ == "bigint" && Ps < _ && _ < t.n;
    }
    function a(_) {
        if (!s(_)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function u(_) {
        const { allowedPrivateKeyLengths: A, nByteLength: O, wrapPrivateKey: N, n: U } = t;
        if (A && typeof _ != "bigint") {
            if (_ instanceof Uint8Array && (_ = ud(_)), typeof _ != "string" || !A.includes(_.length)) throw new Error("Invalid key");
            _ = _.padStart(O * 2, "0");
        }
        let D;
        try {
            D = typeof _ == "bigint" ? _ : fu(cs("private key", _, O));
        } catch  {
            throw new Error(`private key must be ${O} bytes, hex or bigint, not ${typeof _}`);
        }
        return N && (D = Oi(D, U)), a(D), D;
    }
    const f = /* @__PURE__ */ new Map();
    function c(_) {
        if (!(_ instanceof l)) throw new Error("ProjectivePoint expected");
    }
    class l {
        constructor(A, O, N){
            if (this.px = A, this.py = O, this.pz = N, A == null || !r.isValid(A)) throw new Error("x required");
            if (O == null || !r.isValid(O)) throw new Error("y required");
            if (N == null || !r.isValid(N)) throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(A) {
            const { x: O, y: N } = A || {};
            if (!A || !r.isValid(O) || !r.isValid(N)) throw new Error("invalid affine point");
            if (A instanceof l) throw new Error("projective point not allowed");
            const U = (D)=>r.eql(D, r.ZERO);
            return U(O) && U(N) ? l.ZERO : new l(O, N, r.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */ static normalizeZ(A) {
            const O = r.invertBatch(A.map((N)=>N.pz));
            return A.map((N, U)=>N.toAffine(O[U])).map(l.fromAffine);
        }
        /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */ static fromHex(A) {
            const O = l.fromAffine(i(cs("pointHex", A)));
            return O.assertValidity(), O;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(A) {
            return l.BASE.multiply(u(A));
        }
        // "Private method", don't use it directly
        _setWindowSize(A) {
            this._WINDOW_SIZE = A, f.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                if (t.allowInfinityPoint) return;
                throw new Error("bad point: ZERO");
            }
            const { x: A, y: O } = this.toAffine();
            if (!r.isValid(A) || !r.isValid(O)) throw new Error("bad point: x or y not FE");
            const N = r.sqr(O), U = o(A);
            if (!r.eql(N, U)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
            const { y: A } = this.toAffine();
            if (r.isOdd) return !r.isOdd(A);
            throw new Error("Field doesn't support isOdd");
        }
        /**
     * Compare one point to another.
     */ equals(A) {
            c(A);
            const { px: O, py: N, pz: U } = this, { px: D, py: H, pz: K } = A, re = r.eql(r.mul(O, K), r.mul(D, U)), Q = r.eql(r.mul(N, K), r.mul(H, U));
            return re && Q;
        }
        /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */ negate() {
            return new l(this.px, r.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: A, b: O } = t, N = r.mul(O, Mm), { px: U, py: D, pz: H } = this;
            let K = r.ZERO, re = r.ZERO, Q = r.ZERO, G = r.mul(U, U), R = r.mul(D, D), X = r.mul(H, H), $ = r.mul(U, D);
            return $ = r.add($, $), Q = r.mul(U, H), Q = r.add(Q, Q), K = r.mul(A, Q), re = r.mul(N, X), re = r.add(K, re), K = r.sub(R, re), re = r.add(R, re), re = r.mul(K, re), K = r.mul($, K), Q = r.mul(N, Q), X = r.mul(A, X), $ = r.sub(G, X), $ = r.mul(A, $), $ = r.add($, Q), Q = r.add(G, G), G = r.add(Q, G), G = r.add(G, X), G = r.mul(G, $), re = r.add(re, G), X = r.mul(D, H), X = r.add(X, X), G = r.mul(X, $), K = r.sub(K, G), Q = r.mul(X, R), Q = r.add(Q, Q), Q = r.add(Q, Q), new l(K, re, Q);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(A) {
            c(A);
            const { px: O, py: N, pz: U } = this, { px: D, py: H, pz: K } = A;
            let re = r.ZERO, Q = r.ZERO, G = r.ZERO;
            const R = t.a, X = r.mul(t.b, Mm);
            let $ = r.mul(O, D), S = r.mul(N, H), w = r.mul(U, K), g = r.add(O, N), m = r.add(D, H);
            g = r.mul(g, m), m = r.add($, S), g = r.sub(g, m), m = r.add(O, U);
            let E = r.add(D, K);
            return m = r.mul(m, E), E = r.add($, w), m = r.sub(m, E), E = r.add(N, U), re = r.add(H, K), E = r.mul(E, re), re = r.add(S, w), E = r.sub(E, re), G = r.mul(R, m), re = r.mul(X, w), G = r.add(re, G), re = r.sub(S, G), G = r.add(S, G), Q = r.mul(re, G), S = r.add($, $), S = r.add(S, $), w = r.mul(R, w), m = r.mul(X, m), S = r.add(S, w), w = r.sub($, w), w = r.mul(R, w), m = r.add(m, w), $ = r.mul(S, m), Q = r.add(Q, $), $ = r.mul(E, m), re = r.mul(g, re), re = r.sub(re, $), $ = r.mul(g, S), G = r.mul(E, G), G = r.add(G, $), new l(re, Q, G);
        }
        subtract(A) {
            return this.add(A.negate());
        }
        is0() {
            return this.equals(l.ZERO);
        }
        wNAF(A) {
            return y.wNAFCached(this, f, A, (O)=>{
                const N = r.invertBatch(O.map((U)=>U.pz));
                return O.map((U, D)=>U.toAffine(N[D])).map(l.fromAffine);
            });
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(A) {
            const O = l.ZERO;
            if (A === Ps) return O;
            if (a(A), A === Zn) return this;
            const { endo: N } = t;
            if (!N) return y.unsafeLadder(this, A);
            let { k1neg: U, k1: D, k2neg: H, k2: K } = N.splitScalar(A), re = O, Q = O, G = this;
            for(; D > Ps || K > Ps;)D & Zn && (re = re.add(G)), K & Zn && (Q = Q.add(G)), G = G.double(), D >>= Zn, K >>= Zn;
            return U && (re = re.negate()), H && (Q = Q.negate()), Q = new l(r.mul(Q.px, N.beta), Q.py, Q.pz), re.add(Q);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(A) {
            a(A);
            let O = A, N, U;
            const { endo: D } = t;
            if (D) {
                const { k1neg: H, k1: K, k2neg: re, k2: Q } = D.splitScalar(O);
                let { p: G, f: R } = this.wNAF(K), { p: X, f: $ } = this.wNAF(Q);
                G = y.constTimeNegate(H, G), X = y.constTimeNegate(re, X), X = new l(r.mul(X.px, D.beta), X.py, X.pz), N = G.add(X), U = R.add($);
            } else {
                const { p: H, f: K } = this.wNAF(O);
                N = H, U = K;
            }
            return l.normalizeZ([
                N,
                U
            ])[0];
        }
        /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */ multiplyAndAddUnsafe(A, O, N) {
            const U = l.BASE, D = (K, re)=>re === Ps || re === Zn || !K.equals(U) ? K.multiplyUnsafe(re) : K.multiply(re), H = D(this, O).add(D(A, N));
            return H.is0() ? void 0 : H;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(A) {
            const { px: O, py: N, pz: U } = this, D = this.is0();
            A == null && (A = D ? r.ONE : r.inv(U));
            const H = r.mul(O, A), K = r.mul(N, A), re = r.mul(U, A);
            if (D) return {
                x: r.ZERO,
                y: r.ZERO
            };
            if (!r.eql(re, r.ONE)) throw new Error("invZ was invalid");
            return {
                x: H,
                y: K
            };
        }
        isTorsionFree() {
            const { h: A, isTorsionFree: O } = t;
            if (A === Zn) return !0;
            if (O) return O(l, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: A, clearCofactor: O } = t;
            return A === Zn ? this : O ? O(l, this) : this.multiplyUnsafe(t.h);
        }
        toRawBytes(A = !0) {
            return this.assertValidity(), n(l, this, A);
        }
        toHex(A = !0) {
            return ud(this.toRawBytes(A));
        }
    }
    l.BASE = new l(t.Gx, t.Gy, r.ONE), l.ZERO = new l(r.ZERO, r.ONE, r.ZERO);
    const p = t.nBitLength, y = hde(l, t.endo ? Math.ceil(p / 2) : p);
    return {
        CURVE: t,
        ProjectivePoint: l,
        normPrivateKeyToScalar: u,
        weierstrassEquation: o,
        isWithinCurveOrder: s
    };
}
function bde(e) {
    const t = mR(e);
    return qd(t, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...t
    });
}
function wde(e) {
    const t = bde(e), { Fp: r, n } = t, i = r.BYTES + 1, o = 2 * r.BYTES + 1;
    function s(m) {
        return Ps < m && m < r.ORDER;
    }
    function a(m) {
        return Oi(m, n);
    }
    function u(m) {
        return Tx(m, n);
    }
    const { ProjectivePoint: f, normPrivateKeyToScalar: c, weierstrassEquation: l, isWithinCurveOrder: p } = mde({
        ...t,
        toBytes (m, E, T) {
            const I = E.toAffine(), P = r.toBytes(I.x), k = Os;
            return T ? k(Uint8Array.from([
                E.hasEvenY() ? 2 : 3
            ]), P) : k(Uint8Array.from([
                4
            ]), P, r.toBytes(I.y));
        },
        fromBytes (m) {
            const E = m.length, T = m[0], I = m.subarray(1);
            if (E === i && (T === 2 || T === 3)) {
                const P = fu(I);
                if (!s(P)) throw new Error("Point is not on curve");
                const k = l(P);
                let L = r.sqrt(k);
                const j = (L & Zn) === Zn;
                return (T & 1) === 1 !== j && (L = r.neg(L)), {
                    x: P,
                    y: L
                };
            } else if (E === o && T === 4) {
                const P = r.fromBytes(I.subarray(0, r.BYTES)), k = r.fromBytes(I.subarray(r.BYTES, 2 * r.BYTES));
                return {
                    x: P,
                    y: k
                };
            } else throw new Error(`Point of length ${E} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
        }
    }), y = (m)=>ud(Zl(m, t.nByteLength));
    function _(m) {
        const E = n >> Zn;
        return m > E;
    }
    function A(m) {
        return _(m) ? a(-m) : m;
    }
    const O = (m, E, T)=>fu(m.slice(E, T));
    class N {
        constructor(E, T, I){
            this.r = E, this.s = T, this.recovery = I, this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(E) {
            const T = t.nByteLength;
            return E = cs("compactSignature", E, T * 2), new N(O(E, 0, T), O(E, T, 2 * T));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(E) {
            const { r: T, s: I } = ff.toSig(cs("DER", E));
            return new N(T, I);
        }
        assertValidity() {
            if (!p(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!p(this.s)) throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(E) {
            return new N(this.r, this.s, E);
        }
        recoverPublicKey(E) {
            const { r: T, s: I, recovery: P } = this, k = Q(cs("msgHash", E));
            if (P == null || ![
                0,
                1,
                2,
                3
            ].includes(P)) throw new Error("recovery id invalid");
            const L = P === 2 || P === 3 ? T + t.n : T;
            if (L >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const j = P & 1 ? "03" : "02", ie = f.fromHex(j + y(L)), ue = u(L), ce = a(-k * ue), he = a(I * ue), ee = f.BASE.multiplyAndAddUnsafe(ie, ce, he);
            if (!ee) throw new Error("point at infinify");
            return ee.assertValidity(), ee;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return _(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new N(this.r, a(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return fd(this.toDERHex());
        }
        toDERHex() {
            return ff.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return fd(this.toCompactHex());
        }
        toCompactHex() {
            return y(this.r) + y(this.s);
        }
    }
    const U = {
        isValidPrivateKey (m) {
            try {
                return c(m), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: c,
        /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */ randomPrivateKey: ()=>{
            const m = t.randomBytes(r.BYTES + 8), E = lde(m, n);
            return Zl(E, t.nByteLength);
        },
        /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */ precompute (m = 8, E = f.BASE) {
            return E._setWindowSize(m), E.multiply(BigInt(3)), E;
        }
    };
    function D(m, E = !0) {
        return f.fromPrivateKey(m).toRawBytes(E);
    }
    function H(m) {
        const E = m instanceof Uint8Array, T = typeof m == "string", I = (E || T) && m.length;
        return E ? I === i || I === o : T ? I === 2 * i || I === 2 * o : m instanceof f;
    }
    function K(m, E, T = !0) {
        if (H(m)) throw new Error("first arg must be private key");
        if (!H(E)) throw new Error("second arg must be public key");
        return f.fromHex(E).multiply(c(m)).toRawBytes(T);
    }
    const re = t.bits2int || function(m) {
        const E = fu(m), T = m.length * 8 - t.nBitLength;
        return T > 0 ? E >> BigInt(T) : E;
    }, Q = t.bits2int_modN || function(m) {
        return a(re(m));
    }, G = CS(t.nBitLength);
    function R(m) {
        if (typeof m != "bigint") throw new Error("bigint expected");
        if (!(Ps <= m && m < G)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
        return Zl(m, t.nByteLength);
    }
    function X(m, E, T = $) {
        if ([
            "recovered",
            "canonical"
        ].some((ye)=>ye in T)) throw new Error("sign() legacy options not supported");
        const { hash: I, randomBytes: P } = t;
        let { lowS: k, prehash: L, extraEntropy: j } = T;
        k == null && (k = !0), m = cs("msgHash", m), L && (m = cs("prehashed msgHash", I(m)));
        const ie = Q(m), ue = c(E), ce = [
            R(ue),
            R(ie)
        ];
        if (j != null) {
            const ye = j === !0 ? P(r.BYTES) : j;
            ce.push(cs("extraEntropy", ye, r.BYTES));
        }
        const he = Os(...ce), ee = ie;
        function ae(ye) {
            const Se = re(ye);
            if (!p(Se)) return;
            const De = u(Se), Re = f.BASE.multiply(Se).toAffine(), Ce = a(Re.x);
            if (Ce === Ps) return;
            const M = a(De * a(ee + Ce * ue));
            if (M === Ps) return;
            let z = (Re.x === Ce ? 0 : 2) | Number(Re.y & Zn), de = M;
            return k && _(M) && (de = A(M), z ^= 1), new N(Ce, de, z);
        }
        return {
            seed: he,
            k2sig: ae
        };
    }
    const $ = {
        lowS: t.lowS,
        prehash: !1
    }, S = {
        lowS: t.lowS,
        prehash: !1
    };
    function w(m, E, T = $) {
        const { seed: I, k2sig: P } = X(m, E, T);
        return pR(t.hash.outputLen, t.nByteLength, t.hmac)(I, P);
    }
    f.BASE._setWindowSize(8);
    function g(m, E, T, I = S) {
        var Re;
        const P = m;
        if (E = cs("msgHash", E), T = cs("publicKey", T), "strict" in I) throw new Error("options.strict was renamed to lowS");
        const { lowS: k, prehash: L } = I;
        let j, ie;
        try {
            if (typeof P == "string" || P instanceof Uint8Array) try {
                j = N.fromDER(P);
            } catch (Ce) {
                if (!(Ce instanceof ff.Err)) throw Ce;
                j = N.fromCompact(P);
            }
            else if (typeof P == "object" && typeof P.r == "bigint" && typeof P.s == "bigint") {
                const { r: Ce, s: M } = P;
                j = new N(Ce, M);
            } else throw new Error("PARSE");
            ie = f.fromHex(T);
        } catch (Ce) {
            if (Ce.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1;
        }
        if (k && j.hasHighS()) return !1;
        L && (E = t.hash(E));
        const { r: ue, s: ce } = j, he = Q(E), ee = u(ce), ae = a(he * ee), ye = a(ue * ee), Se = (Re = f.BASE.multiplyAndAddUnsafe(ie, ae, ye)) == null ? void 0 : Re.toAffine();
        return Se ? a(Se.x) === ue : !1;
    }
    return {
        CURVE: t,
        getPublicKey: D,
        getSharedSecret: K,
        sign: w,
        verify: g,
        ProjectivePoint: f,
        Signature: N,
        utils: U
    };
}
function vde(e, t) {
    const r = e.ORDER;
    let n = Ps;
    for(let p = r - Zn; p % Ka === Ps; p /= Ka)n += Zn;
    const i = n, o = (r - Zn) / Ka ** i, s = (o - Zn) / Ka, a = Ka ** i - Zn, u = Ka ** (i - Zn), f = e.pow(t, o), c = e.pow(t, (o + Zn) / Ka);
    let l = (p, y)=>{
        let _ = f, A = e.pow(y, a), O = e.sqr(A);
        O = e.mul(O, y);
        let N = e.mul(p, O);
        N = e.pow(N, s), N = e.mul(N, A), A = e.mul(N, y), O = e.mul(N, p);
        let U = e.mul(O, A);
        N = e.pow(U, u);
        let D = e.eql(N, e.ONE);
        A = e.mul(O, c), N = e.mul(U, _), O = e.cmov(A, O, D), U = e.cmov(N, U, D);
        for(let H = i; H > 1; H--){
            let K = Ka ** (H - Ka), re = e.pow(U, K);
            const Q = e.eql(re, e.ONE);
            A = e.mul(O, _), _ = e.mul(_, _), re = e.mul(U, _), O = e.cmov(A, O, Q), U = e.cmov(re, U, Q);
        }
        return {
            isValid: D,
            value: O
        };
    };
    if (e.ORDER % JI === Mm) {
        const p = (e.ORDER - Mm) / JI, y = e.sqrt(e.neg(t));
        l = (_, A)=>{
            let O = e.sqr(A);
            const N = e.mul(_, A);
            O = e.mul(O, N);
            let U = e.pow(O, p);
            U = e.mul(U, N);
            const D = e.mul(U, y), H = e.mul(e.sqr(U), A), K = e.eql(H, _);
            let re = e.cmov(D, U, K);
            return {
                isValid: K,
                value: re
            };
        };
    }
    return l;
}
function _de(e, t) {
    if (gR(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r = vde(e, t.Z);
    if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n)=>{
        let i, o, s, a, u, f, c, l;
        i = e.sqr(n), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), s = e.add(o, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), a = e.mul(a, t.A), o = e.sqr(s), f = e.sqr(a), u = e.mul(f, t.A), o = e.add(o, u), o = e.mul(o, s), f = e.mul(f, a), u = e.mul(f, t.B), o = e.add(o, u), c = e.mul(i, s);
        const { isValid: p, value: y } = r(o, f);
        l = e.mul(i, n), l = e.mul(l, y), c = e.cmov(c, s, p), l = e.cmov(l, y, p);
        const _ = e.isOdd(n) === e.isOdd(l);
        return l = e.cmov(e.neg(l), l, _), c = e.div(c, a), {
            x: c,
            y: l
        };
    };
}
function Ede(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return g1(e);
    throw new Error("DST must be Uint8Array or string");
}
const xde = fu;
function ou(e, t) {
    if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
    const r = Array.from({
        length: t
    }).fill(0);
    for(let n = t - 1; n >= 0; n--)r[n] = e & 255, e >>>= 8;
    return new Uint8Array(r);
}
function Sde(e, t) {
    const r = new Uint8Array(e.length);
    for(let n = 0; n < e.length; n++)r[n] = e[n] ^ t[n];
    return r;
}
function bp(e) {
    if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
function $S(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function Ade(e, t, r, n) {
    bp(e), bp(t), $S(r), t.length > 255 && (t = n(Os(g1("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i, blockLen: o } = n, s = Math.ceil(r / i);
    if (s > 255) throw new Error("Invalid xmd length");
    const a = Os(t, ou(t.length, 1)), u = ou(0, o), f = ou(r, 2), c = new Array(s), l = n(Os(u, e, f, ou(0, 1), a));
    c[0] = n(Os(l, ou(1, 1), a));
    for(let y = 1; y <= s; y++){
        const _ = [
            Sde(l, c[y - 1]),
            ou(y + 1, 1),
            a
        ];
        c[y] = n(Os(..._));
    }
    return Os(...c).slice(0, r);
}
function Tde(e, t, r, n, i) {
    if (bp(e), bp(t), $S(r), t.length > 255) {
        const o = Math.ceil(2 * n / 8);
        t = i.create({
            dkLen: o
        }).update(g1("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (r > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i.create({
        dkLen: r
    }).update(e).update(ou(r, 2)).update(t).update(ou(t.length, 1)).digest();
}
function QI(e, t, r) {
    qd(r, {
        DST: "string",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p: n, k: i, m: o, hash: s, expand: a, DST: u } = r;
    bp(e), $S(t);
    const f = Ede(u), c = n.toString(2).length, l = Math.ceil((c + i) / 8), p = t * o * l;
    let y;
    if (a === "xmd") y = Ade(e, f, p, s);
    else if (a === "xof") y = Tde(e, f, p, i, s);
    else if (a === void 0) y = e;
    else throw new Error('expand must be "xmd", "xof" or undefined');
    const _ = new Array(t);
    for(let A = 0; A < t; A++){
        const O = new Array(o);
        for(let N = 0; N < o; N++){
            const U = l * (N + A * o), D = y.subarray(U, U + l);
            O[N] = Oi(xde(D), n);
        }
        _[A] = O;
    }
    return _;
}
function kde(e, t) {
    const r = t.map((n)=>Array.from(n).reverse());
    return (n, i)=>{
        const [o, s, a, u] = r.map((f)=>f.reduce((c, l)=>e.add(e.mul(c, n), l)));
        return n = e.div(o, s), i = e.mul(i, e.div(a, u)), {
            x: n,
            y: i
        };
    };
}
function Ide(e, t, r) {
    if (typeof t != "function") throw new Error("mapToCurve() must be defined");
    return {
        // Encodes byte string to elliptic curve
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        hashToCurve (n, i) {
            const o = QI(n, 2, {
                ...r,
                DST: r.DST,
                ...i
            }), s = e.fromAffine(t(o[0])), a = e.fromAffine(t(o[1])), u = s.add(a).clearCofactor();
            return u.assertValidity(), u;
        },
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        encodeToCurve (n, i) {
            const o = QI(n, 1, {
                ...r,
                DST: r.encodeDST,
                ...i
            }), s = e.fromAffine(t(o[0])).clearCofactor();
            return s.assertValidity(), s;
        }
    };
}
let bR = class extends cR {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, uf.hash(t);
        const n = PS(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen, o = new Uint8Array(i);
        o.set(n.length > i ? t.create().update(n).digest() : n);
        for(let s = 0; s < o.length; s++)o[s] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let s = 0; s < o.length; s++)o[s] ^= 106;
        this.oHash.update(o), o.fill(0);
    }
    update(t) {
        return uf.exists(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        uf.exists(this), uf.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const wR = (e, t, r)=>new bR(e, t).update(r).digest();
wR.create = (e, t)=>new bR(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Bde(e) {
    return {
        hash: e,
        hmac: (t, ...r)=>wR(e, t, Fle(...r)),
        randomBytes: zle
    };
}
function Ode(e, t) {
    const r = (n)=>wde({
            ...e,
            ...Bde(n)
        });
    return Object.freeze({
        ...r(t),
        create: r
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const vR = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), eB = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Pde = BigInt(1), kx = BigInt(2), tB = (e, t)=>(e + t / kx) / t;
function Nde(e) {
    const t = vR, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), u = BigInt(88), f = e * e * e % t, c = f * f * e % t, l = es(c, r, t) * c % t, p = es(l, r, t) * c % t, y = es(p, kx, t) * f % t, _ = es(y, i, t) * y % t, A = es(_, o, t) * _ % t, O = es(A, a, t) * A % t, N = es(O, u, t) * O % t, U = es(N, a, t) * A % t, D = es(U, r, t) * c % t, H = es(D, s, t) * _ % t, K = es(H, n, t) * f % t, re = es(K, kx, t);
    if (!bu.eql(bu.sqr(re), e)) throw new Error("Cannot find square root");
    return re;
}
const bu = yR(vR, void 0, void 0, {
    sqrt: Nde
}), wu = Ode({
    a: BigInt(0),
    b: BigInt(7),
    Fp: bu,
    n: eB,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */ endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (e)=>{
            const t = eB, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Pde * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = BigInt("0x100000000000000000000000000000000"), a = tB(o * e, t), u = tB(-n * e, t);
            let f = Oi(e - a * r - u * i, t), c = Oi(-a * n - u * o, t);
            const l = f > s, p = c > s;
            if (l && (f = t - f), p && (c = t - c), f > s || c > s) throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: l,
                k1: f,
                k2neg: p,
                k2: c
            };
        }
    }
}, lR);
BigInt(0);
wu.ProjectivePoint;
wu.utils.randomPrivateKey;
const Mde = kde(bu, [
    // xNum
    [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    // yNum
    [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
].map((e)=>e.map((t)=>BigInt(t)))), Rde = _de(bu, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: bu.create(BigInt("-11"))
});
Ide(wu.ProjectivePoint, (e)=>{
    const { x: t, y: r } = Rde(bu.create(e[0]));
    return Mde(t, r);
}, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: bu.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: lR
});
function Ix(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Cde(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function _R(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Ude(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Ix(e.outputLen), Ix(e.blockLen);
}
function $de(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function Lde(e, t) {
    _R(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Dde = {
    number: Ix,
    bool: Cde,
    bytes: _R,
    hash: Ude,
    exists: $de,
    output: Lde
};
var iE = Dde;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const oE = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ia = (e, t)=>e << 32 - t | e >>> t, Fde = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!Fde) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function zde(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function ER(e) {
    if (typeof e == "string" && (e = zde(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
let jde = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function xR(e) {
    const t = (n)=>e().update(ER(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function Hde(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
let qde = class extends jde {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = oE(this.buffer);
    }
    update(t) {
        iE.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = ER(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = oE(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        iE.exists(this), iE.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        Hde(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = oE(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
};
const Kde = (e, t, r)=>e & t ^ ~e & r, Wde = (e, t, r)=>e & t ^ e & r ^ t & r, Vde = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), qc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Kc = new Uint32Array(64);
let SR = class extends qde {
    constructor(){
        super(64, 32, 8, !1), this.A = qc[0] | 0, this.B = qc[1] | 0, this.C = qc[2] | 0, this.D = qc[3] | 0, this.E = qc[4] | 0, this.F = qc[5] | 0, this.G = qc[6] | 0, this.H = qc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Kc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Kc[l - 15], y = Kc[l - 2], _ = ia(p, 7) ^ ia(p, 18) ^ p >>> 3, A = ia(y, 17) ^ ia(y, 19) ^ y >>> 10;
            Kc[l] = A + Kc[l - 7] + _ + Kc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = ia(a, 6) ^ ia(a, 11) ^ ia(a, 25), y = c + p + Kde(a, u, f) + Vde[l] + Kc[l] | 0, A = (ia(n, 2) ^ ia(n, 13) ^ ia(n, 22)) + Wde(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Kc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Gde = class extends SR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const Bx = xR(()=>new SR());
xR(()=>new Gde());
function Zde(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Yde(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Xde(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Jde } = crypto ?? globalThis.crypto ?? window.crypto;
function Qde(e = 32) {
    if (typeof Jde == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function ehe(e, t, r = "be") {
    t === void 0 && (t = e.length), Zde(e, t);
    const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
    return n.set(e, i), n;
}
function AR(e) {
    let t, r = 0;
    const n = e.reduce((o, s)=>o + s.length, 0), i = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i.set(o, r), r += o.length;
    }
    return i;
}
const the = new TextEncoder(), rhe = [
    {
        name: "base58",
        charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }
];
function TR(e) {
    for (const t of rhe)if (t.name === e) return t.charset;
    throw TypeError("Charset does not exist: " + e);
}
function nhe(e, t, r = !1) {
    typeof e == "string" && (e = the.encode(e));
    const n = TR(t), i = n.length, o = [];
    let s = "", a, u = 0, f, c;
    for(a = 0; a < e.length; a++)for(u = 0, f = e[a], s += f > 0 || (s.length ^ a) > 0 ? "" : "1"; u in o || f > 0;)c = o[u], c = c > 0 ? c * 256 + f : f, f = c / i | 0, o[u] = c % i, u++;
    for(; u-- > 0;)s += n[o[u]];
    return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function ihe(e, t) {
    const r = TR(t), n = r.length, i = [], o = [];
    e = e.replace("=", "");
    let s, a = 0, u, f;
    for(s = 0; s < e.length; s++){
        if (a = 0, u = r.indexOf(e[s]), u < 0) throw new Error(`Character range out of bounds: ${u}`);
        for(u > 0 || (o.length ^ s) > 0 || o.push(0); a in i || u > 0;)f = i[a], f = f > 0 ? f * n + u : u, u = f >> 8, i[a] = f % 256, a++;
    }
    for(; a-- > 0;)o.push(i[a]);
    return new Uint8Array(o);
}
function kR(e) {
    return Bx(Bx(e));
}
function ohe(e) {
    const t = kR(e);
    return AR([
        e,
        t.slice(0, 4)
    ]);
}
function she(e) {
    const t = e.slice(0, -4), r = e.slice(-4);
    if (kR(t).slice(0, 4).toString() !== r.toString()) throw new Error("Invalid checksum!");
    return t;
}
const rB = {
    encode: nhe,
    decode: ihe
}, IR = {
    encode: (e)=>{
        const t = ohe(e);
        return rB.encode(t, "base58");
    },
    decode: (e)=>{
        const t = rB.decode(e, "base58");
        return she(t);
    }
}, BR = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ahe = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
], Rm = [
    {
        version: 0,
        name: "bech32",
        const: 1
    },
    {
        version: 1,
        name: "bech32m",
        const: 734539939
    }
];
function OR(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = t >> 25;
        t = (t & 33554431) << 5 ^ e[r];
        for(let i = 0; i < 5; ++i)n >> i & 1 && (t ^= ahe[i]);
    }
    return t;
}
function PR(e) {
    const t = [];
    let r;
    for(r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) >> 5);
    for(t.push(0), r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) & 31);
    return t;
}
function che(e, t, r) {
    const n = PR(e).concat(t);
    return OR(n) === r.const;
}
function uhe(e, t, r) {
    const n = PR(e).concat(t).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ]), i = OR(n) ^ r.const, o = [];
    for(let s = 0; s < 6; ++s)o.push(i >> 5 * (5 - s) & 31);
    return o;
}
function NR(e, t, r, n = !0) {
    const i = [];
    let o = 0, s = 0;
    const a = (1 << r) - 1, u = (1 << t + r - 1) - 1;
    for (const f of e){
        if (f < 0 || f >> t > 0) throw new Error("Failed to perform base conversion. Invalid value: " + String(f));
        for(o = (o << t | f) & u, s += t; s >= r;)s -= r, i.push(o >> s & a);
    }
    if (n) s > 0 && i.push(o << r - s & a);
    else if (s >= t || (o << r - s & a) > 0) throw new Error("Failed to perform base conversion. Invalid Size!");
    return i;
}
function fhe(e, t, r) {
    const n = t.concat(uhe(e, t, r));
    let i = e + "1";
    for(let o = 0; o < n.length; ++o)i += BR.charAt(n[o]);
    return i;
}
function MR(e) {
    if (!lhe(e)) throw new Error("Encoded string goes out of bounds!");
    if (e = e.toLowerCase(), !dhe(e)) throw new Error("Encoded string has invalid separator!");
    const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
    for(let o = r + 1; o < e.length; ++o){
        const s = BR.indexOf(e.charAt(o));
        if (s === -1) throw new Error("Character idx out of bounds: " + String(o));
        t.push(s);
    }
    const i = Rm.find((o)=>o.version === t[0]) ?? Rm[0];
    if (!che(n, t, i)) throw new Error("Checksum verification failed!");
    return [
        n,
        t.slice(0, t.length - 6)
    ];
}
function lhe(e) {
    let t, r, n = !1, i = !1;
    for(t = 0; t < e.length; ++t){
        if (r = e.charCodeAt(t), r < 33 || r > 126) return !1;
        r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i = !0);
    }
    return !(n && i);
}
function dhe(e) {
    const t = e.lastIndexOf("1");
    return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function hhe(e, t = "bc", r = 0) {
    const n = [
        r,
        ...NR([
            ...e
        ], 8, 5)
    ], i = Rm.find((s)=>s.version === r) ?? Rm[0], o = fhe(t, n, i);
    return RR(o), o;
}
function RR(e) {
    e = e.toLowerCase();
    const t = e.split("1", 1)[0], [r, n] = MR(e), i = NR(n.slice(1), 5, 8, !1), o = i.length;
    switch(!0){
        case t !== r:
            throw new Error("Returned hrp string is invalid.");
        case i === null || o < 2 || o > 40:
            throw new Error("Decoded string is invalid or out of spec.");
        case n[0] > 16:
            throw new Error("Returned version bit is out of range.");
        default:
            return Uint8Array.from(i);
    }
}
function phe(e) {
    e = e.toLowerCase();
    const [t, r] = MR(e);
    return r[0];
}
const CR = {
    encode: hhe,
    decode: RR,
    version: phe
}, UR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $R = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", ghe = new TextEncoder();
function LR(e, t = !1, r = !0) {
    typeof e == "string" && (e = ghe.encode(e));
    const n = t ? $R : UR;
    let i = "", o = 0, s = 0;
    for(let a = 0; a < e.length; a++)for(s = s << 8 | e[a], o += 8; o >= 6;)o -= 6, i += n[s >> o & 63];
    if (o > 0) for(s <<= 6 - o, i += n[s & 63]; o < 6;)i += r ? "=" : "", o += 2;
    return i;
}
function DR(e, t = !1) {
    const r = t || e.includes("-") || e.includes("_") ? $R.split("") : UR.split("");
    e = e.replace(/=+$/, "");
    const n = e.split("");
    let i = 0, o = 0;
    const s = [];
    for(let a = 0; a < n.length; a++){
        const u = n[a], f = r.indexOf(u);
        if (f === -1) throw new Error("Invalid character: " + u);
        i += 6, o <<= 6, o |= f, i >= 8 && (i -= 8, s.push(o >>> i & 255));
    }
    return new Uint8Array(s);
}
const FR = {
    encode: LR,
    decode: DR
}, zR = {
    encode: (e)=>LR(e, !0, !1),
    decode: (e)=>DR(e, !0)
}, yhe = BigInt(0), mhe = BigInt(255), jR = BigInt(256);
function bhe(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function whe(e, t, r = "be") {
    t === void 0 && (t = bhe(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > yhe;){
        const a = e & mhe, u = Number(a);
        n ? o.setUint8(s++, u) : o.setUint8(s--, u), e = (e - a) / jR;
    }
    return new Uint8Array(i);
}
function vhe(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * jR + BigInt(e[r]);
    return BigInt(t);
}
function _he(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i = 0; n < t.length; n += 8, i++){
        let o = 0;
        for(let s = 0; s < 8; s++)o |= t[n + s] << 7 - s;
        r[i] = o;
    }
    return r;
}
function Ehe(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i = 7; i >= 0; i--, r++)t[r] = n >> i & 1;
    }
    return t.join("");
}
function xhe(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function She(e, t, r = "be") {
    t === void 0 && (t = xhe(e));
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(; e > 0;){
        const a = e & 255;
        n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
    }
    return new Uint8Array(i);
}
function Ahe(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], Xde(t);
    return t;
}
const The = new TextEncoder(), khe = new TextDecoder();
function LS(e) {
    return The.encode(e);
}
function sE(e) {
    return khe.decode(e);
}
function Ihe(e, t) {
    Yde(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function Bhe(e, t, r = "le") {
    t = Ihe(e, t);
    const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
    let s = n ? 0 : t - 1;
    for(let a = 0; a < e.length; a += 2){
        const u = e.substring(a, a + 2), f = parseInt(u, 16);
        n ? o.setUint8(s++, f) : o.setUint8(s--, f);
    }
    return new Uint8Array(i);
}
function Ohe(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
function Phe(e) {
    const t = JSON.stringify(e, (r, n)=>typeof n == "bigint" ? `${n}n` : n);
    return LS(t);
}
function Nhe(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return ehe(e, t, r);
    if (typeof e == "string") return Bhe(e, t, r);
    if (typeof e == "bigint") return whe(e, t, r);
    if (typeof e == "number") return She(e, t, r);
    if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    throw TypeError("Unsupported format:" + typeof e);
}
const kr = class kr extends Uint8Array {
    static random(t = 32) {
        const r = Qde(t);
        return new kr(r, t);
    }
    constructor(t, r, n){
        const i = Nhe(t, r, n);
        super(i);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new Khe(this);
    }
    toNum(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return Ahe(r);
    }
    toBin() {
        return Ehe(this);
    }
    toBig(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return vhe(r);
    }
    toHash() {
        const t = Bx(this);
        return new kr(t);
    }
    toJson() {
        const t = sE(this);
        return JSON.parse(t);
    }
    toBech32(t, r = 0) {
        return CR.encode(this, t, r);
    }
    toStr() {
        return sE(this);
    }
    toHex() {
        return Ohe(this);
    }
    toBytes() {
        return new Uint8Array(this);
    }
    tob58chk() {
        return IR.encode(this);
    }
    toBase64() {
        return FR.encode(this);
    }
    toB64url() {
        return zR.encode(this);
    }
    prepend(t) {
        return kr.join([
            kr.bytes(t),
            this
        ]);
    }
    append(t) {
        return kr.join([
            this,
            kr.bytes(t)
        ]);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new kr(n);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new kr(n);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new kr(t);
    }
    write(t, r) {
        const n = kr.bytes(t);
        this.set(n, r);
    }
    prefixSize(t) {
        const r = kr.varInt(this.length, t);
        return kr.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new kr(Uint8Array.from(t));
    }
    static of(...t) {
        return new kr(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i)=>kr.bytes(i)), n = AR(r);
        return new kr(n);
    }
    static varInt(t, r) {
        if (t < 253) return kr.num(t, 1);
        if (t < 65536) return kr.of(253, ...kr.num(t, 2, r));
        if (t < 4294967296) return kr.of(254, ...kr.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return kr.of(255, ...kr.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
};
kr.num = Mhe, kr.big = Che, kr.bin = Rhe, kr.raw = Uhe, kr.str = $he, kr.hex = Lhe, kr.bytes = Dhe, kr.json = Fhe, kr.base64 = zhe, kr.b64url = jhe, kr.bech32 = Hhe, kr.b58chk = qhe, kr.encode = LS, kr.decode = sE;
let ir = kr;
function Mhe(e, t, r) {
    return new ir(e, t, r);
}
function Rhe(e, t, r) {
    return new ir(_he(e), t, r);
}
function Che(e, t, r) {
    return new ir(e, t, r);
}
function Uhe(e, t, r) {
    return new ir(e, t, r);
}
function $he(e, t, r) {
    return new ir(LS(e), t, r);
}
function Lhe(e, t, r) {
    return new ir(e, t, r);
}
function Dhe(e, t, r) {
    return new ir(e, t, r);
}
function Fhe(e) {
    return new ir(Phe(e));
}
function zhe(e) {
    return new ir(FR.decode(e));
}
function jhe(e) {
    return new ir(zR.decode(e));
}
function Hhe(e) {
    return new ir(CR.decode(e));
}
function qhe(e) {
    return new ir(IR.decode(e));
}
class Khe {
    constructor(t){
        this.data = ir.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new ir(this.data.slice(0, t));
    }
    read(t) {
        t = t ?? this.readSize();
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    readSize(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).toNum(t);
            case r === 254:
                return this.read(4).toNum(t);
            case r === 255:
                return this.read(8).toNum(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
}
const Cm = wu.CURVE, DS = Cm.n, Whe = Cm.p, Vhe = {
    x: Cm.Gx,
    y: Cm.Gy
}, Ghe = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const Ox = {
    N: DS,
    P: Whe,
    G: Vhe,
    _0n: Ghe
}, bh = yR(DS, 32, !0), HR = (e)=>Oi(e, DS);
function FS(e, t = !1) {
    if (t) throw new Error(e);
    return !1;
}
function qR(e) {
    return ir.random(e);
}
function Zhe(e) {
    const t = ir.bytes(e).big;
    return ir.big(HR(t), 32);
}
var Yhe = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fail: FS,
    mod_bytes: Zhe,
    random: qR
});
const { N: Xhe, _0n: Jhe } = Ox;
function Qhe(e, t, r) {
    const n = ir.bytes(e);
    return n.length !== t ? FS(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function epe(e, t) {
    return typeof e == "bigint" && Jhe < e && e < Xhe || FS("x value is not in the field!", t), !0;
}
const nB = wu.ProjectivePoint, Un = class Un extends Uint8Array {
    static mod(t) {
        return new Un(t);
    }
    static is_valid(t, r) {
        const n = ir.bytes(t, 32).big;
        return epe(n, r);
    }
    constructor(t){
        let r = tpe(t);
        r = HR(r), Un.is_valid(r, !0), super(ir.big(r, 32), 32);
    }
    get buff() {
        return new ir(this);
    }
    get raw() {
        return this.buff.raw;
    }
    get big() {
        return this.buff.big;
    }
    get hex() {
        return this.buff.hex;
    }
    get point() {
        return this.generate();
    }
    get hasOddY() {
        return this.point.hasOddY;
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    gt(t) {
        return new Un(t).big > this.big;
    }
    lt(t) {
        return new Un(t).big < this.big;
    }
    eq(t) {
        return new Un(t).big === this.big;
    }
    ne(t) {
        return new Un(t).big !== this.big;
    }
    add(t) {
        const r = Un.mod(t), n = bh.add(this.big, r.big);
        return new Un(n);
    }
    sub(t) {
        const r = Un.mod(t), n = bh.sub(this.big, r.big);
        return new Un(n);
    }
    mul(t) {
        const r = Un.mod(t), n = bh.mul(this.big, r.big);
        return new Un(n);
    }
    pow(t) {
        const r = Un.mod(t), n = bh.pow(this.big, r.big);
        return new Un(n);
    }
    div(t) {
        const r = Un.mod(t), n = bh.div(this.big, r.big);
        return new Un(n);
    }
    negate() {
        return new Un(Un.N - this.big);
    }
    generate() {
        const r = wu.ProjectivePoint.BASE.multiply(this.big);
        return fc.import(r);
    }
};
Un.N = wu.CURVE.n;
let yi = Un;
const mn = class mn {
    static from_x(t) {
        let r = rpe(t);
        r.length === 32 && (r = r.prepend(2)), Qhe(r, 33);
        const n = nB.fromHex(r.hex);
        return n.assertValidity(), new mn(n.x, n.y);
    }
    static generate(t) {
        const r = yi.mod(t), n = mn.base.multiply(r.big);
        return mn.import(n);
    }
    static import(t) {
        const r = t instanceof mn ? {
            x: t.x.big,
            y: t.y.big
        } : {
            x: t.x,
            y: t.y
        };
        return new mn(r.x, r.y);
    }
    constructor(t, r){
        this._p = new nB(t, r, 1n), this.p.assertValidity();
    }
    get p() {
        return this._p;
    }
    get x() {
        return ir.big(this.p.x, 32);
    }
    get y() {
        return ir.big(this.p.y, 32);
    }
    get buff() {
        return ir.raw(this.p.toRawBytes(!0));
    }
    get raw() {
        return this.buff.raw;
    }
    get hex() {
        return this.buff.hex;
    }
    get hasEvenY() {
        return this.p.hasEvenY();
    }
    get hasOddY() {
        return !this.p.hasEvenY();
    }
    eq(t) {
        const r = t instanceof mn ? t : mn.from_x(t);
        return this.x.big === r.x.big && this.y.big === r.y.big;
    }
    add(t) {
        return t instanceof mn ? mn.import(this.p.add(t.p)) : mn.import(this.p.add(mn.generate(t).p));
    }
    sub(t) {
        return t instanceof mn ? mn.import(this.p.subtract(t.p)) : mn.import(this.p.subtract(mn.generate(t).p));
    }
    mul(t) {
        return t instanceof mn ? mn.import(this.p.multiply(t.x.big)) : mn.import(this.p.multiply(yi.mod(t).big));
    }
    negate() {
        return mn.import(this.p.negate());
    }
};
mn.P = Ox.P, mn.G = Ox.G, mn.base = wu.ProjectivePoint.BASE;
let fc = mn;
function tpe(e) {
    if (e instanceof yi) return e.big;
    if (e instanceof fc) return e.x.big;
    if (e instanceof Uint8Array) return ir.raw(e).big;
    if (typeof e == "string") return ir.hex(e).big;
    if (typeof e == "number") return ir.num(e).big;
    if (typeof e == "bigint") return BigInt(e);
    throw TypeError("Invalid input type:" + typeof e);
}
function rpe(e) {
    if (e instanceof yi) return e.point.buff;
    if (e instanceof fc) return e.buff;
    if (e instanceof Uint8Array || typeof e == "string") return ir.bytes(e);
    if (typeof e == "number" || typeof e == "bigint") return ir.bytes(e, 32);
    throw new TypeError(`Unknown type: ${typeof e}`);
}
function Px(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function npe(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function KR(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function ipe(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Px(e.outputLen), Px(e.blockLen);
}
function ope(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function spe(e, t) {
    KR(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const ape = {
    number: Px,
    bool: npe,
    bytes: KR,
    hash: ipe,
    exists: ope,
    output: spe
};
var lf = ape;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const cpe = (e)=>e instanceof Uint8Array, aE = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), oa = (e, t)=>e << 32 - t | e >>> t, upe = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!upe) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function fpe(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
}
function zS(e) {
    if (typeof e == "string" && (e = fpe(e)), !cpe(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e;
}
class WR {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function qf(e) {
    const t = (n)=>e().update(zS(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function lpe(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), u = n ? 4 : 0, f = n ? 0 : 4;
    e.setUint32(t + u, s, n), e.setUint32(t + f, a, n);
}
class jS extends WR {
    constructor(t, r, n, i){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = aE(this.buffer);
    }
    update(t) {
        lf.exists(this);
        const { view: r, buffer: n, blockLen: i } = this;
        t = zS(t);
        const o = t.length;
        for(let s = 0; s < o;){
            const a = Math.min(i - this.pos, o - s);
            if (a === i) {
                const u = aE(t);
                for(; i <= o - s; s += i)this.process(u, s);
                continue;
            }
            n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        lf.exists(this), lf.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i, isLE: o } = this;
        let { pos: s } = this;
        r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
        for(let l = s; l < i; l++)r[l] = 0;
        lpe(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const a = aE(t), u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = u / 4, c = this.get();
        if (f > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let l = 0; l < f; l++)a.setUint32(4 * l, c[l], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
        return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
    }
}
const dpe = (e, t, r)=>e & t ^ ~e & r, hpe = (e, t, r)=>e & t ^ e & r ^ t & r, ppe = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), Wc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Vc = new Uint32Array(64);
class VR extends jS {
    constructor(){
        super(64, 32, 8, !1), this.A = Wc[0] | 0, this.B = Wc[1] | 0, this.C = Wc[2] | 0, this.D = Wc[3] | 0, this.E = Wc[4] | 0, this.F = Wc[5] | 0, this.G = Wc[6] | 0, this.H = Wc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: u } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = u | 0;
    }
    process(t, r) {
        for(let l = 0; l < 16; l++, r += 4)Vc[l] = t.getUint32(r, !1);
        for(let l = 16; l < 64; l++){
            const p = Vc[l - 15], y = Vc[l - 2], _ = oa(p, 7) ^ oa(p, 18) ^ p >>> 3, A = oa(y, 17) ^ oa(y, 19) ^ y >>> 10;
            Vc[l] = A + Vc[l - 7] + _ + Vc[l - 16] | 0;
        }
        let { A: n, B: i, C: o, D: s, E: a, F: u, G: f, H: c } = this;
        for(let l = 0; l < 64; l++){
            const p = oa(a, 6) ^ oa(a, 11) ^ oa(a, 25), y = c + p + dpe(a, u, f) + ppe[l] + Vc[l] | 0, A = (oa(n, 2) ^ oa(n, 13) ^ oa(n, 22)) + hpe(n, i, o) | 0;
            c = f, f = u, u = a, a = s + y | 0, s = o, o = i, i = n, n = y + A | 0;
        }
        n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, f = f + this.G | 0, c = c + this.H | 0, this.set(n, i, o, s, a, u, f, c);
    }
    roundClean() {
        Vc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}
class gpe extends VR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
}
const Um = qf(()=>new VR());
qf(()=>new gpe());
const py = BigInt(2 ** 32 - 1), Nx = BigInt(32);
function GR(e, t = !1) {
    return t ? {
        h: Number(e & py),
        l: Number(e >> Nx & py)
    } : {
        h: Number(e >> Nx & py) | 0,
        l: Number(e & py) | 0
    };
}
function ype(e, t = !1) {
    let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
    for(let i = 0; i < e.length; i++){
        const { h: o, l: s } = GR(e[i], t);
        [r[i], n[i]] = [
            o,
            s
        ];
    }
    return [
        r,
        n
    ];
}
const mpe = (e, t)=>BigInt(e >>> 0) << Nx | BigInt(t >>> 0), bpe = (e, t, r)=>e >>> r, wpe = (e, t, r)=>e << 32 - r | t >>> r, vpe = (e, t, r)=>e >>> r | t << 32 - r, _pe = (e, t, r)=>e << 32 - r | t >>> r, Epe = (e, t, r)=>e << 64 - r | t >>> r - 32, xpe = (e, t, r)=>e >>> r - 32 | t << 64 - r, Spe = (e, t)=>t, Ape = (e, t)=>e, Tpe = (e, t, r)=>e << r | t >>> 32 - r, kpe = (e, t, r)=>t << r | e >>> 32 - r, Ipe = (e, t, r)=>t << r - 32 | e >>> 64 - r, Bpe = (e, t, r)=>e << r - 32 | t >>> 64 - r;
function Ope(e, t, r, n) {
    const i = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    };
}
const Ppe = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0), Npe = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0, Mpe = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), Rpe = (e, t, r, n, i)=>t + r + n + i + (e / 2 ** 32 | 0) | 0, Cpe = (e, t, r, n, i)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Upe = (e, t, r, n, i, o)=>t + r + n + i + o + (e / 2 ** 32 | 0) | 0, $pe = {
    fromBig: GR,
    split: ype,
    toBig: mpe,
    shrSH: bpe,
    shrSL: wpe,
    rotrSH: vpe,
    rotrSL: _pe,
    rotrBH: Epe,
    rotrBL: xpe,
    rotr32H: Spe,
    rotr32L: Ape,
    rotlSH: Tpe,
    rotlSL: kpe,
    rotlBH: Ipe,
    rotlBL: Bpe,
    add: Ope,
    add3L: Ppe,
    add3H: Npe,
    add4L: Mpe,
    add4H: Rpe,
    add5H: Upe,
    add5L: Cpe
};
var Er = $pe;
const [Lpe, Dpe] = Er.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), Gc = new Uint32Array(80), Zc = new Uint32Array(80);
class y1 extends jS {
    constructor(){
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: u, Eh: f, El: c, Fh: l, Fl: p, Gh: y, Gl: _, Hh: A, Hl: O } = this;
        return [
            t,
            r,
            n,
            i,
            o,
            s,
            a,
            u,
            f,
            c,
            l,
            p,
            y,
            _,
            A,
            O
        ];
    }
    // prettier-ignore
    set(t, r, n, i, o, s, a, u, f, c, l, p, y, _, A, O) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = f | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = y | 0, this.Gl = _ | 0, this.Hh = A | 0, this.Hl = O | 0;
    }
    process(t, r) {
        for(let D = 0; D < 16; D++, r += 4)Gc[D] = t.getUint32(r), Zc[D] = t.getUint32(r += 4);
        for(let D = 16; D < 80; D++){
            const H = Gc[D - 15] | 0, K = Zc[D - 15] | 0, re = Er.rotrSH(H, K, 1) ^ Er.rotrSH(H, K, 8) ^ Er.shrSH(H, K, 7), Q = Er.rotrSL(H, K, 1) ^ Er.rotrSL(H, K, 8) ^ Er.shrSL(H, K, 7), G = Gc[D - 2] | 0, R = Zc[D - 2] | 0, X = Er.rotrSH(G, R, 19) ^ Er.rotrBH(G, R, 61) ^ Er.shrSH(G, R, 6), $ = Er.rotrSL(G, R, 19) ^ Er.rotrBL(G, R, 61) ^ Er.shrSL(G, R, 6), S = Er.add4L(Q, $, Zc[D - 7], Zc[D - 16]), w = Er.add4H(S, re, X, Gc[D - 7], Gc[D - 16]);
            Gc[D] = w | 0, Zc[D] = S | 0;
        }
        let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: u, Dh: f, Dl: c, Eh: l, El: p, Fh: y, Fl: _, Gh: A, Gl: O, Hh: N, Hl: U } = this;
        for(let D = 0; D < 80; D++){
            const H = Er.rotrSH(l, p, 14) ^ Er.rotrSH(l, p, 18) ^ Er.rotrBH(l, p, 41), K = Er.rotrSL(l, p, 14) ^ Er.rotrSL(l, p, 18) ^ Er.rotrBL(l, p, 41), re = l & y ^ ~l & A, Q = p & _ ^ ~p & O, G = Er.add5L(U, K, Q, Dpe[D], Zc[D]), R = Er.add5H(G, N, H, re, Lpe[D], Gc[D]), X = G | 0, $ = Er.rotrSH(n, i, 28) ^ Er.rotrBH(n, i, 34) ^ Er.rotrBH(n, i, 39), S = Er.rotrSL(n, i, 28) ^ Er.rotrBL(n, i, 34) ^ Er.rotrBL(n, i, 39), w = n & o ^ n & a ^ o & a, g = i & s ^ i & u ^ s & u;
            N = A | 0, U = O | 0, A = y | 0, O = _ | 0, y = l | 0, _ = p | 0, ({ h: l, l: p } = Er.add(f | 0, c | 0, R | 0, X | 0)), f = a | 0, c = u | 0, a = o | 0, u = s | 0, o = n | 0, s = i | 0;
            const m = Er.add3L(X, S, g);
            n = Er.add3H(m, R, $, w), i = m | 0;
        }
        ({ h: n, l: i } = Er.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), ({ h: o, l: s } = Er.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0)), ({ h: a, l: u } = Er.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0)), ({ h: f, l: c } = Er.add(this.Dh | 0, this.Dl | 0, f | 0, c | 0)), ({ h: l, l: p } = Er.add(this.Eh | 0, this.El | 0, l | 0, p | 0)), ({ h: y, l: _ } = Er.add(this.Fh | 0, this.Fl | 0, y | 0, _ | 0)), ({ h: A, l: O } = Er.add(this.Gh | 0, this.Gl | 0, A | 0, O | 0)), ({ h: N, l: U } = Er.add(this.Hh | 0, this.Hl | 0, N | 0, U | 0)), this.set(n, i, o, s, a, u, f, c, l, p, y, _, A, O, N, U);
    }
    roundClean() {
        Gc.fill(0), Zc.fill(0);
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class Fpe extends y1 {
    constructor(){
        super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
    }
}
class zpe extends y1 {
    constructor(){
        super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
    }
}
class jpe extends y1 {
    constructor(){
        super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
    }
}
const Hpe = qf(()=>new y1());
qf(()=>new Fpe());
qf(()=>new zpe());
qf(()=>new jpe());
const qpe = new Uint8Array([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), ZR = Uint8Array.from({
    length: 16
}, (e, t)=>t), Kpe = ZR.map((e)=>(9 * e + 5) % 16);
let HS = [
    ZR
], qS = [
    Kpe
];
for(let e = 0; e < 4; e++)for (let t of [
    HS,
    qS
])t.push(t[e].map((r)=>qpe[r]));
const YR = [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>new Uint8Array(e)), Wpe = HS.map((e, t)=>e.map((r)=>YR[t][r])), Vpe = qS.map((e, t)=>e.map((r)=>YR[t][r])), Gpe = new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), Zpe = new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]), gy = (e, t)=>e << t | e >>> 32 - t;
function iB(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const yy = new Uint32Array(16);
class Ype extends jS {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
        return [
            t,
            r,
            n,
            i,
            o
        ];
    }
    set(t, r, n, i, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)yy[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, u = a, f = this.h3 | 0, c = f, l = this.h4 | 0, p = l;
        for(let y = 0; y < 5; y++){
            const _ = 4 - y, A = Gpe[y], O = Zpe[y], N = HS[y], U = qS[y], D = Wpe[y], H = Vpe[y];
            for(let K = 0; K < 16; K++){
                const re = gy(n + iB(y, o, a, f) + yy[N[K]] + A, D[K]) + l | 0;
                n = l, l = f, f = gy(a, 10) | 0, a = o, o = re;
            }
            for(let K = 0; K < 16; K++){
                const re = gy(i + iB(_, s, u, c) + yy[U[K]] + O, H[K]) + p | 0;
                i = p, p = c, c = gy(u, 10) | 0, u = s, s = re;
            }
        }
        this.set(this.h1 + a + c | 0, this.h2 + f + p | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + u | 0);
    }
    roundClean() {
        yy.fill(0);
    }
    destroy() {
        this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
    }
}
const Xpe = qf(()=>new Ype());
class XR extends WR {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, lf.hash(t);
        const n = zS(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen, o = new Uint8Array(i);
        o.set(n.length > i ? t.create().update(n).digest() : n);
        for(let s = 0; s < o.length; s++)o[s] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let s = 0; s < o.length; s++)o[s] ^= 106;
        this.oHash.update(o), o.fill(0);
    }
    update(t) {
        return lf.exists(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        lf.exists(this), lf.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
}
const JR = (e, t, r)=>new XR(e, t).update(r).digest();
JR.create = (e, t)=>new XR(e, t);
function Jpe(e) {
    const t = ir.bytes(e);
    return ir.raw(Um(t));
}
function Qpe(e) {
    const t = ir.bytes(e);
    return ir.raw(Um(Um(t)));
}
function QR(e) {
    const t = ir.bytes(e);
    return ir.raw(Xpe(Um(t)));
}
function e0e(e, t) {
    const r = ir.bytes(e), n = ir.bytes(t);
    return ir.raw(JR(Hpe, r, n));
}
function t0e(e) {
    const t = ir.str(e).digest;
    return ir.join([
        t,
        t
    ]);
}
function r0e(e = 32) {
    return KS(qR(e));
}
function KS(e) {
    return yi.mod(e).buff;
}
function eC(e, t = !1) {
    const r = yi.mod(e).point;
    return t ? r.x : r.buff;
}
function tC(e, t) {
    const r = fc.from_x(t), n = yi.mod(e);
    return r.mul(n).buff;
}
function n0e(e, t, r = "ecdh/code") {
    const n = t0e(r), i = KS(e), o = eC(i), s = ir.bytes(t), a = tC(i, s), u = [
        o.hex,
        s.hex
    ];
    return u.sort(), e0e(a, ir.join([
        n,
        ...u
    ]));
}
function i0e(e) {
    const t = ir.bytes(e);
    switch(!0){
        case t.length === 32:
            return !0;
        case t.length === 33 && t[0] === 2:
            return !0;
        case t.length === 33 && t[0] === 3:
            return !1;
        default:
            throw new TypeError(`Invalid public key: ${t.hex}`);
    }
}
function o0e(e) {
    const t = ir.bytes(e);
    switch(t.length){
        case 32:
            return t;
        case 33:
            return t.slice(1, 33);
        default:
            throw new Error(`Invalid key length: ${t.length}`);
    }
}
var s0e = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    genSecretKey: r0e,
    getPublicKey: eC,
    getSecretKey: KS,
    getSharedCode: n0e,
    getSharedKey: tC,
    is_even_pub: i0e,
    xonly_pub: o0e
});
ir.random(32);
const Mx = {
    ...s0e,
    ...Yhe
};
function m1(e) {
    const t = Ze.bytes(e);
    return Ia(t, 33), QR(t);
}
function rC(e) {
    const t = Ba.fmt.toBytes(e, !1);
    return QR(t);
}
function nC(e) {
    const t = Ba.fmt.toBytes(e, !1);
    return Jpe(t);
}
function iC(e, t = "main") {
    const r = t === "main" ? [
        "1"
    ] : [
        "m",
        "n"
    ];
    for (const n of r)if (e.startsWith(n)) return !0;
    return !1;
}
function oC(e, t = "main") {
    const r = Ze.bytes(e), n = t === "main" ? Ze.num(0) : Ze.num(111);
    return Ia(e, 20), r.prepend(n).tob58chk();
}
function a0e(e, t = "main") {
    if (!iC(e, t)) throw new TypeError("Invalid p2pkh address!");
    return Ze.b58chk(e).slice(1);
}
function c0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 20), [
        "OP_DUP",
        "OP_HASH160",
        t.hex,
        "OP_EQUALVERIFY",
        "OP_CHECKSIG"
    ];
}
function u0e(e, t) {
    const r = m1(e);
    return oC(r, t);
}
const sC = {
    check: iC,
    encode: oC,
    decode: a0e,
    hash: m1,
    scriptPubKey: c0e,
    fromPubKey: u0e
};
function aC(e, t = "main") {
    const r = t === "main" ? [
        "3"
    ] : [
        "2"
    ];
    for (const n of r)if (e.startsWith(n)) return !0;
    return !1;
}
function cC(e, t = "main") {
    const r = t === "main" ? Ze.num(5) : Ze.num(196), n = Ze.bytes(e);
    return Ia(n, 20), n.prepend(r).tob58chk();
}
function f0e(e, t = "main") {
    if (!aC(e, t)) throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
    return Ze.b58chk(e).slice(1);
}
function l0e(e) {
    return [
        "OP_HASH160",
        Ze.bytes(e).hex,
        "OP_EQUAL"
    ];
}
function d0e(e, t) {
    const r = rC(e);
    return cC(r, t);
}
const uC = {
    check: aC,
    encode: cC,
    decode: f0e,
    hash: rC,
    scriptPubKey: l0e,
    fromScript: d0e
}, WS = {
    main: "bc",
    testnet: "tb",
    signet: "tb",
    regtest: "bcrt"
}, h0e = [
    "bc1q",
    "tb1q",
    "bcrt1q"
];
function fC(e) {
    for (const t of h0e)if (e.startsWith(t)) return !0;
    return !1;
}
function lC(e, t = "main") {
    const r = WS[t], n = Ze.bytes(e);
    return Ia(n, 20), n.toBech32(r, 0);
}
function p0e(e) {
    if (!fC(e)) throw new TypeError("Invalid segwit address!");
    return Ze.bech32(e);
}
function g0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 20), [
        "OP_0",
        t.hex
    ];
}
function y0e(e, t) {
    const r = m1(e);
    return lC(r, t);
}
const dC = {
    check: fC,
    encode: lC,
    decode: p0e,
    hash: m1,
    scriptPubKey: g0e,
    fromPubKey: y0e
}, m0e = [
    "bc1q",
    "tb1q",
    "bcrt1q"
];
function hC(e) {
    for (const t of m0e)if (e.startsWith(t)) return !0;
    return !1;
}
function pC(e, t = "main") {
    const r = WS[t], n = Ze.bytes(e);
    return Ia(n, 32), n.toBech32(r, 0);
}
function b0e(e) {
    if (!hC(e)) throw new TypeError("Invalid segwit address!");
    return Ze.bech32(e);
}
function w0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 32), [
        "OP_0",
        t.hex
    ];
}
function v0e(e, t) {
    const r = nC(e);
    return pC(r, t);
}
const gC = {
    check: hC,
    encode: pC,
    decode: b0e,
    hash: nC,
    scriptPubKey: w0e,
    fromScript: v0e
};
function Af(e) {
    const t = Ze.bytes(e);
    return t.length > 32 ? t.slice(1, 33) : t;
}
const _0e = [
    "bc1p",
    "tb1p",
    "bcrt1p"
];
function yC(e) {
    for (const t of _0e)if (e.startsWith(t)) return !0;
    return !1;
}
function mC(e, t = "main") {
    const r = WS[t], n = Ze.bytes(e);
    return Ia(n, 32), n.toBech32(r, 1);
}
function E0e(e) {
    if (!yC(e)) throw new TypeError("Invalid taproot address!");
    return Ze.bech32(e);
}
function x0e(e) {
    const t = Ze.bytes(e);
    return Ia(t, 32), [
        "OP_1",
        t.hex
    ];
}
function S0e(e, t) {
    const r = Af(e);
    return mC(r, t);
}
const bC = {
    check: yC,
    encode: mC,
    decode: E0e,
    scriptPubKey: x0e,
    fromPubKey: S0e
}, A0e = {
    version: 2,
    vin: [],
    vout: [],
    locktime: 0
}, T0e = {
    scriptSig: [],
    sequence: 4294967293,
    witness: []
}, k0e = {
    value: 0n,
    scriptPubKey: []
};
function VS(e) {
    const t = {
        ...A0e,
        ...e
    };
    return t.vin = t.vin.map((r)=>({
            ...T0e,
            ...r
        })), t.vout = t.vout.map((r)=>({
            ...k0e,
            ...r
        })), t;
}
function ld(e, t) {
    const { version: r, vin: n, vout: i, locktime: o } = VS(e), s = t !== !0 && I0e(n), a = [
        wC(r)
    ];
    s && a.push(Ze.hex("0001")), a.push(B0e(n)), a.push(O0e(i));
    for (const u of n)s && a.push(N0e(u.witness));
    return a.push(vC(o)), Ze.join(a);
}
function I0e(e) {
    for (const t of e){
        const { witness: r } = t;
        if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0) return !0;
    }
    return !1;
}
function wC(e) {
    return Ze.num(e, 4).reverse();
}
function GS(e) {
    return Ze.hex(e, 32).reverse();
}
function ZS(e) {
    return Ze.num(e, 4).reverse();
}
function YS(e) {
    if (typeof e == "string") return Ze.hex(e, 4).reverse();
    if (typeof e == "number") return Ze.num(e, 4).reverse();
    throw new Error("Unrecognized format: " + String(e));
}
function B0e(e) {
    const t = [
        Ze.varInt(e.length, "le")
    ];
    for (const r of e){
        const { txid: n, vout: i, scriptSig: o, sequence: s } = r;
        t.push(GS(n)), t.push(ZS(i)), t.push(Hf(o, !0)), t.push(YS(s));
    }
    return Ze.join(t);
}
function A0(e) {
    if (typeof e == "number") {
        if (e % 1 !== 0) throw new Error("Value must be an integer:" + String(e));
        return Ze.num(e, 8).reverse();
    }
    return Ze.big(e, 8).reverse();
}
function O0e(e) {
    const t = [
        Ze.varInt(e.length, "le")
    ];
    for (const r of e)t.push(P0e(r));
    return Ze.join(t);
}
function P0e(e) {
    const { value: t, scriptPubKey: r } = e, n = [];
    return n.push(A0(t)), n.push(Hf(r, !0)), Ze.join(n);
}
function N0e(e = []) {
    const t = [];
    if (Array.isArray(e)) {
        const r = Ze.varInt(e.length);
        t.push(r);
        for (const n of e)t.push(M0e(n));
        return Ze.join(t);
    } else return Ze.bytes(e);
}
function M0e(e) {
    return R0e(e) ? new Ze(0) : Hf(e, !0);
}
function R0e(e) {
    if (Array.isArray(e)) return e.length === 0;
    if (typeof e == "string" && e === "") return !0;
    const t = Ze.bytes(e);
    return t.length === 1 && t[0] === 0;
}
function vC(e) {
    if (typeof e == "string") return Ze.hex(e, 4);
    if (typeof e == "number") return Ze.num(e, 4).reverse();
    throw new Error("Unrecognized format: " + String(e));
}
function XS(e) {
    typeof e == "string" && (e = Ze.hex(e).raw);
    const t = new Hd(e), r = C0e(t), n = U0e(t), i = $0e(t), o = D0e(t);
    if (n) for (const a of i)a.witness = z0e(t);
    const s = j0e(t);
    return {
        version: r,
        vin: i,
        vout: o,
        locktime: s
    };
}
function C0e(e) {
    return e.read(4).reverse().toNum();
}
function U0e(e) {
    const [t, r] = [
        ...e.peek(2)
    ];
    if (t === 0) {
        if (e.read(2), r === 1) return !0;
        throw new Error(`Invalid witness flag: ${r}`);
    }
    return !1;
}
function $0e(e) {
    const t = [], r = e.readSize("le");
    for(let n = 0; n < r; n++)t.push(L0e(e));
    return t;
}
function L0e(e) {
    return {
        txid: e.read(32).reverse().toHex(),
        vout: e.read(4).reverse().toNum(),
        scriptSig: EC(e),
        sequence: e.read(4).reverse().toHex(),
        witness: []
    };
}
function D0e(e) {
    const t = [], r = e.readSize("le");
    for(let n = 0; n < r; n++)t.push(F0e(e));
    return t;
}
function F0e(e) {
    return {
        value: e.read(8).reverse().big,
        scriptPubKey: EC(e)
    };
}
function z0e(e) {
    const t = [], r = e.readSize();
    for(let n = 0; n < r; n++){
        const i = _C(e);
        t.push(i ?? "");
    }
    return t;
}
function _C(e, t) {
    const r = e.readSize("le");
    return r > 0 ? e.read(r).hex : null;
}
function EC(e, t) {
    const r = _C(e);
    return r !== null ? r : [];
}
function j0e(e) {
    return e.read(4).reverse().toNum();
}
function H0e(e) {
    if (oR(e)) return XS(e);
    if (typeof e == "object" && !(e instanceof Uint8Array)) return ld(e), VS(e);
    throw new Error("Invalid format: " + typeof e);
}
function q0e(e) {
    if (oR(e)) return XS(e), Ze.bytes(e);
    if (typeof e == "object") return ld(e);
    throw new Error("Invalid format: " + typeof e);
}
const JS = {
    toBytes: q0e,
    toJson: H0e
}, K0e = [
    [
        "p2pkh",
        /^76a914(?<hash>\w{40})88ac$/
    ],
    [
        "p2sh",
        /^a914(?<hash>\w{40})87$/
    ],
    [
        "p2w-pkh",
        /^0014(?<hash>\w{40})$/
    ],
    [
        "p2w-sh",
        /^0020(?<hash>\w{64})$/
    ],
    [
        "p2tr",
        /^5120(?<hash>\w{64})$/
    ]
], W0e = [
    192,
    194,
    196,
    198,
    200,
    202,
    204,
    206,
    208,
    210,
    212,
    214,
    216,
    218,
    220,
    222,
    224,
    226,
    228,
    230,
    232,
    234,
    236,
    238,
    240,
    242,
    244,
    246,
    248,
    250,
    252,
    254,
    102,
    126,
    128,
    132,
    150,
    152,
    186,
    188,
    190
];
function V0e(e) {
    let t = e.at(-1);
    return bc(t) && (t = Ze.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), Ze.raw(t)) : null;
}
function G0e(e) {
    let t = e.at(-1);
    return bc(t) && (t = Ze.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && W0e.includes(t[0] & 254) ? (e.pop(), Ze.raw(t)) : null;
}
function Z0e(e) {
    if (e.length > 1) {
        const t = e.at(-1);
        try {
            const r = Ba.fmt.toBytes(t);
            return e.pop(), r;
        } catch  {
            return null;
        }
    }
    return null;
}
function Y0e(e) {
    const t = [];
    for (const r of e)if (bc(r) || r instanceof Uint8Array || typeof r == "number") t.push(Ze.bytes(r));
    else throw new Error("unrecognized value: " + String(r));
    return t;
}
function X0e(e = []) {
    const t = [
        ...e
    ], r = V0e(t), n = G0e(t), i = Z0e(t), o = Y0e(t);
    return {
        annex: r,
        cblock: n,
        script: i,
        params: o
    };
}
function J0e(e) {
    const t = Ba.fmt.toBytes(e, !1).hex;
    for (const [r, n] of K0e){
        const i = r, { groups: o } = n.exec(t) ?? {}, { hash: s } = o ?? {};
        if (bc(s)) return {
            type: i,
            data: Ze.hex(s)
        };
    }
    return {
        type: "raw",
        data: Ze.hex(t)
    };
}
function Q0e(e) {
    const t = JS.toJson(e), r = ld(t, !0);
    return Qpe(r).reverse().hex;
}
function ege(e) {
    const t = JS.toJson(e), r = ld(t, !0).length, n = ld(t, !1).length, i = r * 3 + n, o = i % 4 > 0 ? 1 : 0, s = Math.floor(i / 4) + o;
    return {
        size: n,
        bsize: r,
        vsize: s,
        weight: i
    };
}
const lu = {
    create: VS,
    encode: ld,
    decode: XS,
    fmt: JS,
    util: {
        getTxSize: ege,
        getTxid: Q0e,
        readScriptPubKey: J0e,
        readWitness: X0e
    }
}, tge = [
    [
        "1",
        "p2pkh",
        "main",
        20,
        "base58"
    ],
    [
        "3",
        "p2sh",
        "main",
        20,
        "base58"
    ],
    [
        "m",
        "p2pkh",
        "testnet",
        20,
        "base58"
    ],
    [
        "n",
        "p2pkh",
        "testnet",
        20,
        "base58"
    ],
    [
        "2",
        "p2sh",
        "testnet",
        20,
        "base58"
    ],
    [
        "bc1q",
        "p2w-pkh",
        "main",
        20,
        "bech32"
    ],
    [
        "tb1q",
        "p2w-pkh",
        "testnet",
        20,
        "bech32"
    ],
    [
        "bcrt1q",
        "p2w-pkh",
        "regtest",
        20,
        "bech32"
    ],
    [
        "bc1q",
        "p2w-sh",
        "main",
        32,
        "bech32"
    ],
    [
        "tb1q",
        "p2w-sh",
        "testnet",
        32,
        "bech32"
    ],
    [
        "bcrt1q",
        "p2w-sh",
        "regtest",
        32,
        "bech32"
    ],
    [
        "bc1p",
        "p2tr",
        "main",
        32,
        "bech32m"
    ],
    [
        "tb1p",
        "p2tr",
        "testnet",
        32,
        "bech32m"
    ],
    [
        "bcrt1p",
        "p2tr",
        "regtest",
        32,
        "bech32m"
    ]
];
function rge(e, t) {
    switch(t){
        case "base58":
            return Ze.b58chk(e).slice(1);
        case "bech32":
            return Ze.bech32(e);
        case "bech32m":
            return Ze.bech32(e);
        default:
            throw new Error("Invalid address format: " + t);
    }
}
function nge(e) {
    for (const t of tge){
        const [r, n, i, o, s] = t;
        if (e.startsWith(r) && rge(e, s).length === o) return t;
    }
    throw new Error("Invalid address: " + e);
}
function xC(e) {
    switch(e){
        case "p2pkh":
            return sC;
        case "p2sh":
            return uC;
        case "p2w-pkh":
            return dC;
        case "p2w-sh":
            return gC;
        case "p2tr":
            return bC;
        default:
            throw new Error("Invalid address type: " + e);
    }
}
function SC(e) {
    const [t, r, n] = nge(e), i = xC(r), o = i.decode(e, n), s = i.scriptPubKey(o);
    return {
        prefix: t,
        type: r,
        network: n,
        data: o,
        script: s
    };
}
function ige(e, t) {
    const { type: r, data: n } = lu.util.readScriptPubKey(e);
    return xC(r).encode(n, t);
}
function oge(e) {
    const { script: t } = SC(e);
    return Ba.fmt.toAsm(t, !1);
}
const AC = {
    p2pkh: sC,
    p2sh: uC,
    p2wpkh: dC,
    p2wsh: gC,
    p2tr: bC,
    decode: SC,
    fromScriptPubKey: ige,
    toScriptPubKey: oge
}, sge = [
    0,
    1,
    2,
    3,
    129,
    130,
    131
];
function QS(e, t, r = {}) {
    const { extension: n, sigflag: i = 0, extflag: o = 0, key_version: s = 0, separator_pos: a = 4294967295 } = r, u = lu.fmt.toJson(e), { version: f, vin: c, vout: l, locktime: p } = u;
    if (t >= c.length) throw new Error("Index out of bounds: " + String(t));
    if (!sge.includes(i)) throw new Error("Invalid hash type: " + String(i));
    if (o < 0 || o > 127) throw new Error("Extention flag out of range: " + String(o));
    const { txid: y, vout: _, sequence: A, witness: O = [] } = c[t], N = (i & 128) === 128, U = hge(O), D = U !== void 0 ? 1 : 0, K = (o + (n !== void 0 ? 1 : 0)) * 2 + D, re = Ze.str("TapSighash").digest, Q = [
        re,
        re,
        Ze.num(0, 1),
        Ze.num(i, 1),
        wC(f),
        vC(p)
    ];
    if (!N) {
        const G = c.map((R)=>oB(R));
        Q.push(age(c), uge(G), fge(G), cge(c));
    }
    if (((i & 3) < 2 || (i & 3) > 3) && Q.push(lge(l)), Q.push(Ze.num(K, 1)), N) {
        const { value: G, scriptPubKey: R } = oB(c[t]);
        Q.push(GS(y), ZS(_), A0(G), Ba.encode(R, !0), YS(A));
    } else Q.push(Ze.num(t, 4).reverse());
    return U !== void 0 && Q.push(U), (i & 3) === 3 && Q.push(dge(l[t])), n !== void 0 && Q.push(Ze.bytes(n), Ze.num(s), Ze.num(a, 4, "le")), Ze.join(Q).digest;
}
function age(e) {
    const t = [];
    for (const { txid: r, vout: n } of e)t.push(GS(r)), t.push(ZS(n));
    return Ze.join(t).digest;
}
function cge(e) {
    const t = [];
    for (const { sequence: r } of e)t.push(YS(r));
    return Ze.join(t).digest;
}
function uge(e) {
    const t = [];
    for (const { value: r } of e)t.push(A0(r));
    return Ze.join(t).digest;
}
function fge(e) {
    const t = [];
    for (const { scriptPubKey: r } of e)t.push(Hf(r, !0));
    return Ze.join(t).digest;
}
function lge(e) {
    const t = [];
    for (const { value: r, scriptPubKey: n } of e)t.push(A0(r)), t.push(Ba.encode(n, !0));
    return Ze.join(t).digest;
}
function dge(e) {
    return Ze.join([
        A0(e.value),
        Ba.encode(e.scriptPubKey, !0)
    ]).digest;
}
function hge(e) {
    if (e === void 0 || e.length < 2) return;
    let t = e.at(-1);
    if (typeof t == "string" && (t = Ze.hex(t)), t instanceof Uint8Array && t[0] === 80) return Ze.raw(t).prefixSize("be").digest;
}
function oB(e) {
    if (e.prevout === void 0) throw new Error("Prevout data missing for input: " + String(e.txid));
    return e.prevout;
}
const pge = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, gge = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function yge(e, t, r, n = {}) {
    const { sigflag: i = 0 } = n, o = QS(t, r, n), s = mge(e, o);
    return i === 0 ? Ze.raw(s) : Ze.join([
        s,
        i
    ]);
}
function mge(e, t, r = Ze.random(32)) {
    const n = Ze.bytes(t), i = new yi(e), o = i.point, s = o.hasEvenY ? i.big : i.negated.big, a = $y("BIP0340/aux", Ze.bytes(r)), u = s ^ a.big, f = $y("BIP0340/nonce", u, o.x.raw, n), c = new yi(f), l = c.point, p = l.hasEvenY ? c.big : c.negated.big, y = new yi($y("BIP0340/challenge", l.x.raw, o.x.raw, n)), _ = new yi(p + y.big * s);
    return Ze.join([
        l.x.raw,
        _.raw
    ]);
}
function bge(e, t, r, n = !1) {
    const i = fc.from_x(Af(r)), o = Ze.bytes(t), s = Ze.bytes(e).stream;
    s.size < 64 && Oo("Signature length is too small: " + String(s.size), n);
    const a = s.read(32);
    a.big > pge && Oo("Signature r value greater than field size!", n);
    const u = s.read(32);
    u.big > gge && Oo("Signature s value greater than curve order!", n);
    const f = new yi($y("BIP0340/challenge", a.raw, i.x.raw, o)), c = new yi(u).point, l = i.mul(f.big), p = c.sub(l);
    return p.hasOddY && Oo("Signature R value has odd Y coordinate!", n), p.x.big === 0n && Oo("Signature R value is infinite!", n), p.x.big === a.big;
}
const wge = 192;
function b1(e) {
    const t = Ze.str(e).digest;
    return Ze.join([
        t,
        t
    ]);
}
function e8(e, t = wge) {
    return Ze.join([
        b1("TapLeaf"),
        Ege(t),
        Ze.bytes(e)
    ]).digest.hex;
}
function vge(e, t) {
    return e8(Ba.fmt.toBytes(e), t);
}
function t8(e, t) {
    return t < e && ([e, t] = [
        t,
        e
    ]), Ze.join([
        b1("TapBranch"),
        Ze.hex(e).raw,
        Ze.hex(t).raw
    ]).digest.hex;
}
function _ge(e) {
    return Ze.hex($m(e)[0]);
}
function $m(e, t, r = []) {
    const n = [], i = [];
    if (e.length < 1) throw new Error("Tree is empty!");
    for(let o = 0; o < e.length; o++){
        const s = e[o];
        if (Array.isArray(s)) {
            const [a, u, f] = $m(s, t);
            t = u, n.push(a);
            for (const c of f)r.push(c);
        } else n.push(s);
    }
    if (n.length === 1) return [
        n[0],
        t,
        r
    ];
    n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
    for(let o = 0; o < n.length - 1; o += 2){
        const s = t8(n[o], n[o + 1]);
        i.push(s), typeof t == "string" && (t === n[o] ? (r.push(n[o + 1]), t = s) : t === n[o + 1] && (r.push(n[o]), t = s));
    }
    return $m(i, t, r);
}
function Ege(e = 192) {
    return e & 254;
}
function TC(e, t = new Uint8Array(), r = !1) {
    const n = r ? new yi(e).point.x.raw : Af(e);
    return Ze.join([
        b1("TapTweak"),
        n,
        Ze.bytes(t)
    ]).digest;
}
function Yl(e, t, r = !1) {
    t === void 0 && (t = new Uint8Array());
    const n = Ze.bytes(e), i = TC(e, t, r);
    return r ? kC(n, i) : IC(n, i);
}
function xge(e, t) {
    return Yl(e, t);
}
function Sge(e, t) {
    return Yl(e, t, !0);
}
function kC(e, t) {
    let r = new yi(e);
    return r.point.hasOddY && (r = r.negate()), Ze.raw(r.add(t).raw);
}
function IC(e, t) {
    e = Af(e);
    const n = fc.from_x(e).add(t);
    return Ze.raw(n.raw);
}
function Age() {
    const e = Ze.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
    return fc.from_x(e.digest).x;
}
const Tge = Age(), kge = 192;
function Ige(e, t = {}) {
    return BC(e, {
        ...t,
        isPrivate: !0
    });
}
function Bge(e, t = {}) {
    return BC(e, {
        ...t,
        isPrivate: !1
    });
}
function BC(e, t = {}) {
    const { isPrivate: r = !1, tree: n = [], version: i = kge } = t, o = r ? Mx.getPublicKey(e, !0) : Af(e);
    let { target: s } = t;
    s !== void 0 && (s = Ze.bytes(s).hex);
    let a, u = [];
    if (n.length > 0) {
        const [y, _, A] = $m(n, s);
        u = A, a = Yl(e, y, r);
    } else s !== void 0 ? a = Yl(e, s, r) : a = Yl(e, void 0, r);
    const f = r ? Mx.getPublicKey(a)[0] : a[0], l = [
        Ze.num(i + PC(f)),
        o
    ];
    u.length > 0 && u.forEach((y)=>l.push(Ze.hex(y)));
    const p = Ze.join(l);
    if (s !== void 0 && !r8(a, s, p, t)) throw new Error("Path checking failed! Unable to generate path.");
    return [
        Af(a).hex,
        p.hex
    ];
}
function r8(e, t, r, n = {}) {
    const { isPrivate: i = !1, throws: o = !1 } = n, { parity: s, paths: a, intkey: u } = OC(r), f = i ? Mx.getPublicKey(e, !0) : Af(e), c = Ze.join([
        s,
        f
    ]);
    if (c.length !== 33) return Oo("Invalid tapkey: " + c.hex, o);
    let l = Ze.bytes(t).hex;
    for (const y of a)l = t8(l, y);
    const p = Yl(u, l);
    return Ze.raw(p).hex === Ze.raw(c).hex;
}
function OC(e) {
    const t = new Hd(Ze.bytes(e)), r = t.read(1).num, n = t.read(32), [i, o] = r % 2 === 0 ? [
        r,
        2
    ] : [
        r - 1,
        3
    ], s = [];
    for(; t.size >= 32;)s.push(t.read(32).hex);
    if (t.size !== 0) throw new Error("Non-empty buffer on control block: " + String(t));
    return {
        intkey: n,
        paths: s,
        parity: o,
        version: i
    };
}
function PC(e = 2) {
    if (e === 0 || e === 1) return e;
    if (e === 2 || e === "02") return 0;
    if (e === 3 || e === "03") return 1;
    throw new Error("Invalid parity bit: " + String(e));
}
function Oge(e, t, r = {}) {
    const n = lu.fmt.toJson(e), { throws: i = !1 } = r, { prevout: o, witness: s = [] } = n.vin[t], a = lu.util.readWitness(s), { cblock: u, script: f, params: c } = a;
    let l;
    if (c.length < 1) return Oo("Invalid witness data: " + String(s), i);
    const { scriptPubKey: p } = o ?? {};
    if (p === void 0) return Oo("Prevout scriptPubKey is empty!", i);
    const { type: y, data: _ } = lu.util.readScriptPubKey(p);
    if (y !== "p2tr") return Oo("Prevout script is not a valid taproot output:" + _.hex, i);
    if (_.length !== 32) return Oo("Invalid tapkey length: " + String(_.length), i);
    if (u !== null && f !== null) {
        const D = u[0] & 254, H = e8(f, D);
        if (r.extension = H, !r8(_, H, u, {
            throws: i
        })) return Oo("cblock verification failed!", i);
    }
    r.pubkey !== void 0 ? l = Ze.bytes(r.pubkey) : c.length > 1 && c[1].length === 32 ? l = Ze.bytes(c[1]) : l = Ze.bytes(_);
    const A = Ba.fmt.toParam(c[0]), O = new Hd(A), N = O.read(64).raw;
    if (O.size === 1 && (r.sigflag = O.read(1).num, r.sigflag === 0)) return Oo("0x00 is not a valid appended sigflag!", i);
    const U = QS(n, t, r);
    return bge(N, U, l, i) ? !0 : Oo("Invalid signature!", i);
}
const Pge = {
    hash: QS,
    sign: yge,
    verify: Oge
}, Nge = {
    taproot: Pge
}, Mge = {
    getTag: b1,
    getLeaf: e8,
    getBranch: t8,
    getRoot: _ge
}, Rge = {
    readCtrlBlock: OC,
    readParityBit: PC
}, Cge = {
    getPubKey: xge,
    getSecKey: Sge,
    getTweak: TC,
    tweakSecKey: kC,
    tweakPubKey: IC
}, Lm = {
    getPubKey: Bge,
    getSecKey: Ige,
    encodeScript: vge,
    checkPath: r8,
    tree: Mge,
    tweak: Cge,
    util: Rge,
    SCRIPT_PUBKEY: Tge
};
var qr;
(function(e) {
    e.assertEqual = (i)=>i;
    function t(i) {}
    e.assertIs = t;
    function r(i) {
        throw new Error();
    }
    e.assertNever = r, e.arrayToEnum = (i)=>{
        const o = {};
        for (const s of i)o[s] = s;
        return o;
    }, e.getValidEnumValues = (i)=>{
        const o = e.objectKeys(i).filter((a)=>typeof i[i[a]] != "number"), s = {};
        for (const a of o)s[a] = i[a];
        return e.objectValues(s);
    }, e.objectValues = (i)=>e.objectKeys(i).map(function(o) {
            return i[o];
        }), e.objectKeys = typeof Object.keys == "function" ? (i)=>Object.keys(i) : (i)=>{
        const o = [];
        for(const s in i)Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
        return o;
    }, e.find = (i, o)=>{
        for (const s of i)if (o(s)) return s;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i)=>Number.isInteger(i) : (i)=>typeof i == "number" && isFinite(i) && Math.floor(i) === i;
    function n(i, o = " | ") {
        return i.map((s)=>typeof s == "string" ? `'${s}'` : s).join(o);
    }
    e.joinValues = n, e.jsonStringifyReplacer = (i, o)=>typeof o == "bigint" ? o.toString() : o;
})(qr || (qr = {}));
var Rx;
(function(e) {
    e.mergeShapes = (t, r)=>({
            ...t,
            ...r
        });
})(Rx || (Rx = {}));
const Bt = qr.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), au = (e)=>{
    switch(typeof e){
        case "undefined":
            return Bt.undefined;
        case "string":
            return Bt.string;
        case "number":
            return isNaN(e) ? Bt.nan : Bt.number;
        case "boolean":
            return Bt.boolean;
        case "function":
            return Bt.function;
        case "bigint":
            return Bt.bigint;
        case "symbol":
            return Bt.symbol;
        case "object":
            return Array.isArray(e) ? Bt.array : e === null ? Bt.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Bt.promise : typeof Map < "u" && e instanceof Map ? Bt.map : typeof Set < "u" && e instanceof Set ? Bt.set : typeof Date < "u" && e instanceof Date ? Bt.date : Bt.object;
        default:
            return Bt.unknown;
    }
}, gt = qr.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]), Uge = (e)=>JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let Us = class extends Error {
    constructor(t){
        super(), this.issues = [], this.addIssue = (n)=>{
            this.issues = [
                ...this.issues,
                n
            ];
        }, this.addIssues = (n = [])=>{
            this.issues = [
                ...this.issues,
                ...n
            ];
        };
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    get errors() {
        return this.issues;
    }
    format(t) {
        const r = t || function(o) {
            return o.message;
        }, n = {
            _errors: []
        }, i = (o)=>{
            for (const s of o.issues)if (s.code === "invalid_union") s.unionErrors.map(i);
            else if (s.code === "invalid_return_type") i(s.returnTypeError);
            else if (s.code === "invalid_arguments") i(s.argumentsError);
            else if (s.path.length === 0) n._errors.push(r(s));
            else {
                let a = n, u = 0;
                for(; u < s.path.length;){
                    const f = s.path[u];
                    u === s.path.length - 1 ? (a[f] = a[f] || {
                        _errors: []
                    }, a[f]._errors.push(r(s))) : a[f] = a[f] || {
                        _errors: []
                    }, a = a[f], u++;
                }
            }
        };
        return i(this), n;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, qr.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(t = (r)=>r.message) {
        const r = {}, n = [];
        for (const i of this.issues)i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
        return {
            formErrors: n,
            fieldErrors: r
        };
    }
    get formErrors() {
        return this.flatten();
    }
};
Us.create = (e)=>new Us(e);
const wp = (e, t)=>{
    let r;
    switch(e.code){
        case gt.invalid_type:
            e.received === Bt.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
            break;
        case gt.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(e.expected, qr.jsonStringifyReplacer)}`;
            break;
        case gt.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${qr.joinValues(e.keys, ", ")}`;
            break;
        case gt.invalid_union:
            r = "Invalid input";
            break;
        case gt.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${qr.joinValues(e.options)}`;
            break;
        case gt.invalid_enum_value:
            r = `Invalid enum value. Expected ${qr.joinValues(e.options)}, received '${e.received}'`;
            break;
        case gt.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case gt.invalid_return_type:
            r = "Invalid function return type";
            break;
        case gt.invalid_date:
            r = "Invalid date";
            break;
        case gt.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : qr.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
            break;
        case gt.too_small:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
            break;
        case gt.too_big:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
            break;
        case gt.custom:
            r = "Invalid input";
            break;
        case gt.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case gt.not_multiple_of:
            r = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case gt.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = t.defaultError, qr.assertNever(e);
    }
    return {
        message: r
    };
};
let NC = wp;
function $ge(e) {
    NC = e;
}
function Dm() {
    return NC;
}
const Fm = (e)=>{
    const { data: t, path: r, errorMaps: n, issueData: i } = e, o = [
        ...r,
        ...i.path || []
    ], s = {
        ...i,
        path: o
    };
    let a = "";
    const u = n.filter((f)=>!!f).slice().reverse();
    for (const f of u)a = f(s, {
        data: t,
        defaultError: a
    }).message;
    return {
        ...i,
        path: o,
        message: i.message || a
    };
}, Lge = [];
function Nt(e, t) {
    const r = Fm({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            Dm(),
            wp
        ].filter((n)=>!!n)
    });
    e.common.issues.push(r);
}
let yo = class MC {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
        const n = [];
        for (const i of r){
            if (i.status === "aborted") return cr;
            i.status === "dirty" && t.dirty(), n.push(i.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const i of r)n.push({
            key: await i.key,
            value: await i.value
        });
        return MC.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const i of r){
            const { key: o, value: s } = i;
            if (o.status === "aborted" || s.status === "aborted") return cr;
            o.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), (typeof s.value < "u" || i.alwaysSet) && (n[o.value] = s.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
};
const cr = Object.freeze({
    status: "aborted"
}), RC = (e)=>({
        status: "dirty",
        value: e
    }), Ki = (e)=>({
        status: "valid",
        value: e
    }), Cx = (e)=>e.status === "aborted", Ux = (e)=>e.status === "dirty", zm = (e)=>e.status === "valid", jm = (e)=>typeof Promise < "u" && e instanceof Promise;
var qt;
(function(e) {
    e.errToObj = (t)=>typeof t == "string" ? {
            message: t
        } : t || {}, e.toString = (t)=>typeof t == "string" ? t : t == null ? void 0 : t.message;
})(qt || (qt = {}));
let va = class {
    constructor(t, r, n, i){
        this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
};
const sB = (e, t)=>{
    if (zm(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const r = new Us(e.common.issues);
            return this._error = r, this._error;
        }
    };
};
function br(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
    if (t && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i
    } : {
        errorMap: (s, a)=>s.code !== "invalid_type" ? {
                message: a.defaultError
            } : typeof a.data > "u" ? {
                message: n ?? a.defaultError
            } : {
                message: r ?? a.defaultError
            },
        description: i
    };
}
let Ir = class {
    constructor(t){
        this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(t) {
        return au(t.data);
    }
    _getOrReturnCtx(t, r) {
        return r || {
            common: t.parent.common,
            data: t.data,
            parsedType: au(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        };
    }
    _processInputParams(t) {
        return {
            status: new yo(),
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: au(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        };
    }
    _parseSync(t) {
        const r = this._parse(t);
        if (jm(r)) throw new Error("Synchronous parse encountered promise.");
        return r;
    }
    _parseAsync(t) {
        const r = this._parse(t);
        return Promise.resolve(r);
    }
    parse(t, r) {
        const n = this.safeParse(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    safeParse(t, r) {
        var n;
        const i = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: au(t)
        }, o = this._parseSync({
            data: t,
            path: i.path,
            parent: i
        });
        return sB(i, o);
    }
    async parseAsync(t, r) {
        const n = await this.safeParseAsync(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    async safeParseAsync(t, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: au(t)
        }, i = this._parse({
            data: t,
            path: n.path,
            parent: n
        }), o = await (jm(i) ? i : Promise.resolve(i));
        return sB(n, o);
    }
    refine(t, r) {
        const n = (i)=>typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(i) : r;
        return this._refinement((i, o)=>{
            const s = t(i), a = ()=>o.addIssue({
                    code: gt.custom,
                    ...n(i)
                });
            return typeof Promise < "u" && s instanceof Promise ? s.then((u)=>u ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
        });
    }
    refinement(t, r) {
        return this._refinement((n, i)=>t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
    }
    _refinement(t) {
        return new Ds({
            schema: this,
            typeName: tr.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        });
    }
    superRefine(t) {
        return this._refinement(t);
    }
    optional() {
        return oc.create(this, this._def);
    }
    nullable() {
        return kf.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return Tf.create(this, this._def);
    }
    promise() {
        return pd.create(this, this._def);
    }
    or(t) {
        return Tp.create([
            this,
            t
        ], this._def);
    }
    and(t) {
        return kp.create(this, t, this._def);
    }
    transform(t) {
        return new Ds({
            ...br(this._def),
            schema: this,
            typeName: tr.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        });
    }
    default(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Pp({
            ...br(this._def),
            innerType: this,
            defaultValue: r,
            typeName: tr.ZodDefault
        });
    }
    brand() {
        return new jC({
            typeName: tr.ZodBranded,
            type: this,
            ...br(this._def)
        });
    }
    catch(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Vm({
            ...br(this._def),
            innerType: this,
            catchValue: r,
            typeName: tr.ZodCatch
        });
    }
    describe(t) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: t
        });
    }
    pipe(t) {
        return n8.create(this, t);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
};
const Dge = /^c[^\s-]{8,}$/i, Fge = /^[a-z][a-z0-9]*$/, zge = /[0-9A-HJKMNP-TV-Z]{26}/, jge = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Hge = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, qge = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), Kge = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Wge = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Vge = (e)=>e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Gge(e, t) {
    return !!((t === "v4" || !t) && Kge.test(e) || (t === "v6" || !t) && Wge.test(e));
}
let dd = class Ih extends Ir {
    constructor(){
        super(...arguments), this._regex = (t, r, n)=>this.refinement((i)=>t.test(i), {
                validation: r,
                code: gt.invalid_string,
                ...qt.errToObj(n)
            }), this.nonempty = (t)=>this.min(1, qt.errToObj(t)), this.trim = ()=>new Ih({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "trim"
                    }
                ]
            }), this.toLowerCase = ()=>new Ih({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toLowerCase"
                    }
                ]
            }), this.toUpperCase = ()=>new Ih({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toUpperCase"
                    }
                ]
            });
    }
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Bt.string) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.string,
                received: o.parsedType
            }), cr;
        }
        const n = new yo();
        let i;
        for (const o of this._def.checks)if (o.kind === "min") t.data.length < o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "max") t.data.length > o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "length") {
            const s = t.data.length > o.value, a = t.data.length < o.value;
            (s || a) && (i = this._getOrReturnCtx(t, i), s ? Nt(i, {
                code: gt.too_big,
                maximum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }) : a && Nt(i, {
                code: gt.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }), n.dirty());
        } else if (o.kind === "email") Hge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "email",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "emoji") qge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "emoji",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "uuid") jge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "uuid",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid") Dge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "cuid",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid2") Fge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "cuid2",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "ulid") zge.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "ulid",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "url") try {
            new URL(t.data);
        } catch  {
            i = this._getOrReturnCtx(t, i), Nt(i, {
                validation: "url",
                code: gt.invalid_string,
                message: o.message
            }), n.dirty();
        }
        else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "regex",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: {
                includes: o.value,
                position: o.position
            },
            message: o.message
        }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: {
                startsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: {
                endsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "datetime" ? Vge(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.invalid_string,
            validation: "datetime",
            message: o.message
        }), n.dirty()) : o.kind === "ip" ? Gge(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Nt(i, {
            validation: "ip",
            code: gt.invalid_string,
            message: o.message
        }), n.dirty()) : qr.assertNever(o);
        return {
            status: n.value,
            value: t.data
        };
    }
    _addCheck(t) {
        return new Ih({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...qt.errToObj(t)
        });
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...qt.errToObj(t)
        });
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...qt.errToObj(t)
        });
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...qt.errToObj(t)
        });
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...qt.errToObj(t)
        });
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...qt.errToObj(t)
        });
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...qt.errToObj(t)
        });
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...qt.errToObj(t)
        });
    }
    datetime(t) {
        var r;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            ...qt.errToObj(t == null ? void 0 : t.message)
        });
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...qt.errToObj(r)
        });
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...qt.errToObj(r == null ? void 0 : r.message)
        });
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...qt.errToObj(r)
        });
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...qt.errToObj(r)
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...qt.errToObj(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...qt.errToObj(r)
        });
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...qt.errToObj(r)
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((t)=>t.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((t)=>t.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((t)=>t.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((t)=>t.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((t)=>t.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((t)=>t.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((t)=>t.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((t)=>t.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((t)=>t.kind === "ip");
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
};
dd.create = (e)=>{
    var t;
    return new dd({
        checks: [],
        typeName: tr.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...br(e)
    });
};
function Zge(e, t) {
    const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, o = parseInt(e.toFixed(i).replace(".", "")), s = parseInt(t.toFixed(i).replace(".", ""));
    return o % s / Math.pow(10, i);
}
let vp = class $x extends Ir {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Bt.number) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.number,
                received: o.parsedType
            }), cr;
        }
        let n;
        const i = new yo();
        for (const o of this._def.checks)o.kind === "int" ? qr.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.invalid_type,
            expected: "integer",
            received: "float",
            message: o.message
        }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_small,
            minimum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_big,
            maximum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? Zge(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.not_finite,
            message: o.message
        }), i.dirty()) : qr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, qt.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, qt.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, qt.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, qt.toString(r));
    }
    setLimit(t, r, n, i) {
        return new $x({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: qt.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new $x({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: qt.toString(t)
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: qt.toString(r)
        });
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: qt.toString(t)
        });
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: qt.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: qt.toString(t)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
    get isInt() {
        return !!this._def.checks.find((t)=>t.kind === "int" || t.kind === "multipleOf" && qr.isInteger(t.value));
    }
    get isFinite() {
        let t = null, r = null;
        for (const n of this._def.checks){
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        }
        return Number.isFinite(r) && Number.isFinite(t);
    }
};
vp.create = (e)=>new vp({
        checks: [],
        typeName: tr.ZodNumber,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...br(e)
    });
let _p = class Lx extends Ir {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Bt.bigint) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.bigint,
                received: o.parsedType
            }), cr;
        }
        let n;
        const i = new yo();
        for (const o of this._def.checks)o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_small,
            type: "bigint",
            minimum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.too_big,
            type: "bigint",
            maximum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), Nt(n, {
            code: gt.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : qr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, qt.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, qt.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, qt.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, qt.toString(r));
    }
    setLimit(t, r, n, i) {
        return new Lx({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: qt.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new Lx({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: qt.toString(r)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
};
_p.create = (e)=>{
    var t;
    return new _p({
        checks: [],
        typeName: tr.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...br(e)
    });
};
let Ep = class extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Bt.boolean) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.boolean,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Ep.create = (e)=>new Ep({
        typeName: tr.ZodBoolean,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...br(e)
    });
let xp = class CC extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Bt.date) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_type,
                expected: Bt.date,
                received: o.parsedType
            }), cr;
        }
        if (isNaN(t.data.getTime())) {
            const o = this._getOrReturnCtx(t);
            return Nt(o, {
                code: gt.invalid_date
            }), cr;
        }
        const n = new yo();
        let i;
        for (const o of this._def.checks)o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_small,
            message: o.message,
            inclusive: !0,
            exact: !1,
            minimum: o.value,
            type: "date"
        }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), Nt(i, {
            code: gt.too_big,
            message: o.message,
            inclusive: !0,
            exact: !1,
            maximum: o.value,
            type: "date"
        }), n.dirty()) : qr.assertNever(o);
        return {
            status: n.value,
            value: new Date(t.data.getTime())
        };
    }
    _addCheck(t) {
        return new CC({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: qt.toString(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: qt.toString(r)
        });
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
};
xp.create = (e)=>new xp({
        checks: [],
        coerce: (e == null ? void 0 : e.coerce) || !1,
        typeName: tr.ZodDate,
        ...br(e)
    });
let Hm = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.symbol) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.symbol,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Hm.create = (e)=>new Hm({
        typeName: tr.ZodSymbol,
        ...br(e)
    });
let Sp = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.undefined) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.undefined,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Sp.create = (e)=>new Sp({
        typeName: tr.ZodUndefined,
        ...br(e)
    });
let Ap = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.null) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.null,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
Ap.create = (e)=>new Ap({
        typeName: tr.ZodNull,
        ...br(e)
    });
let hd = class extends Ir {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(t) {
        return Ki(t.data);
    }
};
hd.create = (e)=>new hd({
        typeName: tr.ZodAny,
        ...br(e)
    });
let mf = class extends Ir {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(t) {
        return Ki(t.data);
    }
};
mf.create = (e)=>new mf({
        typeName: tr.ZodUnknown,
        ...br(e)
    });
let lc = class extends Ir {
    _parse(t) {
        const r = this._getOrReturnCtx(t);
        return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.never,
            received: r.parsedType
        }), cr;
    }
};
lc.create = (e)=>new lc({
        typeName: tr.ZodNever,
        ...br(e)
    });
let qm = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.undefined) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.void,
                received: n.parsedType
            }), cr;
        }
        return Ki(t.data);
    }
};
qm.create = (e)=>new qm({
        typeName: tr.ZodVoid,
        ...br(e)
    });
let Tf = class Ly extends Ir {
    _parse(t) {
        const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
        if (r.parsedType !== Bt.array) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.array,
            received: r.parsedType
        }), cr;
        if (i.exactLength !== null) {
            const s = r.data.length > i.exactLength.value, a = r.data.length < i.exactLength.value;
            (s || a) && (Nt(r, {
                code: s ? gt.too_big : gt.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: s ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), n.dirty());
        }
        if (i.minLength !== null && r.data.length < i.minLength.value && (Nt(r, {
            code: gt.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Nt(r, {
            code: gt.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([
            ...r.data
        ].map((s, a)=>i.type._parseAsync(new va(r, s, r.path, a)))).then((s)=>yo.mergeArray(n, s));
        const o = [
            ...r.data
        ].map((s, a)=>i.type._parseSync(new va(r, s, r.path, a)));
        return yo.mergeArray(n, o);
    }
    get element() {
        return this._def.type;
    }
    min(t, r) {
        return new Ly({
            ...this._def,
            minLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    max(t, r) {
        return new Ly({
            ...this._def,
            maxLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    length(t, r) {
        return new Ly({
            ...this._def,
            exactLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    nonempty(t) {
        return this.min(1, t);
    }
};
Tf.create = (e, t)=>new Tf({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: tr.ZodArray,
        ...br(t)
    });
function Tl(e) {
    if (e instanceof ps) {
        const t = {};
        for(const r in e.shape){
            const n = e.shape[r];
            t[r] = oc.create(Tl(n));
        }
        return new ps({
            ...e._def,
            shape: ()=>t
        });
    } else return e instanceof Tf ? new Tf({
        ...e._def,
        type: Tl(e.element)
    }) : e instanceof oc ? oc.create(Tl(e.unwrap())) : e instanceof kf ? kf.create(Tl(e.unwrap())) : e instanceof vu ? vu.create(e.items.map((t)=>Tl(t))) : e;
}
let ps = class As extends Ir {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(), r = qr.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        };
    }
    _parse(t) {
        if (this._getType(t) !== Bt.object) {
            const f = this._getOrReturnCtx(t);
            return Nt(f, {
                code: gt.invalid_type,
                expected: Bt.object,
                received: f.parsedType
            }), cr;
        }
        const { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: s } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof lc && this._def.unknownKeys === "strip")) for(const f in i.data)s.includes(f) || a.push(f);
        const u = [];
        for (const f of s){
            const c = o[f], l = i.data[f];
            u.push({
                key: {
                    status: "valid",
                    value: f
                },
                value: c._parse(new va(i, l, i.path, f)),
                alwaysSet: f in i.data
            });
        }
        if (this._def.catchall instanceof lc) {
            const f = this._def.unknownKeys;
            if (f === "passthrough") for (const c of a)u.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: {
                    status: "valid",
                    value: i.data[c]
                }
            });
            else if (f === "strict") a.length > 0 && (Nt(i, {
                code: gt.unrecognized_keys,
                keys: a
            }), n.dirty());
            else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const f = this._def.catchall;
            for (const c of a){
                const l = i.data[c];
                u.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: f._parse(new va(i, l, i.path, c)),
                    alwaysSet: c in i.data
                });
            }
        }
        return i.common.async ? Promise.resolve().then(async ()=>{
            const f = [];
            for (const c of u){
                const l = await c.key;
                f.push({
                    key: l,
                    value: await c.value,
                    alwaysSet: c.alwaysSet
                });
            }
            return f;
        }).then((f)=>yo.mergeObjectSync(n, f)) : yo.mergeObjectSync(n, u);
    }
    get shape() {
        return this._def.shape();
    }
    strict(t) {
        return new As({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n)=>{
                    var i, o, s, a;
                    const u = (s = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (a = qt.errToObj(t).message) !== null && a !== void 0 ? a : u
                    } : {
                        message: u
                    };
                }
            } : {}
        });
    }
    strip() {
        return new As({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new As({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
        return new As({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(t) {
        return new As({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
            typeName: tr.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
        return this.augment({
            [t]: r
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
        return new As({
            ...this._def,
            catchall: t
        });
    }
    pick(t) {
        const r = {};
        return qr.objectKeys(t).forEach((n)=>{
            t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    omit(t) {
        const r = {};
        return qr.objectKeys(this.shape).forEach((n)=>{
            t[n] || (r[n] = this.shape[n]);
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return Tl(this);
    }
    partial(t) {
        const r = {};
        return qr.objectKeys(this.shape).forEach((n)=>{
            const i = this.shape[n];
            t && !t[n] ? r[n] = i : r[n] = i.optional();
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    required(t) {
        const r = {};
        return qr.objectKeys(this.shape).forEach((n)=>{
            if (t && !t[n]) r[n] = this.shape[n];
            else {
                let o = this.shape[n];
                for(; o instanceof oc;)o = o._def.innerType;
                r[n] = o;
            }
        }), new As({
            ...this._def,
            shape: ()=>r
        });
    }
    keyof() {
        return zC(qr.objectKeys(this.shape));
    }
};
ps.create = (e, t)=>new ps({
        shape: ()=>e,
        unknownKeys: "strip",
        catchall: lc.create(),
        typeName: tr.ZodObject,
        ...br(t)
    });
ps.strictCreate = (e, t)=>new ps({
        shape: ()=>e,
        unknownKeys: "strict",
        catchall: lc.create(),
        typeName: tr.ZodObject,
        ...br(t)
    });
ps.lazycreate = (e, t)=>new ps({
        shape: e,
        unknownKeys: "strip",
        catchall: lc.create(),
        typeName: tr.ZodObject,
        ...br(t)
    });
let Tp = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = this._def.options;
        function i(o) {
            for (const a of o)if (a.result.status === "valid") return a.result;
            for (const a of o)if (a.result.status === "dirty") return r.common.issues.push(...a.ctx.common.issues), a.result;
            const s = o.map((a)=>new Us(a.ctx.common.issues));
            return Nt(r, {
                code: gt.invalid_union,
                unionErrors: s
            }), cr;
        }
        if (r.common.async) return Promise.all(n.map(async (o)=>{
            const s = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await o._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: s
                }),
                ctx: s
            };
        })).then(i);
        {
            let o;
            const s = [];
            for (const u of n){
                const f = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }, c = u._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: f
                });
                if (c.status === "valid") return c;
                c.status === "dirty" && !o && (o = {
                    result: c,
                    ctx: f
                }), f.common.issues.length && s.push(f.common.issues);
            }
            if (o) return r.common.issues.push(...o.ctx.common.issues), o.result;
            const a = s.map((u)=>new Us(u));
            return Nt(r, {
                code: gt.invalid_union,
                unionErrors: a
            }), cr;
        }
    }
    get options() {
        return this._def.options;
    }
};
Tp.create = (e, t)=>new Tp({
        options: e,
        typeName: tr.ZodUnion,
        ...br(t)
    });
const Dy = (e)=>e instanceof Ip ? Dy(e.schema) : e instanceof Ds ? Dy(e.innerType()) : e instanceof Bp ? [
        e.value
    ] : e instanceof T0 ? e.options : e instanceof Op ? Object.keys(e.enum) : e instanceof Pp ? Dy(e._def.innerType) : e instanceof Sp ? [
        void 0
    ] : e instanceof Ap ? [
        null
    ] : null;
let UC = class $C extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.object) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.object,
            received: r.parsedType
        }), cr;
        const n = this.discriminator, i = r.data[n], o = this.optionsMap.get(i);
        return o ? r.common.async ? o._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : o._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (Nt(r, {
            code: gt.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                n
            ]
        }), cr);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(t, r, n) {
        const i = /* @__PURE__ */ new Map();
        for (const o of r){
            const s = Dy(o.shape[t]);
            if (!s) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const a of s){
                if (i.has(a)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
                i.set(a, o);
            }
        }
        return new $C({
            typeName: tr.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: i,
            ...br(n)
        });
    }
};
function Dx(e, t) {
    const r = au(e), n = au(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (r === Bt.object && n === Bt.object) {
        const i = qr.objectKeys(t), o = qr.objectKeys(e).filter((a)=>i.indexOf(a) !== -1), s = {
            ...e,
            ...t
        };
        for (const a of o){
            const u = Dx(e[a], t[a]);
            if (!u.valid) return {
                valid: !1
            };
            s[a] = u.data;
        }
        return {
            valid: !0,
            data: s
        };
    } else if (r === Bt.array && n === Bt.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i = [];
        for(let o = 0; o < e.length; o++){
            const s = e[o], a = t[o], u = Dx(s, a);
            if (!u.valid) return {
                valid: !1
            };
            i.push(u.data);
        }
        return {
            valid: !0,
            data: i
        };
    } else return r === Bt.date && n === Bt.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    };
}
let kp = class extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = (o, s)=>{
            if (Cx(o) || Cx(s)) return cr;
            const a = Dx(o.value, s.value);
            return a.valid ? ((Ux(o) || Ux(s)) && r.dirty(), {
                status: r.value,
                value: a.data
            }) : (Nt(n, {
                code: gt.invalid_intersection_types
            }), cr);
        };
        return n.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }),
            this._def.right._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            })
        ]).then(([o, s])=>i(o, s)) : i(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }));
    }
};
kp.create = (e, t, r)=>new kp({
        left: e,
        right: t,
        typeName: tr.ZodIntersection,
        ...br(r)
    });
let vu = class LC extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.array) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.array,
            received: n.parsedType
        }), cr;
        if (n.data.length < this._def.items.length) return Nt(n, {
            code: gt.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), cr;
        !this._def.rest && n.data.length > this._def.items.length && (Nt(n, {
            code: gt.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const o = [
            ...n.data
        ].map((s, a)=>{
            const u = this._def.items[a] || this._def.rest;
            return u ? u._parse(new va(n, s, n.path, a)) : null;
        }).filter((s)=>!!s);
        return n.common.async ? Promise.all(o).then((s)=>yo.mergeArray(r, s)) : yo.mergeArray(r, o);
    }
    get items() {
        return this._def.items;
    }
    rest(t) {
        return new LC({
            ...this._def,
            rest: t
        });
    }
};
vu.create = (e, t)=>{
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new vu({
        items: e,
        typeName: tr.ZodTuple,
        rest: null,
        ...br(t)
    });
};
let DC = class Fx extends Ir {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.object) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.object,
            received: n.parsedType
        }), cr;
        const i = [], o = this._def.keyType, s = this._def.valueType;
        for(const a in n.data)i.push({
            key: o._parse(new va(n, a, n.path, a)),
            value: s._parse(new va(n, n.data[a], n.path, a))
        });
        return n.common.async ? yo.mergeObjectAsync(r, i) : yo.mergeObjectSync(r, i);
    }
    get element() {
        return this._def.valueType;
    }
    static create(t, r, n) {
        return r instanceof Ir ? new Fx({
            keyType: t,
            valueType: r,
            typeName: tr.ZodRecord,
            ...br(n)
        }) : new Fx({
            keyType: dd.create(),
            valueType: t,
            typeName: tr.ZodRecord,
            ...br(r)
        });
    }
}, Km = class extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.map) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.map,
            received: n.parsedType
        }), cr;
        const i = this._def.keyType, o = this._def.valueType, s = [
            ...n.data.entries()
        ].map(([a, u], f)=>({
                key: i._parse(new va(n, a, n.path, [
                    f,
                    "key"
                ])),
                value: o._parse(new va(n, u, n.path, [
                    f,
                    "value"
                ]))
            }));
        if (n.common.async) {
            const a = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const u of s){
                    const f = await u.key, c = await u.value;
                    if (f.status === "aborted" || c.status === "aborted") return cr;
                    (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
                }
                return {
                    status: r.value,
                    value: a
                };
            });
        } else {
            const a = /* @__PURE__ */ new Map();
            for (const u of s){
                const f = u.key, c = u.value;
                if (f.status === "aborted" || c.status === "aborted") return cr;
                (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
            }
            return {
                status: r.value,
                value: a
            };
        }
    }
};
Km.create = (e, t, r)=>new Km({
        valueType: t,
        keyType: e,
        typeName: tr.ZodMap,
        ...br(r)
    });
let Wm = class zx extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.set) return Nt(n, {
            code: gt.invalid_type,
            expected: Bt.set,
            received: n.parsedType
        }), cr;
        const i = this._def;
        i.minSize !== null && n.data.size < i.minSize.value && (Nt(n, {
            code: gt.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Nt(n, {
            code: gt.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), r.dirty());
        const o = this._def.valueType;
        function s(u) {
            const f = /* @__PURE__ */ new Set();
            for (const c of u){
                if (c.status === "aborted") return cr;
                c.status === "dirty" && r.dirty(), f.add(c.value);
            }
            return {
                status: r.value,
                value: f
            };
        }
        const a = [
            ...n.data.values()
        ].map((u, f)=>o._parse(new va(n, u, n.path, f)));
        return n.common.async ? Promise.all(a).then((u)=>s(u)) : s(a);
    }
    min(t, r) {
        return new zx({
            ...this._def,
            minSize: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    max(t, r) {
        return new zx({
            ...this._def,
            maxSize: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    size(t, r) {
        return this.min(t, r).max(t, r);
    }
    nonempty(t) {
        return this.min(1, t);
    }
};
Wm.create = (e, t)=>new Wm({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: tr.ZodSet,
        ...br(t)
    });
let FC = class Fy extends Ir {
    constructor(){
        super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.function) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.function,
            received: r.parsedType
        }), cr;
        function n(a, u) {
            return Fm({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Dm(),
                    wp
                ].filter((f)=>!!f),
                issueData: {
                    code: gt.invalid_arguments,
                    argumentsError: u
                }
            });
        }
        function i(a, u) {
            return Fm({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Dm(),
                    wp
                ].filter((f)=>!!f),
                issueData: {
                    code: gt.invalid_return_type,
                    returnTypeError: u
                }
            });
        }
        const o = {
            errorMap: r.common.contextualErrorMap
        }, s = r.data;
        return this._def.returns instanceof pd ? Ki(async (...a)=>{
            const u = new Us([]), f = await this._def.args.parseAsync(a, o).catch((p)=>{
                throw u.addIssue(n(a, p)), u;
            }), c = await s(...f);
            return await this._def.returns._def.type.parseAsync(c, o).catch((p)=>{
                throw u.addIssue(i(c, p)), u;
            });
        }) : Ki((...a)=>{
            const u = this._def.args.safeParse(a, o);
            if (!u.success) throw new Us([
                n(a, u.error)
            ]);
            const f = s(...u.data), c = this._def.returns.safeParse(f, o);
            if (!c.success) throw new Us([
                i(f, c.error)
            ]);
            return c.data;
        });
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...t) {
        return new Fy({
            ...this._def,
            args: vu.create(t).rest(mf.create())
        });
    }
    returns(t) {
        return new Fy({
            ...this._def,
            returns: t
        });
    }
    implement(t) {
        return this.parse(t);
    }
    strictImplement(t) {
        return this.parse(t);
    }
    static create(t, r, n) {
        return new Fy({
            args: t || vu.create([]).rest(mf.create()),
            returns: r || mf.create(),
            typeName: tr.ZodFunction,
            ...br(n)
        });
    }
}, Ip = class extends Ir {
    get schema() {
        return this._def.getter();
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        });
    }
};
Ip.create = (e, t)=>new Ip({
        getter: e,
        typeName: tr.ZodLazy,
        ...br(t)
    });
let Bp = class extends Ir {
    _parse(t) {
        if (t.data !== this._def.value) {
            const r = this._getOrReturnCtx(t);
            return Nt(r, {
                received: r.data,
                code: gt.invalid_literal,
                expected: this._def.value
            }), cr;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
    get value() {
        return this._def.value;
    }
};
Bp.create = (e, t)=>new Bp({
        value: e,
        typeName: tr.ZodLiteral,
        ...br(t)
    });
function zC(e, t) {
    return new T0({
        values: e,
        typeName: tr.ZodEnum,
        ...br(t)
    });
}
let T0 = class jx extends Ir {
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Nt(r, {
                expected: qr.joinValues(n),
                received: r.parsedType,
                code: gt.invalid_type
            }), cr;
        }
        if (this._def.values.indexOf(t.data) === -1) {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Nt(r, {
                received: r.data,
                code: gt.invalid_enum_value,
                options: n
            }), cr;
        }
        return Ki(t.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    extract(t) {
        return jx.create(t);
    }
    exclude(t) {
        return jx.create(this.options.filter((r)=>!t.includes(r)));
    }
};
T0.create = zC;
let Op = class extends Ir {
    _parse(t) {
        const r = qr.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
        if (n.parsedType !== Bt.string && n.parsedType !== Bt.number) {
            const i = qr.objectValues(r);
            return Nt(n, {
                expected: qr.joinValues(i),
                received: n.parsedType,
                code: gt.invalid_type
            }), cr;
        }
        if (r.indexOf(t.data) === -1) {
            const i = qr.objectValues(r);
            return Nt(n, {
                received: n.data,
                code: gt.invalid_enum_value,
                options: i
            }), cr;
        }
        return Ki(t.data);
    }
    get enum() {
        return this._def.values;
    }
};
Op.create = (e, t)=>new Op({
        values: e,
        typeName: tr.ZodNativeEnum,
        ...br(t)
    });
let pd = class extends Ir {
    unwrap() {
        return this._def.type;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.promise && r.common.async === !1) return Nt(r, {
            code: gt.invalid_type,
            expected: Bt.promise,
            received: r.parsedType
        }), cr;
        const n = r.parsedType === Bt.promise ? r.data : Promise.resolve(r.data);
        return Ki(n.then((i)=>this._def.type.parseAsync(i, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })));
    }
};
pd.create = (e, t)=>new pd({
        type: e,
        typeName: tr.ZodPromise,
        ...br(t)
    });
let Ds = class extends Ir {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === tr.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null;
        if (i.type === "preprocess") {
            const s = i.transform(n.data);
            return n.common.async ? Promise.resolve(s).then((a)=>this._def.schema._parseAsync({
                    data: a,
                    path: n.path,
                    parent: n
                })) : this._def.schema._parseSync({
                data: s,
                path: n.path,
                parent: n
            });
        }
        const o = {
            addIssue: (s)=>{
                Nt(n, s), s.fatal ? r.abort() : r.dirty();
            },
            get path () {
                return n.path;
            }
        };
        if (o.addIssue = o.addIssue.bind(o), i.type === "refinement") {
            const s = (a)=>{
                const u = i.refinement(a, o);
                if (n.common.async) return Promise.resolve(u);
                if (u instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a;
            };
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? cr : (a.status === "dirty" && r.dirty(), s(a.value), {
                    status: r.value,
                    value: a.value
                });
            } else return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then((a)=>a.status === "aborted" ? cr : (a.status === "dirty" && r.dirty(), s(a.value).then(()=>({
                        status: r.value,
                        value: a.value
                    }))));
        }
        if (i.type === "transform") if (n.common.async === !1) {
            const s = this._def.schema._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            if (!zm(s)) return s;
            const a = i.transform(s.value, o);
            if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: r.value,
                value: a
            };
        } else return this._def.schema._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }).then((s)=>zm(s) ? Promise.resolve(i.transform(s.value, o)).then((a)=>({
                    status: r.value,
                    value: a
                })) : s);
        qr.assertNever(i);
    }
};
Ds.create = (e, t, r)=>new Ds({
        schema: e,
        typeName: tr.ZodEffects,
        effect: t,
        ...br(r)
    });
Ds.createWithPreprocess = (e, t, r)=>new Ds({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: tr.ZodEffects,
        ...br(r)
    });
let oc = class extends Ir {
    _parse(t) {
        return this._getType(t) === Bt.undefined ? Ki(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
};
oc.create = (e, t)=>new oc({
        innerType: e,
        typeName: tr.ZodOptional,
        ...br(t)
    });
let kf = class extends Ir {
    _parse(t) {
        return this._getType(t) === Bt.null ? Ki(null) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
};
kf.create = (e, t)=>new kf({
        innerType: e,
        typeName: tr.ZodNullable,
        ...br(t)
    });
let Pp = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        let n = r.data;
        return r.parsedType === Bt.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
};
Pp.create = (e, t)=>new Pp({
        innerType: e,
        typeName: tr.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : ()=>t.default,
        ...br(t)
    });
let Vm = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }, i = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return jm(i) ? i.then((o)=>({
                status: "valid",
                value: o.status === "valid" ? o.value : this._def.catchValue({
                    get error () {
                        return new Us(n.common.issues);
                    },
                    input: n.data
                })
            })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error () {
                    return new Us(n.common.issues);
                },
                input: n.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
};
Vm.create = (e, t)=>new Vm({
        innerType: e,
        typeName: tr.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : ()=>t.catch,
        ...br(t)
    });
let Gm = class extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.nan) {
            const n = this._getOrReturnCtx(t);
            return Nt(n, {
                code: gt.invalid_type,
                expected: Bt.nan,
                received: n.parsedType
            }), cr;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
};
Gm.create = (e)=>new Gm({
        typeName: tr.ZodNaN,
        ...br(e)
    });
const Yge = Symbol("zod_brand");
let jC = class extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    unwrap() {
        return this._def.type;
    }
}, n8 = class HC extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.common.async) return (async ()=>{
            const o = await this._def.in._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return o.status === "aborted" ? cr : o.status === "dirty" ? (r.dirty(), RC(o.value)) : this._def.out._parseAsync({
                data: o.value,
                path: n.path,
                parent: n
            });
        })();
        {
            const i = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i.status === "aborted" ? cr : i.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: n.path,
                parent: n
            });
        }
    }
    static create(t, r) {
        return new HC({
            in: t,
            out: r,
            typeName: tr.ZodPipeline
        });
    }
};
const qC = (e, t = {}, r)=>e ? hd.create().superRefine((n, i)=>{
        var o, s;
        if (!e(n)) {
            const a = typeof t == "function" ? t(n) : typeof t == "string" ? {
                message: t
            } : t, u = (s = (o = a.fatal) !== null && o !== void 0 ? o : r) !== null && s !== void 0 ? s : !0, f = typeof a == "string" ? {
                message: a
            } : a;
            i.addIssue({
                code: "custom",
                ...f,
                fatal: u
            });
        }
    }) : hd.create(), Xge = {
    object: ps.lazycreate
};
var tr;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(tr || (tr = {}));
const Jge = (e, t = {
    message: `Input not instance of ${e.name}`
})=>qC((r)=>r instanceof e, t), KC = dd.create, WC = vp.create, Qge = Gm.create, eye = _p.create, VC = Ep.create, tye = xp.create, rye = Hm.create, nye = Sp.create, iye = Ap.create, oye = hd.create, sye = mf.create, aye = lc.create, cye = qm.create, uye = Tf.create, fye = ps.create, lye = ps.strictCreate, dye = Tp.create, hye = UC.create, pye = kp.create, gye = vu.create, yye = DC.create, mye = Km.create, bye = Wm.create, wye = FC.create, vye = Ip.create, _ye = Bp.create, Eye = T0.create, xye = Op.create, Sye = pd.create, aB = Ds.create, Aye = oc.create, Tye = kf.create, kye = Ds.createWithPreprocess, Iye = n8.create, Bye = ()=>KC().optional(), Oye = ()=>WC().optional(), Pye = ()=>VC().optional(), Nye = {
    string: (e)=>dd.create({
            ...e,
            coerce: !0
        }),
    number: (e)=>vp.create({
            ...e,
            coerce: !0
        }),
    boolean: (e)=>Ep.create({
            ...e,
            coerce: !0
        }),
    bigint: (e)=>_p.create({
            ...e,
            coerce: !0
        }),
    date: (e)=>xp.create({
            ...e,
            coerce: !0
        })
}, Mye = cr;
var qi = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: wp,
    setErrorMap: $ge,
    getErrorMap: Dm,
    makeIssue: Fm,
    EMPTY_PATH: Lge,
    addIssueToContext: Nt,
    ParseStatus: yo,
    INVALID: cr,
    DIRTY: RC,
    OK: Ki,
    isAborted: Cx,
    isDirty: Ux,
    isValid: zm,
    isAsync: jm,
    get util () {
        return qr;
    },
    get objectUtil () {
        return Rx;
    },
    ZodParsedType: Bt,
    getParsedType: au,
    ZodType: Ir,
    ZodString: dd,
    ZodNumber: vp,
    ZodBigInt: _p,
    ZodBoolean: Ep,
    ZodDate: xp,
    ZodSymbol: Hm,
    ZodUndefined: Sp,
    ZodNull: Ap,
    ZodAny: hd,
    ZodUnknown: mf,
    ZodNever: lc,
    ZodVoid: qm,
    ZodArray: Tf,
    ZodObject: ps,
    ZodUnion: Tp,
    ZodDiscriminatedUnion: UC,
    ZodIntersection: kp,
    ZodTuple: vu,
    ZodRecord: DC,
    ZodMap: Km,
    ZodSet: Wm,
    ZodFunction: FC,
    ZodLazy: Ip,
    ZodLiteral: Bp,
    ZodEnum: T0,
    ZodNativeEnum: Op,
    ZodPromise: pd,
    ZodEffects: Ds,
    ZodTransformer: Ds,
    ZodOptional: oc,
    ZodNullable: kf,
    ZodDefault: Pp,
    ZodCatch: Vm,
    ZodNaN: Gm,
    BRAND: Yge,
    ZodBranded: jC,
    ZodPipeline: n8,
    custom: qC,
    Schema: Ir,
    ZodSchema: Ir,
    late: Xge,
    get ZodFirstPartyTypeKind () {
        return tr;
    },
    coerce: Nye,
    any: oye,
    array: uye,
    bigint: eye,
    boolean: VC,
    date: tye,
    discriminatedUnion: hye,
    effect: aB,
    enum: Eye,
    function: wye,
    instanceof: Jge,
    intersection: pye,
    lazy: vye,
    literal: _ye,
    map: mye,
    nan: Qge,
    nativeEnum: xye,
    never: aye,
    null: iye,
    nullable: Tye,
    number: WC,
    object: fye,
    oboolean: Pye,
    onumber: Oye,
    optional: Aye,
    ostring: Bye,
    pipeline: Iye,
    preprocess: kye,
    promise: Sye,
    record: yye,
    set: bye,
    strictObject: lye,
    string: KC,
    symbol: rye,
    transformer: aB,
    tuple: gye,
    undefined: nye,
    union: dye,
    unknown: sye,
    void: cye,
    NEVER: Mye,
    ZodIssueCode: gt,
    quotelessJson: Uge,
    ZodError: Us
});
const GC = qi.string().regex(/^[a-fA-F0-9]$/), Rye = qi.string().regex(/^[a-fA-F0-9]{64}$/), gd = qi.number().min(0).max(4294967295), Cye = qi.bigint(), ZC = qi.instanceof(Uint8Array), Uye = qi.union([
    GC,
    gd,
    qi.string(),
    ZC
]).array(), i8 = qi.union([
    Uye,
    GC,
    ZC
]), $ye = qi.array(i8), YC = qi.object({
    value: qi.union([
        gd,
        Cye
    ]),
    scriptPubKey: i8
}), Lye = qi.object({
    txid: Rye,
    vout: gd,
    scriptSig: i8,
    sequence: gd,
    prevout: YC.optional(),
    witness: $ye
});
qi.object({
    version: gd,
    vin: qi.array(Lye),
    vout: qi.array(YC),
    locktime: gd
});
o3(bb);
const XC = async ({ contentBase64: e, mimeType: t, quantity: r = 1, inscriptions: n, ordinalAddress: i, paymentAddress: o, paymentPublicKey: s, signPsbt: a, dataSourceManager: u, opReturn: f, network: c = ln })=>{
    if (!e && !n) throw new Error("contentBase64 or inscriptions is required");
    if (!u) throw new Error("missing data source");
    if (!u.broadcastTransaction) throw new Error("missing broadcastTransaction");
    const l = await Vre(c), p = We.from(l).toString("hex"), y = n || Array(r).fill({
        content: e,
        mimeType: t
    }), _ = await Dye({
        inscriptions: y,
        paymentAddress: o,
        paymentPublicKey: s,
        privKey: p,
        dataSourceManager: u,
        network: c
    });
    if (!_ || !(_ != null && _.psbtHex)) throw new Error("couldn't get commit tx");
    const A = String(_ == null ? void 0 : _.psbtHex), O = String(_ == null ? void 0 : _.psbtBase64), N = await a({
        tx: A,
        psbtHex: A,
        psbtBase64: O,
        finalize: !0,
        broadcast: !1,
        network: c
    });
    if (!N) throw new Error("sign psbt failed");
    const D = Cr.fromHex((N == null ? void 0 : N.signedPsbtHex) || "").extractTransaction(), H = await u.broadcastTransaction(D.toHex());
    if (!H) throw new Error("commit tx failed");
    return await Fye({
        inscriptions: y,
        ordinalAddress: i,
        privKey: p,
        commitTxId: H,
        dataSourceManager: u,
        opReturn: f
    });
}, Dye = async ({ inscriptions: e, paymentAddress: t, paymentPublicKey: r, privKey: n, dataSourceManager: i, network: o })=>{
    const s = e.length, a = e.reduce((Q, G)=>Q + We.from(G.content).length, 0);
    if (a > 39e4) throw new Error("Content size is too large, must be less than 390kb");
    if (!i) throw new Error("missing data source");
    if (!i.getRecommendedFees) throw new Error("missing getRecommendedFees");
    if (!i.getAddressUtxos) throw new Error("missing getAddressUtxos");
    const { fastFee: u } = await i.getRecommendedFees(), f = CM(String(n), !0), c = new Cr({
        network: Dr(o)
    }), { inscriberAddress: l } = zye(f, e, o), p = 5 * 34 * s, y = Math.floor(p * u * s), _ = Math.floor(a * u / 3) + 1e3 + 546 * s, A = Math.floor(y + _), N = (await i.getAddressUtxos(t)).filter((Q)=>Q.value > 3e3).sort((Q, G)=>G.value - Q.value), U = jb(N);
    if (U === 0) throw new Error("insufficient funds");
    if (U < A) throw new Error("insufficient funds");
    let D = 0;
    const H = hs(t, Dr(o));
    let K = 0;
    for await (const Q of N){
        const G = Jb(t, o);
        if (c.addInput({
            hash: Q.txid,
            index: Q.vout,
            witnessUtxo: {
                value: BigInt(Q.value),
                script: H
            }
        }), G === df && c.updateInput(K, {
            // biome-ignore lint/style/noNonNullAssertion: <explanation>
            tapInternalKey: Mo(We.from(r, "hex"))
        }), G === Xp) {
            const R = d0(r, o);
            c.updateInput(K, {
                redeemScript: R
            });
        }
        if (K++, D += Q.value, D > A) break;
    }
    const re = D - A;
    return c.addOutput({
        value: BigInt(_),
        address: l
    }), re > 546 && c.addOutput({
        value: BigInt(re),
        address: t
    }), {
        psbtHex: c.toHex(),
        psbtBase64: c.toBase64()
    };
}, Fye = async ({ inscriptions: e, ordinalAddress: t, commitTxId: r, privKey: n, dataSourceManager: i, opReturn: o, isDry: s })=>{
    const a = lfe(n), u = CM(n, !0), f = JC(u, e), c = Lm.encodeScript(f), [l, p] = Lm.getPubKey(u, {
        target: c
    });
    if (!i) throw new Error("missing data source");
    if (!i.waitForTransaction) throw new Error("missing waitForTransaction");
    if (!i.getOutputValueByVOutIndex) throw new Error("missing waitForTransaction");
    if (!i.broadcastTransaction) throw new Error("missing broadcastTransaction");
    if (!await i.waitForTransaction(String(r))) throw new Error("ERROR WAITING FOR COMMIT TX");
    const _ = await i.getOutputValueByVOutIndex(r, 0);
    if (_ === 0 || !_) throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const A = lu.create({
        vin: [
            {
                txid: r,
                vout: 0,
                prevout: {
                    value: _,
                    scriptPubKey: [
                        "OP_1",
                        l
                    ]
                }
            }
        ],
        vout: [
            ...Array(e.length).fill({
                value: 546,
                scriptPubKey: AC.toScriptPubKey(t)
            })
        ],
        ...o ? {
            vout: [
                {
                    value: 0,
                    scriptPubKey: [
                        "OP_RETURN",
                        o
                    ]
                }
            ]
        } : {}
    }), O = Nge.taproot.sign(a, A, 0, {
        extension: c
    });
    return A.vin[0].witness = [
        O,
        f,
        p
    ], s ? lu.util.getTxid(A) : await i.broadcastTransaction(lu.encode(A).hex);
}, JC = (e, t)=>{
    const r = new TextEncoder(), n = r.encode("ord"), i = 546, o = (a, u)=>{
        let f;
        if (u === Kre) {
            const l = We.from(a, "base64").toString("utf-8");
            f = We.from(l, "utf-8");
        } else f = We.from(a, "base64");
        const c = [];
        for(let l = 0; l < f.length; l += 520)c.push(f.slice(l, l + 520));
        return c;
    }, s = [
        e,
        "OP_CHECKSIG"
    ];
    return t.forEach((a, u)=>{
        const { content: f, mimeType: c } = a, l = o(f, c);
        if (s.push("OP_0", "OP_IF", n, "01", r.encode(c), "OP_0"), u > 0) {
            const p = i * (u + 1), y = We.from([
                p
            ]);
            s.push(We.from([
                2
            ])), s.push(y);
        }
        s.push(...l.map((p)=>p), "OP_ENDIF");
    }), s;
}, zye = (e, t, r = ln)=>{
    const n = JC(e, t), i = Lm.encodeScript(n), [o] = Lm.getPubKey(e, {
        target: i
    });
    return {
        inscriberAddress: AC.p2tr.fromPubKey(o, VQ(r)),
        tpubkey: o,
        tapleaf: i
    };
};
var jye = {}, k0 = {};
Object.defineProperty(k0, "__esModule", {
    value: !0
});
k0.isRunestone = void 0;
function Hye(e) {
    return !("flaws" in e);
}
k0.isRunestone = Hye;
var Kd = {};
Object.defineProperty(Kd, "__esModule", {
    value: !0
});
Kd.Flaw = void 0;
var cB;
(function(e) {
    e[e.EDICT_OUTPUT = 0] = "EDICT_OUTPUT", e[e.EDICT_RUNE_ID = 1] = "EDICT_RUNE_ID", e[e.INVALID_SCRIPT = 2] = "INVALID_SCRIPT", e[e.OPCODE = 3] = "OPCODE", e[e.SUPPLY_OVERFLOW = 4] = "SUPPLY_OVERFLOW", e[e.TRAILING_INTEGERS = 5] = "TRAILING_INTEGERS", e[e.TRUNCATED_FIELD = 6] = "TRUNCATED_FIELD", e[e.UNRECOGNIZED_EVEN_TAG = 7] = "UNRECOGNIZED_EVEN_TAG", e[e.UNRECOGNIZED_FLAG = 8] = "UNRECOGNIZED_FLAG", e[e.VARINT = 9] = "VARINT";
})(cB || (Kd.Flaw = cB = {}));
var Wd = {};
Object.defineProperty(Wd, "__esModule", {
    value: !0
});
Wd.RuneId = void 0;
const Yc = wi, sa = Qn;
class Xh {
    constructor(t, r){
        this.block = t, this.tx = r;
    }
    static new(t, r) {
        const n = new Xh(t, r);
        return n.block === 0n && n.tx > 0 ? Yc.None : (0, Yc.Some)(n);
    }
    static sort(t) {
        return [
            ...t
        ].sort((r, n)=>Number(r.block - n.block || r.tx - n.tx));
    }
    delta(t) {
        const r = sa.u64.checkedSub(t.block, this.block);
        if (r.isNone()) return Yc.None;
        const n = r.unwrap();
        let i;
        if (n === 0n) {
            const o = sa.u32.checkedSub(t.tx, this.tx);
            if (o.isNone()) return Yc.None;
            i = o.unwrap();
        } else i = t.tx;
        return (0, Yc.Some)([
            (0, sa.u128)(n),
            (0, sa.u128)(i)
        ]);
    }
    next(t, r) {
        const n = sa.u128.tryIntoU64(t), i = sa.u128.tryIntoU32(r);
        if (n.isNone() || i.isNone()) return Yc.None;
        const o = n.unwrap(), s = i.unwrap(), a = sa.u64.checkedAdd(this.block, o);
        if (a.isNone()) return Yc.None;
        let u;
        if (o === 0n) {
            const f = sa.u32.checkedAdd(this.tx, s);
            if (f.isNone()) return Yc.None;
            u = f.unwrap();
        } else u = s;
        return Xh.new(a.unwrap(), u);
    }
    toString() {
        return `${this.block}:${this.tx}`;
    }
    static fromString(t) {
        const r = t.split(":");
        if (r.length !== 2) throw new Error(`invalid rune ID: ${t}`);
        const [n, i] = r;
        if (!/^\d+$/.test(n) || !/^\d+$/.test(i)) throw new Error(`invalid rune ID: ${t}`);
        return new Xh((0, sa.u64)(BigInt(n)), (0, sa.u32)(BigInt(i)));
    }
}
Wd.RuneId = Xh;
var o8 = {}, w1 = {};
Object.defineProperty(w1, "__esModule", {
    value: !0
});
w1.Instruction = void 0;
var uB;
(function(e) {
    function t(n) {
        return typeof n == "number";
    }
    e.isNumber = t;
    function r(n) {
        return typeof n != "number";
    }
    e.isBuffer = r;
})(uB || (w1.Instruction = uB = {}));
var v1 = {}, _1 = {};
Object.defineProperty(_1, "__esModule", {
    value: !0
});
_1.Edict = void 0;
const my = wi, qye = Qn;
var fB;
(function(e) {
    function t(r, n, i, o) {
        if (n.block === 0n && n.tx > 0n) return my.None;
        const s = qye.u128.tryIntoU32(o);
        if (s.isNone()) return my.None;
        const a = s.unwrap();
        return a > r ? my.None : (0, my.Some)({
            id: n,
            amount: i,
            output: a
        });
    }
    e.fromIntegers = t;
})(fB || (_1.Edict = fB = {}));
Object.defineProperty(v1, "__esModule", {
    value: !0
});
v1.Message = void 0;
const Kye = _1, by = Kd, cE = Qn, Wye = Wd, Vye = Ff;
class s8 {
    constructor(t, r, n){
        this.flaws = t, this.edicts = r, this.fields = n;
    }
    static fromIntegers(t, r) {
        const n = [], i = /* @__PURE__ */ new Map(), o = [];
        for (const s of [
            ...Array(Math.ceil(r.length / 2)).keys()
        ].map((a)=>a * 2)){
            const a = r[s];
            if ((0, cE.u128)(Vye.Tag.BODY) === a) {
                let c = new Wye.RuneId((0, cE.u64)(0), (0, cE.u32)(0));
                const l = 4, p = r.slice(s + 1);
                for(let y = 0; y < p.length; y += l){
                    const _ = p.slice(y, y + l);
                    if (_.length !== l) {
                        o.push(by.Flaw.TRAILING_INTEGERS);
                        break;
                    }
                    const A = c.next(_[0], _[1]);
                    if (A.isNone()) {
                        o.push(by.Flaw.EDICT_RUNE_ID);
                        break;
                    }
                    const O = A.unwrap(), N = Kye.Edict.fromIntegers(t, O, _[2], _[3]);
                    if (N.isNone()) {
                        o.push(by.Flaw.EDICT_OUTPUT);
                        break;
                    }
                    const U = N.unwrap();
                    c = O, n.push(U);
                }
                break;
            }
            const u = r[s + 1];
            if (u === void 0) {
                o.push(by.Flaw.TRUNCATED_FIELD);
                break;
            }
            const f = i.get(a) ?? [];
            f.push(u), i.set(a, f);
        }
        return new s8(o, n, i);
    }
}
v1.Message = s8;
var E1 = {};
Object.defineProperty(E1, "__esModule", {
    value: !0
});
E1.Cenotaph = void 0;
const lB = wi;
class Gye {
    constructor(t, r = lB.None, n = lB.None){
        this.flaws = t, this.etching = r, this.mint = n;
    }
}
E1.Cenotaph = Gye;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Runestone = e.isValidPayload = e.MAX_SPACERS = void 0;
    const t = hn, r = Ud, n = b0, i = Ff, o = Qn, s = wi, a = Fd, u = Ld, f = w1, c = Wd, l = uc, p = v1, y = Kd, _ = E1;
    e.MAX_SPACERS = 134217727;
    function A(N) {
        return We.isBuffer(N);
    }
    e.isValidPayload = A;
    class O {
        constructor(U, D, H, K){
            this.mint = U, this.pointer = D, this.edicts = H, this.etching = K;
        }
        static decipher(U) {
            const D = O.payload(U);
            if (D.isNone()) return s.None;
            const H = D.unwrap();
            if (!A(H)) return (0, s.Some)(new _.Cenotaph([
                H
            ]));
            const K = O.integers(H);
            if (K.isNone()) return (0, s.Some)(new _.Cenotaph([
                y.Flaw.VARINT
            ]));
            const { flaws: re, edicts: Q, fields: G } = p.Message.fromIntegers(U.vout.length, K.unwrap());
            let R = i.Tag.take(i.Tag.FLAGS, G, 1, ([m])=>(0, s.Some)(m)).unwrapOr((0, o.u128)(0));
            const X = u.Flag.take(R, u.Flag.ETCHING), $ = X.set;
            R = X.flags;
            const S = $ ? (()=>{
                const m = i.Tag.take(i.Tag.DIVISIBILITY, G, 1, ([ce])=>o.u128.tryIntoU8(ce).andThen((he)=>he <= t.MAX_DIVISIBILITY ? (0, s.Some)(he) : s.None)), E = i.Tag.take(i.Tag.RUNE, G, 1, ([ce])=>(0, s.Some)(new a.Rune(ce))), T = i.Tag.take(i.Tag.SPACERS, G, 1, ([ce])=>o.u128.tryIntoU32(ce).andThen((he)=>he <= e.MAX_SPACERS ? (0, s.Some)(he) : s.None)), I = i.Tag.take(i.Tag.SYMBOL, G, 1, ([ce])=>o.u128.tryIntoU32(ce).andThen((he)=>{
                        try {
                            return (0, s.Some)(String.fromCodePoint(Number(he)));
                        } catch  {
                            return s.None;
                        }
                    })), P = u.Flag.take(R, u.Flag.TERMS), k = P.set;
                R = P.flags;
                const L = k ? (()=>{
                    const ce = i.Tag.take(i.Tag.AMOUNT, G, 1, ([ye])=>(0, s.Some)(ye)), he = i.Tag.take(i.Tag.CAP, G, 1, ([ye])=>(0, s.Some)(ye)), ee = [
                        i.Tag.take(i.Tag.OFFSET_START, G, 1, ([ye])=>o.u128.tryIntoU64(ye)),
                        i.Tag.take(i.Tag.OFFSET_END, G, 1, ([ye])=>o.u128.tryIntoU64(ye))
                    ], ae = [
                        i.Tag.take(i.Tag.HEIGHT_START, G, 1, ([ye])=>o.u128.tryIntoU64(ye)),
                        i.Tag.take(i.Tag.HEIGHT_END, G, 1, ([ye])=>o.u128.tryIntoU64(ye))
                    ];
                    return (0, s.Some)({
                        amount: ce,
                        cap: he,
                        offset: ee,
                        height: ae
                    });
                })() : s.None, j = i.Tag.take(i.Tag.PREMINE, G, 1, ([ce])=>(0, s.Some)(ce)), ie = u.Flag.take(R, u.Flag.TURBO), ue = X.set;
                return R = ie.flags, (0, s.Some)(new r.Etching(m, E, T, I, L, j, ue));
            })() : s.None, w = i.Tag.take(i.Tag.MINT, G, 2, ([m, E])=>{
                const T = o.u128.tryIntoU64(m), I = o.u128.tryIntoU32(E);
                return T.isNone() || I.isNone() ? s.None : c.RuneId.new(T.unwrap(), I.unwrap());
            }), g = i.Tag.take(i.Tag.POINTER, G, 1, ([m])=>o.u128.tryIntoU32(m).andThen((E)=>E < U.vout.length ? (0, s.Some)(E) : s.None));
            return S.map((m)=>m.supply.isNone()).unwrapOr(!1) && re.push(y.Flaw.SUPPLY_OVERFLOW), R !== 0n && re.push(y.Flaw.UNRECOGNIZED_FLAG), [
                ...G.keys()
            ].find((m)=>m % 2n === 0n) !== void 0 && re.push(y.Flaw.UNRECOGNIZED_EVEN_TAG), re.length !== 0 ? (0, s.Some)(new _.Cenotaph(re, S.andThen((m)=>m.rune), w)) : (0, s.Some)(new O(w, g, Q, S));
        }
        encipher() {
            const U = [];
            if (this.etching.isSome()) {
                const K = this.etching.unwrap();
                let re = (0, o.u128)(0);
                if (re = u.Flag.set(re, u.Flag.ETCHING), K.terms.isSome() && (re = u.Flag.set(re, u.Flag.TERMS)), K.turbo && (re = u.Flag.set(re, u.Flag.TURBO)), U.push(i.Tag.encode(i.Tag.FLAGS, [
                    re
                ])), U.push(i.Tag.encodeOptionInt(i.Tag.RUNE, K.rune.map((Q)=>Q.value))), U.push(i.Tag.encodeOptionInt(i.Tag.DIVISIBILITY, K.divisibility.map(o.u128))), U.push(i.Tag.encodeOptionInt(i.Tag.SPACERS, K.spacers.map(o.u128))), U.push(i.Tag.encodeOptionInt(i.Tag.SYMBOL, K.symbol.map((Q)=>(0, o.u128)(Q.codePointAt(0))))), U.push(i.Tag.encodeOptionInt(i.Tag.PREMINE, K.premine)), K.terms.isSome()) {
                    const Q = K.terms.unwrap();
                    U.push(i.Tag.encodeOptionInt(i.Tag.AMOUNT, Q.amount)), U.push(i.Tag.encodeOptionInt(i.Tag.CAP, Q.cap)), U.push(i.Tag.encodeOptionInt(i.Tag.HEIGHT_START, Q.height[0])), U.push(i.Tag.encodeOptionInt(i.Tag.HEIGHT_END, Q.height[1])), U.push(i.Tag.encodeOptionInt(i.Tag.OFFSET_START, Q.offset[0])), U.push(i.Tag.encodeOptionInt(i.Tag.OFFSET_END, Q.offset[1]));
                }
            }
            if (this.mint.isSome()) {
                const K = this.mint.unwrap();
                U.push(i.Tag.encode(i.Tag.MINT, [
                    K.block,
                    K.tx
                ].map(o.u128)));
            }
            if (U.push(i.Tag.encodeOptionInt(i.Tag.POINTER, this.pointer.map(o.u128))), this.edicts.length) {
                U.push(o.u128.encodeVarInt((0, o.u128)(i.Tag.BODY)));
                const K = [
                    ...this.edicts
                ].sort((Q, G)=>Number(Q.id.block - G.id.block || Q.id.tx - G.id.tx));
                let re = new c.RuneId((0, o.u64)(0), (0, o.u32)(0));
                for (const Q of K){
                    const [G, R] = re.delta(Q.id).unwrap();
                    U.push(o.u128.encodeVarInt(G)), U.push(o.u128.encodeVarInt(R)), U.push(o.u128.encodeVarInt(Q.amount)), U.push(o.u128.encodeVarInt((0, o.u128)(Q.output))), re = Q.id;
                }
            }
            const D = [];
            D.push(t.OP_RETURN), D.push(t.MAGIC_NUMBER);
            const H = We.concat(U);
            for(let K = 0; K < H.length; K += t.MAX_SCRIPT_ELEMENT_SIZE)D.push(H.subarray(K, K + t.MAX_SCRIPT_ELEMENT_SIZE));
            return l.script.compile(D);
        }
        static payload(U) {
            for (const D of U.vout){
                const H = l.script.decompile(We.from(D.scriptPubKey.hex, "hex"));
                if (H === null) throw new Error("unable to decompile");
                let K = H.next();
                if (K.done || K.value !== t.OP_RETURN || (K = H.next(), K.done || f.Instruction.isBuffer(K.value) || K.value !== t.MAGIC_NUMBER)) continue;
                let re = [];
                do {
                    if (K = H.next(), K.done) {
                        if (!K.value) return (0, s.Some)(y.Flaw.INVALID_SCRIPT);
                        break;
                    }
                    const Q = K.value;
                    if (f.Instruction.isBuffer(Q)) re.push(Q);
                    else return (0, s.Some)(y.Flaw.OPCODE);
                }while (!0)
                return (0, s.Some)(We.concat(re));
            }
            return s.None;
        }
        static integers(U) {
            const D = [], H = new n.SeekBuffer(U);
            for(; !H.isFinished();){
                const K = o.u128.decodeVarInt(H);
                if (K.isNone()) return s.None;
                D.push(K.unwrap());
            }
            return (0, s.Some)(D);
        }
    }
    e.Runestone = O;
})(o8);
var QC = {}, Np = {}, I0 = {};
Object.defineProperty(I0, "__esModule", {
    value: !0
});
I0.RuneLocation = void 0;
var dB;
(function(e) {
    function t(r) {
        return `${r.block}:${r.tx}`;
    }
    e.toString = t;
})(dB || (I0.RuneLocation = dB = {}));
Object.defineProperty(Np, "__esModule", {
    value: !0
});
Np.RuneUpdater = void 0;
const wh = k0, zy = hn, mr = Qn, ki = wi, hB = Fd, Zye = o8, Yye = uc, pB = Dd, Wa = I0;
function uE(e) {
    return e && We.from(e, "hex")[0] === zy.OP_RETURN;
}
class Xye {
    constructor(t, r, n, i, o){
        this.reorg = n, this._storage = i, this._rpc = o, this.etchings = [], this.utxoBalances = [], this.spentBalances = [], this._mintCountsByRuneLocation = /* @__PURE__ */ new Map(), this._burnedBalancesByRuneLocation = /* @__PURE__ */ new Map(), this.block = {
            height: r.height,
            hash: r.hash,
            previousblockhash: r.previousblockhash,
            time: r.time
        }, this._minimum = hB.Rune.getMinimumAtHeight(t, (0, mr.u128)(r.height));
    }
    get mintCounts() {
        return [
            ...this._mintCountsByRuneLocation.values()
        ];
    }
    get burnedBalances() {
        return [
            ...this._burnedBalancesByRuneLocation.values()
        ];
    }
    async indexRunes(t, r) {
        const n = Zye.Runestone.decipher(t), i = await this.unallocated(t), o = [
            ...new Array(t.vout.length)
        ].map(()=>/* @__PURE__ */ new Map());
        function s(c) {
            const l = Wa.RuneLocation.toString(c), p = i.get(l) ?? {
                runeId: c,
                amount: 0n
            };
            return i.set(l, p), p;
        }
        function a(c, l) {
            const p = Wa.RuneLocation.toString(l), y = o[c].get(p) ?? {
                runeId: l,
                amount: 0n
            };
            return o[c].set(p, y), y;
        }
        if (n.isSome()) {
            const c = n.unwrap(), l = c.mint;
            if (l.isSome()) {
                const y = l.unwrap(), _ = {
                    block: Number(y.block),
                    tx: Number(y.tx)
                }, A = await this.mint(_, t.txid);
                if (A.isSome()) {
                    const O = A.unwrap(), N = s(_);
                    N.amount = mr.u128.checkedAddThrow((0, mr.u128)(N.amount), (0, mr.u128)(O));
                }
            }
            const p = await this.etched(r, t, c);
            if ((0, wh.isRunestone)(c)) {
                const y = c;
                if (p.isSome()) {
                    const _ = p.unwrap(), A = s(_.runeId);
                    A.amount = mr.u128.checkedAddThrow((0, mr.u128)(A.amount), y.etching.unwrap().premine.unwrapOr((0, mr.u128)(0)));
                }
                for (const { id: _, amount: A, output: O } of [
                    ...y.edicts
                ]){
                    if (O > t.vout.length) throw new Error("Runestone edict output should never exceed transaction output size");
                    if (_.block === 0n && _.tx === 0n && p.isNone()) continue;
                    const N = _.block === 0n && _.tx === 0n ? p.unwrap().runeId : {
                        block: Number(_.block),
                        tx: Number(_.tx)
                    }, U = Wa.RuneLocation.toString(N), D = i.get(U);
                    if (D === void 0) continue;
                    let H = (K, re)=>{
                        if (K > 0n) {
                            const Q = a(re, N);
                            D.amount = mr.u128.checkedSubThrow((0, mr.u128)(D.amount), K), Q.amount = mr.u128.checkedAddThrow((0, mr.u128)(Q.amount), K);
                        }
                    };
                    if (Number(O) === t.vout.length) {
                        const K = [
                            ...t.vout.entries()
                        ].filter(([re, Q])=>!uE(Q.scriptPubKey.hex)).map(([re])=>re);
                        if (K.length !== 0) if (A === 0n) {
                            const re = (0, mr.u128)((0, mr.u128)(D.amount) / (0, mr.u128)(K.length)), Q = (0, mr.u128)(D.amount) % (0, mr.u128)(K.length);
                            for (const [G, R] of K.entries())H(G < Q ? mr.u128.checkedAddThrow(re, (0, mr.u128)(1)) : re, R);
                        } else for (const re of K)H(A < D.amount ? A : (0, mr.u128)(D.amount), re);
                    } else H(A !== 0n && A < (0, mr.u128)(D.amount) ? A : (0, mr.u128)(D.amount), Number(O));
                }
            }
            if (p.isSome()) {
                const { runeId: y, rune: _ } = p.unwrap();
                this.createEtching(t.txid, c, y, _);
            }
        }
        const u = /* @__PURE__ */ new Map();
        function f(c) {
            const l = Wa.RuneLocation.toString(c), p = u.get(l) ?? {
                runeId: c,
                amount: 0n
            };
            return u.set(l, p), p;
        }
        if (n.isSome() && !(0, wh.isRunestone)(n.unwrap())) for (const c of i.values()){
            const l = f(c.runeId);
            l.amount = mr.u128.checkedAddThrow((0, mr.u128)(l.amount), (0, mr.u128)(c.amount));
        }
        else {
            const l = n.map((p)=>{
                if (!(0, wh.isRunestone)(p)) throw new Error("unreachable");
                return p.pointer;
            }).unwrapOr(ki.None).map((p)=>Number(p)).inspect((p)=>{
                if (p < 0 || p >= o.length) throw new Error("Pointer is invalid");
            }).orElse(()=>{
                const p = [
                    ...t.vout.entries()
                ].find(([y, _])=>!uE(_.scriptPubKey.hex));
                return p !== void 0 ? (0, ki.Some)(p[0]) : ki.None;
            });
            if (l.isSome()) {
                const p = l.unwrap();
                for (const y of i.values())if (y.amount > 0) {
                    const _ = a(p, y.runeId);
                    _.amount = mr.u128.checkedAddThrow((0, mr.u128)(_.amount), (0, mr.u128)(y.amount));
                }
            } else for (const [p, y] of i)if (y.amount > 0) {
                const _ = f(y.runeId);
                u.set(p, {
                    runeId: y.runeId,
                    amount: mr.u128.checkedAddThrow((0, mr.u128)(_.amount), (0, mr.u128)(y.amount))
                });
            }
        }
        for (const [c, l] of o.entries()){
            if (l.size === 0) continue;
            const p = t.vout[c];
            if (uE(p.scriptPubKey.hex)) {
                for (const [_, A] of l){
                    const O = f(A.runeId);
                    O.amount = mr.u128.checkedAddThrow((0, mr.u128)(O.amount), (0, mr.u128)(A.amount));
                }
                continue;
            }
            const y = new Map(this.etchings.map((_)=>[
                    Wa.RuneLocation.toString(_.runeId),
                    _
                ]));
            for (const _ of l.values()){
                const A = Wa.RuneLocation.toString(_.runeId), O = y.get(A) ?? await this._storage.getEtching(A);
                if (O === null) throw new Error("Rune should exist at this point");
                this.utxoBalances.push({
                    runeId: _.runeId,
                    runeTicker: O.runeTicker,
                    amount: _.amount,
                    scriptPubKey: We.from(p.scriptPubKey.hex),
                    txid: t.txid,
                    vout: c,
                    address: p.scriptPubKey.address
                });
            }
        }
        for (const [c, l] of u)this._burnedBalancesByRuneLocation.set(c, l);
    }
    async etched(t, r, n) {
        let i;
        if ((0, wh.isRunestone)(n)) {
            const s = n;
            if (s.etching.isNone()) return ki.None;
            i = s.etching.unwrap().rune;
        } else {
            const s = n;
            if (s.etching.isNone()) return ki.None;
            i = s.etching;
        }
        let o;
        if (i.isSome()) {
            if (o = i.unwrap(), o.value < this._minimum.value || o.reserved || this.etchings.find((u)=>pB.SpacedRune.fromString(u.runeName).rune.toString() === o.toString())) return ki.None;
            const s = await this._storage.getRuneLocation(o.toString());
            if (s && s.block < this.block.height || !await this.txCommitsToRune(r, o)) return ki.None;
        } else o = hB.Rune.getReserved((0, mr.u64)(this.block.height), (0, mr.u32)(t));
        return (0, ki.Some)({
            runeId: {
                block: this.block.height,
                tx: t
            },
            rune: o
        });
    }
    async mint(t, r) {
        var N, U, D, H;
        const n = Wa.RuneLocation.toString(t), o = new Map(this.etchings.map((K)=>[
                Wa.RuneLocation.toString(K.runeId),
                K
            ])).get(n) ?? await this._storage.getEtching(n);
        if (o === null || !o.valid || !o.terms) return ki.None;
        const s = o.terms, a = ((N = s.offset) == null ? void 0 : N.start) !== void 0 ? o.runeId.block + Number(s.offset.start) : null, u = ((U = s.height) == null ? void 0 : U.start) !== void 0 ? Number(s.height.start) : null, f = a !== null || u !== null ? Math.max(a ?? -1 / 0, u ?? -1 / 0) : null;
        if (f !== null && this.block.height < f) return ki.None;
        const c = ((D = s.offset) == null ? void 0 : D.end) !== void 0 ? o.runeId.block + Number(s.offset.end) : null, l = ((H = s.height) == null ? void 0 : H.end) !== void 0 ? Number(s.height.end) : null, p = c !== null || l !== null ? Math.max(c ?? -1 / 0, l ?? -1 / 0) : null;
        if (p !== null && this.block.height >= p) return ki.None;
        const y = s.cap ?? 0n, _ = this._mintCountsByRuneLocation.get(n) ?? {
            mint: t,
            count: 0
        };
        if (this._mintCountsByRuneLocation.set(n, _), _.count + await this._storage.getValidMintCount(n, this.block.height - 1) >= y) return ki.None;
        const O = s.amount ?? 0n;
        return _.count++, (0, ki.Some)(O);
    }
    async unallocated(t) {
        const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
        for (const i of this.utxoBalances){
            const o = `${i.txid}:${i.vout}`, s = n.get(o) ?? [];
            s.push(i), n.set(o, s);
        }
        for (const i of t.vin){
            if ("coinbase" in i) continue;
            const o = n.get(`${i.txid}:${i.vout}`) ?? await this._storage.getUtxoBalance(i.txid, i.vout);
            for (const s of o){
                const a = s.runeId, u = Wa.RuneLocation.toString(a), f = r.get(u) ?? {
                    runeId: a,
                    amount: 0n
                };
                r.set(u, f), f.amount = mr.u128.checkedAddThrow((0, mr.u128)(f.amount), (0, mr.u128)(s.amount)), this.spentBalances.push({
                    txid: i.txid,
                    vout: i.vout,
                    address: s.address,
                    scriptPubKey: s.scriptPubKey,
                    runeId: s.runeId,
                    runeTicker: s.runeTicker,
                    amount: s.amount,
                    spentTxid: t.txid
                });
            }
        }
        return r;
    }
    async txCommitsToRune(t, r) {
        const n = r.commitment;
        for (const i of t.vin){
            if ("coinbase" in i) continue;
            const o = i.txinwitness.map((c)=>We.from(c, "hex")), s = o[o.length - 1], a = o.length >= 2 && s[0] === zy.TAPROOT_ANNEX_PREFIX ? 3 : 2;
            if (a > o.length) continue;
            const u = o[o.length - a];
            if (u === void 0) continue;
            const f = Yye.script.decompile(u);
            for (const c of f){
                if (!We.isBuffer(c) || We.compare(c, n) !== 0) continue;
                const l = await this._rpc.getrawtransaction({
                    txid: i.txid,
                    verbose: !0
                });
                if (l.error !== null) throw l.error;
                const p = l.result;
                if (!(p.vout[i.vout].scriptPubKey.type === zy.TAPROOT_SCRIPT_PUBKEY_TYPE)) continue;
                const _ = await this._rpc.getblock({
                    blockhash: p.blockhash
                });
                if (_.error !== null) throw _.error;
                const A = _.result.height;
                if (mr.u128.checkedSubThrow((0, mr.u128)(this.block.height), (0, mr.u128)(A)) + 1n >= zy.COMMIT_CONFIRMATIONS) return !0;
            }
        }
        return !1;
    }
    createEtching(t, r, n, i) {
        if ((0, wh.isRunestone)(r)) {
            const { divisibility: o, terms: s, premine: a, spacers: u, symbol: f } = r.etching.unwrap();
            this.etchings.push({
                valid: !0,
                runeTicker: i.toString(),
                runeName: new pB.SpacedRune(i, Number(u.map(Number).unwrapOr(0))).toString(),
                runeId: n,
                txid: t,
                ...o.isSome() ? {
                    divisibility: o.map(Number).unwrap()
                } : {},
                ...a.isSome() ? {
                    premine: a.unwrap()
                } : {},
                ...f.isSome() ? {
                    symbol: f.unwrap()
                } : {},
                ...s.isSome() ? {
                    terms: (()=>{
                        const c = s.unwrap();
                        return {
                            ...c.amount.isSome() ? {
                                amount: c.amount.unwrap()
                            } : {},
                            ...c.cap.isSome() ? {
                                cap: c.cap.unwrap()
                            } : {},
                            ...c.height.filter((l)=>l.isSome()).length ? {
                                height: {
                                    ...c.height[0].isSome() ? {
                                        start: c.height[0].unwrap()
                                    } : {},
                                    ...c.height[1].isSome() ? {
                                        end: c.height[1].unwrap()
                                    } : {}
                                }
                            } : {},
                            ...c.offset.filter((l)=>l.isSome()).length ? {
                                offset: {
                                    ...c.offset[0].isSome() ? {
                                        start: c.offset[0].unwrap()
                                    } : {},
                                    ...c.offset[1].isSome() ? {
                                        end: c.offset[1].unwrap()
                                    } : {}
                                }
                            } : {}
                        };
                    })()
                } : {}
            });
        } else this.etchings.push({
            valid: !1,
            runeId: n,
            txid: t,
            runeTicker: i.toString(),
            runeName: i.toString()
        });
    }
}
Np.RuneUpdater = Xye;
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(u, f, c, l) {
        l === void 0 && (l = c);
        var p = Object.getOwnPropertyDescriptor(f, c);
        (!p || ("get" in p ? !f.__esModule : p.writable || p.configurable)) && (p = {
            enumerable: !0,
            get: function() {
                return f[c];
            }
        }), Object.defineProperty(u, l, p);
    } : function(u, f, c, l) {
        l === void 0 && (l = c), u[l] = f[c];
    }), r = Ge && Ge.__exportStar || function(u, f) {
        for(var c in u)c !== "default" && !Object.prototype.hasOwnProperty.call(f, c) && t(f, u, c);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RunestoneIndexer = e.RuneUpdater = void 0;
    const n = zf, i = Np, o = Qn;
    r(I0, e);
    var s = Np;
    Object.defineProperty(e, "RuneUpdater", {
        enumerable: !0,
        get: function() {
            return s.RuneUpdater;
        }
    });
    class a {
        constructor(f){
            this._started = !1, this._updateInProgress = !1, this._rpc = f.bitcoinRpcClient, this._storage = f.storage, this._network = f.network;
        }
        async start() {
            this._started || (await this._storage.connect(), this._started = !0, this._network === n.Network.MAINNET && this._storage.seedEtchings([
                {
                    runeTicker: "UNCOMMONGOODS",
                    runeName: "UNCOMMONGOODS",
                    runeId: {
                        block: 1,
                        tx: 0
                    },
                    txid: "0000000000000000000000000000000000000000000000000000000000000000",
                    valid: !0,
                    symbol: "",
                    terms: {
                        amount: 1n,
                        cap: o.u128.MAX,
                        height: {
                            start: 840000n,
                            end: 1050000n
                        }
                    }
                }
            ]));
        }
        async stop() {
            this._started && (await this._storage.disconnect(), this._started = !1);
        }
        async updateRuneUtxoBalances() {
            if (!this._started) throw new Error("Runestone indexer is not started");
            if (!this._updateInProgress) {
                this._updateInProgress = !0;
                try {
                    await this.updateRuneUtxoBalancesImpl();
                } finally{
                    this._updateInProgress = !1;
                }
            }
        }
        async updateRuneUtxoBalancesImpl() {
            const f = await this._storage.getCurrentBlock();
            if (f) {
                const p = [];
                let y = f.height, _ = (await this._rpc.getblockhash({
                    height: y
                })).result, A = f.hash;
                for(; A !== _;)_ && p.push(_), y--, _ = (await this._rpc.getblockhash({
                    height: y
                })).result, A = await this._storage.getBlockhash(y);
                p.reverse();
                for (const O of p){
                    const N = await this._rpc.getblock({
                        blockhash: O,
                        verbosity: 2
                    });
                    if (N.error !== null) throw N.error;
                    const U = N.result, D = new i.RuneUpdater(this._network, U, !0, this._storage, this._rpc);
                    for (const [H, K] of U.tx.entries())await D.indexRunes(K, H);
                    await this._storage.saveBlockIndex(D);
                }
            }
            let c = Math.max(n.Network.getFirstRuneHeight(this._network), f ? f.height + 1 : 0), l = (await this._rpc.getblockhash({
                height: c
            })).result;
            for(; l !== null;){
                const p = await this._rpc.getblock({
                    blockhash: l,
                    verbosity: 2
                });
                if (p.error !== null) throw p.error;
                const y = p.result, _ = new i.RuneUpdater(this._network, y, !1, this._storage, this._rpc);
                for (const [A, O] of y.tx.entries())await _.indexRunes(O, A);
                await this._storage.saveBlockIndex(_), c++, l = (await this._rpc.getblockhash({
                    height: c
                })).result;
            }
        }
    }
    e.RunestoneIndexer = a;
})(QC);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.tryDecodeRunestone = e.isRunestone = e.encodeRunestone = e.Network = e.RunestoneIndexer = e.RuneUpdater = e.RuneLocation = void 0;
    const t = k0, r = hn, n = Ud, i = Kd, o = Qn, s = wi, a = Wd, u = o8, f = Dd;
    var c = QC;
    Object.defineProperty(e, "RuneLocation", {
        enumerable: !0,
        get: function() {
            return c.RuneLocation;
        }
    }), Object.defineProperty(e, "RuneUpdater", {
        enumerable: !0,
        get: function() {
            return c.RuneUpdater;
        }
    }), Object.defineProperty(e, "RunestoneIndexer", {
        enumerable: !0,
        get: function() {
            return c.RunestoneIndexer;
        }
    });
    var l = zf;
    Object.defineProperty(e, "Network", {
        enumerable: !0,
        get: function() {
            return l.Network;
        }
    });
    function p(H) {
        switch(H){
            case i.Flaw.EDICT_OUTPUT:
                return "edict_output";
            case i.Flaw.EDICT_RUNE_ID:
                return "edict_rune_id";
            case i.Flaw.INVALID_SCRIPT:
                return "invalid_script";
            case i.Flaw.OPCODE:
                return "opcode";
            case i.Flaw.SUPPLY_OVERFLOW:
                return "supply_overflow";
            case i.Flaw.TRAILING_INTEGERS:
                return "trailing_integers";
            case i.Flaw.TRUNCATED_FIELD:
                return "truncated_field";
            case i.Flaw.UNRECOGNIZED_EVEN_TAG:
                return "unrecognized_even_tag";
            case i.Flaw.UNRECOGNIZED_FLAG:
                return "unrecognized_flag";
            case i.Flaw.VARINT:
                return "varint";
        }
    }
    const y = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u8.MAX) throw Error("u8 overflow");
        return (0, o.u8)(K);
    }, _ = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u32.MAX) throw Error("u32 overflow");
        return (0, o.u32)(K);
    }, A = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u64.MAX) throw Error("u64 overflow");
        return (0, o.u64)(K);
    }, O = (H)=>{
        const K = BigInt(H);
        if (K < 0n || K > o.u128.MAX) throw Error("u128 overflow");
        return (0, o.u128)(K);
    };
    function N(H) {
        const K = H.mint ? (0, s.Some)(new a.RuneId(A(H.mint.block), _(H.mint.tx))) : s.None, re = H.pointer !== void 0 ? (0, s.Some)(H.pointer).map(_) : s.None, Q = (H.edicts ?? []).map((X)=>({
                id: new a.RuneId(A(X.id.block), _(X.id.tx)),
                amount: O(X.amount),
                output: _(X.output)
            }));
        let G = s.None, R;
        if (H.etching) {
            const X = H.etching, $ = X.runeName ? f.SpacedRune.fromString(X.runeName) : void 0, S = ($ == null ? void 0 : $.rune) !== void 0 ? (0, s.Some)($.rune) : s.None;
            if (X.symbol && !(X.symbol.length === 1 || X.symbol.length === 2 && X.symbol.codePointAt(0) >= 65536)) throw Error("Symbol must be one code point");
            const w = X.divisibility !== void 0 ? (0, s.Some)(X.divisibility).map(y) : s.None, g = X.premine !== void 0 ? (0, s.Some)(X.premine).map(O) : s.None, m = ($ == null ? void 0 : $.spacers) !== void 0 && $.spacers !== 0 ? (0, s.Some)(_($.spacers)) : s.None, E = X.symbol ? (0, s.Some)(X.symbol) : s.None;
            if (w.isSome() && w.unwrap() > r.MAX_DIVISIBILITY) throw Error(`Divisibility is greater than protocol max ${r.MAX_DIVISIBILITY}`);
            let T = s.None;
            if (X.terms) {
                const P = X.terms, k = P.amount !== void 0 ? (0, s.Some)(P.amount).map(O) : s.None, L = P.cap !== void 0 ? (0, s.Some)(P.cap).map(O) : s.None, j = P.height ? [
                    P.height.start !== void 0 ? (0, s.Some)(P.height.start).map(A) : s.None,
                    P.height.end !== void 0 ? (0, s.Some)(P.height.end).map(A) : s.None
                ] : [
                    s.None,
                    s.None
                ], ie = P.offset ? [
                    P.offset.start !== void 0 ? (0, s.Some)(P.offset.start).map(A) : s.None,
                    P.offset.end !== void 0 ? (0, s.Some)(P.offset.end).map(A) : s.None
                ] : [
                    s.None,
                    s.None
                ];
                if (k.isSome() && L.isSome() && k.unwrap() * L.unwrap() > o.u128.MAX) throw Error("Terms overflow with amount times cap");
                T = (0, s.Some)({
                    amount: k,
                    cap: L,
                    height: j,
                    offset: ie
                });
            }
            const I = X.turbo ?? !1;
            G = (0, s.Some)(new n.Etching(w, S, m, E, T, g, I)), R = S.isSome() ? S.unwrap().commitment : void 0;
        }
        return {
            encodedRunestone: new u.Runestone(K, re, Q, G).encipher(),
            etchingCommitment: R
        };
    }
    e.encodeRunestone = N;
    function U(H) {
        return !("flaws" in H);
    }
    e.isRunestone = U;
    function D(H) {
        const K = u.Runestone.decipher(H);
        if (K.isNone()) return null;
        const re = K.unwrap();
        if ((0, t.isRunestone)(re)) {
            const Q = re, G = ()=>Q.etching.unwrap(), R = ()=>G().terms.unwrap();
            return {
                ...Q.etching.isSome() ? {
                    etching: {
                        ...G().divisibility.isSome() ? {
                            divisibility: G().divisibility.map(Number).unwrap()
                        } : {},
                        ...G().premine.isSome() ? {
                            premine: G().premine.unwrap()
                        } : {},
                        ...G().rune.isSome() ? {
                            runeName: new f.SpacedRune(G().rune.unwrap(), G().spacers.map(Number).unwrapOr(0)).toString()
                        } : {},
                        ...G().symbol.isSome() ? {
                            symbol: G().symbol.unwrap()
                        } : {},
                        ...G().terms.isSome() ? {
                            terms: {
                                ...R().amount.isSome() ? {
                                    amount: R().amount.unwrap()
                                } : {},
                                ...R().cap.isSome() ? {
                                    cap: R().cap.unwrap()
                                } : {},
                                ...R().height.find((X)=>X.isSome()) ? {
                                    height: {
                                        ...R().height[0].isSome() ? {
                                            start: R().height[0].unwrap()
                                        } : {},
                                        ...R().height[1].isSome() ? {
                                            end: R().height[1].unwrap()
                                        } : {}
                                    }
                                } : {},
                                ...R().offset.find((X)=>X.isSome()) ? {
                                    offset: {
                                        ...R().offset[0].isSome() ? {
                                            start: R().offset[0].unwrap()
                                        } : {},
                                        ...R().offset[1].isSome() ? {
                                            end: R().offset[1].unwrap()
                                        } : {}
                                    }
                                } : {}
                            }
                        } : {},
                        turbo: G().turbo
                    }
                } : {},
                ...Q.mint.isSome() ? {
                    mint: {
                        block: Q.mint.unwrap().block,
                        tx: Number(Q.mint.unwrap().tx)
                    }
                } : {},
                ...Q.pointer.isSome() ? {
                    pointer: Number(Q.pointer.unwrap())
                } : {},
                ...Q.edicts.length ? {
                    edicts: Q.edicts.map((X)=>({
                            id: {
                                block: X.id.block,
                                tx: Number(X.id.tx)
                            },
                            amount: X.amount,
                            output: Number(X.output)
                        }))
                } : {}
            };
        } else {
            const Q = re;
            return {
                flaws: Q.flaws.map(p),
                ...Q.etching.isSome() ? {
                    etching: Q.etching.unwrap().toString()
                } : {},
                ...Q.mint.isSome() ? {
                    mint: {
                        block: Q.mint.unwrap().block,
                        tx: Number(Q.mint.unwrap().tx)
                    }
                } : {}
            };
        }
    }
    e.tryDecodeRunestone = D;
})(jye);
const Jye = ({ runeId: e, amount: t, divisibility: r = 0, sendOutputIndex: n = 1, pointer: i = 0 })=>{
    r === 0 && (t = Math.floor(t));
    const o = Vu(BigInt(22)).varint, s = Vu(BigInt(i)).varint, a = Vu(BigInt(0)).varint, u = Vu(BigInt(t * 10 ** r)).varint, f = Vu(BigInt(n)).varint, c = e.split(":"), l = Number(c[0]), p = Number(c[1]), y = Vu(BigInt(l)).varint, _ = Vu(BigInt(p)).varint, A = We.concat([
        o,
        s,
        a,
        y,
        _,
        u,
        f
    ]);
    let O = A.byteLength.toString(16);
    return O.length % 2 !== 0 && (O = "0" + A.byteLength.toString(16)), We.concat([
        We.from("6a", "hex"),
        We.from("5d", "hex"),
        We.from(O, "hex"),
        A
    ]);
}, x1 = async (e, t)=>{
    const r = JSON.stringify({
        jsonrpc: "2.0",
        id: e,
        method: e,
        params: t
    });
    return await rn.post(`${UP}/${ql}`, r, {
        headers: {
            "content-type": "application/json"
        }
    }).then((n)=>n.data).catch((n)=>{
        throw n;
    });
}, Qye = async (e)=>(await x1("ord_address", [
        e
    ])).result, eU = async (e)=>(await x1("ord_rune", [
        e
    ])).result, eme = async (e)=>(await x1("ord_rune", [
        e
    ])).result, tme = async ({ outpoints: e, rune_name: t })=>{
    const n = [];
    for(let i = 0; i < e.length; i += 1e3){
        const o = e.slice(i, i + 1e3), s = o.map((f)=>[
                "ord_output",
                [
                    f
                ]
            ]), { result: a } = await x1("sandshrew_multicall", s);
        for(let f = 0; f < a.length; f++)a[f].result.output = o[f];
        const u = a.filter((f)=>Object.keys(f.result.runes).includes(t));
        n.push(...u);
    }
    return n;
}, rme = async ({ ordOutputs: e })=>{
    var r;
    const t = [];
    for(let n = 0; n < e.length; n++){
        const i = e[n], { result: o } = i;
        if (!((r = o.output) != null && r.split(":"))) throw new Error("No output found");
        const { output: s, address: a, runes: u } = o, f = {
            output: s,
            wallet_addr: a,
            script: "",
            balances: [],
            decimals: [],
            rune_ids: [],
            value: o.value
        }, [c, l] = s.split(":");
        if (console.log(c, l, s), f.script = We.from(oN(a, ln)).toString("hex"), typeof u == "object" && !Array.isArray(u)) for(const p in u)f.balances.push(u[p].amount), f.decimals.push(u[p].divisibility), f.rune_ids.push((await eme(p)).id);
        t.push(f);
    }
    return t;
}, nme = async ({ address: e, runeId: t })=>{
    const r = await Qye(e), { entry: n } = await eU(t), i = n.spaced_rune, o = await tme({
        outpoints: r.outputs,
        rune_name: i
    });
    return await rme({
        ordOutputs: o
    });
}, ime = async ({ runeId: e, amount: t, ordinalAddress: r, ordinalPublicKey: n, paymentAddress: i, paymentPublicKey: o, toAddress: s, signPsbt: a, network: u = ln })=>{
    try {
        const f = await ome({
            fromAddress: r,
            fromAddressPublicKey: n,
            fromPaymentAddress: i,
            fromPaymentPublicKey: o,
            toAddress: s,
            runeId: e,
            amount: t,
            network: u
        });
        if (!f || !(f != null && f.psbtHex)) throw new Error("couldn't get commit tx");
        const c = String(f == null ? void 0 : f.psbtHex), l = String(f == null ? void 0 : f.psbtBase64), p = await a({
            tx: c,
            psbtHex: c,
            psbtBase64: l,
            finalize: !0,
            broadcast: !1,
            network: u
        });
        if (!p) throw new Error("sign psbt failed");
        const _ = Cr.fromHex((p == null ? void 0 : p.signedPsbtHex) || "").extractTransaction();
        return await Hb(_.toHex(), u);
    } catch (f) {
        throw f;
    }
}, ome = async ({ fromAddress: e, fromAddressPublicKey: t, fromPaymentAddress: r, fromPaymentPublicKey: n, toAddress: i, runeId: o, amount: s, network: a })=>{
    try {
        const { fastestFee: u } = await iN(a);
        let c = (await J3(r, a)).sort((R, X)=>X.value - R.value).filter((R)=>R.value > 3e3);
        if (c.length === 0) throw new Error("No utxos found");
        let l = new Cr({
            network: Dr(a)
        }), p = 0;
        const y = await eU(o), _ = await nme({
            runeId: o,
            address: e
        }), A = jb(c), O = X3(_.length, 2, 4);
        let U = O * u < 250 ? 250 : O * u, D = 0;
        for await (const R of _){
            const { output: X, value: $, script: S } = R, w = X.split(":"), g = w[0], m = w[1];
            l.addInput({
                hash: g,
                index: parseInt(m),
                witnessUtxo: {
                    value: BigInt($),
                    script: We.from(S, "hex")
                },
                tapInternalKey: Mo(We.from(t, "hex"))
            }), D++, p += $;
        }
        const H = Jb(r, a);
        for(let R = 0; R < c.length; R++){
            const X = hs(r, Dr(ln)), $ = c[R];
            if (H === df && l.addInput({
                hash: $.txid,
                index: $.vout,
                witnessUtxo: {
                    value: BigInt($.value),
                    script: X
                },
                tapInternalKey: Mo(We.from(n, "hex"))
            }), H === Xp) {
                let S = d0(n, a);
                l.addInput({
                    hash: $.txid,
                    index: $.vout,
                    witnessUtxo: {
                        value: BigInt($.value),
                        script: X
                    },
                    redeemScript: S
                });
            }
            H === "p2wpkh" && l.addInput({
                hash: $.txid,
                index: $.vout,
                witnessUtxo: {
                    value: BigInt($.value),
                    script: X
                }
            });
        }
        const re = {
            script: Jye({
                runeId: y.id,
                amount: s,
                divisibility: y.entry.divisibility,
                sendOutputIndex: 2,
                pointer: 1
            }),
            value: BigInt(0)
        };
        l.addOutput(re);
        const Q = 546, G = A - (U + Q * 2);
        return l.addOutput({
            value: BigInt(Q),
            address: e
        }), l.addOutput({
            value: BigInt(Q),
            address: i
        }), l.addOutput({
            address: r,
            value: BigInt(G)
        }), {
            psbtBase64: l.toBase64(),
            psbtHex: l.toHex()
        };
    } catch (u) {
        throw u;
    }
}, sme = (e, t)=>`{"p":"brc-20","op":"transfer","tick":"${e}","amt":"${t}"}`, ame = async ({ ticker: e, amount: t, ordinalAddress: r, ordinalPublicKey: n, paymentAddress: i, paymentPublicKey: o, toAddress: s, signPsbt: a, dataSourceManager: u, network: f = ln })=>{
    let c;
    if (u ? c = u : c = nc.getInstance(), !c) throw new Error("Data source not found");
    if (!(c != null && c.getAddressBrc20Balances)) throw new Error("Data source not found");
    if (!await (c == null ? void 0 : c.getAddressBrc20Balances(r))) throw new Error("Address balance not found");
    const p = sme(e, t), y = await XC({
        contentBase64: btoa(p),
        mimeType: "text/plain",
        ordinalAddress: r,
        paymentAddress: i,
        paymentPublicKey: o,
        signPsbt: a,
        dataSourceManager: c,
        network: f
    });
    await c.waitForTransaction(y);
    const { fastFee: _ } = await c.getRecommendedFees(), A = 5 * 34 * 1, O = Math.floor(A * _ * 1);
    await new Promise((g)=>setTimeout(g, 1e4));
    const U = (await c.getAddressUtxos(i)).filter((g)=>g.value > 3e3).sort((g, m)=>m.value - g.value);
    if (jb(U) < O) throw new Error("insufficient funds");
    console.log("inscriptionTxId", y);
    const H = new Cr({
        network: Dr(f)
    }), K = hs(r, Dr(f));
    H.addInput({
        hash: y,
        index: 0,
        witnessUtxo: {
            script: K,
            value: BigInt(546)
        },
        tapInternalKey: Mo(We.from(n, "hex"))
    }), H.addOutput({
        address: s,
        value: BigInt(546)
    });
    let re = 0, Q = 0;
    for await (const g of U){
        const m = hs(i, Dr(f)), E = Jb(i, f);
        if (H.addInput({
            hash: g.txid,
            index: g.vout,
            witnessUtxo: {
                value: BigInt(g.value),
                script: m
            },
            tapInternalKey: Mo(We.from(o, "hex"))
        }), E === Xp) {
            const T = d0(o, f);
            H.updateInput(re, {
                redeemScript: T
            });
        }
        if (re++, Q += g.value, Q > O) {
            console.log("BREAKING");
            break;
        }
    }
    const G = Q - O;
    G > 546 && H.addOutput({
        value: BigInt(G),
        address: i
    });
    const R = H == null ? void 0 : H.toHex(), X = H == null ? void 0 : H.toBase64(), $ = await a({
        tx: "",
        psbtHex: R,
        psbtBase64: X,
        finalize: !0,
        broadcast: !0,
        network: f
    });
    if (!$) throw new Error("sign psbt failed");
    const w = Cr.fromHex(($ == null ? void 0 : $.signedPsbtHex) || "").extractTransaction();
    return await Hb(w.toHex(), f);
}, cme = async ({ inscriptionIds: e, ordinalAddress: t, ordinalPublicKey: r, paymentAddress: n, paymentPublicKey: i, toAddress: o, signPsbt: s, dataSourceManager: a, network: u = ln })=>{
    try {
        const f = await ume({
            inscriptionIds: e,
            fromAddress: t,
            fromAddressPublicKey: r,
            fromPaymentAddress: n,
            fromPaymentPublicKey: i,
            dataSourceManager: a,
            toAddress: o,
            network: u
        });
        if (!f || !(f != null && f.psbtHex)) throw new Error("couldn't get commit tx");
        const c = String(f == null ? void 0 : f.psbtHex), l = String(f == null ? void 0 : f.psbtBase64), p = await s({
            tx: "",
            psbtHex: c,
            psbtBase64: l,
            finalize: !0,
            broadcast: !1,
            network: u
        });
        if (!p) throw new Error("sign psbt failed");
        const _ = Cr.fromHex((p == null ? void 0 : p.signedPsbtHex) || "").extractTransaction();
        return await Hb(_.toHex(), u);
    } catch (f) {
        throw f;
    }
}, ume = async ({ fromAddress: e, fromAddressPublicKey: t, fromPaymentAddress: r, fromPaymentPublicKey: n, toAddress: i, inscriptionIds: o, dataSourceManager: s, network: a })=>{
    try {
        const { fastestFee: u } = await iN(a);
        let c = (await s.getAddressUtxos(r)).sort((K, re)=>re.value - K.value).filter((K)=>K.value > 3e3);
        if (c.length === 0) throw new Error("No utxos found");
        const l = s.getSource("sandshrew");
        if (!l || !l.batchOrdInscriptionInfo) throw new Error("Sandshrew data source not found");
        const p = await (l == null ? void 0 : l.batchOrdInscriptionInfo(o));
        console.log(p);
        let y = new Cr({
            network: Dr(a)
        });
        const _ = jb(c), A = X3(p.length, 2, 4);
        let N = A * u < 250 ? 250 : A * u, U = 0;
        for await (const K of p){
            const { value: re, satpoint: Q } = K, [G, R] = Q.split(":");
            if (!re || !G || !R) throw new Error("Invalid satpoint or value");
            const X = hs(e, Dr(ln));
            y.addInput({
                hash: G,
                index: parseInt(R),
                witnessUtxo: {
                    value: BigInt(re),
                    script: X
                },
                tapInternalKey: Mo(We.from(t, "hex"))
            }), y.addOutput({
                value: BigInt(re),
                address: i
            }), U++;
        }
        const D = Jb(r, a);
        for(let K = 0; K < c.length; K++){
            const re = hs(r, Dr(ln)), Q = c[K];
            if (D === df && y.addInput({
                hash: Q.txid,
                index: Q.vout,
                witnessUtxo: {
                    value: BigInt(Q.value),
                    script: re
                },
                tapInternalKey: Mo(We.from(n, "hex"))
            }), D === Xp) {
                let G = d0(n, a);
                y.addInput({
                    hash: Q.txid,
                    index: Q.vout,
                    witnessUtxo: {
                        value: BigInt(Q.value),
                        script: re
                    },
                    redeemScript: G
                });
            }
            D === "p2wpkh" && y.addInput({
                hash: Q.txid,
                index: Q.vout,
                witnessUtxo: {
                    value: BigInt(Q.value),
                    script: re
                }
            });
        }
        const H = _ - N;
        return y.addOutput({
            address: e,
            value: BigInt(H)
        }), {
            psbtBase64: y.toBase64(),
            psbtHex: y.toHex()
        };
    } catch (u) {
        throw u;
    }
}, gB = new Error("The connected wallet doesn't support this method..."), fme = new Error("Wallet is not installed");
class Do {
    constructor(t, r, n){
        pt(this, "$store");
        pt(this, "$network");
        pt(this, "dataSourceManager");
        pt(this, "send", async (t, r)=>{
            switch(t){
                case Pk:
                    {
                        const n = r;
                        return await this.sendBTC(n.toAddress, n.amount);
                    }
                case Mk:
                    {
                        if (this.$network.get() !== ln) throw new Error("Unsupported network");
                        const n = r;
                        if (!n.runeId || !n.amount || !n.toAddress) throw new Error("Missing required parameters");
                        return await ime({
                            runeId: n.runeId,
                            amount: n.amount,
                            ordinalAddress: this.$store.get().address,
                            ordinalPublicKey: this.$store.get().publicKey,
                            paymentAddress: this.$store.get().paymentAddress,
                            paymentPublicKey: this.$store.get().paymentPublicKey,
                            toAddress: n.toAddress,
                            signPsbt: this.signPsbt.bind(this),
                            network: this.$network.get()
                        });
                    }
                case Nk:
                    {
                        if (this.$network.get() !== ln) throw new Error("Unsupported network");
                        const n = r;
                        if (!n.ticker || !n.amount || !n.toAddress) throw new Error("Missing required parameters");
                        return await ame({
                            ticker: n.ticker,
                            amount: n.amount,
                            ordinalAddress: this.$store.get().address,
                            ordinalPublicKey: this.$store.get().publicKey,
                            paymentAddress: this.$store.get().paymentAddress,
                            paymentPublicKey: this.$store.get().paymentPublicKey,
                            signPsbt: this.signPsbt.bind(this),
                            toAddress: n.toAddress,
                            dataSourceManager: this.dataSourceManager,
                            network: this.$network.get()
                        });
                    }
                case Rk:
                    {
                        const n = r;
                        if (!n.id || !n.amount || !n.toAddress) throw new Error("Missing required parameters");
                        return await new lM(this.parent).send(n.id, n.amount, n.toAddress);
                    }
                default:
                    throw new Error("Unsupported protocol");
            }
        });
        this.parent = r, this.config = n, this.$store = t.$store, this.$network = t.$network, this.config = n;
        try {
            this.dataSourceManager = nc.getInstance();
        } catch  {
            nc.init(n), this.dataSourceManager = nc.getInstance();
        }
        this.initialize();
    }
    disconnect() {}
    async requestAccounts() {
        return this.$store.get().accounts;
    }
    async switchNetwork(t) {
        throw this.parent.disconnect(), gB;
    }
    async getNetwork() {
        const { address: t } = this.$store.get();
        return t.slice(0, 1) === "t" && [
            Ni,
            ao,
            Ro,
            co
        ].includes(this.$network.get()) ? this.$network.get() : ln;
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async getBalance() {
        if (!this.dataSourceManager.getAddressBtcBalance) throw new Error("Method not found on data source");
        return await this.dataSourceManager.getAddressBtcBalance(this.$store.get().paymentAddress);
    }
    async getMetaBalances(t) {
        switch(t){
            case Pk:
                return await this.getBalance();
            case Mk:
                {
                    if (this.$network.get() !== ln) throw new Error("Unsupported network");
                    if (!this.dataSourceManager.getAddressRunesBalances) throw new Error("Method not found on data source");
                    return await this.dataSourceManager.getAddressRunesBalances(this.$store.get().address);
                }
            case Nk:
                if (!this.dataSourceManager.getAddressBrc20Balances) throw new Error("Method not found on data source");
                return await this.dataSourceManager.getAddressBrc20Balances(this.$store.get().address);
            case Rk:
                if (!this.dataSourceManager.getAddressAlkanesBalances) throw new Error("Method not found on data source");
                return await this.dataSourceManager.getAddressAlkanesBalances(this.$store.get().address);
            default:
                throw new Error("Unsupported protocol");
        }
    }
    async getInscriptions(t, r) {
        if (!this.dataSourceManager.getAddressInscriptions) throw new Error("Method not found on data source");
        return await this.dataSourceManager.getAddressInscriptions(this.$store.get().address, t, r);
    }
    async signPsbts(t) {
        throw gB;
    }
    async pushPsbt(t) {
        let r = t;
        return r.startsWith("02") || (r = Cr.fromHex(r).extractTransaction().toHex()), await Hb(r, this.$network.get());
    }
    async inscribe(t, r, n, i) {
        return await XC({
            contentBase64: t,
            mimeType: r,
            ordinalAddress: this.$store.get().address,
            paymentAddress: this.$store.get().paymentAddress,
            paymentPublicKey: this.$store.get().paymentPublicKey,
            signPsbt: this.signPsbt.bind(this),
            dataSourceManager: n || this.dataSourceManager,
            opReturn: i,
            network: this.$network.get()
        });
    }
    async sendInscriptions(t, r) {
        if ((await this.getInscriptions()).filter((o)=>t.includes(o.id)).length !== t.length) throw new Error("Missing inscriptions");
        return await cme({
            inscriptionIds: t,
            ordinalAddress: this.$store.get().address,
            ordinalPublicKey: this.$store.get().publicKey,
            paymentAddress: this.$store.get().paymentAddress,
            paymentPublicKey: this.$store.get().paymentPublicKey,
            toAddress: r,
            signPsbt: this.signPsbt.bind(this),
            dataSourceManager: this.dataSourceManager,
            network: this.$network.get()
        });
    }
    getDeviceInfo() {
        const t = navigator.userAgent.toLowerCase(), n = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(t), o = /ipad|android(?!.*mobile)|tablet/i.test(t), s = "ontouchstart" in window || navigator.maxTouchPoints > 0, a = window.innerWidth <= 768;
        let u;
        return o ? u = "tablet" : n || s && a ? u = "mobile" : u = "desktop", {
            isMobile: u === "mobile" || u === "tablet",
            isDesktop: u === "desktop",
            deviceType: u,
            userAgent: navigator.userAgent
        };
    }
    isMobile() {
        return this.getDeviceInfo().isMobile;
    }
    isDesktop() {
        return this.getDeviceInfo().isDesktop;
    }
    getSuggestedConnectionMethod() {
        const t = this.getDeviceInfo();
        return t.deviceType === "mobile" ? "deep-link" : t.deviceType === "tablet" ? "qr-code" : "browser-extension";
    }
}
class lme extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "handleNetworkChanged", (r)=>{
            const n = r === "mainnet" ? dt.MAINNET : r === "testnet" ? dt.TESTNET : dt.SIGNET;
            this.network !== n && this.connect(Rl);
        });
    }
    get library() {
        var r;
        return ((r = window.keplr) == null ? void 0 : r.bitcoin) ?? window.bitcoin_keplr;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Rl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            var n;
            if (r.provider !== Rl) {
                this == null || this.removeListeners();
                return;
            }
            (n = this.library) == null || n.getAccounts().then((i)=>{
                this.handleAccountsChanged(i);
            }), this.addListeners();
        });
    }
    addListeners() {
        var r, n;
        (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var r, n;
        (r = this.library) == null || r.off("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.off("networkChanged", this.handleNetworkChanged.bind(this));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Rl) : this.parent.disconnect());
    }
    async connect(r) {
        if (!this.library) if (this.isMobile()) {
            const s = `https://deeplink.keplr.app/web-browser?url=${window.location.href}`, a = window.open(s);
            if (!a) throw new Error("Keplr wallet not found");
            return a.focus(), !1;
        } else throw new Error("Keplr wallet not found");
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        const i = await this.library.getPublicKey();
        if (!i) throw new Error("No public key found");
        this.$store.setKey("accounts", n), this.$store.setKey("address", n[0]), this.$store.setKey("paymentAddress", n[0]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i);
        const o = await this.getNetwork();
        this.$network.set(o);
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getChain());
        return r ? GQ(r.enum) : this.network;
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (!i) throw new Error("Transaction failed");
        return i;
    }
    async signMessage(r, n) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await this.library.signMessage(r, i);
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const s = await this.library.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        })), a = Cr.fromHex(s);
        if (i && n) {
            const u = await this.pushPsbt(s);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: u
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        if (!this.library) throw new Error("Keplr isn't installed");
        return (await this.library.getBalance()).total;
    }
    async requestAccounts() {
        if (!this.library) throw new Error("Keplr isn't installed");
        return await this.library.requestAccounts();
    }
    async switchNetwork(r) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const n = [
            dt.MAINNET,
            dt.TESTNET,
            dt.SIGNET
        ];
        if (!n.includes(r)) throw new Error(`Invalid network: ${r}. Keplr supports ${n.join(", ")}`);
        const i = WQ(r);
        await this.library.switchChain(i);
    }
}
var zr;
(function(e) {
    e.assertEqual = (i)=>i;
    function t(i) {}
    e.assertIs = t;
    function r(i) {
        throw new Error();
    }
    e.assertNever = r, e.arrayToEnum = (i)=>{
        const o = {};
        for (const s of i)o[s] = s;
        return o;
    }, e.getValidEnumValues = (i)=>{
        const o = e.objectKeys(i).filter((a)=>typeof i[i[a]] != "number"), s = {};
        for (const a of o)s[a] = i[a];
        return e.objectValues(s);
    }, e.objectValues = (i)=>e.objectKeys(i).map(function(o) {
            return i[o];
        }), e.objectKeys = typeof Object.keys == "function" ? (i)=>Object.keys(i) : (i)=>{
        const o = [];
        for(const s in i)Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
        return o;
    }, e.find = (i, o)=>{
        for (const s of i)if (o(s)) return s;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i)=>Number.isInteger(i) : (i)=>typeof i == "number" && isFinite(i) && Math.floor(i) === i;
    function n(i, o = " | ") {
        return i.map((s)=>typeof s == "string" ? `'${s}'` : s).join(o);
    }
    e.joinValues = n, e.jsonStringifyReplacer = (i, o)=>typeof o == "bigint" ? o.toString() : o;
})(zr || (zr = {}));
var Hx;
(function(e) {
    e.mergeShapes = (t, r)=>({
            ...t,
            ...r
        });
})(Hx || (Hx = {}));
const Ot = zr.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), Qa = (e)=>{
    switch(typeof e){
        case "undefined":
            return Ot.undefined;
        case "string":
            return Ot.string;
        case "number":
            return isNaN(e) ? Ot.nan : Ot.number;
        case "boolean":
            return Ot.boolean;
        case "function":
            return Ot.function;
        case "bigint":
            return Ot.bigint;
        case "symbol":
            return Ot.symbol;
        case "object":
            return Array.isArray(e) ? Ot.array : e === null ? Ot.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ot.promise : typeof Map < "u" && e instanceof Map ? Ot.map : typeof Set < "u" && e instanceof Set ? Ot.set : typeof Date < "u" && e instanceof Date ? Ot.date : Ot.object;
        default:
            return Ot.unknown;
    }
}, ht = zr.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]), dme = (e)=>JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Co extends Error {
    get errors() {
        return this.issues;
    }
    constructor(t){
        super(), this.issues = [], this.addIssue = (n)=>{
            this.issues = [
                ...this.issues,
                n
            ];
        }, this.addIssues = (n = [])=>{
            this.issues = [
                ...this.issues,
                ...n
            ];
        };
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    format(t) {
        const r = t || function(o) {
            return o.message;
        }, n = {
            _errors: []
        }, i = (o)=>{
            for (const s of o.issues)if (s.code === "invalid_union") s.unionErrors.map(i);
            else if (s.code === "invalid_return_type") i(s.returnTypeError);
            else if (s.code === "invalid_arguments") i(s.argumentsError);
            else if (s.path.length === 0) n._errors.push(r(s));
            else {
                let a = n, u = 0;
                for(; u < s.path.length;){
                    const f = s.path[u];
                    u === s.path.length - 1 ? (a[f] = a[f] || {
                        _errors: []
                    }, a[f]._errors.push(r(s))) : a[f] = a[f] || {
                        _errors: []
                    }, a = a[f], u++;
                }
            }
        };
        return i(this), n;
    }
    static assert(t) {
        if (!(t instanceof Co)) throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, zr.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(t = (r)=>r.message) {
        const r = {}, n = [];
        for (const i of this.issues)i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
        return {
            formErrors: n,
            fieldErrors: r
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
Co.create = (e)=>new Co(e);
const yd = (e, t)=>{
    let r;
    switch(e.code){
        case ht.invalid_type:
            e.received === Ot.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
            break;
        case ht.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(e.expected, zr.jsonStringifyReplacer)}`;
            break;
        case ht.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${zr.joinValues(e.keys, ", ")}`;
            break;
        case ht.invalid_union:
            r = "Invalid input";
            break;
        case ht.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${zr.joinValues(e.options)}`;
            break;
        case ht.invalid_enum_value:
            r = `Invalid enum value. Expected ${zr.joinValues(e.options)}, received '${e.received}'`;
            break;
        case ht.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case ht.invalid_return_type:
            r = "Invalid function return type";
            break;
        case ht.invalid_date:
            r = "Invalid date";
            break;
        case ht.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : zr.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
            break;
        case ht.too_small:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
            break;
        case ht.too_big:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
            break;
        case ht.custom:
            r = "Invalid input";
            break;
        case ht.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case ht.not_multiple_of:
            r = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case ht.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = t.defaultError, zr.assertNever(e);
    }
    return {
        message: r
    };
};
let tU = yd;
function hme(e) {
    tU = e;
}
function Zm() {
    return tU;
}
const Ym = (e)=>{
    const { data: t, path: r, errorMaps: n, issueData: i } = e, o = [
        ...r,
        ...i.path || []
    ], s = {
        ...i,
        path: o
    };
    if (i.message !== void 0) return {
        ...i,
        path: o,
        message: i.message
    };
    let a = "";
    const u = n.filter((f)=>!!f).slice().reverse();
    for (const f of u)a = f(s, {
        data: t,
        defaultError: a
    }).message;
    return {
        ...i,
        path: o,
        message: a
    };
}, pme = [];
function Tt(e, t) {
    const r = Zm(), n = Ym({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
            e.common.contextualErrorMap,
            // contextual error map is first priority
            e.schemaErrorMap,
            // then schema-bound map if available
            r,
            // then global override map
            r === yd ? void 0 : yd
        ].filter((i)=>!!i)
    });
    e.common.issues.push(n);
}
class Ui {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
        const n = [];
        for (const i of r){
            if (i.status === "aborted") return er;
            i.status === "dirty" && t.dirty(), n.push(i.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const i of r){
            const o = await i.key, s = await i.value;
            n.push({
                key: o,
                value: s
            });
        }
        return Ui.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const i of r){
            const { key: o, value: s } = i;
            if (o.status === "aborted" || s.status === "aborted") return er;
            o.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof s.value < "u" || i.alwaysSet) && (n[o.value] = s.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
}
const er = Object.freeze({
    status: "aborted"
}), Dl = (e)=>({
        status: "dirty",
        value: e
    }), Wi = (e)=>({
        status: "valid",
        value: e
    }), qx = (e)=>e.status === "aborted", Kx = (e)=>e.status === "dirty", If = (e)=>e.status === "valid", Mp = (e)=>typeof Promise < "u" && e instanceof Promise;
function Xm(e, t, r, n) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t.get(e);
}
function rU(e, t, r, n, i) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, r), r;
}
var $t;
(function(e) {
    e.errToObj = (t)=>typeof t == "string" ? {
            message: t
        } : t || {}, e.toString = (t)=>typeof t == "string" ? t : t == null ? void 0 : t.message;
})($t || ($t = {}));
var Bh, Oh;
class _a {
    constructor(t, r, n, i){
        this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
}
const yB = (e, t)=>{
    if (If(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const r = new Co(e.common.issues);
            return this._error = r, this._error;
        }
    };
};
function hr(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
    if (t && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i
    } : {
        errorMap: (s, a)=>{
            var u, f;
            const { message: c } = e;
            return s.code === "invalid_enum_value" ? {
                message: c ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: (u = c ?? n) !== null && u !== void 0 ? u : a.defaultError
            } : s.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: (f = c ?? r) !== null && f !== void 0 ? f : a.defaultError
            };
        },
        description: i
    };
}
class Sr {
    get description() {
        return this._def.description;
    }
    _getType(t) {
        return Qa(t.data);
    }
    _getOrReturnCtx(t, r) {
        return r || {
            common: t.parent.common,
            data: t.data,
            parsedType: Qa(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        };
    }
    _processInputParams(t) {
        return {
            status: new Ui(),
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: Qa(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        };
    }
    _parseSync(t) {
        const r = this._parse(t);
        if (Mp(r)) throw new Error("Synchronous parse encountered promise.");
        return r;
    }
    _parseAsync(t) {
        const r = this._parse(t);
        return Promise.resolve(r);
    }
    parse(t, r) {
        const n = this.safeParse(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    safeParse(t, r) {
        var n;
        const i = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Qa(t)
        }, o = this._parseSync({
            data: t,
            path: i.path,
            parent: i
        });
        return yB(i, o);
    }
    "~validate"(t) {
        var r, n;
        const i = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Qa(t)
        };
        if (!this["~standard"].async) try {
            const o = this._parseSync({
                data: t,
                path: [],
                parent: i
            });
            return If(o) ? {
                value: o.value
            } : {
                issues: i.common.issues
            };
        } catch (o) {
            !((n = (r = o == null ? void 0 : o.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0), i.common = {
                issues: [],
                async: !0
            };
        }
        return this._parseAsync({
            data: t,
            path: [],
            parent: i
        }).then((o)=>If(o) ? {
                value: o.value
            } : {
                issues: i.common.issues
            });
    }
    async parseAsync(t, r) {
        const n = await this.safeParseAsync(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    async safeParseAsync(t, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Qa(t)
        }, i = this._parse({
            data: t,
            path: n.path,
            parent: n
        }), o = await (Mp(i) ? i : Promise.resolve(i));
        return yB(n, o);
    }
    refine(t, r) {
        const n = (i)=>typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(i) : r;
        return this._refinement((i, o)=>{
            const s = t(i), a = ()=>o.addIssue({
                    code: ht.custom,
                    ...n(i)
                });
            return typeof Promise < "u" && s instanceof Promise ? s.then((u)=>u ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
        });
    }
    refinement(t, r) {
        return this._refinement((n, i)=>t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
    }
    _refinement(t) {
        return new Fs({
            schema: this,
            typeName: Qt.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        });
    }
    superRefine(t) {
        return this._refinement(t);
    }
    constructor(t){
        this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (r)=>this["~validate"](r)
        };
    }
    optional() {
        return ma.create(this, this._def);
    }
    nullable() {
        return Su.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return $s.create(this);
    }
    promise() {
        return bd.create(this, this._def);
    }
    or(t) {
        return $p.create([
            this,
            t
        ], this._def);
    }
    and(t) {
        return Lp.create(this, t, this._def);
    }
    transform(t) {
        return new Fs({
            ...hr(this._def),
            schema: this,
            typeName: Qt.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        });
    }
    default(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Hp({
            ...hr(this._def),
            innerType: this,
            defaultValue: r,
            typeName: Qt.ZodDefault
        });
    }
    brand() {
        return new a8({
            typeName: Qt.ZodBranded,
            type: this,
            ...hr(this._def)
        });
    }
    catch(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new qp({
            ...hr(this._def),
            innerType: this,
            catchValue: r,
            typeName: Qt.ZodCatch
        });
    }
    describe(t) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: t
        });
    }
    pipe(t) {
        return B0.create(this, t);
    }
    readonly() {
        return Kp.create(this);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const gme = /^c[^\s-]{8,}$/i, yme = /^[0-9a-z]+$/, mme = /^[0-9A-HJKMNP-TV-Z]{26}$/i, bme = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, wme = /^[a-z0-9_-]{21}$/i, vme = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, _me = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Eme = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, xme = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let fE;
const Sme = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ame = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Tme = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, kme = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Ime = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Bme = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, nU = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Ome = new RegExp(`^${nU}$`);
function iU(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function Pme(e) {
    return new RegExp(`^${iU(e)}$`);
}
function oU(e) {
    let t = `${nU}T${iU(e)}`;
    const r = [];
    return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
}
function Nme(e, t) {
    return !!((t === "v4" || !t) && Sme.test(e) || (t === "v6" || !t) && Tme.test(e));
}
function Mme(e, t) {
    if (!vme.test(e)) return !1;
    try {
        const [r] = e.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), i = JSON.parse(atob(n));
        return !(typeof i != "object" || i === null || !i.typ || !i.alg || t && i.alg !== t);
    } catch  {
        return !1;
    }
}
function Rme(e, t) {
    return !!((t === "v4" || !t) && Ame.test(e) || (t === "v6" || !t) && kme.test(e));
}
class Ns extends Sr {
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ot.string) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_type,
                expected: Ot.string,
                received: o.parsedType
            }), er;
        }
        const n = new Ui();
        let i;
        for (const o of this._def.checks)if (o.kind === "min") t.data.length < o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "max") t.data.length > o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), n.dirty());
        else if (o.kind === "length") {
            const s = t.data.length > o.value, a = t.data.length < o.value;
            (s || a) && (i = this._getOrReturnCtx(t, i), s ? Tt(i, {
                code: ht.too_big,
                maximum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }) : a && Tt(i, {
                code: ht.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }), n.dirty());
        } else if (o.kind === "email") Eme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "email",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "emoji") fE || (fE = new RegExp(xme, "u")), fE.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "emoji",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "uuid") bme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "uuid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "nanoid") wme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "nanoid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid") gme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "cuid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "cuid2") yme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "cuid2",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "ulid") mme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "ulid",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty());
        else if (o.kind === "url") try {
            new URL(t.data);
        } catch  {
            i = this._getOrReturnCtx(t, i), Tt(i, {
                validation: "url",
                code: ht.invalid_string,
                message: o.message
            }), n.dirty();
        }
        else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "regex",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: {
                includes: o.value,
                position: o.position
            },
            message: o.message
        }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: {
                startsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: {
                endsWith: o.value
            },
            message: o.message
        }), n.dirty()) : o.kind === "datetime" ? oU(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: "datetime",
            message: o.message
        }), n.dirty()) : o.kind === "date" ? Ome.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: "date",
            message: o.message
        }), n.dirty()) : o.kind === "time" ? Pme(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.invalid_string,
            validation: "time",
            message: o.message
        }), n.dirty()) : o.kind === "duration" ? _me.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "duration",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "ip" ? Nme(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "ip",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "jwt" ? Mme(t.data, o.alg) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "jwt",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "cidr" ? Rme(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "cidr",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "base64" ? Ime.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "base64",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : o.kind === "base64url" ? Bme.test(t.data) || (i = this._getOrReturnCtx(t, i), Tt(i, {
            validation: "base64url",
            code: ht.invalid_string,
            message: o.message
        }), n.dirty()) : zr.assertNever(o);
        return {
            status: n.value,
            value: t.data
        };
    }
    _regex(t, r, n) {
        return this.refinement((i)=>t.test(i), {
            validation: r,
            code: ht.invalid_string,
            ...$t.errToObj(n)
        });
    }
    _addCheck(t) {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...$t.errToObj(t)
        });
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...$t.errToObj(t)
        });
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...$t.errToObj(t)
        });
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...$t.errToObj(t)
        });
    }
    nanoid(t) {
        return this._addCheck({
            kind: "nanoid",
            ...$t.errToObj(t)
        });
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...$t.errToObj(t)
        });
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...$t.errToObj(t)
        });
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...$t.errToObj(t)
        });
    }
    base64(t) {
        return this._addCheck({
            kind: "base64",
            ...$t.errToObj(t)
        });
    }
    base64url(t) {
        return this._addCheck({
            kind: "base64url",
            ...$t.errToObj(t)
        });
    }
    jwt(t) {
        return this._addCheck({
            kind: "jwt",
            ...$t.errToObj(t)
        });
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...$t.errToObj(t)
        });
    }
    cidr(t) {
        return this._addCheck({
            kind: "cidr",
            ...$t.errToObj(t)
        });
    }
    datetime(t) {
        var r, n;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            local: (n = t == null ? void 0 : t.local) !== null && n !== void 0 ? n : !1,
            ...$t.errToObj(t == null ? void 0 : t.message)
        });
    }
    date(t) {
        return this._addCheck({
            kind: "date",
            message: t
        });
    }
    time(t) {
        return typeof t == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: t
        }) : this._addCheck({
            kind: "time",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            ...$t.errToObj(t == null ? void 0 : t.message)
        });
    }
    duration(t) {
        return this._addCheck({
            kind: "duration",
            ...$t.errToObj(t)
        });
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...$t.errToObj(r)
        });
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...$t.errToObj(r == null ? void 0 : r.message)
        });
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...$t.errToObj(r)
        });
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...$t.errToObj(r)
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...$t.errToObj(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...$t.errToObj(r)
        });
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...$t.errToObj(r)
        });
    }
    /**
   * Equivalent to `.min(1)`
   */ nonempty(t) {
        return this.min(1, $t.errToObj(t));
    }
    trim() {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new Ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((t)=>t.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((t)=>t.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((t)=>t.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((t)=>t.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((t)=>t.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((t)=>t.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((t)=>t.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((t)=>t.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((t)=>t.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((t)=>t.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((t)=>t.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((t)=>t.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((t)=>t.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((t)=>t.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((t)=>t.kind === "base64");
    }
    get isBase64url() {
        return !!this._def.checks.find((t)=>t.kind === "base64url");
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
}
Ns.create = (e)=>{
    var t;
    return new Ns({
        checks: [],
        typeName: Qt.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...hr(e)
    });
};
function Cme(e, t) {
    const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, o = parseInt(e.toFixed(i).replace(".", "")), s = parseInt(t.toFixed(i).replace(".", ""));
    return o % s / Math.pow(10, i);
}
class _u extends Sr {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ot.number) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_type,
                expected: Ot.number,
                received: o.parsedType
            }), er;
        }
        let n;
        const i = new Ui();
        for (const o of this._def.checks)o.kind === "int" ? zr.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.invalid_type,
            expected: "integer",
            received: "float",
            message: o.message
        }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_small,
            minimum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_big,
            maximum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? Cme(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.not_finite,
            message: o.message
        }), i.dirty()) : zr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, $t.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, $t.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, $t.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, $t.toString(r));
    }
    setLimit(t, r, n, i) {
        return new _u({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: $t.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new _u({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: $t.toString(t)
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: $t.toString(r)
        });
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: $t.toString(t)
        });
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: $t.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: $t.toString(t)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
    get isInt() {
        return !!this._def.checks.find((t)=>t.kind === "int" || t.kind === "multipleOf" && zr.isInteger(t.value));
    }
    get isFinite() {
        let t = null, r = null;
        for (const n of this._def.checks){
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        }
        return Number.isFinite(r) && Number.isFinite(t);
    }
}
_u.create = (e)=>new _u({
        checks: [],
        typeName: Qt.ZodNumber,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...hr(e)
    });
class Eu extends Sr {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
        if (this._def.coerce) try {
            t.data = BigInt(t.data);
        } catch  {
            return this._getInvalidInput(t);
        }
        if (this._getType(t) !== Ot.bigint) return this._getInvalidInput(t);
        let n;
        const i = new Ui();
        for (const o of this._def.checks)o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_small,
            type: "bigint",
            minimum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.too_big,
            type: "bigint",
            maximum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), Tt(n, {
            code: ht.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : zr.assertNever(o);
        return {
            status: i.value,
            value: t.data
        };
    }
    _getInvalidInput(t) {
        const r = this._getOrReturnCtx(t);
        return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.bigint,
            received: r.parsedType
        }), er;
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, $t.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, $t.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, $t.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, $t.toString(r));
    }
    setLimit(t, r, n, i) {
        return new Eu({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: $t.toString(i)
                }
            ]
        });
    }
    _addCheck(t) {
        return new Eu({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: $t.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: $t.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: $t.toString(r)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
}
Eu.create = (e)=>{
    var t;
    return new Eu({
        checks: [],
        typeName: Qt.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...hr(e)
    });
};
class Rp extends Sr {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ot.boolean) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.boolean,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Rp.create = (e)=>new Rp({
        typeName: Qt.ZodBoolean,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...hr(e)
    });
class Bf extends Sr {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ot.date) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_type,
                expected: Ot.date,
                received: o.parsedType
            }), er;
        }
        if (isNaN(t.data.getTime())) {
            const o = this._getOrReturnCtx(t);
            return Tt(o, {
                code: ht.invalid_date
            }), er;
        }
        const n = new Ui();
        let i;
        for (const o of this._def.checks)o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_small,
            message: o.message,
            inclusive: !0,
            exact: !1,
            minimum: o.value,
            type: "date"
        }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), Tt(i, {
            code: ht.too_big,
            message: o.message,
            inclusive: !0,
            exact: !1,
            maximum: o.value,
            type: "date"
        }), n.dirty()) : zr.assertNever(o);
        return {
            status: n.value,
            value: new Date(t.data.getTime())
        };
    }
    _addCheck(t) {
        return new Bf({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: $t.toString(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: $t.toString(r)
        });
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
}
Bf.create = (e)=>new Bf({
        checks: [],
        coerce: (e == null ? void 0 : e.coerce) || !1,
        typeName: Qt.ZodDate,
        ...hr(e)
    });
class Jm extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.symbol) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.symbol,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Jm.create = (e)=>new Jm({
        typeName: Qt.ZodSymbol,
        ...hr(e)
    });
class Cp extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.undefined) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.undefined,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Cp.create = (e)=>new Cp({
        typeName: Qt.ZodUndefined,
        ...hr(e)
    });
class Up extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.null) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.null,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Up.create = (e)=>new Up({
        typeName: Qt.ZodNull,
        ...hr(e)
    });
class md extends Sr {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(t) {
        return Wi(t.data);
    }
}
md.create = (e)=>new md({
        typeName: Qt.ZodAny,
        ...hr(e)
    });
class bf extends Sr {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(t) {
        return Wi(t.data);
    }
}
bf.create = (e)=>new bf({
        typeName: Qt.ZodUnknown,
        ...hr(e)
    });
class dc extends Sr {
    _parse(t) {
        const r = this._getOrReturnCtx(t);
        return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.never,
            received: r.parsedType
        }), er;
    }
}
dc.create = (e)=>new dc({
        typeName: Qt.ZodNever,
        ...hr(e)
    });
class Qm extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.undefined) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.void,
                received: n.parsedType
            }), er;
        }
        return Wi(t.data);
    }
}
Qm.create = (e)=>new Qm({
        typeName: Qt.ZodVoid,
        ...hr(e)
    });
class $s extends Sr {
    _parse(t) {
        const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
        if (r.parsedType !== Ot.array) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.array,
            received: r.parsedType
        }), er;
        if (i.exactLength !== null) {
            const s = r.data.length > i.exactLength.value, a = r.data.length < i.exactLength.value;
            (s || a) && (Tt(r, {
                code: s ? ht.too_big : ht.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: s ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), n.dirty());
        }
        if (i.minLength !== null && r.data.length < i.minLength.value && (Tt(r, {
            code: ht.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (Tt(r, {
            code: ht.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([
            ...r.data
        ].map((s, a)=>i.type._parseAsync(new _a(r, s, r.path, a)))).then((s)=>Ui.mergeArray(n, s));
        const o = [
            ...r.data
        ].map((s, a)=>i.type._parseSync(new _a(r, s, r.path, a)));
        return Ui.mergeArray(n, o);
    }
    get element() {
        return this._def.type;
    }
    min(t, r) {
        return new $s({
            ...this._def,
            minLength: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    max(t, r) {
        return new $s({
            ...this._def,
            maxLength: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    length(t, r) {
        return new $s({
            ...this._def,
            exactLength: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    nonempty(t) {
        return this.min(1, t);
    }
}
$s.create = (e, t)=>new $s({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: Qt.ZodArray,
        ...hr(t)
    });
function kl(e) {
    if (e instanceof _n) {
        const t = {};
        for(const r in e.shape){
            const n = e.shape[r];
            t[r] = ma.create(kl(n));
        }
        return new _n({
            ...e._def,
            shape: ()=>t
        });
    } else return e instanceof $s ? new $s({
        ...e._def,
        type: kl(e.element)
    }) : e instanceof ma ? ma.create(kl(e.unwrap())) : e instanceof Su ? Su.create(kl(e.unwrap())) : e instanceof Ea ? Ea.create(e.items.map((t)=>kl(t))) : e;
}
class _n extends Sr {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(), r = zr.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        };
    }
    _parse(t) {
        if (this._getType(t) !== Ot.object) {
            const f = this._getOrReturnCtx(t);
            return Tt(f, {
                code: ht.invalid_type,
                expected: Ot.object,
                received: f.parsedType
            }), er;
        }
        const { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: s } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof dc && this._def.unknownKeys === "strip")) for(const f in i.data)s.includes(f) || a.push(f);
        const u = [];
        for (const f of s){
            const c = o[f], l = i.data[f];
            u.push({
                key: {
                    status: "valid",
                    value: f
                },
                value: c._parse(new _a(i, l, i.path, f)),
                alwaysSet: f in i.data
            });
        }
        if (this._def.catchall instanceof dc) {
            const f = this._def.unknownKeys;
            if (f === "passthrough") for (const c of a)u.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: {
                    status: "valid",
                    value: i.data[c]
                }
            });
            else if (f === "strict") a.length > 0 && (Tt(i, {
                code: ht.unrecognized_keys,
                keys: a
            }), n.dirty());
            else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const f = this._def.catchall;
            for (const c of a){
                const l = i.data[c];
                u.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: f._parse(new _a(i, l, i.path, c)),
                    alwaysSet: c in i.data
                });
            }
        }
        return i.common.async ? Promise.resolve().then(async ()=>{
            const f = [];
            for (const c of u){
                const l = await c.key, p = await c.value;
                f.push({
                    key: l,
                    value: p,
                    alwaysSet: c.alwaysSet
                });
            }
            return f;
        }).then((f)=>Ui.mergeObjectSync(n, f)) : Ui.mergeObjectSync(n, u);
    }
    get shape() {
        return this._def.shape();
    }
    strict(t) {
        return $t.errToObj, new _n({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n)=>{
                    var i, o, s, a;
                    const u = (s = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (a = $t.errToObj(t).message) !== null && a !== void 0 ? a : u
                    } : {
                        message: u
                    };
                }
            } : {}
        });
    }
    strip() {
        return new _n({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new _n({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
        return new _n({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(t) {
        return new _n({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
            typeName: Qt.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
        return this.augment({
            [t]: r
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
        return new _n({
            ...this._def,
            catchall: t
        });
    }
    pick(t) {
        const r = {};
        return zr.objectKeys(t).forEach((n)=>{
            t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    omit(t) {
        const r = {};
        return zr.objectKeys(this.shape).forEach((n)=>{
            t[n] || (r[n] = this.shape[n]);
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return kl(this);
    }
    partial(t) {
        const r = {};
        return zr.objectKeys(this.shape).forEach((n)=>{
            const i = this.shape[n];
            t && !t[n] ? r[n] = i : r[n] = i.optional();
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    required(t) {
        const r = {};
        return zr.objectKeys(this.shape).forEach((n)=>{
            if (t && !t[n]) r[n] = this.shape[n];
            else {
                let o = this.shape[n];
                for(; o instanceof ma;)o = o._def.innerType;
                r[n] = o;
            }
        }), new _n({
            ...this._def,
            shape: ()=>r
        });
    }
    keyof() {
        return sU(zr.objectKeys(this.shape));
    }
}
_n.create = (e, t)=>new _n({
        shape: ()=>e,
        unknownKeys: "strip",
        catchall: dc.create(),
        typeName: Qt.ZodObject,
        ...hr(t)
    });
_n.strictCreate = (e, t)=>new _n({
        shape: ()=>e,
        unknownKeys: "strict",
        catchall: dc.create(),
        typeName: Qt.ZodObject,
        ...hr(t)
    });
_n.lazycreate = (e, t)=>new _n({
        shape: e,
        unknownKeys: "strip",
        catchall: dc.create(),
        typeName: Qt.ZodObject,
        ...hr(t)
    });
class $p extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = this._def.options;
        function i(o) {
            for (const a of o)if (a.result.status === "valid") return a.result;
            for (const a of o)if (a.result.status === "dirty") return r.common.issues.push(...a.ctx.common.issues), a.result;
            const s = o.map((a)=>new Co(a.ctx.common.issues));
            return Tt(r, {
                code: ht.invalid_union,
                unionErrors: s
            }), er;
        }
        if (r.common.async) return Promise.all(n.map(async (o)=>{
            const s = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await o._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: s
                }),
                ctx: s
            };
        })).then(i);
        {
            let o;
            const s = [];
            for (const u of n){
                const f = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }, c = u._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: f
                });
                if (c.status === "valid") return c;
                c.status === "dirty" && !o && (o = {
                    result: c,
                    ctx: f
                }), f.common.issues.length && s.push(f.common.issues);
            }
            if (o) return r.common.issues.push(...o.ctx.common.issues), o.result;
            const a = s.map((u)=>new Co(u));
            return Tt(r, {
                code: ht.invalid_union,
                unionErrors: a
            }), er;
        }
    }
    get options() {
        return this._def.options;
    }
}
$p.create = (e, t)=>new $p({
        options: e,
        typeName: Qt.ZodUnion,
        ...hr(t)
    });
const Ga = (e)=>e instanceof Fp ? Ga(e.schema) : e instanceof Fs ? Ga(e.innerType()) : e instanceof zp ? [
        e.value
    ] : e instanceof xu ? e.options : e instanceof jp ? zr.objectValues(e.enum) : e instanceof Hp ? Ga(e._def.innerType) : e instanceof Cp ? [
        void 0
    ] : e instanceof Up ? [
        null
    ] : e instanceof ma ? [
        void 0,
        ...Ga(e.unwrap())
    ] : e instanceof Su ? [
        null,
        ...Ga(e.unwrap())
    ] : e instanceof a8 || e instanceof Kp ? Ga(e.unwrap()) : e instanceof qp ? Ga(e._def.innerType) : [];
class S1 extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Ot.object) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.object,
            received: r.parsedType
        }), er;
        const n = this.discriminator, i = r.data[n], o = this.optionsMap.get(i);
        return o ? r.common.async ? o._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : o._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (Tt(r, {
            code: ht.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                n
            ]
        }), er);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(t, r, n) {
        const i = /* @__PURE__ */ new Map();
        for (const o of r){
            const s = Ga(o.shape[t]);
            if (!s.length) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const a of s){
                if (i.has(a)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
                i.set(a, o);
            }
        }
        return new S1({
            typeName: Qt.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: i,
            ...hr(n)
        });
    }
}
function Wx(e, t) {
    const r = Qa(e), n = Qa(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (r === Ot.object && n === Ot.object) {
        const i = zr.objectKeys(t), o = zr.objectKeys(e).filter((a)=>i.indexOf(a) !== -1), s = {
            ...e,
            ...t
        };
        for (const a of o){
            const u = Wx(e[a], t[a]);
            if (!u.valid) return {
                valid: !1
            };
            s[a] = u.data;
        }
        return {
            valid: !0,
            data: s
        };
    } else if (r === Ot.array && n === Ot.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i = [];
        for(let o = 0; o < e.length; o++){
            const s = e[o], a = t[o], u = Wx(s, a);
            if (!u.valid) return {
                valid: !1
            };
            i.push(u.data);
        }
        return {
            valid: !0,
            data: i
        };
    } else return r === Ot.date && n === Ot.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    };
}
class Lp extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = (o, s)=>{
            if (qx(o) || qx(s)) return er;
            const a = Wx(o.value, s.value);
            return a.valid ? ((Kx(o) || Kx(s)) && r.dirty(), {
                status: r.value,
                value: a.data
            }) : (Tt(n, {
                code: ht.invalid_intersection_types
            }), er);
        };
        return n.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }),
            this._def.right._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            })
        ]).then(([o, s])=>i(o, s)) : i(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }));
    }
}
Lp.create = (e, t, r)=>new Lp({
        left: e,
        right: t,
        typeName: Qt.ZodIntersection,
        ...hr(r)
    });
class Ea extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.array) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.array,
            received: n.parsedType
        }), er;
        if (n.data.length < this._def.items.length) return Tt(n, {
            code: ht.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), er;
        !this._def.rest && n.data.length > this._def.items.length && (Tt(n, {
            code: ht.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const o = [
            ...n.data
        ].map((s, a)=>{
            const u = this._def.items[a] || this._def.rest;
            return u ? u._parse(new _a(n, s, n.path, a)) : null;
        }).filter((s)=>!!s);
        return n.common.async ? Promise.all(o).then((s)=>Ui.mergeArray(r, s)) : Ui.mergeArray(r, o);
    }
    get items() {
        return this._def.items;
    }
    rest(t) {
        return new Ea({
            ...this._def,
            rest: t
        });
    }
}
Ea.create = (e, t)=>{
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Ea({
        items: e,
        typeName: Qt.ZodTuple,
        rest: null,
        ...hr(t)
    });
};
class Dp extends Sr {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.object) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.object,
            received: n.parsedType
        }), er;
        const i = [], o = this._def.keyType, s = this._def.valueType;
        for(const a in n.data)i.push({
            key: o._parse(new _a(n, a, n.path, a)),
            value: s._parse(new _a(n, n.data[a], n.path, a)),
            alwaysSet: a in n.data
        });
        return n.common.async ? Ui.mergeObjectAsync(r, i) : Ui.mergeObjectSync(r, i);
    }
    get element() {
        return this._def.valueType;
    }
    static create(t, r, n) {
        return r instanceof Sr ? new Dp({
            keyType: t,
            valueType: r,
            typeName: Qt.ZodRecord,
            ...hr(n)
        }) : new Dp({
            keyType: Ns.create(),
            valueType: t,
            typeName: Qt.ZodRecord,
            ...hr(r)
        });
    }
}
class eb extends Sr {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.map) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.map,
            received: n.parsedType
        }), er;
        const i = this._def.keyType, o = this._def.valueType, s = [
            ...n.data.entries()
        ].map(([a, u], f)=>({
                key: i._parse(new _a(n, a, n.path, [
                    f,
                    "key"
                ])),
                value: o._parse(new _a(n, u, n.path, [
                    f,
                    "value"
                ]))
            }));
        if (n.common.async) {
            const a = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const u of s){
                    const f = await u.key, c = await u.value;
                    if (f.status === "aborted" || c.status === "aborted") return er;
                    (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
                }
                return {
                    status: r.value,
                    value: a
                };
            });
        } else {
            const a = /* @__PURE__ */ new Map();
            for (const u of s){
                const f = u.key, c = u.value;
                if (f.status === "aborted" || c.status === "aborted") return er;
                (f.status === "dirty" || c.status === "dirty") && r.dirty(), a.set(f.value, c.value);
            }
            return {
                status: r.value,
                value: a
            };
        }
    }
}
eb.create = (e, t, r)=>new eb({
        valueType: t,
        keyType: e,
        typeName: Qt.ZodMap,
        ...hr(r)
    });
class Of extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Ot.set) return Tt(n, {
            code: ht.invalid_type,
            expected: Ot.set,
            received: n.parsedType
        }), er;
        const i = this._def;
        i.minSize !== null && n.data.size < i.minSize.value && (Tt(n, {
            code: ht.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (Tt(n, {
            code: ht.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), r.dirty());
        const o = this._def.valueType;
        function s(u) {
            const f = /* @__PURE__ */ new Set();
            for (const c of u){
                if (c.status === "aborted") return er;
                c.status === "dirty" && r.dirty(), f.add(c.value);
            }
            return {
                status: r.value,
                value: f
            };
        }
        const a = [
            ...n.data.values()
        ].map((u, f)=>o._parse(new _a(n, u, n.path, f)));
        return n.common.async ? Promise.all(a).then((u)=>s(u)) : s(a);
    }
    min(t, r) {
        return new Of({
            ...this._def,
            minSize: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    max(t, r) {
        return new Of({
            ...this._def,
            maxSize: {
                value: t,
                message: $t.toString(r)
            }
        });
    }
    size(t, r) {
        return this.min(t, r).max(t, r);
    }
    nonempty(t) {
        return this.min(1, t);
    }
}
Of.create = (e, t)=>new Of({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: Qt.ZodSet,
        ...hr(t)
    });
class Xl extends Sr {
    constructor(){
        super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Ot.function) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.function,
            received: r.parsedType
        }), er;
        function n(a, u) {
            return Ym({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Zm(),
                    yd
                ].filter((f)=>!!f),
                issueData: {
                    code: ht.invalid_arguments,
                    argumentsError: u
                }
            });
        }
        function i(a, u) {
            return Ym({
                data: a,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    Zm(),
                    yd
                ].filter((f)=>!!f),
                issueData: {
                    code: ht.invalid_return_type,
                    returnTypeError: u
                }
            });
        }
        const o = {
            errorMap: r.common.contextualErrorMap
        }, s = r.data;
        if (this._def.returns instanceof bd) {
            const a = this;
            return Wi(async function(...u) {
                const f = new Co([]), c = await a._def.args.parseAsync(u, o).catch((y)=>{
                    throw f.addIssue(n(u, y)), f;
                }), l = await Reflect.apply(s, this, c);
                return await a._def.returns._def.type.parseAsync(l, o).catch((y)=>{
                    throw f.addIssue(i(l, y)), f;
                });
            });
        } else {
            const a = this;
            return Wi(function(...u) {
                const f = a._def.args.safeParse(u, o);
                if (!f.success) throw new Co([
                    n(u, f.error)
                ]);
                const c = Reflect.apply(s, this, f.data), l = a._def.returns.safeParse(c, o);
                if (!l.success) throw new Co([
                    i(c, l.error)
                ]);
                return l.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...t) {
        return new Xl({
            ...this._def,
            args: Ea.create(t).rest(bf.create())
        });
    }
    returns(t) {
        return new Xl({
            ...this._def,
            returns: t
        });
    }
    implement(t) {
        return this.parse(t);
    }
    strictImplement(t) {
        return this.parse(t);
    }
    static create(t, r, n) {
        return new Xl({
            args: t || Ea.create([]).rest(bf.create()),
            returns: r || bf.create(),
            typeName: Qt.ZodFunction,
            ...hr(n)
        });
    }
}
class Fp extends Sr {
    get schema() {
        return this._def.getter();
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        });
    }
}
Fp.create = (e, t)=>new Fp({
        getter: e,
        typeName: Qt.ZodLazy,
        ...hr(t)
    });
class zp extends Sr {
    _parse(t) {
        if (t.data !== this._def.value) {
            const r = this._getOrReturnCtx(t);
            return Tt(r, {
                received: r.data,
                code: ht.invalid_literal,
                expected: this._def.value
            }), er;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
    get value() {
        return this._def.value;
    }
}
zp.create = (e, t)=>new zp({
        value: e,
        typeName: Qt.ZodLiteral,
        ...hr(t)
    });
function sU(e, t) {
    return new xu({
        values: e,
        typeName: Qt.ZodEnum,
        ...hr(t)
    });
}
class xu extends Sr {
    constructor(){
        super(...arguments), Bh.set(this, void 0);
    }
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Tt(r, {
                expected: zr.joinValues(n),
                received: r.parsedType,
                code: ht.invalid_type
            }), er;
        }
        if (Xm(this, Bh) || rU(this, Bh, new Set(this._def.values)), !Xm(this, Bh).has(t.data)) {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Tt(r, {
                received: r.data,
                code: ht.invalid_enum_value,
                options: n
            }), er;
        }
        return Wi(t.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    extract(t, r = this._def) {
        return xu.create(t, {
            ...this._def,
            ...r
        });
    }
    exclude(t, r = this._def) {
        return xu.create(this.options.filter((n)=>!t.includes(n)), {
            ...this._def,
            ...r
        });
    }
}
Bh = /* @__PURE__ */ new WeakMap();
xu.create = sU;
class jp extends Sr {
    constructor(){
        super(...arguments), Oh.set(this, void 0);
    }
    _parse(t) {
        const r = zr.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
        if (n.parsedType !== Ot.string && n.parsedType !== Ot.number) {
            const i = zr.objectValues(r);
            return Tt(n, {
                expected: zr.joinValues(i),
                received: n.parsedType,
                code: ht.invalid_type
            }), er;
        }
        if (Xm(this, Oh) || rU(this, Oh, new Set(zr.getValidEnumValues(this._def.values))), !Xm(this, Oh).has(t.data)) {
            const i = zr.objectValues(r);
            return Tt(n, {
                received: n.data,
                code: ht.invalid_enum_value,
                options: i
            }), er;
        }
        return Wi(t.data);
    }
    get enum() {
        return this._def.values;
    }
}
Oh = /* @__PURE__ */ new WeakMap();
jp.create = (e, t)=>new jp({
        values: e,
        typeName: Qt.ZodNativeEnum,
        ...hr(t)
    });
class bd extends Sr {
    unwrap() {
        return this._def.type;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Ot.promise && r.common.async === !1) return Tt(r, {
            code: ht.invalid_type,
            expected: Ot.promise,
            received: r.parsedType
        }), er;
        const n = r.parsedType === Ot.promise ? r.data : Promise.resolve(r.data);
        return Wi(n.then((i)=>this._def.type.parseAsync(i, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })));
    }
}
bd.create = (e, t)=>new bd({
        type: e,
        typeName: Qt.ZodPromise,
        ...hr(t)
    });
class Fs extends Sr {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === Qt.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null, o = {
            addIssue: (s)=>{
                Tt(n, s), s.fatal ? r.abort() : r.dirty();
            },
            get path () {
                return n.path;
            }
        };
        if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
            const s = i.transform(n.data, o);
            if (n.common.async) return Promise.resolve(s).then(async (a)=>{
                if (r.value === "aborted") return er;
                const u = await this._def.schema._parseAsync({
                    data: a,
                    path: n.path,
                    parent: n
                });
                return u.status === "aborted" ? er : u.status === "dirty" || r.value === "dirty" ? Dl(u.value) : u;
            });
            {
                if (r.value === "aborted") return er;
                const a = this._def.schema._parseSync({
                    data: s,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? er : a.status === "dirty" || r.value === "dirty" ? Dl(a.value) : a;
            }
        }
        if (i.type === "refinement") {
            const s = (a)=>{
                const u = i.refinement(a, o);
                if (n.common.async) return Promise.resolve(u);
                if (u instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a;
            };
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? er : (a.status === "dirty" && r.dirty(), s(a.value), {
                    status: r.value,
                    value: a.value
                });
            } else return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then((a)=>a.status === "aborted" ? er : (a.status === "dirty" && r.dirty(), s(a.value).then(()=>({
                        status: r.value,
                        value: a.value
                    }))));
        }
        if (i.type === "transform") if (n.common.async === !1) {
            const s = this._def.schema._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            if (!If(s)) return s;
            const a = i.transform(s.value, o);
            if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: r.value,
                value: a
            };
        } else return this._def.schema._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }).then((s)=>If(s) ? Promise.resolve(i.transform(s.value, o)).then((a)=>({
                    status: r.value,
                    value: a
                })) : s);
        zr.assertNever(i);
    }
}
Fs.create = (e, t, r)=>new Fs({
        schema: e,
        typeName: Qt.ZodEffects,
        effect: t,
        ...hr(r)
    });
Fs.createWithPreprocess = (e, t, r)=>new Fs({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: Qt.ZodEffects,
        ...hr(r)
    });
class ma extends Sr {
    _parse(t) {
        return this._getType(t) === Ot.undefined ? Wi(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ma.create = (e, t)=>new ma({
        innerType: e,
        typeName: Qt.ZodOptional,
        ...hr(t)
    });
class Su extends Sr {
    _parse(t) {
        return this._getType(t) === Ot.null ? Wi(null) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Su.create = (e, t)=>new Su({
        innerType: e,
        typeName: Qt.ZodNullable,
        ...hr(t)
    });
class Hp extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        let n = r.data;
        return r.parsedType === Ot.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
Hp.create = (e, t)=>new Hp({
        innerType: e,
        typeName: Qt.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : ()=>t.default,
        ...hr(t)
    });
class qp extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }, i = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return Mp(i) ? i.then((o)=>({
                status: "valid",
                value: o.status === "valid" ? o.value : this._def.catchValue({
                    get error () {
                        return new Co(n.common.issues);
                    },
                    input: n.data
                })
            })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error () {
                    return new Co(n.common.issues);
                },
                input: n.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
qp.create = (e, t)=>new qp({
        innerType: e,
        typeName: Qt.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : ()=>t.catch,
        ...hr(t)
    });
class tb extends Sr {
    _parse(t) {
        if (this._getType(t) !== Ot.nan) {
            const n = this._getOrReturnCtx(t);
            return Tt(n, {
                code: ht.invalid_type,
                expected: Ot.nan,
                received: n.parsedType
            }), er;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
}
tb.create = (e)=>new tb({
        typeName: Qt.ZodNaN,
        ...hr(e)
    });
const Ume = Symbol("zod_brand");
class a8 extends Sr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class B0 extends Sr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.common.async) return (async ()=>{
            const o = await this._def.in._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return o.status === "aborted" ? er : o.status === "dirty" ? (r.dirty(), Dl(o.value)) : this._def.out._parseAsync({
                data: o.value,
                path: n.path,
                parent: n
            });
        })();
        {
            const i = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i.status === "aborted" ? er : i.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: n.path,
                parent: n
            });
        }
    }
    static create(t, r) {
        return new B0({
            in: t,
            out: r,
            typeName: Qt.ZodPipeline
        });
    }
}
class Kp extends Sr {
    _parse(t) {
        const r = this._def.innerType._parse(t), n = (i)=>(If(i) && (i.value = Object.freeze(i.value)), i);
        return Mp(r) ? r.then((i)=>n(i)) : n(r);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Kp.create = (e, t)=>new Kp({
        innerType: e,
        typeName: Qt.ZodReadonly,
        ...hr(t)
    });
function mB(e, t) {
    const r = typeof e == "function" ? e(t) : typeof e == "string" ? {
        message: e
    } : e;
    return typeof r == "string" ? {
        message: r
    } : r;
}
function aU(e, t = {}, r) {
    return e ? md.create().superRefine((n, i)=>{
        var o, s;
        const a = e(n);
        if (a instanceof Promise) return a.then((u)=>{
            var f, c;
            if (!u) {
                const l = mB(t, n), p = (c = (f = l.fatal) !== null && f !== void 0 ? f : r) !== null && c !== void 0 ? c : !0;
                i.addIssue({
                    code: "custom",
                    ...l,
                    fatal: p
                });
            }
        });
        if (!a) {
            const u = mB(t, n), f = (s = (o = u.fatal) !== null && o !== void 0 ? o : r) !== null && s !== void 0 ? s : !0;
            i.addIssue({
                code: "custom",
                ...u,
                fatal: f
            });
        }
    }) : md.create();
}
const $me = {
    object: _n.lazycreate
};
var Qt;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Qt || (Qt = {}));
const Lme = (e, t = {
    message: `Input not instance of ${e.name}`
})=>aU((r)=>r instanceof e, t), cU = Ns.create, uU = _u.create, Dme = tb.create, Fme = Eu.create, fU = Rp.create, zme = Bf.create, jme = Jm.create, Hme = Cp.create, qme = Up.create, Kme = md.create, Wme = bf.create, Vme = dc.create, Gme = Qm.create, Zme = $s.create, Yme = _n.create, Xme = _n.strictCreate, Jme = $p.create, Qme = S1.create, ebe = Lp.create, tbe = Ea.create, rbe = Dp.create, nbe = eb.create, ibe = Of.create, obe = Xl.create, sbe = Fp.create, abe = zp.create, cbe = xu.create, ube = jp.create, fbe = bd.create, bB = Fs.create, lbe = ma.create, dbe = Su.create, hbe = Fs.createWithPreprocess, pbe = B0.create, gbe = ()=>cU().optional(), ybe = ()=>uU().optional(), mbe = ()=>fU().optional(), bbe = {
    string: (e)=>Ns.create({
            ...e,
            coerce: !0
        }),
    number: (e)=>_u.create({
            ...e,
            coerce: !0
        }),
    boolean: (e)=>Rp.create({
            ...e,
            coerce: !0
        }),
    bigint: (e)=>Eu.create({
            ...e,
            coerce: !0
        }),
    date: (e)=>Bf.create({
            ...e,
            coerce: !0
        })
}, wbe = er;
var Te = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: yd,
    setErrorMap: hme,
    getErrorMap: Zm,
    makeIssue: Ym,
    EMPTY_PATH: pme,
    addIssueToContext: Tt,
    ParseStatus: Ui,
    INVALID: er,
    DIRTY: Dl,
    OK: Wi,
    isAborted: qx,
    isDirty: Kx,
    isValid: If,
    isAsync: Mp,
    get util () {
        return zr;
    },
    get objectUtil () {
        return Hx;
    },
    ZodParsedType: Ot,
    getParsedType: Qa,
    ZodType: Sr,
    datetimeRegex: oU,
    ZodString: Ns,
    ZodNumber: _u,
    ZodBigInt: Eu,
    ZodBoolean: Rp,
    ZodDate: Bf,
    ZodSymbol: Jm,
    ZodUndefined: Cp,
    ZodNull: Up,
    ZodAny: md,
    ZodUnknown: bf,
    ZodNever: dc,
    ZodVoid: Qm,
    ZodArray: $s,
    ZodObject: _n,
    ZodUnion: $p,
    ZodDiscriminatedUnion: S1,
    ZodIntersection: Lp,
    ZodTuple: Ea,
    ZodRecord: Dp,
    ZodMap: eb,
    ZodSet: Of,
    ZodFunction: Xl,
    ZodLazy: Fp,
    ZodLiteral: zp,
    ZodEnum: xu,
    ZodNativeEnum: jp,
    ZodPromise: bd,
    ZodEffects: Fs,
    ZodTransformer: Fs,
    ZodOptional: ma,
    ZodNullable: Su,
    ZodDefault: Hp,
    ZodCatch: qp,
    ZodNaN: tb,
    BRAND: Ume,
    ZodBranded: a8,
    ZodPipeline: B0,
    ZodReadonly: Kp,
    custom: aU,
    Schema: Sr,
    ZodSchema: Sr,
    late: $me,
    get ZodFirstPartyTypeKind () {
        return Qt;
    },
    coerce: bbe,
    any: Kme,
    array: Zme,
    bigint: Fme,
    boolean: fU,
    date: zme,
    discriminatedUnion: Qme,
    effect: bB,
    enum: cbe,
    function: obe,
    instanceof: Lme,
    intersection: ebe,
    lazy: sbe,
    literal: abe,
    map: nbe,
    nan: Dme,
    nativeEnum: ube,
    never: Vme,
    null: qme,
    nullable: dbe,
    number: uU,
    object: Yme,
    oboolean: mbe,
    onumber: ybe,
    optional: lbe,
    ostring: gbe,
    pipeline: pbe,
    preprocess: hbe,
    promise: fbe,
    record: rbe,
    set: ibe,
    strictObject: Xme,
    string: cU,
    symbol: jme,
    transformer: bB,
    tuple: tbe,
    undefined: Hme,
    union: Jme,
    unknown: Wme,
    void: Gme,
    NEVER: wbe,
    ZodIssueCode: ht,
    quotelessJson: dme,
    ZodError: Co
}), vbe = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, lE = Math.ceil, rs = Math.floor, to = "[BigNumber Error] ", wB = to + "Number primitive has more than 15 significant digits: ", Ss = 1e14, fr = 14, dE = 9007199254740991, hE = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8,
    1e9,
    1e10,
    1e11,
    1e12,
    1e13
], Xc = 1e7, ri = 1e9;
function lU(e) {
    var t, r, n, i = U.prototype = {
        constructor: U,
        toString: null,
        valueOf: null
    }, o = new U(1), s = 20, a = 4, u = -7, f = 21, c = -1e7, l = 1e7, p = !1, y = 1, _ = 0, A = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
    }, O = "0123456789abcdefghijklmnopqrstuvwxyz", N = !0;
    function U(G, R) {
        var X, $, S, w, g, m, E, T, I = this;
        if (!(I instanceof U)) return new U(G, R);
        if (R == null) {
            if (G && G._isBigNumber === !0) {
                I.s = G.s, !G.c || G.e > l ? I.c = I.e = null : G.e < c ? I.c = [
                    I.e = 0
                ] : (I.e = G.e, I.c = G.c.slice());
                return;
            }
            if ((m = typeof G == "number") && G * 0 == 0) {
                if (I.s = 1 / G < 0 ? (G = -G, -1) : 1, G === ~~G) {
                    for(w = 0, g = G; g >= 10; g /= 10, w++);
                    w > l ? I.c = I.e = null : (I.e = w, I.c = [
                        G
                    ]);
                    return;
                }
                T = String(G);
            } else {
                if (!vbe.test(T = String(G))) return n(I, T, m);
                I.s = T.charCodeAt(0) == 45 ? (T = T.slice(1), -1) : 1;
            }
            (w = T.indexOf(".")) > -1 && (T = T.replace(".", "")), (g = T.search(/e/i)) > 0 ? (w < 0 && (w = g), w += +T.slice(g + 1), T = T.substring(0, g)) : w < 0 && (w = T.length);
        } else {
            if (vn(R, 2, O.length, "Base"), R == 10 && N) return I = new U(G), re(I, s + I.e + 1, a);
            if (T = String(G), m = typeof G == "number") {
                if (G * 0 != 0) return n(I, T, m, R);
                if (I.s = 1 / G < 0 ? (T = T.slice(1), -1) : 1, U.DEBUG && T.replace(/^0\.0*|\./, "").length > 15) throw Error(wB + G);
            } else I.s = T.charCodeAt(0) === 45 ? (T = T.slice(1), -1) : 1;
            for(X = O.slice(0, R), w = g = 0, E = T.length; g < E; g++)if (X.indexOf($ = T.charAt(g)) < 0) {
                if ($ == ".") {
                    if (g > w) {
                        w = E;
                        continue;
                    }
                } else if (!S && (T == T.toUpperCase() && (T = T.toLowerCase()) || T == T.toLowerCase() && (T = T.toUpperCase()))) {
                    S = !0, g = -1, w = 0;
                    continue;
                }
                return n(I, String(G), m, R);
            }
            m = !1, T = r(T, R, 10, I.s), (w = T.indexOf(".")) > -1 ? T = T.replace(".", "") : w = T.length;
        }
        for(g = 0; T.charCodeAt(g) === 48; g++);
        for(E = T.length; T.charCodeAt(--E) === 48;);
        if (T = T.slice(g, ++E)) {
            if (E -= g, m && U.DEBUG && E > 15 && (G > dE || G !== rs(G))) throw Error(wB + I.s * G);
            if ((w = w - g - 1) > l) I.c = I.e = null;
            else if (w < c) I.c = [
                I.e = 0
            ];
            else {
                if (I.e = w, I.c = [], g = (w + 1) % fr, w < 0 && (g += fr), g < E) {
                    for(g && I.c.push(+T.slice(0, g)), E -= fr; g < E;)I.c.push(+T.slice(g, g += fr));
                    g = fr - (T = T.slice(g)).length;
                } else g -= E;
                for(; g--; T += "0");
                I.c.push(+T);
            }
        } else I.c = [
            I.e = 0
        ];
    }
    U.clone = lU, U.ROUND_UP = 0, U.ROUND_DOWN = 1, U.ROUND_CEIL = 2, U.ROUND_FLOOR = 3, U.ROUND_HALF_UP = 4, U.ROUND_HALF_DOWN = 5, U.ROUND_HALF_EVEN = 6, U.ROUND_HALF_CEIL = 7, U.ROUND_HALF_FLOOR = 8, U.EUCLID = 9, U.config = U.set = function(G) {
        var R, X;
        if (G != null) if (typeof G == "object") {
            if (G.hasOwnProperty(R = "DECIMAL_PLACES") && (X = G[R], vn(X, 0, ri, R), s = X), G.hasOwnProperty(R = "ROUNDING_MODE") && (X = G[R], vn(X, 0, 8, R), a = X), G.hasOwnProperty(R = "EXPONENTIAL_AT") && (X = G[R], X && X.pop ? (vn(X[0], -ri, 0, R), vn(X[1], 0, ri, R), u = X[0], f = X[1]) : (vn(X, -ri, ri, R), u = -(f = X < 0 ? -X : X))), G.hasOwnProperty(R = "RANGE")) if (X = G[R], X && X.pop) vn(X[0], -ri, -1, R), vn(X[1], 1, ri, R), c = X[0], l = X[1];
            else if (vn(X, -ri, ri, R), X) c = -(l = X < 0 ? -X : X);
            else throw Error(to + R + " cannot be zero: " + X);
            if (G.hasOwnProperty(R = "CRYPTO")) if (X = G[R], X === !!X) if (X) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) p = X;
            else throw p = !X, Error(to + "crypto unavailable");
            else p = X;
            else throw Error(to + R + " not true or false: " + X);
            if (G.hasOwnProperty(R = "MODULO_MODE") && (X = G[R], vn(X, 0, 9, R), y = X), G.hasOwnProperty(R = "POW_PRECISION") && (X = G[R], vn(X, 0, ri, R), _ = X), G.hasOwnProperty(R = "FORMAT")) if (X = G[R], typeof X == "object") A = X;
            else throw Error(to + R + " not an object: " + X);
            if (G.hasOwnProperty(R = "ALPHABET")) if (X = G[R], typeof X == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(X)) N = X.slice(0, 10) == "0123456789", O = X;
            else throw Error(to + R + " invalid: " + X);
        } else throw Error(to + "Object expected: " + G);
        return {
            DECIMAL_PLACES: s,
            ROUNDING_MODE: a,
            EXPONENTIAL_AT: [
                u,
                f
            ],
            RANGE: [
                c,
                l
            ],
            CRYPTO: p,
            MODULO_MODE: y,
            POW_PRECISION: _,
            FORMAT: A,
            ALPHABET: O
        };
    }, U.isBigNumber = function(G) {
        if (!G || G._isBigNumber !== !0) return !1;
        if (!U.DEBUG) return !0;
        var R, X, $ = G.c, S = G.e, w = G.s;
        e: if (({}).toString.call($) == "[object Array]") {
            if ((w === 1 || w === -1) && S >= -ri && S <= ri && S === rs(S)) {
                if ($[0] === 0) {
                    if (S === 0 && $.length === 1) return !0;
                    break e;
                }
                if (R = (S + 1) % fr, R < 1 && (R += fr), String($[0]).length == R) {
                    for(R = 0; R < $.length; R++)if (X = $[R], X < 0 || X >= Ss || X !== rs(X)) break e;
                    if (X !== 0) return !0;
                }
            }
        } else if ($ === null && S === null && (w === null || w === 1 || w === -1)) return !0;
        throw Error(to + "Invalid BigNumber: " + G);
    }, U.maximum = U.max = function() {
        return H(arguments, -1);
    }, U.minimum = U.min = function() {
        return H(arguments, 1);
    }, U.random = function() {
        var G = 9007199254740992, R = Math.random() * G & 2097151 ? function() {
            return rs(Math.random() * G);
        } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(X) {
            var $, S, w, g, m, E = 0, T = [], I = new U(o);
            if (X == null ? X = s : vn(X, 0, ri), g = lE(X / fr), p) if (crypto.getRandomValues) {
                for($ = crypto.getRandomValues(new Uint32Array(g *= 2)); E < g;)m = $[E] * 131072 + ($[E + 1] >>> 11), m >= 9e15 ? (S = crypto.getRandomValues(new Uint32Array(2)), $[E] = S[0], $[E + 1] = S[1]) : (T.push(m % 1e14), E += 2);
                E = g / 2;
            } else if (crypto.randomBytes) {
                for($ = crypto.randomBytes(g *= 7); E < g;)m = ($[E] & 31) * 281474976710656 + $[E + 1] * 1099511627776 + $[E + 2] * 4294967296 + $[E + 3] * 16777216 + ($[E + 4] << 16) + ($[E + 5] << 8) + $[E + 6], m >= 9e15 ? crypto.randomBytes(7).copy($, E) : (T.push(m % 1e14), E += 7);
                E = g / 7;
            } else throw p = !1, Error(to + "crypto unavailable");
            if (!p) for(; E < g;)m = R(), m < 9e15 && (T[E++] = m % 1e14);
            for(g = T[--E], X %= fr, g && X && (m = hE[fr - X], T[E] = rs(g / m) * m); T[E] === 0; T.pop(), E--);
            if (E < 0) T = [
                w = 0
            ];
            else {
                for(w = -1; T[0] === 0; T.splice(0, 1), w -= fr);
                for(E = 1, m = T[0]; m >= 10; m /= 10, E++);
                E < fr && (w -= fr - E);
            }
            return I.e = w, I.c = T, I;
        };
    }(), U.sum = function() {
        for(var G = 1, R = arguments, X = new U(R[0]); G < R.length;)X = X.plus(R[G++]);
        return X;
    }, r = /* @__PURE__ */ function() {
        var G = "0123456789";
        function R(X, $, S, w) {
            for(var g, m = [
                0
            ], E, T = 0, I = X.length; T < I;){
                for(E = m.length; E--; m[E] *= $);
                for(m[0] += w.indexOf(X.charAt(T++)), g = 0; g < m.length; g++)m[g] > S - 1 && (m[g + 1] == null && (m[g + 1] = 0), m[g + 1] += m[g] / S | 0, m[g] %= S);
            }
            return m.reverse();
        }
        return function(X, $, S, w, g) {
            var m, E, T, I, P, k, L, j, ie = X.indexOf("."), ue = s, ce = a;
            for(ie >= 0 && (I = _, _ = 0, X = X.replace(".", ""), j = new U($), k = j.pow(X.length - ie), _ = I, j.c = R(Va(ts(k.c), k.e, "0"), 10, S, G), j.e = j.c.length), L = R(X, $, S, g ? (m = O, G) : (m = G, O)), T = I = L.length; L[--I] == 0; L.pop());
            if (!L[0]) return m.charAt(0);
            if (ie < 0 ? --T : (k.c = L, k.e = T, k.s = w, k = t(k, j, ue, ce, S), L = k.c, P = k.r, T = k.e), E = T + ue + 1, ie = L[E], I = S / 2, P = P || E < 0 || L[E + 1] != null, P = ce < 4 ? (ie != null || P) && (ce == 0 || ce == (k.s < 0 ? 3 : 2)) : ie > I || ie == I && (ce == 4 || P || ce == 6 && L[E - 1] & 1 || ce == (k.s < 0 ? 8 : 7)), E < 1 || !L[0]) X = P ? Va(m.charAt(1), -ue, m.charAt(0)) : m.charAt(0);
            else {
                if (L.length = E, P) for(--S; ++L[--E] > S;)L[E] = 0, E || (++T, L = [
                    1
                ].concat(L));
                for(I = L.length; !L[--I];);
                for(ie = 0, X = ""; ie <= I; X += m.charAt(L[ie++]));
                X = Va(X, T, m.charAt(0));
            }
            return X;
        };
    }(), t = /* @__PURE__ */ function() {
        function G($, S, w) {
            var g, m, E, T, I = 0, P = $.length, k = S % Xc, L = S / Xc | 0;
            for($ = $.slice(); P--;)E = $[P] % Xc, T = $[P] / Xc | 0, g = L * E + T * k, m = k * E + g % Xc * Xc + I, I = (m / w | 0) + (g / Xc | 0) + L * T, $[P] = m % w;
            return I && ($ = [
                I
            ].concat($)), $;
        }
        function R($, S, w, g) {
            var m, E;
            if (w != g) E = w > g ? 1 : -1;
            else for(m = E = 0; m < w; m++)if ($[m] != S[m]) {
                E = $[m] > S[m] ? 1 : -1;
                break;
            }
            return E;
        }
        function X($, S, w, g) {
            for(var m = 0; w--;)$[w] -= m, m = $[w] < S[w] ? 1 : 0, $[w] = m * g + $[w] - S[w];
            for(; !$[0] && $.length > 1; $.splice(0, 1));
        }
        return function($, S, w, g, m) {
            var E, T, I, P, k, L, j, ie, ue, ce, he, ee, ae, ye, Se, De, Re, Ce = $.s == S.s ? 1 : -1, M = $.c, z = S.c;
            if (!M || !M[0] || !z || !z[0]) return new U(// Return NaN if either NaN, or both Infinity or 0.
            !$.s || !S.s || (M ? z && M[0] == z[0] : !z) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            M && M[0] == 0 || !z ? Ce * 0 : Ce / 0);
            for(ie = new U(Ce), ue = ie.c = [], T = $.e - S.e, Ce = w + T + 1, m || (m = Ss, T = ns($.e / fr) - ns(S.e / fr), Ce = Ce / fr | 0), I = 0; z[I] == (M[I] || 0); I++);
            if (z[I] > (M[I] || 0) && T--, Ce < 0) ue.push(1), P = !0;
            else {
                for(ye = M.length, De = z.length, I = 0, Ce += 2, k = rs(m / (z[0] + 1)), k > 1 && (z = G(z, k, m), M = G(M, k, m), De = z.length, ye = M.length), ae = De, ce = M.slice(0, De), he = ce.length; he < De; ce[he++] = 0);
                Re = z.slice(), Re = [
                    0
                ].concat(Re), Se = z[0], z[1] >= m / 2 && Se++;
                do {
                    if (k = 0, E = R(z, ce, De, he), E < 0) {
                        if (ee = ce[0], De != he && (ee = ee * m + (ce[1] || 0)), k = rs(ee / Se), k > 1) for(k >= m && (k = m - 1), L = G(z, k, m), j = L.length, he = ce.length; R(L, ce, j, he) == 1;)k--, X(L, De < j ? Re : z, j, m), j = L.length, E = 1;
                        else k == 0 && (E = k = 1), L = z.slice(), j = L.length;
                        if (j < he && (L = [
                            0
                        ].concat(L)), X(ce, L, he, m), he = ce.length, E == -1) for(; R(z, ce, De, he) < 1;)k++, X(ce, De < he ? Re : z, he, m), he = ce.length;
                    } else E === 0 && (k++, ce = [
                        0
                    ]);
                    ue[I++] = k, ce[0] ? ce[he++] = M[ae] || 0 : (ce = [
                        M[ae]
                    ], he = 1);
                }while ((ae++ < ye || ce[0] != null) && Ce--)
                P = ce[0] != null, ue[0] || ue.splice(0, 1);
            }
            if (m == Ss) {
                for(I = 1, Ce = ue[0]; Ce >= 10; Ce /= 10, I++);
                re(ie, w + (ie.e = I + T * fr - 1) + 1, g, P);
            } else ie.e = T, ie.r = +P;
            return ie;
        };
    }();
    function D(G, R, X, $) {
        var S, w, g, m, E;
        if (X == null ? X = a : vn(X, 0, 8), !G.c) return G.toString();
        if (S = G.c[0], g = G.e, R == null) E = ts(G.c), E = $ == 1 || $ == 2 && (g <= u || g >= f) ? vy(E, g) : Va(E, g, "0");
        else if (G = re(new U(G), R, X), w = G.e, E = ts(G.c), m = E.length, $ == 1 || $ == 2 && (R <= w || w <= u)) {
            for(; m < R; E += "0", m++);
            E = vy(E, w);
        } else if (R -= g, E = Va(E, w, "0"), w + 1 > m) {
            if (--R > 0) for(E += "."; R--; E += "0");
        } else if (R += w - m, R > 0) for(w + 1 == m && (E += "."); R--; E += "0");
        return G.s < 0 && S ? "-" + E : E;
    }
    function H(G, R) {
        for(var X, $, S = 1, w = new U(G[0]); S < G.length; S++)$ = new U(G[S]), (!$.s || (X = Gu(w, $)) === R || X === 0 && w.s === R) && (w = $);
        return w;
    }
    function K(G, R, X) {
        for(var $ = 1, S = R.length; !R[--S]; R.pop());
        for(S = R[0]; S >= 10; S /= 10, $++);
        return (X = $ + X * fr - 1) > l ? G.c = G.e = null : X < c ? G.c = [
            G.e = 0
        ] : (G.e = X, G.c = R), G;
    }
    n = /* @__PURE__ */ function() {
        var G = /^(-?)0([xbo])(?=\w[\w.]*$)/i, R = /^([^.]+)\.$/, X = /^\.([^.]+)$/, $ = /^-?(Infinity|NaN)$/, S = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(w, g, m, E) {
            var T, I = m ? g : g.replace(S, "");
            if ($.test(I)) w.s = isNaN(I) ? null : I < 0 ? -1 : 1;
            else {
                if (!m && (I = I.replace(G, function(P, k, L) {
                    return T = (L = L.toLowerCase()) == "x" ? 16 : L == "b" ? 2 : 8, !E || E == T ? k : P;
                }), E && (T = E, I = I.replace(R, "$1").replace(X, "0.$1")), g != I)) return new U(I, T);
                if (U.DEBUG) throw Error(to + "Not a" + (E ? " base " + E : "") + " number: " + g);
                w.s = null;
            }
            w.c = w.e = null;
        };
    }();
    function re(G, R, X, $) {
        var S, w, g, m, E, T, I, P = G.c, k = hE;
        if (P) {
            e: {
                for(S = 1, m = P[0]; m >= 10; m /= 10, S++);
                if (w = R - S, w < 0) w += fr, g = R, E = P[T = 0], I = rs(E / k[S - g - 1] % 10);
                else if (T = lE((w + 1) / fr), T >= P.length) if ($) {
                    for(; P.length <= T; P.push(0));
                    E = I = 0, S = 1, w %= fr, g = w - fr + 1;
                } else break e;
                else {
                    for(E = m = P[T], S = 1; m >= 10; m /= 10, S++);
                    w %= fr, g = w - fr + S, I = g < 0 ? 0 : rs(E / k[S - g - 1] % 10);
                }
                if ($ = $ || R < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                P[T + 1] != null || (g < 0 ? E : E % k[S - g - 1]), $ = X < 4 ? (I || $) && (X == 0 || X == (G.s < 0 ? 3 : 2)) : I > 5 || I == 5 && (X == 4 || $ || X == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (w > 0 ? g > 0 ? E / k[S - g] : 0 : P[T - 1]) % 10 & 1 || X == (G.s < 0 ? 8 : 7)), R < 1 || !P[0]) return P.length = 0, $ ? (R -= G.e + 1, P[0] = k[(fr - R % fr) % fr], G.e = -R || 0) : P[0] = G.e = 0, G;
                if (w == 0 ? (P.length = T, m = 1, T--) : (P.length = T + 1, m = k[fr - w], P[T] = g > 0 ? rs(E / k[S - g] % k[g]) * m : 0), $) for(;;)if (T == 0) {
                    for(w = 1, g = P[0]; g >= 10; g /= 10, w++);
                    for(g = P[0] += m, m = 1; g >= 10; g /= 10, m++);
                    w != m && (G.e++, P[0] == Ss && (P[0] = 1));
                    break;
                } else {
                    if (P[T] += m, P[T] != Ss) break;
                    P[T--] = 0, m = 1;
                }
                for(w = P.length; P[--w] === 0; P.pop());
            }
            G.e > l ? G.c = G.e = null : G.e < c && (G.c = [
                G.e = 0
            ]);
        }
        return G;
    }
    function Q(G) {
        var R, X = G.e;
        return X === null ? G.toString() : (R = ts(G.c), R = X <= u || X >= f ? vy(R, X) : Va(R, X, "0"), G.s < 0 ? "-" + R : R);
    }
    return i.absoluteValue = i.abs = function() {
        var G = new U(this);
        return G.s < 0 && (G.s = 1), G;
    }, i.comparedTo = function(G, R) {
        return Gu(this, new U(G, R));
    }, i.decimalPlaces = i.dp = function(G, R) {
        var X, $, S, w = this;
        if (G != null) return vn(G, 0, ri), R == null ? R = a : vn(R, 0, 8), re(new U(w), G + w.e + 1, R);
        if (!(X = w.c)) return null;
        if ($ = ((S = X.length - 1) - ns(this.e / fr)) * fr, S = X[S]) for(; S % 10 == 0; S /= 10, $--);
        return $ < 0 && ($ = 0), $;
    }, i.dividedBy = i.div = function(G, R) {
        return t(this, new U(G, R), s, a);
    }, i.dividedToIntegerBy = i.idiv = function(G, R) {
        return t(this, new U(G, R), 0, 1);
    }, i.exponentiatedBy = i.pow = function(G, R) {
        var X, $, S, w, g, m, E, T, I, P = this;
        if (G = new U(G), G.c && !G.isInteger()) throw Error(to + "Exponent not an integer: " + Q(G));
        if (R != null && (R = new U(R)), m = G.e > 14, !P.c || !P.c[0] || P.c[0] == 1 && !P.e && P.c.length == 1 || !G.c || !G.c[0]) return I = new U(Math.pow(+Q(P), m ? G.s * (2 - wy(G)) : +Q(G))), R ? I.mod(R) : I;
        if (E = G.s < 0, R) {
            if (R.c ? !R.c[0] : !R.s) return new U(NaN);
            $ = !E && P.isInteger() && R.isInteger(), $ && (P = P.mod(R));
        } else {
            if (G.e > 9 && (P.e > 0 || P.e < -1 || (P.e == 0 ? P.c[0] > 1 || m && P.c[1] >= 24e7 : P.c[0] < 8e13 || m && P.c[0] <= 9999975e7))) return w = P.s < 0 && wy(G) ? -0 : 0, P.e > -1 && (w = 1 / w), new U(E ? 1 / w : w);
            _ && (w = lE(_ / fr + 2));
        }
        for(m ? (X = new U(0.5), E && (G.s = 1), T = wy(G)) : (S = Math.abs(+Q(G)), T = S % 2), I = new U(o);;){
            if (T) {
                if (I = I.times(P), !I.c) break;
                w ? I.c.length > w && (I.c.length = w) : $ && (I = I.mod(R));
            }
            if (S) {
                if (S = rs(S / 2), S === 0) break;
                T = S % 2;
            } else if (G = G.times(X), re(G, G.e + 1, 1), G.e > 14) T = wy(G);
            else {
                if (S = +Q(G), S === 0) break;
                T = S % 2;
            }
            P = P.times(P), w ? P.c && P.c.length > w && (P.c.length = w) : $ && (P = P.mod(R));
        }
        return $ ? I : (E && (I = o.div(I)), R ? I.mod(R) : w ? re(I, _, a, g) : I);
    }, i.integerValue = function(G) {
        var R = new U(this);
        return G == null ? G = a : vn(G, 0, 8), re(R, R.e + 1, G);
    }, i.isEqualTo = i.eq = function(G, R) {
        return Gu(this, new U(G, R)) === 0;
    }, i.isFinite = function() {
        return !!this.c;
    }, i.isGreaterThan = i.gt = function(G, R) {
        return Gu(this, new U(G, R)) > 0;
    }, i.isGreaterThanOrEqualTo = i.gte = function(G, R) {
        return (R = Gu(this, new U(G, R))) === 1 || R === 0;
    }, i.isInteger = function() {
        return !!this.c && ns(this.e / fr) > this.c.length - 2;
    }, i.isLessThan = i.lt = function(G, R) {
        return Gu(this, new U(G, R)) < 0;
    }, i.isLessThanOrEqualTo = i.lte = function(G, R) {
        return (R = Gu(this, new U(G, R))) === -1 || R === 0;
    }, i.isNaN = function() {
        return !this.s;
    }, i.isNegative = function() {
        return this.s < 0;
    }, i.isPositive = function() {
        return this.s > 0;
    }, i.isZero = function() {
        return !!this.c && this.c[0] == 0;
    }, i.minus = function(G, R) {
        var X, $, S, w, g = this, m = g.s;
        if (G = new U(G, R), R = G.s, !m || !R) return new U(NaN);
        if (m != R) return G.s = -R, g.plus(G);
        var E = g.e / fr, T = G.e / fr, I = g.c, P = G.c;
        if (!E || !T) {
            if (!I || !P) return I ? (G.s = -R, G) : new U(P ? g : NaN);
            if (!I[0] || !P[0]) return P[0] ? (G.s = -R, G) : new U(I[0] ? g : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            a == 3 ? -0 : 0);
        }
        if (E = ns(E), T = ns(T), I = I.slice(), m = E - T) {
            for((w = m < 0) ? (m = -m, S = I) : (T = E, S = P), S.reverse(), R = m; R--; S.push(0));
            S.reverse();
        } else for($ = (w = (m = I.length) < (R = P.length)) ? m : R, m = R = 0; R < $; R++)if (I[R] != P[R]) {
            w = I[R] < P[R];
            break;
        }
        if (w && (S = I, I = P, P = S, G.s = -G.s), R = ($ = P.length) - (X = I.length), R > 0) for(; R--; I[X++] = 0);
        for(R = Ss - 1; $ > m;){
            if (I[--$] < P[$]) {
                for(X = $; X && !I[--X]; I[X] = R);
                --I[X], I[$] += Ss;
            }
            I[$] -= P[$];
        }
        for(; I[0] == 0; I.splice(0, 1), --T);
        return I[0] ? K(G, I, T) : (G.s = a == 3 ? -1 : 1, G.c = [
            G.e = 0
        ], G);
    }, i.modulo = i.mod = function(G, R) {
        var X, $, S = this;
        return G = new U(G, R), !S.c || !G.s || G.c && !G.c[0] ? new U(NaN) : !G.c || S.c && !S.c[0] ? new U(S) : (y == 9 ? ($ = G.s, G.s = 1, X = t(S, G, 0, 3), G.s = $, X.s *= $) : X = t(S, G, 0, y), G = S.minus(X.times(G)), !G.c[0] && y == 1 && (G.s = S.s), G);
    }, i.multipliedBy = i.times = function(G, R) {
        var X, $, S, w, g, m, E, T, I, P, k, L, j, ie, ue, ce = this, he = ce.c, ee = (G = new U(G, R)).c;
        if (!he || !ee || !he[0] || !ee[0]) return !ce.s || !G.s || he && !he[0] && !ee || ee && !ee[0] && !he ? G.c = G.e = G.s = null : (G.s *= ce.s, !he || !ee ? G.c = G.e = null : (G.c = [
            0
        ], G.e = 0)), G;
        for($ = ns(ce.e / fr) + ns(G.e / fr), G.s *= ce.s, E = he.length, P = ee.length, E < P && (j = he, he = ee, ee = j, S = E, E = P, P = S), S = E + P, j = []; S--; j.push(0));
        for(ie = Ss, ue = Xc, S = P; --S >= 0;){
            for(X = 0, k = ee[S] % ue, L = ee[S] / ue | 0, g = E, w = S + g; w > S;)T = he[--g] % ue, I = he[g] / ue | 0, m = L * T + I * k, T = k * T + m % ue * ue + j[w] + X, X = (T / ie | 0) + (m / ue | 0) + L * I, j[w--] = T % ie;
            j[w] = X;
        }
        return X ? ++$ : j.splice(0, 1), K(G, j, $);
    }, i.negated = function() {
        var G = new U(this);
        return G.s = -G.s || null, G;
    }, i.plus = function(G, R) {
        var X, $ = this, S = $.s;
        if (G = new U(G, R), R = G.s, !S || !R) return new U(NaN);
        if (S != R) return G.s = -R, $.minus(G);
        var w = $.e / fr, g = G.e / fr, m = $.c, E = G.c;
        if (!w || !g) {
            if (!m || !E) return new U(S / 0);
            if (!m[0] || !E[0]) return E[0] ? G : new U(m[0] ? $ : S * 0);
        }
        if (w = ns(w), g = ns(g), m = m.slice(), S = w - g) {
            for(S > 0 ? (g = w, X = E) : (S = -S, X = m), X.reverse(); S--; X.push(0));
            X.reverse();
        }
        for(S = m.length, R = E.length, S - R < 0 && (X = E, E = m, m = X, R = S), S = 0; R;)S = (m[--R] = m[R] + E[R] + S) / Ss | 0, m[R] = Ss === m[R] ? 0 : m[R] % Ss;
        return S && (m = [
            S
        ].concat(m), ++g), K(G, m, g);
    }, i.precision = i.sd = function(G, R) {
        var X, $, S, w = this;
        if (G != null && G !== !!G) return vn(G, 1, ri), R == null ? R = a : vn(R, 0, 8), re(new U(w), G, R);
        if (!(X = w.c)) return null;
        if (S = X.length - 1, $ = S * fr + 1, S = X[S]) {
            for(; S % 10 == 0; S /= 10, $--);
            for(S = X[0]; S >= 10; S /= 10, $++);
        }
        return G && w.e + 1 > $ && ($ = w.e + 1), $;
    }, i.shiftedBy = function(G) {
        return vn(G, -dE, dE), this.times("1e" + G);
    }, i.squareRoot = i.sqrt = function() {
        var G, R, X, $, S, w = this, g = w.c, m = w.s, E = w.e, T = s + 4, I = new U("0.5");
        if (m !== 1 || !g || !g[0]) return new U(!m || m < 0 && (!g || g[0]) ? NaN : g ? w : 1 / 0);
        if (m = Math.sqrt(+Q(w)), m == 0 || m == 1 / 0 ? (R = ts(g), (R.length + E) % 2 == 0 && (R += "0"), m = Math.sqrt(+R), E = ns((E + 1) / 2) - (E < 0 || E % 2), m == 1 / 0 ? R = "5e" + E : (R = m.toExponential(), R = R.slice(0, R.indexOf("e") + 1) + E), X = new U(R)) : X = new U(m + ""), X.c[0]) {
            for(E = X.e, m = E + T, m < 3 && (m = 0);;)if (S = X, X = I.times(S.plus(t(w, S, T, 1))), ts(S.c).slice(0, m) === (R = ts(X.c)).slice(0, m)) if (X.e < E && --m, R = R.slice(m - 3, m + 1), R == "9999" || !$ && R == "4999") {
                if (!$ && (re(S, S.e + s + 2, 0), S.times(S).eq(w))) {
                    X = S;
                    break;
                }
                T += 4, m += 4, $ = 1;
            } else {
                (!+R || !+R.slice(1) && R.charAt(0) == "5") && (re(X, X.e + s + 2, 1), G = !X.times(X).eq(w));
                break;
            }
        }
        return re(X, X.e + s + 1, a, G);
    }, i.toExponential = function(G, R) {
        return G != null && (vn(G, 0, ri), G++), D(this, G, R, 1);
    }, i.toFixed = function(G, R) {
        return G != null && (vn(G, 0, ri), G = G + this.e + 1), D(this, G, R);
    }, i.toFormat = function(G, R, X) {
        var $, S = this;
        if (X == null) G != null && R && typeof R == "object" ? (X = R, R = null) : G && typeof G == "object" ? (X = G, G = R = null) : X = A;
        else if (typeof X != "object") throw Error(to + "Argument not an object: " + X);
        if ($ = S.toFixed(G, R), S.c) {
            var w, g = $.split("."), m = +X.groupSize, E = +X.secondaryGroupSize, T = X.groupSeparator || "", I = g[0], P = g[1], k = S.s < 0, L = k ? I.slice(1) : I, j = L.length;
            if (E && (w = m, m = E, E = w, j -= w), m > 0 && j > 0) {
                for(w = j % m || m, I = L.substr(0, w); w < j; w += m)I += T + L.substr(w, m);
                E > 0 && (I += T + L.slice(w)), k && (I = "-" + I);
            }
            $ = P ? I + (X.decimalSeparator || "") + ((E = +X.fractionGroupSize) ? P.replace(new RegExp("\\d{" + E + "}\\B", "g"), "$&" + (X.fractionGroupSeparator || "")) : P) : I;
        }
        return (X.prefix || "") + $ + (X.suffix || "");
    }, i.toFraction = function(G) {
        var R, X, $, S, w, g, m, E, T, I, P, k, L = this, j = L.c;
        if (G != null && (m = new U(G), !m.isInteger() && (m.c || m.s !== 1) || m.lt(o))) throw Error(to + "Argument " + (m.isInteger() ? "out of range: " : "not an integer: ") + Q(m));
        if (!j) return new U(L);
        for(R = new U(o), T = X = new U(o), $ = E = new U(o), k = ts(j), w = R.e = k.length - L.e - 1, R.c[0] = hE[(g = w % fr) < 0 ? fr + g : g], G = !G || m.comparedTo(R) > 0 ? w > 0 ? R : T : m, g = l, l = 1 / 0, m = new U(k), E.c[0] = 0; I = t(m, R, 0, 1), S = X.plus(I.times($)), S.comparedTo(G) != 1;)X = $, $ = S, T = E.plus(I.times(S = T)), E = S, R = m.minus(I.times(S = R)), m = S;
        return S = t(G.minus(X), $, 0, 1), E = E.plus(S.times(T)), X = X.plus(S.times($)), E.s = T.s = L.s, w = w * 2, P = t(T, $, w, a).minus(L).abs().comparedTo(t(E, X, w, a).minus(L).abs()) < 1 ? [
            T,
            $
        ] : [
            E,
            X
        ], l = g, P;
    }, i.toNumber = function() {
        return +Q(this);
    }, i.toPrecision = function(G, R) {
        return G != null && vn(G, 1, ri), D(this, G, R, 2);
    }, i.toString = function(G) {
        var R, X = this, $ = X.s, S = X.e;
        return S === null ? $ ? (R = "Infinity", $ < 0 && (R = "-" + R)) : R = "NaN" : (G == null ? R = S <= u || S >= f ? vy(ts(X.c), S) : Va(ts(X.c), S, "0") : G === 10 && N ? (X = re(new U(X), s + S + 1, a), R = Va(ts(X.c), X.e, "0")) : (vn(G, 2, O.length, "Base"), R = r(Va(ts(X.c), S, "0"), 10, G, $, !0)), $ < 0 && X.c[0] && (R = "-" + R)), R;
    }, i.valueOf = i.toJSON = function() {
        return Q(this);
    }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, e != null && U.set(e), U;
}
function ns(e) {
    var t = e | 0;
    return e > 0 || e === t ? t : t - 1;
}
function ts(e) {
    for(var t, r, n = 1, i = e.length, o = e[0] + ""; n < i;){
        for(t = e[n++] + "", r = fr - t.length; r--; t = "0" + t);
        o += t;
    }
    for(i = o.length; o.charCodeAt(--i) === 48;);
    return o.slice(0, i + 1 || 1);
}
function Gu(e, t) {
    var r, n, i = e.c, o = t.c, s = e.s, a = t.s, u = e.e, f = t.e;
    if (!s || !a) return null;
    if (r = i && !i[0], n = o && !o[0], r || n) return r ? n ? 0 : -a : s;
    if (s != a) return s;
    if (r = s < 0, n = u == f, !i || !o) return n ? 0 : !i ^ r ? 1 : -1;
    if (!n) return u > f ^ r ? 1 : -1;
    for(a = (u = i.length) < (f = o.length) ? u : f, s = 0; s < a; s++)if (i[s] != o[s]) return i[s] > o[s] ^ r ? 1 : -1;
    return u == f ? 0 : u > f ^ r ? 1 : -1;
}
function vn(e, t, r, n) {
    if (e < t || e > r || e !== rs(e)) throw Error(to + (n || "Argument") + (typeof e == "number" ? e < t || e > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function wy(e) {
    var t = e.c.length - 1;
    return ns(e.e / fr) == t && e.c[t] % 2 != 0;
}
function vy(e, t) {
    return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function Va(e, t, r) {
    var n, i;
    if (t < 0) {
        for(i = r + "."; ++t; i += r);
        e = i + e;
    } else if (n = e.length, ++t > n) {
        for(i = r, t -= n; --t; i += r);
        e += i;
    } else t < n && (e = e.slice(0, t) + "." + e.slice(t));
    return e;
}
lU();
var _be = [
    "mainnet",
    "testnet"
], Ebe = [
    "testnet",
    "regtest",
    "signet"
], xbe = [
    "mainnet",
    "testnet3",
    "testnet4",
    "regtest",
    "signet"
], Sbe = Te.enum([
    ..._be,
    ...Ebe
]), Abe = Te.enum([
    ...xbe
]);
Te.object({
    name: Te.string(),
    id: Te.string(),
    chain: Te.object({
        bitcoin: Te.object({
            blockchain: Te.literal("bitcoin"),
            bitcoinUrl: Te.string(),
            bitcoinNetwork: Abe,
            mode: Sbe
        }),
        stacks: Te.object({
            blockchain: Te.literal("stacks"),
            url: Te.string(),
            chainId: Te.number(),
            subnetChainId: Te.number().optional()
        })
    })
});
Te.string().email({
    message: "Invalid email address"
});
var Tbe = Te.object({
    fingerprint: Te.string()
}), kbe = Tbe.merge(Te.object({
    accountIndex: Te.number()
})), Ibe = Te.object({
    taprootDescriptor: Te.string(),
    nativeSegwitDescriptor: Te.string()
}), Bbe = Te.object({
    stxAddress: Te.string()
});
Te.object({
    id: kbe,
    bitcoin: Ibe.optional(),
    stacks: Bbe.optional()
});
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */ const { entries: dU, setPrototypeOf: vB, isFrozen: Obe, getPrototypeOf: Pbe, getOwnPropertyDescriptor: Nbe } = Object;
let { freeze: Vi, seal: gs, create: hU } = Object, { apply: Vx, construct: Gx } = typeof Reflect < "u" && Reflect;
Vi || (Vi = function(t) {
    return t;
});
gs || (gs = function(t) {
    return t;
});
Vx || (Vx = function(t, r, n) {
    return t.apply(r, n);
});
Gx || (Gx = function(t, r) {
    return new t(...r);
});
const _y = Gi(Array.prototype.forEach), Mbe = Gi(Array.prototype.lastIndexOf), _B = Gi(Array.prototype.pop), vh = Gi(Array.prototype.push), Rbe = Gi(Array.prototype.splice), jy = Gi(String.prototype.toLowerCase), pE = Gi(String.prototype.toString), EB = Gi(String.prototype.match), _h = Gi(String.prototype.replace), Cbe = Gi(String.prototype.indexOf), Ube = Gi(String.prototype.trim), Ts = Gi(Object.prototype.hasOwnProperty), zi = Gi(RegExp.prototype.test), Eh = $be(TypeError);
function Gi(e) {
    return function(t) {
        for(var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)n[i - 1] = arguments[i];
        return Vx(e, t, n);
    };
}
function $be(e) {
    return function() {
        for(var t = arguments.length, r = new Array(t), n = 0; n < t; n++)r[n] = arguments[n];
        return Gx(e, r);
    };
}
function Nr(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : jy;
    vB && vB(e, null);
    let n = t.length;
    for(; n--;){
        let i = t[n];
        if (typeof i == "string") {
            const o = r(i);
            o !== i && (Obe(t) || (t[n] = o), i = o);
        }
        e[i] = !0;
    }
    return e;
}
function Lbe(e) {
    for(let t = 0; t < e.length; t++)Ts(e, t) || (e[t] = null);
    return e;
}
function Ju(e) {
    const t = hU(null);
    for (const [r, n] of dU(e))Ts(e, r) && (Array.isArray(n) ? t[r] = Lbe(n) : n && typeof n == "object" && n.constructor === Object ? t[r] = Ju(n) : t[r] = n);
    return t;
}
function xh(e, t) {
    for(; e !== null;){
        const n = Nbe(e, t);
        if (n) {
            if (n.get) return Gi(n.get);
            if (typeof n.value == "function") return Gi(n.value);
        }
        e = Pbe(e);
    }
    function r() {
        return null;
    }
    return r;
}
const xB = Vi([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
]), gE = Vi([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
]), yE = Vi([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
]), Dbe = Vi([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
]), mE = Vi([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts"
]), Fbe = Vi([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
]), SB = Vi([
    "#text"
]), AB = Vi([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "wrap",
    "xmlns",
    "slot"
]), bE = Vi([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "amplitude",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "exponent",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "intercept",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "slope",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "tablevalues",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
]), TB = Vi([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
]), Ey = Vi([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
]), zbe = gs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), jbe = gs(/<%[\w\W]*|[\w\W]*%>/gm), Hbe = gs(/\$\{[\w\W]*/gm), qbe = gs(/^data-[\-\w.\u00B7-\uFFFF]+$/), Kbe = gs(/^aria-[\-\w]+$/), pU = gs(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Wbe = gs(/^(?:\w+script|data):/i), Vbe = gs(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), gU = gs(/^html$/i), Gbe = gs(/^[a-z][.\w]*(-[.\w]+)+$/i);
var kB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR: Kbe,
    ATTR_WHITESPACE: Vbe,
    CUSTOM_ELEMENT: Gbe,
    DATA_ATTR: qbe,
    DOCTYPE_NAME: gU,
    ERB_EXPR: jbe,
    IS_ALLOWED_URI: pU,
    IS_SCRIPT_OR_DATA: Wbe,
    MUSTACHE_EXPR: zbe,
    TMPLIT_EXPR: Hbe
});
const Sh = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
}, Zbe = function() {
    return ("TURBOPACK compile-time value", "undefined") > "u" ? null : window;
}, Ybe = function(t, r) {
    if (typeof t != "object" || typeof t.createPolicy != "function") return null;
    let n = null;
    const i = "data-tt-policy-suffix";
    r && r.hasAttribute(i) && (n = r.getAttribute(i));
    const o = "dompurify" + (n ? "#" + n : "");
    try {
        return t.createPolicy(o, {
            createHTML (s) {
                return s;
            },
            createScriptURL (s) {
                return s;
            }
        });
    } catch  {
        return console.warn("TrustedTypes policy " + o + " could not be created."), null;
    }
}, IB = function() {
    return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
    };
};
function yU() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Zbe();
    const t = (St)=>yU(St);
    if (t.version = "3.2.4", t.removed = [], !e || !e.document || e.document.nodeType !== Sh.document || !e.Element) return t.isSupported = !1, t;
    let { document: r } = e;
    const n = r, i = n.currentScript, { DocumentFragment: o, HTMLTemplateElement: s, Node: a, Element: u, NodeFilter: f, NamedNodeMap: c = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: l, DOMParser: p, trustedTypes: y } = e, _ = u.prototype, A = xh(_, "cloneNode"), O = xh(_, "remove"), N = xh(_, "nextSibling"), U = xh(_, "childNodes"), D = xh(_, "parentNode");
    if (typeof s == "function") {
        const St = r.createElement("template");
        St.content && St.content.ownerDocument && (r = St.content.ownerDocument);
    }
    let H, K = "";
    const { implementation: re, createNodeIterator: Q, createDocumentFragment: G, getElementsByTagName: R } = r, { importNode: X } = n;
    let $ = IB();
    t.isSupported = typeof dU == "function" && typeof D == "function" && re && re.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: S, ERB_EXPR: w, TMPLIT_EXPR: g, DATA_ATTR: m, ARIA_ATTR: E, IS_SCRIPT_OR_DATA: T, ATTR_WHITESPACE: I, CUSTOM_ELEMENT: P } = kB;
    let { IS_ALLOWED_URI: k } = kB, L = null;
    const j = Nr({}, [
        ...xB,
        ...gE,
        ...yE,
        ...mE,
        ...SB
    ]);
    let ie = null;
    const ue = Nr({}, [
        ...AB,
        ...bE,
        ...TB,
        ...Ey
    ]);
    let ce = Object.seal(hU(null, {
        tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
        }
    })), he = null, ee = null, ae = !0, ye = !0, Se = !1, De = !0, Re = !1, Ce = !0, M = !1, z = !1, de = !1, _e = !1, Ie = !1, je = !1, Ke = !0, Ue = !1;
    const h = "user-content-";
    let x = !0, q = !1, te = {}, fe = null;
    const ne = Nr({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
    ]);
    let W = null;
    const J = Nr({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
    ]);
    let V = null;
    const C = Nr({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
    ]), Z = "http://www.w3.org/1998/Math/MathML", le = "http://www.w3.org/2000/svg", se = "http://www.w3.org/1999/xhtml";
    let Ne = se, Le = !1, rt = null;
    const yt = Nr({}, [
        Z,
        le,
        se
    ], pE);
    let _t = Nr({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
    ]), Qe = Nr({}, [
        "annotation-xml"
    ]);
    const Rt = Nr({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
    ]);
    let Lt = null;
    const Ur = [
        "application/xhtml+xml",
        "text/html"
    ], jr = "text/html";
    let Et = null, Xt = null;
    const wr = r.createElement("form"), zt = function(Pe) {
        return Pe instanceof RegExp || Pe instanceof Function;
    }, Ae = function() {
        let Pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(Xt && Xt === Pe)) {
            if ((!Pe || typeof Pe != "object") && (Pe = {}), Pe = Ju(Pe), Lt = Ur.indexOf(Pe.PARSER_MEDIA_TYPE) === -1 ? jr : Pe.PARSER_MEDIA_TYPE, Et = Lt === "application/xhtml+xml" ? pE : jy, L = Ts(Pe, "ALLOWED_TAGS") ? Nr({}, Pe.ALLOWED_TAGS, Et) : j, ie = Ts(Pe, "ALLOWED_ATTR") ? Nr({}, Pe.ALLOWED_ATTR, Et) : ue, rt = Ts(Pe, "ALLOWED_NAMESPACES") ? Nr({}, Pe.ALLOWED_NAMESPACES, pE) : yt, V = Ts(Pe, "ADD_URI_SAFE_ATTR") ? Nr(Ju(C), Pe.ADD_URI_SAFE_ATTR, Et) : C, W = Ts(Pe, "ADD_DATA_URI_TAGS") ? Nr(Ju(J), Pe.ADD_DATA_URI_TAGS, Et) : J, fe = Ts(Pe, "FORBID_CONTENTS") ? Nr({}, Pe.FORBID_CONTENTS, Et) : ne, he = Ts(Pe, "FORBID_TAGS") ? Nr({}, Pe.FORBID_TAGS, Et) : {}, ee = Ts(Pe, "FORBID_ATTR") ? Nr({}, Pe.FORBID_ATTR, Et) : {}, te = Ts(Pe, "USE_PROFILES") ? Pe.USE_PROFILES : !1, ae = Pe.ALLOW_ARIA_ATTR !== !1, ye = Pe.ALLOW_DATA_ATTR !== !1, Se = Pe.ALLOW_UNKNOWN_PROTOCOLS || !1, De = Pe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Re = Pe.SAFE_FOR_TEMPLATES || !1, Ce = Pe.SAFE_FOR_XML !== !1, M = Pe.WHOLE_DOCUMENT || !1, _e = Pe.RETURN_DOM || !1, Ie = Pe.RETURN_DOM_FRAGMENT || !1, je = Pe.RETURN_TRUSTED_TYPE || !1, de = Pe.FORCE_BODY || !1, Ke = Pe.SANITIZE_DOM !== !1, Ue = Pe.SANITIZE_NAMED_PROPS || !1, x = Pe.KEEP_CONTENT !== !1, q = Pe.IN_PLACE || !1, k = Pe.ALLOWED_URI_REGEXP || pU, Ne = Pe.NAMESPACE || se, _t = Pe.MATHML_TEXT_INTEGRATION_POINTS || _t, Qe = Pe.HTML_INTEGRATION_POINTS || Qe, ce = Pe.CUSTOM_ELEMENT_HANDLING || {}, Pe.CUSTOM_ELEMENT_HANDLING && zt(Pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ce.tagNameCheck = Pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Pe.CUSTOM_ELEMENT_HANDLING && zt(Pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ce.attributeNameCheck = Pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Pe.CUSTOM_ELEMENT_HANDLING && typeof Pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ce.allowCustomizedBuiltInElements = Pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Re && (ye = !1), Ie && (_e = !0), te && (L = Nr({}, SB), ie = [], te.html === !0 && (Nr(L, xB), Nr(ie, AB)), te.svg === !0 && (Nr(L, gE), Nr(ie, bE), Nr(ie, Ey)), te.svgFilters === !0 && (Nr(L, yE), Nr(ie, bE), Nr(ie, Ey)), te.mathMl === !0 && (Nr(L, mE), Nr(ie, TB), Nr(ie, Ey))), Pe.ADD_TAGS && (L === j && (L = Ju(L)), Nr(L, Pe.ADD_TAGS, Et)), Pe.ADD_ATTR && (ie === ue && (ie = Ju(ie)), Nr(ie, Pe.ADD_ATTR, Et)), Pe.ADD_URI_SAFE_ATTR && Nr(V, Pe.ADD_URI_SAFE_ATTR, Et), Pe.FORBID_CONTENTS && (fe === ne && (fe = Ju(fe)), Nr(fe, Pe.FORBID_CONTENTS, Et)), x && (L["#text"] = !0), M && Nr(L, [
                "html",
                "head",
                "body"
            ]), L.table && (Nr(L, [
                "tbody"
            ]), delete he.tbody), Pe.TRUSTED_TYPES_POLICY) {
                if (typeof Pe.TRUSTED_TYPES_POLICY.createHTML != "function") throw Eh('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
                if (typeof Pe.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw Eh('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
                H = Pe.TRUSTED_TYPES_POLICY, K = H.createHTML("");
            } else H === void 0 && (H = Ybe(y, i)), H !== null && typeof K == "string" && (K = H.createHTML(""));
            Vi && Vi(Pe), Xt = Pe;
        }
    }, we = Nr({}, [
        ...gE,
        ...yE,
        ...Dbe
    ]), xe = Nr({}, [
        ...mE,
        ...Fbe
    ]), Me = function(Pe) {
        let et = D(Pe);
        (!et || !et.tagName) && (et = {
            namespaceURI: Ne,
            tagName: "template"
        });
        const vt = jy(Pe.tagName), be = jy(et.tagName);
        return rt[Pe.namespaceURI] ? Pe.namespaceURI === le ? et.namespaceURI === se ? vt === "svg" : et.namespaceURI === Z ? vt === "svg" && (be === "annotation-xml" || _t[be]) : !!we[vt] : Pe.namespaceURI === Z ? et.namespaceURI === se ? vt === "math" : et.namespaceURI === le ? vt === "math" && Qe[be] : !!xe[vt] : Pe.namespaceURI === se ? et.namespaceURI === le && !Qe[be] || et.namespaceURI === Z && !_t[be] ? !1 : !xe[vt] && (Rt[vt] || !we[vt]) : !!(Lt === "application/xhtml+xml" && rt[Pe.namespaceURI]) : !1;
    }, ze = function(Pe) {
        vh(t.removed, {
            element: Pe
        });
        try {
            D(Pe).removeChild(Pe);
        } catch  {
            O(Pe);
        }
    }, Ve = function(Pe, et) {
        try {
            vh(t.removed, {
                attribute: et.getAttributeNode(Pe),
                from: et
            });
        } catch  {
            vh(t.removed, {
                attribute: null,
                from: et
            });
        }
        if (et.removeAttribute(Pe), Pe === "is") if (_e || Ie) try {
            ze(et);
        } catch  {}
        else try {
            et.setAttribute(Pe, "");
        } catch  {}
    }, at = function(Pe) {
        let et = null, vt = null;
        if (de) Pe = "<remove></remove>" + Pe;
        else {
            const jt = EB(Pe, /^[\r\n\t ]+/);
            vt = jt && jt[0];
        }
        Lt === "application/xhtml+xml" && Ne === se && (Pe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Pe + "</body></html>");
        const be = H ? H.createHTML(Pe) : Pe;
        if (Ne === se) try {
            et = new p().parseFromString(be, Lt);
        } catch  {}
        if (!et || !et.documentElement) {
            et = re.createDocument(Ne, "template", null);
            try {
                et.documentElement.innerHTML = Le ? K : be;
            } catch  {}
        }
        const $r = et.body || et.documentElement;
        return Pe && vt && $r.insertBefore(r.createTextNode(vt), $r.childNodes[0] || null), Ne === se ? R.call(et, M ? "html" : "body")[0] : M ? et.documentElement : $r;
    }, ct = function(Pe) {
        return Q.call(Pe.ownerDocument || Pe, Pe, // eslint-disable-next-line no-bitwise
        f.SHOW_ELEMENT | f.SHOW_COMMENT | f.SHOW_TEXT | f.SHOW_PROCESSING_INSTRUCTION | f.SHOW_CDATA_SECTION, null);
    }, lt = function(Pe) {
        return Pe instanceof l && (typeof Pe.nodeName != "string" || typeof Pe.textContent != "string" || typeof Pe.removeChild != "function" || !(Pe.attributes instanceof c) || typeof Pe.removeAttribute != "function" || typeof Pe.setAttribute != "function" || typeof Pe.namespaceURI != "string" || typeof Pe.insertBefore != "function" || typeof Pe.hasChildNodes != "function");
    }, mt = function(Pe) {
        return typeof a == "function" && Pe instanceof a;
    };
    function wt(St, Pe, et) {
        _y(St, (vt)=>{
            vt.call(t, Pe, et, Xt);
        });
    }
    const bt = function(Pe) {
        let et = null;
        if (wt($.beforeSanitizeElements, Pe, null), lt(Pe)) return ze(Pe), !0;
        const vt = Et(Pe.nodeName);
        if (wt($.uponSanitizeElement, Pe, {
            tagName: vt,
            allowedTags: L
        }), Pe.hasChildNodes() && !mt(Pe.firstElementChild) && zi(/<[/\w]/g, Pe.innerHTML) && zi(/<[/\w]/g, Pe.textContent) || Pe.nodeType === Sh.progressingInstruction || Ce && Pe.nodeType === Sh.comment && zi(/<[/\w]/g, Pe.data)) return ze(Pe), !0;
        if (!L[vt] || he[vt]) {
            if (!he[vt] && Ct(vt) && (ce.tagNameCheck instanceof RegExp && zi(ce.tagNameCheck, vt) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(vt))) return !1;
            if (x && !fe[vt]) {
                const be = D(Pe) || Pe.parentNode, $r = U(Pe) || Pe.childNodes;
                if ($r && be) {
                    const jt = $r.length;
                    for(let nr = jt - 1; nr >= 0; --nr){
                        const kt = A($r[nr], !0);
                        kt.__removalCount = (Pe.__removalCount || 0) + 1, be.insertBefore(kt, N(Pe));
                    }
                }
            }
            return ze(Pe), !0;
        }
        return Pe instanceof u && !Me(Pe) || (vt === "noscript" || vt === "noembed" || vt === "noframes") && zi(/<\/no(script|embed|frames)/i, Pe.innerHTML) ? (ze(Pe), !0) : (Re && Pe.nodeType === Sh.text && (et = Pe.textContent, _y([
            S,
            w,
            g
        ], (be)=>{
            et = _h(et, be, " ");
        }), Pe.textContent !== et && (vh(t.removed, {
            element: Pe.cloneNode()
        }), Pe.textContent = et)), wt($.afterSanitizeElements, Pe, null), !1);
    }, Mt = function(Pe, et, vt) {
        if (Ke && (et === "id" || et === "name") && (vt in r || vt in wr)) return !1;
        if (!(ye && !ee[et] && zi(m, et))) {
            if (!(ae && zi(E, et))) {
                if (!ie[et] || ee[et]) {
                    if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND
                    // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                    // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                    !(Ct(Pe) && (ce.tagNameCheck instanceof RegExp && zi(ce.tagNameCheck, Pe) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(Pe)) && (ce.attributeNameCheck instanceof RegExp && zi(ce.attributeNameCheck, et) || ce.attributeNameCheck instanceof Function && ce.attributeNameCheck(et)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                    // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                    et === "is" && ce.allowCustomizedBuiltInElements && (ce.tagNameCheck instanceof RegExp && zi(ce.tagNameCheck, vt) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(vt)))) return !1;
                } else if (!V[et]) {
                    if (!zi(k, _h(vt, I, ""))) {
                        if (!((et === "src" || et === "xlink:href" || et === "href") && Pe !== "script" && Cbe(vt, "data:") === 0 && W[Pe])) {
                            if (!(Se && !zi(T, _h(vt, I, "")))) {
                                if (vt) return !1;
                            }
                        }
                    }
                }
            }
        }
        return !0;
    }, Ct = function(Pe) {
        return Pe !== "annotation-xml" && EB(Pe, P);
    }, Xe = function(Pe) {
        wt($.beforeSanitizeAttributes, Pe, null);
        const { attributes: et } = Pe;
        if (!et || lt(Pe)) return;
        const vt = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: ie,
            forceKeepAttr: void 0
        };
        let be = et.length;
        for(; be--;){
            const $r = et[be], { name: jt, namespaceURI: nr, value: kt } = $r, Hn = Et(jt);
            let Zr = jt === "value" ? kt : Ube(kt);
            if (vt.attrName = Hn, vt.attrValue = Zr, vt.keepAttr = !0, vt.forceKeepAttr = void 0, wt($.uponSanitizeAttribute, Pe, vt), Zr = vt.attrValue, Ue && (Hn === "id" || Hn === "name") && (Ve(jt, Pe), Zr = h + Zr), Ce && zi(/((--!?|])>)|<\/(style|title)/i, Zr)) {
                Ve(jt, Pe);
                continue;
            }
            if (vt.forceKeepAttr || (Ve(jt, Pe), !vt.keepAttr)) continue;
            if (!De && zi(/\/>/i, Zr)) {
                Ve(jt, Pe);
                continue;
            }
            Re && _y([
                S,
                w,
                g
            ], (B)=>{
                Zr = _h(Zr, B, " ");
            });
            const v = Et(Pe.nodeName);
            if (Mt(v, Hn, Zr)) {
                if (H && typeof y == "object" && typeof y.getAttributeType == "function" && !nr) switch(y.getAttributeType(v, Hn)){
                    case "TrustedHTML":
                        {
                            Zr = H.createHTML(Zr);
                            break;
                        }
                    case "TrustedScriptURL":
                        {
                            Zr = H.createScriptURL(Zr);
                            break;
                        }
                }
                try {
                    nr ? Pe.setAttributeNS(nr, jt, Zr) : Pe.setAttribute(jt, Zr), lt(Pe) ? ze(Pe) : _B(t.removed);
                } catch  {}
            }
        }
        wt($.afterSanitizeAttributes, Pe, null);
    }, xt = function St(Pe) {
        let et = null;
        const vt = ct(Pe);
        for(wt($.beforeSanitizeShadowDOM, Pe, null); et = vt.nextNode();)wt($.uponSanitizeShadowNode, et, null), bt(et), Xe(et), et.content instanceof o && St(et.content);
        wt($.afterSanitizeShadowDOM, Pe, null);
    };
    return t.sanitize = function(St) {
        let Pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, et = null, vt = null, be = null, $r = null;
        if (Le = !St, Le && (St = "<!-->"), typeof St != "string" && !mt(St)) if (typeof St.toString == "function") {
            if (St = St.toString(), typeof St != "string") throw Eh("dirty is not a string, aborting");
        } else throw Eh("toString is not a function");
        if (!t.isSupported) return St;
        if (z || Ae(Pe), t.removed = [], typeof St == "string" && (q = !1), q) {
            if (St.nodeName) {
                const kt = Et(St.nodeName);
                if (!L[kt] || he[kt]) throw Eh("root node is forbidden and cannot be sanitized in-place");
            }
        } else if (St instanceof a) et = at("<!---->"), vt = et.ownerDocument.importNode(St, !0), vt.nodeType === Sh.element && vt.nodeName === "BODY" || vt.nodeName === "HTML" ? et = vt : et.appendChild(vt);
        else {
            if (!_e && !Re && !M && // eslint-disable-next-line unicorn/prefer-includes
            St.indexOf("<") === -1) return H && je ? H.createHTML(St) : St;
            if (et = at(St), !et) return _e ? null : je ? K : "";
        }
        et && de && ze(et.firstChild);
        const jt = ct(q ? St : et);
        for(; be = jt.nextNode();)bt(be), Xe(be), be.content instanceof o && xt(be.content);
        if (q) return St;
        if (_e) {
            if (Ie) for($r = G.call(et.ownerDocument); et.firstChild;)$r.appendChild(et.firstChild);
            else $r = et;
            return (ie.shadowroot || ie.shadowrootmode) && ($r = X.call(n, $r, !0)), $r;
        }
        let nr = M ? et.outerHTML : et.innerHTML;
        return M && L["!doctype"] && et.ownerDocument && et.ownerDocument.doctype && et.ownerDocument.doctype.name && zi(gU, et.ownerDocument.doctype.name) && (nr = "<!DOCTYPE " + et.ownerDocument.doctype.name + `>
` + nr), Re && _y([
            S,
            w,
            g
        ], (kt)=>{
            nr = _h(nr, kt, " ");
        }), H && je ? H.createHTML(nr) : nr;
    }, t.setConfig = function() {
        let St = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Ae(St), z = !0;
    }, t.clearConfig = function() {
        Xt = null, z = !1;
    }, t.isValidAttribute = function(St, Pe, et) {
        Xt || Ae({});
        const vt = Et(St), be = Et(Pe);
        return Mt(vt, be, et);
    }, t.addHook = function(St, Pe) {
        typeof Pe == "function" && vh($[St], Pe);
    }, t.removeHook = function(St, Pe) {
        if (Pe !== void 0) {
            const et = Mbe($[St], Pe);
            return et === -1 ? void 0 : Rbe($[St], et, 1)[0];
        }
        return _B($[St]);
    }, t.removeHooks = function(St) {
        $[St] = [];
    }, t.removeAllHooks = function() {
        $ = IB();
    }, t;
}
yU();
var Xbe = [
    {
        name: "US Dollar",
        symbol: "$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "USD",
        namePlural: "US dollars"
    },
    {
        name: "Canadian Dollar",
        symbol: "CA$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "CAD",
        namePlural: "Canadian dollars"
    },
    {
        name: "Euro",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "EUR",
        namePlural: "euros"
    },
    {
        name: "United Arab Emirates Dirham",
        symbol: "AED",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "AED",
        namePlural: "UAE dirhams"
    },
    {
        name: "Afghan Afghani",
        symbol: "Af",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "AFN",
        namePlural: "Afghan Afghanis"
    },
    {
        name: "Albanian Lek",
        symbol: "ALL",
        symbolNative: "Lek",
        decimalDigits: 0,
        rounding: 0,
        code: "ALL",
        namePlural: "Albanian lek"
    },
    {
        name: "Armenian Dram",
        symbol: "AMD",
        symbolNative: ".",
        decimalDigits: 0,
        rounding: 0,
        code: "AMD",
        namePlural: "Armenian drams"
    },
    {
        name: "Argentine Peso",
        symbol: "AR$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "ARS",
        namePlural: "Argentine pesos"
    },
    {
        name: "Australian Dollar",
        symbol: "AU$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "AUD",
        namePlural: "Australian dollars"
    },
    {
        name: "Azerbaijani Manat",
        symbol: "man.",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "AZN",
        namePlural: "Azerbaijani manats"
    },
    {
        name: "Bosnia-Herzegovina Convertible Mark",
        symbol: "KM",
        symbolNative: "KM",
        decimalDigits: 2,
        rounding: 0,
        code: "BAM",
        namePlural: "Bosnia-Herzegovina convertible marks"
    },
    {
        name: "Bangladeshi Taka",
        symbol: "Tk",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "BDT",
        namePlural: "Bangladeshi takas"
    },
    {
        name: "Bulgarian Lev",
        symbol: "BGN",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "BGN",
        namePlural: "Bulgarian leva"
    },
    {
        name: "Bahraini Dinar",
        symbol: "BD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "BHD",
        namePlural: "Bahraini dinars"
    },
    {
        name: "Burundian Franc",
        symbol: "FBu",
        symbolNative: "FBu",
        decimalDigits: 0,
        rounding: 0,
        code: "BIF",
        namePlural: "Burundian francs"
    },
    {
        name: "Brunei Dollar",
        symbol: "BN$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "BND",
        namePlural: "Brunei dollars"
    },
    {
        name: "Bolivian Boliviano",
        symbol: "Bs",
        symbolNative: "Bs",
        decimalDigits: 2,
        rounding: 0,
        code: "BOB",
        namePlural: "Bolivian bolivianos"
    },
    {
        name: "Brazilian Real",
        symbol: "R$",
        symbolNative: "R$",
        decimalDigits: 2,
        rounding: 0,
        code: "BRL",
        namePlural: "Brazilian reals"
    },
    {
        name: "Botswanan Pula",
        symbol: "BWP",
        symbolNative: "P",
        decimalDigits: 2,
        rounding: 0,
        code: "BWP",
        namePlural: "Botswanan pulas"
    },
    {
        name: "Belarusian Ruble",
        symbol: "Br",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "BYN",
        namePlural: "Belarusian rubles"
    },
    {
        name: "Belize Dollar",
        symbol: "BZ$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "BZD",
        namePlural: "Belize dollars"
    },
    {
        name: "Congolese Franc",
        symbol: "CDF",
        symbolNative: "FrCD",
        decimalDigits: 2,
        rounding: 0,
        code: "CDF",
        namePlural: "Congolese francs"
    },
    {
        name: "Swiss Franc",
        symbol: "CHF",
        symbolNative: "CHF",
        decimalDigits: 2,
        rounding: 0.05,
        code: "CHF",
        namePlural: "Swiss francs"
    },
    {
        name: "Chilean Peso",
        symbol: "CL$",
        symbolNative: "$",
        decimalDigits: 0,
        rounding: 0,
        code: "CLP",
        namePlural: "Chilean pesos"
    },
    {
        name: "Chinese Yuan",
        symbol: "CN",
        symbolNative: "CN",
        decimalDigits: 2,
        rounding: 0,
        code: "CNY",
        namePlural: "Chinese yuan"
    },
    {
        name: "Colombian Peso",
        symbol: "CO$",
        symbolNative: "$",
        decimalDigits: 0,
        rounding: 0,
        code: "COP",
        namePlural: "Colombian pesos"
    },
    {
        name: "Costa Rican Coln",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "CRC",
        namePlural: "Costa Rican colns"
    },
    {
        name: "Cape Verdean Escudo",
        symbol: "CV$",
        symbolNative: "CV$",
        decimalDigits: 2,
        rounding: 0,
        code: "CVE",
        namePlural: "Cape Verdean escudos"
    },
    {
        name: "Czech Republic Koruna",
        symbol: "K",
        symbolNative: "K",
        decimalDigits: 2,
        rounding: 0,
        code: "CZK",
        namePlural: "Czech Republic korunas"
    },
    {
        name: "Djiboutian Franc",
        symbol: "Fdj",
        symbolNative: "Fdj",
        decimalDigits: 0,
        rounding: 0,
        code: "DJF",
        namePlural: "Djiboutian francs"
    },
    {
        name: "Danish Krone",
        symbol: "Dkr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "DKK",
        namePlural: "Danish kroner"
    },
    {
        name: "Dominican Peso",
        symbol: "RD$",
        symbolNative: "RD$",
        decimalDigits: 2,
        rounding: 0,
        code: "DOP",
        namePlural: "Dominican pesos"
    },
    {
        name: "Algerian Dinar",
        symbol: "DA",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "DZD",
        namePlural: "Algerian dinars"
    },
    {
        name: "Estonian Kroon",
        symbol: "Ekr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "EEK",
        namePlural: "Estonian kroons"
    },
    {
        name: "Egyptian Pound",
        symbol: "EGP",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "EGP",
        namePlural: "Egyptian pounds"
    },
    {
        name: "Eritrean Nakfa",
        symbol: "Nfk",
        symbolNative: "Nfk",
        decimalDigits: 2,
        rounding: 0,
        code: "ERN",
        namePlural: "Eritrean nakfas"
    },
    {
        name: "Ethiopian Birr",
        symbol: "Br",
        symbolNative: "Br",
        decimalDigits: 2,
        rounding: 0,
        code: "ETB",
        namePlural: "Ethiopian birrs"
    },
    {
        name: "British Pound Sterling",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "GBP",
        namePlural: "British pounds sterling"
    },
    {
        name: "Georgian Lari",
        symbol: "GEL",
        symbolNative: "GEL",
        decimalDigits: 2,
        rounding: 0,
        code: "GEL",
        namePlural: "Georgian laris"
    },
    {
        name: "Ghanaian Cedi",
        symbol: "GH",
        symbolNative: "GH",
        decimalDigits: 2,
        rounding: 0,
        code: "GHS",
        namePlural: "Ghanaian cedis"
    },
    {
        name: "Guinean Franc",
        symbol: "FG",
        symbolNative: "FG",
        decimalDigits: 0,
        rounding: 0,
        code: "GNF",
        namePlural: "Guinean francs"
    },
    {
        name: "Guatemalan Quetzal",
        symbol: "GTQ",
        symbolNative: "Q",
        decimalDigits: 2,
        rounding: 0,
        code: "GTQ",
        namePlural: "Guatemalan quetzals"
    },
    {
        name: "Hong Kong Dollar",
        symbol: "HK$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "HKD",
        namePlural: "Hong Kong dollars"
    },
    {
        name: "Honduran Lempira",
        symbol: "HNL",
        symbolNative: "L",
        decimalDigits: 2,
        rounding: 0,
        code: "HNL",
        namePlural: "Honduran lempiras"
    },
    {
        name: "Croatian Kuna",
        symbol: "kn",
        symbolNative: "kn",
        decimalDigits: 2,
        rounding: 0,
        code: "HRK",
        namePlural: "Croatian kunas"
    },
    {
        name: "Hungarian Forint",
        symbol: "Ft",
        symbolNative: "Ft",
        decimalDigits: 0,
        rounding: 0,
        code: "HUF",
        namePlural: "Hungarian forints"
    },
    {
        name: "Indonesian Rupiah",
        symbol: "Rp",
        symbolNative: "Rp",
        decimalDigits: 0,
        rounding: 0,
        code: "IDR",
        namePlural: "Indonesian rupiahs"
    },
    {
        name: "Israeli New Sheqel",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "ILS",
        namePlural: "Israeli new sheqels"
    },
    {
        name: "Indian Rupee",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "INR",
        namePlural: "Indian rupees"
    },
    {
        name: "Iraqi Dinar",
        symbol: "IQD",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "IQD",
        namePlural: "Iraqi dinars"
    },
    {
        name: "Iranian Rial",
        symbol: "IRR",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "IRR",
        namePlural: "Iranian rials"
    },
    {
        name: "Icelandic Krna",
        symbol: "Ikr",
        symbolNative: "kr",
        decimalDigits: 0,
        rounding: 0,
        code: "ISK",
        namePlural: "Icelandic krnur"
    },
    {
        name: "Jamaican Dollar",
        symbol: "J$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "JMD",
        namePlural: "Jamaican dollars"
    },
    {
        name: "Jordanian Dinar",
        symbol: "JD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "JOD",
        namePlural: "Jordanian dinars"
    },
    {
        name: "Japanese Yen",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "JPY",
        namePlural: "Japanese yen"
    },
    {
        name: "Kenyan Shilling",
        symbol: "Ksh",
        symbolNative: "Ksh",
        decimalDigits: 2,
        rounding: 0,
        code: "KES",
        namePlural: "Kenyan shillings"
    },
    {
        name: "Cambodian Riel",
        symbol: "KHR",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "KHR",
        namePlural: "Cambodian riels"
    },
    {
        name: "Comorian Franc",
        symbol: "CF",
        symbolNative: "FC",
        decimalDigits: 0,
        rounding: 0,
        code: "KMF",
        namePlural: "Comorian francs"
    },
    {
        name: "South Korean Won",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "KRW",
        namePlural: "South Korean won"
    },
    {
        name: "Kuwaiti Dinar",
        symbol: "KD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "KWD",
        namePlural: "Kuwaiti dinars"
    },
    {
        name: "Kazakhstani Tenge",
        symbol: "KZT",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "KZT",
        namePlural: "Kazakhstani tenges"
    },
    {
        name: "Lebanese Pound",
        symbol: "LB",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "LBP",
        namePlural: "Lebanese pounds"
    },
    {
        name: "Sri Lankan Rupee",
        symbol: "SLRs",
        symbolNative: "SL Re",
        decimalDigits: 2,
        rounding: 0,
        code: "LKR",
        namePlural: "Sri Lankan rupees"
    },
    {
        name: "Lithuanian Litas",
        symbol: "Lt",
        symbolNative: "Lt",
        decimalDigits: 2,
        rounding: 0,
        code: "LTL",
        namePlural: "Lithuanian litai"
    },
    {
        name: "Latvian Lats",
        symbol: "Ls",
        symbolNative: "Ls",
        decimalDigits: 2,
        rounding: 0,
        code: "LVL",
        namePlural: "Latvian lati"
    },
    {
        name: "Libyan Dinar",
        symbol: "LD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "LYD",
        namePlural: "Libyan dinars"
    },
    {
        name: "Moroccan Dirham",
        symbol: "MAD",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "MAD",
        namePlural: "Moroccan dirhams"
    },
    {
        name: "Moldovan Leu",
        symbol: "MDL",
        symbolNative: "MDL",
        decimalDigits: 2,
        rounding: 0,
        code: "MDL",
        namePlural: "Moldovan lei"
    },
    {
        name: "Malagasy Ariary",
        symbol: "MGA",
        symbolNative: "MGA",
        decimalDigits: 0,
        rounding: 0,
        code: "MGA",
        namePlural: "Malagasy Ariaries"
    },
    {
        name: "Macedonian Denar",
        symbol: "MKD",
        symbolNative: "MKD",
        decimalDigits: 2,
        rounding: 0,
        code: "MKD",
        namePlural: "Macedonian denari"
    },
    {
        name: "Myanma Kyat",
        symbol: "MMK",
        symbolNative: "K",
        decimalDigits: 0,
        rounding: 0,
        code: "MMK",
        namePlural: "Myanma kyats"
    },
    {
        name: "Macanese Pataca",
        symbol: "MOP$",
        symbolNative: "MOP$",
        decimalDigits: 2,
        rounding: 0,
        code: "MOP",
        namePlural: "Macanese patacas"
    },
    {
        name: "Mauritian Rupee",
        symbol: "MURs",
        symbolNative: "MURs",
        decimalDigits: 0,
        rounding: 0,
        code: "MUR",
        namePlural: "Mauritian rupees"
    },
    {
        name: "Mexican Peso",
        symbol: "MX$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "MXN",
        namePlural: "Mexican pesos"
    },
    {
        name: "Malaysian Ringgit",
        symbol: "RM",
        symbolNative: "RM",
        decimalDigits: 2,
        rounding: 0,
        code: "MYR",
        namePlural: "Malaysian ringgits"
    },
    {
        name: "Mozambican Metical",
        symbol: "MTn",
        symbolNative: "MTn",
        decimalDigits: 2,
        rounding: 0,
        code: "MZN",
        namePlural: "Mozambican meticals"
    },
    {
        name: "Namibian Dollar",
        symbol: "N$",
        symbolNative: "N$",
        decimalDigits: 2,
        rounding: 0,
        code: "NAD",
        namePlural: "Namibian dollars"
    },
    {
        name: "Nigerian Naira",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "NGN",
        namePlural: "Nigerian nairas"
    },
    {
        name: "Nicaraguan Crdoba",
        symbol: "C$",
        symbolNative: "C$",
        decimalDigits: 2,
        rounding: 0,
        code: "NIO",
        namePlural: "Nicaraguan crdobas"
    },
    {
        name: "Norwegian Krone",
        symbol: "Nkr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "NOK",
        namePlural: "Norwegian kroner"
    },
    {
        name: "Nepalese Rupee",
        symbol: "NPRs",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "NPR",
        namePlural: "Nepalese rupees"
    },
    {
        name: "New Zealand Dollar",
        symbol: "NZ$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "NZD",
        namePlural: "New Zealand dollars"
    },
    {
        name: "Omani Rial",
        symbol: "OMR",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "OMR",
        namePlural: "Omani rials"
    },
    {
        name: "Panamanian Balboa",
        symbol: "B/.",
        symbolNative: "B/.",
        decimalDigits: 2,
        rounding: 0,
        code: "PAB",
        namePlural: "Panamanian balboas"
    },
    {
        name: "Peruvian Nuevo Sol",
        symbol: "S/.",
        symbolNative: "S/.",
        decimalDigits: 2,
        rounding: 0,
        code: "PEN",
        namePlural: "Peruvian nuevos soles"
    },
    {
        name: "Philippine Peso",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "PHP",
        namePlural: "Philippine pesos"
    },
    {
        name: "Pakistani Rupee",
        symbol: "PKRs",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "PKR",
        namePlural: "Pakistani rupees"
    },
    {
        name: "Polish Zloty",
        symbol: "z",
        symbolNative: "z",
        decimalDigits: 2,
        rounding: 0,
        code: "PLN",
        namePlural: "Polish zlotys"
    },
    {
        name: "Paraguayan Guarani",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "PYG",
        namePlural: "Paraguayan guaranis"
    },
    {
        name: "Qatari Rial",
        symbol: "QR",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "QAR",
        namePlural: "Qatari rials"
    },
    {
        name: "Romanian Leu",
        symbol: "RON",
        symbolNative: "RON",
        decimalDigits: 2,
        rounding: 0,
        code: "RON",
        namePlural: "Romanian lei"
    },
    {
        name: "Serbian Dinar",
        symbol: "din.",
        symbolNative: ".",
        decimalDigits: 0,
        rounding: 0,
        code: "RSD",
        namePlural: "Serbian dinars"
    },
    {
        name: "Russian Ruble",
        symbol: "RUB",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "RUB",
        namePlural: "Russian rubles"
    },
    {
        name: "Rwandan Franc",
        symbol: "RWF",
        symbolNative: "FR",
        decimalDigits: 0,
        rounding: 0,
        code: "RWF",
        namePlural: "Rwandan francs"
    },
    {
        name: "Saudi Riyal",
        symbol: "SR",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "SAR",
        namePlural: "Saudi riyals"
    },
    {
        name: "Sudanese Pound",
        symbol: "SDG",
        symbolNative: "SDG",
        decimalDigits: 2,
        rounding: 0,
        code: "SDG",
        namePlural: "Sudanese pounds"
    },
    {
        name: "Swedish Krona",
        symbol: "Skr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "SEK",
        namePlural: "Swedish kronor"
    },
    {
        name: "Singapore Dollar",
        symbol: "S$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "SGD",
        namePlural: "Singapore dollars"
    },
    {
        name: "Somali Shilling",
        symbol: "Ssh",
        symbolNative: "Ssh",
        decimalDigits: 0,
        rounding: 0,
        code: "SOS",
        namePlural: "Somali shillings"
    },
    {
        name: "Syrian Pound",
        symbol: "SY",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "SYP",
        namePlural: "Syrian pounds"
    },
    {
        name: "Thai Baht",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "THB",
        namePlural: "Thai baht"
    },
    {
        name: "Tunisian Dinar",
        symbol: "DT",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "TND",
        namePlural: "Tunisian dinars"
    },
    {
        name: "Tongan Paanga",
        symbol: "T$",
        symbolNative: "T$",
        decimalDigits: 2,
        rounding: 0,
        code: "TOP",
        namePlural: "Tongan paanga"
    },
    {
        name: "Turkish Lira",
        symbol: "TL",
        symbolNative: "TL",
        decimalDigits: 2,
        rounding: 0,
        code: "TRY",
        namePlural: "Turkish Lira"
    },
    {
        name: "Trinidad and Tobago Dollar",
        symbol: "TT$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "TTD",
        namePlural: "Trinidad and Tobago dollars"
    },
    {
        name: "New Taiwan Dollar",
        symbol: "NT$",
        symbolNative: "NT$",
        decimalDigits: 2,
        rounding: 0,
        code: "TWD",
        namePlural: "New Taiwan dollars"
    },
    {
        name: "Tanzanian Shilling",
        symbol: "TSh",
        symbolNative: "TSh",
        decimalDigits: 0,
        rounding: 0,
        code: "TZS",
        namePlural: "Tanzanian shillings"
    },
    {
        name: "Ukrainian Hryvnia",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "UAH",
        namePlural: "Ukrainian hryvnias"
    },
    {
        name: "Ugandan Shilling",
        symbol: "USh",
        symbolNative: "USh",
        decimalDigits: 0,
        rounding: 0,
        code: "UGX",
        namePlural: "Ugandan shillings"
    },
    {
        name: "Uruguayan Peso",
        symbol: "$U",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "UYU",
        namePlural: "Uruguayan pesos"
    },
    {
        name: "Uzbekistan Som",
        symbol: "UZS",
        symbolNative: "UZS",
        decimalDigits: 0,
        rounding: 0,
        code: "UZS",
        namePlural: "Uzbekistan som"
    },
    {
        name: "Venezuelan Bolvar",
        symbol: "Bs.F.",
        symbolNative: "Bs.F.",
        decimalDigits: 2,
        rounding: 0,
        code: "VEF",
        namePlural: "Venezuelan bolvars"
    },
    {
        name: "Vietnamese Dong",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "VND",
        namePlural: "Vietnamese dong"
    },
    {
        name: "CFA Franc BEAC",
        symbol: "FCFA",
        symbolNative: "FCFA",
        decimalDigits: 0,
        rounding: 0,
        code: "XAF",
        namePlural: "CFA francs BEAC"
    },
    {
        name: "CFA Franc BCEAO",
        symbol: "CFA",
        symbolNative: "CFA",
        decimalDigits: 0,
        rounding: 0,
        code: "XOF",
        namePlural: "CFA francs BCEAO"
    },
    {
        name: "Yemeni Rial",
        symbol: "YR",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "YER",
        namePlural: "Yemeni rials"
    },
    {
        name: "South African Rand",
        symbol: "R",
        symbolNative: "R",
        decimalDigits: 2,
        rounding: 0,
        code: "ZAR",
        namePlural: "South African rand"
    },
    {
        name: "Zambian Kwacha",
        symbol: "ZK",
        symbolNative: "ZK",
        decimalDigits: 0,
        rounding: 0,
        code: "ZMK",
        namePlural: "Zambian kwachas"
    },
    {
        name: "Zimbabwean Dollar",
        symbol: "ZWL$",
        symbolNative: "ZWL$",
        decimalDigits: 0,
        rounding: 0,
        code: "ZWL",
        namePlural: "Zimbabwean Dollar"
    }
];
new Set(Xbe.map((e)=>e.code));
function BB(e) {
    return typeof e == "number";
}
function Jbe(e) {
    return typeof e > "u";
}
function Qbe(e) {
    return Array.isArray(e) ? e.every((t)=>BB(t)) : BB(e);
}
var e1e = Te.string().array(), t1e = Te.record(Te.string(), Te.unknown());
Te.union([
    e1e,
    t1e,
    Te.undefined()
]);
var rb = Te.object({
    jsonrpc: Te.literal("2.0"),
    id: Te.string()
});
function OB(e, t) {
    return t ? rb.extend({
        method: Te.literal(e),
        params: t
    }) : rb.extend({
        method: Te.literal(e)
    });
}
var c8 = /* @__PURE__ */ ((e)=>(e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.SERVER_ERROR = -32e3] = "SERVER_ERROR", e[e.USER_REJECTION = 4001] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = 4002] = "METHOD_NOT_SUPPORTED", e[e.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", e[e.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", e))(c8 || {}), r1e = Te.nativeEnum(c8);
function n1e(e) {
    return Te.object({
        code: Te.union([
            Te.number(),
            r1e
        ]),
        message: Te.string(),
        data: e.optional()
    });
}
function i1e(e) {
    return rb.extend({
        error: e
    });
}
var o1e = n1e(Te.any());
function s1e(e) {
    return rb.extend({
        result: e
    });
}
function PB(e, t) {
    return Te.union([
        s1e(e),
        i1e(t)
    ]);
}
function ei(e) {
    const t = e.error ?? o1e;
    return "params" in e ? {
        method: e.method,
        params: e.params,
        result: e.result,
        error: t,
        request: OB(e.method, e.params),
        response: PB(e.result, t)
    } : {
        method: e.method,
        result: e.result,
        error: t,
        request: OB(e.method),
        response: PB(e.result, t)
    };
}
var a1e = Te.object({
    account: Te.number().optional(),
    address: Te.string(),
    amount: Te.coerce.string(),
    network: Te.string()
}), c1e = Te.object({
    address: Te.string(),
    amount: Te.coerce.string()
}), u1e = Te.object({
    account: Te.number().optional(),
    recipients: Te.array(c1e),
    network: Te.string()
}), f1e = Te.union([
    a1e,
    u1e
]);
ei({
    method: "sendTransfer",
    params: f1e,
    result: Te.object({
        txid: Te.string()
    })
});
var l1e = Te.enum([
    "legacy",
    "bip322"
]), d1e = Te.enum([
    "p2tr",
    "p2wpkh"
]), h1e = Te.object({
    type: l1e.optional(),
    account: Te.number().optional(),
    message: Te.string(),
    paymentType: d1e
}).passthrough();
ei({
    method: "signMessage",
    params: h1e,
    result: Te.object({
        signature: Te.string(),
        address: Te.string()
    }).passthrough()
});
function p1e(e) {
    return Jbe(e) ? !0 : Qbe(e);
}
var g1e = Te.object({
    account: Te.number().optional(),
    allowedSighash: Te.array(Te.any()).optional(),
    broadcast: Te.boolean().optional(),
    hex: Te.string(),
    network: Te.string().optional(),
    signAtIndex: Te.union([
        Te.number(),
        Te.array(Te.number())
    ]).optional().refine(p1e)
}), y1e = Te.object({
    hex: Te.string(),
    txid: Te.string().optional()
});
ei({
    method: "signPsbt",
    params: g1e,
    result: y1e
});
var m1e = Te.enum([
    "p2pkh",
    "p2sh",
    "p2wpkh-p2sh",
    "p2wpkh",
    "p2tr"
]), mU = Te.object({
    symbol: Te.literal("BTC"),
    type: m1e,
    address: Te.string(),
    publicKey: Te.string(),
    derivationPath: Te.string()
}), b1e = mU.extend({
    type: Te.literal("p2wpkh")
}).passthrough(), w1e = mU.extend({
    type: Te.literal("p2tr"),
    tweakedPublicKey: Te.string()
}).passthrough(), v1e = Te.discriminatedUnion("type", [
    b1e,
    w1e
]), _1e = Te.object({
    symbol: Te.literal("STX"),
    address: Te.string(),
    publicKey: Te.string()
}).passthrough(), E1e = Te.union([
    v1e,
    _1e
]), x1e = Te.object({
    addresses: Te.array(E1e)
}).passthrough();
ei({
    method: "getAddresses",
    params: Te.object({
        network: Te.string().optional()
    }).optional(),
    result: x1e
});
var S1e = Te.object({
    version: Te.string(),
    supportedMethods: Te.array(Te.string()).optional(),
    platform: Te.union([
        Te.literal("mobile"),
        Te.literal("extension")
    ])
});
ei({
    method: "getInfo",
    result: S1e
});
ei({
    method: "open",
    params: Te.object({
        mode: Te.enum([
            "fullpage",
            "popup"
        ])
    }).default({
        mode: "popup"
    }),
    result: Te.object({
        success: Te.literal(!0)
    })
});
var A1e = Te.object({
    base: Te.string(),
    quote: Te.string()
}), T1e = Te.object({
    message: Te.string()
});
ei({
    method: "openSwap",
    params: A1e,
    result: T1e
});
var Vd = Te.object({
    txid: Te.string(),
    transaction: Te.string()
}), O0 = Te.object({
    address: Te.string().optional(),
    network: Te.union([
        Te.literal("mainnet"),
        Te.literal("testnet"),
        Te.literal("regtest"),
        Te.literal("devnet"),
        Te.literal("mocknet"),
        Te.string()
    ]).optional(),
    fee: Te.coerce.number().optional(),
    nonce: Te.coerce.number().optional(),
    // add pc later when imported from stacks.js
    postConditions: Te.array(Te.string()).optional(),
    postConditionMode: Te.union([
        Te.literal("allow"),
        Te.literal("deny")
    ]).optional(),
    sponsored: Te.boolean().optional()
});
ei({
    method: "stx_callContract",
    params: Te.intersection(Te.object({
        contract: Te.string(),
        functionName: Te.string(),
        functionArgs: Te.array(Te.string()).optional()
    }), O0),
    result: Vd
});
var k1e = Vd;
ei({
    method: "stx_deployContract",
    params: Te.intersection(Te.object({
        name: Te.string(),
        clarityCode: Te.string(),
        clarityVersion: Te.coerce.number().optional()
    }), O0),
    result: k1e
});
var I1e = Te.object({
    address: Te.string(),
    publicKey: Te.string(),
    derivationPath: Te.string()
}), B1e = Te.array(I1e);
ei({
    method: "stx_getAddresses",
    params: Te.object({
        network: Te.string().optional()
    }).optional(),
    result: B1e
});
ei({
    method: "stx_getNetworks",
    result: Te.object({
        active: Te.string(),
        networks: Te.array(Te.object({
            id: Te.string(),
            chainId: Te.string(),
            transactionVersion: Te.string()
        }).passthrough())
    })
});
var O1e = Te.enum([
    "utf8",
    "structured"
]), bU = Te.object({
    messageType: O1e.optional().default("utf8"),
    network: Te.optional(Te.enum([
        "mainnet",
        "testnet",
        "devnet",
        "mocknet"
    ]))
}), P1e = bU.merge(Te.object({
    messageType: Te.literal("utf8").default("utf8"),
    message: Te.string()
})), N1e = bU.merge(Te.object({
    messageType: Te.literal("structured"),
    domain: Te.string(),
    message: Te.string()
}));
ei({
    method: "stx_signMessage",
    params: Te.union([
        P1e,
        N1e
    ]),
    result: Te.object({
        signature: Te.string(),
        publicKey: Te.string()
    })
});
ei({
    method: "stx_signStructuredMessage",
    params: Te.object({
        domain: Te.string(),
        message: Te.string()
    }),
    result: Te.object({
        signature: Te.string(),
        publicKey: Te.string()
    })
});
var M1e = Te.object({
    txHex: Te.string(),
    stxAddress: Te.string().optional(),
    attachment: Te.string().optional(),
    accountIndex: Te.string().optional(),
    network: Te.string().optional()
}), R1e = Te.object({
    transaction: Te.string(),
    network: Te.string().optional()
});
ei({
    method: "stx_signTransaction",
    params: Te.union([
        M1e,
        R1e
    ]),
    result: Te.object({
        transaction: Te.string(),
        txHex: Te.string()
    })
});
ei({
    method: "stx_transferSip9Nft",
    params: Te.intersection(Te.object({
        recipient: Te.string(),
        asset: Te.string(),
        assetId: Te.string()
    }).passthrough(), O0),
    result: Vd
});
ei({
    method: "stx_transferSip10Ft",
    params: Te.intersection(Te.object({
        recipient: Te.string(),
        asset: Te.string(),
        amount: Te.coerce.number()
    }).passthrough(), O0),
    result: Vd
});
ei({
    method: "stx_transferStx",
    params: Te.intersection(Te.object({
        recipient: Te.string(),
        amount: Te.coerce.number().int("Amount must be an integer describing STX"),
        memo: Te.string().optional()
    }).passthrough(), O0),
    result: Vd
});
var C1e = Te.object({
    // schema.org/Person
    person: Te.object({}).passthrough()
}), U1e = Vd;
ei({
    method: "stx_updateProfile",
    params: C1e,
    result: U1e
});
var $1e = Te.object({
    name: Te.string(),
    docsUrl: Te.union([
        Te.string(),
        Te.array(Te.string())
    ])
});
ei({
    method: "supportedMethods",
    result: Te.object({
        documentation: Te.string(),
        methods: Te.array($1e)
    })
});
var L1e = Te.object({
    type: Te.literal("int"),
    value: Te.coerce.string()
}), D1e = Te.object({
    type: Te.literal("uint"),
    value: Te.coerce.string()
}), F1e = Te.object({
    type: Te.literal("buffer"),
    value: Te.string()
}), z1e = Te.object({
    type: Te.literal("true")
}), j1e = Te.object({
    type: Te.literal("false")
}), H1e = Te.object({
    type: Te.literal("address"),
    value: Te.string()
}), q1e = Te.object({
    type: Te.literal("contract"),
    value: Te.string().refine((e)=>e.includes("."), {
        message: "Stacks contract principals are denoted with a dot"
    })
}), K1e = Te.object({
    type: Te.literal("ascii"),
    value: Te.string()
}), W1e = Te.object({
    type: Te.literal("utf8"),
    value: Te.string()
}), V1e = Te.object({
    type: Te.literal("ok"),
    value: Te.lazy(()=>P0)
}).transform((e)=>e), G1e = Te.object({
    type: Te.literal("err"),
    value: Te.lazy(()=>P0)
}), Z1e = Te.object({
    type: Te.literal("none")
}), Y1e = Te.object({
    type: Te.literal("some"),
    value: Te.lazy(()=>P0)
}), X1e = Te.object({
    type: Te.literal("list"),
    value: Te.array(Te.lazy(()=>P0))
}), J1e = Te.object({
    type: Te.literal("tuple"),
    value: Te.record(Te.lazy(()=>P0))
}), P0 = Te.union([
    L1e,
    D1e,
    F1e,
    z1e,
    j1e,
    H1e,
    q1e,
    V1e,
    G1e,
    Z1e,
    Y1e,
    X1e,
    J1e,
    K1e,
    W1e
]);
let NB = (e)=>e, Ph = {}, tu = {
    addEventListener () {},
    removeEventListener () {}
};
function Q1e() {
    try {
        return typeof localStorage < "u";
    } catch  {
        return !1;
    }
}
Q1e() && (Ph = localStorage);
let ewe = {
    addEventListener (e, t, r) {
        window.addEventListener("storage", t), window.addEventListener("pageshow", r);
    },
    removeEventListener (e, t, r) {
        window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
    }
};
("TURBOPACK compile-time value", "undefined") < "u" && (tu = ewe);
function Kf(e, t = {}, r = {}) {
    let n = r.encode || NB, i = r.decode || NB, o = J7(), s = o.setKey, a = (l, p)=>{
        typeof p > "u" ? (r.listen !== !1 && tu.perKey && tu.removeEventListener(e + l, f, c), delete Ph[e + l]) : (r.listen !== !1 && tu.perKey && !(l in o.value) && tu.addEventListener(e + l, f, c), Ph[e + l] = n(p));
    };
    o.setKey = (l, p)=>{
        a(l, p), s(l, p);
    };
    let u = o.set;
    o.set = function(l) {
        for(let p in l)a(p, l[p]);
        for(let p in o.value)p in l || a(p, void 0);
        u(l);
    };
    function f(l) {
        l.key ? l.key.startsWith(e) && (l.newValue === null ? s(l.key.slice(e.length), void 0) : s(l.key.slice(e.length), i(l.newValue))) : u({});
    }
    function c() {
        let l = {
            ...t
        };
        for(let p in Ph)p.startsWith(e) && (l[p.slice(e.length)] = i(Ph[p]));
        for(let p in l)o.setKey(p, l[p]);
    }
    return aG(o, ()=>{
        if (c(), r.listen !== !1) return tu.addEventListener(e, f, c), ()=>{
            tu.removeEventListener(e, f, c);
            for(let l in o.value)tu.removeEventListener(e + l, f, c);
        };
    }), o;
}
function twe(e) {
    ("TURBOPACK compile-time value", "undefined") < "u" && typeof localStorage < "u" && setTimeout(()=>{
        const t = document.createTextNode(" ");
        document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
    }, 1500);
}
function a_e() {
    return {
        $store: J7({
            provider: void 0,
            address: "",
            paymentAddress: "",
            publicKey: "",
            paymentPublicKey: "",
            connected: !1,
            isConnecting: !1,
            isInitializing: !0,
            accounts: [],
            balance: void 0,
            hasProvider: {
                [Rh]: !1,
                [Bl]: !1,
                [ru]: !1,
                [Ch]: !1,
                [Nl]: !1,
                [Qu]: !1,
                [Il]: !1,
                [Ml]: !0,
                [$h]: !1,
                [Pl]: !1,
                [Uh]: !1,
                [Ol]: !1,
                [Rl]: !1
            }
        }),
        $network: NE(ln),
        $library: NE(void 0)
    };
}
function c_e(e) {
    if (e) return {
        ...e
    };
}
const Nu = [
    "address",
    "paymentAddress",
    "publicKey",
    "paymentPublicKey",
    "balance"
];
function Wf(e, t, r, n) {
    var i, o, s;
    t.provider === e && (r ? r === "balance" ? n.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : Nu.includes(r) && n.setKey(r, ((o = t[r]) == null ? void 0 : o.toString()) ?? "") : n.set({
        address: t.address,
        paymentAddress: t.paymentAddress,
        paymentPublicKey: t.paymentPublicKey,
        publicKey: t.publicKey,
        balance: ((s = t.balance) == null ? void 0 : s.toString()) ?? ""
    }));
}
const rwe = (e)=>{
    const t = e.match(/.{1,2}/g);
    if (!t) throw new Error("Invalid hex string");
    return Uint8Array.from(t.map((r)=>Number.parseInt(r, 16)));
}, nwe = "LEATHER_CONNECTED_WALLET_STATE";
class iwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(nwe, {
            address: "",
            publicKey: "",
            paymentAddress: "",
            paymentPublicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        return window == null ? void 0 : window.LeatherProvider;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Rh, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n;
            (window == null ? void 0 : window.LeatherProvider) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Rh]: !0
            }), (n = this.observer) == null || n.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Rh ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        var f;
        const { address: n, paymentAddress: i } = this.$valueStore.get();
        if (n) if (n.startsWith("tb1") && qb(this.network)) this.disconnect();
        else {
            this.restorePersistedValues(), id(i, this.network).then((c)=>{
                this.$store.setKey("balance", c);
            });
            return;
        }
        if (!this.library) throw new Error("Leather isn't installed");
        const o = (await this.library.request("getAddresses", {
            network: ((f = this.config) == null ? void 0 : f.network) ?? this.network
        })).result.addresses;
        if (!o) throw new Error("No accounts found");
        const s = o.map((c)=>c.address), a = o.find((c)=>c.type === df), u = o.find((c)=>c.type === Ay);
        if (!(a != null && a.publicKey) || !(u != null && u.publicKey)) throw new Error("No accounts found");
        this.$store.setKey("accounts", s), this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", u.address), this.$store.setKey("publicKey", a.publicKey), this.$store.setKey("paymentPublicKey", u.publicKey);
    }
    async getNetwork() {
        return this.network;
    }
    async switchNetwork(r) {
        if (r !== this.network) {
            if (!this.library) throw new Error("Leather isn't installed");
            const n = (await this.library.request("getAddresses", {
                network: r
            })).result.addresses;
            if (!n) throw new Error("Failed to get new network details");
            const i = n.map((a)=>a.address), o = n.find((a)=>a.type === df), s = n.find((a)=>a.type === Ay);
            if (!(o != null && o.publicKey) || !(s != null && s.publicKey)) throw new Error("Failed to get new network details");
            this.$store.setKey("accounts", i), this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", s.address), this.$store.setKey("publicKey", o.publicKey), this.$store.setKey("paymentPublicKey", s.publicKey), this.$network.set(r);
        }
    }
    async sendBTC(r, n) {
        var i, o;
        try {
            const s = await ((i = this.library) == null ? void 0 : i.request("sendTransfer", {
                recipients: [
                    {
                        address: r,
                        amount: String(n)
                    }
                ],
                network: this.network
            }));
            if (s != null && s.result.txid) return s == null ? void 0 : s.result.txid;
            throw new Error("Error sending BTC");
        } catch (s) {
            if ((o = s.error) != null && o.code) {
                const a = s.error;
                throw a.code === c8.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error sending BTC: ${a.message}`);
            }
            throw new Error("Error sending BTC");
        }
    }
    async signMessage(r, n) {
        var u, f;
        const i = n == null ? void 0 : n.toSignAddress;
        if ((n == null ? void 0 : n.protocol) === f0) throw new Error("Leather doesn't support ECDSA message signing");
        const s = i === this.$store.get().address ? df : Ay;
        if (i !== this.$store.get().address && i !== this.$store.get().paymentAddress) throw new Error("Invalid address to sign message");
        const a = await ((u = this.library) == null ? void 0 : u.request("signMessage", {
            message: r,
            paymentType: s
        }));
        return ((f = a == null ? void 0 : a.result) == null ? void 0 : f.signature) ?? "";
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var l;
        const s = {
            hex: r,
            broadcast: !1,
            network: this.network,
            signAtIndex: o == null ? void 0 : o.map((p)=>p.index)
        }, a = await ((l = this.library) == null ? void 0 : l.request("signPsbt", s));
        if (!a) throw new Error("No response from Leather");
        const f = a.result.hex, c = Cr.fromHex(String(f));
        if (i && n) {
            const p = c.finalizeAllInputs(), y = await this.pushPsbt(p.toHex());
            return {
                signedPsbtHex: c.toHex(),
                signedPsbtBase64: c.toBase64(),
                txId: y
            };
        }
        if (i) {
            const p = c.finalizeAllInputs();
            return {
                signedPsbtHex: p.toHex(),
                signedPsbtBase64: p.toBase64(),
                txId: void 0
            };
        }
        return {
            signedPsbtHex: c.toHex(),
            signedPsbtBase64: c.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async getBalance() {
        const r = await id(this.$store.get().paymentAddress, this.network);
        return this.$store.setKey("balance", r), r.toString();
    }
    async requestAccounts() {
        var a;
        const { accounts: r } = this.$store.get();
        if (r.length > 0) return r;
        const n = await ((a = this.library) == null ? void 0 : a.request("getAddresses", {
            network: this.network
        }));
        if (!n) throw new Error("No accounts found");
        const s = n.result.addresses.map((u)=>u.address);
        return this.$store.setKey("accounts", s), s;
    }
}
const owe = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
class swe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(owe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.magicEden) == null ? void 0 : r.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu){
            if (n === "balance") {
                this.$store.setKey(n, BigInt(r[n]));
                continue;
            }
            this.$store.setKey(n, r[n]);
        }
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(ru, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n, i;
            ((n = window == null ? void 0 : window.magicEden) == null ? void 0 : n.bitcoin) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [ru]: !0
            }), (i = this.observer) == null || i.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== ru ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect() {
        const { address: r, paymentAddress: n } = this.$valueStore.get();
        if (r) if (r.startsWith("tb1") && qb(this.network)) this.disconnect();
        else {
            id(n, this.network).then((s)=>{
                this.$store.setKey("balance", s);
            }), this.restorePersistedValues();
            return;
        }
        if (LP(this.network)) throw new Error(`${this.network} is not supported by ${ru}`);
        const i = d_(this.network || ln);
        await AJ({
            getProvider: async ()=>this.library,
            payload: {
                purposes: [
                    "ordinals",
                    "payment"
                ],
                message: "Connecting with lasereyes",
                network: {
                    type: i
                }
            },
            onFinish: (s)=>{
                const a = um(s.addresses), u = fm(s.addresses);
                if (!a || !u) throw new Error("No address found");
                a && u && (this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", u.address), this.$store.setKey("accounts", s.addresses.map((f)=>f.address))), this.$store.setKey("publicKey", String(s.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(s.addresses[1].publicKey));
            },
            onCancel: ()=>{
                throw new Error(`User canceled lasereyes to ${ru} wallet`);
            },
            onError: ()=>{
                throw new Error(`Can't lasereyes to ${ru} wallet`);
            }
        });
    }
    async sendBTC(r, n) {
        let i;
        if (await qQ({
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: d_(this.network)
                },
                recipients: [
                    {
                        address: r,
                        amountSats: BigInt(n)
                    }
                ],
                senderAddress: this.$store.get().paymentAddress
            },
            onFinish: (o)=>{
                i = o;
            },
            onCancel: ()=>{
                throw console.error("Request canceled"), new Error("User canceled the request");
            }
        }), !i || !i.txid) throw new Error("Error sending BTC");
        return i.txid;
    }
    async signMessage(r, n) {
        const i = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress;
        let o = "";
        return await jQ({
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: Mn.Mainnet
                },
                address: i,
                message: r,
                protocol: (n == null ? void 0 : n.protocol) === f0 ? _f.ECDSA : _f.BIP322
            },
            onFinish: (s)=>{
                o = s;
            },
            onCancel: ()=>{
                throw console.error("Request canceled"), new Error("User canceled the request");
            }
        }), o;
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const s = Cr.fromBase64(String(r), {
            network: Dr(this.network)
        }), a = s.data.inputs;
        let u = [];
        if (o) {
            const A = o.reduce((O, N)=>({
                    ...O,
                    [N.address]: [
                        ...O[N.address] || [],
                        N.index
                    ]
                }), {});
            u = Object.entries(A).map(([O, N])=>({
                    address: O,
                    signingIndexes: N
                }));
        } else {
            const { address: A, paymentAddress: O } = this.$store.get(), N = {
                address: A,
                signingIndexes: []
            }, U = {
                address: O,
                signingIndexes: []
            };
            for (const D of a.keys()){
                const H = a[D];
                if (H.witnessUtxo === void 0) {
                    U.signingIndexes.push(Number(D));
                    continue;
                }
                const { script: K } = H.witnessUtxo, re = Yp(K, Dr(this.network));
                re === O ? (U.signingIndexes.push(Number(D)), H.sighashType && (console.log("Updating sigHash for paymentsAddressData"), U.sigHash = H.sighashType)) : re === A && (N.signingIndexes.push(Number(D)), H.sighashType && (console.log("Updating sigHash for ordinalAddressData"), N.sigHash = H.sighashType));
            }
            N.signingIndexes.length > 0 && u.push(N), U.signingIndexes.length > 0 && u.push(U);
        }
        let f, c, l, p;
        const y = d_(this.network), _ = {
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: y
                },
                message: "Sign Transaction",
                psbtBase64: s.toBase64(),
                broadcast: n,
                inputsToSign: u
            },
            onFinish: async (A)=>{
                A.psbtBase64 && (p = Cr.fromBase64(String(A.psbtBase64), {
                    network: Dr(this.network)
                }), c = p.toHex(), l = p.toBase64());
            },
            onCancel: ()=>{
                throw console.log("Canceled"), new Error("User canceled the request");
            },
            onError: (A)=>{
                throw console.log("error", A), A;
            }
        };
        if (await KQ(_), !p) throw new Error("signature failed");
        return i || n ? (p.finalizeAllInputs(), {
            signedPsbtHex: p.toHex(),
            signedPsbtBase64: l,
            txId: f
        }) : {
            signedPsbtHex: c,
            signedPsbtBase64: l,
            txId: f
        };
    }
}
const awe = "OKX_CONNECTED_WALLET_STATE";
class cwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(awe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var n, i;
        let r;
        return this.network === Ni || this.network === ao || this.network === Ro || this.network === co ? r = (n = window == null ? void 0 : window.okxwallet) == null ? void 0 : n.bitcoinTestnet : (this.network === ln || this.network === yc) && (r = (i = window == null ? void 0 : window.okxwallet) == null ? void 0 : i.bitcoin), r;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Ch, r, i, this.$valueStore);
    }
    initialize() {
        var r;
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var i;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ch]: !0
            }), (i = this.observer) == null || i.disconnect());
        }), (r = this.observer) == null || r.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (n)=>{
            n.provider !== Ch ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        const { address: n, paymentAddress: i } = this.$valueStore.get();
        if (n) if (n.startsWith("tb1") && qb(this.network)) this.disconnect();
        else {
            this.restorePersistedValues(), id(i, this.network).then((o)=>{
                this.$store.setKey("balance", o);
            });
            return;
        }
        try {
            const o = await this.library.connect();
            if (!o) throw new Error("No accounts found");
            this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", o.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("accounts", [
                o.address
            ]);
        } catch (o) {
            throw o;
        }
    }
    async requestAccounts() {
        const r = this.library, n = this.network;
        return n === Ni || n === ao || n === co ? await r.connect() : await r.requestAccounts();
    }
    async getNetwork() {
        const { address: r } = this.$store.get(), n = this.network;
        if (r.slice(0, 1) === "t") return n === Ni ? Ni : n === ao ? ao : n === Ro ? Ro : n === co ? co : Ni;
        const i = await this.library.getNetwork();
        return ZQ(i);
    }
    async getPublicKey() {
        const r = this.library;
        return await (r == null ? void 0 : r.getPublicKey());
    }
    async getInscriptions(r, n) {
        const i = r || 0, o = n || 10;
        return (await this.library.getInscriptions(i, o)).list.map((u)=>Kl(u, void 0, this.network));
    }
    async sendBTC(r, n) {
        const o = await this.library.sendBitcoin(r, n);
        if (!o) throw new Error("Transaction failed");
        return o;
    }
    async signMessage(r, n) {
        const i = this.library, o = (n == null ? void 0 : n.protocol) === f0 ? l0 : n == null ? void 0 : n.protocol;
        return await (i == null ? void 0 : i.signMessage(r, o));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const a = await this.library.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        })), u = Cr.fromHex(a);
        if (i && n) {
            const f = await this.pushPsbt(a);
            return {
                signedPsbtHex: u.toHex(),
                signedPsbtBase64: u.toBase64(),
                txId: f
            };
        }
        return {
            signedPsbtHex: u.toHex(),
            signedPsbtBase64: u.toBase64(),
            txId: void 0
        };
    }
}
class uwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        return window == null ? void 0 : window.opnet;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Nl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            if (r.provider !== Nl) {
                this.removeListeners();
                return;
            }
            this.library.getAccounts().then((n)=>{
                this.handleAccountsChanged(n);
            }), this.addListeners();
        });
    }
    addListeners() {
        var r, n;
        (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var r, n;
        !this.library || !this.library.removeListener || ((r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Nl) : this.parent.disconnect());
    }
    handleNetworkChanged(r) {
        const n = om(r);
        this.network !== n && this.switchNetwork(n), this.parent.connect(Nl);
    }
    async connect(r) {
        if (!this.library) throw new Error("OP_NET isn't installed");
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        const i = await this.library.getPublicKey();
        if (!i) throw new Error("No public key found");
        this.$store.setKey("accounts", n), this.$store.setKey("address", n[0]), this.$store.setKey("paymentAddress", n[0]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i), await this.getNetwork().then((o)=>{
            var s;
            ((s = this.config) == null ? void 0 : s.network) !== o && this.switchNetwork(o);
        });
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getChain());
        return r ? om(r.enum) : this.network;
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (!i) throw new Error("Transaction failed");
        return i;
    }
    async signMessage(r, n) {
        var o;
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await ((o = this.library) == null ? void 0 : o.signMessage(r, i));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var u;
        const s = await ((u = this.library) == null ? void 0 : u.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        }))), a = Cr.fromHex(s);
        if (i && n) {
            const f = await this.pushPsbt(s);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: f
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(r, n) {
        return await this.library.getInscriptions(r, n);
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async switchNetwork(r) {
        var i;
        const n = fP(r);
        await ((i = this.library) == null ? void 0 : i.switchChain(n)), this.$network.set(r);
    }
}
var Jh = {}, wU = {}, Hs = {}, vU = {};
Object.defineProperty(vU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
    async function n(s) {
        var u, f;
        if (s) {
            const c = await s();
            if (c) return c;
        }
        const a = window.OrangeBitcoinProvider || ((u = window.OrangecryptoProviders) == null ? void 0 : u.BitcoinProvider) || ((f = window.OrangeWalletProviders) == null ? void 0 : f.OrangeBitcoinProvider);
        if (!a) throw new Error("No Orange Bitcoin wallet installed");
        return a;
    }
    e.getProviderOrThrow = n;
    function i() {
        return window.btc_providers || (window.btc_providers = []), window.btc_providers;
    }
    e.getProviders = i;
    function o(s) {
        var a;
        if (Array.isArray(window.btc_providers)) {
            const u = window.btc_providers.find((f)=>f.id === s);
            return (a = u == null ? void 0 : u.id) == null ? void 0 : a.split(".").reduce((f, c)=>f == null ? void 0 : f[c], window);
        } else {
            console.log("window.btc_providers is not defined or not an array");
            return;
        }
    }
    e.getProviderById = o, r(vU, e);
})(Hs);
var _U = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.AddressType = e.AddressPurpose = void 0, function(t) {
        t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
    }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
        t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
    }(e.AddressType || (e.AddressType = {}));
})(_U);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getAddress = void 0;
    const n = Lo, i = Hs, o = async (s)=>{
        var f, c;
        const a = await (0, i.getProviderOrThrow)(s.getProvider), { purposes: u } = s.payload;
        if (!u) throw new Error("Address purposes are required");
        try {
            const l = (0, n.createUnsecuredToken)(s.payload), p = await a.connect(l);
            (f = s.onFinish) == null || f.call(s, p);
        } catch (l) {
            console.error("[Connect] Error during address request", l), (c = s.onCancel) == null || c.call(s);
        }
    };
    e.getAddress = o, r(_U, e);
})(wU);
var EU = {}, xU = {}, SU = {};
Object.defineProperty(SU, "__esModule", {
    value: !0
});
var AU = {};
Object.defineProperty(AU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(SU, e), r(AU, e);
})(xU);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.request = void 0;
    const n = Hs, i = async (s, a, u)=>{
        var l;
        let f = ((l = window.OrangecryptoProviders) == null ? void 0 : l.BitcoinProvider) || window.OrangeBitcoinProvider;
        if (u && (f = await (0, n.getProviderById)(u)), !f) throw new Error("no wallet provider was found");
        if (!s) throw new Error("A wallet method is required");
        const c = await f.request(s, a);
        return o(c) ? {
            status: "success",
            result: c.result
        } : {
            status: "error",
            error: c.error
        };
    };
    e.request = i;
    const o = (s)=>Object.hasOwn(s, "result") && !!s.result;
    r(xU, e);
})(EU);
var TU = {}, kU = {};
Object.defineProperty(kU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(a, u, f, c) {
        c === void 0 && (c = f);
        var l = Object.getOwnPropertyDescriptor(u, f);
        (!l || ("get" in l ? !u.__esModule : l.writable || l.configurable)) && (l = {
            enumerable: !0,
            get: function() {
                return u[f];
            }
        }), Object.defineProperty(a, c, l);
    } : function(a, u, f, c) {
        c === void 0 && (c = f), a[c] = u[f];
    }), r = Ge && Ge.__exportStar || function(a, u) {
        for(var f in a)f !== "default" && !Object.prototype.hasOwnProperty.call(u, f) && t(u, a, f);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getCapabilities = void 0;
    const n = Lo, i = Hs, o = (a, u)=>{
        const f = (l)=>!(!a[l] || u && !u.has(l)), c = {
            request: f("request"),
            connect: f("connect"),
            signMessage: f("signMessage"),
            signTransaction: f("signTransaction"),
            sendBtcTransaction: f("sendBtcTransaction"),
            signMultipleTransactions: f("signMultipleTransactions")
        };
        return Object.entries(c).reduce((l, [p, y])=>y ? [
                ...l,
                p
            ] : l, []);
    }, s = async (a)=>{
        var c, l, p;
        const u = await (0, i.getProviderOrThrow)(a.getProvider), f = (0, n.createUnsecuredToken)(a.payload);
        if (u.getCapabilities) try {
            const y = await u.getCapabilities(f);
            (c = a.onFinish) == null || c.call(a, o(u, new Set(y)));
        } catch (y) {
            console.error("[Connect] Error during capabilities request", y);
        }
        try {
            const y = o(u);
            (l = a.onFinish) == null || l.call(a, y);
        } catch (y) {
            console.error("[Connect] Error during capabilities request", y), (p = a.onCancel) == null || p.call(a);
        }
    };
    e.getCapabilities = s, r(kU, e);
})(TU);
var IU = {}, A1 = {}, N0 = {};
Object.defineProperty(N0, "__esModule", {
    value: !0
});
N0.validateInscriptionPayload = void 0;
const fwe = 4e5, lwe = 6e4, dwe = (e)=>{
    const { contentType: t, content: r, payloadType: n, network: i, appFeeAddress: o, appFee: s } = e;
    if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t)) throw new Error("Invalid content type detected");
    if (!r || r.length === 0) throw new Error("Empty content not allowed");
    if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT") throw new Error("Empty invalid payloadType specified");
    if (r.length > (i.type === "Mainnet" ? fwe : lwe)) throw new Error("Content too large");
    if (((o == null ? void 0 : o.length) ?? 0) > 0 && (s ?? 0) <= 0) throw new Error("Invalid combination of app fee address and fee provided");
};
N0.validateInscriptionPayload = dwe;
Object.defineProperty(A1, "__esModule", {
    value: !0
});
A1.createInscription = void 0;
const hwe = Lo, pwe = Hs, gwe = N0, ywe = async (e)=>{
    var n, i;
    const { getProvider: t } = e, r = await (0, pwe.getProviderOrThrow)(t);
    (0, gwe.validateInscriptionPayload)(e.payload);
    try {
        const o = (0, hwe.createUnsecuredToken)(e.payload);
        if (r.createInscription) {
            const s = await r.createInscription(o);
            (n = e.onFinish) == null || n.call(e, s);
        }
    } catch (o) {
        console.error("[Connect] Error during create inscription", o), (i = e.onCancel) == null || i.call(e);
    }
};
A1.createInscription = ywe;
var T1 = {};
Object.defineProperty(T1, "__esModule", {
    value: !0
});
T1.createRepeatInscriptions = void 0;
const mwe = Hs, bwe = Lo, wwe = N0, vwe = async (e)=>{
    var n, i;
    const { getProvider: t } = e, r = await (0, mwe.getProviderOrThrow)(t);
    (0, wwe.validateInscriptionPayload)(e.payload);
    try {
        const o = (0, bwe.createUnsecuredToken)(e.payload);
        if (r.createRepeatInscriptions) {
            const s = await r.createRepeatInscriptions(o);
            (n = e.onFinish) == null || n.call(e, s);
        }
    } catch (o) {
        console.error("[Connect] Error during create repeat inscriptions", o), (i = e.onCancel) == null || i.call(e);
    }
};
T1.createRepeatInscriptions = vwe;
var BU = {};
Object.defineProperty(BU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(A1, e), r(T1, e), r(BU, e);
})(IU);
var OU = {}, PU = {};
Object.defineProperty(PU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(s, a, u, f) {
        f === void 0 && (f = u);
        var c = Object.getOwnPropertyDescriptor(a, u);
        (!c || ("get" in c ? !a.__esModule : c.writable || c.configurable)) && (c = {
            enumerable: !0,
            get: function() {
                return a[u];
            }
        }), Object.defineProperty(s, f, c);
    } : function(s, a, u, f) {
        f === void 0 && (f = u), s[f] = a[u];
    }), r = Ge && Ge.__exportStar || function(s, a) {
        for(var u in s)u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.signMessage = void 0;
    const n = Lo, i = Hs, o = async (s)=>{
        var c, l;
        const a = await (0, i.getProviderOrThrow)(s.getProvider), { address: u, message: f } = s.payload;
        if (!u) throw new Error("An address is required to sign a message");
        if (!f) throw new Error("A message to be signed is required");
        try {
            const p = (0, n.createUnsecuredToken)(s.payload), y = await a.signMessage(p);
            (c = s.onFinish) == null || c.call(s, y);
        } catch (p) {
            console.error("[Connect] Error during sign message request", p), (l = s.onCancel) == null || l.call(s);
        }
    };
    e.signMessage = o, r(PU, e);
})(OU);
var NU = {}, k1 = {};
Object.defineProperty(k1, "__esModule", {
    value: !0
});
k1.sendBtcTransaction = void 0;
const _we = Lo, Ewe = Hs, xwe = (e)=>e.map((t)=>{
        const { address: r, amountSats: n } = t;
        return {
            address: r,
            amountSats: n.toString()
        };
    }), Swe = async (e)=>{
    var s, a;
    const t = await (0, Ewe.getProviderOrThrow)(e.getProvider), { recipients: r, senderAddress: n, network: i, message: o } = e.payload;
    if (!r || r.length === 0) throw new Error("At least one recipient is required");
    if (r.some((u)=>typeof u.address != "string" || typeof u.amountSats != "bigint")) throw new Error("Incorrect recipient format");
    if (!n) throw new Error("The sender address is required");
    try {
        const u = xwe(r), f = {
            network: i,
            senderAddress: n,
            message: o,
            recipients: u
        }, c = (0, _we.createUnsecuredToken)(f), l = await t.sendBtcTransaction(c);
        (s = e.onFinish) == null || s.call(e, l);
    } catch (u) {
        console.error("[Connect] Error during send BTC transaction request", u), (a = e.onCancel) == null || a.call(e);
    }
};
k1.sendBtcTransaction = Swe;
var I1 = {};
Object.defineProperty(I1, "__esModule", {
    value: !0
});
I1.signTransaction = void 0;
const Awe = Lo, Twe = Hs, kwe = async (e)=>{
    var i, o;
    const t = await (0, Twe.getProviderOrThrow)(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
    if (!r) throw new Error("A value for psbtBase64 representing the tx hash is required");
    if (!n) throw new Error("An array specifying the inputs to be signed by the wallet is required");
    try {
        const s = (0, Awe.createUnsecuredToken)(e.payload), a = await t.signTransaction(s);
        (i = e.onFinish) == null || i.call(e, a);
    } catch (s) {
        console.error("[Connect] Error during sign transaction request", s), (o = e.onCancel) == null || o.call(e);
    }
};
I1.signTransaction = kwe;
var B1 = {};
Object.defineProperty(B1, "__esModule", {
    value: !0
});
B1.signMultipleTransactions = void 0;
const Iwe = Lo, Bwe = Hs, Owe = async (e)=>{
    var n, i;
    const t = await (0, Bwe.getProviderOrThrow)(e.getProvider), { psbts: r } = e.payload;
    if (!r || !r.length) throw new Error("psbts array is required");
    if (r.length > 100) throw new Error("psbts array must contain less than 100 psbts");
    try {
        const o = (0, Iwe.createUnsecuredToken)(e.payload), s = await t.signMultipleTransactions(o);
        (n = e.onFinish) == null || n.call(e, s);
    } catch (o) {
        console.error("[Connect] Error during sign Multiple transactions request", o), (i = e.onCancel) == null || i.call(e);
    }
};
B1.signMultipleTransactions = Owe;
var MU = {};
Object.defineProperty(MU, "__esModule", {
    value: !0
});
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(k1, e), r(I1, e), r(B1, e), r(MU, e);
})(NU);
var RU = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
        t.Mainnet = "Mainnet", t.Testnet = "Testnet";
    }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
        t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
    }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(RU);
(function(e) {
    var t = Ge && Ge.__createBinding || (Object.create ? function(n, i, o, s) {
        s === void 0 && (s = o);
        var a = Object.getOwnPropertyDescriptor(i, o);
        (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
            enumerable: !0,
            get: function() {
                return i[o];
            }
        }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
        s === void 0 && (s = o), n[s] = i[o];
    }), r = Ge && Ge.__exportStar || function(n, i) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(wU, e), r(EU, e), r(TU, e), r(IU, e), r(OU, e), r(Hs, e), r(NU, e), r(RU, e);
})(Jh);
const Jl = /* @__PURE__ */ c7(Jh), Pwe = Jl == null ? void 0 : Jl.signMessage, Nwe = Jl == null ? void 0 : Jl.sendBtcTransaction, Mwe = "ORANGE_CONNECTED_WALLET_STATE";
class Rwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(Mwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : r.OrangeBitcoinProvider;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Qu, r, i, this.$valueStore);
    }
    initialize() {
        var r;
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n;
            window.OrangeBitcoinProvider && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Qu]: !0
            }), (n = this.observer) == null || n.disconnect());
        }), (r = this.observer) == null || r.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (n)=>{
            n.provider !== Qu ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        const { address: n, paymentAddress: i } = this.$valueStore.get();
        if (n) {
            this.restorePersistedValues(), id(i, this.network).then((a)=>{
                this.$store.setKey("balance", a);
            });
            return;
        }
        const o = h_(this.network || ln), s = {
            payload: {
                purposes: [
                    "ordinals",
                    "payment"
                ],
                message: "Address for receiving Ordinals and payments",
                network: {
                    type: o
                }
            },
            onFinish: (a)=>{
                const u = um(a.addresses), f = fm(a.addresses);
                if (!u || !(f != null && f.address)) throw new Error("Could not find addresses");
                u && f && (this.$store.setKey("provider", Qu), this.$store.setKey("address", u.address), this.$store.setKey("paymentAddress", f.address)), this.$store.setKey("publicKey", String(u.publicKey)), this.$store.setKey("paymentPublicKey", String(f.publicKey)), this.$store.setKey("accounts", a.addresses.map((c)=>c.address));
            },
            onCancel: ()=>{
                throw new Error(`User canceled lasereyes to ${Qu} wallet`);
            }
        };
        await Jh.getAddress(s), this.$store.setKey("connected", !0);
    }
    async getNetwork() {
        const { address: r } = this.$store.get();
        return r.slice(0, 1) === "t" && [
            Ni,
            ao,
            Ro,
            co
        ].includes(this.network) ? this.network : ln;
    }
    async sendBTC(r, n) {
        let i = "";
        const o = {
            payload: {
                network: {
                    type: h_(this.network)
                },
                recipients: [
                    {
                        address: r,
                        amountSats: BigInt(n)
                    }
                ],
                senderAddress: this.$store.get().paymentAddress
            },
            onFinish: (s)=>{
                i = s;
            },
            onCancel: ()=>{
                throw new Error("User canceled the request");
            }
        };
        return await Nwe(o), i;
    }
    async signMessage(r, n) {
        let i = "";
        const o = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress, s = {
            payload: {
                network: {
                    type: h_(this.network)
                },
                address: o,
                message: r
            },
            onFinish: (a)=>{
                i = a;
            },
            onCancel: ()=>{
                throw new Error("User canceled the request");
            }
        };
        return await Pwe(s), i;
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        try {
            const a = Cr.fromBase64(String(r), {
                network: Dr(this.network)
            }).data.inputs;
            let u = {};
            if (o) u = o.reduce((_, A)=>(_[A.address] = [
                    ..._[A.address] || [],
                    A.index
                ], _), {});
            else {
                const { address: _, paymentAddress: A } = this.$store.get(), O = {
                    [_]: []
                }, N = {
                    [A]: []
                };
                for (const U of a.keys()){
                    const D = a[U];
                    if (D.witnessUtxo === void 0) {
                        N[A].push(Number(U));
                        continue;
                    }
                    const { script: H } = D.witnessUtxo, K = Yp(H, Dr(this.network));
                    K === A ? N[A].push(Number(U)) : K === _ && O[_].push(Number(U));
                }
                O[_].length > 0 && (u = {
                    ...u,
                    ...O
                }), N[A].length > 0 && (u = {
                    ...u,
                    ...N
                });
            }
            let f, c, l, p;
            const y = await Jh.request("signPsbt", {
                psbt: r,
                broadcast: !!n,
                signInputs: u
            });
            if (y.status === "success") p = Cr.fromBase64(y.result.psbt, {
                network: Dr(this.network)
            }), f = y.result.txid;
            else throw y.error.code === Jh.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
            if (!p) throw new Error("Error signing psbt");
            return i && !f ? (p.finalizeAllInputs(), c = p.toHex(), l = p.toBase64()) : (c = p.toHex(), l = p.toBase64()), {
                signedPsbtHex: c,
                signedPsbtBase64: l,
                txId: f
            };
        } catch (s) {
            throw console.error(s), s;
        }
    }
}
const Cwe = "OYL_CONNECTED_WALLET_STATE";
class Uwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(Cwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        return window.oyl;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf(Il, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var n;
            (window == null ? void 0 : window.oyl) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Il]: !0
            }), (n = this.observer) == null || n.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Il ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { nativeSegwit: n, taproot: i, nestedSegwit: o, legacy: s } = await this.library.getAddresses();
        if (!n || !i) throw new Error("No accounts found");
        this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", n.address), this.$store.setKey("publicKey", i.publicKey), this.$store.setKey("paymentPublicKey", n.publicKey), this.$store.setKey("accounts", [
            i.address,
            n.address,
            o.address,
            s.address
        ]);
    }
    async getNetwork() {
        var r;
        return (r = this.library) == null ? void 0 : r.getNetwork();
    }
    async sendBTC(r, n) {
        const { psbtHex: i, psbtBase64: o } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), s = await this.signPsbt({
            psbtBase64: o,
            psbtHex: i,
            tx: i,
            broadcast: !0,
            finalize: !0
        });
        if (!s || !s.txId) throw new Error("Error sending BTC");
        return s.txId;
    }
    async signMessage(r, n) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const i = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress;
        return (await this.library.signMessage({
            address: i,
            message: r,
            protocol: n == null ? void 0 : n.protocol
        })).signature;
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i }) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { psbt: o, txid: s } = await this.library.signPsbt({
            psbt: r,
            finalize: i,
            broadcast: n
        }), a = Cr.fromHex(o);
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: s
        };
    }
    async signPsbts(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { psbts: n, finalize: i, broadcast: o } = r, s = n.map((f)=>({
                psbt: f,
                finalize: i,
                broadcast: o
            })), a = await this.library.signPsbts(s);
        return {
            signedPsbts: a.map((f, c)=>{
                const l = Cr.fromHex(f.psbt);
                return {
                    signedPsbtHex: l.toHex(),
                    signedPsbtBase64: l.toBase64(),
                    txId: a[c].txid
                };
            }) || []
        };
    }
    async pushPsbt(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        return (await this.library.pushPsbt({
            psbt: r
        })).txid;
    }
    async getPublicKey() {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { nativeSegwit: r, taproot: n } = await this.library.getAddresses();
        if (!r || !n) throw new Error("No accounts found");
        return this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), n.publicKey;
    }
    async getBalance() {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { total: r } = await this.library.getBalance();
        return this.$store.setKey("balance", BigInt(r)), r;
    }
    async requestAccounts() {
        return [
            this.$store.get().address,
            this.$store.get().paymentAddress
        ];
    }
    async switchNetwork(r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        await this.library.switchNetwork(r), this.$network.set(r), await this.parent.connect(Il);
    }
}
class $we extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.phantom) == null ? void 0 : r.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Pl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider === Pl && this.library.requestAccounts().then((n)=>{
                this.handleAccountsChanged(n);
            });
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Pl) : this.parent.disconnect());
    }
    async connect(r) {
        if (!this.library) throw new Error("Phantom isn't installed");
        if (LP(this.network)) throw new Error(`${this.network} is not supported by ${Pl}`);
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        this.$store.setKey("accounts", n);
        const i = n.find((s)=>s.purpose === "ordinals"), o = n.find((s)=>s.purpose === "payment");
        this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", i.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("accounts", n.map((s)=>s.address));
    }
    async getNetwork() {
        return this.$store.get().address.slice(0, 1) === "t" ? Ni : ln;
    }
    async sendBTC(r, n) {
        const { psbtHex: i, psbtBase64: o } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), s = await this.signPsbt({
            psbtBase64: o,
            psbtHex: i,
            tx: i,
            broadcast: !0,
            finalize: !0
        });
        if (!s || !s.txId) throw new Error("Error sending BTC");
        return s.txId;
    }
    async signMessage(r, n) {
        var f;
        if ((n == null ? void 0 : n.protocol) === f0) throw new Error("ECDSA signing is not supported by Phantom");
        const i = new TextEncoder().encode(r), o = new Uint8Array(i), s = (n == null ? void 0 : n.toSignAddress) || this.$store.get().paymentAddress, a = await ((f = this.library) == null ? void 0 : f.signMessage(s, o)), u = String.fromCharCode(...a.signature);
        return btoa(u);
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const a = Cr.fromHex(String(r), {
            network: Dr(this.network)
        }).data.inputs;
        let u = [];
        if (o) {
            const l = o.reduce((p, y)=>({
                    ...p,
                    [y.address]: [
                        ...p[y.address] || [],
                        y.index
                    ]
                }), {});
            u = Object.entries(l).map(([p, y])=>({
                    address: p,
                    signingIndexes: y
                }));
        } else {
            const { address: l, paymentAddress: p } = this.$store.get(), y = {
                address: l,
                signingIndexes: []
            }, _ = {
                address: p,
                signingIndexes: []
            };
            for (let A of a.keys()){
                const O = a[A];
                if (O.witnessUtxo === void 0) {
                    _.signingIndexes.push(Number(A));
                    continue;
                }
                const { script: N } = O.witnessUtxo, U = Yp(N, Dr(this.network));
                U === p ? _.signingIndexes.push(Number(A)) : U === l && y.signingIndexes.push(Number(A));
            }
            y.signingIndexes.length > 0 && u.push(y), _.signingIndexes.length > 0 && u.push(_);
        }
        const f = await this.library.signPSBT(rwe(r), {
            inputsToSign: u
        }), c = Cr.fromBuffer(f);
        if (i && u.forEach((l)=>{
            l.signingIndexes.forEach((p)=>{
                c.finalizeInput(p);
            });
        }), n) {
            const l = await this.pushPsbt(c.toHex());
            return {
                signedPsbtHex: c.toHex(),
                signedPsbtBase64: c.toBase64(),
                txId: l
            };
        }
        return {
            signedPsbtHex: c.toHex(),
            signedPsbtBase64: c.toBase64(),
            txId: void 0
        };
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
}
const Ah = {}, wE = console.log;
function Th(e) {
    if (Ah[e]) return console.warn(`Multiple requests for "${e}" detected`), Ah[e];
    const t = new Promise((r, n)=>{
        const i = setTimeout(()=>{
            console.log = wE, Ah[e] = void 0, n(new Error(`Timeout waiting for "${e}" value`));
        }, 6e4);
        console.log = (...o)=>{
            o.length > 0 && typeof o[0] == "string" && (clearTimeout(i), console.log = wE, Ah[e] = void 0, r(o[0]));
        }, wE(`Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`);
    });
    return Ah[e] = t, t;
}
class Lwe {
    async requestAccounts(t) {
        const r = await Th(`address_${t || "mainnet"}`);
        if (!r) throw new Error("No address provided");
        const n = await Th(`paymentAddress_${t || "mainnet"}`);
        if (!n) throw new Error("No payment address provided");
        return [
            r,
            n
        ];
    }
    async signMessage(t) {
        return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Th("message to sign");
    }
    async signPsbt(t) {
        return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Th("signed psbt hex");
    }
    async getPublicKey(t) {
        const r = await Th(`publicKey_${t || "mainnet"}`);
        if (!r) throw new Error("No public key provided");
        return r;
    }
    // TODO: Implement network switching between mainnet and testnet
    async getNetwork() {
        return "mainnet";
    }
    async switchNetwork(t) {
        const [r, n] = await this.requestAccounts(), i = await this.getPublicKey();
        return {
            address: r,
            paymentAddress: n,
            publicKey: i
        };
    }
}
const Dwe = "SPARROW_CONNECTED_WALLET_STATE";
class Fwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(Dwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        return window == null ? void 0 : window.SparrowWalletProvider;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library || (window.SparrowWalletProvider = new Lwe()), this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ml]: !0
            }), (r = this.observer) == null || r.disconnect();
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Ml ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    watchStateChange(r, n, i) {
        Wf(Ml, r, i, this.$valueStore);
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        try {
            const { address: n, paymentAddress: i } = this.$valueStore.get();
            if (n && i) if (n.startsWith("tb1") && qb(this.network)) this.disconnect();
            else {
                this.restorePersistedValues();
                return;
            }
            if (!this.library) throw new Error("Sparrow wallet isn't supported");
            const o = await this.library.requestAccounts();
            if (!o) throw new Error("No accounts found");
            await this.getNetwork().then((a)=>{
                this.network !== a && this.switchNetwork(this.network);
            });
            const s = await this.library.getPublicKey();
            if (!s) throw new Error("No public key found");
            this.$store.setKey("accounts", o), this.$store.setKey("address", o[0]), this.$store.setKey("paymentAddress", o[1]), this.$store.setKey("publicKey", s), this.$store.setKey("paymentPublicKey", s);
        } catch (n) {
            throw console.error("Error during sparrow connect:", n), n;
        }
    }
    async getNetwork() {
        return this.network;
    }
    async switchNetwork(r) {
        if (!this.library) throw new Error("Sparrow wallet isn't supported");
        try {
            const n = await this.library.switchNetwork(r);
            if (!n) throw new Error("No result returned from switchNetwork");
            const { address: i, paymentAddress: o, publicKey: s } = n;
            this.$store.setKey("address", i), this.$store.setKey("paymentAddress", o), this.$store.setKey("publicKey", s), this.$store.setKey("paymentPublicKey", s), this.$network.set(r);
        } catch (n) {
            throw console.error("Error during sparrow switchNetwork:", n), n;
        }
    }
    async sendBTC(r, n) {
        const { psbtBase64: i } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), o = await this.library.signPsbt(i);
        if (!o) throw new Error("No signed PSBT provided");
        const s = await this.pushPsbt(o);
        if (!s) throw new Error("send failed, no txid returned");
        return s;
    }
    async signMessage(r) {
        return await this.library.signMessage(r);
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i }) {
        const o = Cr.fromBase64(r), s = await this.library.signPsbt(r);
        if (i && n) {
            const a = await this.pushPsbt(s);
            return {
                signedPsbtHex: s,
                signedPsbtBase64: o.toBase64(),
                txId: a
            };
        }
        return {
            signedPsbtHex: s,
            signedPsbtBase64: o.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        const r = await this.library.getPublicKey();
        return this.$store.setKey("publicKey", r), r;
    }
    async getBalance() {
        const r = await id(this.$store.get().paymentAddress, this.network);
        return this.$store.setKey("balance", r), r.toString();
    }
    async requestAccounts() {
        return await this.connect(Ml), this.$store.get().accounts;
    }
}
const zwe = "TOKEO_CONNECTED_WALLET_STATE";
class jwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
        pt(this, "$valueStore", Kf(zwe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        }));
        pt(this, "removeSubscriber");
    }
    get library() {
        var r;
        return (r = window.tokeo) == null ? void 0 : r.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const r = this.$valueStore.get();
        for (const n of Nu)n === "balance" && this.$store.setKey(n, BigInt(r[n])), this.$store.setKey(n, r[n]);
        this.$store.setKey("accounts", [
            r.address,
            r.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(r, n, i) {
        Wf($h, r, i, this.$valueStore);
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [$h]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== $h ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect();
    }
    async connect(r) {
        try {
            if (!this.library) if (this.isMobile()) {
                const s = `tokeo://open-url?url=${encodeURIComponent(window.location.href)}`, a = window.open(s);
                if (!a) throw new Error("Tokeo wallet not found");
                return a.focus(), !1;
            } else throw new Error("Tokeo wallet not found");
            await this.library.requestAccounts();
            const n = (await this.library.getAccounts()).accounts;
            if (!n || n.length === 0) throw new Error("No accounts found");
            const i = n.find((s)=>s.type === "p2tr"), o = n.find((s)=>s.type === "p2wpkh");
            if (!i) throw new Error("No p2tr address found");
            this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", (o == null ? void 0 : o.address) ?? i.address), this.$store.setKey("publicKey", i.publicKey), this.$store.setKey("paymentPublicKey", (o == null ? void 0 : o.publicKey) ?? i.publicKey), this.$store.setKey("accounts", n.map((s)=>s.address));
        } catch (n) {
            throw console.error(n), n;
        }
    }
    async getNetwork() {
        return ln;
    }
    async sendBTC(r, n) {
        const { psbtHex: i, psbtBase64: o } = await zb(this.$store.get().address, this.$store.get().paymentAddress, r, n, this.$store.get().paymentPublicKey, this.network, 7), s = await this.signPsbt({
            psbtBase64: o,
            psbtHex: i,
            tx: i,
            broadcast: !0,
            finalize: !0
        });
        if (!s || !s.txId) throw new Error("Error sending BTC");
        return s.txId;
    }
    async signMessage(r, n) {
        return await this.library.signMessage(r, n == null ? void 0 : n.protocol);
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        const s = {
            autoFinalize: i,
            inputs: o == null ? void 0 : o.map((c)=>({
                    index: c.index,
                    address: c.address
                }))
        }, a = await this.library.signPsbt(r, Sf(s)), u = Cr.fromBase64(a);
        let f;
        return n && (f = await this.pushPsbt(a)), {
            signedPsbtHex: u.toHex(),
            signedPsbtBase64: u.toBase64(),
            txId: f
        };
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async requestAccounts() {
        return await this.library.requestAccounts(), (await this.library.getAccounts()).accounts.map((n)=>n.address);
    }
}
class Hwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        return window.unisat;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Bl]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), $o(this.$store, [
            "provider"
        ], (r)=>{
            var n;
            if (r.provider !== Bl) {
                this == null || this.removeListeners();
                return;
            }
            (n = this.library) == null || n.getAccounts().then((i)=>{
                this.handleAccountsChanged(i);
            }), this.addListeners();
        });
    }
    addListeners() {
        var r, n;
        (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var r, n;
        !this.library || !this.library.removeListener || ((r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (n = this.library) == null || n.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && (this.$store.setKey("accounts", r), r.length > 0 ? this.parent.connect(Bl) : this.parent.disconnect());
    }
    handleNetworkChanged(r) {
        const n = om(r);
        this.network !== n && this.switchNetwork(n), this.parent.connect(Bl);
    }
    async connect(r) {
        if (!this.library) throw new Error("Unisat isn't installed");
        const n = await this.library.requestAccounts();
        if (!n) throw new Error("No accounts found");
        const i = await this.library.getPublicKey();
        if (!i) throw new Error("No public key found");
        this.$store.setKey("accounts", n), this.$store.setKey("address", n[0]), this.$store.setKey("paymentAddress", n[0]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i);
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getChain());
        return r ? om(r.enum) : this.network;
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (!i) throw new Error("Transaction failed");
        return i;
    }
    async signMessage(r, n) {
        var o;
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await ((o = this.library) == null ? void 0 : o.signMessage(r, i));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var u;
        const s = await ((u = this.library) == null ? void 0 : u.signPsbt(r, Sf({
            autoFinalized: i,
            toSignInputs: o
        }))), a = Cr.fromHex(s);
        if (i && n) {
            const f = await this.pushPsbt(s);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: f
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async signPsbts(r) {
        const { psbts: n, finalize: i, broadcast: o, inputsToSign: s } = r, a = await this.library.signPsbts(n, Sf({
            autoFinalized: i,
            toSignInputs: s
        }));
        return {
            signedPsbts: await Promise.all(a.map(async (f)=>{
                const c = Cr.fromHex(f);
                let l;
                return i && o && (l = await this.pushPsbt(f)), {
                    signedPsbtHex: c.toHex(),
                    signedPsbtBase64: c.toBase64(),
                    txId: l
                };
            }))
        };
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(r, n) {
        const i = r || 0, o = n || 10;
        return (await this.library.getInscriptions(i, o)).list.map((u)=>Kl(u, void 0, this.network));
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async switchNetwork(r) {
        var i;
        const n = fP(r);
        await ((i = this.library) == null ? void 0 : i.switchChain(n)), this.$network.set(r);
    }
}
class qwe extends Do {
    constructor(r, n, i){
        super(r, n, i);
        pt(this, "observer");
    }
    get library() {
        return window.wizz;
    }
    get network() {
        return this.$network.get();
    }
    handleNetworkChanged(r) {
        this.parent.connect(Uh);
    }
    handleAccountsChanged(r) {
        if (!r.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== r[0] && this.$store.setKey("accounts", r);
    }
    initialize() {
        $o(this.$store, [
            "provider"
        ], (r)=>{
            r.provider === Uh ? this.addLibraryListeners() : this.removeLibraryListeners();
        }), ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Uh]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        }));
    }
    removeLibraryListeners() {
        var r, n;
        !this.library || !this.library.removeListener || ((r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)), (n = this.library) == null || n.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)));
    }
    addLibraryListeners() {
        var r, n;
        (r = this.library) == null || r.on("networkChanged", this.handleNetworkChanged.bind(this)), (n = this.library) == null || n.on("accountsChanged", this.handleAccountsChanged.bind(this));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeLibraryListeners();
    }
    async connect() {
        if (!this.library) throw fme;
        const r = await this.library.requestAccounts();
        if (!r) throw new Error("No accounts found");
        const n = await this.library.getPublicKey();
        if (!n) throw new Error("No public key found");
        this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), await this.getNetwork().then((i)=>{
            var o;
            i && ((o = this.config) == null ? void 0 : o.network) !== i && this.parent.switchNetwork(i);
        });
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async getNetwork() {
        var n;
        const r = await ((n = this.library) == null ? void 0 : n.getNetwork());
        return r ? fk(r) : void 0;
    }
    async switchNetwork(r) {
        var i;
        if (r === co || r === yc) return await this.library.switchNetwork(ko.MAINNET);
        const n = fk(r);
        await ((i = this.library) == null ? void 0 : i.switchNetwork(n)), this.$network.set(r), await this.parent.getBalance();
    }
    async getPublicKey() {
        var r;
        return await ((r = this.library) == null ? void 0 : r.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(r, n) {
        const i = r || 0, o = n || 10;
        return (await this.library.getInscriptions(i, o)).list.map((u)=>Kl(u, void 0, this.network));
    }
    async sendBTC(r, n) {
        var o;
        const i = await ((o = this.library) == null ? void 0 : o.sendBitcoin(r, n));
        if (i) return i;
        throw new Error("Error sending BTC");
    }
    async signMessage(r, n) {
        var o;
        const i = (n == null ? void 0 : n.protocol) === Xb ? l0 : n == null ? void 0 : n.protocol;
        return await ((o = this.library) == null ? void 0 : o.signMessage(r, i));
    }
    async signPsbt({ psbtHex: r, broadcast: n, finalize: i, inputsToSign: o }) {
        var f;
        const s = await ((f = this.library) == null ? void 0 : f.signPsbt(r, Sf({
            autoFinalized: i,
            broadcast: !1,
            toSignInputs: o
        }))), a = Cr.fromHex(s);
        let u;
        return i && n && (u = await this.pushPsbt(s)), {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: u
        };
    }
}
const Kwe = (e)=>e === ln ? Mn.Mainnet : e === Ni ? Mn.Testnet : e === Ro ? Mn.Signet : e === co ? Mn.Testnet : e === yc ? Mn.Mainnet : e === ao ? Mn.Testnet4 : Mn.Mainnet;
class Wwe extends Do {
    constructor(){
        super(...arguments);
        pt(this, "observer");
    }
    get network() {
        return this.$network.get();
    }
    get library() {
        var r;
        return (r = window == null ? void 0 : window.XverseProviders) == null ? void 0 : r.BitcoinProvider;
    }
    initialize() {
        ("TURBOPACK compile-time value", "undefined") < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ol]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        }));
    }
    dispose() {
        var r;
        (r = this.observer) == null || r.disconnect(), this.removeListeners();
    }
    addListeners() {
        uk("accountChange", ()=>{}), uk("networkChange", (r)=>{
            r.type === "networkChange" && this.handleNetworkChanged(r.bitcoin.name);
        });
    }
    removeListeners() {
        console.log("removeListeners");
    }
    // private handleAccountsChanged(accounts: string[]) {
    //   console.log('handleAccountsChanged', accounts)
    //   if (!accounts.length) {
    //     this.parent.disconnect()
    //     return
    //   }
    //   // if (this.$store.get().accounts[0] === accounts[0]) {
    //   //   return
    //   // }
    //   // this.$store.setKey('accounts', accounts)
    //   // if (accounts.length > 0) {
    //   //   this.parent.connect(XVERSE)
    //   // } else {
    //   //   this.parent.disconnect()
    //   // }
    // }
    handleNetworkChanged(r) {
        const n = p_(r);
        this.$network.set(n), this.parent.connect(Ol);
    }
    async connect(r) {
        if (this.isMobile() && !this.library) {
            const a = `xverse://browser?url=${encodeURIComponent(window.location.href)}`;
            window.location.href = a;
            return;
        }
        let n, i, o, s = [];
        try {
            const a = await Wu("wallet_getAccount", null);
            if (a.status === "success") n = um(a.result.addresses), i = fm(a.result.addresses), o = a.result.network.bitcoin.name, s = a.result.addresses.map((u)=>u.address);
            else throw new Error(`Error getting account: ${a.error.message}`);
        } catch (a) {
            if (a instanceof Error && (a.message.toLowerCase().includes("failed to get") || a.message.toLowerCase().includes("access denied"))) {
                const u = await Wu("wallet_connect", {
                    addresses: [
                        vf.Ordinals,
                        vf.Payment
                    ],
                    message: "Connecting with lasereyes"
                });
                if (u.status === "success") n = um(u.result.addresses), i = fm(u.result.addresses), o = u.result.network.bitcoin.name, s = u.result.addresses.map((f)=>f.address);
                else throw u.error.code === kh.USER_REJECTION ? new Error(`User canceled lasereyes to ${Ol} wallet`) : new Error(u.error.message);
            } else throw console.error(a), new Error(`Error connecting to ${Ol} wallet`);
        }
        if (!n || !i) throw new Error("Could not find the addresses");
        this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", i.address), this.$store.setKey("publicKey", String(n.publicKey)), this.$store.setKey("paymentPublicKey", String(i.publicKey)), this.$store.setKey("accounts", s), o && this.$network.set(p_(o));
    }
    async getNetwork() {
        try {
            const r = await Wu("wallet_getNetwork", null);
            if (r.status === "success") return p_(r.result.bitcoin.name);
            throw new Error("Error getting network");
        } catch (r) {
            return console.error(r), this.network;
        }
    }
    async switchNetwork(r) {
        if ((await Wu("wallet_changeNetwork", {
            name: Kwe(r)
        })).status === "success") this.handleNetworkChanged(r);
        else throw new Error("Error switching network");
    }
    async sendBTC(r, n) {
        const i = await Wu("sendTransfer", {
            recipients: [
                {
                    address: r,
                    amount: n
                }
            ]
        });
        if (i.status === "success") return i.result.txid;
        throw i.error.code === kh.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error sending BTC: ${i.error.message}`);
    }
    async signMessage(r, { toSignAddress: n, protocol: i }) {
        const o = n || this.$store.get().paymentAddress, s = await Wu("signMessage", {
            address: o,
            message: r,
            protocol: i === f0 ? _f.ECDSA : _f.BIP322
        });
        if (s.status === "success") return s.result.signature;
        throw s.error.code === kh.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error signing message: ${s.error.message}`);
    }
    async signPsbt({ psbtBase64: r, broadcast: n, finalize: i, inputsToSign: o }) {
        try {
            const a = Cr.fromBase64(String(r), {
                network: Dr(this.network)
            }).data.inputs;
            let u = {};
            if (o) u = o.reduce((_, A)=>(_[A.address] = [
                    ..._[A.address] || [],
                    A.index
                ], _), {});
            else {
                const { address: _, paymentAddress: A } = this.$store.get(), O = {
                    [_]: []
                }, N = {
                    [A]: []
                };
                for (const U of a.keys()){
                    const D = a[U];
                    if (D.witnessUtxo === void 0) {
                        N[A].push(Number(U));
                        continue;
                    }
                    const { script: H } = D.witnessUtxo, K = Yp(H, Dr(this.network));
                    K === A ? N[A].push(Number(U)) : K === _ && O[_].push(Number(U));
                }
                O[_].length > 0 && (u = {
                    ...u,
                    ...O
                }), N[A].length > 0 && (u = {
                    ...u,
                    ...N
                });
            }
            let f, c, l, p;
            const y = await Wu("signPsbt", {
                psbt: r,
                broadcast: !!n,
                signInputs: u
            });
            if (y.status === "success") p = Cr.fromBase64(y.result.psbt, {
                network: Dr(this.network)
            }), f = y.result.txid;
            else throw y.error.code === kh.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
            if (!p) throw new Error("Error signing psbt");
            return i && !f ? (p.finalizeAllInputs(), c = p.toHex(), l = p.toBase64()) : (c = p.toHex(), l = p.toBase64()), {
                signedPsbtHex: c,
                signedPsbtBase64: l,
                txId: f
            };
        } catch (s) {
            throw console.error(s), s;
        }
    }
}
class u_e {
    constructor(t, r){
        pt(this, "$store");
        pt(this, "$network");
        pt(this, "$providerMap");
        pt(this, "disposed", !1);
        pt(this, "dataSourceManager");
        pt(this, "modules");
        this.config = r, this.$store = t.$store, this.$network = t.$network, cG(this.$store), this.$providerMap = {
            [Rh]: new iwe(t, this, r),
            [ru]: new swe(t, this, r),
            [Ch]: new cwe(t, this, r),
            [Nl]: new uwe(t, this, r),
            [Qu]: new Rwe(t, this, r),
            [Il]: new Uwe(t, this, r),
            [Pl]: new $we(t, this, r),
            [Ml]: new Fwe(t, this, r),
            [$h]: new jwe(t, this, r),
            [Bl]: new Hwe(t, this, r),
            [Ol]: new Wwe(t, this, r),
            [Uh]: new qwe(t, this, r),
            [Rl]: new lme(t, this, r)
        }, this.modules = {
            alkanes: new lM(this)
        };
        try {
            this.dataSourceManager = nc.getInstance();
        } catch  {
            nc.init(r), this.dataSourceManager = nc.getInstance();
        }
    }
    dispose() {
        this.disposed = !0;
        for (const t of Object.values(this.$providerMap))t.dispose();
    }
    initialize() {
        this.$network.listen(this.watchNetworkChange.bind(this)), $o(this.$store, [
            "isInitializing"
        ], (t, r)=>{
            if (!this.disposed && t.isInitializing !== r.isInitializing) return this.handleIsInitializingChanged(t.isInitializing);
        }), twe(()=>{
            this.$store.setKey("isInitializing", !1), this.checkNetwork();
        });
    }
    async checkNetwork() {
        var i;
        const { provider: t, isInitializing: r } = this.$store.get();
        if (!t || r) return;
        const n = await this.getNetwork();
        n && (this.dataSourceManager.updateNetwork(n), this.$network.set(n));
        try {
            (i = this.config) != null && i.network && this.config.network !== n && await this.switchNetwork(this.config.network);
        } catch (o) {
            console.error("Couldn't enforce config network", o), this.disconnect();
        }
    }
    handleIsInitializingChanged(t) {
        if (("TURBOPACK compile-time value", "undefined") < "u" && typeof localStorage < "u" && !t) {
            const r = localStorage == null ? void 0 : localStorage.getItem(ev);
            r && this.connect(r);
        }
    }
    async connect(t) {
        if (this.disposed) {
            console.warn("Client disposed, cannot connect");
            return;
        }
        this.$store.setKey("isConnecting", !0);
        try {
            if (localStorage == null || localStorage.setItem(ev, t), !this.$providerMap[t]) throw new Error("Unsupported wallet provider");
            const r = this.$providerMap[t];
            if (await (r == null ? void 0 : r.connect(t)) === !1) {
                this.$store.setKey("isConnecting", !1), this.disconnect();
                return;
            }
            this.$store.setKey("provider", t), await this.checkNetwork(), this.$store.setKey("connected", !0);
        } catch (r) {
            throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", !1), this.disconnect(), r;
        } finally{
            this.$store.setKey("isConnecting", !1);
        }
    }
    async requestAccounts() {
        var r;
        const t = this.$store.get().provider;
        if (!t) throw new Error("No wallet provider connected");
        try {
            return await ((r = this.$providerMap[t]) == null ? void 0 : r.requestAccounts());
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : n;
        }
    }
    disconnect() {
        this.$store.set({
            provider: void 0,
            address: "",
            paymentAddress: "",
            publicKey: "",
            paymentPublicKey: "",
            balance: void 0,
            accounts: [],
            connected: !1,
            isConnecting: !1,
            isInitializing: !1,
            hasProvider: this.$store.get().hasProvider
        }), localStorage == null || localStorage.removeItem(ev);
    }
    async switchNetwork(t) {
        var r;
        try {
            const n = this.$store.get().provider;
            n && (console.log("switchNetwork", t), await ((r = this.$providerMap[n]) == null ? void 0 : r.switchNetwork(t)), this.dataSourceManager.updateNetwork(t));
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error("The connected wallet doesn't support programmatic network changes..")) : n;
        }
    }
    watchNetworkChange() {
        this.$store.setKey("balance", void 0), this.getBalance();
    }
    async getNetwork() {
        var r;
        const t = this.$store.get().provider;
        return t && this.$providerMap[t] ? await ((r = this.$providerMap[t]) == null ? void 0 : r.getNetwork()) : this.$network.get();
    }
    async sendBTC(t, r) {
        var i;
        if (r <= 0) throw new Error("Amount must be greater than 0");
        if (!Number.isInteger(r)) throw new Error("Amount must be an integer");
        const n = this.$store.get().provider;
        if (!n) throw new Error("No wallet connected");
        if (n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.sendBTC(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending BTC...") : o;
        }
        throw new Error("Something went wrong");
    }
    async signMessage(t, r) {
        let n = {};
        typeof r == "string" ? n = {
            toSignAddress: r
        } : r && (n = r);
        const i = this.$store.get().provider;
        if (!i) throw new Error("No wallet connected");
        if (i && this.$providerMap[i]) try {
            return await this.$providerMap[i].signMessage(t, n);
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support message signing...") : o;
        }
        throw new Error("Something went wrong");
    }
    async signPsbt(t, r, n) {
        var l;
        let i, o, s, a;
        typeof t == "string" ? (i = t, o = r ?? !1, s = n ?? !1) : (i = t.tx, o = t.finalize ?? !1, s = t.broadcast ?? !1, a = t.inputsToSign);
        let u, f;
        if (!i) throw new Error("No PSBT provided");
        if (Wae(i)) f = Cr.fromHex(i).toBase64(), u = i;
        else if (Kae(i)) f = i, u = Cr.fromBase64(i).toHex();
        else throw new Error("Invalid PSBT format");
        const c = this.$store.get().provider;
        if (c && this.$providerMap[c]) try {
            return await ((l = this.$providerMap[c]) == null ? void 0 : l.signPsbt({
                psbtHex: u,
                psbtBase64: f,
                tx: i,
                broadcast: s,
                finalize: o,
                inputsToSign: a
            }));
        } catch (p) {
            throw p instanceof Error && p.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : p;
        }
        else throw new Error("No wallet provider connected");
    }
    async signPsbts(t) {
        var a;
        const { psbts: r, finalize: n = !1, broadcast: i = !1, inputsToSign: o } = t;
        if (!r || r.length === 0) throw new Error("No PSBTs provided");
        const s = this.$store.get().provider;
        if (s && this.$providerMap[s]) try {
            return await ((a = this.$providerMap[s]) == null ? void 0 : a.signPsbts({
                psbts: r,
                finalize: n,
                broadcast: i,
                inputsToSign: o
            }));
        } catch (u) {
            throw u instanceof Error && u.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : u;
        }
        else throw new Error("No wallet provider connected");
    }
    async pushPsbt(t) {
        var n;
        const r = this.$store.get().provider;
        if (r && r && this.$providerMap[r]) try {
            return await ((n = this.$providerMap[r]) == null ? void 0 : n.pushPsbt(t));
        } catch (i) {
            throw i instanceof Error && i.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : i;
        }
    }
    async inscribe(t, r, n) {
        var o;
        const i = this.$store.get().provider;
        if (i && i && this.$providerMap[i]) try {
            return await ((o = this.$providerMap[i]) == null ? void 0 : o.inscribe(t, r, this.dataSourceManager, n));
        } catch (s) {
            throw s instanceof Error && s.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support inscribing...") : s;
        }
    }
    async send(t, r) {
        var i;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.send(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending stuff...") : o;
        }
    }
    async getPublicKey() {
        var r;
        const t = this.$store.get().provider;
        if (t && t && this.$providerMap[t]) try {
            return await ((r = this.$providerMap[t]) == null ? void 0 : r.getPublicKey());
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : n;
        }
    }
    async getBalance() {
        const t = this.$store.get().provider;
        if (t && t && this.$providerMap[t]) try {
            const r = await this.$providerMap[t].getBalance();
            return this.$store.setKey("balance", BigInt(r)), r;
        } catch (r) {
            throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : r;
        }
    }
    async getMetaBalances(t) {
        const r = this.$store.get().provider;
        if (r && r && this.$providerMap[r]) try {
            if (!t) throw new Error("No protocol provided");
            return await this.$providerMap[r].getMetaBalances(t);
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : n;
        }
    }
    async getInscriptions(t, r) {
        var i;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.getInscriptions(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
        }
    }
    async sendInscriptions(t, r) {
        var i;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((i = this.$providerMap[n]) == null ? void 0 : i.sendInscriptions(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
        }
    }
}
;
}),
];

//# sourceMappingURL=node_modules_%40omnisat_lasereyes-core_dist_index_70036980.js.map