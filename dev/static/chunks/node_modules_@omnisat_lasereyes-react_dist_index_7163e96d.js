(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@omnisat/lasereyes-react/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ALKANES",
    ()=>G8,
    "APPLICATION_ATOM_XML",
    ()=>h8e,
    "APPLICATION_FORM_URLENCODED",
    ()=>p8e,
    "APPLICATION_GZIP",
    ()=>l8e,
    "APPLICATION_JAVASCRIPT",
    ()=>a8e,
    "APPLICATION_JSON",
    ()=>o8e,
    "APPLICATION_OCTET_STREAM",
    ()=>g8e,
    "APPLICATION_PDF",
    ()=>u8e,
    "APPLICATION_RSS_XML",
    ()=>d8e,
    "APPLICATION_XHTML_XML",
    ()=>f8e,
    "APPLICATION_XML",
    ()=>s8e,
    "APPLICATION_ZIP",
    ()=>c8e,
    "AUDIO_MP3",
    ()=>_8e,
    "AUDIO_OGG",
    ()=>O8e,
    "AUDIO_WAV",
    ()=>k8e,
    "BIP322",
    ()=>mb,
    "BIP322_SIMPLE",
    ()=>k1,
    "BRC20",
    ()=>bO,
    "BTC",
    ()=>Md,
    "BaseNetwork",
    ()=>pt,
    "CmdruidNetwork",
    ()=>Dp,
    "DataSourceManager",
    ()=>ff,
    "ECDSA",
    ()=>_1,
    "FRACTAL_MAINNET",
    ()=>Ku,
    "FRACTAL_TESTNET",
    ()=>ko,
    "FractalNetwork",
    ()=>I8,
    "IMAGE_GIF",
    ()=>b8e,
    "IMAGE_ICON",
    ()=>v8e,
    "IMAGE_JPEG",
    ()=>y8e,
    "IMAGE_PNG",
    ()=>m8e,
    "IMAGE_SVG_XML",
    ()=>w8e,
    "IMAGE_WEBP",
    ()=>A8e,
    "KEPLR",
    ()=>Hl,
    "KeplrChain",
    ()=>Kc,
    "LEATHER",
    ()=>jd,
    "LOCAL_STORAGE_DEFAULT_WALLET",
    ()=>wA,
    "LaserEyesClient",
    ()=>yve,
    "LaserEyesLogo",
    ()=>R8e,
    "LaserEyesProvider",
    ()=>N8e,
    "LeatherLogo",
    ()=>l3e,
    "LeatherNetwork",
    ()=>Hd,
    "MAGIC_EDEN",
    ()=>_u,
    "MAINNET",
    ()=>mn,
    "MULTIPART_FORM_DATA",
    ()=>I8e,
    "MaestroDataSource",
    ()=>boe,
    "MagicEdenLogo",
    ()=>y3e,
    "MempoolSpaceDataSource",
    ()=>woe,
    "OKX",
    ()=>Fd,
    "OP_NET",
    ()=>zl,
    "ORANGE",
    ()=>Mc,
    "OYL",
    ()=>Ul,
    "OYLNET",
    ()=>yM,
    "OkxLogo",
    ()=>g3e,
    "OkxNetwork",
    ()=>B8,
    "OpNetwork",
    ()=>QZ,
    "OrangeNetwork",
    ()=>zy,
    "OylLogo",
    ()=>BB,
    "P2PKH",
    ()=>RZ,
    "P2PSH",
    ()=>M3e,
    "P2SH",
    ()=>d1,
    "P2SH_P2WPKH",
    ()=>UZ,
    "P2TR",
    ()=>sf,
    "P2WPKH",
    ()=>Fy,
    "P2WSH",
    ()=>DZ,
    "PHANTOM",
    ()=>Fl,
    "PhantomLogo",
    ()=>f3e,
    "REGTEST",
    ()=>R3e,
    "RUNES",
    ()=>wO,
    "SIGNET",
    ()=>Xo,
    "SPARROW",
    ()=>Ll,
    "SUPPORTED_WALLETS",
    ()=>N3e,
    "SandshrewDataSource",
    ()=>dle,
    "TESTNET",
    ()=>Ki,
    "TESTNET4",
    ()=>_o,
    "TEXT_CSS",
    ()=>r8e,
    "TEXT_HTML",
    ()=>t8e,
    "TEXT_JAVASCRIPT",
    ()=>n8e,
    "TEXT_MARKDOWN",
    ()=>i8e,
    "TEXT_PLAIN",
    ()=>hoe,
    "TOKEO",
    ()=>Ld,
    "TokeoLogo",
    ()=>k3e,
    "UNISAT",
    ()=>Dl,
    "UNSUPPORTED_PROVIDER_METHOD_ERROR",
    ()=>nB,
    "UnisatLogo",
    ()=>h3e,
    "UnisatNetwork",
    ()=>Ao,
    "VIDEO_MP4",
    ()=>E8e,
    "VIDEO_OGG",
    ()=>x8e,
    "VIDEO_WEBM",
    ()=>S8e,
    "WALLET_NOT_INSTALLED_ERROR",
    ()=>C2e,
    "WIZZ",
    ()=>zd,
    "WalletIcon",
    ()=>U8e,
    "WalletProvider",
    ()=>ra,
    "WizzLogo",
    ()=>p3e,
    "WizzNetwork",
    ()=>Oa,
    "XVERSE",
    ()=>jl,
    "XverseLogo",
    ()=>d3e,
    "XverseNetwork",
    ()=>Tl,
    "createConfig",
    ()=>xAe,
    "createStores",
    ()=>Ij,
    "getCmDruidNetwork",
    ()=>mre,
    "getKeplrChainFromNetwork",
    ()=>yre,
    "getLeatherNetwork",
    ()=>U3e,
    "getNetworkForLeather",
    ()=>j3e,
    "getNetworkForOkx",
    ()=>wre,
    "getNetworkForUnisat",
    ()=>Am,
    "getNetworkForWizz",
    ()=>Xk,
    "getNetworkForXverse",
    ()=>g3,
    "getNetworkFromKeplrChain",
    ()=>bre,
    "getOrangeNetwork",
    ()=>p3,
    "getSatsConnectNetwork",
    ()=>h3,
    "getUnisatNetwork",
    ()=>mM,
    "getWizzNetwork",
    ()=>D3e,
    "useAccount",
    ()=>F8e,
    "useAccountEffect",
    ()=>z8e,
    "useAddressTokens",
    ()=>L8e,
    "useAlkanesList",
    ()=>D8e,
    "useAlkanesToken",
    ()=>j8e,
    "useBalance",
    ()=>H8e,
    "useBitcoinFees",
    ()=>K8e,
    "useClient",
    ()=>q8e,
    "useConnect",
    ()=>V8e,
    "useConnectedProvider",
    ()=>W8e,
    "useLaserEyes",
    ()=>iu
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
var VE = (e)=>{
    throw TypeError(e);
};
var aA = (e, t, r)=>t.has(e) || VE("Cannot " + r);
var Fe = (e, t, r)=>(aA(e, t, "read from private field"), r ? r.call(e) : t.get(e)), tr = (e, t, r)=>t.has(e) ? VE("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Nt = (e, t, r, n)=>(aA(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), Kr = (e, t, r)=>(aA(e, t, "access private method"), r);
var Ug = (e, t, r, n)=>({
        set _ (i){
            Nt(e, t, i, r);
        },
        get _ () {
            return Fe(e, t, n);
        }
    });
;
;
;
var uW = Object.defineProperty, cW = (e, t, r)=>t in e ? uW(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r, wt = (e, t, r)=>cW(e, typeof t != "symbol" ? t + "" : t, r);
function lW(e, t) {
    for(var r = 0; r < t.length; r++){
        const n = t[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for(const i1 in n)if (i1 !== "default" && !(i1 in e)) {
                const o = Object.getOwnPropertyDescriptor(n, i1);
                o && Object.defineProperty(e, i1, o.get ? o : {
                    enumerable: !0,
                    get: ()=>n[i1]
                });
            }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }));
}
const ds = {
    /**
   * The message prefix used for signing Bitcoin messages.
   */ messagePrefix: `Bitcoin Signed Message:
`,
    /**
   * The Bech32 prefix used for Bitcoin addresses.
   */ bech32: "bc",
    /**
   * The BIP32 key prefixes for Bitcoin.
   */ bip32: {
        /**
     * The public key prefix for BIP32 extended public keys.
     */ public: 76067358,
        /**
     * The private key prefix for BIP32 extended private keys.
     */ private: 76066276
    },
    /**
   * The prefix for Bitcoin public key hashes.
   */ pubKeyHash: 0,
    /**
   * The prefix for Bitcoin script hashes.
   */ scriptHash: 5,
    /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */ wif: 128
}, fW = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
        public: 70617039,
        private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
};
function dW(e) {
    if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
    const t = e[3];
    if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
    const r = e[5 + t];
    return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function hW(e) {
    if (e.length < 8) throw new Error("DER sequence length is too short");
    if (e.length > 72) throw new Error("DER sequence length is too long");
    if (e[0] !== 48) throw new Error("Expected DER sequence");
    if (e[1] !== e.length - 2) throw new Error("DER sequence length is invalid");
    if (e[2] !== 2) throw new Error("Expected DER integer");
    const t = e[3];
    if (t === 0) throw new Error("R length is zero");
    if (5 + t >= e.length) throw new Error("R length is too long");
    if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
    const r = e[5 + t];
    if (r === 0) throw new Error("S length is zero");
    if (6 + t + r !== e.length) throw new Error("S length is invalid");
    if (e[4] & 128) throw new Error("R value is negative");
    if (t > 1 && e[4] === 0 && !(e[5] & 128)) throw new Error("R value excessively padded");
    if (e[t + 6] & 128) throw new Error("S value is negative");
    if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) throw new Error("S value excessively padded");
    return {
        r: e.slice(4, 4 + t),
        s: e.slice(6 + t)
    };
}
function pW(e, t) {
    const r = e.length, n = t.length;
    if (r === 0) throw new Error("R length is zero");
    if (n === 0) throw new Error("S length is zero");
    if (r > 33) throw new Error("R length is too long");
    if (n > 33) throw new Error("S length is too long");
    if (e[0] & 128) throw new Error("R value is negative");
    if (t[0] & 128) throw new Error("S value is negative");
    if (r > 1 && e[0] === 0 && !(e[1] & 128)) throw new Error("R value excessively padded");
    if (n > 1 && t[0] === 0 && !(t[1] & 128)) throw new Error("S value excessively padded");
    const i1 = new Uint8Array(6 + r + n);
    return i1[0] = 48, i1[1] = i1.length - 2, i1[2] = 2, i1[3] = e.length, i1.set(e, 4), i1[4 + r] = 2, i1[5 + r] = t.length, i1.set(t, 6 + r), i1;
}
const Zr = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
}, zB = {};
for (const e of Object.keys(Zr)){
    const t = Zr[e];
    zB[t] = e;
}
const im = "0123456789abcdefABCDEF", om = im.split("").map((e)=>e.codePointAt(0)), am = Array(256).fill(!0).map((e, t)=>{
    const r = String.fromCodePoint(t), n = im.indexOf(r);
    return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), LB = new TextEncoder(), HB = new TextDecoder();
function gW(e) {
    return HB.decode(e);
}
function yW(e) {
    return LB.encode(e);
}
function Mn(e) {
    const t = e.reduce((i1, o)=>i1 + o.length, 0), r = new Uint8Array(t);
    let n = 0;
    for (const i1 of e)r.set(i1, n), n += i1.length;
    return r;
}
function nr(e) {
    const t = e || new Uint8Array();
    return t.length > 512 ? bW(t) : mW(t);
}
function mW(e) {
    let t = "";
    for(let r = 0; r < e.length; ++r)t += im[am[om[e[r] >> 4]]], t += im[am[om[e[r] & 15]]];
    return t;
}
function bW(e) {
    const t = new Uint8Array(e.length * 2);
    for(let r = 0; r < e.length; ++r)t[r * 2] = om[e[r] >> 4], t[r * 2 + 1] = om[e[r] & 15];
    return HB.decode(t);
}
function zu(e) {
    const t = LB.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
    let n;
    for(n = 0; n < r.length; n++){
        const i1 = am[t[n * 2]], o = am[t[n * 2 + 1]];
        if (i1 === void 0 || o === void 0) break;
        r[n] = i1 << 4 | o;
    }
    return n === r.length ? r : r.slice(0, n);
}
function wW(e) {
    return btoa(String.fromCharCode(...e));
}
function KB(e) {
    const t = atob(e), r = new Uint8Array(t.length);
    for(let n = 0; n < t.length; n++)r[n] = t.charCodeAt(n);
    return r;
}
function Ot(e, t) {
    const r = Math.min(e.length, t.length);
    for(let n = 0; n < r; ++n)if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
    return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function Qo(e, t, r) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 255) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
    return e[t] = r, t + 1;
}
function AW(e, t, r, n) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 65535) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
    return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function s1(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 4294967295) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
    return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function vW(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 0xffffffffffffffffn) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
    return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function Nu(e, t) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    return e[t];
}
function EW(e, t, r) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
    }
}
function Bh(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
    }
}
function qB(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 2147483647 || r < -2147483648) throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
    return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function VB(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n) throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
    return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function SW(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
        return e[t + 3] <= 127 ? n : n - 4294967296;
    } else {
        const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
        return e[t] <= 127 ? n : n - 4294967296;
    }
}
function WB(e, t, r) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    r = r.toUpperCase();
    let n = 0n;
    if (r === "LE") return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
    {
        let i1 = 0n;
        return i1 = (i1 << 8n) + BigInt(e[t]), i1 = (i1 << 8n) + BigInt(e[t + 1]), i1 = (i1 << 8n) + BigInt(e[t + 2]), i1 = (i1 << 8n) + BigInt(e[t + 3]), i1 = (i1 << 8n) + BigInt(e[t + 4]), i1 = (i1 << 8n) + BigInt(e[t + 5]), i1 = (i1 << 8n) + BigInt(e[t + 6]), i1 = (i1 << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i1 : i1 - 0x10000000000000000n;
    }
}
function GB(e) {
    return e < Zr.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function xW(e, t, r) {
    const n = GB(t);
    return n === 1 ? Qo(e, r, t) : n === 2 ? (Qo(e, r, Zr.OP_PUSHDATA1), Qo(e, r + 1, t)) : n === 3 ? (Qo(e, r, Zr.OP_PUSHDATA2), AW(e, r + 1, t, "LE")) : (Qo(e, r, Zr.OP_PUSHDATA4), s1(e, r + 1, t, "LE")), n;
}
function _W(e, t) {
    const r = Nu(e, t);
    let n, i1;
    if (r < Zr.OP_PUSHDATA1) n = r, i1 = 1;
    else if (r === Zr.OP_PUSHDATA1) {
        if (t + 2 > e.length) return null;
        n = Nu(e, t + 1), i1 = 2;
    } else if (r === Zr.OP_PUSHDATA2) {
        if (t + 3 > e.length) return null;
        n = EW(e, t + 1, "LE"), i1 = 3;
    } else {
        if (t + 5 > e.length) return null;
        if (r !== Zr.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        n = Bh(e, t + 1, "LE"), i1 = 5;
    }
    return {
        opcode: r,
        number: n,
        size: i1
    };
}
function kW(e) {
    return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function OW(e) {
    let t = Math.abs(e);
    const r = kW(t), n = new Uint8Array(r), i1 = e < 0;
    for(let o = 0; o < r; ++o)Qo(n, o, t & 255), t >>= 8;
    return n[r - 1] & 128 ? Qo(n, r - 1, i1 ? 128 : 0) : i1 && (n[r - 1] |= 128), n;
}
function IW(e) {
    return {
        lang: (e == null ? void 0 : e.lang) ?? void 0,
        message: e == null ? void 0 : e.message,
        abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
        abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
    };
}
function BW(e, t) {
    var r;
    return (r = void 0) == null ? void 0 : r.get(t);
}
function u0(e) {
    var t, r;
    const n = typeof e;
    return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function Wi(e, t, r, n, i1) {
    const o = i1 && "input" in i1 ? i1.input : r.value, a = (i1 == null ? void 0 : i1.expected) ?? e.expects ?? null, s = (i1 == null ? void 0 : i1.received) ?? u0(o), c = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: a,
        received: s,
        message: `Invalid ${t}: ${a ? `Expected ${a} but r` : "R"}eceived ${s}`,
        // @ts-expect-error
        requirement: e.requirement,
        path: i1 == null ? void 0 : i1.path,
        issues: i1 == null ? void 0 : i1.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, l = e.kind === "schema", u = (i1 == null ? void 0 : i1.message) ?? // @ts-expect-error
    e.message ?? BW(e.reference, c.lang) ?? (l ? (c.lang, void 0) : null) ?? n.message ?? (c.lang, void 0);
    u && (c.message = typeof u == "function" ? u(c) : u), l && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [
        c
    ];
}
function TW(e, t) {
    const r = [
        ...new Set(e)
    ];
    return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var PW = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(e){
        super(e[0].message), wt(this, "issues"), this.name = "ValiError", this.issues = e;
    }
};
function QB(e, t) {
    return {
        kind: "validation",
        type: "every_item",
        reference: QB,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !r.value.every(this.requirement) && Wi(this, "item", r, n), r;
        }
    };
}
function c6(e) {
    return {
        kind: "validation",
        type: "integer",
        reference: c6,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run (t, r) {
            return t.typed && !this.requirement(t.value) && Wi(this, "integer", t, r), t;
        }
    };
}
function $B(e, t) {
    return {
        kind: "validation",
        type: "length",
        reference: $B,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length !== this.requirement && Wi(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function S2(e, t) {
    return {
        kind: "validation",
        type: "max_value",
        reference: S2,
        async: !1,
        expects: `<=${e instanceof Date ? e.toJSON() : u0(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value > this.requirement && Wi(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : u0(r.value)
            }), r;
        }
    };
}
function x2(e, t) {
    return {
        kind: "validation",
        type: "min_value",
        reference: x2,
        async: !1,
        expects: `>=${e instanceof Date ? e.toJSON() : u0(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value < this.requirement && Wi(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : u0(r.value)
            }), r;
        }
    };
}
function ZB(e, t) {
    return {
        kind: "validation",
        type: "regex",
        reference: ZB,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement.test(r.value) && Wi(this, "format", r, n), r;
        }
    };
}
function l6(e, t, r) {
    return typeof e.default == "function" ? // @ts-expect-error
    e.default(t, r) : // @ts-expect-error
    e.default;
}
function _2(e, t) {
    return !e._run({
        typed: !1,
        value: t
    }, {
        abortEarly: !0
    }).issues;
}
function XB() {
    return {
        kind: "schema",
        type: "any",
        reference: XB,
        expects: "any",
        async: !1,
        _run (e) {
            return e.typed = !0, e;
        }
    };
}
function Bo(e, t) {
    return {
        kind: "schema",
        type: "array",
        reference: Bo,
        expects: "Array",
        async: !1,
        item: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (Array.isArray(o)) {
                r.typed = !0, r.value = [];
                for(let a = 0; a < o.length; a++){
                    const s = o[a], c = this.item._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "array",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), r.value.push(c.value);
                }
            } else Wi(this, "type", r, n);
            return r;
        }
    };
}
function YB(e) {
    return {
        kind: "schema",
        type: "bigint",
        reference: YB,
        expects: "bigint",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "bigint" ? t.typed = !0 : Wi(this, "type", t, r), t;
        }
    };
}
function cs(e, t) {
    return {
        kind: "schema",
        type: "custom",
        reference: cs,
        expects: "unknown",
        async: !1,
        check: e,
        message: t,
        _run (r, n) {
            return this.check(r.value) ? r.typed = !0 : Wi(this, "type", r, n), r;
        }
    };
}
function k2(e, t) {
    return {
        kind: "schema",
        type: "instance",
        reference: k2,
        expects: e.name,
        async: !1,
        class: e,
        message: t,
        _run (r, n) {
            return r.value instanceof this.class ? r.typed = !0 : Wi(this, "type", r, n), r;
        }
    };
}
function g8(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullable",
        reference: g8,
        expects: `(${e.expects} | null)`,
        async: !1,
        wrapped: e,
        _run (n, i1) {
            return n.value === null && ("default" in this && (n.value = l6(this, n, i1)), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, i1);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function JB(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullish",
        reference: JB,
        expects: `(${e.expects} | null | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i1) {
            return (n.value === null || n.value === void 0) && ("default" in this && (n.value = l6(this, n, i1)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i1);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function So(e) {
    return {
        kind: "schema",
        type: "number",
        reference: So,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Wi(this, "type", t, r), t;
        }
    };
}
function Zn(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: Zn,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (o && typeof o == "object") {
                r.typed = !0, r.value = {};
                for(const a in this.entries){
                    const s = o[a], c = this.entries[a]._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), (c.value !== void 0 || a in o) && (r.value[a] = c.value);
                }
            } else Wi(this, "type", r, n);
            return r;
        }
    };
}
function sm(e, ...t) {
    const r = {
        kind: "schema",
        type: "optional",
        reference: sm,
        expects: `(${e.expects} | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i1) {
            return n.value === void 0 && ("default" in this && (n.value = l6(this, n, i1)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i1);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function If(e) {
    return {
        kind: "schema",
        type: "string",
        reference: If,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : Wi(this, "type", t, r), t;
        }
    };
}
function Ms(e, t) {
    return {
        kind: "schema",
        type: "tuple",
        reference: Ms,
        expects: "Array",
        async: !1,
        items: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (Array.isArray(o)) {
                r.typed = !0, r.value = [];
                for(let a = 0; a < this.items.length; a++){
                    const s = o[a], c = this.items[a]._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "array",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), r.value.push(c.value);
                }
            } else Wi(this, "type", r, n);
            return r;
        }
    };
}
function WE(e) {
    let t;
    if (e) for (const r of e)t ? t.push(...r.issues) : t = r.issues;
    return t;
}
function f6(e, t) {
    return {
        kind: "schema",
        type: "union",
        reference: f6,
        expects: TW(e.map((r)=>r.expects), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            let i1, o, a;
            for (const s of this.options){
                const c = s._run({
                    typed: !1,
                    value: r.value
                }, n);
                if (c.typed) if (c.issues) o ? o.push(c) : o = [
                    c
                ];
                else {
                    i1 = c;
                    break;
                }
                else a ? a.push(c) : a = [
                    c
                ];
            }
            if (i1) return i1;
            if (o) {
                if (o.length === 1) return o[0];
                Wi(this, "type", r, n, {
                    issues: WE(o)
                }), r.typed = !0;
            } else {
                if ((a == null ? void 0 : a.length) === 1) return a[0];
                Wi(this, "type", r, n, {
                    issues: WE(a)
                });
            }
            return r;
        }
    };
}
function Bn(e, t, r) {
    const n = e._run({
        typed: !1,
        value: t
    }, IW(r));
    if (n.issues) throw new PW(n.issues);
    return n.value;
}
function Qc(e, t) {
    const r = {};
    for(const n in e.entries)r[n] = sm(e.entries[n]);
    return {
        ...e,
        entries: r
    };
}
function Th(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
const GE = new Uint8Array(32), QE = zu("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), oi = (e)=>Th(k2(Uint8Array), $B(e));
function c0(e, t) {
    return e.length !== t.length ? !1 : e.every((r, n)=>Ot(r, t[n]) === 0);
}
function is(e) {
    if (!(e instanceof Uint8Array) || e.length < 33) return !1;
    const t = e[0], r = e.slice(1, 33);
    if (Ot(GE, r) === 0 || Ot(r, QE) >= 0) return !1;
    if ((t === 2 || t === 3) && e.length === 33) return !0;
    const n = e.slice(33);
    return Ot(GE, n) === 0 || Ot(n, QE) >= 0 ? !1 : t === 4 && e.length === 65;
}
const Dy = 254;
function d6(e) {
    return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? !1 : e.version !== void 0 ? (e.version & Dy) === e.version : !0;
}
function eT(e) {
    return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t)=>eT(t)) : d6(e);
}
const CW = oi(32), MW = oi(20), $E = oi(32), sn = k2(Uint8Array);
Th(If(), ZB(/^([0-9a-f]{2})+$/i));
const NW = Th(So(), c6(), x2(0), S2(255)), Eu = Th(So(), c6(), x2(0), S2(4294967295)), sA = Th(YB(), x2(0n), S2(0x7fffffffffffffffn)), ZE = (e)=>Zn(Object.entries(e).reduce((t, r)=>({
            ...t,
            [r[0]]: JB(r[1])
        }), {})), XE = new Uint8Array(1);
function YE(e) {
    let t = 0;
    for(; e[t] === 0;)++t;
    return t === e.length ? XE : (e = e.slice(t), e[0] & 128 ? Mn([
        XE,
        e
    ]) : e);
}
function JE(e) {
    e[0] === 0 && (e = e.slice(1));
    const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
    return t.set(e, r), t;
}
function RW(e) {
    const t = Nu(e, e.length - 1);
    if (!p6(t)) throw new Error("Invalid hashType " + t);
    const r = hW(e.subarray(0, -1)), n = JE(r.r), i1 = JE(r.s);
    return {
        signature: Mn([
            n,
            i1
        ]),
        hashType: t
    };
}
function UW(e, t) {
    if (Bn(Zn({
        signature: oi(64),
        hashType: NW
    }), {
        signature: e,
        hashType: t
    }), !p6(t)) throw new Error("Invalid hashType " + t);
    const r = new Uint8Array(1);
    Qo(r, 0, t);
    const n = YE(e.slice(0, 32)), i1 = YE(e.slice(32, 64));
    return Mn([
        pW(n, i1),
        r
    ]);
}
const DW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    decode: RW,
    encode: UW
}, Symbol.toStringTag, {
    value: "Module"
})), tT = Zr.OP_RESERVED, rT = Bo(f6([
    k2(Uint8Array),
    So()
]));
function jW(e) {
    return _2(So(), e) && (e === Zr.OP_0 || e >= Zr.OP_1 && e <= Zr.OP_16 || e === Zr.OP_1NEGATE);
}
function nT(e) {
    return _2(sn, e) || jW(e);
}
function h6(e) {
    return _2(Th(XB(), QB(nT)), e);
}
function iT(e) {
    return e.length - e.filter(nT).length;
}
function um(e) {
    if (e.length === 0) return Zr.OP_0;
    if (e.length === 1) {
        if (e[0] >= 1 && e[0] <= 16) return tT + e[0];
        if (e[0] === 129) return Zr.OP_1NEGATE;
    }
}
function oT(e) {
    return e instanceof Uint8Array;
}
function FW(e) {
    return _2(rT, e);
}
function cm(e) {
    return e instanceof Uint8Array;
}
function Vi(e) {
    if (oT(e)) return e;
    Bn(rT, e);
    const t = e.reduce((i1, o)=>cm(o) ? o.length === 1 && um(o) !== void 0 ? i1 + 1 : i1 + GB(o.length) + o.length : i1 + 1, 0), r = new Uint8Array(t);
    let n = 0;
    if (e.forEach((i1)=>{
        if (cm(i1)) {
            const o = um(i1);
            if (o !== void 0) {
                Qo(r, n, o), n += 1;
                return;
            }
            n += xW(r, i1.length, n), r.set(i1, n), n += i1.length;
        } else Qo(r, n, i1), n += 1;
    }), n !== r.length) throw new Error("Could not decode chunks");
    return r;
}
function Tn(e) {
    if (FW(e)) return e;
    Bn(sn, e);
    const t = [];
    let r = 0;
    for(; r < e.length;){
        const n = e[r];
        if (n > Zr.OP_0 && n <= Zr.OP_PUSHDATA4) {
            const i1 = _W(e, r);
            if (i1 === null || (r += i1.size, r + i1.number > e.length)) return null;
            const o = e.slice(r, r + i1.number);
            r += i1.number;
            const a = um(o);
            a !== void 0 ? t.push(a) : t.push(o);
        } else t.push(n), r += 1;
    }
    return t;
}
function zW(e) {
    if (oT(e) && (e = Tn(e)), !e) throw new Error("Could not convert invalid chunks to ASM");
    return e.map((t)=>{
        if (cm(t)) {
            const r = um(t);
            if (r === void 0) return nr(t);
            t = r;
        }
        return zB[t];
    }).join(" ");
}
function LW(e) {
    return e = Tn(e), Bn(cs(h6), e), e.map((t)=>cm(t) ? t : t === Zr.OP_0 ? new Uint8Array(0) : OW(t - tT));
}
function HW(e) {
    return is(e);
}
function p6(e) {
    const t = e & -129;
    return t > 0 && t < 4;
}
function Ru(e) {
    return !(e instanceof Uint8Array) || !p6(e[e.length - 1]) ? !1 : dW(e.slice(0, -1));
}
const Vp = DW;
function Zt(e, t, r) {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !0,
        get () {
            const n = r.call(this);
            return this[t] = n, n;
        },
        set (n) {
            Object.defineProperty(this, t, {
                configurable: !0,
                enumerable: !0,
                value: n,
                writable: !0
            });
        }
    });
}
function Ta(e) {
    let t;
    return ()=>(t !== void 0 || (t = e()), t);
}
const Sd = Zr, Dg = Sd.OP_RESERVED;
function O2(e, t) {
    if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {});
    function r(s) {
        return Ru(s) || (t.allowIncomplete && s === Sd.OP_0) !== void 0;
    }
    Bn(Qc(Zn({
        network: Zn({}),
        m: So(),
        n: So(),
        output: sn,
        pubkeys: Bo(cs(is), "Received invalid pubkey"),
        signatures: Bo(cs(r), "Expected signature to be of type isAcceptableSignature"),
        input: sn
    })), e);
    const n = {
        network: e.network || ds
    };
    let i1 = [], o = !1;
    function a(s) {
        o || (o = !0, i1 = Tn(s), n.m = i1[0] - Dg, n.n = i1[i1.length - 2] - Dg, n.pubkeys = i1.slice(1, -2));
    }
    if (Zt(n, "output", ()=>{
        if (e.m && n.n && e.pubkeys) return Vi([].concat(Dg + e.m, e.pubkeys, Dg + n.n, Sd.OP_CHECKMULTISIG));
    }), Zt(n, "m", ()=>{
        if (n.output) return a(n.output), n.m;
    }), Zt(n, "n", ()=>{
        if (n.pubkeys) return n.pubkeys.length;
    }), Zt(n, "pubkeys", ()=>{
        if (e.output) return a(e.output), n.pubkeys;
    }), Zt(n, "signatures", ()=>{
        if (e.input) return Tn(e.input).slice(1);
    }), Zt(n, "input", ()=>{
        if (e.signatures) return Vi([
            Sd.OP_0
        ].concat(e.signatures));
    }), Zt(n, "witness", ()=>{
        if (n.input) return [];
    }), Zt(n, "name", ()=>{
        if (!(!n.m || !n.n)) return `p2ms(${n.m} of ${n.n})`;
    }), t.validate) {
        if (e.output) {
            if (a(e.output), Bn(So(), i1[0], {
                message: "Output is invalid"
            }), Bn(So(), i1[i1.length - 2], {
                message: "Output is invalid"
            }), i1[i1.length - 1] !== Sd.OP_CHECKMULTISIG) throw new TypeError("Output is invalid");
            if (n.m <= 0 || n.n > 16 || n.m > n.n || n.n !== i1.length - 3) throw new TypeError("Output is invalid");
            if (!n.pubkeys.every((s)=>is(s))) throw new TypeError("Output is invalid");
            if (e.m !== void 0 && e.m !== n.m) throw new TypeError("m mismatch");
            if (e.n !== void 0 && e.n !== n.n) throw new TypeError("n mismatch");
            if (e.pubkeys && !c0(e.pubkeys, n.pubkeys)) throw new TypeError("Pubkeys mismatch");
        }
        if (e.pubkeys) {
            if (e.n !== void 0 && e.n !== e.pubkeys.length) throw new TypeError("Pubkey count mismatch");
            if (n.n = e.pubkeys.length, n.n < n.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (e.signatures) {
            if (e.signatures.length < n.m) throw new TypeError("Not enough signatures provided");
            if (e.signatures.length > n.m) throw new TypeError("Too many signatures provided");
        }
        if (e.input) {
            if (e.input[0] !== Sd.OP_0) throw new TypeError("Input is invalid");
            if (n.signatures.length === 0 || !n.signatures.every(r)) throw new TypeError("Input has invalid signature(s)");
            if (e.signatures && !c0(e.signatures, n.signatures)) throw new TypeError("Signature mismatch");
            if (e.m !== void 0 && e.m !== e.signatures.length) throw new TypeError("Signature count mismatch");
        }
    }
    return Object.assign(n, e);
}
const eS = Zr;
function aT(e, t) {
    if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), Bn(Qc(Zn({
        network: Zn({}),
        output: sn,
        pubkey: cs(is, "invalid pubkey"),
        signature: cs(Ru, "Expected signature to be of type isCanonicalScriptSignature"),
        input: sn
    })), e);
    const r = Ta(()=>Tn(e.input)), n = {
        name: "p2pk",
        network: e.network || ds
    };
    if (Zt(n, "output", ()=>{
        if (e.pubkey) return Vi([
            e.pubkey,
            eS.OP_CHECKSIG
        ]);
    }), Zt(n, "pubkey", ()=>{
        if (e.output) return e.output.slice(1, -1);
    }), Zt(n, "signature", ()=>{
        if (e.input) return r()[0];
    }), Zt(n, "input", ()=>{
        if (e.signature) return Vi([
            e.signature
        ]);
    }), Zt(n, "witness", ()=>{
        if (n.input) return [];
    }), t.validate) {
        if (e.output) {
            if (e.output[e.output.length - 1] !== eS.OP_CHECKSIG) throw new TypeError("Output is invalid");
            if (!is(n.pubkey)) throw new TypeError("Output pubkey is invalid");
            if (e.pubkey && Ot(e.pubkey, n.pubkey) !== 0) throw new TypeError("Pubkey mismatch");
        }
        if (e.signature && e.input && Ot(e.input, n.input) !== 0) throw new TypeError("Signature mismatch");
        if (e.input) {
            if (r().length !== 1) throw new TypeError("Input is invalid");
            if (!Ru(n.signature)) throw new TypeError("Input has invalid signature");
        }
    }
    return Object.assign(n, e);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function KW(e) {
    return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function tS(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function I2(e, ...t) {
    if (!KW(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function qW(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    tS(e.outputLen), tS(e.blockLen);
}
function lm(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function VW(e, t) {
    I2(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error("digestInto() expects output buffer of length at least " + r);
}
function $c(...e) {
    for(let t = 0; t < e.length; t++)e[t].fill(0);
}
function uA(e) {
    return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function bs(e, t) {
    return e << 32 - t | e >>> t;
}
function jg(e, t) {
    return e << t | e >>> 32 - t >>> 0;
}
function WW(e) {
    if (typeof e != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(e));
}
function g6(e) {
    return typeof e == "string" && (e = WW(e)), I2(e), e;
}
let sT = class {
};
function y6(e) {
    const t = (n)=>e().update(g6(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function GW(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
function QW(e, t, r) {
    return e & t ^ ~e & r;
}
function $W(e, t, r) {
    return e & t ^ e & r ^ t & r;
}
let m6 = class extends sT {
    constructor(e, t, r, n){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.buffer = new Uint8Array(e), this.view = uA(this.buffer);
    }
    update(e) {
        lm(this), e = g6(e), I2(e);
        const { view: t, buffer: r, blockLen: n } = this, i1 = e.length;
        for(let o = 0; o < i1;){
            const a = Math.min(n - this.pos, i1 - o);
            if (a === n) {
                const s = uA(e);
                for(; n <= i1 - o; o += n)this.process(s, o);
                continue;
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        lm(this), VW(e, this), this.finished = !0;
        const { buffer: t, view: r, blockLen: n, isLE: i1 } = this;
        let { pos: o } = this;
        t[o++] = 128, $c(this.buffer.subarray(o)), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for(let u = o; u < n; u++)t[u] = 0;
        GW(r, n - 8, BigInt(this.length * 8), i1), this.process(r, 0);
        const a = uA(e), s = this.outputLen;
        if (s % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = s / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let u = 0; u < c; u++)a.setUint32(4 * u, l[u], i1);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: r, length: n, finished: i1, destroyed: o, pos: a } = this;
        return e.destroyed = o, e.finished = i1, e.length = n, e.pos = a, n % t && e.buffer.set(r), e;
    }
    clone() {
        return this._cloneInto();
    }
};
const tc = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Mi = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]), ZW = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), uT = Uint8Array.from(new Array(16).fill(0).map((e, t)=>t)), XW = uT.map((e)=>(9 * e + 5) % 16), cT = /* @__PURE__ */ (()=>{
    const e = [
        [
            uT
        ],
        [
            XW
        ]
    ];
    for(let t = 0; t < 4; t++)for (let r of e)r.push(r[t].map((n)=>ZW[n]));
    return e;
})(), lT = cT[0], fT = cT[1], dT = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>Uint8Array.from(e)), YW = /* @__PURE__ */ lT.map((e, t)=>e.map((r)=>dT[t][r])), JW = /* @__PURE__ */ fT.map((e, t)=>e.map((r)=>dT[t][r])), eG = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), tG = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]);
function rS(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const Fg = /* @__PURE__ */ new Uint32Array(16);
let rG = class extends m6 {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: e, h1: t, h2: r, h3: n, h4: i1 } = this;
        return [
            e,
            t,
            r,
            n,
            i1
        ];
    }
    set(e, t, r, n, i1) {
        this.h0 = e | 0, this.h1 = t | 0, this.h2 = r | 0, this.h3 = n | 0, this.h4 = i1 | 0;
    }
    process(e, t) {
        for(let h = 0; h < 16; h++, t += 4)Fg[h] = e.getUint32(t, !0);
        let r = this.h0 | 0, n = r, i1 = this.h1 | 0, o = i1, a = this.h2 | 0, s = a, c = this.h3 | 0, l = c, u = this.h4 | 0, f = u;
        for(let h = 0; h < 5; h++){
            const y = 4 - h, S = eG[h], k = tG[h], P = lT[h], M = fT[h], N = YW[h], z = JW[h];
            for(let K = 0; K < 16; K++){
                const $ = jg(r + rS(h, i1, a, c) + Fg[P[K]] + S, N[K]) + u | 0;
                r = u, u = c, c = jg(a, 10) | 0, a = i1, i1 = $;
            }
            for(let K = 0; K < 16; K++){
                const $ = jg(n + rS(y, o, s, l) + Fg[M[K]] + k, z[K]) + f | 0;
                n = f, f = l, l = jg(s, 10) | 0, s = o, o = $;
            }
        }
        this.set(this.h1 + a + l | 0, this.h2 + c + f | 0, this.h3 + u + n | 0, this.h4 + r + o | 0, this.h0 + i1 + s | 0);
    }
    roundClean() {
        $c(Fg);
    }
    destroy() {
        this.destroyed = !0, $c(this.buffer), this.set(0, 0, 0, 0, 0);
    }
};
const nG = /* @__PURE__ */ y6(()=>new rG()), hT = nG, zg = /* @__PURE__ */ BigInt(2 ** 32 - 1), nS = /* @__PURE__ */ BigInt(32);
function iG(e, t = !1) {
    return t ? {
        h: Number(e & zg),
        l: Number(e >> nS & zg)
    } : {
        h: Number(e >> nS & zg) | 0,
        l: Number(e & zg) | 0
    };
}
function oG(e, t = !1) {
    const r = e.length;
    let n = new Uint32Array(r), i1 = new Uint32Array(r);
    for(let o = 0; o < r; o++){
        const { h: a, l: s } = iG(e[o], t);
        [n[o], i1[o]] = [
            a,
            s
        ];
    }
    return [
        n,
        i1
    ];
}
const iS = (e, t, r)=>e >>> r, oS = (e, t, r)=>e << 32 - r | t >>> r, od = (e, t, r)=>e >>> r | t << 32 - r, ad = (e, t, r)=>e << 32 - r | t >>> r, Lg = (e, t, r)=>e << 64 - r | t >>> r - 32, Hg = (e, t, r)=>e >>> r - 32 | t << 64 - r;
function pu(e, t, r, n) {
    const i1 = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i1 / 2 ** 32 | 0) | 0,
        l: i1 | 0
    };
}
const aG = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0), sG = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0, uG = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), cG = (e, t, r, n, i1)=>t + r + n + i1 + (e / 2 ** 32 | 0) | 0, lG = (e, t, r, n, i1)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i1 >>> 0), fG = (e, t, r, n, i1, o)=>t + r + n + i1 + o + (e / 2 ** 32 | 0) | 0, dG = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), rc = /* @__PURE__ */ new Uint32Array(64);
let hG = class extends m6 {
    constructor(e = 32){
        super(64, e, 8, !1), this.A = tc[0] | 0, this.B = tc[1] | 0, this.C = tc[2] | 0, this.D = tc[3] | 0, this.E = tc[4] | 0, this.F = tc[5] | 0, this.G = tc[6] | 0, this.H = tc[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n, E: i1, F: o, G: a, H: s } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i1 | 0, this.F = o | 0, this.G = a | 0, this.H = s | 0;
    }
    process(e, t) {
        for(let u = 0; u < 16; u++, t += 4)rc[u] = e.getUint32(t, !1);
        for(let u = 16; u < 64; u++){
            const f = rc[u - 15], h = rc[u - 2], y = bs(f, 7) ^ bs(f, 18) ^ f >>> 3, S = bs(h, 17) ^ bs(h, 19) ^ h >>> 10;
            rc[u] = S + rc[u - 7] + y + rc[u - 16] | 0;
        }
        let { A: r, B: n, C: i1, D: o, E: a, F: s, G: c, H: l } = this;
        for(let u = 0; u < 64; u++){
            const f = bs(a, 6) ^ bs(a, 11) ^ bs(a, 25), h = l + f + QW(a, s, c) + dG[u] + rc[u] | 0, y = (bs(r, 2) ^ bs(r, 13) ^ bs(r, 22)) + $W(r, n, i1) | 0;
            l = c, c = s, s = a, a = o + h | 0, o = i1, i1 = n, n = r, r = h + y | 0;
        }
        r = r + this.A | 0, n = n + this.B | 0, i1 = i1 + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, n, i1, o, a, s, c, l);
    }
    roundClean() {
        $c(rc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), $c(this.buffer);
    }
};
const pT = oG([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), pG = pT[0], gG = pT[1], nc = /* @__PURE__ */ new Uint32Array(80), ic = /* @__PURE__ */ new Uint32Array(80);
let yG = class extends m6 {
    constructor(e = 64){
        super(128, e, 16, !1), this.Ah = Mi[0] | 0, this.Al = Mi[1] | 0, this.Bh = Mi[2] | 0, this.Bl = Mi[3] | 0, this.Ch = Mi[4] | 0, this.Cl = Mi[5] | 0, this.Dh = Mi[6] | 0, this.Dl = Mi[7] | 0, this.Eh = Mi[8] | 0, this.El = Mi[9] | 0, this.Fh = Mi[10] | 0, this.Fl = Mi[11] | 0, this.Gh = Mi[12] | 0, this.Gl = Mi[13] | 0, this.Hh = Mi[14] | 0, this.Hl = Mi[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: e, Al: t, Bh: r, Bl: n, Ch: i1, Cl: o, Dh: a, Dl: s, Eh: c, El: l, Fh: u, Fl: f, Gh: h, Gl: y, Hh: S, Hl: k } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s,
            c,
            l,
            u,
            f,
            h,
            y,
            S,
            k
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s, c, l, u, f, h, y, S, k) {
        this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = i1 | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = s | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = u | 0, this.Fl = f | 0, this.Gh = h | 0, this.Gl = y | 0, this.Hh = S | 0, this.Hl = k | 0;
    }
    process(e, t) {
        for(let N = 0; N < 16; N++, t += 4)nc[N] = e.getUint32(t), ic[N] = e.getUint32(t += 4);
        for(let N = 16; N < 80; N++){
            const z = nc[N - 15] | 0, K = ic[N - 15] | 0, $ = od(z, K, 1) ^ od(z, K, 8) ^ iS(z, K, 7), ne = ad(z, K, 1) ^ ad(z, K, 8) ^ oS(z, K, 7), ee = nc[N - 2] | 0, q = ic[N - 2] | 0, U = od(ee, q, 19) ^ Lg(ee, q, 61) ^ iS(ee, q, 6), Q = ad(ee, q, 19) ^ Hg(ee, q, 61) ^ oS(ee, q, 6), v = uG(ne, Q, ic[N - 7], ic[N - 16]), B = cG(v, $, U, nc[N - 7], nc[N - 16]);
            nc[N] = B | 0, ic[N] = v | 0;
        }
        let { Ah: r, Al: n, Bh: i1, Bl: o, Ch: a, Cl: s, Dh: c, Dl: l, Eh: u, El: f, Fh: h, Fl: y, Gh: S, Gl: k, Hh: P, Hl: M } = this;
        for(let N = 0; N < 80; N++){
            const z = od(u, f, 14) ^ od(u, f, 18) ^ Lg(u, f, 41), K = ad(u, f, 14) ^ ad(u, f, 18) ^ Hg(u, f, 41), $ = u & h ^ ~u & S, ne = f & y ^ ~f & k, ee = lG(M, K, ne, gG[N], ic[N]), q = fG(ee, P, z, $, pG[N], nc[N]), U = ee | 0, Q = od(r, n, 28) ^ Lg(r, n, 34) ^ Lg(r, n, 39), v = ad(r, n, 28) ^ Hg(r, n, 34) ^ Hg(r, n, 39), B = r & i1 ^ r & a ^ i1 & a, g = n & o ^ n & s ^ o & s;
            P = S | 0, M = k | 0, S = h | 0, k = y | 0, h = u | 0, y = f | 0, ({ h: u, l: f } = pu(c | 0, l | 0, q | 0, U | 0)), c = a | 0, l = s | 0, a = i1 | 0, s = o | 0, i1 = r | 0, o = n | 0;
            const E = aG(U, v, g);
            r = sG(E, q, Q, B), n = E | 0;
        }
        ({ h: r, l: n } = pu(this.Ah | 0, this.Al | 0, r | 0, n | 0)), ({ h: i1, l: o } = pu(this.Bh | 0, this.Bl | 0, i1 | 0, o | 0)), ({ h: a, l: s } = pu(this.Ch | 0, this.Cl | 0, a | 0, s | 0)), ({ h: c, l } = pu(this.Dh | 0, this.Dl | 0, c | 0, l | 0)), ({ h: u, l: f } = pu(this.Eh | 0, this.El | 0, u | 0, f | 0)), ({ h, l: y } = pu(this.Fh | 0, this.Fl | 0, h | 0, y | 0)), ({ h: S, l: k } = pu(this.Gh | 0, this.Gl | 0, S | 0, k | 0)), ({ h: P, l: M } = pu(this.Hh | 0, this.Hl | 0, P | 0, M | 0)), this.set(r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M);
    }
    roundClean() {
        $c(nc, ic);
    }
    destroy() {
        $c(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
const mG = /* @__PURE__ */ y6(()=>new hG()), bG = /* @__PURE__ */ y6(()=>new yG()), _i = mG;
function os(e) {
    return hT(_i(e));
}
function xl(e) {
    return _i(_i(e));
}
const wG = {
    "BIP0340/challenge": Uint8Array.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
    ]),
    "BIP0340/aux": Uint8Array.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
    ]),
    "BIP0340/nonce": Uint8Array.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
    ]),
    TapLeaf: Uint8Array.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
    ]),
    TapBranch: Uint8Array.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
    ]),
    TapSighash: Uint8Array.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
    ]),
    TapTweak: Uint8Array.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
    ]),
    "KeyAgg list": Uint8Array.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
    ]),
    "KeyAgg coefficient": Uint8Array.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
    ])
};
function B2(e, t) {
    return _i(Mn([
        wG[e],
        t
    ]));
}
function AG(e) {
    if (e.length >= 255) throw new TypeError("Alphabet too long");
    const t = new Uint8Array(256);
    for(let l = 0; l < t.length; l++)t[l] = 255;
    for(let l = 0; l < e.length; l++){
        const u = e.charAt(l), f = u.charCodeAt(0);
        if (t[f] !== 255) throw new TypeError(u + " is ambiguous");
        t[f] = l;
    }
    const r = e.length, n = e.charAt(0), i1 = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
    function a(l) {
        if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (l.length === 0) return "";
        let u = 0, f = 0, h = 0;
        const y = l.length;
        for(; h !== y && l[h] === 0;)h++, u++;
        const S = (y - h) * o + 1 >>> 0, k = new Uint8Array(S);
        for(; h !== y;){
            let N = l[h], z = 0;
            for(let K = S - 1; (N !== 0 || z < f) && K !== -1; K--, z++)N += 256 * k[K] >>> 0, k[K] = N % r >>> 0, N = N / r >>> 0;
            if (N !== 0) throw new Error("Non-zero carry");
            f = z, h++;
        }
        let P = S - f;
        for(; P !== S && k[P] === 0;)P++;
        let M = n.repeat(u);
        for(; P < S; ++P)M += e.charAt(k[P]);
        return M;
    }
    function s(l) {
        if (typeof l != "string") throw new TypeError("Expected String");
        if (l.length === 0) return new Uint8Array();
        let u = 0, f = 0, h = 0;
        for(; l[u] === n;)f++, u++;
        const y = (l.length - u) * i1 + 1 >>> 0, S = new Uint8Array(y);
        for(; u < l.length;){
            const N = l.charCodeAt(u);
            if (N > 255) return;
            let z = t[N];
            if (z === 255) return;
            let K = 0;
            for(let $ = y - 1; (z !== 0 || K < h) && $ !== -1; $--, K++)z += r * S[$] >>> 0, S[$] = z % 256 >>> 0, z = z / 256 >>> 0;
            if (z !== 0) throw new Error("Non-zero carry");
            h = K, u++;
        }
        let k = y - h;
        for(; k !== y && S[k] === 0;)k++;
        const P = new Uint8Array(f + (y - k));
        let M = f;
        for(; k !== y;)P[M++] = S[k++];
        return P;
    }
    function c(l) {
        const u = s(l);
        if (u) return u;
        throw new Error("Non-base" + r + " character");
    }
    return {
        encode: a,
        decodeUnsafe: s,
        decode: c
    };
}
var vG = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const cA = AG(vG);
function EG(e) {
    function t(o) {
        var a = Uint8Array.from(o), s = e(a), c = a.length + 4, l = new Uint8Array(c);
        return l.set(a, 0), l.set(s.subarray(0, 4), a.length), cA.encode(l);
    }
    function r(o) {
        var a = o.slice(0, -4), s = o.slice(-4), c = e(a);
        if (!(s[0] ^ c[0] | s[1] ^ c[1] | s[2] ^ c[2] | s[3] ^ c[3])) return a;
    }
    function n(o) {
        var a = cA.decodeUnsafe(o);
        if (a != null) return r(a);
    }
    function i1(o) {
        var a = cA.decode(o), s = r(a);
        if (s == null) throw new Error("Invalid checksum");
        return s;
    }
    return {
        encode: t,
        decode: i1,
        decodeUnsafe: n
    };
}
function SG(e) {
    return _i(_i(e));
}
const ch = EG(SG), oc = Zr;
function u1(e, t) {
    if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), Bn(Qc(Zn({
        network: Zn({}),
        address: If(),
        hash: MW,
        output: oi(25),
        pubkey: cs(is),
        signature: cs(Ru),
        input: sn
    })), e);
    const r = Ta(()=>{
        const a = ch.decode(e.address), s = Nu(a, 0), c = a.slice(1);
        return {
            version: s,
            hash: c
        };
    }), n = Ta(()=>Tn(e.input)), i1 = e.network || ds, o = {
        name: "p2pkh",
        network: i1
    };
    if (Zt(o, "address", ()=>{
        if (!o.hash) return;
        const a = new Uint8Array(21);
        return Qo(a, 0, i1.pubKeyHash), a.set(o.hash, 1), ch.encode(a);
    }), Zt(o, "hash", ()=>{
        if (e.output) return e.output.slice(3, 23);
        if (e.address) return r().hash;
        if (e.pubkey || o.pubkey) return os(e.pubkey || o.pubkey);
    }), Zt(o, "output", ()=>{
        if (o.hash) return Vi([
            oc.OP_DUP,
            oc.OP_HASH160,
            o.hash,
            oc.OP_EQUALVERIFY,
            oc.OP_CHECKSIG
        ]);
    }), Zt(o, "pubkey", ()=>{
        if (e.input) return n()[1];
    }), Zt(o, "signature", ()=>{
        if (e.input) return n()[0];
    }), Zt(o, "input", ()=>{
        if (e.pubkey && e.signature) return Vi([
            e.signature,
            e.pubkey
        ]);
    }), Zt(o, "witness", ()=>{
        if (o.input) return [];
    }), t.validate) {
        let a = Uint8Array.from([]);
        if (e.address) {
            if (r().version !== i1.pubKeyHash) throw new TypeError("Invalid version or Network mismatch");
            if (r().hash.length !== 20) throw new TypeError("Invalid address");
            a = r().hash;
        }
        if (e.hash) {
            if (a.length > 0 && Ot(a, e.hash) !== 0) throw new TypeError("Hash mismatch");
            a = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 25 || e.output[0] !== oc.OP_DUP || e.output[1] !== oc.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== oc.OP_EQUALVERIFY || e.output[24] !== oc.OP_CHECKSIG) throw new TypeError("Output is invalid");
            const s = e.output.slice(3, 23);
            if (a.length > 0 && Ot(a, s) !== 0) throw new TypeError("Hash mismatch");
            a = s;
        }
        if (e.pubkey) {
            const s = os(e.pubkey);
            if (a.length > 0 && Ot(a, s) !== 0) throw new TypeError("Hash mismatch");
            a = s;
        }
        if (e.input) {
            const s = n();
            if (s.length !== 2) throw new TypeError("Input is invalid");
            if (!Ru(s[0])) throw new TypeError("Input has invalid signature");
            if (!is(s[1])) throw new TypeError("Input has invalid pubkey");
            if (e.signature && Ot(e.signature, s[0]) !== 0) throw new TypeError("Signature mismatch");
            if (e.pubkey && Ot(e.pubkey, s[1]) !== 0) throw new TypeError("Pubkey mismatch");
            const c = os(s[1]);
            if (a.length > 0 && Ot(a, c) !== 0) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(o, e);
}
const wp = Zr;
function Ph(e, t) {
    if (!e.address && !e.hash && !e.output && !e.redeem && !e.input) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), Bn(Qc(Zn({
        network: Zn({}),
        address: If(),
        hash: oi(20),
        output: oi(23),
        redeem: Qc(Zn({
            network: Zn({}),
            output: sn,
            input: sn,
            witness: Bo(sn)
        })),
        input: sn,
        witness: Bo(sn)
    })), e);
    let r = e.network;
    r || (r = e.redeem && e.redeem.network || ds);
    const n = {
        network: r
    }, i1 = Ta(()=>{
        const s = ch.decode(e.address), c = Nu(s, 0), l = s.slice(1);
        return {
            version: c,
            hash: l
        };
    }), o = Ta(()=>Tn(e.input)), a = Ta(()=>{
        const s = o(), c = s[s.length - 1];
        return {
            network: r,
            output: c === wp.OP_FALSE ? Uint8Array.from([]) : c,
            input: Vi(s.slice(0, -1)),
            witness: e.witness || []
        };
    });
    if (Zt(n, "address", ()=>{
        if (!n.hash) return;
        const s = new Uint8Array(21);
        return Qo(s, 0, n.network.scriptHash), s.set(n.hash, 1), ch.encode(s);
    }), Zt(n, "hash", ()=>{
        if (e.output) return e.output.slice(2, 22);
        if (e.address) return i1().hash;
        if (n.redeem && n.redeem.output) return os(n.redeem.output);
    }), Zt(n, "output", ()=>{
        if (n.hash) return Vi([
            wp.OP_HASH160,
            n.hash,
            wp.OP_EQUAL
        ]);
    }), Zt(n, "redeem", ()=>{
        if (e.input) return a();
    }), Zt(n, "input", ()=>{
        if (!(!e.redeem || !e.redeem.input || !e.redeem.output)) return Vi([].concat(Tn(e.redeem.input), e.redeem.output));
    }), Zt(n, "witness", ()=>{
        if (n.redeem && n.redeem.witness) return n.redeem.witness;
        if (n.input) return [];
    }), Zt(n, "name", ()=>{
        const s = [
            "p2sh"
        ];
        return n.redeem !== void 0 && n.redeem.name !== void 0 && s.push(n.redeem.name), s.join("-");
    }), t.validate) {
        let s = Uint8Array.from([]);
        if (e.address) {
            if (i1().version !== r.scriptHash) throw new TypeError("Invalid version or Network mismatch");
            if (i1().hash.length !== 20) throw new TypeError("Invalid address");
            s = i1().hash;
        }
        if (e.hash) {
            if (s.length > 0 && Ot(s, e.hash) !== 0) throw new TypeError("Hash mismatch");
            s = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 23 || e.output[0] !== wp.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== wp.OP_EQUAL) throw new TypeError("Output is invalid");
            const l = e.output.slice(2, 22);
            if (s.length > 0 && Ot(s, l) !== 0) throw new TypeError("Hash mismatch");
            s = l;
        }
        const c = (l)=>{
            if (l.output) {
                const u = Tn(l.output);
                if (!u || u.length < 1) throw new TypeError("Redeem.output too short");
                if (l.output.byteLength > 520) throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
                if (iT(u) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
                const f = os(l.output);
                if (s.length > 0 && Ot(s, f) !== 0) throw new TypeError("Hash mismatch");
                s = f;
            }
            if (l.input) {
                const u = l.input.length > 0, f = l.witness && l.witness.length > 0;
                if (!u && !f) throw new TypeError("Empty input");
                if (u && f) throw new TypeError("Input and witness provided");
                if (u) {
                    const h = Tn(l.input);
                    if (!h6(h)) throw new TypeError("Non push-only scriptSig");
                }
            }
        };
        if (e.input) {
            const l = o();
            if (!l || l.length < 1) throw new TypeError("Input too short");
            if (!(a().output instanceof Uint8Array)) throw new TypeError("Input is invalid");
            c(a());
        }
        if (e.redeem) {
            if (e.redeem.network && e.redeem.network !== r) throw new TypeError("Network mismatch");
            if (e.input) {
                const l = a();
                if (e.redeem.output && Ot(e.redeem.output, l.output) !== 0) throw new TypeError("Redeem.output mismatch");
                if (e.redeem.input && Ot(e.redeem.input, l.input) !== 0) throw new TypeError("Redeem.input mismatch");
            }
            c(e.redeem);
        }
        if (e.witness && e.redeem && e.redeem.witness && !c0(e.redeem.witness, e.witness)) throw new TypeError("Witness and redeem.witness mismatch");
    }
    return Object.assign(n, e);
}
var Qe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : ("TURBOPACK compile-time value", "object") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g : typeof self < "u" ? self : {};
function gT(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xG(e) {
    if (e.__esModule) return e;
    var t = e.default;
    if (typeof t == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
        };
        r.prototype = t.prototype;
    } else r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(n) {
        var i1 = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(r, n, i1.get ? i1 : {
            enumerable: !0,
            get: function() {
                return e[n];
            }
        });
    }), r;
}
var l0 = {};
Object.defineProperty(l0, "__esModule", {
    value: !0
});
var f0 = l0.bech32m = $o = l0.bech32 = void 0;
const fm = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", yT = {};
for(let e = 0; e < fm.length; e++){
    const t = fm.charAt(e);
    yT[t] = e;
}
function Rd(e) {
    const t = e >> 25;
    return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function aS(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = e.charCodeAt(r);
        if (n < 33 || n > 126) return "Invalid prefix (" + e + ")";
        t = Rd(t) ^ n >> 5;
    }
    t = Rd(t);
    for(let r = 0; r < e.length; ++r){
        const n = e.charCodeAt(r);
        t = Rd(t) ^ n & 31;
    }
    return t;
}
function b6(e, t, r, n) {
    let i1 = 0, o = 0;
    const a = (1 << r) - 1, s = [];
    for(let c = 0; c < e.length; ++c)for(i1 = i1 << t | e[c], o += t; o >= r;)o -= r, s.push(i1 >> o & a);
    if (n) o > 0 && s.push(i1 << r - o & a);
    else {
        if (o >= t) return "Excess padding";
        if (i1 << r - o & a) return "Non-zero padding";
    }
    return s;
}
function _G(e) {
    return b6(e, 8, 5, !0);
}
function kG(e) {
    const t = b6(e, 5, 8, !1);
    if (Array.isArray(t)) return t;
}
function OG(e) {
    const t = b6(e, 5, 8, !1);
    if (Array.isArray(t)) return t;
    throw new Error(t);
}
function mT(e) {
    let t;
    e === "bech32" ? t = 1 : t = 734539939;
    function r(a, s, c) {
        if (c = c || 90, a.length + 7 + s.length > c) throw new TypeError("Exceeds length limit");
        a = a.toLowerCase();
        let l = aS(a);
        if (typeof l == "string") throw new Error(l);
        let u = a + "1";
        for(let f = 0; f < s.length; ++f){
            const h = s[f];
            if (h >> 5) throw new Error("Non 5-bit word");
            l = Rd(l) ^ h, u += fm.charAt(h);
        }
        for(let f = 0; f < 6; ++f)l = Rd(l);
        l ^= t;
        for(let f = 0; f < 6; ++f){
            const h = l >> (5 - f) * 5 & 31;
            u += fm.charAt(h);
        }
        return u;
    }
    function n(a, s) {
        if (s = s || 90, a.length < 8) return a + " too short";
        if (a.length > s) return "Exceeds length limit";
        const c = a.toLowerCase(), l = a.toUpperCase();
        if (a !== c && a !== l) return "Mixed-case string " + a;
        a = c;
        const u = a.lastIndexOf("1");
        if (u === -1) return "No separator character for " + a;
        if (u === 0) return "Missing prefix for " + a;
        const f = a.slice(0, u), h = a.slice(u + 1);
        if (h.length < 6) return "Data too short";
        let y = aS(f);
        if (typeof y == "string") return y;
        const S = [];
        for(let k = 0; k < h.length; ++k){
            const P = h.charAt(k), M = yT[P];
            if (M === void 0) return "Unknown character " + P;
            y = Rd(y) ^ M, !(k + 6 >= h.length) && S.push(M);
        }
        return y !== t ? "Invalid checksum for " + a : {
            prefix: f,
            words: S
        };
    }
    function i1(a, s) {
        const c = n(a, s);
        if (typeof c == "object") return c;
    }
    function o(a, s) {
        const c = n(a, s);
        if (typeof c == "object") return c;
        throw new Error(c);
    }
    return {
        decodeUnsafe: i1,
        decode: o,
        encode: r,
        toWords: _G,
        fromWordsUnsafe: kG,
        fromWords: OG
    };
}
var $o = l0.bech32 = mT("bech32");
f0 = l0.bech32m = mT("bech32m");
const sS = Zr, IG = new Uint8Array(0);
function c1(e, t) {
    if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), Bn(Qc(Zn({
        address: If(),
        hash: oi(20),
        input: oi(0),
        network: Zn({}),
        output: oi(22),
        pubkey: cs(is, "Not a valid pubkey"),
        signature: cs(Ru),
        witness: Bo(sn)
    })), e);
    const r = Ta(()=>{
        const o = $o.decode(e.address), a = o.words.shift(), s = $o.fromWords(o.words);
        return {
            version: a,
            prefix: o.prefix,
            data: Uint8Array.from(s)
        };
    }), n = e.network || ds, i1 = {
        name: "p2wpkh",
        network: n
    };
    if (Zt(i1, "address", ()=>{
        if (!i1.hash) return;
        const o = $o.toWords(i1.hash);
        return o.unshift(0), $o.encode(n.bech32, o);
    }), Zt(i1, "hash", ()=>{
        if (e.output) return e.output.slice(2, 22);
        if (e.address) return r().data;
        if (e.pubkey || i1.pubkey) return os(e.pubkey || i1.pubkey);
    }), Zt(i1, "output", ()=>{
        if (i1.hash) return Vi([
            sS.OP_0,
            i1.hash
        ]);
    }), Zt(i1, "pubkey", ()=>{
        if (e.pubkey) return e.pubkey;
        if (e.witness) return e.witness[1];
    }), Zt(i1, "signature", ()=>{
        if (e.witness) return e.witness[0];
    }), Zt(i1, "input", ()=>{
        if (i1.witness) return IG;
    }), Zt(i1, "witness", ()=>{
        if (e.pubkey && e.signature) return [
            e.signature,
            e.pubkey
        ];
    }), t.validate) {
        let o = Uint8Array.from([]);
        if (e.address) {
            if (n && n.bech32 !== r().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== 0) throw new TypeError("Invalid address version");
            if (r().data.length !== 20) throw new TypeError("Invalid address data");
            o = r().data;
        }
        if (e.hash) {
            if (o.length > 0 && Ot(o, e.hash) !== 0) throw new TypeError("Hash mismatch");
            o = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 22 || e.output[0] !== sS.OP_0 || e.output[1] !== 20) throw new TypeError("Output is invalid");
            if (o.length > 0 && Ot(o, e.output.slice(2)) !== 0) throw new TypeError("Hash mismatch");
            o = e.output.slice(2);
        }
        if (e.pubkey) {
            const a = os(e.pubkey);
            if (o.length > 0 && Ot(o, a) !== 0) throw new TypeError("Hash mismatch");
            if (o = a, !is(e.pubkey) || e.pubkey.length !== 33) throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (e.witness) {
            if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
            if (!Ru(e.witness[0])) throw new TypeError("Witness has invalid signature");
            if (!is(e.witness[1]) || e.witness[1].length !== 33) throw new TypeError("Witness has invalid pubkey");
            if (e.signature && Ot(e.signature, e.witness[0]) !== 0) throw new TypeError("Signature mismatch");
            if (e.pubkey && Ot(e.pubkey, e.witness[1]) !== 0) throw new TypeError("Pubkey mismatch");
            const a = os(e.witness[1]);
            if (o.length > 0 && Ot(o, a) !== 0) throw new TypeError("Hash mismatch");
        }
    }
    return Object.assign(i1, e);
}
const uS = Zr, lA = new Uint8Array(0);
function Kg(e) {
    return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && is(e));
}
function l1(e, t) {
    if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), Bn(ZE({
        network: Zn({}),
        address: If(),
        hash: CW,
        output: oi(34),
        redeem: ZE({
            input: sn,
            network: Zn({}),
            output: sn,
            witness: Bo(sn)
        }),
        input: oi(0),
        witness: Bo(sn)
    }), e);
    const r = Ta(()=>{
        const a = $o.decode(e.address), s = a.words.shift(), c = $o.fromWords(a.words);
        return {
            version: s,
            prefix: a.prefix,
            data: Uint8Array.from(c)
        };
    }), n = Ta(()=>Tn(e.redeem.input));
    let i1 = e.network;
    i1 || (i1 = e.redeem && e.redeem.network || ds);
    const o = {
        network: i1
    };
    if (Zt(o, "address", ()=>{
        if (!o.hash) return;
        const a = $o.toWords(o.hash);
        return a.unshift(0), $o.encode(i1.bech32, a);
    }), Zt(o, "hash", ()=>{
        if (e.output) return e.output.slice(2);
        if (e.address) return r().data;
        if (o.redeem && o.redeem.output) return _i(o.redeem.output);
    }), Zt(o, "output", ()=>{
        if (o.hash) return Vi([
            uS.OP_0,
            o.hash
        ]);
    }), Zt(o, "redeem", ()=>{
        if (e.witness) return {
            output: e.witness[e.witness.length - 1],
            input: lA,
            witness: e.witness.slice(0, -1)
        };
    }), Zt(o, "input", ()=>{
        if (o.witness) return lA;
    }), Zt(o, "witness", ()=>{
        if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
            const a = LW(n());
            return o.redeem = Object.assign({
                witness: a
            }, e.redeem), o.redeem.input = lA, [].concat(a, e.redeem.output);
        }
        if (e.redeem && e.redeem.output && e.redeem.witness) return [].concat(e.redeem.witness, e.redeem.output);
    }), Zt(o, "name", ()=>{
        const a = [
            "p2wsh"
        ];
        return o.redeem !== void 0 && o.redeem.name !== void 0 && a.push(o.redeem.name), a.join("-");
    }), t.validate) {
        let a = Uint8Array.from([]);
        if (e.address) {
            if (r().prefix !== i1.bech32) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== 0) throw new TypeError("Invalid address version");
            if (r().data.length !== 32) throw new TypeError("Invalid address data");
            a = r().data;
        }
        if (e.hash) {
            if (a.length > 0 && Ot(a, e.hash) !== 0) throw new TypeError("Hash mismatch");
            a = e.hash;
        }
        if (e.output) {
            if (e.output.length !== 34 || e.output[0] !== uS.OP_0 || e.output[1] !== 32) throw new TypeError("Output is invalid");
            const s = e.output.slice(2);
            if (a.length > 0 && Ot(a, s) !== 0) throw new TypeError("Hash mismatch");
            a = s;
        }
        if (e.redeem) {
            if (e.redeem.network && e.redeem.network !== i1) throw new TypeError("Network mismatch");
            if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0) throw new TypeError("Ambiguous witness source");
            if (e.redeem.output) {
                const s = Tn(e.redeem.output);
                if (!s || s.length < 1) throw new TypeError("Redeem.output is invalid");
                if (e.redeem.output.byteLength > 3600) throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
                if (iT(s) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
                const c = _i(e.redeem.output);
                if (a.length > 0 && Ot(a, c) !== 0) throw new TypeError("Hash mismatch");
                a = c;
            }
            if (e.redeem.input && !h6(n())) throw new TypeError("Non push-only scriptSig");
            if (e.witness && e.redeem.witness && !c0(e.witness, e.redeem.witness)) throw new TypeError("Witness and redeem.witness mismatch");
            if (e.redeem.input && n().some(Kg) || e.redeem.output && (Tn(e.redeem.output) || []).some(Kg)) throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
        }
        if (e.witness && e.witness.length > 0) {
            const s = e.witness[e.witness.length - 1];
            if (e.redeem && e.redeem.output && Ot(e.redeem.output, s) !== 0) throw new TypeError("Witness and redeem.output mismatch");
            if (e.witness.some(Kg) || (Tn(s) || []).some(Kg)) throw new TypeError("Witness contains uncompressed pubkey");
        }
    }
    return Object.assign(o, e);
}
const Wp = {};
function w6(e) {
    e ? e !== Wp.eccLib && (BG(e), Wp.eccLib = e) : Wp.eccLib = e;
}
function y8() {
    if (!Wp.eccLib) throw new Error("No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance");
    return Wp.eccLib;
}
const gu = (e)=>zu(e);
function BG(e) {
    fa(typeof e.isXOnlyPoint == "function"), fa(e.isXOnlyPoint(gu("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), fa(e.isXOnlyPoint(gu("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e"))), fa(e.isXOnlyPoint(gu("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9"))), fa(e.isXOnlyPoint(gu("0000000000000000000000000000000000000000000000000000000000000001"))), fa(!e.isXOnlyPoint(gu("0000000000000000000000000000000000000000000000000000000000000000"))), fa(!e.isXOnlyPoint(gu("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"))), fa(typeof e.xOnlyPointAddTweak == "function"), TG.forEach((t)=>{
        const r = e.xOnlyPointAddTweak(gu(t.pubkey), gu(t.tweak));
        t.result === null ? fa(r === null) : (fa(r !== null), fa(r.parity === t.parity), fa(Ot(r.xOnlyPubkey, gu(t.result)) === 0));
    });
}
function fa(e) {
    if (!e) throw new Error("ecc library invalid");
}
const TG = [
    {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
    },
    {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
    },
    {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
    }
], bT = "0123456789abcdefABCDEF";
bT.split("").map((e)=>e.codePointAt(0));
const cS = Array(256).fill(!0).map((e, t)=>{
    const r = String.fromCodePoint(t), n = bT.indexOf(r);
    return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), wT = new TextEncoder();
new TextDecoder();
function PG(e) {
    return wT.encode(e);
}
function CG(e) {
    const t = e.reduce((i1, o)=>i1 + o.length, 0), r = new Uint8Array(t);
    let n = 0;
    for (const i1 of e)r.set(i1, n), n += i1.length;
    return r;
}
function MG(e) {
    const t = wT.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
    let n;
    for(n = 0; n < r.length; n++){
        const i1 = cS[t[n * 2]], o = cS[t[n * 2 + 1]];
        if (i1 === void 0 || o === void 0) break;
        r[n] = i1 << 4 | o;
    }
    return n === r.length ? r : r.slice(0, n);
}
function yu(e, t) {
    const r = Math.min(e.length, t.length);
    for(let n = 0; n < r; ++n)if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;
    return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function lS(e, t, r) {
    if (t + 1 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r > 255) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
    e[t] = r;
}
function NG(e, t, r, n) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 65535) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
    n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Bl(e, t, r, n) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 4294967295) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
    n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function RG(e, t, r, n) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (n = n.toUpperCase(), r > 0xffffffffffffffffn) throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
    n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function UG(e, t, r) {
    if (t + 2 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
    }
}
function xd(e, t, r) {
    if (t + 4 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0;
        return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
    } else {
        let n = 0;
        return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
    }
}
function DG(e, t, r) {
    if (t + 8 > e.length) throw new Error("Offset is outside the bounds of Uint8Array");
    if (r = r.toUpperCase(), r === "LE") {
        let n = 0n;
        return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
    } else {
        let n = 0n;
        return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
    }
}
const jG = (e)=>{
    if (e < 0 || e > 0xffffffffffffffffn) throw new RangeError("value out of range");
};
function FG(e) {
    if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0) throw new RangeError("value out of range");
}
function AT(e) {
    typeof e == "number" ? FG(e) : jG(e);
}
function Zc(e, t, r) {
    AT(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(Ca(e)));
    let n = 0;
    return e < 253 ? (t.set([
        Number(e)
    ], r), n = 1) : e <= 65535 ? (t.set([
        253
    ], r), NG(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([
        254
    ], r), Bl(t, r + 1, Number(e), "LE"), n = 5) : (t.set([
        255
    ], r), RG(t, r + 1, BigInt(e), "LE"), n = 9), {
        buffer: t,
        bytes: n
    };
}
function Ch(e, t) {
    t === void 0 && (t = 0);
    const r = e.at(t);
    if (r === void 0) throw new Error("buffer too small");
    if (r < 253) return {
        numberValue: r,
        bigintValue: BigInt(r),
        bytes: 1
    };
    if (r === 253) {
        const n = UG(e, t + 1, "LE");
        return {
            numberValue: n,
            bigintValue: BigInt(n),
            bytes: 3
        };
    } else if (r === 254) {
        const n = xd(e, t + 1, "LE");
        return {
            numberValue: n,
            bigintValue: BigInt(n),
            bytes: 5
        };
    } else {
        const n = DG(e, t + 1, "LE");
        return {
            numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null,
            bigintValue: n,
            bytes: 9
        };
    }
}
function Ca(e) {
    return AT(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const zG = 9007199254740991;
function LG(e, t) {
    if (typeof e != "number" && typeof e != "bigint") throw new Error("cannot write a non-number as a number");
    if (e < 0 && e < BigInt(0)) throw new Error("specified a negative value for writing an unsigned value");
    if (e > t && e > BigInt(t)) throw new Error("RangeError: value out of range");
    if (Math.floor(Number(e)) !== Number(e)) throw new Error("value has a fractional component");
}
function A6(e) {
    if (e.length < 1) return e;
    let t = e.length - 1, r = 0;
    for(let n = 0; n < e.length / 2; n++)r = e[n], e[n] = e[t], e[t] = r, t--;
    return e;
}
function fS(e) {
    const t = new Uint8Array(e.length);
    return t.set(e), t;
}
class ji {
    constructor(t, r = 0){
        wt(this, "buffer"), wt(this, "offset"), this.buffer = t, this.offset = r, Bn(Ms([
            sn,
            Eu
        ]), [
            t,
            r
        ]);
    }
    static withCapacity(t) {
        return new ji(new Uint8Array(t));
    }
    writeUInt8(t) {
        this.offset = Qo(this.buffer, this.offset, t);
    }
    writeInt32(t) {
        this.offset = qB(this.buffer, this.offset, t, "LE");
    }
    writeInt64(t) {
        this.offset = VB(this.buffer, this.offset, BigInt(t), "LE");
    }
    writeUInt32(t) {
        this.offset = s1(this.buffer, this.offset, t, "LE");
    }
    writeUInt64(t) {
        this.offset = vW(this.buffer, this.offset, BigInt(t), "LE");
    }
    writeVarInt(t) {
        const { bytes: r } = Zc(t, this.buffer, this.offset);
        this.offset += r;
    }
    writeSlice(t) {
        if (this.buffer.length < this.offset + t.length) throw new Error("Cannot write slice out of bounds");
        this.buffer.set(t, this.offset), this.offset += t.length;
    }
    writeVarSlice(t) {
        this.writeVarInt(t.length), this.writeSlice(t);
    }
    writeVector(t) {
        this.writeVarInt(t.length), t.forEach((r)=>this.writeVarSlice(r));
    }
    end() {
        if (this.buffer.length === this.offset) return this.buffer;
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
    }
}
class HG {
    constructor(t, r = 0){
        wt(this, "buffer"), wt(this, "offset"), this.buffer = t, this.offset = r, Bn(Ms([
            sn,
            Eu
        ]), [
            t,
            r
        ]);
    }
    readUInt8() {
        const t = Nu(this.buffer, this.offset);
        return this.offset++, t;
    }
    readInt32() {
        const t = SW(this.buffer, this.offset, "LE");
        return this.offset += 4, t;
    }
    readUInt32() {
        const t = Bh(this.buffer, this.offset, "LE");
        return this.offset += 4, t;
    }
    readInt64() {
        const t = WB(this.buffer, this.offset, "LE");
        return this.offset += 8, t;
    }
    readVarInt() {
        const { bigintValue: t, bytes: r } = Ch(this.buffer, this.offset);
        return this.offset += r, t;
    }
    readSlice(t) {
        LG(t, zG);
        const r = Number(t);
        if (this.buffer.length < this.offset + r) throw new Error("Cannot read slice out of bounds");
        const n = this.buffer.slice(this.offset, this.offset + r);
        return this.offset += r, n;
    }
    readVarSlice() {
        return this.readSlice(this.readVarInt());
    }
    readVector() {
        const t = this.readVarInt(), r = [];
        for(let n = 0; n < t; n++)r.push(this.readVarSlice());
        return r;
    }
}
const vT = 192, KG = 128, qG = (e)=>"left" in e && "right" in e;
function m8(e, t) {
    if (e.length < 33) throw new TypeError(`The control-block length is too small. Got ${e.length}, expected min 33.`);
    const r = (e.length - 33) / 32;
    let n = t;
    for(let i1 = 0; i1 < r; i1++){
        const o = e.slice(33 + 32 * i1, 65 + 32 * i1);
        Ot(n, o) < 0 ? n = w8(n, o) : n = w8(o, n);
    }
    return n;
}
function b8(e) {
    if (d6(e)) return {
        hash: Tu(e)
    };
    const t = [
        b8(e[0]),
        b8(e[1])
    ];
    t.sort((i1, o)=>Ot(i1.hash, o.hash));
    const [r, n] = t;
    return {
        hash: w8(r.hash, n.hash),
        left: r,
        right: n
    };
}
function dm(e, t) {
    if (qG(e)) {
        const r = dm(e.left, t);
        if (r !== void 0) return [
            ...r,
            e.right.hash
        ];
        const n = dm(e.right, t);
        if (n !== void 0) return [
            ...n,
            e.left.hash
        ];
    } else if (Ot(e.hash, t) === 0) return [];
}
function Tu(e) {
    const t = e.version || vT;
    return B2("TapLeaf", Mn([
        Uint8Array.from([
            t
        ]),
        WG(e.output)
    ]));
}
function VG(e, t) {
    return B2("TapTweak", Mn(t ? [
        e,
        t
    ] : [
        e
    ]));
}
function qg(e, t) {
    if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
    const r = VG(e, t), n = y8().xOnlyPointAddTweak(e, r);
    return !n || n.xOnlyPubkey === null ? null : {
        parity: n.parity,
        x: Uint8Array.from(n.xOnlyPubkey)
    };
}
function w8(e, t) {
    return B2("TapBranch", Mn([
        e,
        t
    ]));
}
function WG(e) {
    const t = Ca(e.length), r = new Uint8Array(t);
    return Zc(e.length, r), Mn([
        r,
        e
    ]);
}
const dS = Zr, hS = 1, GG = 80;
function Mh(e, t) {
    if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1)) throw new TypeError("Not enough data");
    t = Object.assign({
        validate: !0
    }, t || {}), Bn(Qc(Zn({
        address: If(),
        input: oi(0),
        network: Zn({}),
        output: oi(34),
        internalPubkey: oi(32),
        hash: oi(32),
        // merkle root hash, the tweak
        pubkey: oi(32),
        // tweaked with `hash` from `internalPubkey`
        signature: f6([
            oi(64),
            oi(65)
        ]),
        witness: Bo(sn),
        scriptTree: cs(eT, "Taptree is not of type isTaptree"),
        redeem: Qc(Zn({
            output: sn,
            // tapleaf script
            redeemVersion: So(),
            // tapleaf version
            witness: Bo(sn)
        })),
        redeemVersion: So()
    })), e);
    const r = Ta(()=>v6(e.address)), n = Ta(()=>{
        if (!(!e.witness || !e.witness.length)) return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === GG ? e.witness.slice(0, -1) : e.witness.slice();
    }), i1 = Ta(()=>{
        if (e.scriptTree) return b8(e.scriptTree);
        if (e.hash) return {
            hash: e.hash
        };
    }), o = e.network || ds, a = {
        name: "p2tr",
        network: o
    };
    if (Zt(a, "address", ()=>{
        if (!a.pubkey) return;
        const s = f0.toWords(a.pubkey);
        return s.unshift(hS), f0.encode(o.bech32, s);
    }), Zt(a, "hash", ()=>{
        const s = i1();
        if (s) return s.hash;
        const c = n();
        if (c && c.length > 1) {
            const l = c[c.length - 1], u = l[0] & Dy, f = c[c.length - 2], h = Tu({
                output: f,
                version: u
            });
            return m8(l, h);
        }
        return null;
    }), Zt(a, "output", ()=>{
        if (a.pubkey) return Vi([
            dS.OP_1,
            a.pubkey
        ]);
    }), Zt(a, "redeemVersion", ()=>e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : vT), Zt(a, "redeem", ()=>{
        const s = n();
        if (!(!s || s.length < 2)) return {
            output: s[s.length - 2],
            witness: s.slice(0, -2),
            redeemVersion: s[s.length - 1][0] & Dy
        };
    }), Zt(a, "pubkey", ()=>{
        if (e.pubkey) return e.pubkey;
        if (e.output) return e.output.slice(2);
        if (e.address) return r().data;
        if (a.internalPubkey) {
            const s = qg(a.internalPubkey, a.hash);
            if (s) return s.x;
        }
    }), Zt(a, "internalPubkey", ()=>{
        if (e.internalPubkey) return e.internalPubkey;
        const s = n();
        if (s && s.length > 1) return s[s.length - 1].slice(1, 33);
    }), Zt(a, "signature", ()=>{
        if (e.signature) return e.signature;
        const s = n();
        if (!(!s || s.length !== 1)) return s[0];
    }), Zt(a, "witness", ()=>{
        if (e.witness) return e.witness;
        const s = i1();
        if (s && e.redeem && e.redeem.output && e.internalPubkey) {
            const c = Tu({
                output: e.redeem.output,
                version: a.redeemVersion
            }), l = dm(s, c);
            if (!l) return;
            const u = qg(e.internalPubkey, s.hash);
            if (!u) return;
            const f = Mn([
                Uint8Array.from([
                    a.redeemVersion | u.parity
                ]),
                e.internalPubkey
            ].concat(l));
            return [
                e.redeem.output,
                f
            ];
        }
        if (e.signature) return [
            e.signature
        ];
    }), t.validate) {
        let s = Uint8Array.from([]);
        if (e.address) {
            if (o && o.bech32 !== r().prefix) throw new TypeError("Invalid prefix or Network mismatch");
            if (r().version !== hS) throw new TypeError("Invalid address version");
            if (r().data.length !== 32) throw new TypeError("Invalid address data");
            s = r().data;
        }
        if (e.pubkey) {
            if (s.length > 0 && Ot(s, e.pubkey) !== 0) throw new TypeError("Pubkey mismatch");
            s = e.pubkey;
        }
        if (e.output) {
            if (e.output.length !== 34 || e.output[0] !== dS.OP_1 || e.output[1] !== 32) throw new TypeError("Output is invalid");
            if (s.length > 0 && Ot(s, e.output.slice(2)) !== 0) throw new TypeError("Pubkey mismatch");
            s = e.output.slice(2);
        }
        if (e.internalPubkey) {
            const u = qg(e.internalPubkey, a.hash);
            if (s.length > 0 && Ot(s, u.x) !== 0) throw new TypeError("Pubkey mismatch");
            s = u.x;
        }
        if (s && s.length && !y8().isXOnlyPoint(s)) throw new TypeError("Invalid pubkey for p2tr");
        const c = i1();
        if (e.hash && c && Ot(e.hash, c.hash) !== 0) throw new TypeError("Hash mismatch");
        if (e.redeem && e.redeem.output && c) {
            const u = Tu({
                output: e.redeem.output,
                version: a.redeemVersion
            });
            if (!dm(c, u)) throw new TypeError("Redeem script not in tree");
        }
        const l = n();
        if (e.redeem && a.redeem) {
            if (e.redeem.redeemVersion && e.redeem.redeemVersion !== a.redeem.redeemVersion) throw new TypeError("Redeem.redeemVersion and witness mismatch");
            if (e.redeem.output) {
                if (Tn(e.redeem.output).length === 0) throw new TypeError("Redeem.output is invalid");
                if (a.redeem.output && Ot(e.redeem.output, a.redeem.output) !== 0) throw new TypeError("Redeem.output and witness mismatch");
            }
            if (e.redeem.witness && a.redeem.witness && !c0(e.redeem.witness, a.redeem.witness)) throw new TypeError("Redeem.witness and witness mismatch");
        }
        if (l && l.length) if (l.length === 1) {
            if (e.signature && Ot(e.signature, l[0]) !== 0) throw new TypeError("Signature mismatch");
        } else {
            const u = l[l.length - 1];
            if (u.length < 33) throw new TypeError(`The control-block length is too small. Got ${u.length}, expected min 33.`);
            if ((u.length - 33) % 32 !== 0) throw new TypeError(`The control-block length of ${u.length} is incorrect!`);
            const f = (u.length - 33) / 32;
            if (f > 128) throw new TypeError(`The script path is too long. Got ${f}, expected max 128.`);
            const h = u.slice(1, 33);
            if (e.internalPubkey && Ot(e.internalPubkey, h) !== 0) throw new TypeError("Internal pubkey mismatch");
            if (!y8().isXOnlyPoint(h)) throw new TypeError("Invalid internalPubkey for p2tr witness");
            const y = u[0] & Dy, S = l[l.length - 2], k = Tu({
                output: S,
                version: y
            }), P = m8(u, k), M = qg(h, P);
            if (!M) throw new TypeError("Invalid outputKey for p2tr witness");
            if (s.length && Ot(s, M.x) !== 0) throw new TypeError("Pubkey mismatch for p2tr witness");
            if (M.parity !== (u[0] & 1)) throw new Error("Incorrect parity");
        }
    }
    return Object.assign(a, e);
}
const ET = 40, ST = 2, xT = 16, _T = 2, kT = 80, OT = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function QG(e, t) {
    const r = e.slice(2);
    if (r.length < ST || r.length > ET) throw new TypeError("Invalid program length for segwit address");
    const n = e[0] - kT;
    if (n < _T || n > xT) throw new TypeError("Invalid version for segwit address");
    if (e[1] !== r.length) throw new TypeError("Invalid script for segwit address");
    return console.warn(OT), $G(r, n, t.bech32);
}
function IT(e) {
    const t = ch.decode(e);
    if (t.length < 21) throw new TypeError(e + " is too short");
    if (t.length > 21) throw new TypeError(e + " is too long");
    const r = Nu(t, 0), n = t.slice(1);
    return {
        version: r,
        hash: n
    };
}
function v6(e) {
    let t, r;
    try {
        t = $o.decode(e);
    } catch  {}
    if (t) {
        if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
    } else if (t = f0.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
    const n = $o.fromWords(t.words.slice(1));
    return {
        version: r,
        prefix: t.prefix,
        data: Uint8Array.from(n)
    };
}
function $G(e, t, r) {
    const n = $o.toWords(e);
    return n.unshift(t), t === 0 ? $o.encode(r, n) : f0.encode(r, n);
}
function f1(e, t) {
    t = t || ds;
    try {
        return u1({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return Ph({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return c1({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return l1({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return Mh({
            output: e,
            network: t
        }).address;
    } catch  {}
    try {
        return QG(e, t);
    } catch  {}
    throw new Error(zW(e) + " has no matching Address");
}
function Ma(e, t) {
    t = t || ds;
    let r, n;
    try {
        r = IT(e);
    } catch  {}
    if (r) {
        if (r.version === t.pubKeyHash) return u1({
            hash: r.hash
        }).output;
        if (r.version === t.scriptHash) return Ph({
            hash: r.hash
        }).output;
    } else {
        try {
            n = v6(e);
        } catch  {}
        if (n) {
            if (n.prefix !== t.bech32) throw new Error(e + " has an invalid prefix");
            if (n.version === 0) {
                if (n.data.length === 20) return c1({
                    hash: n.data
                }).output;
                if (n.data.length === 32) return l1({
                    hash: n.data
                }).output;
            } else if (n.version === 1) {
                if (n.data.length === 32) return Mh({
                    pubkey: n.data
                }).output;
            } else if (n.version >= _T && n.version <= xT && n.data.length >= ST && n.data.length <= ET) return console.warn(OT), Vi([
                n.version + kT,
                n.data
            ]);
        }
    }
    throw new Error(e + " has no matching Script");
}
function Cs(e) {
    const t = e.length;
    return Ca(t) + t;
}
function ZG(e) {
    const t = e.length;
    return Ca(t) + e.reduce((r, n)=>r + Cs(n), 0);
}
const kc = new Uint8Array(0), pS = [], fA = zu("0000000000000000000000000000000000000000000000000000000000000000"), gS = zu("0000000000000000000000000000000000000000000000000000000000000001"), XG = zu("ffffffffffffffff"), YG = {
    script: kc,
    valueBuffer: XG
};
function JG(e) {
    return e.value !== void 0;
}
const Wa = class pn {
    constructor(){
        wt(this, "version", 1), wt(this, "locktime", 0), wt(this, "ins", []), wt(this, "outs", []);
    }
    static fromBuffer(t, r) {
        const n = new HG(t), i1 = new pn();
        i1.version = n.readInt32();
        const o = n.readUInt8(), a = n.readUInt8();
        let s = !1;
        o === pn.ADVANCED_TRANSACTION_MARKER && a === pn.ADVANCED_TRANSACTION_FLAG ? s = !0 : n.offset -= 2;
        const c = n.readVarInt();
        for(let u = 0; u < c; ++u)i1.ins.push({
            hash: n.readSlice(32),
            index: n.readUInt32(),
            script: n.readVarSlice(),
            sequence: n.readUInt32(),
            witness: pS
        });
        const l = n.readVarInt();
        for(let u = 0; u < l; ++u)i1.outs.push({
            value: n.readInt64(),
            script: n.readVarSlice()
        });
        if (s) {
            for(let u = 0; u < c; ++u)i1.ins[u].witness = n.readVector();
            if (!i1.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
        }
        if (i1.locktime = n.readUInt32(), r) return i1;
        if (n.offset !== t.length) throw new Error("Transaction has unexpected data");
        return i1;
    }
    static fromHex(t) {
        return pn.fromBuffer(zu(t), !1);
    }
    static isCoinbaseHash(t) {
        Bn($E, t);
        for(let r = 0; r < 32; ++r)if (t[r] !== 0) return !1;
        return !0;
    }
    isCoinbase() {
        return this.ins.length === 1 && pn.isCoinbaseHash(this.ins[0].hash);
    }
    addInput(t, r, n, i1) {
        return Bn(Ms([
            $E,
            Eu,
            g8(sm(Eu)),
            g8(sm(sn))
        ]), [
            t,
            r,
            n,
            i1
        ]), n == null && (n = pn.DEFAULT_SEQUENCE), this.ins.push({
            hash: t,
            index: r,
            script: i1 || kc,
            sequence: n,
            witness: pS
        }) - 1;
    }
    addOutput(t, r) {
        return Bn(Ms([
            sn,
            sA
        ]), [
            t,
            r
        ]), this.outs.push({
            script: t,
            value: r
        }) - 1;
    }
    hasWitnesses() {
        return this.ins.some((t)=>t.witness.length !== 0);
    }
    weight() {
        const t = this.byteLength(!1), r = this.byteLength(!0);
        return t * 3 + r;
    }
    virtualSize() {
        return Math.ceil(this.weight() / 4);
    }
    byteLength(t = !0) {
        const r = t && this.hasWitnesses();
        return (r ? 10 : 8) + Ca(this.ins.length) + Ca(this.outs.length) + this.ins.reduce((n, i1)=>n + 40 + Cs(i1.script), 0) + this.outs.reduce((n, i1)=>n + 8 + Cs(i1.script), 0) + (r ? this.ins.reduce((n, i1)=>n + ZG(i1.witness), 0) : 0);
    }
    clone() {
        const t = new pn();
        return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r)=>({
                hash: r.hash,
                index: r.index,
                script: r.script,
                sequence: r.sequence,
                witness: r.witness
            })), t.outs = this.outs.map((r)=>({
                script: r.script,
                value: r.value
            })), t;
    }
    /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */ hashForSignature(t, r, n) {
        if (Bn(Ms([
            Eu,
            sn,
            So()
        ]), [
            t,
            r,
            n
        ]), t >= this.ins.length) return gS;
        const i1 = Vi(Tn(r).filter((s)=>s !== Zr.OP_CODESEPARATOR)), o = this.clone();
        if ((n & 31) === pn.SIGHASH_NONE) o.outs = [], o.ins.forEach((s, c)=>{
            c !== t && (s.sequence = 0);
        });
        else if ((n & 31) === pn.SIGHASH_SINGLE) {
            if (t >= this.outs.length) return gS;
            o.outs.length = t + 1;
            for(let s = 0; s < t; s++)o.outs[s] = YG;
            o.ins.forEach((s, c)=>{
                c !== t && (s.sequence = 0);
            });
        }
        n & pn.SIGHASH_ANYONECANPAY ? (o.ins = [
            o.ins[t]
        ], o.ins[0].script = i1) : (o.ins.forEach((s)=>{
            s.script = kc;
        }), o.ins[t].script = i1);
        const a = new Uint8Array(o.byteLength(!1) + 4);
        return qB(a, a.length - 4, n, "LE"), o.__toBuffer(a, 0, !1), xl(a);
    }
    hashForWitnessV1(t, r, n, i1, o, a) {
        if (Bn(Ms([
            Eu,
            Bo(sn),
            Bo(sA),
            Eu
        ]), [
            t,
            r,
            n,
            i1
        ]), n.length !== this.ins.length || r.length !== this.ins.length) throw new Error("Must supply prevout script and value for all inputs");
        const s = i1 === pn.SIGHASH_DEFAULT ? pn.SIGHASH_ALL : i1 & pn.SIGHASH_OUTPUT_MASK, c = (i1 & pn.SIGHASH_INPUT_MASK) === pn.SIGHASH_ANYONECANPAY, l = s === pn.SIGHASH_NONE, u = s === pn.SIGHASH_SINGLE;
        let f = kc, h = kc, y = kc, S = kc, k = kc;
        if (!c) {
            let z = ji.withCapacity(36 * this.ins.length);
            this.ins.forEach((K)=>{
                z.writeSlice(K.hash), z.writeUInt32(K.index);
            }), f = _i(z.end()), z = ji.withCapacity(8 * this.ins.length), n.forEach((K)=>z.writeInt64(K)), h = _i(z.end()), z = ji.withCapacity(r.map(Cs).reduce((K, $)=>K + $)), r.forEach((K)=>z.writeVarSlice(K)), y = _i(z.end()), z = ji.withCapacity(4 * this.ins.length), this.ins.forEach((K)=>z.writeUInt32(K.sequence)), S = _i(z.end());
        }
        if (l || u) {
            if (u && t < this.outs.length) {
                const z = this.outs[t], K = ji.withCapacity(8 + Cs(z.script));
                K.writeInt64(z.value), K.writeVarSlice(z.script), k = _i(K.end());
            }
        } else {
            if (!this.outs.length) throw new Error("Add outputs to the transaction before signing.");
            const z = this.outs.map(($)=>8 + Cs($.script)).reduce(($, ne)=>$ + ne), K = ji.withCapacity(z);
            this.outs.forEach(($)=>{
                K.writeInt64($.value), K.writeVarSlice($.script);
            }), k = _i(K.end());
        }
        const P = (o ? 2 : 0) + (a ? 1 : 0), M = 174 - (c ? 49 : 0) - (l ? 32 : 0) + (a ? 32 : 0) + (o ? 37 : 0), N = ji.withCapacity(M);
        if (N.writeUInt8(i1), N.writeInt32(this.version), N.writeUInt32(this.locktime), N.writeSlice(f), N.writeSlice(h), N.writeSlice(y), N.writeSlice(S), l || u || N.writeSlice(k), N.writeUInt8(P), c) {
            const z = this.ins[t];
            N.writeSlice(z.hash), N.writeUInt32(z.index), N.writeInt64(n[t]), N.writeVarSlice(r[t]), N.writeUInt32(z.sequence);
        } else N.writeUInt32(t);
        if (a) {
            const z = ji.withCapacity(Cs(a));
            z.writeVarSlice(a), N.writeSlice(_i(z.end()));
        }
        return u && N.writeSlice(k), o && (N.writeSlice(o), N.writeUInt8(0), N.writeUInt32(4294967295)), B2("TapSighash", Mn([
            Uint8Array.from([
                0
            ]),
            N.end()
        ]));
    }
    hashForWitnessV0(t, r, n, i1) {
        Bn(Ms([
            Eu,
            sn,
            sA,
            Eu
        ]), [
            t,
            r,
            n,
            i1
        ]);
        let o = Uint8Array.from([]), a, s = fA, c = fA, l = fA;
        if (i1 & pn.SIGHASH_ANYONECANPAY || (o = new Uint8Array(36 * this.ins.length), a = new ji(o, 0), this.ins.forEach((f)=>{
            a.writeSlice(f.hash), a.writeUInt32(f.index);
        }), c = xl(o)), !(i1 & pn.SIGHASH_ANYONECANPAY) && (i1 & 31) !== pn.SIGHASH_SINGLE && (i1 & 31) !== pn.SIGHASH_NONE && (o = new Uint8Array(4 * this.ins.length), a = new ji(o, 0), this.ins.forEach((f)=>{
            a.writeUInt32(f.sequence);
        }), l = xl(o)), (i1 & 31) !== pn.SIGHASH_SINGLE && (i1 & 31) !== pn.SIGHASH_NONE) {
            const f = this.outs.reduce((h, y)=>h + 8 + Cs(y.script), 0);
            o = new Uint8Array(f), a = new ji(o, 0), this.outs.forEach((h)=>{
                a.writeInt64(h.value), a.writeVarSlice(h.script);
            }), s = xl(o);
        } else if ((i1 & 31) === pn.SIGHASH_SINGLE && t < this.outs.length) {
            const f = this.outs[t];
            o = new Uint8Array(8 + Cs(f.script)), a = new ji(o, 0), a.writeInt64(f.value), a.writeVarSlice(f.script), s = xl(o);
        }
        o = new Uint8Array(156 + Cs(r)), a = new ji(o, 0);
        const u = this.ins[t];
        return a.writeInt32(this.version), a.writeSlice(c), a.writeSlice(l), a.writeSlice(u.hash), a.writeUInt32(u.index), a.writeVarSlice(r), a.writeInt64(n), a.writeUInt32(u.sequence), a.writeSlice(s), a.writeUInt32(this.locktime), a.writeUInt32(i1), xl(o);
    }
    getHash(t) {
        return t && this.isCoinbase() ? new Uint8Array(32) : xl(this.__toBuffer(void 0, void 0, t));
    }
    getId() {
        return nr(A6(this.getHash(!1)));
    }
    toBuffer(t, r) {
        return this.__toBuffer(t, r, !0);
    }
    toHex() {
        return nr(this.toBuffer(void 0, void 0));
    }
    setInputScript(t, r) {
        Bn(Ms([
            So(),
            sn
        ]), [
            t,
            r
        ]), this.ins[t].script = r;
    }
    setWitness(t, r) {
        Bn(Ms([
            So(),
            Bo(sn)
        ]), [
            t,
            r
        ]), this.ins[t].witness = r;
    }
    __toBuffer(t, r, n = !1) {
        t || (t = new Uint8Array(this.byteLength(n)));
        const i1 = new ji(t, r || 0);
        i1.writeInt32(this.version);
        const o = n && this.hasWitnesses();
        return o && (i1.writeUInt8(pn.ADVANCED_TRANSACTION_MARKER), i1.writeUInt8(pn.ADVANCED_TRANSACTION_FLAG)), i1.writeVarInt(this.ins.length), this.ins.forEach((a)=>{
            i1.writeSlice(a.hash), i1.writeUInt32(a.index), i1.writeVarSlice(a.script), i1.writeUInt32(a.sequence);
        }), i1.writeVarInt(this.outs.length), this.outs.forEach((a)=>{
            JG(a) ? i1.writeInt64(a.value) : i1.writeSlice(a.valueBuffer), i1.writeVarSlice(a.script);
        }), o && this.ins.forEach((a)=>{
            i1.writeVector(a.witness);
        }), i1.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, i1.offset) : t;
    }
};
wt(Wa, "DEFAULT_SEQUENCE", 4294967295), wt(Wa, "SIGHASH_DEFAULT", 0), wt(Wa, "SIGHASH_ALL", 1), wt(Wa, "SIGHASH_NONE", 2), wt(Wa, "SIGHASH_SINGLE", 3), wt(Wa, "SIGHASH_ANYONECANPAY", 128), wt(Wa, "SIGHASH_OUTPUT_MASK", 3), wt(Wa, "SIGHASH_INPUT_MASK", 128), wt(Wa, "ADVANCED_TRANSACTION_MARKER", 0), wt(Wa, "ADVANCED_TRANSACTION_FLAG", 1);
let Kn = Wa;
var qs;
(function(e) {
    e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(qs || (qs = {}));
var zt;
(function(e) {
    e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(zt || (zt = {}));
var Hn;
(function(e) {
    e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(Hn || (Hn = {}));
const eQ = (e)=>[
        ...Array(e).keys()
    ];
function tQ(e) {
    if (e.key[0] !== qs.GLOBAL_XPUB) throw new Error("Decode Error: could not decode globalXpub with key 0x" + nr(e.key));
    if (e.key.length !== 79 || ![
        2,
        3
    ].includes(e.key[46])) throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x" + nr(e.key));
    if (e.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");
    const t = e.key.slice(1), r = {
        masterFingerprint: e.value.slice(0, 4),
        extendedPubkey: t,
        path: "m"
    };
    for (const n of eQ(e.value.length / 4 - 1)){
        const i1 = Bh(e.value, n * 4 + 4, "LE"), o = !!(i1 & 2147483648), a = i1 & 2147483647;
        r.path += "/" + a.toString(10) + (o ? "'" : "");
    }
    return r;
}
function rQ(e) {
    const t = new Uint8Array([
        qs.GLOBAL_XPUB
    ]), r = Mn([
        t,
        e.extendedPubkey
    ]), n = e.path.split("/"), i1 = new Uint8Array(n.length * 4);
    i1.set(e.masterFingerprint, 0);
    let o = 4;
    return n.slice(1).forEach((a)=>{
        const s = a.slice(-1) === "'";
        let c = 2147483647 & parseInt(s ? a.slice(0, -1) : a, 10);
        s && (c += 2147483648), s1(i1, o, c, "LE"), o += 4;
    }), {
        key: r,
        value: i1
    };
}
const nQ = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function iQ(e) {
    const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
    return t instanceof Uint8Array && t.length === 78 && [
        2,
        3
    ].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function oQ(e, t, r) {
    const n = nr(t.extendedPubkey);
    return r.has(n) ? !1 : (r.add(n), e.filter((i1)=>Ot(i1.extendedPubkey, t.extendedPubkey)).length === 0);
}
const aQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: oQ,
    check: iQ,
    decode: tQ,
    encode: rQ,
    expected: nQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function sQ(e) {
    return {
        key: new Uint8Array([
            qs.UNSIGNED_TX
        ]),
        value: e.toBuffer()
    };
}
const uQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    encode: sQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function cQ(e) {
    if (e.key[0] !== zt.FINAL_SCRIPTSIG) throw new Error("Decode Error: could not decode finalScriptSig with key 0x" + nr(e.key));
    return e.value;
}
function lQ(e) {
    return {
        key: new Uint8Array([
            zt.FINAL_SCRIPTSIG
        ]),
        value: e
    };
}
const fQ = "Uint8Array";
function dQ(e) {
    return e instanceof Uint8Array;
}
function hQ(e, t) {
    return !!e && !!t && e.finalScriptSig === void 0;
}
const pQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: hQ,
    check: dQ,
    decode: cQ,
    encode: lQ,
    expected: fQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function gQ(e) {
    if (e.key[0] !== zt.FINAL_SCRIPTWITNESS) throw new Error("Decode Error: could not decode finalScriptWitness with key 0x" + nr(e.key));
    return e.value;
}
function yQ(e) {
    return {
        key: new Uint8Array([
            zt.FINAL_SCRIPTWITNESS
        ]),
        value: e
    };
}
const mQ = "Uint8Array";
function bQ(e) {
    return e instanceof Uint8Array;
}
function wQ(e, t) {
    return !!e && !!t && e.finalScriptWitness === void 0;
}
const AQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: wQ,
    check: bQ,
    decode: gQ,
    encode: yQ,
    expected: mQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function vQ(e) {
    if (e.key[0] !== zt.NON_WITNESS_UTXO) throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x" + nr(e.key));
    return e.value;
}
function EQ(e) {
    return {
        key: new Uint8Array([
            zt.NON_WITNESS_UTXO
        ]),
        value: e
    };
}
const SQ = "Uint8Array";
function xQ(e) {
    return e instanceof Uint8Array;
}
function _Q(e, t) {
    return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const kQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: _Q,
    check: xQ,
    decode: vQ,
    encode: EQ,
    expected: SQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function OQ(e) {
    if (e.key[0] !== zt.PARTIAL_SIG) throw new Error("Decode Error: could not decode partialSig with key 0x" + nr(e.key));
    if (!(e.key.length === 34 || e.key.length === 66) || ![
        2,
        3,
        4
    ].includes(e.key[1])) throw new Error("Decode Error: partialSig has invalid pubkey in key 0x" + nr(e.key));
    return {
        pubkey: e.key.slice(1),
        signature: e.value
    };
}
function IQ(e) {
    const t = new Uint8Array([
        zt.PARTIAL_SIG
    ]);
    return {
        key: Mn([
            t,
            e.pubkey
        ]),
        value: e.signature
    };
}
const BQ = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function TQ(e) {
    return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [
        33,
        65
    ].includes(e.pubkey.length) && [
        2,
        3,
        4
    ].includes(e.pubkey[0]) && PQ(e.signature);
}
function PQ(e) {
    if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
    const t = e[3];
    if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
    const r = e[3 + t + 2];
    return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function CQ(e, t, r) {
    const n = nr(t.pubkey);
    return r.has(n) ? !1 : (r.add(n), e.filter((i1)=>Ot(i1.pubkey, t.pubkey) === 0).length === 0);
}
const MQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: CQ,
    check: TQ,
    decode: OQ,
    encode: IQ,
    expected: BQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function NQ(e) {
    if (e.key[0] !== zt.POR_COMMITMENT) throw new Error("Decode Error: could not decode porCommitment with key 0x" + nr(e.key));
    return gW(e.value);
}
function RQ(e) {
    return {
        key: new Uint8Array([
            zt.POR_COMMITMENT
        ]),
        value: yW(e)
    };
}
const UQ = "string";
function DQ(e) {
    return typeof e == "string";
}
function jQ(e, t) {
    return !!e && !!t && e.porCommitment === void 0;
}
const FQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: jQ,
    check: DQ,
    decode: NQ,
    encode: RQ,
    expected: UQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function zQ(e) {
    if (e.key[0] !== zt.SIGHASH_TYPE) throw new Error("Decode Error: could not decode sighashType with key 0x" + nr(e.key));
    return Number(Bh(e.value, 0, "LE"));
}
function LQ(e) {
    const t = Uint8Array.from([
        zt.SIGHASH_TYPE
    ]), r = new Uint8Array(4);
    return s1(r, 0, e, "LE"), {
        key: t,
        value: r
    };
}
const HQ = "number";
function KQ(e) {
    return typeof e == "number";
}
function qQ(e, t) {
    return !!e && !!t && e.sighashType === void 0;
}
const VQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: qQ,
    check: KQ,
    decode: zQ,
    encode: LQ,
    expected: HQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function WQ(e) {
    if (e.key[0] !== zt.TAP_KEY_SIG || e.key.length !== 1) throw new Error("Decode Error: could not decode tapKeySig with key 0x" + nr(e.key));
    if (!BT(e.value)) throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");
    return e.value;
}
function GQ(e) {
    return {
        key: Uint8Array.from([
            zt.TAP_KEY_SIG
        ]),
        value: e
    };
}
const QQ = "Uint8Array";
function BT(e) {
    return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function $Q(e, t) {
    return !!e && !!t && e.tapKeySig === void 0;
}
const ZQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: $Q,
    check: BT,
    decode: WQ,
    encode: GQ,
    expected: QQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function XQ(e) {
    if (e.key[0] !== zt.TAP_LEAF_SCRIPT) throw new Error("Decode Error: could not decode tapLeafScript with key 0x" + nr(e.key));
    if ((e.key.length - 2) % 32 !== 0) throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x" + nr(e.key));
    const t = e.value[e.value.length - 1];
    if ((e.key[1] & 254) !== t) throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x" + nr(e.key));
    const r = e.value.slice(0, -1);
    return {
        controlBlock: e.key.slice(1),
        script: r,
        leafVersion: t
    };
}
function YQ(e) {
    const t = Uint8Array.from([
        zt.TAP_LEAF_SCRIPT
    ]), r = Uint8Array.from([
        e.leafVersion
    ]);
    return {
        key: Mn([
            t,
            e.controlBlock
        ]),
        value: Mn([
            e.script,
            r
        ])
    };
}
const JQ = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function e$(e) {
    return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function t$(e, t, r) {
    const n = nr(t.controlBlock);
    return r.has(n) ? !1 : (r.add(n), e.filter((i1)=>Ot(i1.controlBlock, t.controlBlock) === 0).length === 0);
}
const r$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: t$,
    check: e$,
    decode: XQ,
    encode: YQ,
    expected: JQ
}, Symbol.toStringTag, {
    value: "Module"
}));
function n$(e) {
    if (e.key[0] !== zt.TAP_MERKLE_ROOT || e.key.length !== 1) throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x" + nr(e.key));
    if (!TT(e.value)) throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
    return e.value;
}
function i$(e) {
    return {
        key: Uint8Array.from([
            zt.TAP_MERKLE_ROOT
        ]),
        value: e
    };
}
const o$ = "Uint8Array";
function TT(e) {
    return e instanceof Uint8Array && e.length === 32;
}
function a$(e, t) {
    return !!e && !!t && e.tapMerkleRoot === void 0;
}
const s$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: a$,
    check: TT,
    decode: n$,
    encode: i$,
    expected: o$
}, Symbol.toStringTag, {
    value: "Module"
}));
function u$(e) {
    if (e.key[0] !== zt.TAP_SCRIPT_SIG) throw new Error("Decode Error: could not decode tapScriptSig with key 0x" + nr(e.key));
    if (e.key.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid key 0x" + nr(e.key));
    if (e.value.length !== 64 && e.value.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x" + nr(e.key));
    const t = e.key.slice(1, 33), r = e.key.slice(33);
    return {
        pubkey: t,
        leafHash: r,
        signature: e.value
    };
}
function c$(e) {
    const t = Uint8Array.from([
        zt.TAP_SCRIPT_SIG
    ]);
    return {
        key: Mn([
            t,
            e.pubkey,
            e.leafHash
        ]),
        value: e.signature
    };
}
const l$ = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function f$(e) {
    return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function d$(e, t, r) {
    const n = nr(t.pubkey) + nr(t.leafHash);
    return r.has(n) ? !1 : (r.add(n), e.filter((i1)=>Ot(i1.pubkey, t.pubkey) === 0 && Ot(i1.leafHash, t.leafHash) === 0).length === 0);
}
const h$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAddToArray: d$,
    check: f$,
    decode: u$,
    encode: c$,
    expected: l$
}, Symbol.toStringTag, {
    value: "Module"
}));
function p$(e) {
    if (e.key[0] !== zt.WITNESS_UTXO) throw new Error("Decode Error: could not decode witnessUtxo with key 0x" + nr(e.key));
    const t = WB(e.value, 0, "LE");
    let r = 8;
    const { numberValue: n, bytes: i1 } = Ch(e.value, r);
    r += i1;
    const o = e.value.slice(r);
    if (o.length !== n) throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
    return {
        script: o,
        value: t
    };
}
function g$(e) {
    const { script: t, value: r } = e, n = Ca(t.length), i1 = new Uint8Array(8 + n + t.length);
    return VB(i1, 0, BigInt(r), "LE"), Zc(t.length, i1, 8), i1.set(t, 8 + n), {
        key: Uint8Array.from([
            zt.WITNESS_UTXO
        ]),
        value: i1
    };
}
const y$ = "{ script: Uint8Array; value: bigint; }";
function m$(e) {
    return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function b$(e, t) {
    return !!e && !!t && e.witnessUtxo === void 0;
}
const w$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: b$,
    check: m$,
    decode: p$,
    encode: g$,
    expected: y$
}, Symbol.toStringTag, {
    value: "Module"
}));
function A$(e) {
    if (e.key[0] !== Hn.TAP_TREE || e.key.length !== 1) throw new Error("Decode Error: could not decode tapTree with key 0x" + nr(e.key));
    let t = 0;
    const r = [];
    for(; t < e.value.length;){
        const n = e.value[t++], i1 = e.value[t++], { numberValue: o, bytes: a } = Ch(e.value, t);
        t += a, r.push({
            depth: n,
            leafVersion: i1,
            script: e.value.slice(t, t + o)
        }), t += o;
    }
    return {
        leaves: r
    };
}
function v$(e) {
    const t = Uint8Array.from([
        Hn.TAP_TREE
    ]), r = [].concat(...e.leaves.map((n)=>[
            Uint8Array.of(n.depth, n.leafVersion),
            Zc(BigInt(n.script.length)).buffer,
            n.script
        ]));
    return {
        key: t,
        value: Mn(r)
    };
}
const E$ = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function S$(e) {
    return Array.isArray(e.leaves) && e.leaves.every((t)=>t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array);
}
function x$(e, t) {
    return !!e && !!t && e.tapTree === void 0;
}
const _$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    canAdd: x$,
    check: S$,
    decode: A$,
    encode: v$,
    expected: E$
}, Symbol.toStringTag, {
    value: "Module"
})), k$ = (e)=>[
        ...Array(e).keys()
    ], O$ = (e)=>e.length === 33 && [
        2,
        3
    ].includes(e[0]) || e.length === 65 && e[0] === 4;
function E6(e, t = O$) {
    function r(s) {
        if (s.key[0] !== e) throw new Error("Decode Error: could not decode bip32Derivation with key 0x" + nr(s.key));
        const c = s.key.slice(1);
        if (!t(c)) throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x" + nr(s.key));
        if (s.value.length / 4 % 1 !== 0) throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");
        const l = {
            masterFingerprint: s.value.slice(0, 4),
            pubkey: c,
            path: "m"
        };
        for (const u of k$(s.value.length / 4 - 1)){
            const f = Bh(s.value, u * 4 + 4, "LE"), h = !!(f & 2147483648), y = f & 2147483647;
            l.path += "/" + y.toString(10) + (h ? "'" : "");
        }
        return l;
    }
    function n(s) {
        const c = Uint8Array.from([
            e
        ]), l = Mn([
            c,
            s.pubkey
        ]), u = s.path.split("/"), f = new Uint8Array(u.length * 4);
        f.set(s.masterFingerprint, 0);
        let h = 4;
        return u.slice(1).forEach((y)=>{
            const S = y.slice(-1) === "'";
            let k = 2147483647 & parseInt(S ? y.slice(0, -1) : y, 10);
            S && (k += 2147483648), s1(f, h, k, "LE"), h += 4;
        }), {
            key: l,
            value: f
        };
    }
    const i1 = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
    function o(s) {
        return s.pubkey instanceof Uint8Array && s.masterFingerprint instanceof Uint8Array && typeof s.path == "string" && t(s.pubkey) && s.masterFingerprint.length === 4;
    }
    function a(s, c, l) {
        const u = nr(c.pubkey);
        return l.has(u) ? !1 : (l.add(u), s.filter((f)=>Ot(f.pubkey, c.pubkey) === 0).length === 0);
    }
    return {
        decode: r,
        encode: n,
        check: o,
        expected: i1,
        canAddToArray: a
    };
}
function S6(e) {
    return t;
    //TURBOPACK unreachable
    ;
    function t(r) {
        let n;
        if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![
            2,
            3,
            4
        ].includes(n[0]))) throw new Error("Format Error: invalid pubkey in key 0x" + nr(r.key));
        return n;
    }
}
function PT(e) {
    function t(a) {
        if (a.key[0] !== e) throw new Error("Decode Error: could not decode redeemScript with key 0x" + nr(a.key));
        return a.value;
    }
    function r(a) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: a
        };
    }
    const n = "Uint8Array";
    function i1(a) {
        return a instanceof Uint8Array;
    }
    function o(a, s) {
        return !!a && !!s && a.redeemScript === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i1,
        expected: n,
        canAdd: o
    };
}
const I$ = (e)=>e.length === 32;
function CT(e) {
    const t = E6(e, I$);
    function r(a) {
        const { numberValue: s, bytes: c } = Ch(a.value), l = t.decode({
            key: a.key,
            value: a.value.slice(c + Number(s) * 32)
        }), u = new Array(Number(s));
        for(let f = 0, h = c; f < s; f++, h += 32)u[f] = a.value.slice(h, h + 32);
        return {
            ...l,
            leafHashes: u
        };
    }
    function n(a) {
        const s = t.encode(a), c = Ca(a.leafHashes.length), l = new Uint8Array(c);
        Zc(a.leafHashes.length, l);
        const u = Mn([
            l,
            ...a.leafHashes,
            s.value
        ]);
        return {
            ...s,
            value: u
        };
    }
    const i1 = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
    function o(a) {
        return Array.isArray(a.leafHashes) && a.leafHashes.every((s)=>s instanceof Uint8Array && s.length === 32) && t.check(a);
    }
    return {
        decode: r,
        encode: n,
        check: o,
        expected: i1,
        canAddToArray: t.canAddToArray
    };
}
function MT(e) {
    function t(a) {
        if (a.key[0] !== e || a.key.length !== 1) throw new Error("Decode Error: could not decode tapInternalKey with key 0x" + nr(a.key));
        if (a.value.length !== 32) throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");
        return a.value;
    }
    function r(a) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: a
        };
    }
    const n = "Uint8Array";
    function i1(a) {
        return a instanceof Uint8Array && a.length === 32;
    }
    function o(a, s) {
        return !!a && !!s && a.tapInternalKey === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i1,
        expected: n,
        canAdd: o
    };
}
function NT(e) {
    function t(a) {
        if (a.key[0] !== e) throw new Error("Decode Error: could not decode witnessScript with key 0x" + nr(a.key));
        return a.value;
    }
    function r(a) {
        return {
            key: Uint8Array.from([
                e
            ]),
            value: a
        };
    }
    const n = "Uint8Array";
    function i1(a) {
        return a instanceof Uint8Array;
    }
    function o(a, s) {
        return !!a && !!s && a.witnessScript === void 0;
    }
    return {
        decode: t,
        encode: r,
        check: i1,
        expected: n,
        canAdd: o
    };
}
const x6 = {
    unsignedTx: uQ,
    globalXpub: aQ,
    // pass an Array of key bytes that require pubkey beside the key
    checkPubkey: S6([])
}, ri = {
    nonWitnessUtxo: kQ,
    partialSig: MQ,
    sighashType: VQ,
    finalScriptSig: pQ,
    finalScriptWitness: AQ,
    porCommitment: FQ,
    witnessUtxo: w$,
    bip32Derivation: E6(zt.BIP32_DERIVATION),
    redeemScript: PT(zt.REDEEM_SCRIPT),
    witnessScript: NT(zt.WITNESS_SCRIPT),
    checkPubkey: S6([
        zt.PARTIAL_SIG,
        zt.BIP32_DERIVATION
    ]),
    tapKeySig: ZQ,
    tapScriptSig: h$,
    tapLeafScript: r$,
    tapBip32Derivation: CT(zt.TAP_BIP32_DERIVATION),
    tapInternalKey: MT(zt.TAP_INTERNAL_KEY),
    tapMerkleRoot: s$
}, Su = {
    bip32Derivation: E6(Hn.BIP32_DERIVATION),
    redeemScript: PT(Hn.REDEEM_SCRIPT),
    witnessScript: NT(Hn.WITNESS_SCRIPT),
    checkPubkey: S6([
        Hn.BIP32_DERIVATION
    ]),
    tapBip32Derivation: CT(Hn.TAP_BIP32_DERIVATION),
    tapTree: _$,
    tapInternalKey: MT(Hn.TAP_INTERNAL_KEY)
}, B$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    globals: x6,
    inputs: ri,
    outputs: Su
}, Symbol.toStringTag, {
    value: "Module"
})), hm = (e)=>[
        ...Array(e).keys()
    ];
function yS(e) {
    const t = e.map(T$);
    return t.push(Uint8Array.from([
        0
    ])), Mn(t);
}
function T$(e) {
    const t = e.key.length, r = e.value.length, n = Ca(t), i1 = Ca(r), o = new Uint8Array(n + t + i1 + r);
    return Zc(t, o, 0), o.set(e.key, n), Zc(r, o, n + t), o.set(e.value, n + t + i1), o;
}
function P$(e, t) {
    let r = 0;
    function n() {
        const { numberValue: P, bytes: M } = Ch(e, r);
        r += M;
        const N = e.slice(r, r + Number(P));
        return r += Number(P), N;
    }
    function i1() {
        const P = Bh(e, r, "BE");
        return r += 4, P;
    }
    function o() {
        const P = Nu(e, r);
        return r += 1, P;
    }
    function a() {
        const P = n(), M = n();
        return {
            key: P,
            value: M
        };
    }
    function s() {
        if (r >= e.length) throw new Error("Format Error: Unexpected End of PSBT");
        const P = Nu(e, r) === 0;
        return P && r++, P;
    }
    if (i1() !== 1886610036) throw new Error("Format Error: Invalid Magic Number");
    if (o() !== 255) throw new Error("Format Error: Magic Number must be followed by 0xff separator");
    const c = [], l = {};
    for(; !s();){
        const P = a(), M = nr(P.key);
        if (l[M]) throw new Error("Format Error: Keys must be unique for global keymap: key " + M);
        l[M] = 1, c.push(P);
    }
    const u = c.filter((P)=>P.key[0] === qs.UNSIGNED_TX);
    if (u.length !== 1) throw new Error("Format Error: Only one UNSIGNED_TX allowed");
    const f = t(u[0].value), { inputCount: h, outputCount: y } = f.getInputOutputCounts(), S = [], k = [];
    for (const P of hm(h)){
        const M = {}, N = [];
        for(; !s();){
            const z = a(), K = nr(z.key);
            if (M[K]) throw new Error("Format Error: Keys must be unique for each input: input index " + P + " key " + K);
            M[K] = 1, N.push(z);
        }
        S.push(N);
    }
    for (const P of hm(y)){
        const M = {}, N = [];
        for(; !s();){
            const z = a(), K = nr(z.key);
            if (M[K]) throw new Error("Format Error: Keys must be unique for each output: output index " + P + " key " + K);
            M[K] = 1, N.push(z);
        }
        k.push(N);
    }
    return RT(f, {
        globalMapKeyVals: c,
        inputKeyVals: S,
        outputKeyVals: k
    });
}
function Ni(e, t, r) {
    if (Ot(t, Uint8Array.from([
        r
    ]))) throw new Error(// `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    `Format Error: Invalid ${e} key: ${nr(t)}`);
}
function RT(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
    const i1 = {
        unsignedTx: e
    };
    let o = 0;
    for (const u of t)switch(u.key[0]){
        case qs.UNSIGNED_TX:
            if (Ni("global", u.key, qs.UNSIGNED_TX), o > 0) throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            o++;
            break;
        case qs.GLOBAL_XPUB:
            i1.globalXpub === void 0 && (i1.globalXpub = []), i1.globalXpub.push(x6.globalXpub.decode(u));
            break;
        default:
            i1.unknownKeyVals || (i1.unknownKeyVals = []), i1.unknownKeyVals.push(u);
    }
    const a = r.length, s = n.length, c = [], l = [];
    for (const u of hm(a)){
        const f = {};
        for (const h of r[u])switch(ri.checkPubkey(h), h.key[0]){
            case zt.NON_WITNESS_UTXO:
                if (Ni("input", h.key, zt.NON_WITNESS_UTXO), f.nonWitnessUtxo !== void 0) throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");
                f.nonWitnessUtxo = ri.nonWitnessUtxo.decode(h);
                break;
            case zt.WITNESS_UTXO:
                if (Ni("input", h.key, zt.WITNESS_UTXO), f.witnessUtxo !== void 0) throw new Error("Format Error: Input has multiple WITNESS_UTXO");
                f.witnessUtxo = ri.witnessUtxo.decode(h);
                break;
            case zt.PARTIAL_SIG:
                f.partialSig === void 0 && (f.partialSig = []), f.partialSig.push(ri.partialSig.decode(h));
                break;
            case zt.SIGHASH_TYPE:
                if (Ni("input", h.key, zt.SIGHASH_TYPE), f.sighashType !== void 0) throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
                f.sighashType = ri.sighashType.decode(h);
                break;
            case zt.REDEEM_SCRIPT:
                if (Ni("input", h.key, zt.REDEEM_SCRIPT), f.redeemScript !== void 0) throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
                f.redeemScript = ri.redeemScript.decode(h);
                break;
            case zt.WITNESS_SCRIPT:
                if (Ni("input", h.key, zt.WITNESS_SCRIPT), f.witnessScript !== void 0) throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
                f.witnessScript = ri.witnessScript.decode(h);
                break;
            case zt.BIP32_DERIVATION:
                f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(ri.bip32Derivation.decode(h));
                break;
            case zt.FINAL_SCRIPTSIG:
                Ni("input", h.key, zt.FINAL_SCRIPTSIG), f.finalScriptSig = ri.finalScriptSig.decode(h);
                break;
            case zt.FINAL_SCRIPTWITNESS:
                Ni("input", h.key, zt.FINAL_SCRIPTWITNESS), f.finalScriptWitness = ri.finalScriptWitness.decode(h);
                break;
            case zt.POR_COMMITMENT:
                Ni("input", h.key, zt.POR_COMMITMENT), f.porCommitment = ri.porCommitment.decode(h);
                break;
            case zt.TAP_KEY_SIG:
                Ni("input", h.key, zt.TAP_KEY_SIG), f.tapKeySig = ri.tapKeySig.decode(h);
                break;
            case zt.TAP_SCRIPT_SIG:
                f.tapScriptSig === void 0 && (f.tapScriptSig = []), f.tapScriptSig.push(ri.tapScriptSig.decode(h));
                break;
            case zt.TAP_LEAF_SCRIPT:
                f.tapLeafScript === void 0 && (f.tapLeafScript = []), f.tapLeafScript.push(ri.tapLeafScript.decode(h));
                break;
            case zt.TAP_BIP32_DERIVATION:
                f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(ri.tapBip32Derivation.decode(h));
                break;
            case zt.TAP_INTERNAL_KEY:
                Ni("input", h.key, zt.TAP_INTERNAL_KEY), f.tapInternalKey = ri.tapInternalKey.decode(h);
                break;
            case zt.TAP_MERKLE_ROOT:
                Ni("input", h.key, zt.TAP_MERKLE_ROOT), f.tapMerkleRoot = ri.tapMerkleRoot.decode(h);
                break;
            default:
                f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(h);
        }
        c.push(f);
    }
    for (const u of hm(s)){
        const f = {};
        for (const h of n[u])switch(Su.checkPubkey(h), h.key[0]){
            case Hn.REDEEM_SCRIPT:
                if (Ni("output", h.key, Hn.REDEEM_SCRIPT), f.redeemScript !== void 0) throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
                f.redeemScript = Su.redeemScript.decode(h);
                break;
            case Hn.WITNESS_SCRIPT:
                if (Ni("output", h.key, Hn.WITNESS_SCRIPT), f.witnessScript !== void 0) throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
                f.witnessScript = Su.witnessScript.decode(h);
                break;
            case Hn.BIP32_DERIVATION:
                f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(Su.bip32Derivation.decode(h));
                break;
            case Hn.TAP_INTERNAL_KEY:
                Ni("output", h.key, Hn.TAP_INTERNAL_KEY), f.tapInternalKey = Su.tapInternalKey.decode(h);
                break;
            case Hn.TAP_TREE:
                Ni("output", h.key, Hn.TAP_TREE), f.tapTree = Su.tapTree.decode(h);
                break;
            case Hn.TAP_BIP32_DERIVATION:
                f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(Su.tapBip32Derivation.decode(h));
                break;
            default:
                f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(h);
        }
        l.push(f);
    }
    return {
        globalMap: i1,
        inputs: c,
        outputs: l
    };
}
function C$({ globalMap: e, inputs: t, outputs: r }) {
    const { globalKeyVals: n, inputKeyVals: i1, outputKeyVals: o } = A8({
        globalMap: e,
        inputs: t,
        outputs: r
    }), a = yS(n), s = (f)=>f.length === 0 ? [
            Uint8Array.from([
                0
            ])
        ] : f.map(yS), c = s(i1), l = s(o), u = new Uint8Array(5);
    return u.set([
        112,
        115,
        98,
        116,
        255
    ], 0), Mn([
        u,
        a
    ].concat(c, l));
}
const M$ = (e, t)=>Ot(e.key, t.key);
function dA(e, t) {
    const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((o, [a, s])=>{
        if (a === "unknownKeyVals") return o;
        const c = t[a];
        if (c === void 0) return o;
        const l = (Array.isArray(s) ? s : [
            s
        ]).map(c.encode);
        return l.map((u)=>nr(u.key)).forEach((u)=>{
            if (r.has(u)) throw new Error("Serialize Error: Duplicate key: " + u);
            r.add(u);
        }), o.concat(l);
    }, []), i1 = e.unknownKeyVals ? e.unknownKeyVals.filter((o)=>!r.has(nr(o.key))) : [];
    return n.concat(i1).sort(M$);
}
function A8({ globalMap: e, inputs: t, outputs: r }) {
    return {
        globalKeyVals: dA(e, x6),
        inputKeyVals: t.map((n)=>dA(n, ri)),
        outputKeyVals: r.map((n)=>dA(n, Su))
    };
}
function N$(e) {
    const t = e[0], r = A8(t), n = e.slice(1);
    if (n.length === 0) throw new Error("Combine: Nothing to combine");
    const i1 = mS(t);
    if (i1 === void 0) throw new Error("Combine: Self missing transaction");
    const o = sd(r.globalKeyVals), a = r.inputKeyVals.map(sd), s = r.outputKeyVals.map(sd);
    for (const c of n){
        const l = mS(c);
        if (l === void 0 || Ot(l.toBuffer(), i1.toBuffer()) !== 0) throw new Error("Combine: One of the Psbts does not have the same transaction.");
        const u = A8(c);
        sd(u.globalKeyVals).forEach(hA(o, r.globalKeyVals, u.globalKeyVals)), u.inputKeyVals.map(sd).forEach((f, h)=>f.forEach(hA(a[h], r.inputKeyVals[h], u.inputKeyVals[h]))), u.outputKeyVals.map(sd).forEach((f, h)=>f.forEach(hA(s[h], r.outputKeyVals[h], u.outputKeyVals[h])));
    }
    return RT(i1, {
        globalMapKeyVals: r.globalKeyVals,
        inputKeyVals: r.inputKeyVals,
        outputKeyVals: r.outputKeyVals
    });
}
function hA(e, t, r) {
    return (n)=>{
        if (e.has(n)) return;
        const i1 = r.filter((o)=>nr(o.key) === n)[0];
        t.push(i1), e.add(n);
    };
}
function mS(e) {
    return e.globalMap.unsignedTx;
}
function sd(e) {
    const t = /* @__PURE__ */ new Set();
    return e.forEach((r)=>{
        const n = nr(r.key);
        if (t.has(n)) throw new Error("Combine: KeyValue Map keys should be unique");
        t.add(n);
    }), t;
}
function Ei(e, t) {
    const r = e[t];
    if (r === void 0) throw new Error(`No input #${t}`);
    return r;
}
function d0(e, t) {
    const r = e[t];
    if (r === void 0) throw new Error(`No output #${t}`);
    return r;
}
function pA(e, t, r) {
    if (e.key[0] < r) throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");
    if (t && t.filter((n)=>Ot(n.key, e.key) === 0).length !== 0) throw new Error(`Duplicate Key: ${nr(e.key)}`);
}
function gA(e) {
    let t = 0;
    return Object.keys(e).forEach((r)=>{
        Number(isNaN(Number(r))) && t++;
    }), t;
}
function R$(e, t) {
    let r = !1;
    if (t.nonWitnessUtxo || t.witnessUtxo) {
        const n = !!t.redeemScript, i1 = !!t.witnessScript, o = !n || !!t.finalScriptSig, a = !i1 || !!t.finalScriptWitness, s = !!t.finalScriptSig || !!t.finalScriptWitness;
        r = o && a && s;
    }
    if (r === !1) throw new Error(`Input #${e} has too much or too little data to clean`);
}
function bS(e, t, r, n) {
    throw new Error(`Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`);
}
function _6(e) {
    return (t, r)=>{
        for (const n of Object.keys(t)){
            const i1 = t[n], { canAdd: o, canAddToArray: a, check: s, expected: c } = // @ts-ignore
            B$[e + "s"][n] || {}, l = !!a;
            if (s) if (l) {
                if (!Array.isArray(i1) || // @ts-ignore
                r[n] && !Array.isArray(r[n])) throw new Error(`Key type ${n} must be an array`);
                i1.every(s) || bS(e, n, c, i1);
                const u = r[n] || [], f = /* @__PURE__ */ new Set();
                if (!i1.every((h)=>a(u, h, f))) throw new Error("Can not add duplicate data to array");
                r[n] = u.concat(i1);
            } else {
                if (s(i1) || bS(e, n, c, i1), !o(r, i1)) throw new Error(`Can not add duplicate data to ${e}`);
                r[n] = i1;
            }
        }
    };
}
const U$ = _6("global"), UT = _6("input"), DT = _6("output");
function D$(e, t) {
    const r = e.length - 1, n = Ei(e, r);
    UT(t, n);
}
function j$(e, t) {
    const r = e.length - 1, n = d0(e, r);
    DT(t, n);
}
let wS = class {
    constructor(e){
        this.inputs = [], this.outputs = [], this.globalMap = {
            unsignedTx: e
        };
    }
    static fromBase64(e, t) {
        const r = KB(e);
        return this.fromBuffer(r, t);
    }
    static fromHex(e, t) {
        const r = zu(e);
        return this.fromBuffer(r, t);
    }
    static fromBuffer(e, t) {
        const r = P$(e, t), n = new this(r.globalMap.unsignedTx);
        return Object.assign(n, r), n;
    }
    toBase64() {
        const e = this.toBuffer();
        return wW(e);
    }
    toHex() {
        const e = this.toBuffer();
        return nr(e);
    }
    toBuffer() {
        return C$(this);
    }
    updateGlobal(e) {
        return U$(e, this.globalMap), this;
    }
    updateInput(e, t) {
        const r = Ei(this.inputs, e);
        return UT(t, r), this;
    }
    updateOutput(e, t) {
        const r = d0(this.outputs, e);
        return DT(t, r), this;
    }
    addUnknownKeyValToGlobal(e) {
        return pA(e, this.globalMap.unknownKeyVals, gA(qs)), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(e), this;
    }
    addUnknownKeyValToInput(e, t) {
        const r = Ei(this.inputs, e);
        return pA(t, r.unknownKeyVals, gA(zt)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
    }
    addUnknownKeyValToOutput(e, t) {
        const r = d0(this.outputs, e);
        return pA(t, r.unknownKeyVals, gA(Hn)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
    }
    addInput(e) {
        this.globalMap.unsignedTx.addInput(e), this.inputs.push({
            unknownKeyVals: []
        });
        const t = e.unknownKeyVals || [], r = this.inputs.length - 1;
        if (!Array.isArray(t)) throw new Error("unknownKeyVals must be an Array");
        return t.forEach((n)=>this.addUnknownKeyValToInput(r, n)), D$(this.inputs, e), this;
    }
    addOutput(e) {
        this.globalMap.unsignedTx.addOutput(e), this.outputs.push({
            unknownKeyVals: []
        });
        const t = e.unknownKeyVals || [], r = this.outputs.length - 1;
        if (!Array.isArray(t)) throw new Error("unknownKeyVals must be an Array");
        return t.forEach((n)=>this.addUnknownKeyValToOutput(r, n)), j$(this.outputs, e), this;
    }
    clearFinalizedInput(e) {
        const t = Ei(this.inputs, e);
        R$(e, t);
        for (const r of Object.keys(t))[
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
        ].includes(r) || delete t[r];
        return this;
    }
    combine(...e) {
        const t = N$([
            this
        ].concat(e));
        return Object.assign(this, t), this;
    }
    getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
    }
};
function Bf(e) {
    return (t)=>{
        try {
            return e({
                output: t
            }), !0;
        } catch  {
            return !1;
        }
    };
}
const F$ = Bf(O2), z$ = Bf(aT), L$ = Bf(u1), T2 = Bf(c1), AS = Bf(l1), jT = Bf(Ph), FT = Bf(Mh);
function pm(e) {
    let t = new Uint8Array(0);
    function r(a) {
        t = Mn([
            t,
            a
        ]);
    }
    function n(a) {
        const s = t.length, c = Ca(a);
        t = Mn([
            t,
            new Uint8Array(c)
        ]), Zc(a, t, s);
    }
    function i1(a) {
        n(a.length), r(a);
    }
    function o(a) {
        n(a.length), a.forEach(i1);
    }
    return o(e), t;
}
function zT(e, t) {
    const r = os(e), n = e.slice(1, 33), i1 = Tn(t);
    if (i1 === null) throw new Error("Unknown script error");
    return i1.findIndex((o)=>typeof o == "number" ? !1 : Ot(e, o) === 0 || Ot(r, o) === 0 || Ot(n, o) === 0);
}
function P2(e, t) {
    return zT(e, t) !== -1;
}
function H$(e, t) {
    return K$(e).some((r)=>LT(r, Vp.decode, t));
}
function LT(e, t, r) {
    const { hashType: n } = t(e), i1 = [];
    switch(n & Kn.SIGHASH_ANYONECANPAY && i1.push("addInput"), n & 31){
        case Kn.SIGHASH_ALL:
            break;
        case Kn.SIGHASH_SINGLE:
        case Kn.SIGHASH_NONE:
            i1.push("addOutput"), i1.push("setInputSequence");
            break;
    }
    return i1.indexOf(r) === -1;
}
function K$(e) {
    let t = [];
    if ((e.partialSig || []).length === 0) {
        if (!e.finalScriptSig && !e.finalScriptWitness) return [];
        t = q$(e);
    } else t = e.partialSig;
    return t.map((r)=>r.signature);
}
function q$(e) {
    const t = e.finalScriptSig ? Tn(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? Tn(e.finalScriptWitness) || [] : [];
    return t.concat(r).filter((n)=>n instanceof Uint8Array && Ru(n)).map((n)=>({
            signature: n
        }));
}
const Zo = (e)=>e.length === 32 ? e : e.slice(1, 33);
function vS(e, t, r) {
    const n = iZ(t, e, r);
    try {
        const i1 = rZ(t, n).concat(n.script).concat(n.controlBlock);
        return {
            finalScriptWitness: pm(i1)
        };
    } catch (i1) {
        throw new Error(`Can not finalize taproot input #${e}: ${i1}`);
    }
}
function Vg(e, t) {
    const r = t ? Uint8Array.from([
        t
    ]) : Uint8Array.from([]);
    return Mn([
        e,
        r
    ]);
}
function Ya(e) {
    return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && FT(e.witnessUtxo.script));
}
function yA(e, t) {
    return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function ES(e, t, r) {
    J$(e, t, r), tZ(e, t, r);
}
function SS(e, t, r) {
    eZ(e, t, r), V$(e, t);
}
function V$(e, t) {
    if (!t.tapTree && !t.tapInternalKey) return;
    const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
    if (r) {
        const { script: i1 } = e, o = W$(r, n);
        if (i1 && Ot(o, i1) !== 0) throw new Error("Error adding output. Script or address mismatch.");
    }
}
function W$(e, t) {
    const r = t && G$(t.leaves), { output: n } = Mh({
        internalPubkey: e,
        scriptTree: r
    });
    return n;
}
function G$(e = []) {
    return e.length === 1 && e[0].depth === 0 ? {
        output: e[0].script,
        version: e[0].leafVersion
    } : Y$(e);
}
function Q$(e, t) {
    return Z$(e).some((r)=>LT(r, $$, t));
}
function $$(e) {
    return {
        signature: e.slice(0, 64),
        hashType: e.slice(64)[0] || Kn.SIGHASH_DEFAULT
    };
}
function Z$(e) {
    const t = [];
    if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r)=>r.signature)), !t.length) {
        const r = X$(e.finalScriptWitness);
        r && t.push(r);
    }
    return t;
}
function X$(e) {
    if (!e) return;
    const t = e.slice(2);
    if (t.length === 64 || t.length === 65) return t;
}
function Y$(e) {
    let t;
    for (const r of e)if (t = v8(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
    return t;
}
function v8(e, t, r = 0) {
    if (r > KG) throw new Error("Max taptree depth exceeded.");
    if (e.depth === r) return t ? void 0 : {
        output: e.script,
        version: e.leafVersion
    };
    if (d6(t)) return;
    const n = v8(e, t && t[0], r + 1);
    if (n) return [
        n,
        t && t[1]
    ];
    const i1 = v8(e, t && t[1], r + 1);
    if (i1) return [
        t && t[0],
        i1
    ];
}
function J$(e, t, r) {
    const n = Ya(e) && Ud(t), i1 = Ud(e) && Ya(t), o = e === t && Ya(t) && Ud(t);
    if (n || i1 || o) throw new Error(`Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`);
}
function eZ(e, t, r) {
    const n = yA(e) && Ud(t), i1 = Ud(e) && yA(t), o = e === t && yA(t) && Ud(t);
    if (n || i1 || o) throw new Error(`Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`);
}
function tZ(e, t, r) {
    if (t.tapMerkleRoot) {
        const n = (t.tapLeafScript || []).every((o)=>mA(o, t.tapMerkleRoot)), i1 = (e.tapLeafScript || []).every((o)=>mA(o, t.tapMerkleRoot));
        if (!n || !i1) throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
    } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every((n)=>mA(n, e.tapMerkleRoot))) throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
}
function mA(e, t) {
    if (!t) return !0;
    const r = Tu({
        output: e.script,
        version: e.leafVersion
    }), n = m8(e.controlBlock, r);
    return Ot(n, t) === 0;
}
function rZ(e, t) {
    const r = Tu({
        output: t.script,
        version: t.leafVersion
    });
    return (e.tapScriptSig || []).filter((n)=>Ot(n.leafHash, r) === 0).map((n)=>nZ(t.script, n)).sort((n, i1)=>i1.positionInScript - n.positionInScript).map((n)=>n.signature);
}
function nZ(e, t) {
    return Object.assign({
        positionInScript: zT(t.pubkey, e)
    }, t);
}
function iZ(e, t, r) {
    if (!e.tapScriptSig || !e.tapScriptSig.length) throw new Error(`Can not finalize taproot input #${t}. No tapleaf script signature provided.`);
    const n = (e.tapLeafScript || []).sort((i1, o)=>i1.controlBlock.length - o.controlBlock.length).find((i1)=>oZ(i1, e.tapScriptSig, r));
    if (!n) throw new Error(`Can not finalize taproot input #${t}. Signature for tapleaf script not found.`);
    return n;
}
function oZ(e, t, r) {
    const n = Tu({
        output: e.script,
        version: e.leafVersion
    });
    return (!r || Ot(n, r) === 0) && t.find((i1)=>Ot(i1.leafHash, n) === 0) !== void 0;
}
function Ud(e) {
    return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const aZ = {
    /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */ network: ds,
    /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */ maximumFeeRate: 5e3
};
class zr {
    constructor(t = {}, r = new wS(new HT())){
        wt(this, "data"), wt(this, "__CACHE"), wt(this, "opts"), this.data = r, this.opts = Object.assign({}, aZ, t), this.__CACHE = {
            __NON_WITNESS_UTXO_TX_CACHE: [],
            __NON_WITNESS_UTXO_BUF_CACHE: [],
            __TX_IN_CACHE: {},
            __TX: this.data.globalMap.unsignedTx.tx,
            // Psbt's predecessor (TransactionBuilder - now removed) behavior
            // was to not confirm input values  before signing.
            // Even though we highly encourage people to get
            // the full parent transaction to verify values, the ability to
            // sign non-segwit inputs without the full transaction was often
            // requested. So the only way to activate is to use @ts-ignore.
            // We will disable exporting the Psbt when unsafe sign is active.
            // because it is not BIP174 compliant.
            __UNSAFE_SIGN_NONSEGWIT: !1
        }, this.data.inputs.length === 0 && this.setVersion(2);
        const n = (i1, o, a, s)=>Object.defineProperty(i1, o, {
                enumerable: a,
                writable: s
            });
        n(this, "__CACHE", !1, !0), n(this, "opts", !1, !0);
    }
    static fromBase64(t, r = {}) {
        const n = KB(t);
        return this.fromBuffer(n, r);
    }
    static fromHex(t, r = {}) {
        const n = zu(t);
        return this.fromBuffer(n, r);
    }
    static fromBuffer(t, r = {}) {
        const n = wS.fromBuffer(t, sZ), i1 = new zr(r, n);
        return dZ(i1.__CACHE.__TX, i1.__CACHE), i1;
    }
    get inputCount() {
        return this.data.inputs.length;
    }
    get version() {
        return this.__CACHE.__TX.version;
    }
    set version(t) {
        this.setVersion(t);
    }
    get locktime() {
        return this.__CACHE.__TX.locktime;
    }
    set locktime(t) {
        this.setLocktime(t);
    }
    get txInputs() {
        return this.__CACHE.__TX.ins.map((t)=>({
                hash: fS(t.hash),
                index: t.index,
                sequence: t.sequence
            }));
    }
    get txOutputs() {
        return this.__CACHE.__TX.outs.map((t)=>{
            let r;
            try {
                r = f1(t.script, this.opts.network);
            } catch  {}
            return {
                script: fS(t.script),
                value: t.value,
                address: r
            };
        });
    }
    combine(...t) {
        return this.data.combine(...t.map((r)=>r.data)), this;
    }
    clone() {
        const t = zr.fromBuffer(this.data.toBuffer());
        return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
    }
    setMaximumFeeRate(t) {
        Wg(t), this.opts.maximumFeeRate = t;
    }
    setVersion(t) {
        Wg(t), Ap(this.data.inputs, "setVersion");
        const r = this.__CACHE;
        return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
    }
    setLocktime(t) {
        Wg(t), Ap(this.data.inputs, "setLocktime");
        const r = this.__CACHE;
        return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
    }
    setInputSequence(t, r) {
        Wg(r), Ap(this.data.inputs, "setInputSequence");
        const n = this.__CACHE;
        if (n.__TX.ins.length <= t) throw new Error("Input index too high");
        return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
    }
    addInputs(t) {
        return t.forEach((r)=>this.addInput(r)), this;
    }
    addInput(t) {
        if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0) throw new Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");
        ES(t, t, "addInput"), Ap(this.data.inputs, "addInput"), t.witnessScript && gm(t.witnessScript);
        const r = this.__CACHE;
        this.data.addInput(t);
        const n = r.__TX.ins[r.__TX.ins.length - 1];
        VT(r, n);
        const i1 = this.data.inputs.length - 1, o = this.data.inputs[i1];
        return o.nonWitnessUtxo && S8(this.__CACHE, o, i1), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
    }
    addOutputs(t) {
        return t.forEach((r)=>this.addOutput(r)), this;
    }
    addOutput(t) {
        if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0) throw new Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");
        Ap(this.data.inputs, "addOutput");
        const { address: r } = t;
        if (typeof r == "string") {
            const { network: i1 } = this.opts, o = Ma(r, i1);
            t = Object.assign({}, t, {
                script: o
            });
        }
        SS(t, t, "addOutput");
        const n = this.__CACHE;
        return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
    }
    extractTransaction(t) {
        if (!this.data.inputs.every(KT)) throw new Error("Not finalized");
        const r = this.__CACHE;
        if (t || cZ(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
        const n = r.__TX.clone();
        return XT(this.data.inputs, n, r, !0), n;
    }
    getFeeRate() {
        return IS("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
    }
    getFee() {
        return IS("__FEE", "fee", this.data.inputs, this.__CACHE);
    }
    finalizeAllInputs() {
        return Ei(this.data.inputs, 0), vp(this.data.inputs.length).forEach((t)=>this.finalizeInput(t)), this;
    }
    finalizeInput(t, r) {
        const n = Ei(this.data.inputs, t);
        return Ya(n) ? this._finalizeTaprootInput(t, n, void 0, r) : this._finalizeInput(t, n, r);
    }
    finalizeTaprootInput(t, r, n = vS) {
        const i1 = Ei(this.data.inputs, t);
        if (Ya(i1)) return this._finalizeTaprootInput(t, i1, r, n);
        throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
    }
    _finalizeInput(t, r, n = hZ) {
        const { script: i1, isP2SH: o, isP2WSH: a, isSegwit: s } = mZ(t, r, this.__CACHE);
        if (!i1) throw new Error(`No script found for input #${t}`);
        lZ(r);
        const { finalScriptSig: c, finalScriptWitness: l } = n(t, r, i1, s, o, a);
        if (c && this.data.updateInput(t, {
            finalScriptSig: c
        }), l && this.data.updateInput(t, {
            finalScriptWitness: l
        }), !c && !l) throw new Error(`Unknown error finalizing input #${t}`);
        return this.data.clearFinalizedInput(t), this;
    }
    _finalizeTaprootInput(t, r, n, i1 = vS) {
        if (!r.witnessUtxo) throw new Error(`Cannot finalize input #${t}. Missing withness utxo.`);
        if (r.tapKeySig) {
            const o = Mh({
                output: r.witnessUtxo.script,
                signature: r.tapKeySig
            }), a = pm(o.witness);
            this.data.updateInput(t, {
                finalScriptWitness: a
            });
        } else {
            const { finalScriptWitness: o } = i1(t, r, n);
            this.data.updateInput(t, {
                finalScriptWitness: o
            });
        }
        return this.data.clearFinalizedInput(t), this;
    }
    getInputType(t) {
        const r = Ei(this.data.inputs, t), n = YT(t, r, this.__CACHE), i1 = M2(n, t, "input", r.redeemScript || EZ(r.finalScriptSig), r.witnessScript || SZ(r.finalScriptWitness)), o = i1.type === "raw" ? "" : i1.type + "-", a = eP(i1.meaningfulScript);
        return o + a;
    }
    inputHasPubkey(t, r) {
        const n = Ei(this.data.inputs, t);
        return AZ(r, n, t, this.__CACHE);
    }
    inputHasHDKey(t, r) {
        const n = Ei(this.data.inputs, t), i1 = _S(r);
        return !!n.bip32Derivation && n.bip32Derivation.some(i1);
    }
    outputHasPubkey(t, r) {
        const n = d0(this.data.outputs, t);
        return vZ(r, n, t, this.__CACHE);
    }
    outputHasHDKey(t, r) {
        const n = d0(this.data.outputs, t), i1 = _S(r);
        return !!n.bip32Derivation && n.bip32Derivation.some(i1);
    }
    validateSignaturesOfAllInputs(t) {
        return Ei(this.data.inputs, 0), vp(this.data.inputs.length).map((r)=>this.validateSignaturesOfInput(r, t)).reduce((r, n)=>n === !0 && r, !0);
    }
    validateSignaturesOfInput(t, r, n) {
        const i1 = this.data.inputs[t];
        return Ya(i1) ? this.validateSignaturesOfTaprootInput(t, r, n) : this._validateSignaturesOfInput(t, r, n);
    }
    _validateSignaturesOfInput(t, r, n) {
        const i1 = this.data.inputs[t], o = (i1 || {}).partialSig;
        if (!i1 || !o || o.length < 1) throw new Error("No signatures to validate");
        if (typeof r != "function") throw new Error("Need validator function to validate signatures");
        const a = n ? o.filter((f)=>Ot(f.pubkey, n) === 0) : o;
        if (a.length < 1) throw new Error("No signatures for this pubkey");
        const s = [];
        let c, l, u;
        for (const f of a){
            const h = Vp.decode(f.signature), { hash: y, script: S } = u !== h.hashType ? GT(t, Object.assign({}, i1, {
                sighashType: h.hashType
            }), this.__CACHE, !0) : {
                hash: c,
                script: l
            };
            u = h.hashType, c = y, l = S, qT(f.pubkey, S, "verify"), s.push(r(f.pubkey, y, h.signature));
        }
        return s.every((f)=>f === !0);
    }
    validateSignaturesOfTaprootInput(t, r, n) {
        const i1 = this.data.inputs[t], o = (i1 || {}).tapKeySig, a = (i1 || {}).tapScriptSig;
        if (!i1 && !o && !(a && !a.length)) throw new Error("No signatures to validate");
        if (typeof r != "function") throw new Error("Need validator function to validate signatures");
        n = n && Zo(n);
        const s = n ? E8(t, i1, this.data.inputs, n, this.__CACHE) : gZ(t, i1, this.data.inputs, this.__CACHE);
        if (!s.length) throw new Error("No signatures for this pubkey");
        const c = s.find((u)=>!u.leafHash);
        let l = 0;
        if (o && c) {
            if (!r(c.pubkey, c.hash, TS(o))) return !1;
            l++;
        }
        if (a) for (const u of a){
            const f = s.find((h)=>Ot(h.pubkey, u.pubkey) === 0);
            if (f) {
                if (!r(u.pubkey, f.hash, TS(u.signature))) return !1;
                l++;
            }
        }
        return l > 0;
    }
    signAllInputsHD(t, r = [
        Kn.SIGHASH_ALL
    ]) {
        if (!t || !t.publicKey || !t.fingerprint) throw new Error("Need HDSigner to sign input");
        const n = [];
        for (const i1 of vp(this.data.inputs.length))try {
            this.signInputHD(i1, t, r), n.push(!0);
        } catch  {
            n.push(!1);
        }
        if (n.every((i1)=>i1 === !1)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsHDAsync(t, r = [
        Kn.SIGHASH_ALL
    ]) {
        return new Promise((n, i1)=>{
            if (!t || !t.publicKey || !t.fingerprint) return i1(new Error("Need HDSigner to sign input"));
            const o = [], a = [];
            for (const s of vp(this.data.inputs.length))a.push(this.signInputHDAsync(s, t, r).then(()=>{
                o.push(!0);
            }, ()=>{
                o.push(!1);
            }));
            return Promise.all(a).then(()=>{
                if (o.every((s)=>s === !1)) return i1(new Error("No inputs were signed"));
                n();
            });
        });
    }
    signInputHD(t, r, n = [
        Kn.SIGHASH_ALL
    ]) {
        if (!r || !r.publicKey || !r.fingerprint) throw new Error("Need HDSigner to sign input");
        return PS(t, this.data.inputs, r).forEach((i1)=>this.signInput(t, i1, n)), this;
    }
    signInputHDAsync(t, r, n = [
        Kn.SIGHASH_ALL
    ]) {
        return new Promise((i1, o)=>{
            if (!r || !r.publicKey || !r.fingerprint) return o(new Error("Need HDSigner to sign input"));
            const a = PS(t, this.data.inputs, r).map((s)=>this.signInputAsync(t, s, n));
            return Promise.all(a).then(()=>{
                i1();
            }).catch(o);
        });
    }
    signAllInputs(t, r) {
        if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
        const n = [];
        for (const i1 of vp(this.data.inputs.length))try {
            this.signInput(i1, t, r), n.push(!0);
        } catch  {
            n.push(!1);
        }
        if (n.every((i1)=>i1 === !1)) throw new Error("No inputs were signed");
        return this;
    }
    signAllInputsAsync(t, r) {
        return new Promise((n, i1)=>{
            if (!t || !t.publicKey) return i1(new Error("Need Signer to sign input"));
            const o = [], a = [];
            for (const [s] of this.data.inputs.entries())a.push(this.signInputAsync(s, t, r).then(()=>{
                o.push(!0);
            }, ()=>{
                o.push(!1);
            }));
            return Promise.all(a).then(()=>{
                if (o.every((s)=>s === !1)) return i1(new Error("No inputs were signed"));
                n();
            });
        });
    }
    signInput(t, r, n) {
        if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
        const i1 = Ei(this.data.inputs, t);
        return Ya(i1) ? this._signTaprootInput(t, i1, r, void 0, n) : this._signInput(t, r, n);
    }
    signTaprootInput(t, r, n, i1) {
        if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
        const o = Ei(this.data.inputs, t);
        if (Ya(o)) return this._signTaprootInput(t, o, r, n, i1);
        throw new Error(`Input #${t} is not of type Taproot.`);
    }
    _signInput(t, r, n = [
        Kn.SIGHASH_ALL
    ]) {
        const { hash: i1, sighashType: o } = BS(this.data.inputs, t, r.publicKey, this.__CACHE, n), a = [
            {
                pubkey: r.publicKey,
                signature: Vp.encode(r.sign(i1), o)
            }
        ];
        return this.data.updateInput(t, {
            partialSig: a
        }), this;
    }
    _signTaprootInput(t, r, n, i1, o = [
        Kn.SIGHASH_DEFAULT
    ]) {
        const a = this.checkTaprootHashesForSig(t, r, n, i1, o), s = a.filter((l)=>!l.leafHash).map((l)=>Vg(n.signSchnorr(l.hash), r.sighashType))[0], c = a.filter((l)=>!!l.leafHash).map((l)=>({
                pubkey: Zo(n.publicKey),
                signature: Vg(n.signSchnorr(l.hash), r.sighashType),
                leafHash: l.leafHash
            }));
        return s && this.data.updateInput(t, {
            tapKeySig: s
        }), c.length && this.data.updateInput(t, {
            tapScriptSig: c
        }), this;
    }
    signInputAsync(t, r, n) {
        return Promise.resolve().then(()=>{
            if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
            const i1 = Ei(this.data.inputs, t);
            return Ya(i1) ? this._signTaprootInputAsync(t, i1, r, void 0, n) : this._signInputAsync(t, r, n);
        });
    }
    signTaprootInputAsync(t, r, n, i1) {
        return Promise.resolve().then(()=>{
            if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
            const o = Ei(this.data.inputs, t);
            if (Ya(o)) return this._signTaprootInputAsync(t, o, r, n, i1);
            throw new Error(`Input #${t} is not of type Taproot.`);
        });
    }
    _signInputAsync(t, r, n = [
        Kn.SIGHASH_ALL
    ]) {
        const { hash: i1, sighashType: o } = BS(this.data.inputs, t, r.publicKey, this.__CACHE, n);
        return Promise.resolve(r.sign(i1)).then((a)=>{
            const s = [
                {
                    pubkey: r.publicKey,
                    signature: Vp.encode(a, o)
                }
            ];
            this.data.updateInput(t, {
                partialSig: s
            });
        });
    }
    async _signTaprootInputAsync(t, r, n, i1, o = [
        Kn.SIGHASH_DEFAULT
    ]) {
        const a = this.checkTaprootHashesForSig(t, r, n, i1, o), s = [], c = a.filter((u)=>!u.leafHash)[0];
        if (c) {
            const u = Promise.resolve(n.signSchnorr(c.hash)).then((f)=>({
                    tapKeySig: Vg(f, r.sighashType)
                }));
            s.push(u);
        }
        const l = a.filter((u)=>!!u.leafHash);
        if (l.length) {
            const u = l.map((f)=>Promise.resolve(n.signSchnorr(f.hash)).then((h)=>({
                        tapScriptSig: [
                            {
                                pubkey: Zo(n.publicKey),
                                signature: Vg(h, r.sighashType),
                                leafHash: f.leafHash
                            }
                        ]
                    })));
            s.push(...u);
        }
        return Promise.all(s).then((u)=>{
            u.forEach((f)=>this.data.updateInput(t, f));
        });
    }
    checkTaprootHashesForSig(t, r, n, i1, o) {
        if (typeof n.signSchnorr != "function") throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
        const a = E8(t, r, this.data.inputs, n.publicKey, this.__CACHE, i1, o);
        if (!a || !a.length) throw new Error(`Can not sign for input #${t} with the key ${nr(n.publicKey)}`);
        return a;
    }
    toBuffer() {
        return bA(this.__CACHE), this.data.toBuffer();
    }
    toHex() {
        return bA(this.__CACHE), this.data.toHex();
    }
    toBase64() {
        return bA(this.__CACHE), this.data.toBase64();
    }
    updateGlobal(t) {
        return this.data.updateGlobal(t), this;
    }
    updateInput(t, r) {
        return r.witnessScript && gm(r.witnessScript), ES(this.data.inputs[t], r, "updateInput"), this.data.updateInput(t, r), r.nonWitnessUtxo && S8(this.__CACHE, this.data.inputs[t], t), this;
    }
    updateOutput(t, r) {
        const n = this.data.outputs[t];
        return SS(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
    }
    addUnknownKeyValToGlobal(t) {
        return this.data.addUnknownKeyValToGlobal(t), this;
    }
    addUnknownKeyValToInput(t, r) {
        return this.data.addUnknownKeyValToInput(t, r), this;
    }
    addUnknownKeyValToOutput(t, r) {
        return this.data.addUnknownKeyValToOutput(t, r), this;
    }
    clearFinalizedInput(t) {
        return this.data.clearFinalizedInput(t), this;
    }
}
const sZ = (e)=>new HT(e);
class HT {
    constructor(t = Uint8Array.from([
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ])){
        wt(this, "tx"), this.tx = Kn.fromBuffer(t), fZ(this.tx), Object.defineProperty(this, "tx", {
            enumerable: !1,
            writable: !0
        });
    }
    getInputOutputCounts() {
        return {
            inputCount: this.tx.ins.length,
            outputCount: this.tx.outs.length
        };
    }
    addInput(t) {
        if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number") throw new Error("Error adding input.");
        const r = typeof t.hash == "string" ? A6(zu(t.hash)) : t.hash;
        this.tx.addInput(r, t.index, t.sequence);
    }
    addOutput(t) {
        if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint") throw new Error("Error adding output.");
        this.tx.addOutput(t.script, t.value);
    }
    toBuffer() {
        return this.tx.toBuffer();
    }
}
function uZ(e, t, r) {
    switch(r){
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
            return xS(1, e.partialSig);
        case "multisig":
            const n = O2({
                output: t
            });
            return xS(n.m, e.partialSig, n.pubkeys);
        default:
            return !1;
    }
}
function bA(e) {
    if (e.__UNSAFE_SIGN_NONSEGWIT !== !1) throw new Error("Not BIP174 compliant, can not export");
}
function xS(e, t, r) {
    if (!t) return !1;
    let n;
    if (r ? n = r.map((i1)=>{
        const o = xZ(i1);
        return t.find((a)=>Ot(a.pubkey, o) === 0);
    }).filter((i1)=>!!i1) : n = t, n.length > e) throw new Error("Too many signatures");
    return n.length === e;
}
function KT(e) {
    return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function _S(e) {
    return (t)=>!(Ot(e.fingerprint, t.masterFingerprint) || Ot(e.derivePath(t.path).publicKey, t.pubkey));
}
function Wg(e) {
    if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0) throw new Error("Invalid 32 bit integer");
}
function cZ(e, t, r) {
    const n = t.__FEE_RATE || e.getFeeRate(), i1 = t.__EXTRACTED_TX.virtualSize(), o = n * i1;
    if (n >= r.maximumFeeRate) throw new Error(`Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${i1} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`);
}
function Ap(e, t) {
    e.forEach((r)=>{
        if (Ya(r) ? Q$(r, t) : H$(r, t)) throw new Error("Can not modify transaction, signatures exist.");
    });
}
function lZ(e) {
    if (!e.sighashType || !e.partialSig) return;
    const { partialSig: t, sighashType: r } = e;
    t.forEach((n)=>{
        const { hashType: i1 } = Vp.decode(n.signature);
        if (r !== i1) throw new Error("Signature sighash does not match input sighash type");
    });
}
function qT(e, t, r) {
    if (!P2(e, t)) throw new Error(`Can not ${r} for this input with the key ${nr(e)}`);
}
function fZ(e) {
    if (!e.ins.every((t)=>t.script && t.script.length === 0 && t.witness && t.witness.length === 0)) throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function dZ(e, t) {
    e.ins.forEach((r)=>{
        VT(t, r);
    });
}
function VT(e, t) {
    const r = nr(A6(Uint8Array.from(t.hash))) + ":" + t.index;
    if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
    e.__TX_IN_CACHE[r] = 1;
}
function WT(e, t) {
    return (r, n, i1, o)=>{
        const a = e({
            redeem: {
                output: i1
            }
        }).output;
        if (Ot(n, a)) throw new Error(`${t} for ${o} #${r} doesn't match the scriptPubKey in the prevout`);
    };
}
const kS = WT(Ph, "Redeem script"), OS = WT(l1, "Witness script");
function IS(e, t, r, n) {
    if (!r.every(KT)) throw new Error(`PSBT must be finalized to calculate ${t}`);
    if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
    if (e === "__FEE" && n.__FEE) return n.__FEE;
    let i1, o = !0;
    if (n.__EXTRACTED_TX ? (i1 = n.__EXTRACTED_TX, o = !1) : i1 = n.__TX.clone(), XT(r, i1, n, o), e === "__FEE_RATE") return n.__FEE_RATE;
    if (e === "__FEE") return n.__FEE;
}
function hZ(e, t, r, n, i1, o) {
    const a = eP(r);
    if (!uZ(t, r, a)) throw new Error(`Can not finalize input #${e}`);
    return pZ(r, a, t.partialSig, n, i1, o);
}
function pZ(e, t, r, n, i1, o) {
    let a, s;
    const c = yZ(e, t, r), l = o ? l1({
        redeem: c
    }) : null, u = i1 ? Ph({
        redeem: l || c
    }) : null;
    return n ? (l ? s = pm(l.witness) : s = pm(c.witness), u && (a = u.input)) : u ? a = u.input : a = c.input, {
        finalScriptSig: a,
        finalScriptWitness: s
    };
}
function BS(e, t, r, n, i1) {
    const o = Ei(e, t), { hash: a, sighashType: s, script: c } = GT(t, o, n, !1, i1);
    return qT(r, c, "sign"), {
        hash: a,
        sighashType: s
    };
}
function GT(e, t, r, n, i1) {
    const o = r.__TX, a = t.sighashType || Kn.SIGHASH_ALL;
    $T(a, i1);
    let s, c;
    if (t.nonWitnessUtxo) {
        const f = C2(r, t, e), h = o.ins[e].hash, y = f.getHash();
        if (Ot(h, y) !== 0) throw new Error(`Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`);
        const S = o.ins[e].index;
        c = f.outs[S];
    } else if (t.witnessUtxo) c = t.witnessUtxo;
    else throw new Error("Need a Utxo input item for signing");
    const { meaningfulScript: l, type: u } = M2(c.script, e, "input", t.redeemScript, t.witnessScript);
    if ([
        "p2sh-p2wsh",
        "p2wsh"
    ].indexOf(u) >= 0) s = o.hashForWitnessV0(e, l, c.value, a);
    else if (T2(l)) {
        const f = u1({
            hash: l.slice(2)
        }).output;
        s = o.hashForWitnessV0(e, f, c.value, a);
    } else {
        if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1) throw new Error(`Input #${e} has witnessUtxo but non-segwit script: ${nr(l)}`);
        !n && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(`Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`), s = o.hashForSignature(e, l, a);
    }
    return {
        script: l,
        sighashType: a,
        hash: s
    };
}
function gZ(e, t, r, n) {
    const i1 = [];
    if (t.tapInternalKey) {
        const o = QT(e, t, n);
        o && i1.push(o);
    }
    if (t.tapScriptSig) {
        const o = t.tapScriptSig.map((a)=>a.pubkey);
        i1.push(...o);
    }
    return i1.map((o)=>E8(e, t, r, o, n)).flat();
}
function QT(e, t, r) {
    const { script: n } = k6(e, t, r);
    return FT(n) ? n.subarray(2, 34) : null;
}
function TS(e) {
    return e.length === 64 ? e : e.subarray(0, 64);
}
function E8(e, t, r, n, i1, o, a) {
    const s = i1.__TX, c = t.sighashType || Kn.SIGHASH_DEFAULT;
    $T(c, a);
    const l = r.map((S, k)=>k6(k, S, i1)), u = l.map((S)=>S.script), f = l.map((S)=>S.value), h = [];
    if (t.tapInternalKey && !o) {
        const S = QT(e, t, i1) || Uint8Array.from([]);
        if (Ot(Zo(n), S) === 0) {
            const k = s.hashForWitnessV1(e, u, f, c);
            h.push({
                pubkey: n,
                hash: k
            });
        }
    }
    const y = (t.tapLeafScript || []).filter((S)=>P2(n, S.script)).map((S)=>{
        const k = Tu({
            output: S.script,
            version: S.leafVersion
        });
        return Object.assign({
            hash: k
        }, S);
    }).filter((S)=>!o || Ot(o, S.hash) === 0).map((S)=>{
        const k = s.hashForWitnessV1(e, u, f, c, S.hash);
        return {
            pubkey: n,
            hash: k,
            leafHash: S.hash
        };
    });
    return h.concat(y);
}
function $T(e, t) {
    if (t && t.indexOf(e) < 0) {
        const r = wZ(e);
        throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`);
    }
}
function yZ(e, t, r) {
    let n;
    switch(t){
        case "multisig":
            const i1 = bZ(e, r);
            n = O2({
                output: e,
                signatures: i1
            });
            break;
        case "pubkey":
            n = aT({
                output: e,
                signature: r[0].signature
            });
            break;
        case "pubkeyhash":
            n = u1({
                output: e,
                pubkey: r[0].pubkey,
                signature: r[0].signature
            });
            break;
        case "witnesspubkeyhash":
            n = c1({
                output: e,
                pubkey: r[0].pubkey,
                signature: r[0].signature
            });
            break;
    }
    return n;
}
function mZ(e, t, r) {
    const n = r.__TX, i1 = {
        script: null,
        isSegwit: !1,
        isP2SH: !1,
        isP2WSH: !1
    };
    if (i1.isP2SH = !!t.redeemScript, i1.isP2WSH = !!t.witnessScript, t.witnessScript) i1.script = t.witnessScript;
    else if (t.redeemScript) i1.script = t.redeemScript;
    else if (t.nonWitnessUtxo) {
        const o = C2(r, t, e), a = n.ins[e].index;
        i1.script = o.outs[a].script;
    } else t.witnessUtxo && (i1.script = t.witnessUtxo.script);
    return (t.witnessScript || T2(i1.script)) && (i1.isSegwit = !0), i1;
}
function PS(e, t, r) {
    const n = Ei(t, e);
    if (!n.bip32Derivation || n.bip32Derivation.length === 0) throw new Error("Need bip32Derivation to sign with HD");
    const i1 = n.bip32Derivation.map((o)=>{
        if (Ot(o.masterFingerprint, r.fingerprint) === 0) return o;
    }).filter((o)=>!!o);
    if (i1.length === 0) throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
    return i1.map((o)=>{
        const a = r.derivePath(o.path);
        if (Ot(o.pubkey, a.publicKey) !== 0) throw new Error("pubkey did not match bip32Derivation");
        return a;
    });
}
function bZ(e, t) {
    return O2({
        output: e
    }).pubkeys.map((r)=>(t.filter((n)=>Ot(n.pubkey, r) === 0)[0] || {}).signature).filter((r)=>!!r);
}
function ZT(e) {
    let t = 0;
    function r(a) {
        return t += a, e.slice(t - a, t);
    }
    function n() {
        const a = Ch(e, t);
        return t += Ca(a.bigintValue), a.numberValue;
    }
    function i1() {
        return r(n());
    }
    function o() {
        const a = n(), s = [];
        for(let c = 0; c < a; c++)s.push(i1());
        return s;
    }
    return o();
}
function wZ(e) {
    let t = e & Kn.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
    switch(e & 31){
        case Kn.SIGHASH_ALL:
            t += "SIGHASH_ALL";
            break;
        case Kn.SIGHASH_SINGLE:
            t += "SIGHASH_SINGLE";
            break;
        case Kn.SIGHASH_NONE:
            t += "SIGHASH_NONE";
            break;
    }
    return t;
}
function S8(e, t, r) {
    e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
    const n = Kn.fromBuffer(t.nonWitnessUtxo);
    e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
    const i1 = e, o = r;
    delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
        enumerable: !0,
        get () {
            const a = i1.__NON_WITNESS_UTXO_BUF_CACHE[o], s = i1.__NON_WITNESS_UTXO_TX_CACHE[o];
            if (a !== void 0) return a;
            {
                const c = s.toBuffer();
                return i1.__NON_WITNESS_UTXO_BUF_CACHE[o] = c, c;
            }
        },
        set (a) {
            i1.__NON_WITNESS_UTXO_BUF_CACHE[o] = a;
        }
    });
}
function XT(e, t, r, n) {
    let i1 = 0n;
    e.forEach((c, l)=>{
        if (n && c.finalScriptSig && (t.ins[l].script = c.finalScriptSig), n && c.finalScriptWitness && (t.ins[l].witness = ZT(c.finalScriptWitness)), c.witnessUtxo) i1 += c.witnessUtxo.value;
        else if (c.nonWitnessUtxo) {
            const u = C2(r, c, l), f = t.ins[l].index, h = u.outs[f];
            i1 += h.value;
        }
    });
    const o = t.outs.reduce((c, l)=>c + l.value, 0n), a = i1 - o;
    if (a < 0) throw new Error("Outputs are spending more than Inputs");
    const s = t.virtualSize();
    r.__FEE = a, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(a / BigInt(s)));
}
function C2(e, t, r) {
    const n = e.__NON_WITNESS_UTXO_TX_CACHE;
    return n[r] || S8(e, t, r), n[r];
}
function YT(e, t, r) {
    const { script: n } = k6(e, t, r);
    return n;
}
function k6(e, t, r) {
    if (t.witnessUtxo !== void 0) return {
        script: t.witnessUtxo.script,
        value: t.witnessUtxo.value
    };
    if (t.nonWitnessUtxo !== void 0) {
        const n = C2(r, t, e).outs[r.__TX.ins[e].index];
        return {
            script: n.script,
            value: n.value
        };
    } else throw new Error("Can't find pubkey in input without Utxo data");
}
function AZ(e, t, r, n) {
    const i1 = YT(r, t, n), { meaningfulScript: o } = M2(i1, r, "input", t.redeemScript, t.witnessScript);
    return P2(e, o);
}
function vZ(e, t, r, n) {
    const i1 = n.__TX.outs[r].script, { meaningfulScript: o } = M2(i1, r, "output", t.redeemScript, t.witnessScript);
    return P2(e, o);
}
function EZ(e) {
    if (!e) return;
    const t = Tn(e);
    if (!t) return;
    const r = t[t.length - 1];
    if (!(!(r instanceof Uint8Array) || JT(r) || _Z(r) || !Tn(r))) return r;
}
function SZ(e) {
    if (!e) return;
    const t = ZT(e), r = t[t.length - 1];
    if (!(JT(r) || !Tn(r))) return r;
}
function xZ(e) {
    if (e.length === 65) {
        const t = e[64] & 1, r = e.slice(0, 33);
        return r[0] = 2 | t, r;
    }
    return e.slice();
}
function JT(e) {
    return e.length === 33 && HW(e);
}
function _Z(e) {
    return Ru(e);
}
function M2(e, t, r, n, i1) {
    const o = jT(e), a = o && n && AS(n), s = AS(e);
    if (o && n === void 0) throw new Error("scriptPubkey is P2SH but redeemScript missing");
    if ((s || a) && i1 === void 0) throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    let c;
    return a ? (c = i1, kS(t, e, n, r), OS(t, n, i1, r), gm(c)) : s ? (c = i1, OS(t, e, i1, r), gm(c)) : o ? (c = n, kS(t, e, n, r)) : c = e, {
        meaningfulScript: c,
        type: a ? "p2sh-p2wsh" : o ? "p2sh" : s ? "p2wsh" : "raw"
    };
}
function gm(e) {
    if (T2(e) || jT(e)) throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function eP(e) {
    return T2(e) ? "witnesspubkeyhash" : L$(e) ? "pubkeyhash" : F$(e) ? "multisig" : z$(e) ? "pubkey" : "nonstandard";
}
function vp(e) {
    return [
        ...Array(e).keys()
    ];
}
function kZ(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var tP = {
    exports: {}
}, Vn = tP.exports = {}, Ns, Rs;
function x8() {
    throw new Error("setTimeout has not been defined");
}
function _8() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        typeof setTimeout == "function" ? Ns = setTimeout : Ns = x8;
    } catch  {
        Ns = x8;
    }
    try {
        typeof clearTimeout == "function" ? Rs = clearTimeout : Rs = _8;
    } catch  {
        Rs = _8;
    }
})();
function rP(e) {
    if (Ns === setTimeout) return setTimeout(e, 0);
    if ((Ns === x8 || !Ns) && setTimeout) return Ns = setTimeout, setTimeout(e, 0);
    try {
        return Ns(e, 0);
    } catch  {
        try {
            return Ns.call(null, e, 0);
        } catch  {
            return Ns.call(this, e, 0);
        }
    }
}
function OZ(e) {
    if (Rs === clearTimeout) return clearTimeout(e);
    if ((Rs === _8 || !Rs) && clearTimeout) return Rs = clearTimeout, clearTimeout(e);
    try {
        return Rs(e);
    } catch  {
        try {
            return Rs.call(null, e);
        } catch  {
            return Rs.call(this, e);
        }
    }
}
var Pu = [], Dd = !1, Rl, jy = -1;
function IZ() {
    !Dd || !Rl || (Dd = !1, Rl.length ? Pu = Rl.concat(Pu) : jy = -1, Pu.length && nP());
}
function nP() {
    if (!Dd) {
        var e = rP(IZ);
        Dd = !0;
        for(var t = Pu.length; t;){
            for(Rl = Pu, Pu = []; ++jy < t;)Rl && Rl[jy].run();
            jy = -1, t = Pu.length;
        }
        Rl = null, Dd = !1, OZ(e);
    }
}
Vn.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)t[r - 1] = arguments[r];
    Pu.push(new iP(e, t)), Pu.length === 1 && !Dd && rP(nP);
};
function iP(e, t) {
    this.fun = e, this.array = t;
}
iP.prototype.run = function() {
    this.fun.apply(null, this.array);
};
Vn.title = "browser";
Vn.browser = !0;
Vn.env = {};
Vn.argv = [];
Vn.version = "";
Vn.versions = {};
function Lu() {}
Vn.on = Lu;
Vn.addListener = Lu;
Vn.once = Lu;
Vn.off = Lu;
Vn.removeListener = Lu;
Vn.removeAllListeners = Lu;
Vn.emit = Lu;
Vn.prependListener = Lu;
Vn.prependOnceListener = Lu;
Vn.listeners = function(e) {
    return [];
};
Vn.binding = function(e) {
    throw new Error("process.binding is not supported");
};
Vn.cwd = function() {
    return "/";
};
Vn.chdir = function(e) {
    throw new Error("process.chdir is not supported");
};
Vn.umask = function() {
    return 0;
};
var BZ = tP.exports;
const xn = /* @__PURE__ */ kZ(BZ);
let k8 = Symbol("clean"), Ka = [], ac = 0;
const Gg = 4;
let O8 = (e)=>{
    let t = [], r = {
        get () {
            return r.lc || r.listen(()=>{})(), r.value;
        },
        lc: 0,
        listen (n) {
            return r.lc = t.push(n), ()=>{
                for(let o = ac + Gg; o < Ka.length;)Ka[o] === n ? Ka.splice(o, Gg) : o += Gg;
                let i1 = t.indexOf(n);
                ~i1 && (t.splice(i1, 1), --r.lc || r.off());
            };
        },
        notify (n, i1) {
            let o = !Ka.length;
            for (let a of t)Ka.push(a, r.value, n, i1);
            if (o) {
                for(ac = 0; ac < Ka.length; ac += Gg)Ka[ac](Ka[ac + 1], Ka[ac + 2], Ka[ac + 3]);
                Ka.length = 0;
            }
        },
        /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */ off () {},
        set (n) {
            let i1 = r.value;
            i1 !== n && (r.value = n, r.notify(i1));
        },
        subscribe (n) {
            let i1 = r.listen(n);
            return n(r.value), i1;
        },
        value: e
    };
    return xn.env.NODE_ENV !== "production" && (r[k8] = ()=>{
        t = [], r.lc = 0, r.off();
    }), r;
};
const TZ = 5, ud = 6, Qg = 10;
let PZ = (e, t, r, n)=>(e.events = e.events || {}, e.events[r + Qg] || (e.events[r + Qg] = n((i1)=>{
        e.events[r].reduceRight((o, a)=>(a(o), o), {
            shared: {},
            ...i1
        });
    })), e.events[r] = e.events[r] || [], e.events[r].push(t), ()=>{
        let i1 = e.events[r], o = i1.indexOf(t);
        i1.splice(o, 1), i1.length || (delete e.events[r], e.events[r + Qg](), delete e.events[r + Qg]);
    }), CZ = 1e3, MZ = (e, t)=>PZ(e, (r)=>{
        let n = t(r);
        n && e.events[ud].push(n);
    }, TZ, (r)=>{
        let n = e.listen;
        e.listen = (...o)=>(!e.lc && !e.active && (e.active = !0, r()), n(...o));
        let i1 = e.off;
        if (e.events[ud] = [], e.off = ()=>{
            i1(), setTimeout(()=>{
                if (e.active && !e.lc) {
                    e.active = !1;
                    for (let o of e.events[ud])o();
                    e.events[ud] = [];
                }
            }, CZ);
        }, xn.env.NODE_ENV !== "production") {
            let o = e[k8];
            e[k8] = ()=>{
                for (let a of e.events[ud])a();
                e.events[ud] = [], e.active = !1, o();
            };
        }
        return ()=>{
            e.listen = n, e.off = i1;
        };
    }), NZ = (e)=>{
    e.listen(()=>{});
};
function ea(e, t, r) {
    let n = new Set(t).add(void 0);
    return e.listen((i1, o, a)=>{
        n.has(a) && r(i1, o, a);
    });
}
let oP = (e = {})=>{
    let t = O8(e);
    return t.setKey = function(r, n) {
        let i1 = t.value;
        typeof n > "u" && r in t.value ? (t.value = {
            ...t.value
        }, delete t.value[r], t.notify(i1, r)) : t.value[r] !== n && (t.value = {
            ...t.value,
            [r]: n
        }, t.notify(i1, r));
    }, t;
};
const wA = "defaultWallet", Ul = "oyl", Dl = "unisat", jl = "xverse", Fl = "phantom", jd = "leather", _u = "magic-eden", Fd = "okx", zd = "wizz", Mc = "orange", zl = "op_net", Ll = "sparrow", Ld = "tokeo", Hl = "keplr", sf = "p2tr", RZ = "p2pkh", UZ = "p2sh-p2wpkh", Fy = "p2wpkh", M3e = "p2psh", DZ = "p2wsh", d1 = "p2sh", N3e = {
    leather: {
        name: "leather",
        url: "https://leather.io/wallet"
    },
    "magic-eden": {
        name: "magic-eden",
        url: "https://wallet.magiceden.io/"
    },
    okx: {
        name: "okx",
        url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    op_net: {
        name: "op_net",
        url: "https://opnet.org/"
    },
    orange: {
        name: "orange",
        url: "https://www.orangewallet.com/"
    },
    oyl: {
        name: "oyl",
        url: "https://www.oyl.io/#get-wallet"
    },
    phantom: {
        name: "phantom",
        url: "https://phantom.app/download"
    },
    sparrow: {
        name: "sparrow",
        url: "https://sparrowwallet.com/"
    },
    tokeo: {
        name: "tokeo",
        url: "https://tokeo.io/"
    },
    unisat: {
        name: "unisat",
        url: "https://unisat.io/download"
    },
    wizz: {
        name: "wizz",
        url: "https://wizzwallet.io/#extension"
    },
    xverse: {
        name: "xverse",
        url: "https://www.xverse.app/download"
    },
    keplr: {
        name: "keplr",
        url: "https://keplr.app/download"
    }
};
var aP = {}, N2 = {};
N2.byteLength = zZ;
N2.toByteArray = HZ;
N2.fromByteArray = VZ;
var Ls = [], va = [], jZ = typeof Uint8Array < "u" ? Uint8Array : Array, AA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var cd = 0, FZ = AA.length; cd < FZ; ++cd)Ls[cd] = AA[cd], va[AA.charCodeAt(cd)] = cd;
va[45] = 62;
va[95] = 63;
function sP(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [
        r,
        n
    ];
}
function zZ(e) {
    var t = sP(e), r = t[0], n = t[1];
    return (r + n) * 3 / 4 - n;
}
function LZ(e, t, r) {
    return (t + r) * 3 / 4 - r;
}
function HZ(e) {
    var t, r = sP(e), n = r[0], i1 = r[1], o = new jZ(LZ(e, n, i1)), a = 0, s = i1 > 0 ? n - 4 : n, c;
    for(c = 0; c < s; c += 4)t = va[e.charCodeAt(c)] << 18 | va[e.charCodeAt(c + 1)] << 12 | va[e.charCodeAt(c + 2)] << 6 | va[e.charCodeAt(c + 3)], o[a++] = t >> 16 & 255, o[a++] = t >> 8 & 255, o[a++] = t & 255;
    return i1 === 2 && (t = va[e.charCodeAt(c)] << 2 | va[e.charCodeAt(c + 1)] >> 4, o[a++] = t & 255), i1 === 1 && (t = va[e.charCodeAt(c)] << 10 | va[e.charCodeAt(c + 1)] << 4 | va[e.charCodeAt(c + 2)] >> 2, o[a++] = t >> 8 & 255, o[a++] = t & 255), o;
}
function KZ(e) {
    return Ls[e >> 18 & 63] + Ls[e >> 12 & 63] + Ls[e >> 6 & 63] + Ls[e & 63];
}
function qZ(e, t, r) {
    for(var n, i1 = [], o = t; o < r; o += 3)n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i1.push(KZ(n));
    return i1.join("");
}
function VZ(e) {
    for(var t, r = e.length, n = r % 3, i1 = [], o = 16383, a = 0, s = r - n; a < s; a += o)i1.push(qZ(e, a, a + o > s ? s : a + o));
    return n === 1 ? (t = e[r - 1], i1.push(Ls[t >> 2] + Ls[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i1.push(Ls[t >> 10] + Ls[t >> 4 & 63] + Ls[t << 2 & 63] + "=")), i1.join("");
}
var O6 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ O6.read = function(e, t, r, n, i1) {
    var o, a, s = i1 * 8 - n - 1, c = (1 << s) - 1, l = c >> 1, u = -7, f = r ? i1 - 1 : 0, h = r ? -1 : 1, y = e[t + f];
    for(f += h, o = y & (1 << -u) - 1, y >>= -u, u += s; u > 0; o = o * 256 + e[t + f], f += h, u -= 8);
    for(a = o & (1 << -u) - 1, o >>= -u, u += n; u > 0; a = a * 256 + e[t + f], f += h, u -= 8);
    if (o === 0) o = 1 - l;
    else {
        if (o === c) return a ? NaN : (y ? -1 : 1) * (1 / 0);
        a = a + Math.pow(2, n), o = o - l;
    }
    return (y ? -1 : 1) * a * Math.pow(2, o - n);
};
O6.write = function(e, t, r, n, i1, o) {
    var a, s, c, l = o * 8 - i1 - 1, u = (1 << l) - 1, f = u >> 1, h = i1 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, S = n ? 1 : -1, k = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), a + f >= 1 ? t += h / c : t += h * Math.pow(2, 1 - f), t * c >= 2 && (a++, c /= 2), a + f >= u ? (s = 0, a = u) : a + f >= 1 ? (s = (t * c - 1) * Math.pow(2, i1), a = a + f) : (s = t * Math.pow(2, f - 1) * Math.pow(2, i1), a = 0)); i1 >= 8; e[r + y] = s & 255, y += S, s /= 256, i1 -= 8);
    for(a = a << i1 | s, l += i1; l > 0; e[r + y] = a & 255, y += S, a /= 256, l -= 8);
    e[r + y - S] |= k * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(e) {
    const t = N2, r = O6, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = u, e.SlowBuffer = $, e.INSPECT_MAX_BYTES = 50;
    const i1 = 2147483647;
    e.kMaxLength = i1;
    const { Uint8Array: o, ArrayBuffer: a, SharedArrayBuffer: s } = globalThis;
    u.TYPED_ARRAY_SUPPORT = c(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function c() {
        try {
            const D = new o(1), H = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(H, o.prototype), Object.setPrototypeOf(D, H), D.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(u.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (u.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(u.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (u.isBuffer(this)) return this.byteOffset;
        }
    });
    function l(D) {
        if (D > i1) throw new RangeError('The value "' + D + '" is invalid for option "size"');
        const H = new o(D);
        return Object.setPrototypeOf(H, u.prototype), H;
    }
    function u(D, H, te) {
        if (typeof D == "number") {
            if (typeof H == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return S(D);
        }
        return f(D, H, te);
    }
    u.poolSize = 8192;
    function f(D, H, te) {
        if (typeof D == "string") return k(D, H);
        if (a.isView(D)) return M(D);
        if (D == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof D);
        if (re(D, a) || D && re(D.buffer, a) || typeof s < "u" && (re(D, s) || D && re(D.buffer, s))) return N(D, H, te);
        if (typeof D == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const ge = D.valueOf && D.valueOf();
        if (ge != null && ge !== D) return u.from(ge, H, te);
        const ce = z(D);
        if (ce) return ce;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof D[Symbol.toPrimitive] == "function") return u.from(D[Symbol.toPrimitive]("string"), H, te);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof D);
    }
    u.from = function(D, H, te) {
        return f(D, H, te);
    }, Object.setPrototypeOf(u.prototype, o.prototype), Object.setPrototypeOf(u, o);
    function h(D) {
        if (typeof D != "number") throw new TypeError('"size" argument must be of type number');
        if (D < 0) throw new RangeError('The value "' + D + '" is invalid for option "size"');
    }
    function y(D, H, te) {
        return h(D), D <= 0 ? l(D) : H !== void 0 ? typeof te == "string" ? l(D).fill(H, te) : l(D).fill(H) : l(D);
    }
    u.alloc = function(D, H, te) {
        return y(D, H, te);
    };
    function S(D) {
        return h(D), l(D < 0 ? 0 : K(D) | 0);
    }
    u.allocUnsafe = function(D) {
        return S(D);
    }, u.allocUnsafeSlow = function(D) {
        return S(D);
    };
    function k(D, H) {
        if ((typeof H != "string" || H === "") && (H = "utf8"), !u.isEncoding(H)) throw new TypeError("Unknown encoding: " + H);
        const te = ne(D, H) | 0;
        let ge = l(te);
        const ce = ge.write(D, H);
        return ce !== te && (ge = ge.slice(0, ce)), ge;
    }
    function P(D) {
        const H = D.length < 0 ? 0 : K(D.length) | 0, te = l(H);
        for(let ge = 0; ge < H; ge += 1)te[ge] = D[ge] & 255;
        return te;
    }
    function M(D) {
        if (re(D, o)) {
            const H = new o(D);
            return N(H.buffer, H.byteOffset, H.byteLength);
        }
        return P(D);
    }
    function N(D, H, te) {
        if (H < 0 || D.byteLength < H) throw new RangeError('"offset" is outside of buffer bounds');
        if (D.byteLength < H + (te || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let ge;
        return H === void 0 && te === void 0 ? ge = new o(D) : te === void 0 ? ge = new o(D, H) : ge = new o(D, H, te), Object.setPrototypeOf(ge, u.prototype), ge;
    }
    function z(D) {
        if (u.isBuffer(D)) {
            const H = K(D.length) | 0, te = l(H);
            return te.length === 0 || D.copy(te, 0, 0, H), te;
        }
        if (D.length !== void 0) return typeof D.length != "number" || le(D.length) ? l(0) : P(D);
        if (D.type === "Buffer" && Array.isArray(D.data)) return P(D.data);
    }
    function K(D) {
        if (D >= i1) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i1.toString(16) + " bytes");
        return D | 0;
    }
    function $(D) {
        return +D != D && (D = 0), u.alloc(+D);
    }
    u.isBuffer = function(D) {
        return D != null && D._isBuffer === !0 && D !== u.prototype;
    }, u.compare = function(D, H) {
        if (re(D, o) && (D = u.from(D, D.offset, D.byteLength)), re(H, o) && (H = u.from(H, H.offset, H.byteLength)), !u.isBuffer(D) || !u.isBuffer(H)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (D === H) return 0;
        let te = D.length, ge = H.length;
        for(let ce = 0, Ue = Math.min(te, ge); ce < Ue; ++ce)if (D[ce] !== H[ce]) {
            te = D[ce], ge = H[ce];
            break;
        }
        return te < ge ? -1 : ge < te ? 1 : 0;
    }, u.isEncoding = function(D) {
        switch(String(D).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, u.concat = function(D, H) {
        if (!Array.isArray(D)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (D.length === 0) return u.alloc(0);
        let te;
        if (H === void 0) for(H = 0, te = 0; te < D.length; ++te)H += D[te].length;
        const ge = u.allocUnsafe(H);
        let ce = 0;
        for(te = 0; te < D.length; ++te){
            let Ue = D[te];
            if (re(Ue, o)) ce + Ue.length > ge.length ? (u.isBuffer(Ue) || (Ue = u.from(Ue)), Ue.copy(ge, ce)) : o.prototype.set.call(ge, Ue, ce);
            else if (u.isBuffer(Ue)) Ue.copy(ge, ce);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            ce += Ue.length;
        }
        return ge;
    };
    function ne(D, H) {
        if (u.isBuffer(D)) return D.length;
        if (a.isView(D) || re(D, a)) return D.byteLength;
        if (typeof D != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof D);
        const te = D.length, ge = arguments.length > 2 && arguments[2] === !0;
        if (!ge && te === 0) return 0;
        let ce = !1;
        for(;;)switch(H){
            case "ascii":
            case "latin1":
            case "binary":
                return te;
            case "utf8":
            case "utf-8":
                return We(D).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return te * 2;
            case "hex":
                return te >>> 1;
            case "base64":
                return A(D).length;
            default:
                if (ce) return ge ? -1 : We(D).length;
                H = ("" + H).toLowerCase(), ce = !0;
        }
    }
    u.byteLength = ne;
    function ee(D, H, te) {
        let ge = !1;
        if ((H === void 0 || H < 0) && (H = 0), H > this.length || ((te === void 0 || te > this.length) && (te = this.length), te <= 0) || (te >>>= 0, H >>>= 0, te <= H)) return "";
        for(D || (D = "utf8");;)switch(D){
            case "hex":
                return Y(this, H, te);
            case "utf8":
            case "utf-8":
                return O(this, H, te);
            case "ascii":
                return R(this, H, te);
            case "latin1":
            case "binary":
                return j(this, H, te);
            case "base64":
                return _(this, H, te);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return he(this, H, te);
            default:
                if (ge) throw new TypeError("Unknown encoding: " + D);
                D = (D + "").toLowerCase(), ge = !0;
        }
    }
    u.prototype._isBuffer = !0;
    function q(D, H, te) {
        const ge = D[H];
        D[H] = D[te], D[te] = ge;
    }
    u.prototype.swap16 = function() {
        const D = this.length;
        if (D % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let H = 0; H < D; H += 2)q(this, H, H + 1);
        return this;
    }, u.prototype.swap32 = function() {
        const D = this.length;
        if (D % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let H = 0; H < D; H += 4)q(this, H, H + 3), q(this, H + 1, H + 2);
        return this;
    }, u.prototype.swap64 = function() {
        const D = this.length;
        if (D % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let H = 0; H < D; H += 8)q(this, H, H + 7), q(this, H + 1, H + 6), q(this, H + 2, H + 5), q(this, H + 3, H + 4);
        return this;
    }, u.prototype.toString = function() {
        const D = this.length;
        return D === 0 ? "" : arguments.length === 0 ? O(this, 0, D) : ee.apply(this, arguments);
    }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(D) {
        if (!u.isBuffer(D)) throw new TypeError("Argument must be a Buffer");
        return this === D ? !0 : u.compare(this, D) === 0;
    }, u.prototype.inspect = function() {
        let D = "";
        const H = e.INSPECT_MAX_BYTES;
        return D = this.toString("hex", 0, H).replace(/(.{2})/g, "$1 ").trim(), this.length > H && (D += " ... "), "<Buffer " + D + ">";
    }, n && (u.prototype[n] = u.prototype.inspect), u.prototype.compare = function(D, H, te, ge, ce) {
        if (re(D, o) && (D = u.from(D, D.offset, D.byteLength)), !u.isBuffer(D)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof D);
        if (H === void 0 && (H = 0), te === void 0 && (te = D ? D.length : 0), ge === void 0 && (ge = 0), ce === void 0 && (ce = this.length), H < 0 || te > D.length || ge < 0 || ce > this.length) throw new RangeError("out of range index");
        if (ge >= ce && H >= te) return 0;
        if (ge >= ce) return -1;
        if (H >= te) return 1;
        if (H >>>= 0, te >>>= 0, ge >>>= 0, ce >>>= 0, this === D) return 0;
        let Ue = ce - ge, qe = te - H;
        const ot = Math.min(Ue, qe), yt = this.slice(ge, ce), Ut = D.slice(H, te);
        for(let Xe = 0; Xe < ot; ++Xe)if (yt[Xe] !== Ut[Xe]) {
            Ue = yt[Xe], qe = Ut[Xe];
            break;
        }
        return Ue < qe ? -1 : qe < Ue ? 1 : 0;
    };
    function U(D, H, te, ge, ce) {
        if (D.length === 0) return -1;
        if (typeof te == "string" ? (ge = te, te = 0) : te > 2147483647 ? te = 2147483647 : te < -2147483648 && (te = -2147483648), te = +te, le(te) && (te = ce ? 0 : D.length - 1), te < 0 && (te = D.length + te), te >= D.length) {
            if (ce) return -1;
            te = D.length - 1;
        } else if (te < 0) if (ce) te = 0;
        else return -1;
        if (typeof H == "string" && (H = u.from(H, ge)), u.isBuffer(H)) return H.length === 0 ? -1 : Q(D, H, te, ge, ce);
        if (typeof H == "number") return H = H & 255, typeof o.prototype.indexOf == "function" ? ce ? o.prototype.indexOf.call(D, H, te) : o.prototype.lastIndexOf.call(D, H, te) : Q(D, [
            H
        ], te, ge, ce);
        throw new TypeError("val must be string, number or Buffer");
    }
    function Q(D, H, te, ge, ce) {
        let Ue = 1, qe = D.length, ot = H.length;
        if (ge !== void 0 && (ge = String(ge).toLowerCase(), ge === "ucs2" || ge === "ucs-2" || ge === "utf16le" || ge === "utf-16le")) {
            if (D.length < 2 || H.length < 2) return -1;
            Ue = 2, qe /= 2, ot /= 2, te /= 2;
        }
        function yt(Xe, _t) {
            return Ue === 1 ? Xe[_t] : Xe.readUInt16BE(_t * Ue);
        }
        let Ut;
        if (ce) {
            let Xe = -1;
            for(Ut = te; Ut < qe; Ut++)if (yt(D, Ut) === yt(H, Xe === -1 ? 0 : Ut - Xe)) {
                if (Xe === -1 && (Xe = Ut), Ut - Xe + 1 === ot) return Xe * Ue;
            } else Xe !== -1 && (Ut -= Ut - Xe), Xe = -1;
        } else for(te + ot > qe && (te = qe - ot), Ut = te; Ut >= 0; Ut--){
            let Xe = !0;
            for(let _t = 0; _t < ot; _t++)if (yt(D, Ut + _t) !== yt(H, _t)) {
                Xe = !1;
                break;
            }
            if (Xe) return Ut;
        }
        return -1;
    }
    u.prototype.includes = function(D, H, te) {
        return this.indexOf(D, H, te) !== -1;
    }, u.prototype.indexOf = function(D, H, te) {
        return U(this, D, H, te, !0);
    }, u.prototype.lastIndexOf = function(D, H, te) {
        return U(this, D, H, te, !1);
    };
    function v(D, H, te, ge) {
        te = Number(te) || 0;
        const ce = D.length - te;
        ge ? (ge = Number(ge), ge > ce && (ge = ce)) : ge = ce;
        const Ue = H.length;
        ge > Ue / 2 && (ge = Ue / 2);
        let qe;
        for(qe = 0; qe < ge; ++qe){
            const ot = parseInt(H.substr(qe * 2, 2), 16);
            if (le(ot)) return qe;
            D[te + qe] = ot;
        }
        return qe;
    }
    function B(D, H, te, ge) {
        return V(We(H, D.length - te), D, te, ge);
    }
    function g(D, H, te, ge) {
        return V(Ge(H), D, te, ge);
    }
    function E(D, H, te, ge) {
        return V(A(H), D, te, ge);
    }
    function w(D, H, te, ge) {
        return V(p(H, D.length - te), D, te, ge);
    }
    u.prototype.write = function(D, H, te, ge) {
        if (H === void 0) ge = "utf8", te = this.length, H = 0;
        else if (te === void 0 && typeof H == "string") ge = H, te = this.length, H = 0;
        else if (isFinite(H)) H = H >>> 0, isFinite(te) ? (te = te >>> 0, ge === void 0 && (ge = "utf8")) : (ge = te, te = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const ce = this.length - H;
        if ((te === void 0 || te > ce) && (te = ce), D.length > 0 && (te < 0 || H < 0) || H > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        ge || (ge = "utf8");
        let Ue = !1;
        for(;;)switch(ge){
            case "hex":
                return v(this, D, H, te);
            case "utf8":
            case "utf-8":
                return B(this, D, H, te);
            case "ascii":
            case "latin1":
            case "binary":
                return g(this, D, H, te);
            case "base64":
                return E(this, D, H, te);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return w(this, D, H, te);
            default:
                if (Ue) throw new TypeError("Unknown encoding: " + ge);
                ge = ("" + ge).toLowerCase(), Ue = !0;
        }
    }, u.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function _(D, H, te) {
        return H === 0 && te === D.length ? t.fromByteArray(D) : t.fromByteArray(D.slice(H, te));
    }
    function O(D, H, te) {
        te = Math.min(D.length, te);
        const ge = [];
        let ce = H;
        for(; ce < te;){
            const Ue = D[ce];
            let qe = null, ot = Ue > 239 ? 4 : Ue > 223 ? 3 : Ue > 191 ? 2 : 1;
            if (ce + ot <= te) {
                let yt, Ut, Xe, _t;
                switch(ot){
                    case 1:
                        Ue < 128 && (qe = Ue);
                        break;
                    case 2:
                        yt = D[ce + 1], (yt & 192) === 128 && (_t = (Ue & 31) << 6 | yt & 63, _t > 127 && (qe = _t));
                        break;
                    case 3:
                        yt = D[ce + 1], Ut = D[ce + 2], (yt & 192) === 128 && (Ut & 192) === 128 && (_t = (Ue & 15) << 12 | (yt & 63) << 6 | Ut & 63, _t > 2047 && (_t < 55296 || _t > 57343) && (qe = _t));
                        break;
                    case 4:
                        yt = D[ce + 1], Ut = D[ce + 2], Xe = D[ce + 3], (yt & 192) === 128 && (Ut & 192) === 128 && (Xe & 192) === 128 && (_t = (Ue & 15) << 18 | (yt & 63) << 12 | (Ut & 63) << 6 | Xe & 63, _t > 65535 && _t < 1114112 && (qe = _t));
                }
            }
            qe === null ? (qe = 65533, ot = 1) : qe > 65535 && (qe -= 65536, ge.push(qe >>> 10 & 1023 | 55296), qe = 56320 | qe & 1023), ge.push(qe), ce += ot;
        }
        return x(ge);
    }
    const I = 4096;
    function x(D) {
        const H = D.length;
        if (H <= I) return String.fromCharCode.apply(String, D);
        let te = "", ge = 0;
        for(; ge < H;)te += String.fromCharCode.apply(String, D.slice(ge, ge += I));
        return te;
    }
    function R(D, H, te) {
        let ge = "";
        te = Math.min(D.length, te);
        for(let ce = H; ce < te; ++ce)ge += String.fromCharCode(D[ce] & 127);
        return ge;
    }
    function j(D, H, te) {
        let ge = "";
        te = Math.min(D.length, te);
        for(let ce = H; ce < te; ++ce)ge += String.fromCharCode(D[ce]);
        return ge;
    }
    function Y(D, H, te) {
        const ge = D.length;
        (!H || H < 0) && (H = 0), (!te || te < 0 || te > ge) && (te = ge);
        let ce = "";
        for(let Ue = H; Ue < te; ++Ue)ce += L[D[Ue]];
        return ce;
    }
    function he(D, H, te) {
        const ge = D.slice(H, te);
        let ce = "";
        for(let Ue = 0; Ue < ge.length - 1; Ue += 2)ce += String.fromCharCode(ge[Ue] + ge[Ue + 1] * 256);
        return ce;
    }
    u.prototype.slice = function(D, H) {
        const te = this.length;
        D = ~~D, H = H === void 0 ? te : ~~H, D < 0 ? (D += te, D < 0 && (D = 0)) : D > te && (D = te), H < 0 ? (H += te, H < 0 && (H = 0)) : H > te && (H = te), H < D && (H = D);
        const ge = this.subarray(D, H);
        return Object.setPrototypeOf(ge, u.prototype), ge;
    };
    function ue(D, H, te) {
        if (D % 1 !== 0 || D < 0) throw new RangeError("offset is not uint");
        if (D + H > te) throw new RangeError("Trying to access beyond buffer length");
    }
    u.prototype.readUintLE = u.prototype.readUIntLE = function(D, H, te) {
        D = D >>> 0, H = H >>> 0, te || ue(D, H, this.length);
        let ge = this[D], ce = 1, Ue = 0;
        for(; ++Ue < H && (ce *= 256);)ge += this[D + Ue] * ce;
        return ge;
    }, u.prototype.readUintBE = u.prototype.readUIntBE = function(D, H, te) {
        D = D >>> 0, H = H >>> 0, te || ue(D, H, this.length);
        let ge = this[D + --H], ce = 1;
        for(; H > 0 && (ce *= 256);)ge += this[D + --H] * ce;
        return ge;
    }, u.prototype.readUint8 = u.prototype.readUInt8 = function(D, H) {
        return D = D >>> 0, H || ue(D, 1, this.length), this[D];
    }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(D, H) {
        return D = D >>> 0, H || ue(D, 2, this.length), this[D] | this[D + 1] << 8;
    }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(D, H) {
        return D = D >>> 0, H || ue(D, 2, this.length), this[D] << 8 | this[D + 1];
    }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(D, H) {
        return D = D >>> 0, H || ue(D, 4, this.length), (this[D] | this[D + 1] << 8 | this[D + 2] << 16) + this[D + 3] * 16777216;
    }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(D, H) {
        return D = D >>> 0, H || ue(D, 4, this.length), this[D] * 16777216 + (this[D + 1] << 16 | this[D + 2] << 8 | this[D + 3]);
    }, u.prototype.readBigUInt64LE = X(function(D) {
        D = D >>> 0, me(D, "offset");
        const H = this[D], te = this[D + 7];
        (H === void 0 || te === void 0) && je(D, this.length - 8);
        const ge = H + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + this[++D] * 2 ** 24, ce = this[++D] + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + te * 2 ** 24;
        return BigInt(ge) + (BigInt(ce) << BigInt(32));
    }), u.prototype.readBigUInt64BE = X(function(D) {
        D = D >>> 0, me(D, "offset");
        const H = this[D], te = this[D + 7];
        (H === void 0 || te === void 0) && je(D, this.length - 8);
        const ge = H * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + this[++D], ce = this[++D] * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + te;
        return (BigInt(ge) << BigInt(32)) + BigInt(ce);
    }), u.prototype.readIntLE = function(D, H, te) {
        D = D >>> 0, H = H >>> 0, te || ue(D, H, this.length);
        let ge = this[D], ce = 1, Ue = 0;
        for(; ++Ue < H && (ce *= 256);)ge += this[D + Ue] * ce;
        return ce *= 128, ge >= ce && (ge -= Math.pow(2, 8 * H)), ge;
    }, u.prototype.readIntBE = function(D, H, te) {
        D = D >>> 0, H = H >>> 0, te || ue(D, H, this.length);
        let ge = H, ce = 1, Ue = this[D + --ge];
        for(; ge > 0 && (ce *= 256);)Ue += this[D + --ge] * ce;
        return ce *= 128, Ue >= ce && (Ue -= Math.pow(2, 8 * H)), Ue;
    }, u.prototype.readInt8 = function(D, H) {
        return D = D >>> 0, H || ue(D, 1, this.length), this[D] & 128 ? (255 - this[D] + 1) * -1 : this[D];
    }, u.prototype.readInt16LE = function(D, H) {
        D = D >>> 0, H || ue(D, 2, this.length);
        const te = this[D] | this[D + 1] << 8;
        return te & 32768 ? te | 4294901760 : te;
    }, u.prototype.readInt16BE = function(D, H) {
        D = D >>> 0, H || ue(D, 2, this.length);
        const te = this[D + 1] | this[D] << 8;
        return te & 32768 ? te | 4294901760 : te;
    }, u.prototype.readInt32LE = function(D, H) {
        return D = D >>> 0, H || ue(D, 4, this.length), this[D] | this[D + 1] << 8 | this[D + 2] << 16 | this[D + 3] << 24;
    }, u.prototype.readInt32BE = function(D, H) {
        return D = D >>> 0, H || ue(D, 4, this.length), this[D] << 24 | this[D + 1] << 16 | this[D + 2] << 8 | this[D + 3];
    }, u.prototype.readBigInt64LE = X(function(D) {
        D = D >>> 0, me(D, "offset");
        const H = this[D], te = this[D + 7];
        (H === void 0 || te === void 0) && je(D, this.length - 8);
        const ge = this[D + 4] + this[D + 5] * 2 ** 8 + this[D + 6] * 2 ** 16 + (te << 24);
        return (BigInt(ge) << BigInt(32)) + BigInt(H + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + this[++D] * 2 ** 24);
    }), u.prototype.readBigInt64BE = X(function(D) {
        D = D >>> 0, me(D, "offset");
        const H = this[D], te = this[D + 7];
        (H === void 0 || te === void 0) && je(D, this.length - 8);
        const ge = (H << 24) + // Overflow
        this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + this[++D];
        return (BigInt(ge) << BigInt(32)) + BigInt(this[++D] * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + te);
    }), u.prototype.readFloatLE = function(D, H) {
        return D = D >>> 0, H || ue(D, 4, this.length), r.read(this, D, !0, 23, 4);
    }, u.prototype.readFloatBE = function(D, H) {
        return D = D >>> 0, H || ue(D, 4, this.length), r.read(this, D, !1, 23, 4);
    }, u.prototype.readDoubleLE = function(D, H) {
        return D = D >>> 0, H || ue(D, 8, this.length), r.read(this, D, !0, 52, 8);
    }, u.prototype.readDoubleBE = function(D, H) {
        return D = D >>> 0, H || ue(D, 8, this.length), r.read(this, D, !1, 52, 8);
    };
    function G(D, H, te, ge, ce, Ue) {
        if (!u.isBuffer(D)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (H > ce || H < Ue) throw new RangeError('"value" argument is out of bounds');
        if (te + ge > D.length) throw new RangeError("Index out of range");
    }
    u.prototype.writeUintLE = u.prototype.writeUIntLE = function(D, H, te, ge) {
        if (D = +D, H = H >>> 0, te = te >>> 0, !ge) {
            const qe = Math.pow(2, 8 * te) - 1;
            G(this, D, H, te, qe, 0);
        }
        let ce = 1, Ue = 0;
        for(this[H] = D & 255; ++Ue < te && (ce *= 256);)this[H + Ue] = D / ce & 255;
        return H + te;
    }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(D, H, te, ge) {
        if (D = +D, H = H >>> 0, te = te >>> 0, !ge) {
            const qe = Math.pow(2, 8 * te) - 1;
            G(this, D, H, te, qe, 0);
        }
        let ce = te - 1, Ue = 1;
        for(this[H + ce] = D & 255; --ce >= 0 && (Ue *= 256);)this[H + ce] = D / Ue & 255;
        return H + te;
    }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 1, 255, 0), this[H] = D & 255, H + 1;
    }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 2, 65535, 0), this[H] = D & 255, this[H + 1] = D >>> 8, H + 2;
    }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 2, 65535, 0), this[H] = D >>> 8, this[H + 1] = D & 255, H + 2;
    }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 4, 4294967295, 0), this[H + 3] = D >>> 24, this[H + 2] = D >>> 16, this[H + 1] = D >>> 8, this[H] = D & 255, H + 4;
    }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 4, 4294967295, 0), this[H] = D >>> 24, this[H + 1] = D >>> 16, this[H + 2] = D >>> 8, this[H + 3] = D & 255, H + 4;
    };
    function se(D, H, te, ge, ce) {
        J(H, ge, ce, D, te, 7);
        let Ue = Number(H & BigInt(4294967295));
        D[te++] = Ue, Ue = Ue >> 8, D[te++] = Ue, Ue = Ue >> 8, D[te++] = Ue, Ue = Ue >> 8, D[te++] = Ue;
        let qe = Number(H >> BigInt(32) & BigInt(4294967295));
        return D[te++] = qe, qe = qe >> 8, D[te++] = qe, qe = qe >> 8, D[te++] = qe, qe = qe >> 8, D[te++] = qe, te;
    }
    function Z(D, H, te, ge, ce) {
        J(H, ge, ce, D, te, 7);
        let Ue = Number(H & BigInt(4294967295));
        D[te + 7] = Ue, Ue = Ue >> 8, D[te + 6] = Ue, Ue = Ue >> 8, D[te + 5] = Ue, Ue = Ue >> 8, D[te + 4] = Ue;
        let qe = Number(H >> BigInt(32) & BigInt(4294967295));
        return D[te + 3] = qe, qe = qe >> 8, D[te + 2] = qe, qe = qe >> 8, D[te + 1] = qe, qe = qe >> 8, D[te] = qe, te + 8;
    }
    u.prototype.writeBigUInt64LE = X(function(D, H = 0) {
        return se(this, D, H, BigInt(0), BigInt("0xffffffffffffffff"));
    }), u.prototype.writeBigUInt64BE = X(function(D, H = 0) {
        return Z(this, D, H, BigInt(0), BigInt("0xffffffffffffffff"));
    }), u.prototype.writeIntLE = function(D, H, te, ge) {
        if (D = +D, H = H >>> 0, !ge) {
            const ot = Math.pow(2, 8 * te - 1);
            G(this, D, H, te, ot - 1, -ot);
        }
        let ce = 0, Ue = 1, qe = 0;
        for(this[H] = D & 255; ++ce < te && (Ue *= 256);)D < 0 && qe === 0 && this[H + ce - 1] !== 0 && (qe = 1), this[H + ce] = (D / Ue >> 0) - qe & 255;
        return H + te;
    }, u.prototype.writeIntBE = function(D, H, te, ge) {
        if (D = +D, H = H >>> 0, !ge) {
            const ot = Math.pow(2, 8 * te - 1);
            G(this, D, H, te, ot - 1, -ot);
        }
        let ce = te - 1, Ue = 1, qe = 0;
        for(this[H + ce] = D & 255; --ce >= 0 && (Ue *= 256);)D < 0 && qe === 0 && this[H + ce + 1] !== 0 && (qe = 1), this[H + ce] = (D / Ue >> 0) - qe & 255;
        return H + te;
    }, u.prototype.writeInt8 = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 1, 127, -128), D < 0 && (D = 255 + D + 1), this[H] = D & 255, H + 1;
    }, u.prototype.writeInt16LE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 2, 32767, -32768), this[H] = D & 255, this[H + 1] = D >>> 8, H + 2;
    }, u.prototype.writeInt16BE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 2, 32767, -32768), this[H] = D >>> 8, this[H + 1] = D & 255, H + 2;
    }, u.prototype.writeInt32LE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 4, 2147483647, -2147483648), this[H] = D & 255, this[H + 1] = D >>> 8, this[H + 2] = D >>> 16, this[H + 3] = D >>> 24, H + 4;
    }, u.prototype.writeInt32BE = function(D, H, te) {
        return D = +D, H = H >>> 0, te || G(this, D, H, 4, 2147483647, -2147483648), D < 0 && (D = 4294967295 + D + 1), this[H] = D >>> 24, this[H + 1] = D >>> 16, this[H + 2] = D >>> 8, this[H + 3] = D & 255, H + 4;
    }, u.prototype.writeBigInt64LE = X(function(D, H = 0) {
        return se(this, D, H, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), u.prototype.writeBigInt64BE = X(function(D, H = 0) {
        return Z(this, D, H, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ie(D, H, te, ge, ce, Ue) {
        if (te + ge > D.length) throw new RangeError("Index out of range");
        if (te < 0) throw new RangeError("Index out of range");
    }
    function pe(D, H, te, ge, ce) {
        return H = +H, te = te >>> 0, ce || ie(D, H, te, 4), r.write(D, H, te, ge, 23, 4), te + 4;
    }
    u.prototype.writeFloatLE = function(D, H, te) {
        return pe(this, D, H, !0, te);
    }, u.prototype.writeFloatBE = function(D, H, te) {
        return pe(this, D, H, !1, te);
    };
    function ve(D, H, te, ge, ce) {
        return H = +H, te = te >>> 0, ce || ie(D, H, te, 8), r.write(D, H, te, ge, 52, 8), te + 8;
    }
    u.prototype.writeDoubleLE = function(D, H, te) {
        return ve(this, D, H, !0, te);
    }, u.prototype.writeDoubleBE = function(D, H, te) {
        return ve(this, D, H, !1, te);
    }, u.prototype.copy = function(D, H, te, ge) {
        if (!u.isBuffer(D)) throw new TypeError("argument should be a Buffer");
        if (te || (te = 0), !ge && ge !== 0 && (ge = this.length), H >= D.length && (H = D.length), H || (H = 0), ge > 0 && ge < te && (ge = te), ge === te || D.length === 0 || this.length === 0) return 0;
        if (H < 0) throw new RangeError("targetStart out of bounds");
        if (te < 0 || te >= this.length) throw new RangeError("Index out of range");
        if (ge < 0) throw new RangeError("sourceEnd out of bounds");
        ge > this.length && (ge = this.length), D.length - H < ge - te && (ge = D.length - H + te);
        const ce = ge - te;
        return this === D && typeof o.prototype.copyWithin == "function" ? this.copyWithin(H, te, ge) : o.prototype.set.call(D, this.subarray(te, ge), H), ce;
    }, u.prototype.fill = function(D, H, te, ge) {
        if (typeof D == "string") {
            if (typeof H == "string" ? (ge = H, H = 0, te = this.length) : typeof te == "string" && (ge = te, te = this.length), ge !== void 0 && typeof ge != "string") throw new TypeError("encoding must be a string");
            if (typeof ge == "string" && !u.isEncoding(ge)) throw new TypeError("Unknown encoding: " + ge);
            if (D.length === 1) {
                const Ue = D.charCodeAt(0);
                (ge === "utf8" && Ue < 128 || ge === "latin1") && (D = Ue);
            }
        } else typeof D == "number" ? D = D & 255 : typeof D == "boolean" && (D = Number(D));
        if (H < 0 || this.length < H || this.length < te) throw new RangeError("Out of range index");
        if (te <= H) return this;
        H = H >>> 0, te = te === void 0 ? this.length : te >>> 0, D || (D = 0);
        let ce;
        if (typeof D == "number") for(ce = H; ce < te; ++ce)this[ce] = D;
        else {
            const Ue = u.isBuffer(D) ? D : u.from(D, ge), qe = Ue.length;
            if (qe === 0) throw new TypeError('The value "' + D + '" is invalid for argument "value"');
            for(ce = 0; ce < te - H; ++ce)this[ce + H] = Ue[ce % qe];
        }
        return this;
    };
    const Ie = {};
    function Me(D, H, te) {
        Ie[D] = class extends te {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: H.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${D}]`, this.stack, delete this.name;
            }
            get code() {
                return D;
            }
            set code(ge) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: ge,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${D}]: ${this.message}`;
            }
        };
    }
    Me("ERR_BUFFER_OUT_OF_BOUNDS", function(D) {
        return D ? `${D} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), Me("ERR_INVALID_ARG_TYPE", function(D, H) {
        return `The "${D}" argument must be of type number. Received type ${typeof H}`;
    }, TypeError), Me("ERR_OUT_OF_RANGE", function(D, H, te) {
        let ge = `The value of "${D}" is out of range.`, ce = te;
        return Number.isInteger(te) && Math.abs(te) > 2 ** 32 ? ce = Re(String(te)) : typeof te == "bigint" && (ce = String(te), (te > BigInt(2) ** BigInt(32) || te < -(BigInt(2) ** BigInt(32))) && (ce = Re(ce)), ce += "n"), ge += ` It must be ${H}. Received ${ce}`, ge;
    }, RangeError);
    function Re(D) {
        let H = "", te = D.length;
        const ge = D[0] === "-" ? 1 : 0;
        for(; te >= ge + 4; te -= 3)H = `_${D.slice(te - 3, te)}${H}`;
        return `${D.slice(0, te)}${H}`;
    }
    function C(D, H, te) {
        me(H, "offset"), (D[H] === void 0 || D[H + te] === void 0) && je(H, D.length - (te + 1));
    }
    function J(D, H, te, ge, ce, Ue) {
        if (D > te || D < H) {
            const qe = typeof H == "bigint" ? "n" : "";
            let ot;
            throw H === 0 || H === BigInt(0) ? ot = `>= 0${qe} and < 2${qe} ** ${(Ue + 1) * 8}${qe}` : ot = `>= -(2${qe} ** ${(Ue + 1) * 8 - 1}${qe}) and < 2 ** ${(Ue + 1) * 8 - 1}${qe}`, new Ie.ERR_OUT_OF_RANGE("value", ot, D);
        }
        C(ge, ce, Ue);
    }
    function me(D, H) {
        if (typeof D != "number") throw new Ie.ERR_INVALID_ARG_TYPE(H, "number", D);
    }
    function je(D, H, te) {
        throw Math.floor(D) !== D ? (me(D, te), new Ie.ERR_OUT_OF_RANGE("offset", "an integer", D)) : H < 0 ? new Ie.ERR_BUFFER_OUT_OF_BOUNDS() : new Ie.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${H}`, D);
    }
    const Ve = /[^+/0-9A-Za-z-_]/g;
    function nt(D) {
        if (D = D.split("=")[0], D = D.trim().replace(Ve, ""), D.length < 2) return "";
        for(; D.length % 4 !== 0;)D = D + "=";
        return D;
    }
    function We(D, H) {
        H = H || 1 / 0;
        let te;
        const ge = D.length;
        let ce = null;
        const Ue = [];
        for(let qe = 0; qe < ge; ++qe){
            if (te = D.charCodeAt(qe), te > 55295 && te < 57344) {
                if (!ce) {
                    if (te > 56319) {
                        (H -= 3) > -1 && Ue.push(239, 191, 189);
                        continue;
                    } else if (qe + 1 === ge) {
                        (H -= 3) > -1 && Ue.push(239, 191, 189);
                        continue;
                    }
                    ce = te;
                    continue;
                }
                if (te < 56320) {
                    (H -= 3) > -1 && Ue.push(239, 191, 189), ce = te;
                    continue;
                }
                te = (ce - 55296 << 10 | te - 56320) + 65536;
            } else ce && (H -= 3) > -1 && Ue.push(239, 191, 189);
            if (ce = null, te < 128) {
                if ((H -= 1) < 0) break;
                Ue.push(te);
            } else if (te < 2048) {
                if ((H -= 2) < 0) break;
                Ue.push(te >> 6 | 192, te & 63 | 128);
            } else if (te < 65536) {
                if ((H -= 3) < 0) break;
                Ue.push(te >> 12 | 224, te >> 6 & 63 | 128, te & 63 | 128);
            } else if (te < 1114112) {
                if ((H -= 4) < 0) break;
                Ue.push(te >> 18 | 240, te >> 12 & 63 | 128, te >> 6 & 63 | 128, te & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return Ue;
    }
    function Ge(D) {
        const H = [];
        for(let te = 0; te < D.length; ++te)H.push(D.charCodeAt(te) & 255);
        return H;
    }
    function p(D, H) {
        let te, ge, ce;
        const Ue = [];
        for(let qe = 0; qe < D.length && !((H -= 2) < 0); ++qe)te = D.charCodeAt(qe), ge = te >> 8, ce = te % 256, Ue.push(ce), Ue.push(ge);
        return Ue;
    }
    function A(D) {
        return t.toByteArray(nt(D));
    }
    function V(D, H, te, ge) {
        let ce;
        for(ce = 0; ce < ge && !(ce + te >= H.length || ce >= D.length); ++ce)H[ce + te] = D[ce];
        return ce;
    }
    function re(D, H) {
        return D instanceof H || D != null && D.constructor != null && D.constructor.name != null && D.constructor.name === H.name;
    }
    function le(D) {
        return D !== D;
    }
    const L = function() {
        const D = "0123456789abcdef", H = new Array(256);
        for(let te = 0; te < 16; ++te){
            const ge = te * 16;
            for(let ce = 0; ce < 16; ++ce)H[ge + ce] = D[te] + D[ce];
        }
        return H;
    }();
    function X(D) {
        return typeof BigInt > "u" ? ae : D;
    }
    function ae() {
        throw new Error("BigInt not supported");
    }
})(aP);
const Ke = aP.Buffer, uP = "maestro", WZ = "mempool-space", GZ = "sandshrew";
var I8 = /* @__PURE__ */ ((e)=>(e.MAINNET = "fractal_mainnet", e.TESTNET = "fractal_testnet", e))(I8 || {}), Dp = /* @__PURE__ */ ((e)=>(e.MAINNET = "main", e.TESTNET = "testnet", e.SIGNET = "signet", e))(Dp || {}), Hd = /* @__PURE__ */ ((e)=>(e.MAINNET = "mainnet", e.TESTNET = "testnet", e))(Hd || {}), Ao = /* @__PURE__ */ ((e)=>(e.MAINNET = "BITCOIN_MAINNET", e.TESTNET = "BITCOIN_TESTNET", e.TESTNET4 = "BITCOIN_TESTNET4", e.SIGNET = "BITCOIN_SIGNET", e.FRACTAL_MAINNET = "FRACTAL_BITCOIN_MAINNET", e.FRACTAL_TESTNET = "FRACTAL_BITCOIN_TESTNET", e))(Ao || {}), Kc = /* @__PURE__ */ ((e)=>(e.BITCOIN_MAINNET = "BITCOIN_MAINNET", e.BITCOIN_TESTNET = "BITCOIN_TESTNET", e.BITCOIN_SIGNET = "BITCOIN_SIGNET", e))(Kc || {}), QZ = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e))(QZ || {}), Tl = /* @__PURE__ */ ((e)=>(e.MAINNET = "Mainnet", e.TESTNET = "Testnet", e.SIGNET = "Signet", e.FRACTAL_MAINNET = "fractal mainnet", e.FRACTAL_TESTNET = "fractal testnet", e.TESTNET4 = "Testnet4", e))(Tl || {}), B8 = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e))(B8 || {}), Oa = /* @__PURE__ */ ((e)=>(e.MAINNET = "livenet", e.TESTNET = "testnet", e.TESTNET4 = "testnet4", e.SIGNET = "signet", e))(Oa || {}), zy = /* @__PURE__ */ ((e)=>(e.MAINNET = "Mainnet", e.TESTNET = "Testnet", e))(zy || {}), pt = /* @__PURE__ */ ((e)=>(e.MAINNET = "mainnet", e.SIGNET = "signet", e.TESTNET = "testnet", e.TESTNET4 = "testnet4", e.REGTEST = "regtest", e.FRACTAL_MAINNET = "fractal_mainnet", e.FRACTAL_TESTNET = "fractal_testnet", e.OYLNET = "oylnet", e))(pt || {}), Nn = {}, I6 = {}, an = {}, Hi = {}, Qr = {}, R2 = {};
Object.defineProperty(R2, "__esModule", {
    value: !0
});
R2.crypto = void 0;
R2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.Hash = e.nextTick = e.swap32IfBE = e.byteSwapIfBE = e.swap8IfBE = e.isLE = void 0, e.isBytes = r, e.anumber = n, e.abytes = i1, e.ahash = o, e.aexists = a, e.aoutput = s, e.u8 = c, e.u32 = l, e.clean = u, e.createView = f, e.rotr = h, e.rotl = y, e.byteSwap = S, e.byteSwap32 = k, e.bytesToHex = N, e.hexToBytes = $, e.asyncLoop = ee, e.utf8ToBytes = q, e.bytesToUtf8 = U, e.toBytes = Q, e.kdfInputToBytes = v, e.concatBytes = B, e.checkOpts = g, e.createHasher = w, e.createOptHasher = _, e.createXOFer = O, e.randomBytes = I;
    const t = R2;
    function r(x) {
        return x instanceof Uint8Array || ArrayBuffer.isView(x) && x.constructor.name === "Uint8Array";
    }
    function n(x) {
        if (!Number.isSafeInteger(x) || x < 0) throw new Error("positive integer expected, got " + x);
    }
    function i1(x, ...R) {
        if (!r(x)) throw new Error("Uint8Array expected");
        if (R.length > 0 && !R.includes(x.length)) throw new Error("Uint8Array expected of length " + R + ", got length=" + x.length);
    }
    function o(x) {
        if (typeof x != "function" || typeof x.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
        n(x.outputLen), n(x.blockLen);
    }
    function a(x, R = !0) {
        if (x.destroyed) throw new Error("Hash instance has been destroyed");
        if (R && x.finished) throw new Error("Hash#digest() has already been called");
    }
    function s(x, R) {
        i1(x);
        const j = R.outputLen;
        if (x.length < j) throw new Error("digestInto() expects output buffer of length at least " + j);
    }
    function c(x) {
        return new Uint8Array(x.buffer, x.byteOffset, x.byteLength);
    }
    function l(x) {
        return new Uint32Array(x.buffer, x.byteOffset, Math.floor(x.byteLength / 4));
    }
    function u(...x) {
        for(let R = 0; R < x.length; R++)x[R].fill(0);
    }
    function f(x) {
        return new DataView(x.buffer, x.byteOffset, x.byteLength);
    }
    function h(x, R) {
        return x << 32 - R | x >>> R;
    }
    function y(x, R) {
        return x << R | x >>> 32 - R >>> 0;
    }
    e.isLE = new Uint8Array(new Uint32Array([
        287454020
    ]).buffer)[0] === 68;
    function S(x) {
        return x << 24 & 4278190080 | x << 8 & 16711680 | x >>> 8 & 65280 | x >>> 24 & 255;
    }
    e.swap8IfBE = e.isLE ? (x)=>x : (x)=>S(x), e.byteSwapIfBE = e.swap8IfBE;
    function k(x) {
        for(let R = 0; R < x.length; R++)x[R] = S(x[R]);
        return x;
    }
    e.swap32IfBE = e.isLE ? (x)=>x : k;
    const P = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", M = /* @__PURE__ */ Array.from({
        length: 256
    }, (x, R)=>R.toString(16).padStart(2, "0"));
    function N(x) {
        if (i1(x), P) return x.toHex();
        let R = "";
        for(let j = 0; j < x.length; j++)R += M[x[j]];
        return R;
    }
    const z = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function K(x) {
        if (x >= z._0 && x <= z._9) return x - z._0;
        if (x >= z.A && x <= z.F) return x - (z.A - 10);
        if (x >= z.a && x <= z.f) return x - (z.a - 10);
    }
    function $(x) {
        if (typeof x != "string") throw new Error("hex string expected, got " + typeof x);
        if (P) return Uint8Array.fromHex(x);
        const R = x.length, j = R / 2;
        if (R % 2) throw new Error("hex string expected, got unpadded hex of length " + R);
        const Y = new Uint8Array(j);
        for(let he = 0, ue = 0; he < j; he++, ue += 2){
            const G = K(x.charCodeAt(ue)), se = K(x.charCodeAt(ue + 1));
            if (G === void 0 || se === void 0) {
                const Z = x[ue] + x[ue + 1];
                throw new Error('hex string expected, got non-hex character "' + Z + '" at index ' + ue);
            }
            Y[he] = G * 16 + se;
        }
        return Y;
    }
    const ne = async ()=>{};
    e.nextTick = ne;
    async function ee(x, R, j) {
        let Y = Date.now();
        for(let he = 0; he < x; he++){
            j(he);
            const ue = Date.now() - Y;
            ue >= 0 && ue < R || (await (0, e.nextTick)(), Y += ue);
        }
    }
    function q(x) {
        if (typeof x != "string") throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(x));
    }
    function U(x) {
        return new TextDecoder().decode(x);
    }
    function Q(x) {
        return typeof x == "string" && (x = q(x)), i1(x), x;
    }
    function v(x) {
        return typeof x == "string" && (x = q(x)), i1(x), x;
    }
    function B(...x) {
        let R = 0;
        for(let Y = 0; Y < x.length; Y++){
            const he = x[Y];
            i1(he), R += he.length;
        }
        const j = new Uint8Array(R);
        for(let Y = 0, he = 0; Y < x.length; Y++){
            const ue = x[Y];
            j.set(ue, he), he += ue.length;
        }
        return j;
    }
    function g(x, R) {
        if (R !== void 0 && ({}).toString.call(R) !== "[object Object]") throw new Error("options should be object or undefined");
        return Object.assign(x, R);
    }
    class E {
    }
    e.Hash = E;
    function w(x) {
        const R = (Y)=>x().update(Q(Y)).digest(), j = x();
        return R.outputLen = j.outputLen, R.blockLen = j.blockLen, R.create = ()=>x(), R;
    }
    function _(x) {
        const R = (Y, he)=>x(he).update(Q(Y)).digest(), j = x({});
        return R.outputLen = j.outputLen, R.blockLen = j.blockLen, R.create = (Y)=>x(Y), R;
    }
    function O(x) {
        const R = (Y, he)=>x(he).update(Q(Y)).digest(), j = x({});
        return R.outputLen = j.outputLen, R.blockLen = j.blockLen, R.create = (Y)=>x(Y), R;
    }
    e.wrapConstructor = w, e.wrapConstructorWithOpts = _, e.wrapXOFConstructorWithOpts = O;
    function I(x = 32) {
        if (t.crypto && typeof t.crypto.getRandomValues == "function") return t.crypto.getRandomValues(new Uint8Array(x));
        if (t.crypto && typeof t.crypto.randomBytes == "function") return Uint8Array.from(t.crypto.randomBytes(x));
        throw new Error("crypto.getRandomValues must be defined");
    }
})(Qr);
Object.defineProperty(Hi, "__esModule", {
    value: !0
});
Hi.SHA512_IV = Hi.SHA384_IV = Hi.SHA224_IV = Hi.SHA256_IV = Hi.HashMD = void 0;
Hi.setBigUint64 = cP;
Hi.Chi = $Z;
Hi.Maj = ZZ;
const ws = Qr;
function cP(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
function $Z(e, t, r) {
    return e & t ^ ~e & r;
}
function ZZ(e, t, r) {
    return e & t ^ e & r ^ t & r;
}
class XZ extends ws.Hash {
    constructor(t, r, n, i1){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i1, this.buffer = new Uint8Array(t), this.view = (0, ws.createView)(this.buffer);
    }
    update(t) {
        (0, ws.aexists)(this), t = (0, ws.toBytes)(t), (0, ws.abytes)(t);
        const { view: r, buffer: n, blockLen: i1 } = this, o = t.length;
        for(let a = 0; a < o;){
            const s = Math.min(i1 - this.pos, o - a);
            if (s === i1) {
                const c = (0, ws.createView)(t);
                for(; i1 <= o - a; a += i1)this.process(c, a);
                continue;
            }
            n.set(t.subarray(a, a + s), this.pos), this.pos += s, a += s, this.pos === i1 && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        (0, ws.aexists)(this), (0, ws.aoutput)(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i1, isLE: o } = this;
        let { pos: a } = this;
        r[a++] = 128, (0, ws.clean)(this.buffer.subarray(a)), this.padOffset > i1 - a && (this.process(n, 0), a = 0);
        for(let f = a; f < i1; f++)r[f] = 0;
        cP(n, i1 - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const s = (0, ws.createView)(t), c = this.outputLen;
        if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4, u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for(let f = 0; f < l; f++)s.setUint32(4 * f, u[f], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i1, finished: o, destroyed: a, pos: s } = this;
        return t.destroyed = a, t.finished = o, t.length = i1, t.pos = s, i1 % r && t.buffer.set(n), t;
    }
    clone() {
        return this._cloneInto();
    }
}
Hi.HashMD = XZ;
Hi.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]);
Hi.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
]);
Hi.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
]);
Hi.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]);
var fr = {};
Object.defineProperty(fr, "__esModule", {
    value: !0
});
fr.toBig = fr.shrSL = fr.shrSH = fr.rotrSL = fr.rotrSH = fr.rotrBL = fr.rotrBH = fr.rotr32L = fr.rotr32H = fr.rotlSL = fr.rotlSH = fr.rotlBL = fr.rotlBH = fr.add5L = fr.add5H = fr.add4L = fr.add4H = fr.add3L = fr.add3H = void 0;
fr.add = xP;
fr.fromBig = B6;
fr.split = lP;
const $g = /* @__PURE__ */ BigInt(2 ** 32 - 1), T8 = /* @__PURE__ */ BigInt(32);
function B6(e, t = !1) {
    return t ? {
        h: Number(e & $g),
        l: Number(e >> T8 & $g)
    } : {
        h: Number(e >> T8 & $g) | 0,
        l: Number(e & $g) | 0
    };
}
function lP(e, t = !1) {
    const r = e.length;
    let n = new Uint32Array(r), i1 = new Uint32Array(r);
    for(let o = 0; o < r; o++){
        const { h: a, l: s } = B6(e[o], t);
        [n[o], i1[o]] = [
            a,
            s
        ];
    }
    return [
        n,
        i1
    ];
}
const fP = (e, t)=>BigInt(e >>> 0) << T8 | BigInt(t >>> 0);
fr.toBig = fP;
const dP = (e, t, r)=>e >>> r;
fr.shrSH = dP;
const hP = (e, t, r)=>e << 32 - r | t >>> r;
fr.shrSL = hP;
const pP = (e, t, r)=>e >>> r | t << 32 - r;
fr.rotrSH = pP;
const gP = (e, t, r)=>e << 32 - r | t >>> r;
fr.rotrSL = gP;
const yP = (e, t, r)=>e << 64 - r | t >>> r - 32;
fr.rotrBH = yP;
const mP = (e, t, r)=>e >>> r - 32 | t << 64 - r;
fr.rotrBL = mP;
const bP = (e, t)=>t;
fr.rotr32H = bP;
const wP = (e, t)=>e;
fr.rotr32L = wP;
const AP = (e, t, r)=>e << r | t >>> 32 - r;
fr.rotlSH = AP;
const vP = (e, t, r)=>t << r | e >>> 32 - r;
fr.rotlSL = vP;
const EP = (e, t, r)=>t << r - 32 | e >>> 64 - r;
fr.rotlBH = EP;
const SP = (e, t, r)=>e << r - 32 | t >>> 64 - r;
fr.rotlBL = SP;
function xP(e, t, r, n) {
    const i1 = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i1 / 2 ** 32 | 0) | 0,
        l: i1 | 0
    };
}
const _P = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0);
fr.add3L = _P;
const kP = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0;
fr.add3H = kP;
const OP = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
fr.add4L = OP;
const IP = (e, t, r, n, i1)=>t + r + n + i1 + (e / 2 ** 32 | 0) | 0;
fr.add4H = IP;
const BP = (e, t, r, n, i1)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i1 >>> 0);
fr.add5L = BP;
const TP = (e, t, r, n, i1, o)=>t + r + n + i1 + o + (e / 2 ** 32 | 0) | 0;
fr.add5H = TP;
const YZ = {
    fromBig: B6,
    split: lP,
    toBig: fP,
    shrSH: dP,
    shrSL: hP,
    rotrSH: pP,
    rotrSL: gP,
    rotrBH: yP,
    rotrBL: mP,
    rotr32H: bP,
    rotr32L: wP,
    rotlSH: AP,
    rotlSL: vP,
    rotlBH: EP,
    rotlBL: SP,
    add: xP,
    add3L: _P,
    add3H: kP,
    add4L: OP,
    add4H: IP,
    add5H: TP,
    add5L: BP
};
fr.default = YZ;
Object.defineProperty(an, "__esModule", {
    value: !0
});
an.sha512_224 = an.sha512_256 = an.sha384 = an.sha512 = an.sha224 = UP = an.sha256 = an.SHA512_256 = an.SHA512_224 = an.SHA384 = an.SHA512 = an.SHA224 = an.SHA256 = void 0;
const Vt = Hi, _r = fr, Gn = Qr, JZ = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), sc = /* @__PURE__ */ new Uint32Array(64);
let T6 = class extends Vt.HashMD {
    constructor(e = 32){
        super(64, e, 8, !1), this.A = Vt.SHA256_IV[0] | 0, this.B = Vt.SHA256_IV[1] | 0, this.C = Vt.SHA256_IV[2] | 0, this.D = Vt.SHA256_IV[3] | 0, this.E = Vt.SHA256_IV[4] | 0, this.F = Vt.SHA256_IV[5] | 0, this.G = Vt.SHA256_IV[6] | 0, this.H = Vt.SHA256_IV[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n, E: i1, F: o, G: a, H: s } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i1 | 0, this.F = o | 0, this.G = a | 0, this.H = s | 0;
    }
    process(e, t) {
        for(let u = 0; u < 16; u++, t += 4)sc[u] = e.getUint32(t, !1);
        for(let u = 16; u < 64; u++){
            const f = sc[u - 15], h = sc[u - 2], y = (0, Gn.rotr)(f, 7) ^ (0, Gn.rotr)(f, 18) ^ f >>> 3, S = (0, Gn.rotr)(h, 17) ^ (0, Gn.rotr)(h, 19) ^ h >>> 10;
            sc[u] = S + sc[u - 7] + y + sc[u - 16] | 0;
        }
        let { A: r, B: n, C: i1, D: o, E: a, F: s, G: c, H: l } = this;
        for(let u = 0; u < 64; u++){
            const f = (0, Gn.rotr)(a, 6) ^ (0, Gn.rotr)(a, 11) ^ (0, Gn.rotr)(a, 25), h = l + f + (0, Vt.Chi)(a, s, c) + JZ[u] + sc[u] | 0, y = ((0, Gn.rotr)(r, 2) ^ (0, Gn.rotr)(r, 13) ^ (0, Gn.rotr)(r, 22)) + (0, Vt.Maj)(r, n, i1) | 0;
            l = c, c = s, s = a, a = o + h | 0, o = i1, i1 = n, n = r, r = h + y | 0;
        }
        r = r + this.A | 0, n = n + this.B | 0, i1 = i1 + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, n, i1, o, a, s, c, l);
    }
    roundClean() {
        (0, Gn.clean)(sc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, Gn.clean)(this.buffer);
    }
};
an.SHA256 = T6;
let PP = class extends T6 {
    constructor(){
        super(28), this.A = Vt.SHA224_IV[0] | 0, this.B = Vt.SHA224_IV[1] | 0, this.C = Vt.SHA224_IV[2] | 0, this.D = Vt.SHA224_IV[3] | 0, this.E = Vt.SHA224_IV[4] | 0, this.F = Vt.SHA224_IV[5] | 0, this.G = Vt.SHA224_IV[6] | 0, this.H = Vt.SHA224_IV[7] | 0;
    }
};
an.SHA224 = PP;
const CP = _r.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), eX = CP[0], tX = CP[1], uc = /* @__PURE__ */ new Uint32Array(80), cc = /* @__PURE__ */ new Uint32Array(80);
let h1 = class extends Vt.HashMD {
    constructor(e = 64){
        super(128, e, 16, !1), this.Ah = Vt.SHA512_IV[0] | 0, this.Al = Vt.SHA512_IV[1] | 0, this.Bh = Vt.SHA512_IV[2] | 0, this.Bl = Vt.SHA512_IV[3] | 0, this.Ch = Vt.SHA512_IV[4] | 0, this.Cl = Vt.SHA512_IV[5] | 0, this.Dh = Vt.SHA512_IV[6] | 0, this.Dl = Vt.SHA512_IV[7] | 0, this.Eh = Vt.SHA512_IV[8] | 0, this.El = Vt.SHA512_IV[9] | 0, this.Fh = Vt.SHA512_IV[10] | 0, this.Fl = Vt.SHA512_IV[11] | 0, this.Gh = Vt.SHA512_IV[12] | 0, this.Gl = Vt.SHA512_IV[13] | 0, this.Hh = Vt.SHA512_IV[14] | 0, this.Hl = Vt.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: e, Al: t, Bh: r, Bl: n, Ch: i1, Cl: o, Dh: a, Dl: s, Eh: c, El: l, Fh: u, Fl: f, Gh: h, Gl: y, Hh: S, Hl: k } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s,
            c,
            l,
            u,
            f,
            h,
            y,
            S,
            k
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s, c, l, u, f, h, y, S, k) {
        this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = i1 | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = s | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = u | 0, this.Fl = f | 0, this.Gh = h | 0, this.Gl = y | 0, this.Hh = S | 0, this.Hl = k | 0;
    }
    process(e, t) {
        for(let N = 0; N < 16; N++, t += 4)uc[N] = e.getUint32(t), cc[N] = e.getUint32(t += 4);
        for(let N = 16; N < 80; N++){
            const z = uc[N - 15] | 0, K = cc[N - 15] | 0, $ = _r.rotrSH(z, K, 1) ^ _r.rotrSH(z, K, 8) ^ _r.shrSH(z, K, 7), ne = _r.rotrSL(z, K, 1) ^ _r.rotrSL(z, K, 8) ^ _r.shrSL(z, K, 7), ee = uc[N - 2] | 0, q = cc[N - 2] | 0, U = _r.rotrSH(ee, q, 19) ^ _r.rotrBH(ee, q, 61) ^ _r.shrSH(ee, q, 6), Q = _r.rotrSL(ee, q, 19) ^ _r.rotrBL(ee, q, 61) ^ _r.shrSL(ee, q, 6), v = _r.add4L(ne, Q, cc[N - 7], cc[N - 16]), B = _r.add4H(v, $, U, uc[N - 7], uc[N - 16]);
            uc[N] = B | 0, cc[N] = v | 0;
        }
        let { Ah: r, Al: n, Bh: i1, Bl: o, Ch: a, Cl: s, Dh: c, Dl: l, Eh: u, El: f, Fh: h, Fl: y, Gh: S, Gl: k, Hh: P, Hl: M } = this;
        for(let N = 0; N < 80; N++){
            const z = _r.rotrSH(u, f, 14) ^ _r.rotrSH(u, f, 18) ^ _r.rotrBH(u, f, 41), K = _r.rotrSL(u, f, 14) ^ _r.rotrSL(u, f, 18) ^ _r.rotrBL(u, f, 41), $ = u & h ^ ~u & S, ne = f & y ^ ~f & k, ee = _r.add5L(M, K, ne, tX[N], cc[N]), q = _r.add5H(ee, P, z, $, eX[N], uc[N]), U = ee | 0, Q = _r.rotrSH(r, n, 28) ^ _r.rotrBH(r, n, 34) ^ _r.rotrBH(r, n, 39), v = _r.rotrSL(r, n, 28) ^ _r.rotrBL(r, n, 34) ^ _r.rotrBL(r, n, 39), B = r & i1 ^ r & a ^ i1 & a, g = n & o ^ n & s ^ o & s;
            P = S | 0, M = k | 0, S = h | 0, k = y | 0, h = u | 0, y = f | 0, ({ h: u, l: f } = _r.add(c | 0, l | 0, q | 0, U | 0)), c = a | 0, l = s | 0, a = i1 | 0, s = o | 0, i1 = r | 0, o = n | 0;
            const E = _r.add3L(U, v, g);
            r = _r.add3H(E, q, Q, B), n = E | 0;
        }
        ({ h: r, l: n } = _r.add(this.Ah | 0, this.Al | 0, r | 0, n | 0)), ({ h: i1, l: o } = _r.add(this.Bh | 0, this.Bl | 0, i1 | 0, o | 0)), ({ h: a, l: s } = _r.add(this.Ch | 0, this.Cl | 0, a | 0, s | 0)), ({ h: c, l } = _r.add(this.Dh | 0, this.Dl | 0, c | 0, l | 0)), ({ h: u, l: f } = _r.add(this.Eh | 0, this.El | 0, u | 0, f | 0)), ({ h, l: y } = _r.add(this.Fh | 0, this.Fl | 0, h | 0, y | 0)), ({ h: S, l: k } = _r.add(this.Gh | 0, this.Gl | 0, S | 0, k | 0)), ({ h: P, l: M } = _r.add(this.Hh | 0, this.Hl | 0, P | 0, M | 0)), this.set(r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M);
    }
    roundClean() {
        (0, Gn.clean)(uc, cc);
    }
    destroy() {
        (0, Gn.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
};
an.SHA512 = h1;
let MP = class extends h1 {
    constructor(){
        super(48), this.Ah = Vt.SHA384_IV[0] | 0, this.Al = Vt.SHA384_IV[1] | 0, this.Bh = Vt.SHA384_IV[2] | 0, this.Bl = Vt.SHA384_IV[3] | 0, this.Ch = Vt.SHA384_IV[4] | 0, this.Cl = Vt.SHA384_IV[5] | 0, this.Dh = Vt.SHA384_IV[6] | 0, this.Dl = Vt.SHA384_IV[7] | 0, this.Eh = Vt.SHA384_IV[8] | 0, this.El = Vt.SHA384_IV[9] | 0, this.Fh = Vt.SHA384_IV[10] | 0, this.Fl = Vt.SHA384_IV[11] | 0, this.Gh = Vt.SHA384_IV[12] | 0, this.Gl = Vt.SHA384_IV[13] | 0, this.Hh = Vt.SHA384_IV[14] | 0, this.Hl = Vt.SHA384_IV[15] | 0;
    }
};
an.SHA384 = MP;
const Ri = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
]), Ui = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
]);
let NP = class extends h1 {
    constructor(){
        super(28), this.Ah = Ri[0] | 0, this.Al = Ri[1] | 0, this.Bh = Ri[2] | 0, this.Bl = Ri[3] | 0, this.Ch = Ri[4] | 0, this.Cl = Ri[5] | 0, this.Dh = Ri[6] | 0, this.Dl = Ri[7] | 0, this.Eh = Ri[8] | 0, this.El = Ri[9] | 0, this.Fh = Ri[10] | 0, this.Fl = Ri[11] | 0, this.Gh = Ri[12] | 0, this.Gl = Ri[13] | 0, this.Hh = Ri[14] | 0, this.Hl = Ri[15] | 0;
    }
};
an.SHA512_224 = NP;
let RP = class extends h1 {
    constructor(){
        super(32), this.Ah = Ui[0] | 0, this.Al = Ui[1] | 0, this.Bh = Ui[2] | 0, this.Bl = Ui[3] | 0, this.Ch = Ui[4] | 0, this.Cl = Ui[5] | 0, this.Dh = Ui[6] | 0, this.Dl = Ui[7] | 0, this.Eh = Ui[8] | 0, this.El = Ui[9] | 0, this.Fh = Ui[10] | 0, this.Fl = Ui[11] | 0, this.Gh = Ui[12] | 0, this.Gl = Ui[13] | 0, this.Hh = Ui[14] | 0, this.Hl = Ui[15] | 0;
    }
};
an.SHA512_256 = RP;
var UP = an.sha256 = (0, Gn.createHasher)(()=>new T6());
an.sha224 = (0, Gn.createHasher)(()=>new PP());
an.sha512 = (0, Gn.createHasher)(()=>new h1());
an.sha384 = (0, Gn.createHasher)(()=>new MP());
an.sha512_256 = (0, Gn.createHasher)(()=>new RP());
an.sha512_224 = (0, Gn.createHasher)(()=>new NP());
var U2 = {}, P6 = {}, p1 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.hmac = e.HMAC = void 0;
    const t = Qr;
    class r extends t.Hash {
        constructor(o, a){
            super(), this.finished = !1, this.destroyed = !1, (0, t.ahash)(o);
            const s = (0, t.toBytes)(a);
            if (this.iHash = o.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
            const c = this.blockLen, l = new Uint8Array(c);
            l.set(s.length > c ? o.create().update(s).digest() : s);
            for(let u = 0; u < l.length; u++)l[u] ^= 54;
            this.iHash.update(l), this.oHash = o.create();
            for(let u = 0; u < l.length; u++)l[u] ^= 106;
            this.oHash.update(l), (0, t.clean)(l);
        }
        update(o) {
            return (0, t.aexists)(this), this.iHash.update(o), this;
        }
        digestInto(o) {
            (0, t.aexists)(this), (0, t.abytes)(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();
        }
        digest() {
            const o = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(o), o;
        }
        _cloneInto(o) {
            o || (o = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash: a, iHash: s, finished: c, destroyed: l, blockLen: u, outputLen: f } = this;
            return o = o, o.finished = c, o.destroyed = l, o.blockLen = u, o.outputLen = f, o.oHash = a._cloneInto(o.oHash), o.iHash = s._cloneInto(o.iHash), o;
        }
        clone() {
            return this._cloneInto();
        }
        destroy() {
            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
        }
    }
    e.HMAC = r;
    const n = (i1, o, a)=>new r(i1, o).update(a).digest();
    e.hmac = n, e.hmac.create = (i1, o)=>new r(i1, o);
})(p1);
var Tf = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.notImplemented = e.bitMask = e.utf8ToBytes = e.randomBytes = e.isBytes = e.hexToBytes = e.concatBytes = e.bytesToUtf8 = e.bytesToHex = e.anumber = e.abytes = void 0, e.abool = o, e.numberToHexUnpadded = a, e.hexToNumber = s, e.bytesToNumberBE = c, e.bytesToNumberLE = l, e.numberToBytesBE = u, e.numberToBytesLE = f, e.numberToVarBytesBE = h, e.ensureBytes = y, e.equalBytes = S, e.inRange = P, e.aInRange = M, e.bitLen = N, e.bitGet = z, e.bitSet = K, e.createHmacDrbg = ne, e.validateObject = q, e.isHash = U, e._validateObject = Q, e.memoized = B;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = Qr;
    var r = Qr;
    Object.defineProperty(e, "abytes", {
        enumerable: !0,
        get: function() {
            return r.abytes;
        }
    }), Object.defineProperty(e, "anumber", {
        enumerable: !0,
        get: function() {
            return r.anumber;
        }
    }), Object.defineProperty(e, "bytesToHex", {
        enumerable: !0,
        get: function() {
            return r.bytesToHex;
        }
    }), Object.defineProperty(e, "bytesToUtf8", {
        enumerable: !0,
        get: function() {
            return r.bytesToUtf8;
        }
    }), Object.defineProperty(e, "concatBytes", {
        enumerable: !0,
        get: function() {
            return r.concatBytes;
        }
    }), Object.defineProperty(e, "hexToBytes", {
        enumerable: !0,
        get: function() {
            return r.hexToBytes;
        }
    }), Object.defineProperty(e, "isBytes", {
        enumerable: !0,
        get: function() {
            return r.isBytes;
        }
    }), Object.defineProperty(e, "randomBytes", {
        enumerable: !0,
        get: function() {
            return r.randomBytes;
        }
    }), Object.defineProperty(e, "utf8ToBytes", {
        enumerable: !0,
        get: function() {
            return r.utf8ToBytes;
        }
    });
    const n = /* @__PURE__ */ BigInt(0), i1 = /* @__PURE__ */ BigInt(1);
    function o(g, E) {
        if (typeof E != "boolean") throw new Error(g + " boolean expected, got " + E);
    }
    function a(g) {
        const E = g.toString(16);
        return E.length & 1 ? "0" + E : E;
    }
    function s(g) {
        if (typeof g != "string") throw new Error("hex string expected, got " + typeof g);
        return g === "" ? n : BigInt("0x" + g);
    }
    function c(g) {
        return s((0, t.bytesToHex)(g));
    }
    function l(g) {
        return (0, t.abytes)(g), s((0, t.bytesToHex)(Uint8Array.from(g).reverse()));
    }
    function u(g, E) {
        return (0, t.hexToBytes)(g.toString(16).padStart(E * 2, "0"));
    }
    function f(g, E) {
        return u(g, E).reverse();
    }
    function h(g) {
        return (0, t.hexToBytes)(a(g));
    }
    function y(g, E, w) {
        let _;
        if (typeof E == "string") try {
            _ = (0, t.hexToBytes)(E);
        } catch (I) {
            throw new Error(g + " must be hex string or Uint8Array, cause: " + I);
        }
        else if ((0, t.isBytes)(E)) _ = Uint8Array.from(E);
        else throw new Error(g + " must be hex string or Uint8Array");
        const O = _.length;
        if (typeof w == "number" && O !== w) throw new Error(g + " of length " + w + " expected, got " + O);
        return _;
    }
    function S(g, E) {
        if (g.length !== E.length) return !1;
        let w = 0;
        for(let _ = 0; _ < g.length; _++)w |= g[_] ^ E[_];
        return w === 0;
    }
    const k = (g)=>typeof g == "bigint" && n <= g;
    function P(g, E, w) {
        return k(g) && k(E) && k(w) && E <= g && g < w;
    }
    function M(g, E, w, _) {
        if (!P(E, w, _)) throw new Error("expected valid " + g + ": " + w + " <= n < " + _ + ", got " + E);
    }
    function N(g) {
        let E;
        for(E = 0; g > n; g >>= i1, E += 1);
        return E;
    }
    function z(g, E) {
        return g >> BigInt(E) & i1;
    }
    function K(g, E, w) {
        return g | (w ? i1 : n) << BigInt(E);
    }
    const $ = (g)=>(i1 << BigInt(g)) - i1;
    e.bitMask = $;
    function ne(g, E, w) {
        if (typeof g != "number" || g < 2) throw new Error("hashLen must be a number");
        if (typeof E != "number" || E < 2) throw new Error("qByteLen must be a number");
        if (typeof w != "function") throw new Error("hmacFn must be a function");
        const _ = (G)=>new Uint8Array(G), O = (G)=>Uint8Array.of(G);
        let I = _(g), x = _(g), R = 0;
        const j = ()=>{
            I.fill(1), x.fill(0), R = 0;
        }, Y = (...G)=>w(x, I, ...G), he = (G = _(0))=>{
            x = Y(O(0), G), I = Y(), G.length !== 0 && (x = Y(O(1), G), I = Y());
        }, ue = ()=>{
            if (R++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let G = 0;
            const se = [];
            for(; G < E;){
                I = Y();
                const Z = I.slice();
                se.push(Z), G += I.length;
            }
            return (0, t.concatBytes)(...se);
        };
        return (G, se)=>{
            j(), he(G);
            let Z;
            for(; !(Z = se(ue()));)he();
            return j(), Z;
        };
    }
    const ee = {
        bigint: (g)=>typeof g == "bigint",
        function: (g)=>typeof g == "function",
        boolean: (g)=>typeof g == "boolean",
        string: (g)=>typeof g == "string",
        stringOrUint8Array: (g)=>typeof g == "string" || (0, t.isBytes)(g),
        isSafeInteger: (g)=>Number.isSafeInteger(g),
        array: (g)=>Array.isArray(g),
        field: (g, E)=>E.Fp.isValid(g),
        hash: (g)=>typeof g == "function" && Number.isSafeInteger(g.outputLen)
    };
    function q(g, E, w = {}) {
        const _ = (O, I, x)=>{
            const R = ee[I];
            if (typeof R != "function") throw new Error("invalid validator function");
            const j = g[O];
            if (!(x && j === void 0) && !R(j, g)) throw new Error("param " + String(O) + " is invalid. Expected " + I + ", got " + j);
        };
        for (const [O, I] of Object.entries(E))_(O, I, !1);
        for (const [O, I] of Object.entries(w))_(O, I, !0);
        return g;
    }
    function U(g) {
        return typeof g == "function" && Number.isSafeInteger(g.outputLen);
    }
    function Q(g, E, w = {}) {
        if (!g || typeof g != "object") throw new Error("expected valid options object");
        function _(O, I, x) {
            const R = g[O];
            if (x && R === void 0) return;
            const j = typeof R;
            if (j !== I || R === null) throw new Error(`param "${O}" is invalid: expected ${I}, got ${j}`);
        }
        Object.entries(E).forEach(([O, I])=>_(O, I, !1)), Object.entries(w).forEach(([O, I])=>_(O, I, !0));
    }
    const v = ()=>{
        throw new Error("not implemented");
    };
    e.notImplemented = v;
    function B(g) {
        const E = /* @__PURE__ */ new WeakMap();
        return (w, ..._)=>{
            const O = E.get(w);
            if (O !== void 0) return O;
            const I = g(w, ..._);
            return E.set(w, I), I;
        };
    }
})(Tf);
var Xs = {}, dn = {};
Object.defineProperty(dn, "__esModule", {
    value: !0
});
dn.isNegativeLE = void 0;
dn.mod = Vo;
dn.pow = nX;
dn.pow2 = iX;
dn.invert = ym;
dn.tonelliShanks = LP;
dn.FpSqrt = HP;
dn.validateField = uX;
dn.FpPow = C6;
dn.FpInvertBatch = KP;
dn.FpDiv = cX;
dn.FpLegendre = mm;
dn.FpIsSquare = lX;
dn.nLength = M6;
dn.Field = N6;
dn.FpSqrtOdd = fX;
dn.FpSqrtEven = dX;
dn.hashToPrivateScalar = hX;
dn.getFieldBytesLength = R6;
dn.getMinHashLength = qP;
dn.mapHashToField = pX;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Eo = Tf, xo = BigInt(0), ai = BigInt(1), Kl = /* @__PURE__ */ BigInt(2), rX = /* @__PURE__ */ BigInt(3), DP = /* @__PURE__ */ BigInt(4), jP = /* @__PURE__ */ BigInt(5), FP = /* @__PURE__ */ BigInt(8);
function Vo(e, t) {
    const r = e % t;
    return r >= xo ? r : t + r;
}
function nX(e, t, r) {
    return C6(N6(r), e, t);
}
function iX(e, t, r) {
    let n = e;
    for(; t-- > xo;)n *= n, n %= r;
    return n;
}
function ym(e, t) {
    if (e === xo) throw new Error("invert: expected non-zero number");
    if (t <= xo) throw new Error("invert: expected positive modulus, got " + t);
    let r = Vo(e, t), n = t, i1 = xo, o = ai;
    for(; r !== xo;){
        const a = n / r, s = n % r, c = i1 - o * a;
        n = r, r = s, i1 = o, o = c;
    }
    if (n !== ai) throw new Error("invert: does not exist");
    return Vo(i1, t);
}
function zP(e, t) {
    const r = (e.ORDER + ai) / DP, n = e.pow(t, r);
    if (!e.eql(e.sqr(n), t)) throw new Error("Cannot find square root");
    return n;
}
function oX(e, t) {
    const r = (e.ORDER - jP) / FP, n = e.mul(t, Kl), i1 = e.pow(n, r), o = e.mul(t, i1), a = e.mul(e.mul(o, Kl), i1), s = e.mul(o, e.sub(a, e.ONE));
    if (!e.eql(e.sqr(s), t)) throw new Error("Cannot find square root");
    return s;
}
function LP(e) {
    if (e < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let t = e - ai, r = 0;
    for(; t % Kl === xo;)t /= Kl, r++;
    let n = Kl;
    const i1 = N6(e);
    for(; mm(i1, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return zP;
    let o = i1.pow(n, t);
    const a = (t + ai) / Kl;
    return function(s, c) {
        if (s.is0(c)) return c;
        if (mm(s, c) !== 1) throw new Error("Cannot find square root");
        let l = r, u = s.mul(s.ONE, o), f = s.pow(c, t), h = s.pow(c, a);
        for(; !s.eql(f, s.ONE);){
            if (s.is0(f)) return s.ZERO;
            let y = 1, S = s.sqr(f);
            for(; !s.eql(S, s.ONE);)if (y++, S = s.sqr(S), y === l) throw new Error("Cannot find square root");
            const k = ai << BigInt(l - y - 1), P = s.pow(u, k);
            l = y, u = s.sqr(P), f = s.mul(f, u), h = s.mul(h, P);
        }
        return h;
    };
}
function HP(e) {
    return e % DP === rX ? zP : e % FP === jP ? oX : LP(e);
}
const aX = (e, t)=>(Vo(e, t) & ai) === ai;
dn.isNegativeLE = aX;
const sX = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function uX(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, r = sX.reduce((n, i1)=>(n[i1] = "function", n), t);
    return (0, Eo._validateObject)(e, r), e;
}
function C6(e, t, r) {
    if (r < xo) throw new Error("invalid exponent, negatives unsupported");
    if (r === xo) return e.ONE;
    if (r === ai) return t;
    let n = e.ONE, i1 = t;
    for(; r > xo;)r & ai && (n = e.mul(n, i1)), i1 = e.sqr(i1), r >>= ai;
    return n;
}
function KP(e, t, r = !1) {
    const n = new Array(t.length).fill(r ? e.ZERO : void 0), i1 = t.reduce((a, s, c)=>e.is0(s) ? a : (n[c] = a, e.mul(a, s)), e.ONE), o = e.inv(i1);
    return t.reduceRight((a, s, c)=>e.is0(s) ? a : (n[c] = e.mul(a, n[c]), e.mul(a, s)), o), n;
}
function cX(e, t, r) {
    return e.mul(t, typeof r == "bigint" ? ym(r, e.ORDER) : e.inv(r));
}
function mm(e, t) {
    const r = (e.ORDER - ai) / Kl, n = e.pow(t, r), i1 = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), a = e.eql(n, e.neg(e.ONE));
    if (!i1 && !o && !a) throw new Error("invalid Legendre symbol result");
    return i1 ? 1 : o ? 0 : -1;
}
function lX(e, t) {
    return mm(e, t) === 1;
}
function M6(e, t) {
    t !== void 0 && (0, Eo.anumber)(t);
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function N6(e, t, r = !1, n = {}) {
    if (e <= xo) throw new Error("invalid field: expected ORDER > 0, got " + e);
    let i1, o;
    if (typeof t == "object" && t != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const u = t;
        u.BITS && (i1 = u.BITS), u.sqrt && (o = u.sqrt), typeof u.isLE == "boolean" && (r = u.isLE);
    } else typeof t == "number" && (i1 = t), n.sqrt && (o = n.sqrt);
    const { nBitLength: a, nByteLength: s } = M6(e, i1);
    if (s > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let c;
    const l = Object.freeze({
        ORDER: e,
        isLE: r,
        BITS: a,
        BYTES: s,
        MASK: (0, Eo.bitMask)(a),
        ZERO: xo,
        ONE: ai,
        create: (u)=>Vo(u, e),
        isValid: (u)=>{
            if (typeof u != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof u);
            return xo <= u && u < e;
        },
        is0: (u)=>u === xo,
        // is valid and invertible
        isValidNot0: (u)=>!l.is0(u) && l.isValid(u),
        isOdd: (u)=>(u & ai) === ai,
        neg: (u)=>Vo(-u, e),
        eql: (u, f)=>u === f,
        sqr: (u)=>Vo(u * u, e),
        add: (u, f)=>Vo(u + f, e),
        sub: (u, f)=>Vo(u - f, e),
        mul: (u, f)=>Vo(u * f, e),
        pow: (u, f)=>C6(l, u, f),
        div: (u, f)=>Vo(u * ym(f, e), e),
        // Same as above, but doesn't normalize
        sqrN: (u)=>u * u,
        addN: (u, f)=>u + f,
        subN: (u, f)=>u - f,
        mulN: (u, f)=>u * f,
        inv: (u)=>ym(u, e),
        sqrt: o || ((u)=>(c || (c = HP(e)), c(l, u))),
        toBytes: (u)=>r ? (0, Eo.numberToBytesLE)(u, s) : (0, Eo.numberToBytesBE)(u, s),
        fromBytes: (u)=>{
            if (u.length !== s) throw new Error("Field.fromBytes: expected " + s + " bytes, got " + u.length);
            return r ? (0, Eo.bytesToNumberLE)(u) : (0, Eo.bytesToNumberBE)(u);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (u)=>KP(l, u),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (u, f, h)=>h ? f : u
    });
    return Object.freeze(l);
}
function fX(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? r : e.neg(r);
}
function dX(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const r = e.sqrt(t);
    return e.isOdd(r) ? e.neg(r) : r;
}
function hX(e, t, r = !1) {
    e = (0, Eo.ensureBytes)("privateHash", e);
    const n = e.length, i1 = M6(t).nByteLength + 8;
    if (i1 < 24 || n < i1 || n > 1024) throw new Error("hashToPrivateScalar: expected " + i1 + "-1024 bytes of input, got " + n);
    const o = r ? (0, Eo.bytesToNumberLE)(e) : (0, Eo.bytesToNumberBE)(e);
    return Vo(o, t - ai) + ai;
}
function R6(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function qP(e) {
    const t = R6(e);
    return t + Math.ceil(t / 2);
}
function pX(e, t, r = !1) {
    const n = e.length, i1 = R6(t), o = qP(t);
    if (n < 16 || n < o || n > 1024) throw new Error("expected " + o + "-1024 bytes of input, got " + n);
    const a = r ? (0, Eo.bytesToNumberLE)(e) : (0, Eo.bytesToNumberBE)(e), s = Vo(a, t - ai) + ai;
    return r ? (0, Eo.numberToBytesLE)(s, i1) : (0, Eo.numberToBytesBE)(s, i1);
}
Object.defineProperty(Xs, "__esModule", {
    value: !0
});
Xs.negateCt = Ly;
Xs.normalizeZ = gX;
Xs.wNAF = yX;
Xs.mulEndoUnsafe = mX;
Xs.pippenger = bX;
Xs.precomputeMSMUnsafe = wX;
Xs.validateBasic = AX;
Xs._createCurveFields = vX;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const h0 = Tf, p0 = dn, lh = BigInt(0), ql = BigInt(1);
function Ly(e, t) {
    const r = t.negate();
    return e ? r : t;
}
function gX(e, t, r) {
    const n = t === "pz" ? (o)=>o.pz : (o)=>o.ez, i1 = (0, p0.FpInvertBatch)(e.Fp, r.map(n));
    return r.map((o, a)=>o.toAffine(i1[a])).map(e.fromAffine);
}
function U6(e, t) {
    if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function vA(e, t) {
    U6(e, t);
    const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i1 = 2 ** e, o = (0, h0.bitMask)(e), a = BigInt(e);
    return {
        windows: r,
        windowSize: n,
        mask: o,
        maxNumber: i1,
        shiftBy: a
    };
}
function CS(e, t, r) {
    const { windowSize: n, mask: i1, maxNumber: o, shiftBy: a } = r;
    let s = Number(e & i1), c = e >> a;
    s > n && (s -= o, c += ql);
    const l = t * n, u = l + Math.abs(s) - 1, f = s === 0, h = s < 0, y = t % 2 !== 0;
    return {
        nextN: c,
        offset: u,
        isZero: f,
        isNeg: h,
        isNegF: y,
        offsetF: l
    };
}
function VP(e, t) {
    if (!Array.isArray(e)) throw new Error("array expected");
    e.forEach((r, n)=>{
        if (!(r instanceof t)) throw new Error("invalid point at index " + n);
    });
}
function WP(e, t) {
    if (!Array.isArray(e)) throw new Error("array of scalars expected");
    e.forEach((r, n)=>{
        if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
    });
}
const EA = /* @__PURE__ */ new WeakMap(), GP = /* @__PURE__ */ new WeakMap();
function SA(e) {
    return GP.get(e) || 1;
}
function MS(e) {
    if (e !== lh) throw new Error("invalid wNAF");
}
function yX(e, t) {
    return {
        constTimeNegate: Ly,
        hasPrecomputes (r) {
            return SA(r) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (r, n, i1 = e.ZERO) {
            let o = r;
            for(; n > lh;)n & ql && (i1 = i1.add(o)), o = o.double(), n >>= ql;
            return i1;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (r, n) {
            const { windows: i1, windowSize: o } = vA(n, t), a = [];
            let s = r, c = s;
            for(let l = 0; l < i1; l++){
                c = s, a.push(c);
                for(let u = 1; u < o; u++)c = c.add(s), a.push(c);
                s = c.double();
            }
            return a;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (r, n, i1) {
            let o = e.ZERO, a = e.BASE;
            const s = vA(r, t);
            for(let c = 0; c < s.windows; c++){
                const { nextN: l, offset: u, isZero: f, isNeg: h, isNegF: y, offsetF: S } = CS(i1, c, s);
                i1 = l, f ? a = a.add(Ly(y, n[S])) : o = o.add(Ly(h, n[u]));
            }
            return MS(i1), {
                p: o,
                f: a
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (r, n, i1, o = e.ZERO) {
            const a = vA(r, t);
            for(let s = 0; s < a.windows && i1 !== lh; s++){
                const { nextN: c, offset: l, isZero: u, isNeg: f } = CS(i1, s, a);
                if (i1 = c, !u) {
                    const h = n[l];
                    o = o.add(f ? h.negate() : h);
                }
            }
            return MS(i1), o;
        },
        getPrecomputes (r, n, i1) {
            let o = EA.get(n);
            return o || (o = this.precomputeWindow(n, r), r !== 1 && (typeof i1 == "function" && (o = i1(o)), EA.set(n, o))), o;
        },
        wNAFCached (r, n, i1) {
            const o = SA(r);
            return this.wNAF(o, this.getPrecomputes(o, r, i1), n);
        },
        wNAFCachedUnsafe (r, n, i1, o) {
            const a = SA(r);
            return a === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(a, this.getPrecomputes(a, r, i1), n, o);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (r, n) {
            U6(n, t), GP.set(r, n), EA.delete(r);
        }
    };
}
function mX(e, t, r, n) {
    let i1 = t, o = e.ZERO, a = e.ZERO;
    for(; r > lh || n > lh;)r & ql && (o = o.add(i1)), n & ql && (a = a.add(i1)), i1 = i1.double(), r >>= ql, n >>= ql;
    return {
        p1: o,
        p2: a
    };
}
function bX(e, t, r, n) {
    VP(r, e), WP(n, t);
    const i1 = r.length, o = n.length;
    if (i1 !== o) throw new Error("arrays of points and scalars must have equal length");
    const a = e.ZERO, s = (0, h0.bitLen)(BigInt(i1));
    let c = 1;
    s > 12 ? c = s - 3 : s > 4 ? c = s - 2 : s > 0 && (c = 2);
    const l = (0, h0.bitMask)(c), u = new Array(Number(l) + 1).fill(a), f = Math.floor((t.BITS - 1) / c) * c;
    let h = a;
    for(let y = f; y >= 0; y -= c){
        u.fill(a);
        for(let k = 0; k < o; k++){
            const P = n[k], M = Number(P >> BigInt(y) & l);
            u[M] = u[M].add(r[k]);
        }
        let S = a;
        for(let k = u.length - 1, P = a; k > 0; k--)P = P.add(u[k]), S = S.add(P);
        if (h = h.add(S), y !== 0) for(let k = 0; k < c; k++)h = h.double();
    }
    return h;
}
function wX(e, t, r, n) {
    U6(n, t.BITS), VP(r, e);
    const i1 = e.ZERO, o = 2 ** n - 1, a = Math.ceil(t.BITS / n), s = (0, h0.bitMask)(n), c = r.map((l)=>{
        const u = [];
        for(let f = 0, h = l; f < o; f++)u.push(h), h = h.add(l);
        return u;
    });
    return (l)=>{
        if (WP(l, t), l.length > r.length) throw new Error("array of scalars must be smaller than array of points");
        let u = i1;
        for(let f = 0; f < a; f++){
            if (u !== i1) for(let y = 0; y < n; y++)u = u.double();
            const h = BigInt(a * n - (f + 1) * n);
            for(let y = 0; y < l.length; y++){
                const S = l[y], k = Number(S >> h & s);
                k && (u = u.add(c[y][k - 1]));
            }
        }
        return u;
    };
}
function AX(e) {
    return (0, p0.validateField)(e.Fp), (0, h0.validateObject)(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...(0, p0.nLength)(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
}
function NS(e, t) {
    if (t) {
        if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return (0, p0.validateField)(t), t;
    } else return (0, p0.Field)(e);
}
function vX(e, t, r = {}) {
    if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const s = t[a];
        if (!(typeof s == "bigint" && s > lh)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const n = NS(t.p, r.Fp), i1 = NS(t.n, r.Fn), o = [
        "Gx",
        "Gy",
        "a",
        e === "weierstrass" ? "b" : "d"
    ];
    for (const a of o)if (!n.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i1
    };
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.DER = e.DERErr = void 0, e._legacyHelperEquat = h, e._legacyHelperNormPriv = y, e.weierstrassN = S, e.weierstrassPoints = k, e.ecdsa = M, e.weierstrass = ne, e.SWUFpSqrtRatio = ee, e.mapToCurveSimpleSWU = q;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = p1, r = Tf, n = Xs, i1 = dn;
    function o(U) {
        U.lowS !== void 0 && (0, r.abool)("lowS", U.lowS), U.prehash !== void 0 && (0, r.abool)("prehash", U.prehash);
    }
    class a extends Error {
        constructor(Q = ""){
            super(Q);
        }
    }
    e.DERErr = a, e.DER = {
        // asn.1 DER encoding utils
        Err: a,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
            encode: (U, Q)=>{
                const { Err: v } = e.DER;
                if (U < 0 || U > 256) throw new v("tlv.encode: wrong tag");
                if (Q.length & 1) throw new v("tlv.encode: unpadded data");
                const B = Q.length / 2, g = (0, r.numberToHexUnpadded)(B);
                if (g.length / 2 & 128) throw new v("tlv.encode: long form length too big");
                const E = B > 127 ? (0, r.numberToHexUnpadded)(g.length / 2 | 128) : "";
                return (0, r.numberToHexUnpadded)(U) + E + g + Q;
            },
            // v - value, l - left bytes (unparsed)
            decode (U, Q) {
                const { Err: v } = e.DER;
                let B = 0;
                if (U < 0 || U > 256) throw new v("tlv.encode: wrong tag");
                if (Q.length < 2 || Q[B++] !== U) throw new v("tlv.decode: wrong tlv");
                const g = Q[B++], E = !!(g & 128);
                let w = 0;
                if (!E) w = g;
                else {
                    const O = g & 127;
                    if (!O) throw new v("tlv.decode(long): indefinite length not supported");
                    if (O > 4) throw new v("tlv.decode(long): byte length is too big");
                    const I = Q.subarray(B, B + O);
                    if (I.length !== O) throw new v("tlv.decode: length bytes not complete");
                    if (I[0] === 0) throw new v("tlv.decode(long): zero leftmost byte");
                    for (const x of I)w = w << 8 | x;
                    if (B += O, w < 128) throw new v("tlv.decode(long): not minimal encoding");
                }
                const _ = Q.subarray(B, B + w);
                if (_.length !== w) throw new v("tlv.decode: wrong value length");
                return {
                    v: _,
                    l: Q.subarray(B + w)
                };
            }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
            encode (U) {
                const { Err: Q } = e.DER;
                if (U < s) throw new Q("integer: negative integers are not allowed");
                let v = (0, r.numberToHexUnpadded)(U);
                if (Number.parseInt(v[0], 16) & 8 && (v = "00" + v), v.length & 1) throw new Q("unexpected DER parsing assertion: unpadded hex");
                return v;
            },
            decode (U) {
                const { Err: Q } = e.DER;
                if (U[0] & 128) throw new Q("invalid signature integer: negative");
                if (U[0] === 0 && !(U[1] & 128)) throw new Q("invalid signature integer: unnecessary leading zero");
                return (0, r.bytesToNumberBE)(U);
            }
        },
        toSig (U) {
            const { Err: Q, _int: v, _tlv: B } = e.DER, g = (0, r.ensureBytes)("signature", U), { v: E, l: w } = B.decode(48, g);
            if (w.length) throw new Q("invalid signature: left bytes after parsing");
            const { v: _, l: O } = B.decode(2, E), { v: I, l: x } = B.decode(2, O);
            if (x.length) throw new Q("invalid signature: left bytes after parsing");
            return {
                r: v.decode(_),
                s: v.decode(I)
            };
        },
        hexFromSig (U) {
            const { _tlv: Q, _int: v } = e.DER, B = Q.encode(2, v.encode(U.r)), g = Q.encode(2, v.encode(U.s)), E = B + g;
            return Q.encode(48, E);
        }
    };
    const s = BigInt(0), c = BigInt(1), l = BigInt(2), u = BigInt(3), f = BigInt(4);
    function h(U, Q, v) {
        function B(g) {
            const E = U.sqr(g), w = U.mul(E, g);
            return U.add(U.add(w, U.mul(g, Q)), v);
        }
        return B;
    }
    function y(U, Q, v) {
        const { BYTES: B } = U;
        function g(E) {
            let w;
            if (typeof E == "bigint") w = E;
            else {
                let _ = (0, r.ensureBytes)("private key", E);
                if (Q) {
                    if (!Q.includes(_.length * 2)) throw new Error("invalid private key");
                    const O = new Uint8Array(B);
                    O.set(_, O.length - _.length), _ = O;
                }
                try {
                    w = U.fromBytes(_);
                } catch  {
                    throw new Error(`invalid private key: expected ui8a of size ${B}, got ${typeof E}`);
                }
            }
            if (v && (w = U.create(w)), !U.isValidNot0(w)) throw new Error("invalid private key: out of range [1..N-1]");
            return w;
        }
        return g;
    }
    function S(U, Q = {}) {
        const { Fp: v, Fn: B } = (0, n._createCurveFields)("weierstrass", U, Q), { h: g, n: E } = U;
        (0, r._validateObject)(Q, {}, {
            allowInfinityPoint: "boolean",
            clearCofactor: "function",
            isTorsionFree: "function",
            fromBytes: "function",
            toBytes: "function",
            endo: "object",
            wrapPrivateKey: "boolean"
        });
        const { endo: w } = Q;
        if (w && (!v.is0(U.a) || typeof w.beta != "bigint" || typeof w.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
        function _() {
            if (!v.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
        }
        function O(Re, C, J) {
            const { x: me, y: je } = C.toAffine(), Ve = v.toBytes(me);
            if ((0, r.abool)("isCompressed", J), J) {
                _();
                const nt = !v.isOdd(je);
                return (0, r.concatBytes)(P(nt), Ve);
            } else return (0, r.concatBytes)(Uint8Array.of(4), Ve, v.toBytes(je));
        }
        function I(Re) {
            (0, r.abytes)(Re);
            const C = v.BYTES, J = C + 1, me = 2 * C + 1, je = Re.length, Ve = Re[0], nt = Re.subarray(1);
            if (je === J && (Ve === 2 || Ve === 3)) {
                const We = v.fromBytes(nt);
                if (!v.isValid(We)) throw new Error("bad point: is not on curve, wrong x");
                const Ge = j(We);
                let p;
                try {
                    p = v.sqrt(Ge);
                } catch (V) {
                    const re = V instanceof Error ? ": " + V.message : "";
                    throw new Error("bad point: is not on curve, sqrt error" + re);
                }
                _();
                const A = v.isOdd(p);
                return (Ve & 1) === 1 !== A && (p = v.neg(p)), {
                    x: We,
                    y: p
                };
            } else if (je === me && Ve === 4) {
                const We = v.fromBytes(nt.subarray(C * 0, C * 1)), Ge = v.fromBytes(nt.subarray(C * 1, C * 2));
                if (!Y(We, Ge)) throw new Error("bad point: is not on curve");
                return {
                    x: We,
                    y: Ge
                };
            } else throw new Error(`bad point: got length ${je}, expected compressed=${J} or uncompressed=${me}`);
        }
        const x = Q.toBytes || O, R = Q.fromBytes || I, j = h(v, U.a, U.b);
        function Y(Re, C) {
            const J = v.sqr(C), me = j(Re);
            return v.eql(J, me);
        }
        if (!Y(U.Gx, U.Gy)) throw new Error("bad curve params: generator point");
        const he = v.mul(v.pow(U.a, u), f), ue = v.mul(v.sqr(U.b), BigInt(27));
        if (v.is0(v.add(he, ue))) throw new Error("bad curve params: a or b");
        function G(Re, C, J = !1) {
            if (!v.isValid(C) || J && v.is0(C)) throw new Error(`bad point coordinate ${Re}`);
            return C;
        }
        function se(Re) {
            if (!(Re instanceof ve)) throw new Error("ProjectivePoint expected");
        }
        const Z = (0, r.memoized)((Re, C)=>{
            const { px: J, py: me, pz: je } = Re;
            if (v.eql(je, v.ONE)) return {
                x: J,
                y: me
            };
            const Ve = Re.is0();
            C == null && (C = Ve ? v.ONE : v.inv(je));
            const nt = v.mul(J, C), We = v.mul(me, C), Ge = v.mul(je, C);
            if (Ve) return {
                x: v.ZERO,
                y: v.ZERO
            };
            if (!v.eql(Ge, v.ONE)) throw new Error("invZ was invalid");
            return {
                x: nt,
                y: We
            };
        }), ie = (0, r.memoized)((Re)=>{
            if (Re.is0()) {
                if (Q.allowInfinityPoint && !v.is0(Re.py)) return;
                throw new Error("bad point: ZERO");
            }
            const { x: C, y: J } = Re.toAffine();
            if (!v.isValid(C) || !v.isValid(J)) throw new Error("bad point: x or y not field elements");
            if (!Y(C, J)) throw new Error("bad point: equation left != right");
            if (!Re.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0;
        });
        function pe(Re, C, J, me, je) {
            return J = new ve(v.mul(J.px, Re), J.py, J.pz), C = (0, n.negateCt)(me, C), J = (0, n.negateCt)(je, J), C.add(J);
        }
        class ve {
            /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(C, J, me){
                this.px = G("x", C), this.py = G("y", J, !0), this.pz = G("z", me), Object.freeze(this);
            }
            /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(C) {
                const { x: J, y: me } = C || {};
                if (!C || !v.isValid(J) || !v.isValid(me)) throw new Error("invalid affine point");
                if (C instanceof ve) throw new Error("projective point not allowed");
                return v.is0(J) && v.is0(me) ? ve.ZERO : new ve(J, me, v.ONE);
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            static normalizeZ(C) {
                return (0, n.normalizeZ)(ve, "pz", C);
            }
            static fromBytes(C) {
                return (0, r.abytes)(C), ve.fromHex(C);
            }
            /** Converts hash string or Uint8Array to Point. */ static fromHex(C) {
                const J = ve.fromAffine(R((0, r.ensureBytes)("pointHex", C)));
                return J.assertValidity(), J;
            }
            /** Multiplies generator point by privateKey. */ static fromPrivateKey(C) {
                const J = y(B, Q.allowedPrivateKeyLengths, Q.wrapPrivateKey);
                return ve.BASE.multiply(J(C));
            }
            /** Multiscalar Multiplication */ static msm(C, J) {
                return (0, n.pippenger)(ve, B, C, J);
            }
            /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */ precompute(C = 8, J = !0) {
                return Me.setWindowSize(this, C), J || this.multiply(u), this;
            }
            /** "Private method", don't use it directly */ _setWindowSize(C) {
                this.precompute(C);
            }
            // TODO: return `this`
            /** A point on curve is valid if it conforms to equation. */ assertValidity() {
                ie(this);
            }
            hasEvenY() {
                const { y: C } = this.toAffine();
                if (!v.isOdd) throw new Error("Field doesn't support isOdd");
                return !v.isOdd(C);
            }
            /** Compare one point to another. */ equals(C) {
                se(C);
                const { px: J, py: me, pz: je } = this, { px: Ve, py: nt, pz: We } = C, Ge = v.eql(v.mul(J, We), v.mul(Ve, je)), p = v.eql(v.mul(me, We), v.mul(nt, je));
                return Ge && p;
            }
            /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
                return new ve(this.px, v.neg(this.py), this.pz);
            }
            // Renes-Costello-Batina exception-free doubling formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 3
            // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
            double() {
                const { a: C, b: J } = U, me = v.mul(J, u), { px: je, py: Ve, pz: nt } = this;
                let We = v.ZERO, Ge = v.ZERO, p = v.ZERO, A = v.mul(je, je), V = v.mul(Ve, Ve), re = v.mul(nt, nt), le = v.mul(je, Ve);
                return le = v.add(le, le), p = v.mul(je, nt), p = v.add(p, p), We = v.mul(C, p), Ge = v.mul(me, re), Ge = v.add(We, Ge), We = v.sub(V, Ge), Ge = v.add(V, Ge), Ge = v.mul(We, Ge), We = v.mul(le, We), p = v.mul(me, p), re = v.mul(C, re), le = v.sub(A, re), le = v.mul(C, le), le = v.add(le, p), p = v.add(A, A), A = v.add(p, A), A = v.add(A, re), A = v.mul(A, le), Ge = v.add(Ge, A), re = v.mul(Ve, nt), re = v.add(re, re), A = v.mul(re, le), We = v.sub(We, A), p = v.mul(re, V), p = v.add(p, p), p = v.add(p, p), new ve(We, Ge, p);
            }
            // Renes-Costello-Batina exception-free addition formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 1
            // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
            add(C) {
                se(C);
                const { px: J, py: me, pz: je } = this, { px: Ve, py: nt, pz: We } = C;
                let Ge = v.ZERO, p = v.ZERO, A = v.ZERO;
                const V = U.a, re = v.mul(U.b, u);
                let le = v.mul(J, Ve), L = v.mul(me, nt), X = v.mul(je, We), ae = v.add(J, me), D = v.add(Ve, nt);
                ae = v.mul(ae, D), D = v.add(le, L), ae = v.sub(ae, D), D = v.add(J, je);
                let H = v.add(Ve, We);
                return D = v.mul(D, H), H = v.add(le, X), D = v.sub(D, H), H = v.add(me, je), Ge = v.add(nt, We), H = v.mul(H, Ge), Ge = v.add(L, X), H = v.sub(H, Ge), A = v.mul(V, D), Ge = v.mul(re, X), A = v.add(Ge, A), Ge = v.sub(L, A), A = v.add(L, A), p = v.mul(Ge, A), L = v.add(le, le), L = v.add(L, le), X = v.mul(V, X), D = v.mul(re, D), L = v.add(L, X), X = v.sub(le, X), X = v.mul(V, X), D = v.add(D, X), le = v.mul(L, D), p = v.add(p, le), le = v.mul(H, D), Ge = v.mul(ae, Ge), Ge = v.sub(Ge, le), le = v.mul(ae, L), A = v.mul(H, A), A = v.add(A, le), new ve(Ge, p, A);
            }
            subtract(C) {
                return this.add(C.negate());
            }
            is0() {
                return this.equals(ve.ZERO);
            }
            /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */ multiply(C) {
                const { endo: J } = Q;
                if (!B.isValidNot0(C)) throw new Error("invalid scalar: out of range");
                let me, je;
                const Ve = (nt)=>Me.wNAFCached(this, nt, ve.normalizeZ);
                if (J) {
                    const { k1neg: nt, k1: We, k2neg: Ge, k2: p } = J.splitScalar(C), { p: A, f: V } = Ve(We), { p: re, f: le } = Ve(p);
                    je = V.add(le), me = pe(J.beta, A, re, nt, Ge);
                } else {
                    const { p: nt, f: We } = Ve(C);
                    me = nt, je = We;
                }
                return ve.normalizeZ([
                    me,
                    je
                ])[0];
            }
            /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */ multiplyUnsafe(C) {
                const { endo: J } = Q, me = this;
                if (!B.isValid(C)) throw new Error("invalid scalar: out of range");
                if (C === s || me.is0()) return ve.ZERO;
                if (C === c) return me;
                if (Me.hasPrecomputes(this)) return this.multiply(C);
                if (J) {
                    const { k1neg: je, k1: Ve, k2neg: nt, k2: We } = J.splitScalar(C), { p1: Ge, p2: p } = (0, n.mulEndoUnsafe)(ve, me, Ve, We);
                    return pe(J.beta, Ge, p, je, nt);
                } else return Me.wNAFCachedUnsafe(me, C);
            }
            multiplyAndAddUnsafe(C, J, me) {
                const je = this.multiplyUnsafe(J).add(C.multiplyUnsafe(me));
                return je.is0() ? void 0 : je;
            }
            /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */ toAffine(C) {
                return Z(this, C);
            }
            /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */ isTorsionFree() {
                const { isTorsionFree: C } = Q;
                return g === c ? !0 : C ? C(ve, this) : Me.wNAFCachedUnsafe(this, E).is0();
            }
            clearCofactor() {
                const { clearCofactor: C } = Q;
                return g === c ? this : C ? C(ve, this) : this.multiplyUnsafe(g);
            }
            toBytes(C = !0) {
                return (0, r.abool)("isCompressed", C), this.assertValidity(), x(ve, this, C);
            }
            /** @deprecated use `toBytes` */ toRawBytes(C = !0) {
                return this.toBytes(C);
            }
            toHex(C = !0) {
                return (0, r.bytesToHex)(this.toBytes(C));
            }
            toString() {
                return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
            }
        }
        ve.BASE = new ve(U.Gx, U.Gy, v.ONE), ve.ZERO = new ve(v.ZERO, v.ONE, v.ZERO), ve.Fp = v, ve.Fn = B;
        const Ie = B.BITS, Me = (0, n.wNAF)(ve, Q.endo ? Math.ceil(Ie / 2) : Ie);
        return ve;
    }
    function k(U) {
        const { CURVE: Q, curveOpts: v } = N(U), B = S(Q, v);
        return K(U, B);
    }
    function P(U) {
        return Uint8Array.of(U ? 2 : 3);
    }
    function M(U, Q, v = {}) {
        (0, r._validateObject)(Q, {
            hash: "function"
        }, {
            hmac: "function",
            lowS: "boolean",
            randomBytes: "function",
            bits2int: "function",
            bits2int_modN: "function"
        });
        const B = Q.randomBytes || r.randomBytes, g = Q.hmac || ((me, ...je)=>(0, t.hmac)(Q.hash, me, (0, r.concatBytes)(...je))), { Fp: E, Fn: w } = U, { ORDER: _, BITS: O } = w;
        function I(me) {
            const je = _ >> c;
            return me > je;
        }
        function x(me) {
            return I(me) ? w.neg(me) : me;
        }
        function R(me, je) {
            if (!w.isValidNot0(je)) throw new Error(`invalid signature ${me}: out of range 1..CURVE.n`);
        }
        class j {
            constructor(je, Ve, nt){
                R("r", je), R("s", Ve), this.r = je, this.s = Ve, nt != null && (this.recovery = nt), Object.freeze(this);
            }
            // pair (bytes of r, bytes of s)
            static fromCompact(je) {
                const Ve = w.BYTES, nt = (0, r.ensureBytes)("compactSignature", je, Ve * 2);
                return new j(w.fromBytes(nt.subarray(0, Ve)), w.fromBytes(nt.subarray(Ve, Ve * 2)));
            }
            // DER encoded ECDSA signature
            // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
            static fromDER(je) {
                const { r: Ve, s: nt } = e.DER.toSig((0, r.ensureBytes)("DER", je));
                return new j(Ve, nt);
            }
            /**
       * @todo remove
       * @deprecated
       */ assertValidity() {}
            addRecoveryBit(je) {
                return new j(this.r, this.s, je);
            }
            // ProjPointType<bigint>
            recoverPublicKey(je) {
                const Ve = E.ORDER, { r: nt, s: We, recovery: Ge } = this;
                if (Ge == null || ![
                    0,
                    1,
                    2,
                    3
                ].includes(Ge)) throw new Error("recovery id invalid");
                if (_ * l < Ve && Ge > 1) throw new Error("recovery id is ambiguous for h>1 curve");
                const p = Ge === 2 || Ge === 3 ? nt + _ : nt;
                if (!E.isValid(p)) throw new Error("recovery id 2 or 3 invalid");
                const A = E.toBytes(p), V = U.fromHex((0, r.concatBytes)(P((Ge & 1) === 0), A)), re = w.inv(p), le = ie((0, r.ensureBytes)("msgHash", je)), L = w.create(-le * re), X = w.create(We * re), ae = U.BASE.multiplyUnsafe(L).add(V.multiplyUnsafe(X));
                if (ae.is0()) throw new Error("point at infinify");
                return ae.assertValidity(), ae;
            }
            // Signatures should be low-s, to prevent malleability.
            hasHighS() {
                return I(this.s);
            }
            normalizeS() {
                return this.hasHighS() ? new j(this.r, w.neg(this.s), this.recovery) : this;
            }
            toBytes(je) {
                if (je === "compact") return (0, r.concatBytes)(w.toBytes(this.r), w.toBytes(this.s));
                if (je === "der") return (0, r.hexToBytes)(e.DER.hexFromSig(this));
                throw new Error("invalid format");
            }
            // DER-encoded
            toDERRawBytes() {
                return this.toBytes("der");
            }
            toDERHex() {
                return (0, r.bytesToHex)(this.toBytes("der"));
            }
            // padded bytes of r, then padded bytes of s
            toCompactRawBytes() {
                return this.toBytes("compact");
            }
            toCompactHex() {
                return (0, r.bytesToHex)(this.toBytes("compact"));
            }
        }
        const Y = y(w, v.allowedPrivateKeyLengths, v.wrapPrivateKey), he = {
            isValidPrivateKey (me) {
                try {
                    return Y(me), !0;
                } catch  {
                    return !1;
                }
            },
            normPrivateKeyToScalar: Y,
            /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */ randomPrivateKey: ()=>{
                const me = _;
                return (0, i1.mapHashToField)(B((0, i1.getMinHashLength)(me)), me);
            },
            precompute (me = 8, je = U.BASE) {
                return je.precompute(me, !1);
            }
        };
        function ue(me, je = !0) {
            return U.fromPrivateKey(me).toBytes(je);
        }
        function G(me) {
            if (typeof me == "bigint") return !1;
            if (me instanceof U) return !0;
            const je = (0, r.ensureBytes)("key", me).length, Ve = E.BYTES, nt = Ve + 1, We = 2 * Ve + 1;
            if (!(v.allowedPrivateKeyLengths || w.BYTES === nt)) return je === nt || je === We;
        }
        function se(me, je, Ve = !0) {
            if (G(me) === !0) throw new Error("first arg must be private key");
            if (G(je) === !1) throw new Error("second arg must be public key");
            return U.fromHex(je).multiply(Y(me)).toBytes(Ve);
        }
        const Z = Q.bits2int || function(me) {
            if (me.length > 8192) throw new Error("input is too large");
            const je = (0, r.bytesToNumberBE)(me), Ve = me.length * 8 - O;
            return Ve > 0 ? je >> BigInt(Ve) : je;
        }, ie = Q.bits2int_modN || function(me) {
            return w.create(Z(me));
        }, pe = (0, r.bitMask)(O);
        function ve(me) {
            return (0, r.aInRange)("num < 2^" + O, me, s, pe), w.toBytes(me);
        }
        function Ie(me, je, Ve = Me) {
            if ([
                "recovered",
                "canonical"
            ].some((ae)=>ae in Ve)) throw new Error("sign() legacy options not supported");
            const { hash: nt } = Q;
            let { lowS: We, prehash: Ge, extraEntropy: p } = Ve;
            We == null && (We = !0), me = (0, r.ensureBytes)("msgHash", me), o(Ve), Ge && (me = (0, r.ensureBytes)("prehashed msgHash", nt(me)));
            const A = ie(me), V = Y(je), re = [
                ve(V),
                ve(A)
            ];
            if (p != null && p !== !1) {
                const ae = p === !0 ? B(E.BYTES) : p;
                re.push((0, r.ensureBytes)("extraEntropy", ae));
            }
            const le = (0, r.concatBytes)(...re), L = A;
            function X(ae) {
                const D = Z(ae);
                if (!w.isValidNot0(D)) return;
                const H = w.inv(D), te = U.BASE.multiply(D).toAffine(), ge = w.create(te.x);
                if (ge === s) return;
                const ce = w.create(H * w.create(L + ge * V));
                if (ce === s) return;
                let Ue = (te.x === ge ? 0 : 2) | Number(te.y & c), qe = ce;
                return We && I(ce) && (qe = x(ce), Ue ^= 1), new j(ge, qe, Ue);
            }
            return {
                seed: le,
                k2sig: X
            };
        }
        const Me = {
            lowS: Q.lowS,
            prehash: !1
        }, Re = {
            lowS: Q.lowS,
            prehash: !1
        };
        function C(me, je, Ve = Me) {
            const { seed: nt, k2sig: We } = Ie(me, je, Ve);
            return (0, r.createHmacDrbg)(Q.hash.outputLen, w.BYTES, g)(nt, We);
        }
        U.BASE.precompute(8);
        function J(me, je, Ve, nt = Re) {
            const We = me;
            je = (0, r.ensureBytes)("msgHash", je), Ve = (0, r.ensureBytes)("publicKey", Ve), o(nt);
            const { lowS: Ge, prehash: p, format: A } = nt;
            if ("strict" in nt) throw new Error("options.strict was renamed to lowS");
            if (A !== void 0 && ![
                "compact",
                "der",
                "js"
            ].includes(A)) throw new Error('format must be "compact", "der" or "js"');
            const V = typeof We == "string" || (0, r.isBytes)(We), re = !V && !A && typeof We == "object" && We !== null && typeof We.r == "bigint" && typeof We.s == "bigint";
            if (!V && !re) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
            let le, L;
            try {
                if (re) if (A === void 0 || A === "js") le = new j(We.r, We.s);
                else throw new Error("invalid format");
                if (V) {
                    try {
                        A !== "compact" && (le = j.fromDER(We));
                    } catch (Ue) {
                        if (!(Ue instanceof e.DER.Err)) throw Ue;
                    }
                    !le && A !== "der" && (le = j.fromCompact(We));
                }
                L = U.fromHex(Ve);
            } catch  {
                return !1;
            }
            if (!le || Ge && le.hasHighS()) return !1;
            p && (je = Q.hash(je));
            const { r: X, s: ae } = le, D = ie(je), H = w.inv(ae), te = w.create(D * H), ge = w.create(X * H), ce = U.BASE.multiplyUnsafe(te).add(L.multiplyUnsafe(ge));
            return ce.is0() ? !1 : w.create(ce.x) === X;
        }
        return Object.freeze({
            getPublicKey: ue,
            getSharedSecret: se,
            sign: C,
            verify: J,
            utils: he,
            Point: U,
            Signature: j
        });
    }
    function N(U) {
        const Q = {
            a: U.a,
            b: U.b,
            p: U.Fp.ORDER,
            n: U.n,
            h: U.h,
            Gx: U.Gx,
            Gy: U.Gy
        }, v = U.Fp, B = (0, i1.Field)(Q.n, U.nBitLength), g = {
            Fp: v,
            Fn: B,
            allowedPrivateKeyLengths: U.allowedPrivateKeyLengths,
            allowInfinityPoint: U.allowInfinityPoint,
            endo: U.endo,
            wrapPrivateKey: U.wrapPrivateKey,
            isTorsionFree: U.isTorsionFree,
            clearCofactor: U.clearCofactor,
            fromBytes: U.fromBytes,
            toBytes: U.toBytes
        };
        return {
            CURVE: Q,
            curveOpts: g
        };
    }
    function z(U) {
        const { CURVE: Q, curveOpts: v } = N(U), B = {
            hash: U.hash,
            hmac: U.hmac,
            randomBytes: U.randomBytes,
            lowS: U.lowS,
            bits2int: U.bits2int,
            bits2int_modN: U.bits2int_modN
        };
        return {
            CURVE: Q,
            curveOpts: v,
            ecdsaOpts: B
        };
    }
    function K(U, Q) {
        const { Fp: v, Fn: B } = Q;
        function g(_) {
            return (0, r.inRange)(_, c, B.ORDER);
        }
        const E = h(v, U.a, U.b), w = y(B, U.allowedPrivateKeyLengths, U.wrapPrivateKey);
        return Object.assign({}, {
            CURVE: U,
            Point: Q,
            ProjectivePoint: Q,
            normPrivateKeyToScalar: w,
            weierstrassEquation: E,
            isWithinCurveOrder: g
        });
    }
    function $(U, Q) {
        return Object.assign({}, Q, {
            ProjectivePoint: Q.Point,
            CURVE: U
        });
    }
    function ne(U) {
        const { CURVE: Q, curveOpts: v, ecdsaOpts: B } = z(U), g = S(Q, v), E = M(g, B, v);
        return $(U, E);
    }
    function ee(U, Q) {
        const v = U.ORDER;
        let B = s;
        for(let he = v - c; he % l === s; he /= l)B += c;
        const g = B, E = l << g - c - c, w = E * l, _ = (v - c) / w, O = (_ - c) / l, I = w - c, x = E, R = U.pow(Q, _), j = U.pow(Q, (_ + c) / l);
        let Y = (he, ue)=>{
            let G = R, se = U.pow(ue, I), Z = U.sqr(se);
            Z = U.mul(Z, ue);
            let ie = U.mul(he, Z);
            ie = U.pow(ie, O), ie = U.mul(ie, se), se = U.mul(ie, ue), Z = U.mul(ie, he);
            let pe = U.mul(Z, se);
            ie = U.pow(pe, x);
            let ve = U.eql(ie, U.ONE);
            se = U.mul(Z, j), ie = U.mul(pe, G), Z = U.cmov(se, Z, ve), pe = U.cmov(ie, pe, ve);
            for(let Ie = g; Ie > c; Ie--){
                let Me = Ie - l;
                Me = l << Me - c;
                let Re = U.pow(pe, Me);
                const C = U.eql(Re, U.ONE);
                se = U.mul(Z, G), G = U.mul(G, G), Re = U.mul(pe, G), Z = U.cmov(se, Z, C), pe = U.cmov(Re, pe, C);
            }
            return {
                isValid: ve,
                value: Z
            };
        };
        if (U.ORDER % f === u) {
            const he = (U.ORDER - u) / f, ue = U.sqrt(U.neg(Q));
            Y = (G, se)=>{
                let Z = U.sqr(se);
                const ie = U.mul(G, se);
                Z = U.mul(Z, ie);
                let pe = U.pow(Z, he);
                pe = U.mul(pe, ie);
                const ve = U.mul(pe, ue), Ie = U.mul(U.sqr(pe), se), Me = U.eql(Ie, G);
                let Re = U.cmov(ve, pe, Me);
                return {
                    isValid: Me,
                    value: Re
                };
            };
        }
        return Y;
    }
    function q(U, Q) {
        (0, i1.validateField)(U);
        const { A: v, B, Z: g } = Q;
        if (!U.isValid(v) || !U.isValid(B) || !U.isValid(g)) throw new Error("mapToCurveSimpleSWU: invalid opts");
        const E = ee(U, g);
        if (!U.isOdd) throw new Error("Field does not have .isOdd()");
        return (w)=>{
            let _, O, I, x, R, j, Y, he;
            _ = U.sqr(w), _ = U.mul(_, g), O = U.sqr(_), O = U.add(O, _), I = U.add(O, U.ONE), I = U.mul(I, B), x = U.cmov(g, U.neg(O), !U.eql(O, U.ZERO)), x = U.mul(x, v), O = U.sqr(I), j = U.sqr(x), R = U.mul(j, v), O = U.add(O, R), O = U.mul(O, I), j = U.mul(j, x), R = U.mul(j, B), O = U.add(O, R), Y = U.mul(_, I);
            const { isValid: ue, value: G } = E(O, j);
            he = U.mul(_, w), he = U.mul(he, G), Y = U.cmov(Y, I, ue), he = U.cmov(he, G, ue);
            const se = U.isOdd(w) === U.isOdd(he);
            he = U.cmov(U.neg(he), he, se);
            const Z = (0, i1.FpInvertBatch)(U, [
                x
            ], !0)[0];
            return Y = U.mul(Y, Z), {
                x: Y,
                y: he
            };
        };
    }
})(P6);
Object.defineProperty(U2, "__esModule", {
    value: !0
});
U2.getHash = SX;
U2.createCurve = xX;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const EX = P6;
function SX(e) {
    return {
        hash: e
    };
}
function xX(e, t) {
    const r = (n)=>(0, EX.weierstrass)({
            ...e,
            hash: n
        });
    return {
        ...r(t),
        create: r
    };
}
var Pf = {};
Object.defineProperty(Pf, "__esModule", {
    value: !0
});
Pf.expand_message_xmd = $P;
Pf.expand_message_xof = ZP;
Pf.hash_to_field = P8;
Pf.isogenyMap = OX;
Pf.createHasher = IX;
const pi = Tf, QP = dn, _X = pi.bytesToNumberBE;
function Tc(e, t) {
    if (g0(e), g0(t), e < 0 || e >= 1 << 8 * t) throw new Error("invalid I2OSP input: " + e);
    const r = Array.from({
        length: t
    }).fill(0);
    for(let n = t - 1; n >= 0; n--)r[n] = e & 255, e >>>= 8;
    return new Uint8Array(r);
}
function kX(e, t) {
    const r = new Uint8Array(e.length);
    for(let n = 0; n < e.length; n++)r[n] = e[n] ^ t[n];
    return r;
}
function g0(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function $P(e, t, r, n) {
    (0, pi.abytes)(e), (0, pi.abytes)(t), g0(r), t.length > 255 && (t = n((0, pi.concatBytes)((0, pi.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i1, blockLen: o } = n, a = Math.ceil(r / i1);
    if (r > 65535 || a > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const s = (0, pi.concatBytes)(t, Tc(t.length, 1)), c = Tc(0, o), l = Tc(r, 2), u = new Array(a), f = n((0, pi.concatBytes)(c, e, l, Tc(0, 1), s));
    u[0] = n((0, pi.concatBytes)(f, Tc(1, 1), s));
    for(let h = 1; h <= a; h++){
        const y = [
            kX(f, u[h - 1]),
            Tc(h + 1, 1),
            s
        ];
        u[h] = n((0, pi.concatBytes)(...y));
    }
    return (0, pi.concatBytes)(...u).slice(0, r);
}
function ZP(e, t, r, n, i1) {
    if ((0, pi.abytes)(e), (0, pi.abytes)(t), g0(r), t.length > 255) {
        const o = Math.ceil(2 * n / 8);
        t = i1.create({
            dkLen: o
        }).update((0, pi.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (r > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i1.create({
        dkLen: r
    }).update(e).update(Tc(r, 2)).update(t).update(Tc(t.length, 1)).digest();
}
function P8(e, t, r) {
    (0, pi._validateObject)(r, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
    });
    const { p: n, k: i1, m: o, hash: a, expand: s, DST: c } = r;
    if (!(0, pi.isBytes)(c) && typeof c != "string") throw new Error("DST must be string or uint8array");
    if (!(0, pi.isHash)(r.hash)) throw new Error("expected valid hash");
    (0, pi.abytes)(e), g0(t);
    const l = typeof c == "string" ? (0, pi.utf8ToBytes)(c) : c, u = n.toString(2).length, f = Math.ceil((u + i1) / 8), h = t * o * f;
    let y;
    if (s === "xmd") y = $P(e, l, h, a);
    else if (s === "xof") y = ZP(e, l, h, i1, a);
    else if (s === "_internal_pass") y = e;
    else throw new Error('expand must be "xmd" or "xof"');
    const S = new Array(t);
    for(let k = 0; k < t; k++){
        const P = new Array(o);
        for(let M = 0; M < o; M++){
            const N = f * (M + k * o), z = y.subarray(N, N + f);
            P[M] = (0, QP.mod)(_X(z), n);
        }
        S[k] = P;
    }
    return S;
}
function OX(e, t) {
    const r = t.map((n)=>Array.from(n).reverse());
    return (n, i1)=>{
        const [o, a, s, c] = r.map((f)=>f.reduce((h, y)=>e.add(e.mul(h, n), y))), [l, u] = (0, QP.FpInvertBatch)(e, [
            a,
            c
        ], !0);
        return n = e.mul(o, l), i1 = e.mul(i1, e.mul(s, u)), {
            x: n,
            y: i1
        };
    };
}
function IX(e, t, r) {
    if (typeof t != "function") throw new Error("mapToCurve() must be defined");
    function n(o) {
        return e.fromAffine(t(o));
    }
    function i1(o) {
        const a = o.clearCofactor();
        return a.equals(e.ZERO) ? e.ZERO : (a.assertValidity(), a);
    }
    return {
        defaults: r,
        hashToCurve (o, a) {
            const s = r.DST ? r.DST : {}, c = Object.assign({}, r, s, a), l = P8(o, 2, c), u = n(l[0]), f = n(l[1]);
            return i1(u.add(f));
        },
        encodeToCurve (o, a) {
            const s = r.encodeDST ? r.encodeDST : {}, c = Object.assign({}, r, s, a), l = P8(o, 1, c);
            return i1(n(l[0]));
        },
        /** See {@link H2CHasher} */ mapToCurve (o) {
            if (!Array.isArray(o)) throw new Error("expected array of bigints");
            for (const a of o)if (typeof a != "bigint") throw new Error("expected array of bigints");
            return i1(n(o));
        }
    };
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.encodeToCurve = e.hashToCurve = e.secp256k1_hasher = e.schnorr = e.secp256k1 = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = an, r = Qr, n = U2, i1 = Pf, o = dn, a = P6, s = Tf, c = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    }, l = BigInt(0), u = BigInt(1), f = BigInt(2), h = (_, O)=>(_ + O / f) / O;
    function y(_) {
        const O = c.p, I = BigInt(3), x = BigInt(6), R = BigInt(11), j = BigInt(22), Y = BigInt(23), he = BigInt(44), ue = BigInt(88), G = _ * _ * _ % O, se = G * G * _ % O, Z = (0, o.pow2)(se, I, O) * se % O, ie = (0, o.pow2)(Z, I, O) * se % O, pe = (0, o.pow2)(ie, f, O) * G % O, ve = (0, o.pow2)(pe, R, O) * pe % O, Ie = (0, o.pow2)(ve, j, O) * ve % O, Me = (0, o.pow2)(Ie, he, O) * Ie % O, Re = (0, o.pow2)(Me, ue, O) * Me % O, C = (0, o.pow2)(Re, he, O) * Ie % O, J = (0, o.pow2)(C, I, O) * se % O, me = (0, o.pow2)(J, Y, O) * ve % O, je = (0, o.pow2)(me, x, O) * G % O, Ve = (0, o.pow2)(je, f, O);
        if (!S.eql(S.sqr(Ve), _)) throw new Error("Cannot find square root");
        return Ve;
    }
    const S = (0, o.Field)(c.p, void 0, void 0, {
        sqrt: y
    });
    e.secp256k1 = (0, n.createCurve)({
        ...c,
        Fp: S,
        lowS: !0,
        // Allow only low-S signatures by default in sign() and verify()
        endo: {
            // Endomorphism, see above
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: (_)=>{
                const O = c.n, I = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), x = -u * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), R = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), j = I, Y = BigInt("0x100000000000000000000000000000000"), he = h(j * _, O), ue = h(-x * _, O);
                let G = (0, o.mod)(_ - he * I - ue * R, O), se = (0, o.mod)(-he * x - ue * j, O);
                const Z = G > Y, ie = se > Y;
                if (Z && (G = O - G), ie && (se = O - se), G > Y || se > Y) throw new Error("splitScalar: Endomorphism failed, k=" + _);
                return {
                    k1neg: Z,
                    k1: G,
                    k2neg: ie,
                    k2: se
                };
            }
        }
    }, t.sha256);
    const k = {};
    function P(_, ...O) {
        let I = k[_];
        if (I === void 0) {
            const x = (0, t.sha256)(Uint8Array.from(_, (R)=>R.charCodeAt(0)));
            I = (0, s.concatBytes)(x, x), k[_] = I;
        }
        return (0, t.sha256)((0, s.concatBytes)(I, ...O));
    }
    const M = (_)=>_.toBytes(!0).slice(1), N = (_)=>(0, s.numberToBytesBE)(_, 32), z = (_)=>(0, o.mod)(_, c.p), K = (_)=>(0, o.mod)(_, c.n), $ = e.secp256k1.Point, ne = (_)=>_ % f === l;
    function ee(_) {
        let O = e.secp256k1.utils.normPrivateKeyToScalar(_), I = $.fromPrivateKey(O);
        return {
            scalar: ne(I.y) ? O : K(-O),
            bytes: M(I)
        };
    }
    function q(_) {
        (0, s.aInRange)("x", _, u, c.p);
        const O = z(_ * _), I = z(O * _ + BigInt(7));
        let x = y(I);
        ne(x) || (x = z(-x));
        const R = $.fromAffine({
            x: _,
            y: x
        });
        return R.assertValidity(), R;
    }
    const U = s.bytesToNumberBE;
    function Q(..._) {
        return K(U(P("BIP0340/challenge", ..._)));
    }
    function v(_) {
        return ee(_).bytes;
    }
    function B(_, O, I = (0, r.randomBytes)(32)) {
        const x = (0, s.ensureBytes)("message", _), { bytes: R, scalar: j } = ee(O), Y = (0, s.ensureBytes)("auxRand", I, 32), he = N(j ^ U(P("BIP0340/aux", Y))), ue = P("BIP0340/nonce", he, R, x), G = K(U(ue));
        if (G === l) throw new Error("sign failed: k is zero");
        const { bytes: se, scalar: Z } = ee(G), ie = Q(se, R, x), pe = new Uint8Array(64);
        if (pe.set(se, 0), pe.set(N(K(Z + ie * j)), 32), !g(pe, x, R)) throw new Error("sign: Invalid signature produced");
        return pe;
    }
    function g(_, O, I) {
        const x = (0, s.ensureBytes)("signature", _, 64), R = (0, s.ensureBytes)("message", O), j = (0, s.ensureBytes)("publicKey", I, 32);
        try {
            const Y = q(U(j)), he = U(x.subarray(0, 32));
            if (!(0, s.inRange)(he, u, c.p)) return !1;
            const ue = U(x.subarray(32, 64));
            if (!(0, s.inRange)(ue, u, c.n)) return !1;
            const G = Q(N(he), M(Y), R), se = $.BASE.multiplyUnsafe(ue).add(Y.multiplyUnsafe(K(-G))), { x: Z, y: ie } = se.toAffine();
            return !(se.is0() || !ne(ie) || Z !== he);
        } catch  {
            return !1;
        }
    }
    e.schnorr = {
        getPublicKey: v,
        sign: B,
        verify: g,
        utils: {
            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
            lift_x: q,
            pointToBytes: M,
            numberToBytesBE: s.numberToBytesBE,
            bytesToNumberBE: s.bytesToNumberBE,
            taggedHash: P,
            mod: o.mod
        }
    };
    const E = (0, i1.isogenyMap)(S, [
        // xNum
        [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        // yNum
        [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
    ].map((_)=>_.map((O)=>BigInt(O)))), w = (0, a.mapToCurveSimpleSWU)(S, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: S.create(BigInt("-11"))
    });
    e.secp256k1_hasher = (0, i1.createHasher)(e.secp256k1.Point, (_)=>{
        const { x: O, y: I } = w(S.create(_[0]));
        return E(O, I);
    }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: S.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: t.sha256
    }), e.hashToCurve = e.secp256k1_hasher.hashToCurve, e.encodeToCurve = e.secp256k1_hasher.encodeToCurve;
})(I6);
var XP = {};
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Tf, e);
})(XP);
var Ii = I6, BX = dn, TX = XP;
function YP(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
        if (r !== "default") {
            var n = Object.getOwnPropertyDescriptor(e, r);
            Object.defineProperty(t, r, n.get ? n : {
                enumerable: !0,
                get: function() {
                    return e[r];
                }
            });
        }
    }), t.default = e, Object.freeze(t);
}
var JP = /* @__PURE__ */ YP(BX), Xc = /* @__PURE__ */ YP(TX);
const D6 = Ii.secp256k1.ProjectivePoint, al = "Expected Private", sl = "Expected Point", g1 = "Expected Tweak", PX = "Expected Hash", Gp = "Expected Signature", j6 = "Expected Extra Data (32 bytes)", y1 = "Expected Scalar", CX = "Bad Recovery Id", MX = 32, NX = 32, C8 = new Uint8Array([
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    254,
    186,
    174,
    220,
    230,
    175,
    72,
    160,
    59,
    191,
    210,
    94,
    140,
    208,
    54,
    65,
    65
]), RX = 32, UX = new Uint8Array(32), DX = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    69,
    81,
    35,
    25,
    80,
    183,
    95,
    196,
    64,
    45,
    161,
    114,
    47,
    201,
    186,
    238
]), jX = BigInt(1);
function FX(e) {
    return e instanceof Uint8Array;
}
function y0(e, t) {
    for(let r = 0; r < 32; ++r)if (e[r] !== t[r]) return e[r] < t[r] ? -1 : 1;
    return 0;
}
function RS(e) {
    return y0(e, UX) === 0;
}
function m1(e) {
    return !(!(e instanceof Uint8Array) || e.length !== NX || y0(e, C8) >= 0);
}
function F6(e) {
    return e instanceof Uint8Array && e.length === 64 && y0(e.subarray(0, 32), C8) < 0 && y0(e.subarray(32, 64), C8) < 0;
}
function zX(e) {
    return FX(e) && e.length === 64 && y0(e.subarray(0, 32), DX) < 0;
}
function LX(e) {
    return !(RS(e.subarray(0, 32)) || RS(e.subarray(32, 64)));
}
function Nh(e) {
    return e instanceof Uint8Array && e.length === MX;
}
function z6(e) {
    return e === void 0 || e instanceof Uint8Array && e.length === RX;
}
function L6(e) {
    let t;
    if (typeof e == "bigint") t = e;
    else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0) t = BigInt(e);
    else if (typeof e == "string") {
        if (e.length !== 64) throw new Error("Expected 32 bytes of private scalar");
        t = Xc.hexToNumber(e);
    } else if (e instanceof Uint8Array) {
        if (e.length !== 32) throw new Error("Expected 32 bytes of private scalar");
        t = Xc.bytesToNumberBE(e);
    } else throw new TypeError("Expected valid private scalar");
    if (t < 0) throw new Error("Expected private scalar >= 0");
    return t;
}
function H6(e) {
    return Ii.secp256k1.utils.normPrivateKeyToScalar(e);
}
function HX(e, t) {
    const r = H6(e), n = L6(t), i1 = Xc.numberToBytesBE(JP.mod(r + n, Ii.secp256k1.CURVE.n), 32);
    return Ii.secp256k1.utils.isValidPrivateKey(i1) ? i1 : null;
}
function KX(e, t) {
    const r = H6(e), n = L6(t), i1 = Xc.numberToBytesBE(JP.mod(r - n, Ii.secp256k1.CURVE.n), 32);
    return Ii.secp256k1.utils.isValidPrivateKey(i1) ? i1 : null;
}
function qX(e) {
    const t = H6(e), r = Xc.numberToBytesBE(Ii.secp256k1.CURVE.n - t, 32);
    return Ii.secp256k1.utils.isValidPrivateKey(r) ? r : null;
}
function eC(e, t, r) {
    const n = m0(e), i1 = L6(t), o = D6.BASE.multiplyAndAddUnsafe(n, i1, jX);
    if (!o) throw new Error("Tweaked point at infinity");
    return o.toRawBytes(r);
}
function VX(e, t, r) {
    const n = m0(e), i1 = typeof t == "string" ? t : Xc.bytesToHex(t), o = Xc.hexToNumber(i1);
    return n.multiply(o).toRawBytes(r);
}
function Rh(e, t) {
    return e === void 0 ? t !== void 0 ? rC(t) : !0 : !!e;
}
function Cf(e) {
    try {
        return e();
    } catch  {
        return null;
    }
}
function tC(e) {
    return Ii.schnorr.utils.lift_x(Xc.bytesToNumberBE(e));
}
function m0(e) {
    return e.length === 32 ? tC(e) : D6.fromHex(e);
}
function K6(e, t) {
    if (e.length === 32 !== t) return !1;
    try {
        return t ? !!tC(e) : !!D6.fromHex(e);
    } catch  {
        return !1;
    }
}
function Yc(e) {
    return K6(e, !1);
}
function rC(e) {
    return K6(e, !1) && e.length === 33;
}
function Hu(e) {
    return Ii.secp256k1.utils.isValidPrivateKey(e);
}
function D2(e) {
    return K6(e, !0);
}
function WX(e, t) {
    if (!D2(e)) throw new Error(sl);
    if (!m1(t)) throw new Error(g1);
    return Cf(()=>{
        const r = eC(e, t, !0);
        return {
            parity: r[0] % 2 === 1 ? 1 : 0,
            xOnlyPubkey: r.slice(1)
        };
    });
}
function nC(e) {
    if (!Yc(e)) throw new Error(sl);
    return e.slice(1, 33);
}
function iC(e, t) {
    if (!Hu(e)) throw new Error(al);
    return Cf(()=>Ii.secp256k1.getPublicKey(e, Rh(t)));
}
function GX(e) {
    if (!Hu(e)) throw new Error(al);
    return nC(iC(e));
}
function QX(e, t) {
    if (!Yc(e)) throw new Error(sl);
    return m0(e).toRawBytes(Rh(t, e));
}
function $X(e, t, r) {
    if (!Yc(e)) throw new Error(sl);
    if (!m1(t)) throw new Error(g1);
    return Cf(()=>VX(e, t, Rh(r, e)));
}
function ZX(e, t, r) {
    if (!Yc(e) || !Yc(t)) throw new Error(sl);
    return Cf(()=>{
        const n = m0(e), i1 = m0(t);
        return n.equals(i1.negate()) ? null : n.add(i1).toRawBytes(Rh(r, e));
    });
}
function XX(e, t, r) {
    if (!Yc(e)) throw new Error(sl);
    if (!m1(t)) throw new Error(g1);
    return Cf(()=>eC(e, t, Rh(r, e)));
}
function YX(e, t) {
    if (!Hu(e)) throw new Error(al);
    if (!m1(t)) throw new Error(g1);
    return Cf(()=>HX(e, t));
}
function JX(e, t) {
    if (!Hu(e)) throw new Error(al);
    if (!m1(t)) throw new Error(g1);
    return Cf(()=>KX(e, t));
}
function eY(e) {
    if (!Hu(e)) throw new Error(al);
    return qX(e);
}
function tY(e, t, r) {
    if (!Hu(t)) throw new Error(al);
    if (!Nh(e)) throw new Error(y1);
    if (!z6(r)) throw new Error(j6);
    return Ii.secp256k1.sign(e, t, {
        extraEntropy: r
    }).toCompactRawBytes();
}
function rY(e, t, r) {
    if (!Hu(t)) throw new Error(al);
    if (!Nh(e)) throw new Error(y1);
    if (!z6(r)) throw new Error(j6);
    const n = Ii.secp256k1.sign(e, t, {
        extraEntropy: r
    });
    return {
        signature: n.toCompactRawBytes(),
        recoveryId: n.recovery
    };
}
function nY(e, t, r) {
    if (!Hu(t)) throw new Error(al);
    if (!Nh(e)) throw new Error(y1);
    if (!z6(r)) throw new Error(j6);
    return Ii.schnorr.sign(e, t, r);
}
function iY(e, t, r, n) {
    if (!Nh(e)) throw new Error(PX);
    if (!F6(t) || !LX(t)) throw new Error(Gp);
    if (r & 2 && !zX(t)) throw new Error(CX);
    if (!D2(t.subarray(0, 32))) throw new Error(Gp);
    const i1 = Ii.secp256k1.Signature.fromCompact(t).addRecoveryBit(r).recoverPublicKey(e);
    if (!i1) throw new Error(Gp);
    return i1.toRawBytes(Rh(n));
}
function oY(e, t, r, n) {
    if (!Yc(t)) throw new Error(sl);
    if (!F6(r)) throw new Error(Gp);
    if (!Nh(e)) throw new Error(y1);
    return Ii.secp256k1.verify(r, e, t, {
        lowS: n
    });
}
function aY(e, t, r) {
    if (!D2(t)) throw new Error(sl);
    if (!F6(r)) throw new Error(Gp);
    if (!Nh(e)) throw new Error(y1);
    return Ii.schnorr.verify(r, e, t);
}
var sY = Nn.isPoint = Yc, uY = Nn.isPointCompressed = rC, cY = Nn.isPrivate = Hu, lY = Nn.isXOnlyPoint = D2, fY = Nn.pointAdd = ZX, dY = Nn.pointAddScalar = XX, hY = Nn.pointCompress = QX, pY = Nn.pointFromScalar = iC, gY = Nn.pointMultiply = $X, yY = Nn.privateAdd = YX, mY = Nn.privateNegate = eY, bY = Nn.privateSub = JX, wY = Nn.recover = iY, AY = Nn.sign = tY, vY = Nn.signRecoverable = rY, EY = Nn.signSchnorr = nY, SY = Nn.verify = oY, xY = Nn.verifySchnorr = aY, _Y = Nn.xOnlyPointAddTweak = WX, kY = Nn.xOnlyPointFromPoint = nC, OY = Nn.xOnlyPointFromScalar = GX;
const j2 = /* @__PURE__ */ lW({
    __proto__: null,
    default: Nn,
    isPoint: sY,
    isPointCompressed: uY,
    isPrivate: cY,
    isXOnlyPoint: lY,
    pointAdd: fY,
    pointAddScalar: dY,
    pointCompress: hY,
    pointFromScalar: pY,
    pointMultiply: gY,
    privateAdd: yY,
    privateNegate: mY,
    privateSub: bY,
    recover: wY,
    sign: AY,
    signRecoverable: vY,
    signSchnorr: EY,
    verify: SY,
    verifySchnorr: xY,
    xOnlyPointAddTweak: _Y,
    xOnlyPointFromPoint: kY,
    xOnlyPointFromScalar: OY
}, [
    Nn
]);
var ta = {}, fh = {}, ro = {}, Uh = {};
Uh.byteLength = TY;
Uh.toByteArray = CY;
Uh.fromByteArray = RY;
var Hs = [], Ea = [], IY = typeof Uint8Array < "u" ? Uint8Array : Array, xA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var ld = 0, BY = xA.length; ld < BY; ++ld)Hs[ld] = xA[ld], Ea[xA.charCodeAt(ld)] = ld;
Ea[45] = 62;
Ea[95] = 63;
function oC(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    r === -1 && (r = t);
    var n = r === t ? 0 : 4 - r % 4;
    return [
        r,
        n
    ];
}
function TY(e) {
    var t = oC(e), r = t[0], n = t[1];
    return (r + n) * 3 / 4 - n;
}
function PY(e, t, r) {
    return (t + r) * 3 / 4 - r;
}
function CY(e) {
    var t, r = oC(e), n = r[0], i1 = r[1], o = new IY(PY(e, n, i1)), a = 0, s = i1 > 0 ? n - 4 : n, c;
    for(c = 0; c < s; c += 4)t = Ea[e.charCodeAt(c)] << 18 | Ea[e.charCodeAt(c + 1)] << 12 | Ea[e.charCodeAt(c + 2)] << 6 | Ea[e.charCodeAt(c + 3)], o[a++] = t >> 16 & 255, o[a++] = t >> 8 & 255, o[a++] = t & 255;
    return i1 === 2 && (t = Ea[e.charCodeAt(c)] << 2 | Ea[e.charCodeAt(c + 1)] >> 4, o[a++] = t & 255), i1 === 1 && (t = Ea[e.charCodeAt(c)] << 10 | Ea[e.charCodeAt(c + 1)] << 4 | Ea[e.charCodeAt(c + 2)] >> 2, o[a++] = t >> 8 & 255, o[a++] = t & 255), o;
}
function MY(e) {
    return Hs[e >> 18 & 63] + Hs[e >> 12 & 63] + Hs[e >> 6 & 63] + Hs[e & 63];
}
function NY(e, t, r) {
    for(var n, i1 = [], o = t; o < r; o += 3)n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i1.push(MY(n));
    return i1.join("");
}
function RY(e) {
    for(var t, r = e.length, n = r % 3, i1 = [], o = 16383, a = 0, s = r - n; a < s; a += o)i1.push(NY(e, a, a + o > s ? s : a + o));
    return n === 1 ? (t = e[r - 1], i1.push(Hs[t >> 2] + Hs[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i1.push(Hs[t >> 10] + Hs[t >> 4 & 63] + Hs[t << 2 & 63] + "=")), i1.join("");
}
Object.defineProperty(ro, "__esModule", {
    value: !0
});
ro.decode = ro.encode = ro.unescape = ro.escape = ro.pad = void 0;
const aC = Uh;
function q6(e) {
    return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
ro.pad = q6;
function sC(e) {
    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
ro.escape = sC;
function uC(e) {
    return q6(e).replace(/-/g, "+").replace(/_/g, "/");
}
ro.unescape = uC;
function UY(e) {
    return sC((0, aC.fromByteArray)(new TextEncoder().encode(e)));
}
ro.encode = UY;
function DY(e) {
    return new TextDecoder().decode((0, aC.toByteArray)(q6(uC(e))));
}
ro.decode = DY;
var F2 = {}, z2 = {}, Ba = {};
Object.defineProperty(Ba, "__esModule", {
    value: !0
});
Ba.sha224 = Ba.SHA224 = Ba.sha256 = Ba.SHA256 = void 0;
const L2 = an;
Ba.SHA256 = L2.SHA256;
Ba.sha256 = L2.sha256;
Ba.SHA224 = L2.SHA224;
Ba.sha224 = L2.sha224;
var cC = {}, Ar = {}, Zg = {
    exports: {}
}, _A = {
    exports: {}
}, ul = {}, V6 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ V6.read = function(e, t, r, n, i1) {
    var o, a, s = i1 * 8 - n - 1, c = (1 << s) - 1, l = c >> 1, u = -7, f = r ? i1 - 1 : 0, h = r ? -1 : 1, y = e[t + f];
    for(f += h, o = y & (1 << -u) - 1, y >>= -u, u += s; u > 0; o = o * 256 + e[t + f], f += h, u -= 8);
    for(a = o & (1 << -u) - 1, o >>= -u, u += n; u > 0; a = a * 256 + e[t + f], f += h, u -= 8);
    if (o === 0) o = 1 - l;
    else {
        if (o === c) return a ? NaN : (y ? -1 : 1) * (1 / 0);
        a = a + Math.pow(2, n), o = o - l;
    }
    return (y ? -1 : 1) * a * Math.pow(2, o - n);
};
V6.write = function(e, t, r, n, i1, o) {
    var a, s, c, l = o * 8 - i1 - 1, u = (1 << l) - 1, f = u >> 1, h = i1 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, S = n ? 1 : -1, k = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), a + f >= 1 ? t += h / c : t += h * Math.pow(2, 1 - f), t * c >= 2 && (a++, c /= 2), a + f >= u ? (s = 0, a = u) : a + f >= 1 ? (s = (t * c - 1) * Math.pow(2, i1), a = a + f) : (s = t * Math.pow(2, f - 1) * Math.pow(2, i1), a = 0)); i1 >= 8; e[r + y] = s & 255, y += S, s /= 256, i1 -= 8);
    for(a = a << i1 | s, l += i1; l > 0; e[r + y] = a & 255, y += S, a /= 256, l -= 8);
    e[r + y - S] |= k * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(e) {
    const t = Uh, r = V6, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = s, e.SlowBuffer = N, e.INSPECT_MAX_BYTES = 50;
    const i1 = 2147483647;
    e.kMaxLength = i1, s.TYPED_ARRAY_SUPPORT = o(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function o() {
        try {
            const L = new Uint8Array(1), X = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(X, Uint8Array.prototype), Object.setPrototypeOf(L, X), L.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(s.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (s.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(s.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (s.isBuffer(this)) return this.byteOffset;
        }
    });
    function a(L) {
        if (L > i1) throw new RangeError('The value "' + L + '" is invalid for option "size"');
        const X = new Uint8Array(L);
        return Object.setPrototypeOf(X, s.prototype), X;
    }
    function s(L, X, ae) {
        if (typeof L == "number") {
            if (typeof X == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return f(L);
        }
        return c(L, X, ae);
    }
    s.poolSize = 8192;
    function c(L, X, ae) {
        if (typeof L == "string") return h(L, X);
        if (ArrayBuffer.isView(L)) return S(L);
        if (L == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof L);
        if (p(L, ArrayBuffer) || L && p(L.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (p(L, SharedArrayBuffer) || L && p(L.buffer, SharedArrayBuffer))) return k(L, X, ae);
        if (typeof L == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const D = L.valueOf && L.valueOf();
        if (D != null && D !== L) return s.from(D, X, ae);
        const H = P(L);
        if (H) return H;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof L[Symbol.toPrimitive] == "function") return s.from(L[Symbol.toPrimitive]("string"), X, ae);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof L);
    }
    s.from = function(L, X, ae) {
        return c(L, X, ae);
    }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
    function l(L) {
        if (typeof L != "number") throw new TypeError('"size" argument must be of type number');
        if (L < 0) throw new RangeError('The value "' + L + '" is invalid for option "size"');
    }
    function u(L, X, ae) {
        return l(L), L <= 0 ? a(L) : X !== void 0 ? typeof ae == "string" ? a(L).fill(X, ae) : a(L).fill(X) : a(L);
    }
    s.alloc = function(L, X, ae) {
        return u(L, X, ae);
    };
    function f(L) {
        return l(L), a(L < 0 ? 0 : M(L) | 0);
    }
    s.allocUnsafe = function(L) {
        return f(L);
    }, s.allocUnsafeSlow = function(L) {
        return f(L);
    };
    function h(L, X) {
        if ((typeof X != "string" || X === "") && (X = "utf8"), !s.isEncoding(X)) throw new TypeError("Unknown encoding: " + X);
        const ae = z(L, X) | 0;
        let D = a(ae);
        const H = D.write(L, X);
        return H !== ae && (D = D.slice(0, H)), D;
    }
    function y(L) {
        const X = L.length < 0 ? 0 : M(L.length) | 0, ae = a(X);
        for(let D = 0; D < X; D += 1)ae[D] = L[D] & 255;
        return ae;
    }
    function S(L) {
        if (p(L, Uint8Array)) {
            const X = new Uint8Array(L);
            return k(X.buffer, X.byteOffset, X.byteLength);
        }
        return y(L);
    }
    function k(L, X, ae) {
        if (X < 0 || L.byteLength < X) throw new RangeError('"offset" is outside of buffer bounds');
        if (L.byteLength < X + (ae || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let D;
        return X === void 0 && ae === void 0 ? D = new Uint8Array(L) : ae === void 0 ? D = new Uint8Array(L, X) : D = new Uint8Array(L, X, ae), Object.setPrototypeOf(D, s.prototype), D;
    }
    function P(L) {
        if (s.isBuffer(L)) {
            const X = M(L.length) | 0, ae = a(X);
            return ae.length === 0 || L.copy(ae, 0, 0, X), ae;
        }
        if (L.length !== void 0) return typeof L.length != "number" || A(L.length) ? a(0) : y(L);
        if (L.type === "Buffer" && Array.isArray(L.data)) return y(L.data);
    }
    function M(L) {
        if (L >= i1) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i1.toString(16) + " bytes");
        return L | 0;
    }
    function N(L) {
        return +L != L && (L = 0), s.alloc(+L);
    }
    s.isBuffer = function(L) {
        return L != null && L._isBuffer === !0 && L !== s.prototype;
    }, s.compare = function(L, X) {
        if (p(L, Uint8Array) && (L = s.from(L, L.offset, L.byteLength)), p(X, Uint8Array) && (X = s.from(X, X.offset, X.byteLength)), !s.isBuffer(L) || !s.isBuffer(X)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (L === X) return 0;
        let ae = L.length, D = X.length;
        for(let H = 0, te = Math.min(ae, D); H < te; ++H)if (L[H] !== X[H]) {
            ae = L[H], D = X[H];
            break;
        }
        return ae < D ? -1 : D < ae ? 1 : 0;
    }, s.isEncoding = function(L) {
        switch(String(L).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, s.concat = function(L, X) {
        if (!Array.isArray(L)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (L.length === 0) return s.alloc(0);
        let ae;
        if (X === void 0) for(X = 0, ae = 0; ae < L.length; ++ae)X += L[ae].length;
        const D = s.allocUnsafe(X);
        let H = 0;
        for(ae = 0; ae < L.length; ++ae){
            let te = L[ae];
            if (p(te, Uint8Array)) H + te.length > D.length ? (s.isBuffer(te) || (te = s.from(te)), te.copy(D, H)) : Uint8Array.prototype.set.call(D, te, H);
            else if (s.isBuffer(te)) te.copy(D, H);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            H += te.length;
        }
        return D;
    };
    function z(L, X) {
        if (s.isBuffer(L)) return L.length;
        if (ArrayBuffer.isView(L) || p(L, ArrayBuffer)) return L.byteLength;
        if (typeof L != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof L);
        const ae = L.length, D = arguments.length > 2 && arguments[2] === !0;
        if (!D && ae === 0) return 0;
        let H = !1;
        for(;;)switch(X){
            case "ascii":
            case "latin1":
            case "binary":
                return ae;
            case "utf8":
            case "utf-8":
                return je(L).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ae * 2;
            case "hex":
                return ae >>> 1;
            case "base64":
                return We(L).length;
            default:
                if (H) return D ? -1 : je(L).length;
                X = ("" + X).toLowerCase(), H = !0;
        }
    }
    s.byteLength = z;
    function K(L, X, ae) {
        let D = !1;
        if ((X === void 0 || X < 0) && (X = 0), X > this.length || ((ae === void 0 || ae > this.length) && (ae = this.length), ae <= 0) || (ae >>>= 0, X >>>= 0, ae <= X)) return "";
        for(L || (L = "utf8");;)switch(L){
            case "hex":
                return x(this, X, ae);
            case "utf8":
            case "utf-8":
                return E(this, X, ae);
            case "ascii":
                return O(this, X, ae);
            case "latin1":
            case "binary":
                return I(this, X, ae);
            case "base64":
                return g(this, X, ae);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return R(this, X, ae);
            default:
                if (D) throw new TypeError("Unknown encoding: " + L);
                L = (L + "").toLowerCase(), D = !0;
        }
    }
    s.prototype._isBuffer = !0;
    function $(L, X, ae) {
        const D = L[X];
        L[X] = L[ae], L[ae] = D;
    }
    s.prototype.swap16 = function() {
        const L = this.length;
        if (L % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let X = 0; X < L; X += 2)$(this, X, X + 1);
        return this;
    }, s.prototype.swap32 = function() {
        const L = this.length;
        if (L % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let X = 0; X < L; X += 4)$(this, X, X + 3), $(this, X + 1, X + 2);
        return this;
    }, s.prototype.swap64 = function() {
        const L = this.length;
        if (L % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let X = 0; X < L; X += 8)$(this, X, X + 7), $(this, X + 1, X + 6), $(this, X + 2, X + 5), $(this, X + 3, X + 4);
        return this;
    }, s.prototype.toString = function() {
        const L = this.length;
        return L === 0 ? "" : arguments.length === 0 ? E(this, 0, L) : K.apply(this, arguments);
    }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(L) {
        if (!s.isBuffer(L)) throw new TypeError("Argument must be a Buffer");
        return this === L ? !0 : s.compare(this, L) === 0;
    }, s.prototype.inspect = function() {
        let L = "";
        const X = e.INSPECT_MAX_BYTES;
        return L = this.toString("hex", 0, X).replace(/(.{2})/g, "$1 ").trim(), this.length > X && (L += " ... "), "<Buffer " + L + ">";
    }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(L, X, ae, D, H) {
        if (p(L, Uint8Array) && (L = s.from(L, L.offset, L.byteLength)), !s.isBuffer(L)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof L);
        if (X === void 0 && (X = 0), ae === void 0 && (ae = L ? L.length : 0), D === void 0 && (D = 0), H === void 0 && (H = this.length), X < 0 || ae > L.length || D < 0 || H > this.length) throw new RangeError("out of range index");
        if (D >= H && X >= ae) return 0;
        if (D >= H) return -1;
        if (X >= ae) return 1;
        if (X >>>= 0, ae >>>= 0, D >>>= 0, H >>>= 0, this === L) return 0;
        let te = H - D, ge = ae - X;
        const ce = Math.min(te, ge), Ue = this.slice(D, H), qe = L.slice(X, ae);
        for(let ot = 0; ot < ce; ++ot)if (Ue[ot] !== qe[ot]) {
            te = Ue[ot], ge = qe[ot];
            break;
        }
        return te < ge ? -1 : ge < te ? 1 : 0;
    };
    function ne(L, X, ae, D, H) {
        if (L.length === 0) return -1;
        if (typeof ae == "string" ? (D = ae, ae = 0) : ae > 2147483647 ? ae = 2147483647 : ae < -2147483648 && (ae = -2147483648), ae = +ae, A(ae) && (ae = H ? 0 : L.length - 1), ae < 0 && (ae = L.length + ae), ae >= L.length) {
            if (H) return -1;
            ae = L.length - 1;
        } else if (ae < 0) if (H) ae = 0;
        else return -1;
        if (typeof X == "string" && (X = s.from(X, D)), s.isBuffer(X)) return X.length === 0 ? -1 : ee(L, X, ae, D, H);
        if (typeof X == "number") return X = X & 255, typeof Uint8Array.prototype.indexOf == "function" ? H ? Uint8Array.prototype.indexOf.call(L, X, ae) : Uint8Array.prototype.lastIndexOf.call(L, X, ae) : ee(L, [
            X
        ], ae, D, H);
        throw new TypeError("val must be string, number or Buffer");
    }
    function ee(L, X, ae, D, H) {
        let te = 1, ge = L.length, ce = X.length;
        if (D !== void 0 && (D = String(D).toLowerCase(), D === "ucs2" || D === "ucs-2" || D === "utf16le" || D === "utf-16le")) {
            if (L.length < 2 || X.length < 2) return -1;
            te = 2, ge /= 2, ce /= 2, ae /= 2;
        }
        function Ue(ot, yt) {
            return te === 1 ? ot[yt] : ot.readUInt16BE(yt * te);
        }
        let qe;
        if (H) {
            let ot = -1;
            for(qe = ae; qe < ge; qe++)if (Ue(L, qe) === Ue(X, ot === -1 ? 0 : qe - ot)) {
                if (ot === -1 && (ot = qe), qe - ot + 1 === ce) return ot * te;
            } else ot !== -1 && (qe -= qe - ot), ot = -1;
        } else for(ae + ce > ge && (ae = ge - ce), qe = ae; qe >= 0; qe--){
            let ot = !0;
            for(let yt = 0; yt < ce; yt++)if (Ue(L, qe + yt) !== Ue(X, yt)) {
                ot = !1;
                break;
            }
            if (ot) return qe;
        }
        return -1;
    }
    s.prototype.includes = function(L, X, ae) {
        return this.indexOf(L, X, ae) !== -1;
    }, s.prototype.indexOf = function(L, X, ae) {
        return ne(this, L, X, ae, !0);
    }, s.prototype.lastIndexOf = function(L, X, ae) {
        return ne(this, L, X, ae, !1);
    };
    function q(L, X, ae, D) {
        ae = Number(ae) || 0;
        const H = L.length - ae;
        D ? (D = Number(D), D > H && (D = H)) : D = H;
        const te = X.length;
        D > te / 2 && (D = te / 2);
        let ge;
        for(ge = 0; ge < D; ++ge){
            const ce = parseInt(X.substr(ge * 2, 2), 16);
            if (A(ce)) return ge;
            L[ae + ge] = ce;
        }
        return ge;
    }
    function U(L, X, ae, D) {
        return Ge(je(X, L.length - ae), L, ae, D);
    }
    function Q(L, X, ae, D) {
        return Ge(Ve(X), L, ae, D);
    }
    function v(L, X, ae, D) {
        return Ge(We(X), L, ae, D);
    }
    function B(L, X, ae, D) {
        return Ge(nt(X, L.length - ae), L, ae, D);
    }
    s.prototype.write = function(L, X, ae, D) {
        if (X === void 0) D = "utf8", ae = this.length, X = 0;
        else if (ae === void 0 && typeof X == "string") D = X, ae = this.length, X = 0;
        else if (isFinite(X)) X = X >>> 0, isFinite(ae) ? (ae = ae >>> 0, D === void 0 && (D = "utf8")) : (D = ae, ae = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const H = this.length - X;
        if ((ae === void 0 || ae > H) && (ae = H), L.length > 0 && (ae < 0 || X < 0) || X > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        D || (D = "utf8");
        let te = !1;
        for(;;)switch(D){
            case "hex":
                return q(this, L, X, ae);
            case "utf8":
            case "utf-8":
                return U(this, L, X, ae);
            case "ascii":
            case "latin1":
            case "binary":
                return Q(this, L, X, ae);
            case "base64":
                return v(this, L, X, ae);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return B(this, L, X, ae);
            default:
                if (te) throw new TypeError("Unknown encoding: " + D);
                D = ("" + D).toLowerCase(), te = !0;
        }
    }, s.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function g(L, X, ae) {
        return X === 0 && ae === L.length ? t.fromByteArray(L) : t.fromByteArray(L.slice(X, ae));
    }
    function E(L, X, ae) {
        ae = Math.min(L.length, ae);
        const D = [];
        let H = X;
        for(; H < ae;){
            const te = L[H];
            let ge = null, ce = te > 239 ? 4 : te > 223 ? 3 : te > 191 ? 2 : 1;
            if (H + ce <= ae) {
                let Ue, qe, ot, yt;
                switch(ce){
                    case 1:
                        te < 128 && (ge = te);
                        break;
                    case 2:
                        Ue = L[H + 1], (Ue & 192) === 128 && (yt = (te & 31) << 6 | Ue & 63, yt > 127 && (ge = yt));
                        break;
                    case 3:
                        Ue = L[H + 1], qe = L[H + 2], (Ue & 192) === 128 && (qe & 192) === 128 && (yt = (te & 15) << 12 | (Ue & 63) << 6 | qe & 63, yt > 2047 && (yt < 55296 || yt > 57343) && (ge = yt));
                        break;
                    case 4:
                        Ue = L[H + 1], qe = L[H + 2], ot = L[H + 3], (Ue & 192) === 128 && (qe & 192) === 128 && (ot & 192) === 128 && (yt = (te & 15) << 18 | (Ue & 63) << 12 | (qe & 63) << 6 | ot & 63, yt > 65535 && yt < 1114112 && (ge = yt));
                }
            }
            ge === null ? (ge = 65533, ce = 1) : ge > 65535 && (ge -= 65536, D.push(ge >>> 10 & 1023 | 55296), ge = 56320 | ge & 1023), D.push(ge), H += ce;
        }
        return _(D);
    }
    const w = 4096;
    function _(L) {
        const X = L.length;
        if (X <= w) return String.fromCharCode.apply(String, L);
        let ae = "", D = 0;
        for(; D < X;)ae += String.fromCharCode.apply(String, L.slice(D, D += w));
        return ae;
    }
    function O(L, X, ae) {
        let D = "";
        ae = Math.min(L.length, ae);
        for(let H = X; H < ae; ++H)D += String.fromCharCode(L[H] & 127);
        return D;
    }
    function I(L, X, ae) {
        let D = "";
        ae = Math.min(L.length, ae);
        for(let H = X; H < ae; ++H)D += String.fromCharCode(L[H]);
        return D;
    }
    function x(L, X, ae) {
        const D = L.length;
        (!X || X < 0) && (X = 0), (!ae || ae < 0 || ae > D) && (ae = D);
        let H = "";
        for(let te = X; te < ae; ++te)H += V[L[te]];
        return H;
    }
    function R(L, X, ae) {
        const D = L.slice(X, ae);
        let H = "";
        for(let te = 0; te < D.length - 1; te += 2)H += String.fromCharCode(D[te] + D[te + 1] * 256);
        return H;
    }
    s.prototype.slice = function(L, X) {
        const ae = this.length;
        L = ~~L, X = X === void 0 ? ae : ~~X, L < 0 ? (L += ae, L < 0 && (L = 0)) : L > ae && (L = ae), X < 0 ? (X += ae, X < 0 && (X = 0)) : X > ae && (X = ae), X < L && (X = L);
        const D = this.subarray(L, X);
        return Object.setPrototypeOf(D, s.prototype), D;
    };
    function j(L, X, ae) {
        if (L % 1 !== 0 || L < 0) throw new RangeError("offset is not uint");
        if (L + X > ae) throw new RangeError("Trying to access beyond buffer length");
    }
    s.prototype.readUintLE = s.prototype.readUIntLE = function(L, X, ae) {
        L = L >>> 0, X = X >>> 0, ae || j(L, X, this.length);
        let D = this[L], H = 1, te = 0;
        for(; ++te < X && (H *= 256);)D += this[L + te] * H;
        return D;
    }, s.prototype.readUintBE = s.prototype.readUIntBE = function(L, X, ae) {
        L = L >>> 0, X = X >>> 0, ae || j(L, X, this.length);
        let D = this[L + --X], H = 1;
        for(; X > 0 && (H *= 256);)D += this[L + --X] * H;
        return D;
    }, s.prototype.readUint8 = s.prototype.readUInt8 = function(L, X) {
        return L = L >>> 0, X || j(L, 1, this.length), this[L];
    }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(L, X) {
        return L = L >>> 0, X || j(L, 2, this.length), this[L] | this[L + 1] << 8;
    }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(L, X) {
        return L = L >>> 0, X || j(L, 2, this.length), this[L] << 8 | this[L + 1];
    }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(L, X) {
        return L = L >>> 0, X || j(L, 4, this.length), (this[L] | this[L + 1] << 8 | this[L + 2] << 16) + this[L + 3] * 16777216;
    }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(L, X) {
        return L = L >>> 0, X || j(L, 4, this.length), this[L] * 16777216 + (this[L + 1] << 16 | this[L + 2] << 8 | this[L + 3]);
    }, s.prototype.readBigUInt64LE = re(function(L) {
        L = L >>> 0, Re(L, "offset");
        const X = this[L], ae = this[L + 7];
        (X === void 0 || ae === void 0) && C(L, this.length - 8);
        const D = X + this[++L] * 2 ** 8 + this[++L] * 2 ** 16 + this[++L] * 2 ** 24, H = this[++L] + this[++L] * 2 ** 8 + this[++L] * 2 ** 16 + ae * 2 ** 24;
        return BigInt(D) + (BigInt(H) << BigInt(32));
    }), s.prototype.readBigUInt64BE = re(function(L) {
        L = L >>> 0, Re(L, "offset");
        const X = this[L], ae = this[L + 7];
        (X === void 0 || ae === void 0) && C(L, this.length - 8);
        const D = X * 2 ** 24 + this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + this[++L], H = this[++L] * 2 ** 24 + this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + ae;
        return (BigInt(D) << BigInt(32)) + BigInt(H);
    }), s.prototype.readIntLE = function(L, X, ae) {
        L = L >>> 0, X = X >>> 0, ae || j(L, X, this.length);
        let D = this[L], H = 1, te = 0;
        for(; ++te < X && (H *= 256);)D += this[L + te] * H;
        return H *= 128, D >= H && (D -= Math.pow(2, 8 * X)), D;
    }, s.prototype.readIntBE = function(L, X, ae) {
        L = L >>> 0, X = X >>> 0, ae || j(L, X, this.length);
        let D = X, H = 1, te = this[L + --D];
        for(; D > 0 && (H *= 256);)te += this[L + --D] * H;
        return H *= 128, te >= H && (te -= Math.pow(2, 8 * X)), te;
    }, s.prototype.readInt8 = function(L, X) {
        return L = L >>> 0, X || j(L, 1, this.length), this[L] & 128 ? (255 - this[L] + 1) * -1 : this[L];
    }, s.prototype.readInt16LE = function(L, X) {
        L = L >>> 0, X || j(L, 2, this.length);
        const ae = this[L] | this[L + 1] << 8;
        return ae & 32768 ? ae | 4294901760 : ae;
    }, s.prototype.readInt16BE = function(L, X) {
        L = L >>> 0, X || j(L, 2, this.length);
        const ae = this[L + 1] | this[L] << 8;
        return ae & 32768 ? ae | 4294901760 : ae;
    }, s.prototype.readInt32LE = function(L, X) {
        return L = L >>> 0, X || j(L, 4, this.length), this[L] | this[L + 1] << 8 | this[L + 2] << 16 | this[L + 3] << 24;
    }, s.prototype.readInt32BE = function(L, X) {
        return L = L >>> 0, X || j(L, 4, this.length), this[L] << 24 | this[L + 1] << 16 | this[L + 2] << 8 | this[L + 3];
    }, s.prototype.readBigInt64LE = re(function(L) {
        L = L >>> 0, Re(L, "offset");
        const X = this[L], ae = this[L + 7];
        (X === void 0 || ae === void 0) && C(L, this.length - 8);
        const D = this[L + 4] + this[L + 5] * 2 ** 8 + this[L + 6] * 2 ** 16 + (ae << 24);
        return (BigInt(D) << BigInt(32)) + BigInt(X + this[++L] * 2 ** 8 + this[++L] * 2 ** 16 + this[++L] * 2 ** 24);
    }), s.prototype.readBigInt64BE = re(function(L) {
        L = L >>> 0, Re(L, "offset");
        const X = this[L], ae = this[L + 7];
        (X === void 0 || ae === void 0) && C(L, this.length - 8);
        const D = (X << 24) + // Overflow
        this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + this[++L];
        return (BigInt(D) << BigInt(32)) + BigInt(this[++L] * 2 ** 24 + this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + ae);
    }), s.prototype.readFloatLE = function(L, X) {
        return L = L >>> 0, X || j(L, 4, this.length), r.read(this, L, !0, 23, 4);
    }, s.prototype.readFloatBE = function(L, X) {
        return L = L >>> 0, X || j(L, 4, this.length), r.read(this, L, !1, 23, 4);
    }, s.prototype.readDoubleLE = function(L, X) {
        return L = L >>> 0, X || j(L, 8, this.length), r.read(this, L, !0, 52, 8);
    }, s.prototype.readDoubleBE = function(L, X) {
        return L = L >>> 0, X || j(L, 8, this.length), r.read(this, L, !1, 52, 8);
    };
    function Y(L, X, ae, D, H, te) {
        if (!s.isBuffer(L)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (X > H || X < te) throw new RangeError('"value" argument is out of bounds');
        if (ae + D > L.length) throw new RangeError("Index out of range");
    }
    s.prototype.writeUintLE = s.prototype.writeUIntLE = function(L, X, ae, D) {
        if (L = +L, X = X >>> 0, ae = ae >>> 0, !D) {
            const ge = Math.pow(2, 8 * ae) - 1;
            Y(this, L, X, ae, ge, 0);
        }
        let H = 1, te = 0;
        for(this[X] = L & 255; ++te < ae && (H *= 256);)this[X + te] = L / H & 255;
        return X + ae;
    }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(L, X, ae, D) {
        if (L = +L, X = X >>> 0, ae = ae >>> 0, !D) {
            const ge = Math.pow(2, 8 * ae) - 1;
            Y(this, L, X, ae, ge, 0);
        }
        let H = ae - 1, te = 1;
        for(this[X + H] = L & 255; --H >= 0 && (te *= 256);)this[X + H] = L / te & 255;
        return X + ae;
    }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 1, 255, 0), this[X] = L & 255, X + 1;
    }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 2, 65535, 0), this[X] = L & 255, this[X + 1] = L >>> 8, X + 2;
    }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 2, 65535, 0), this[X] = L >>> 8, this[X + 1] = L & 255, X + 2;
    }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 4, 4294967295, 0), this[X + 3] = L >>> 24, this[X + 2] = L >>> 16, this[X + 1] = L >>> 8, this[X] = L & 255, X + 4;
    }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 4, 4294967295, 0), this[X] = L >>> 24, this[X + 1] = L >>> 16, this[X + 2] = L >>> 8, this[X + 3] = L & 255, X + 4;
    };
    function he(L, X, ae, D, H) {
        Me(X, D, H, L, ae, 7);
        let te = Number(X & BigInt(4294967295));
        L[ae++] = te, te = te >> 8, L[ae++] = te, te = te >> 8, L[ae++] = te, te = te >> 8, L[ae++] = te;
        let ge = Number(X >> BigInt(32) & BigInt(4294967295));
        return L[ae++] = ge, ge = ge >> 8, L[ae++] = ge, ge = ge >> 8, L[ae++] = ge, ge = ge >> 8, L[ae++] = ge, ae;
    }
    function ue(L, X, ae, D, H) {
        Me(X, D, H, L, ae, 7);
        let te = Number(X & BigInt(4294967295));
        L[ae + 7] = te, te = te >> 8, L[ae + 6] = te, te = te >> 8, L[ae + 5] = te, te = te >> 8, L[ae + 4] = te;
        let ge = Number(X >> BigInt(32) & BigInt(4294967295));
        return L[ae + 3] = ge, ge = ge >> 8, L[ae + 2] = ge, ge = ge >> 8, L[ae + 1] = ge, ge = ge >> 8, L[ae] = ge, ae + 8;
    }
    s.prototype.writeBigUInt64LE = re(function(L, X = 0) {
        return he(this, L, X, BigInt(0), BigInt("0xffffffffffffffff"));
    }), s.prototype.writeBigUInt64BE = re(function(L, X = 0) {
        return ue(this, L, X, BigInt(0), BigInt("0xffffffffffffffff"));
    }), s.prototype.writeIntLE = function(L, X, ae, D) {
        if (L = +L, X = X >>> 0, !D) {
            const ce = Math.pow(2, 8 * ae - 1);
            Y(this, L, X, ae, ce - 1, -ce);
        }
        let H = 0, te = 1, ge = 0;
        for(this[X] = L & 255; ++H < ae && (te *= 256);)L < 0 && ge === 0 && this[X + H - 1] !== 0 && (ge = 1), this[X + H] = (L / te >> 0) - ge & 255;
        return X + ae;
    }, s.prototype.writeIntBE = function(L, X, ae, D) {
        if (L = +L, X = X >>> 0, !D) {
            const ce = Math.pow(2, 8 * ae - 1);
            Y(this, L, X, ae, ce - 1, -ce);
        }
        let H = ae - 1, te = 1, ge = 0;
        for(this[X + H] = L & 255; --H >= 0 && (te *= 256);)L < 0 && ge === 0 && this[X + H + 1] !== 0 && (ge = 1), this[X + H] = (L / te >> 0) - ge & 255;
        return X + ae;
    }, s.prototype.writeInt8 = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 1, 127, -128), L < 0 && (L = 255 + L + 1), this[X] = L & 255, X + 1;
    }, s.prototype.writeInt16LE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 2, 32767, -32768), this[X] = L & 255, this[X + 1] = L >>> 8, X + 2;
    }, s.prototype.writeInt16BE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 2, 32767, -32768), this[X] = L >>> 8, this[X + 1] = L & 255, X + 2;
    }, s.prototype.writeInt32LE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 4, 2147483647, -2147483648), this[X] = L & 255, this[X + 1] = L >>> 8, this[X + 2] = L >>> 16, this[X + 3] = L >>> 24, X + 4;
    }, s.prototype.writeInt32BE = function(L, X, ae) {
        return L = +L, X = X >>> 0, ae || Y(this, L, X, 4, 2147483647, -2147483648), L < 0 && (L = 4294967295 + L + 1), this[X] = L >>> 24, this[X + 1] = L >>> 16, this[X + 2] = L >>> 8, this[X + 3] = L & 255, X + 4;
    }, s.prototype.writeBigInt64LE = re(function(L, X = 0) {
        return he(this, L, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), s.prototype.writeBigInt64BE = re(function(L, X = 0) {
        return ue(this, L, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function G(L, X, ae, D, H, te) {
        if (ae + D > L.length) throw new RangeError("Index out of range");
        if (ae < 0) throw new RangeError("Index out of range");
    }
    function se(L, X, ae, D, H) {
        return X = +X, ae = ae >>> 0, H || G(L, X, ae, 4), r.write(L, X, ae, D, 23, 4), ae + 4;
    }
    s.prototype.writeFloatLE = function(L, X, ae) {
        return se(this, L, X, !0, ae);
    }, s.prototype.writeFloatBE = function(L, X, ae) {
        return se(this, L, X, !1, ae);
    };
    function Z(L, X, ae, D, H) {
        return X = +X, ae = ae >>> 0, H || G(L, X, ae, 8), r.write(L, X, ae, D, 52, 8), ae + 8;
    }
    s.prototype.writeDoubleLE = function(L, X, ae) {
        return Z(this, L, X, !0, ae);
    }, s.prototype.writeDoubleBE = function(L, X, ae) {
        return Z(this, L, X, !1, ae);
    }, s.prototype.copy = function(L, X, ae, D) {
        if (!s.isBuffer(L)) throw new TypeError("argument should be a Buffer");
        if (ae || (ae = 0), !D && D !== 0 && (D = this.length), X >= L.length && (X = L.length), X || (X = 0), D > 0 && D < ae && (D = ae), D === ae || L.length === 0 || this.length === 0) return 0;
        if (X < 0) throw new RangeError("targetStart out of bounds");
        if (ae < 0 || ae >= this.length) throw new RangeError("Index out of range");
        if (D < 0) throw new RangeError("sourceEnd out of bounds");
        D > this.length && (D = this.length), L.length - X < D - ae && (D = L.length - X + ae);
        const H = D - ae;
        return this === L && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(X, ae, D) : Uint8Array.prototype.set.call(L, this.subarray(ae, D), X), H;
    }, s.prototype.fill = function(L, X, ae, D) {
        if (typeof L == "string") {
            if (typeof X == "string" ? (D = X, X = 0, ae = this.length) : typeof ae == "string" && (D = ae, ae = this.length), D !== void 0 && typeof D != "string") throw new TypeError("encoding must be a string");
            if (typeof D == "string" && !s.isEncoding(D)) throw new TypeError("Unknown encoding: " + D);
            if (L.length === 1) {
                const te = L.charCodeAt(0);
                (D === "utf8" && te < 128 || D === "latin1") && (L = te);
            }
        } else typeof L == "number" ? L = L & 255 : typeof L == "boolean" && (L = Number(L));
        if (X < 0 || this.length < X || this.length < ae) throw new RangeError("Out of range index");
        if (ae <= X) return this;
        X = X >>> 0, ae = ae === void 0 ? this.length : ae >>> 0, L || (L = 0);
        let H;
        if (typeof L == "number") for(H = X; H < ae; ++H)this[H] = L;
        else {
            const te = s.isBuffer(L) ? L : s.from(L, D), ge = te.length;
            if (ge === 0) throw new TypeError('The value "' + L + '" is invalid for argument "value"');
            for(H = 0; H < ae - X; ++H)this[H + X] = te[H % ge];
        }
        return this;
    };
    const ie = {};
    function pe(L, X, ae) {
        ie[L] = class extends ae {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: X.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${L}]`, this.stack, delete this.name;
            }
            get code() {
                return L;
            }
            set code(D) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: D,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${L}]: ${this.message}`;
            }
        };
    }
    pe("ERR_BUFFER_OUT_OF_BOUNDS", function(L) {
        return L ? `${L} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), pe("ERR_INVALID_ARG_TYPE", function(L, X) {
        return `The "${L}" argument must be of type number. Received type ${typeof X}`;
    }, TypeError), pe("ERR_OUT_OF_RANGE", function(L, X, ae) {
        let D = `The value of "${L}" is out of range.`, H = ae;
        return Number.isInteger(ae) && Math.abs(ae) > 2 ** 32 ? H = ve(String(ae)) : typeof ae == "bigint" && (H = String(ae), (ae > BigInt(2) ** BigInt(32) || ae < -(BigInt(2) ** BigInt(32))) && (H = ve(H)), H += "n"), D += ` It must be ${X}. Received ${H}`, D;
    }, RangeError);
    function ve(L) {
        let X = "", ae = L.length;
        const D = L[0] === "-" ? 1 : 0;
        for(; ae >= D + 4; ae -= 3)X = `_${L.slice(ae - 3, ae)}${X}`;
        return `${L.slice(0, ae)}${X}`;
    }
    function Ie(L, X, ae) {
        Re(X, "offset"), (L[X] === void 0 || L[X + ae] === void 0) && C(X, L.length - (ae + 1));
    }
    function Me(L, X, ae, D, H, te) {
        if (L > ae || L < X) {
            const ge = typeof X == "bigint" ? "n" : "";
            let ce;
            throw X === 0 || X === BigInt(0) ? ce = `>= 0${ge} and < 2${ge} ** ${(te + 1) * 8}${ge}` : ce = `>= -(2${ge} ** ${(te + 1) * 8 - 1}${ge}) and < 2 ** ${(te + 1) * 8 - 1}${ge}`, new ie.ERR_OUT_OF_RANGE("value", ce, L);
        }
        Ie(D, H, te);
    }
    function Re(L, X) {
        if (typeof L != "number") throw new ie.ERR_INVALID_ARG_TYPE(X, "number", L);
    }
    function C(L, X, ae) {
        throw Math.floor(L) !== L ? (Re(L, ae), new ie.ERR_OUT_OF_RANGE("offset", "an integer", L)) : X < 0 ? new ie.ERR_BUFFER_OUT_OF_BOUNDS() : new ie.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${X}`, L);
    }
    const J = /[^+/0-9A-Za-z-_]/g;
    function me(L) {
        if (L = L.split("=")[0], L = L.trim().replace(J, ""), L.length < 2) return "";
        for(; L.length % 4 !== 0;)L = L + "=";
        return L;
    }
    function je(L, X) {
        X = X || 1 / 0;
        let ae;
        const D = L.length;
        let H = null;
        const te = [];
        for(let ge = 0; ge < D; ++ge){
            if (ae = L.charCodeAt(ge), ae > 55295 && ae < 57344) {
                if (!H) {
                    if (ae > 56319) {
                        (X -= 3) > -1 && te.push(239, 191, 189);
                        continue;
                    } else if (ge + 1 === D) {
                        (X -= 3) > -1 && te.push(239, 191, 189);
                        continue;
                    }
                    H = ae;
                    continue;
                }
                if (ae < 56320) {
                    (X -= 3) > -1 && te.push(239, 191, 189), H = ae;
                    continue;
                }
                ae = (H - 55296 << 10 | ae - 56320) + 65536;
            } else H && (X -= 3) > -1 && te.push(239, 191, 189);
            if (H = null, ae < 128) {
                if ((X -= 1) < 0) break;
                te.push(ae);
            } else if (ae < 2048) {
                if ((X -= 2) < 0) break;
                te.push(ae >> 6 | 192, ae & 63 | 128);
            } else if (ae < 65536) {
                if ((X -= 3) < 0) break;
                te.push(ae >> 12 | 224, ae >> 6 & 63 | 128, ae & 63 | 128);
            } else if (ae < 1114112) {
                if ((X -= 4) < 0) break;
                te.push(ae >> 18 | 240, ae >> 12 & 63 | 128, ae >> 6 & 63 | 128, ae & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return te;
    }
    function Ve(L) {
        const X = [];
        for(let ae = 0; ae < L.length; ++ae)X.push(L.charCodeAt(ae) & 255);
        return X;
    }
    function nt(L, X) {
        let ae, D, H;
        const te = [];
        for(let ge = 0; ge < L.length && !((X -= 2) < 0); ++ge)ae = L.charCodeAt(ge), D = ae >> 8, H = ae % 256, te.push(H), te.push(D);
        return te;
    }
    function We(L) {
        return t.toByteArray(me(L));
    }
    function Ge(L, X, ae, D) {
        let H;
        for(H = 0; H < D && !(H + ae >= X.length || H >= L.length); ++H)X[H + ae] = L[H];
        return H;
    }
    function p(L, X) {
        return L instanceof X || L != null && L.constructor != null && L.constructor.name != null && L.constructor.name === X.name;
    }
    function A(L) {
        return L !== L;
    }
    const V = function() {
        const L = "0123456789abcdef", X = new Array(256);
        for(let ae = 0; ae < 16; ++ae){
            const D = ae * 16;
            for(let H = 0; H < 16; ++H)X[D + H] = L[ae] + L[H];
        }
        return X;
    }();
    function re(L) {
        return typeof BigInt > "u" ? le : L;
    }
    function le() {
        throw new Error("BigInt not supported");
    }
})(ul);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var US;
function Br() {
    return US || (US = 1, function(e, t) {
        var r = ul, n = r.Buffer;
        function i1(a, s) {
            for(var c in a)s[c] = a[c];
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i1(r, t), t.Buffer = o);
        function o(a, s, c) {
            return n(a, s, c);
        }
        o.prototype = Object.create(n.prototype), i1(n, o), o.from = function(a, s, c) {
            if (typeof a == "number") throw new TypeError("Argument must not be a number");
            return n(a, s, c);
        }, o.alloc = function(a, s, c) {
            if (typeof a != "number") throw new TypeError("Argument must be a number");
            var l = n(a);
            return s !== void 0 ? typeof c == "string" ? l.fill(s, c) : l.fill(s) : l.fill(0), l;
        }, o.allocUnsafe = function(a) {
            if (typeof a != "number") throw new TypeError("Argument must be a number");
            return n(a);
        }, o.allocUnsafeSlow = function(a) {
            if (typeof a != "number") throw new TypeError("Argument must be a number");
            return r.SlowBuffer(a);
        };
    }(_A, _A.exports)), _A.exports;
}
var DS;
function Dh() {
    if (DS) return Zg.exports;
    DS = 1;
    var e = 65536, t = 4294967295;
    function r() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var n = Br().Buffer, i1 = Qe.crypto || Qe.msCrypto;
    i1 && i1.getRandomValues ? Zg.exports = o : Zg.exports = r;
    function o(a, s) {
        if (a > t) throw new RangeError("requested too many random bytes");
        var c = n.allocUnsafe(a);
        if (a > 0) if (a > e) for(var l = 0; l < a; l += e)i1.getRandomValues(c.slice(l, l + e));
        else i1.getRandomValues(c);
        return typeof s == "function" ? xn.nextTick(function() {
            s(null, c);
        }) : c;
    }
    return Zg.exports;
}
var kA = {
    exports: {}
}, jS;
function Nr() {
    return jS || (jS = 1, typeof Object.create == "function" ? kA.exports = function(e, t) {
        t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    } : kA.exports = function(e, t) {
        if (t) {
            e.super_ = t;
            var r = function() {};
            r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
        }
    }), kA.exports;
}
const jY = {}, FY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: jY
}, Symbol.toStringTag, {
    value: "Module"
})), cl = /* @__PURE__ */ xG(FY);
var OA, FS;
function lC() {
    if (FS) return OA;
    FS = 1;
    var e = Br().Buffer, t = cl.Transform, r = Nr();
    function n(s) {
        t.call(this), this._block = e.allocUnsafe(s), this._blockSize = s, this._blockOffset = 0, this._length = [
            0,
            0,
            0,
            0
        ], this._finalized = !1;
    }
    r(n, t), n.prototype._transform = function(s, c, l) {
        var u = null;
        try {
            this.update(s, c);
        } catch (f) {
            u = f;
        }
        l(u);
    }, n.prototype._flush = function(s) {
        var c = null;
        try {
            this.push(this.digest());
        } catch (l) {
            c = l;
        }
        s(c);
    };
    var i1 = typeof Uint8Array < "u", o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
    function a(s, c) {
        if (s instanceof e) return s;
        if (typeof s == "string") return e.from(s, c);
        if (o && ArrayBuffer.isView(s)) {
            if (s.byteLength === 0) return e.alloc(0);
            var l = e.from(s.buffer, s.byteOffset, s.byteLength);
            if (l.byteLength === s.byteLength) return l;
        }
        if (i1 && s instanceof Uint8Array || e.isBuffer(s) && s.constructor && typeof s.constructor.isBuffer == "function" && s.constructor.isBuffer(s)) return e.from(s);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    return n.prototype.update = function(s, c) {
        if (this._finalized) throw new Error("Digest already called");
        s = a(s, c);
        for(var l = this._block, u = 0; this._blockOffset + s.length - u >= this._blockSize;){
            for(var f = this._blockOffset; f < this._blockSize;)l[f++] = s[u++];
            this._update(), this._blockOffset = 0;
        }
        for(; u < s.length;)l[this._blockOffset++] = s[u++];
        for(var h = 0, y = s.length * 8; y > 0; ++h)this._length[h] += y, y = this._length[h] / 4294967296 | 0, y > 0 && (this._length[h] -= 4294967296 * y);
        return this;
    }, n.prototype._update = function() {
        throw new Error("_update is not implemented");
    }, n.prototype.digest = function(s) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = !0;
        var c = this._digest();
        s !== void 0 && (c = c.toString(s)), this._block.fill(0), this._blockOffset = 0;
        for(var l = 0; l < 4; ++l)this._length[l] = 0;
        return c;
    }, n.prototype._digest = function() {
        throw new Error("_digest is not implemented");
    }, OA = n, OA;
}
var IA, zS;
function W6() {
    if (zS) return IA;
    zS = 1;
    var e = Nr(), t = lC(), r = Br().Buffer, n = new Array(16);
    function i1() {
        t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    e(i1, t), i1.prototype._update = function() {
        for(var u = n, f = 0; f < 16; ++f)u[f] = this._block.readInt32LE(f * 4);
        var h = this._a, y = this._b, S = this._c, k = this._d;
        h = a(h, y, S, k, u[0], 3614090360, 7), k = a(k, h, y, S, u[1], 3905402710, 12), S = a(S, k, h, y, u[2], 606105819, 17), y = a(y, S, k, h, u[3], 3250441966, 22), h = a(h, y, S, k, u[4], 4118548399, 7), k = a(k, h, y, S, u[5], 1200080426, 12), S = a(S, k, h, y, u[6], 2821735955, 17), y = a(y, S, k, h, u[7], 4249261313, 22), h = a(h, y, S, k, u[8], 1770035416, 7), k = a(k, h, y, S, u[9], 2336552879, 12), S = a(S, k, h, y, u[10], 4294925233, 17), y = a(y, S, k, h, u[11], 2304563134, 22), h = a(h, y, S, k, u[12], 1804603682, 7), k = a(k, h, y, S, u[13], 4254626195, 12), S = a(S, k, h, y, u[14], 2792965006, 17), y = a(y, S, k, h, u[15], 1236535329, 22), h = s(h, y, S, k, u[1], 4129170786, 5), k = s(k, h, y, S, u[6], 3225465664, 9), S = s(S, k, h, y, u[11], 643717713, 14), y = s(y, S, k, h, u[0], 3921069994, 20), h = s(h, y, S, k, u[5], 3593408605, 5), k = s(k, h, y, S, u[10], 38016083, 9), S = s(S, k, h, y, u[15], 3634488961, 14), y = s(y, S, k, h, u[4], 3889429448, 20), h = s(h, y, S, k, u[9], 568446438, 5), k = s(k, h, y, S, u[14], 3275163606, 9), S = s(S, k, h, y, u[3], 4107603335, 14), y = s(y, S, k, h, u[8], 1163531501, 20), h = s(h, y, S, k, u[13], 2850285829, 5), k = s(k, h, y, S, u[2], 4243563512, 9), S = s(S, k, h, y, u[7], 1735328473, 14), y = s(y, S, k, h, u[12], 2368359562, 20), h = c(h, y, S, k, u[5], 4294588738, 4), k = c(k, h, y, S, u[8], 2272392833, 11), S = c(S, k, h, y, u[11], 1839030562, 16), y = c(y, S, k, h, u[14], 4259657740, 23), h = c(h, y, S, k, u[1], 2763975236, 4), k = c(k, h, y, S, u[4], 1272893353, 11), S = c(S, k, h, y, u[7], 4139469664, 16), y = c(y, S, k, h, u[10], 3200236656, 23), h = c(h, y, S, k, u[13], 681279174, 4), k = c(k, h, y, S, u[0], 3936430074, 11), S = c(S, k, h, y, u[3], 3572445317, 16), y = c(y, S, k, h, u[6], 76029189, 23), h = c(h, y, S, k, u[9], 3654602809, 4), k = c(k, h, y, S, u[12], 3873151461, 11), S = c(S, k, h, y, u[15], 530742520, 16), y = c(y, S, k, h, u[2], 3299628645, 23), h = l(h, y, S, k, u[0], 4096336452, 6), k = l(k, h, y, S, u[7], 1126891415, 10), S = l(S, k, h, y, u[14], 2878612391, 15), y = l(y, S, k, h, u[5], 4237533241, 21), h = l(h, y, S, k, u[12], 1700485571, 6), k = l(k, h, y, S, u[3], 2399980690, 10), S = l(S, k, h, y, u[10], 4293915773, 15), y = l(y, S, k, h, u[1], 2240044497, 21), h = l(h, y, S, k, u[8], 1873313359, 6), k = l(k, h, y, S, u[15], 4264355552, 10), S = l(S, k, h, y, u[6], 2734768916, 15), y = l(y, S, k, h, u[13], 1309151649, 21), h = l(h, y, S, k, u[4], 4149444226, 6), k = l(k, h, y, S, u[11], 3174756917, 10), S = l(S, k, h, y, u[2], 718787259, 15), y = l(y, S, k, h, u[9], 3951481745, 21), this._a = this._a + h | 0, this._b = this._b + y | 0, this._c = this._c + S | 0, this._d = this._d + k | 0;
    }, i1.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var u = r.allocUnsafe(16);
        return u.writeInt32LE(this._a, 0), u.writeInt32LE(this._b, 4), u.writeInt32LE(this._c, 8), u.writeInt32LE(this._d, 12), u;
    };
    function o(u, f) {
        return u << f | u >>> 32 - f;
    }
    function a(u, f, h, y, S, k, P) {
        return o(u + (f & h | ~f & y) + S + k | 0, P) + f | 0;
    }
    function s(u, f, h, y, S, k, P) {
        return o(u + (f & y | h & ~y) + S + k | 0, P) + f | 0;
    }
    function c(u, f, h, y, S, k, P) {
        return o(u + (f ^ h ^ y) + S + k | 0, P) + f | 0;
    }
    function l(u, f, h, y, S, k, P) {
        return o(u + (h ^ (f | ~y)) + S + k | 0, P) + f | 0;
    }
    return IA = i1, IA;
}
var BA, LS;
function G6() {
    if (LS) return BA;
    LS = 1;
    var e = ul.Buffer, t = Nr(), r = lC(), n = new Array(16), i1 = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], o = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], a = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], s = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ], c = [
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
    ], l = [
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
    ];
    function u() {
        r.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    t(u, r), u.prototype._update = function() {
        for(var M = n, N = 0; N < 16; ++N)M[N] = this._block.readInt32LE(N * 4);
        for(var z = this._a | 0, K = this._b | 0, $ = this._c | 0, ne = this._d | 0, ee = this._e | 0, q = this._a | 0, U = this._b | 0, Q = this._c | 0, v = this._d | 0, B = this._e | 0, g = 0; g < 80; g += 1){
            var E, w;
            g < 16 ? (E = h(z, K, $, ne, ee, M[i1[g]], c[0], a[g]), w = P(q, U, Q, v, B, M[o[g]], l[0], s[g])) : g < 32 ? (E = y(z, K, $, ne, ee, M[i1[g]], c[1], a[g]), w = k(q, U, Q, v, B, M[o[g]], l[1], s[g])) : g < 48 ? (E = S(z, K, $, ne, ee, M[i1[g]], c[2], a[g]), w = S(q, U, Q, v, B, M[o[g]], l[2], s[g])) : g < 64 ? (E = k(z, K, $, ne, ee, M[i1[g]], c[3], a[g]), w = y(q, U, Q, v, B, M[o[g]], l[3], s[g])) : (E = P(z, K, $, ne, ee, M[i1[g]], c[4], a[g]), w = h(q, U, Q, v, B, M[o[g]], l[4], s[g])), z = ee, ee = ne, ne = f($, 10), $ = K, K = E, q = B, B = v, v = f(Q, 10), Q = U, U = w;
        }
        var _ = this._b + $ + v | 0;
        this._b = this._c + ne + B | 0, this._c = this._d + ee + q | 0, this._d = this._e + z + U | 0, this._e = this._a + K + Q | 0, this._a = _;
    }, u.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var M = e.alloc ? e.alloc(20) : new e(20);
        return M.writeInt32LE(this._a, 0), M.writeInt32LE(this._b, 4), M.writeInt32LE(this._c, 8), M.writeInt32LE(this._d, 12), M.writeInt32LE(this._e, 16), M;
    };
    function f(M, N) {
        return M << N | M >>> 32 - N;
    }
    function h(M, N, z, K, $, ne, ee, q) {
        return f(M + (N ^ z ^ K) + ne + ee | 0, q) + $ | 0;
    }
    function y(M, N, z, K, $, ne, ee, q) {
        return f(M + (N & z | ~N & K) + ne + ee | 0, q) + $ | 0;
    }
    function S(M, N, z, K, $, ne, ee, q) {
        return f(M + ((N | ~z) ^ K) + ne + ee | 0, q) + $ | 0;
    }
    function k(M, N, z, K, $, ne, ee, q) {
        return f(M + (N & K | z & ~K) + ne + ee | 0, q) + $ | 0;
    }
    function P(M, N, z, K, $, ne, ee, q) {
        return f(M + (N ^ (z | ~K)) + ne + ee | 0, q) + $ | 0;
    }
    return BA = u, BA;
}
var TA = {
    exports: {}
}, PA, HS;
function jh() {
    if (HS) return PA;
    HS = 1;
    var e = Br().Buffer;
    function t(r, n) {
        this._block = e.alloc(r), this._finalSize = n, this._blockSize = r, this._len = 0;
    }
    return t.prototype.update = function(r, n) {
        typeof r == "string" && (n = n || "utf8", r = e.from(r, n));
        for(var i1 = this._block, o = this._blockSize, a = r.length, s = this._len, c = 0; c < a;){
            for(var l = s % o, u = Math.min(a - c, o - l), f = 0; f < u; f++)i1[l + f] = r[c + f];
            s += u, c += u, s % o === 0 && this._update(i1);
        }
        return this._len += a, this;
    }, t.prototype.digest = function(r) {
        var n = this._len % this._blockSize;
        this._block[n] = 128, this._block.fill(0, n + 1), n >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var i1 = this._len * 8;
        if (i1 <= 4294967295) this._block.writeUInt32BE(i1, this._blockSize - 4);
        else {
            var o = (i1 & 4294967295) >>> 0, a = (i1 - o) / 4294967296;
            this._block.writeUInt32BE(a, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
        }
        this._update(this._block);
        var s = this._hash();
        return r ? s.toString(r) : s;
    }, t.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    }, PA = t, PA;
}
var CA, KS;
function zY() {
    if (KS) return CA;
    KS = 1;
    var e = Nr(), t = jh(), r = Br().Buffer, n = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], i1 = new Array(80);
    function o() {
        this.init(), this._w = i1, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function a(l) {
        return l << 5 | l >>> 27;
    }
    function s(l) {
        return l << 30 | l >>> 2;
    }
    function c(l, u, f, h) {
        return l === 0 ? u & f | ~u & h : l === 2 ? u & f | u & h | f & h : u ^ f ^ h;
    }
    return o.prototype._update = function(l) {
        for(var u = this._w, f = this._a | 0, h = this._b | 0, y = this._c | 0, S = this._d | 0, k = this._e | 0, P = 0; P < 16; ++P)u[P] = l.readInt32BE(P * 4);
        for(; P < 80; ++P)u[P] = u[P - 3] ^ u[P - 8] ^ u[P - 14] ^ u[P - 16];
        for(var M = 0; M < 80; ++M){
            var N = ~~(M / 20), z = a(f) + c(N, h, y, S) + k + u[M] + n[N] | 0;
            k = S, S = y, y = s(h), h = f, f = z;
        }
        this._a = f + this._a | 0, this._b = h + this._b | 0, this._c = y + this._c | 0, this._d = S + this._d | 0, this._e = k + this._e | 0;
    }, o.prototype._hash = function() {
        var l = r.allocUnsafe(20);
        return l.writeInt32BE(this._a | 0, 0), l.writeInt32BE(this._b | 0, 4), l.writeInt32BE(this._c | 0, 8), l.writeInt32BE(this._d | 0, 12), l.writeInt32BE(this._e | 0, 16), l;
    }, CA = o, CA;
}
var MA, qS;
function LY() {
    if (qS) return MA;
    qS = 1;
    var e = Nr(), t = jh(), r = Br().Buffer, n = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], i1 = new Array(80);
    function o() {
        this.init(), this._w = i1, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function a(u) {
        return u << 1 | u >>> 31;
    }
    function s(u) {
        return u << 5 | u >>> 27;
    }
    function c(u) {
        return u << 30 | u >>> 2;
    }
    function l(u, f, h, y) {
        return u === 0 ? f & h | ~f & y : u === 2 ? f & h | f & y | h & y : f ^ h ^ y;
    }
    return o.prototype._update = function(u) {
        for(var f = this._w, h = this._a | 0, y = this._b | 0, S = this._c | 0, k = this._d | 0, P = this._e | 0, M = 0; M < 16; ++M)f[M] = u.readInt32BE(M * 4);
        for(; M < 80; ++M)f[M] = a(f[M - 3] ^ f[M - 8] ^ f[M - 14] ^ f[M - 16]);
        for(var N = 0; N < 80; ++N){
            var z = ~~(N / 20), K = s(h) + l(z, y, S, k) + P + f[N] + n[z] | 0;
            P = k, k = S, S = c(y), y = h, h = K;
        }
        this._a = h + this._a | 0, this._b = y + this._b | 0, this._c = S + this._c | 0, this._d = k + this._d | 0, this._e = P + this._e | 0;
    }, o.prototype._hash = function() {
        var u = r.allocUnsafe(20);
        return u.writeInt32BE(this._a | 0, 0), u.writeInt32BE(this._b | 0, 4), u.writeInt32BE(this._c | 0, 8), u.writeInt32BE(this._d | 0, 12), u.writeInt32BE(this._e | 0, 16), u;
    }, MA = o, MA;
}
var NA, VS;
function fC() {
    if (VS) return NA;
    VS = 1;
    var e = Nr(), t = jh(), r = Br().Buffer, n = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ], i1 = new Array(64);
    function o() {
        this.init(), this._w = i1, t.call(this, 64, 56);
    }
    e(o, t), o.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function a(h, y, S) {
        return S ^ h & (y ^ S);
    }
    function s(h, y, S) {
        return h & y | S & (h | y);
    }
    function c(h) {
        return (h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10);
    }
    function l(h) {
        return (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
    }
    function u(h) {
        return (h >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3;
    }
    function f(h) {
        return (h >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10;
    }
    return o.prototype._update = function(h) {
        for(var y = this._w, S = this._a | 0, k = this._b | 0, P = this._c | 0, M = this._d | 0, N = this._e | 0, z = this._f | 0, K = this._g | 0, $ = this._h | 0, ne = 0; ne < 16; ++ne)y[ne] = h.readInt32BE(ne * 4);
        for(; ne < 64; ++ne)y[ne] = f(y[ne - 2]) + y[ne - 7] + u(y[ne - 15]) + y[ne - 16] | 0;
        for(var ee = 0; ee < 64; ++ee){
            var q = $ + l(N) + a(N, z, K) + n[ee] + y[ee] | 0, U = c(S) + s(S, k, P) | 0;
            $ = K, K = z, z = N, N = M + q | 0, M = P, P = k, k = S, S = q + U | 0;
        }
        this._a = S + this._a | 0, this._b = k + this._b | 0, this._c = P + this._c | 0, this._d = M + this._d | 0, this._e = N + this._e | 0, this._f = z + this._f | 0, this._g = K + this._g | 0, this._h = $ + this._h | 0;
    }, o.prototype._hash = function() {
        var h = r.allocUnsafe(32);
        return h.writeInt32BE(this._a, 0), h.writeInt32BE(this._b, 4), h.writeInt32BE(this._c, 8), h.writeInt32BE(this._d, 12), h.writeInt32BE(this._e, 16), h.writeInt32BE(this._f, 20), h.writeInt32BE(this._g, 24), h.writeInt32BE(this._h, 28), h;
    }, NA = o, NA;
}
var RA, WS;
function HY() {
    if (WS) return RA;
    WS = 1;
    var e = Nr(), t = fC(), r = jh(), n = Br().Buffer, i1 = new Array(64);
    function o() {
        this.init(), this._w = i1, r.call(this, 64, 56);
    }
    return e(o, t), o.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    }, o.prototype._hash = function() {
        var a = n.allocUnsafe(28);
        return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a;
    }, RA = o, RA;
}
var UA, GS;
function dC() {
    if (GS) return UA;
    GS = 1;
    var e = Nr(), t = jh(), r = Br().Buffer, n = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ], i1 = new Array(160);
    function o() {
        this.init(), this._w = i1, t.call(this, 128, 112);
    }
    e(o, t), o.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function a(k, P, M) {
        return M ^ k & (P ^ M);
    }
    function s(k, P, M) {
        return k & P | M & (k | P);
    }
    function c(k, P) {
        return (k >>> 28 | P << 4) ^ (P >>> 2 | k << 30) ^ (P >>> 7 | k << 25);
    }
    function l(k, P) {
        return (k >>> 14 | P << 18) ^ (k >>> 18 | P << 14) ^ (P >>> 9 | k << 23);
    }
    function u(k, P) {
        return (k >>> 1 | P << 31) ^ (k >>> 8 | P << 24) ^ k >>> 7;
    }
    function f(k, P) {
        return (k >>> 1 | P << 31) ^ (k >>> 8 | P << 24) ^ (k >>> 7 | P << 25);
    }
    function h(k, P) {
        return (k >>> 19 | P << 13) ^ (P >>> 29 | k << 3) ^ k >>> 6;
    }
    function y(k, P) {
        return (k >>> 19 | P << 13) ^ (P >>> 29 | k << 3) ^ (k >>> 6 | P << 26);
    }
    function S(k, P) {
        return k >>> 0 < P >>> 0 ? 1 : 0;
    }
    return o.prototype._update = function(k) {
        for(var P = this._w, M = this._ah | 0, N = this._bh | 0, z = this._ch | 0, K = this._dh | 0, $ = this._eh | 0, ne = this._fh | 0, ee = this._gh | 0, q = this._hh | 0, U = this._al | 0, Q = this._bl | 0, v = this._cl | 0, B = this._dl | 0, g = this._el | 0, E = this._fl | 0, w = this._gl | 0, _ = this._hl | 0, O = 0; O < 32; O += 2)P[O] = k.readInt32BE(O * 4), P[O + 1] = k.readInt32BE(O * 4 + 4);
        for(; O < 160; O += 2){
            var I = P[O - 30], x = P[O - 15 * 2 + 1], R = u(I, x), j = f(x, I);
            I = P[O - 2 * 2], x = P[O - 2 * 2 + 1];
            var Y = h(I, x), he = y(x, I), ue = P[O - 7 * 2], G = P[O - 7 * 2 + 1], se = P[O - 16 * 2], Z = P[O - 16 * 2 + 1], ie = j + G | 0, pe = R + ue + S(ie, j) | 0;
            ie = ie + he | 0, pe = pe + Y + S(ie, he) | 0, ie = ie + Z | 0, pe = pe + se + S(ie, Z) | 0, P[O] = pe, P[O + 1] = ie;
        }
        for(var ve = 0; ve < 160; ve += 2){
            pe = P[ve], ie = P[ve + 1];
            var Ie = s(M, N, z), Me = s(U, Q, v), Re = c(M, U), C = c(U, M), J = l($, g), me = l(g, $), je = n[ve], Ve = n[ve + 1], nt = a($, ne, ee), We = a(g, E, w), Ge = _ + me | 0, p = q + J + S(Ge, _) | 0;
            Ge = Ge + We | 0, p = p + nt + S(Ge, We) | 0, Ge = Ge + Ve | 0, p = p + je + S(Ge, Ve) | 0, Ge = Ge + ie | 0, p = p + pe + S(Ge, ie) | 0;
            var A = C + Me | 0, V = Re + Ie + S(A, C) | 0;
            q = ee, _ = w, ee = ne, w = E, ne = $, E = g, g = B + Ge | 0, $ = K + p + S(g, B) | 0, K = z, B = v, z = N, v = Q, N = M, Q = U, U = Ge + A | 0, M = p + V + S(U, Ge) | 0;
        }
        this._al = this._al + U | 0, this._bl = this._bl + Q | 0, this._cl = this._cl + v | 0, this._dl = this._dl + B | 0, this._el = this._el + g | 0, this._fl = this._fl + E | 0, this._gl = this._gl + w | 0, this._hl = this._hl + _ | 0, this._ah = this._ah + M + S(this._al, U) | 0, this._bh = this._bh + N + S(this._bl, Q) | 0, this._ch = this._ch + z + S(this._cl, v) | 0, this._dh = this._dh + K + S(this._dl, B) | 0, this._eh = this._eh + $ + S(this._el, g) | 0, this._fh = this._fh + ne + S(this._fl, E) | 0, this._gh = this._gh + ee + S(this._gl, w) | 0, this._hh = this._hh + q + S(this._hl, _) | 0;
    }, o.prototype._hash = function() {
        var k = r.allocUnsafe(64);
        function P(M, N, z) {
            k.writeInt32BE(M, z), k.writeInt32BE(N, z + 4);
        }
        return P(this._ah, this._al, 0), P(this._bh, this._bl, 8), P(this._ch, this._cl, 16), P(this._dh, this._dl, 24), P(this._eh, this._el, 32), P(this._fh, this._fl, 40), P(this._gh, this._gl, 48), P(this._hh, this._hl, 56), k;
    }, UA = o, UA;
}
var DA, QS;
function KY() {
    if (QS) return DA;
    QS = 1;
    var e = Nr(), t = dC(), r = jh(), n = Br().Buffer, i1 = new Array(160);
    function o() {
        this.init(), this._w = i1, r.call(this, 128, 112);
    }
    return e(o, t), o.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    }, o.prototype._hash = function() {
        var a = n.allocUnsafe(48);
        function s(c, l, u) {
            a.writeInt32BE(c, u), a.writeInt32BE(l, u + 4);
        }
        return s(this._ah, this._al, 0), s(this._bh, this._bl, 8), s(this._ch, this._cl, 16), s(this._dh, this._dl, 24), s(this._eh, this._el, 32), s(this._fh, this._fl, 40), a;
    }, DA = o, DA;
}
var $S;
function Q6() {
    if ($S) return TA.exports;
    $S = 1;
    var e = TA.exports = function(t) {
        t = t.toLowerCase();
        var r = e[t];
        if (!r) throw new Error(t + " is not supported (we accept pull requests)");
        return new r();
    };
    return e.sha = zY(), e.sha1 = LY(), e.sha224 = HY(), e.sha256 = fC(), e.sha384 = KY(), e.sha512 = dC(), TA.exports;
}
var jA = {}, ZS;
function qY() {
    if (ZS) return jA;
    ZS = 1;
    var e = Br().Buffer, t = e.isEncoding || function(M) {
        switch(M = "" + M, M && M.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function r(M) {
        if (!M) return "utf8";
        for(var N;;)switch(M){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return M;
            default:
                if (N) return;
                M = ("" + M).toLowerCase(), N = !0;
        }
    }
    function n(M) {
        var N = r(M);
        if (typeof N != "string" && (e.isEncoding === t || !t(M))) throw new Error("Unknown encoding: " + M);
        return N || M;
    }
    jA.StringDecoder = i1;
    function i1(M) {
        this.encoding = n(M);
        var N;
        switch(this.encoding){
            case "utf16le":
                this.text = f, this.end = h, N = 4;
                break;
            case "utf8":
                this.fillLast = c, N = 4;
                break;
            case "base64":
                this.text = y, this.end = S, N = 3;
                break;
            default:
                this.write = k, this.end = P;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(N);
    }
    i1.prototype.write = function(M) {
        if (M.length === 0) return "";
        var N, z;
        if (this.lastNeed) {
            if (N = this.fillLast(M), N === void 0) return "";
            z = this.lastNeed, this.lastNeed = 0;
        } else z = 0;
        return z < M.length ? N ? N + this.text(M, z) : this.text(M, z) : N || "";
    }, i1.prototype.end = u, i1.prototype.text = l, i1.prototype.fillLast = function(M) {
        if (this.lastNeed <= M.length) return M.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        M.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, M.length), this.lastNeed -= M.length;
    };
    function o(M) {
        return M <= 127 ? 0 : M >> 5 === 6 ? 2 : M >> 4 === 14 ? 3 : M >> 3 === 30 ? 4 : M >> 6 === 2 ? -1 : -2;
    }
    function a(M, N, z) {
        var K = N.length - 1;
        if (K < z) return 0;
        var $ = o(N[K]);
        return $ >= 0 ? ($ > 0 && (M.lastNeed = $ - 1), $) : --K < z || $ === -2 ? 0 : ($ = o(N[K]), $ >= 0 ? ($ > 0 && (M.lastNeed = $ - 2), $) : --K < z || $ === -2 ? 0 : ($ = o(N[K]), $ >= 0 ? ($ > 0 && ($ === 2 ? $ = 0 : M.lastNeed = $ - 3), $) : 0));
    }
    function s(M, N, z) {
        if ((N[0] & 192) !== 128) return M.lastNeed = 0, "";
        if (M.lastNeed > 1 && N.length > 1) {
            if ((N[1] & 192) !== 128) return M.lastNeed = 1, "";
            if (M.lastNeed > 2 && N.length > 2 && (N[2] & 192) !== 128) return M.lastNeed = 2, "";
        }
    }
    function c(M) {
        var N = this.lastTotal - this.lastNeed, z = s(this, M);
        if (z !== void 0) return z;
        if (this.lastNeed <= M.length) return M.copy(this.lastChar, N, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        M.copy(this.lastChar, N, 0, M.length), this.lastNeed -= M.length;
    }
    function l(M, N) {
        var z = a(this, M, N);
        if (!this.lastNeed) return M.toString("utf8", N);
        this.lastTotal = z;
        var K = M.length - (z - this.lastNeed);
        return M.copy(this.lastChar, 0, K), M.toString("utf8", N, K);
    }
    function u(M) {
        var N = M && M.length ? this.write(M) : "";
        return this.lastNeed ? N + "" : N;
    }
    function f(M, N) {
        if ((M.length - N) % 2 === 0) {
            var z = M.toString("utf16le", N);
            if (z) {
                var K = z.charCodeAt(z.length - 1);
                if (K >= 55296 && K <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = M[M.length - 2], this.lastChar[1] = M[M.length - 1], z.slice(0, -1);
            }
            return z;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = M[M.length - 1], M.toString("utf16le", N, M.length - 1);
    }
    function h(M) {
        var N = M && M.length ? this.write(M) : "";
        if (this.lastNeed) {
            var z = this.lastTotal - this.lastNeed;
            return N + this.lastChar.toString("utf16le", 0, z);
        }
        return N;
    }
    function y(M, N) {
        var z = (M.length - N) % 3;
        return z === 0 ? M.toString("base64", N) : (this.lastNeed = 3 - z, this.lastTotal = 3, z === 1 ? this.lastChar[0] = M[M.length - 1] : (this.lastChar[0] = M[M.length - 2], this.lastChar[1] = M[M.length - 1]), M.toString("base64", N, M.length - z));
    }
    function S(M) {
        var N = M && M.length ? this.write(M) : "";
        return this.lastNeed ? N + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : N;
    }
    function k(M) {
        return M.toString(this.encoding);
    }
    function P(M) {
        return M && M.length ? this.write(M) : "";
    }
    return jA;
}
var FA, XS;
function ll() {
    if (XS) return FA;
    XS = 1;
    var e = Br().Buffer, t = cl.Transform, r = qY().StringDecoder, n = Nr();
    function i1(c) {
        t.call(this), this.hashMode = typeof c == "string", this.hashMode ? this[c] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    n(i1, t);
    var o = typeof Uint8Array < "u", a = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
    function s(c, l) {
        if (c instanceof e) return c;
        if (typeof c == "string") return e.from(c, l);
        if (a && ArrayBuffer.isView(c)) {
            if (c.byteLength === 0) return e.alloc(0);
            var u = e.from(c.buffer, c.byteOffset, c.byteLength);
            if (u.byteLength === c.byteLength) return u;
        }
        if (o && c instanceof Uint8Array || e.isBuffer(c) && c.constructor && typeof c.constructor.isBuffer == "function" && c.constructor.isBuffer(c)) return e.from(c);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    return i1.prototype.update = function(c, l, u) {
        var f = s(c, l), h = this._update(f);
        return this.hashMode ? this : (u && (h = this._toString(h, u)), h);
    }, i1.prototype.setAutoPadding = function() {}, i1.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
    }, i1.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
    }, i1.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
    }, i1.prototype._transform = function(c, l, u) {
        var f;
        try {
            this.hashMode ? this._update(c) : this.push(this._update(c));
        } catch (h) {
            f = h;
        } finally{
            u(f);
        }
    }, i1.prototype._flush = function(c) {
        var l;
        try {
            this.push(this.__final());
        } catch (u) {
            l = u;
        }
        c(l);
    }, i1.prototype._finalOrDigest = function(c) {
        var l = this.__final() || e.alloc(0);
        return c && (l = this._toString(l, c, !0)), l;
    }, i1.prototype._toString = function(c, l, u) {
        if (this._decoder || (this._decoder = new r(l), this._encoding = l), this._encoding !== l) throw new Error("cant switch encodings");
        var f = this._decoder.write(c);
        return u && (f += this._decoder.end()), f;
    }, FA = i1, FA;
}
var zA, YS;
function b1() {
    if (YS) return zA;
    YS = 1;
    var e = Nr(), t = W6(), r = G6(), n = Q6(), i1 = ll();
    function o(a) {
        i1.call(this, "digest"), this._hash = a;
    }
    return e(o, i1), o.prototype._update = function(a) {
        this._hash.update(a);
    }, o.prototype._final = function() {
        return this._hash.digest();
    }, zA = function(a) {
        return a = a.toLowerCase(), a === "md5" ? new t() : a === "rmd160" || a === "ripemd160" ? new r() : new o(n(a));
    }, zA;
}
var LA, JS;
function VY() {
    if (JS) return LA;
    JS = 1;
    var e = Nr(), t = Br().Buffer, r = ll(), n = t.alloc(128), i1 = 64;
    function o(a, s) {
        r.call(this, "digest"), typeof s == "string" && (s = t.from(s)), this._alg = a, this._key = s, s.length > i1 ? s = a(s) : s.length < i1 && (s = t.concat([
            s,
            n
        ], i1));
        for(var c = this._ipad = t.allocUnsafe(i1), l = this._opad = t.allocUnsafe(i1), u = 0; u < i1; u++)c[u] = s[u] ^ 54, l[u] = s[u] ^ 92;
        this._hash = [
            c
        ];
    }
    return e(o, r), o.prototype._update = function(a) {
        this._hash.push(a);
    }, o.prototype._final = function() {
        var a = this._alg(t.concat(this._hash));
        return this._alg(t.concat([
            this._opad,
            a
        ]));
    }, LA = o, LA;
}
var HA, ex;
function hC() {
    if (ex) return HA;
    ex = 1;
    var e = W6();
    return HA = function(t) {
        return new e().update(t).digest();
    }, HA;
}
var KA, tx;
function pC() {
    if (tx) return KA;
    tx = 1;
    var e = Nr(), t = VY(), r = ll(), n = Br().Buffer, i1 = hC(), o = G6(), a = Q6(), s = n.alloc(128);
    function c(l, u) {
        r.call(this, "digest"), typeof u == "string" && (u = n.from(u));
        var f = l === "sha512" || l === "sha384" ? 128 : 64;
        if (this._alg = l, this._key = u, u.length > f) {
            var h = l === "rmd160" ? new o() : a(l);
            u = h.update(u).digest();
        } else u.length < f && (u = n.concat([
            u,
            s
        ], f));
        for(var y = this._ipad = n.allocUnsafe(f), S = this._opad = n.allocUnsafe(f), k = 0; k < f; k++)y[k] = u[k] ^ 54, S[k] = u[k] ^ 92;
        this._hash = l === "rmd160" ? new o() : a(l), this._hash.update(y);
    }
    return e(c, r), c.prototype._update = function(l) {
        this._hash.update(l);
    }, c.prototype._final = function() {
        var l = this._hash.digest(), u = this._alg === "rmd160" ? new o() : a(this._alg);
        return u.update(this._opad).update(l).digest();
    }, KA = function(l, u) {
        return l = l.toLowerCase(), l === "rmd160" || l === "ripemd160" ? new c("rmd160", u) : l === "md5" ? new t(i1, u) : new c(l, u);
    }, KA;
}
const WY = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
}, GY = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
}, QY = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
}, $Y = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
}, ZY = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
}, XY = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
}, YY = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
}, JY = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
}, eJ = {
    sign: "dsa",
    hash: "sha1",
    id: ""
}, tJ = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
}, rJ = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
}, gC = {
    sha224WithRSAEncryption: WY,
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption: GY,
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption: QY,
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption: $Y,
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256: ZY,
    sha224: XY,
    sha384: YY,
    sha512: JY,
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA: eJ,
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA: tJ,
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption: rJ,
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var rx, nx;
function nJ() {
    return nx || (nx = 1, rx = gC), rx;
}
var qA = {}, VA, ix;
function yC() {
    if (ix) return VA;
    ix = 1;
    var e = Math.pow(2, 30) - 1;
    return VA = function(t, r) {
        if (typeof t != "number") throw new TypeError("Iterations not a number");
        if (t < 0) throw new TypeError("Bad iterations");
        if (typeof r != "number") throw new TypeError("Key length not a number");
        if (r < 0 || r > e || r !== r) throw new TypeError("Bad key length");
    }, VA;
}
var WA, ox;
function mC() {
    if (ox) return WA;
    ox = 1;
    var e;
    if (Qe.process && Qe.process.browser) e = "utf-8";
    else if (Qe.process && Qe.process.version) {
        var t = parseInt(xn.version.split(".")[0].slice(1), 10);
        e = t >= 6 ? "utf-8" : "binary";
    } else e = "utf-8";
    return WA = e, WA;
}
var GA, ax;
function bC() {
    if (ax) return GA;
    ax = 1;
    var e = Br().Buffer;
    return GA = function(t, r, n) {
        if (e.isBuffer(t)) return t;
        if (typeof t == "string") return e.from(t, r);
        if (ArrayBuffer.isView(t)) return e.from(t.buffer);
        throw new TypeError(n + " must be a string, a Buffer, a typed array or a DataView");
    }, GA;
}
var QA, sx;
function wC() {
    if (sx) return QA;
    sx = 1;
    var e = hC(), t = G6(), r = Q6(), n = Br().Buffer, i1 = yC(), o = mC(), a = bC(), s = n.alloc(128), c = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function l(h, y, S) {
        var k = u(h), P = h === "sha512" || h === "sha384" ? 128 : 64;
        y.length > P ? y = k(y) : y.length < P && (y = n.concat([
            y,
            s
        ], P));
        for(var M = n.allocUnsafe(P + c[h]), N = n.allocUnsafe(P + c[h]), z = 0; z < P; z++)M[z] = y[z] ^ 54, N[z] = y[z] ^ 92;
        var K = n.allocUnsafe(P + S + 4);
        M.copy(K, 0, 0, P), this.ipad1 = K, this.ipad2 = M, this.opad = N, this.alg = h, this.blocksize = P, this.hash = k, this.size = c[h];
    }
    l.prototype.run = function(h, y) {
        h.copy(y, this.blocksize);
        var S = this.hash(y);
        return S.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function u(h) {
        function y(k) {
            return r(h).update(k).digest();
        }
        function S(k) {
            return new t().update(k).digest();
        }
        return h === "rmd160" || h === "ripemd160" ? S : h === "md5" ? e : y;
    }
    function f(h, y, S, k, P) {
        i1(S, k), h = a(h, o, "Password"), y = a(y, o, "Salt"), P = P || "sha1";
        var M = new l(P, h, y.length), N = n.allocUnsafe(k), z = n.allocUnsafe(y.length + 4);
        y.copy(z, 0, 0, y.length);
        for(var K = 0, $ = c[P], ne = Math.ceil(k / $), ee = 1; ee <= ne; ee++){
            z.writeUInt32BE(ee, y.length);
            for(var q = M.run(z, M.ipad1), U = q, Q = 1; Q < S; Q++){
                U = M.run(U, M.ipad2);
                for(var v = 0; v < $; v++)q[v] ^= U[v];
            }
            q.copy(N, K), K += $;
        }
        return N;
    }
    return QA = f, QA;
}
var $A, ux;
function iJ() {
    if (ux) return $A;
    ux = 1;
    var e = Br().Buffer, t = yC(), r = mC(), n = wC(), i1 = bC(), o, a = Qe.crypto && Qe.crypto.subtle, s = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, c = [];
    function l(S) {
        if (Qe.process && !Qe.process.browser || !a || !a.importKey || !a.deriveBits) return Promise.resolve(!1);
        if (c[S] !== void 0) return c[S];
        o = o || e.alloc(8);
        var k = h(o, o, 10, 128, S).then(function() {
            return !0;
        }).catch(function() {
            return !1;
        });
        return c[S] = k, k;
    }
    var u;
    function f() {
        return u || (Qe.process && Qe.process.nextTick ? u = Qe.process.nextTick : Qe.queueMicrotask ? u = Qe.queueMicrotask : Qe.setImmediate ? u = Qe.setImmediate : u = Qe.setTimeout, u);
    }
    function h(S, k, P, M, N) {
        return a.importKey("raw", S, {
            name: "PBKDF2"
        }, !1, [
            "deriveBits"
        ]).then(function(z) {
            return a.deriveBits({
                name: "PBKDF2",
                salt: k,
                iterations: P,
                hash: {
                    name: N
                }
            }, z, M << 3);
        }).then(function(z) {
            return e.from(z);
        });
    }
    function y(S, k) {
        S.then(function(P) {
            f()(function() {
                k(null, P);
            });
        }, function(P) {
            f()(function() {
                k(P);
            });
        });
    }
    return $A = function(S, k, P, M, N, z) {
        typeof N == "function" && (z = N, N = void 0), N = N || "sha1";
        var K = s[N.toLowerCase()];
        if (!K || typeof Qe.Promise != "function") {
            f()(function() {
                var $;
                try {
                    $ = n(S, k, P, M, N);
                } catch (ne) {
                    return z(ne);
                }
                z(null, $);
            });
            return;
        }
        if (t(P, M), S = i1(S, r, "Password"), k = i1(k, r, "Salt"), typeof z != "function") throw new Error("No callback provided to pbkdf2");
        y(l(K).then(function($) {
            return $ ? h(S, k, P, M, K) : n(S, k, P, M, N);
        }), z);
    }, $A;
}
var cx;
function AC() {
    return cx || (cx = 1, qA.pbkdf2 = iJ(), qA.pbkdf2Sync = wC()), qA;
}
var da = {}, fd = {}, Lo = {}, lx;
function vC() {
    if (lx) return Lo;
    lx = 1, Lo.readUInt32BE = function(n, i1) {
        var o = n[0 + i1] << 24 | n[1 + i1] << 16 | n[2 + i1] << 8 | n[3 + i1];
        return o >>> 0;
    }, Lo.writeUInt32BE = function(n, i1, o) {
        n[0 + o] = i1 >>> 24, n[1 + o] = i1 >>> 16 & 255, n[2 + o] = i1 >>> 8 & 255, n[3 + o] = i1 & 255;
    }, Lo.ip = function(n, i1, o, a) {
        for(var s = 0, c = 0, l = 6; l >= 0; l -= 2){
            for(var u = 0; u <= 24; u += 8)s <<= 1, s |= i1 >>> u + l & 1;
            for(var u = 0; u <= 24; u += 8)s <<= 1, s |= n >>> u + l & 1;
        }
        for(var l = 6; l >= 0; l -= 2){
            for(var u = 1; u <= 25; u += 8)c <<= 1, c |= i1 >>> u + l & 1;
            for(var u = 1; u <= 25; u += 8)c <<= 1, c |= n >>> u + l & 1;
        }
        o[a + 0] = s >>> 0, o[a + 1] = c >>> 0;
    }, Lo.rip = function(n, i1, o, a) {
        for(var s = 0, c = 0, l = 0; l < 4; l++)for(var u = 24; u >= 0; u -= 8)s <<= 1, s |= i1 >>> u + l & 1, s <<= 1, s |= n >>> u + l & 1;
        for(var l = 4; l < 8; l++)for(var u = 24; u >= 0; u -= 8)c <<= 1, c |= i1 >>> u + l & 1, c <<= 1, c |= n >>> u + l & 1;
        o[a + 0] = s >>> 0, o[a + 1] = c >>> 0;
    }, Lo.pc1 = function(n, i1, o, a) {
        for(var s = 0, c = 0, l = 7; l >= 5; l--){
            for(var u = 0; u <= 24; u += 8)s <<= 1, s |= i1 >> u + l & 1;
            for(var u = 0; u <= 24; u += 8)s <<= 1, s |= n >> u + l & 1;
        }
        for(var u = 0; u <= 24; u += 8)s <<= 1, s |= i1 >> u + l & 1;
        for(var l = 1; l <= 3; l++){
            for(var u = 0; u <= 24; u += 8)c <<= 1, c |= i1 >> u + l & 1;
            for(var u = 0; u <= 24; u += 8)c <<= 1, c |= n >> u + l & 1;
        }
        for(var u = 0; u <= 24; u += 8)c <<= 1, c |= n >> u + l & 1;
        o[a + 0] = s >>> 0, o[a + 1] = c >>> 0;
    }, Lo.r28shl = function(n, i1) {
        return n << i1 & 268435455 | n >>> 28 - i1;
    };
    var e = [
        // inL => outL
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        // inR => outR
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
    ];
    Lo.pc2 = function(n, i1, o, a) {
        for(var s = 0, c = 0, l = e.length >>> 1, u = 0; u < l; u++)s <<= 1, s |= n >>> e[u] & 1;
        for(var u = l; u < e.length; u++)c <<= 1, c |= i1 >>> e[u] & 1;
        o[a + 0] = s >>> 0, o[a + 1] = c >>> 0;
    }, Lo.expand = function(n, i1, o) {
        var a = 0, s = 0;
        a = (n & 1) << 5 | n >>> 27;
        for(var c = 23; c >= 15; c -= 4)a <<= 6, a |= n >>> c & 63;
        for(var c = 11; c >= 3; c -= 4)s |= n >>> c & 63, s <<= 6;
        s |= (n & 31) << 1 | n >>> 31, i1[o + 0] = a >>> 0, i1[o + 1] = s >>> 0;
    };
    var t = [
        14,
        0,
        4,
        15,
        13,
        7,
        1,
        4,
        2,
        14,
        15,
        2,
        11,
        13,
        8,
        1,
        3,
        10,
        10,
        6,
        6,
        12,
        12,
        11,
        5,
        9,
        9,
        5,
        0,
        3,
        7,
        8,
        4,
        15,
        1,
        12,
        14,
        8,
        8,
        2,
        13,
        4,
        6,
        9,
        2,
        1,
        11,
        7,
        15,
        5,
        12,
        11,
        9,
        3,
        7,
        14,
        3,
        10,
        10,
        0,
        5,
        6,
        0,
        13,
        15,
        3,
        1,
        13,
        8,
        4,
        14,
        7,
        6,
        15,
        11,
        2,
        3,
        8,
        4,
        14,
        9,
        12,
        7,
        0,
        2,
        1,
        13,
        10,
        12,
        6,
        0,
        9,
        5,
        11,
        10,
        5,
        0,
        13,
        14,
        8,
        7,
        10,
        11,
        1,
        10,
        3,
        4,
        15,
        13,
        4,
        1,
        2,
        5,
        11,
        8,
        6,
        12,
        7,
        6,
        12,
        9,
        0,
        3,
        5,
        2,
        14,
        15,
        9,
        10,
        13,
        0,
        7,
        9,
        0,
        14,
        9,
        6,
        3,
        3,
        4,
        15,
        6,
        5,
        10,
        1,
        2,
        13,
        8,
        12,
        5,
        7,
        14,
        11,
        12,
        4,
        11,
        2,
        15,
        8,
        1,
        13,
        1,
        6,
        10,
        4,
        13,
        9,
        0,
        8,
        6,
        15,
        9,
        3,
        8,
        0,
        7,
        11,
        4,
        1,
        15,
        2,
        14,
        12,
        3,
        5,
        11,
        10,
        5,
        14,
        2,
        7,
        12,
        7,
        13,
        13,
        8,
        14,
        11,
        3,
        5,
        0,
        6,
        6,
        15,
        9,
        0,
        10,
        3,
        1,
        4,
        2,
        7,
        8,
        2,
        5,
        12,
        11,
        1,
        12,
        10,
        4,
        14,
        15,
        9,
        10,
        3,
        6,
        15,
        9,
        0,
        0,
        6,
        12,
        10,
        11,
        1,
        7,
        13,
        13,
        8,
        15,
        9,
        1,
        4,
        3,
        5,
        14,
        11,
        5,
        12,
        2,
        7,
        8,
        2,
        4,
        14,
        2,
        14,
        12,
        11,
        4,
        2,
        1,
        12,
        7,
        4,
        10,
        7,
        11,
        13,
        6,
        1,
        8,
        5,
        5,
        0,
        3,
        15,
        15,
        10,
        13,
        3,
        0,
        9,
        14,
        8,
        9,
        6,
        4,
        11,
        2,
        8,
        1,
        12,
        11,
        7,
        10,
        1,
        13,
        14,
        7,
        2,
        8,
        13,
        15,
        6,
        9,
        15,
        12,
        0,
        5,
        9,
        6,
        10,
        3,
        4,
        0,
        5,
        14,
        3,
        12,
        10,
        1,
        15,
        10,
        4,
        15,
        2,
        9,
        7,
        2,
        12,
        6,
        9,
        8,
        5,
        0,
        6,
        13,
        1,
        3,
        13,
        4,
        14,
        14,
        0,
        7,
        11,
        5,
        3,
        11,
        8,
        9,
        4,
        14,
        3,
        15,
        2,
        5,
        12,
        2,
        9,
        8,
        5,
        12,
        15,
        3,
        10,
        7,
        11,
        0,
        14,
        4,
        1,
        10,
        7,
        1,
        6,
        13,
        0,
        11,
        8,
        6,
        13,
        4,
        13,
        11,
        0,
        2,
        11,
        14,
        7,
        15,
        4,
        0,
        9,
        8,
        1,
        13,
        10,
        3,
        14,
        12,
        3,
        9,
        5,
        7,
        12,
        5,
        2,
        10,
        15,
        6,
        8,
        1,
        6,
        1,
        6,
        4,
        11,
        11,
        13,
        13,
        8,
        12,
        1,
        3,
        4,
        7,
        10,
        14,
        7,
        10,
        9,
        15,
        5,
        6,
        0,
        8,
        15,
        0,
        14,
        5,
        2,
        9,
        3,
        2,
        12,
        13,
        1,
        2,
        15,
        8,
        13,
        4,
        8,
        6,
        10,
        15,
        3,
        11,
        7,
        1,
        4,
        10,
        12,
        9,
        5,
        3,
        6,
        14,
        11,
        5,
        0,
        0,
        14,
        12,
        9,
        7,
        2,
        7,
        2,
        11,
        1,
        4,
        14,
        1,
        7,
        9,
        4,
        12,
        10,
        14,
        8,
        2,
        13,
        0,
        15,
        6,
        12,
        10,
        9,
        13,
        0,
        15,
        3,
        3,
        5,
        5,
        6,
        8,
        11
    ];
    Lo.substitute = function(n, i1) {
        for(var o = 0, a = 0; a < 4; a++){
            var s = n >>> 18 - a * 6 & 63, c = t[a * 64 + s];
            o <<= 4, o |= c;
        }
        for(var a = 0; a < 4; a++){
            var s = i1 >>> 18 - a * 6 & 63, c = t[4 * 64 + a * 64 + s];
            o <<= 4, o |= c;
        }
        return o >>> 0;
    };
    var r = [
        16,
        25,
        12,
        11,
        3,
        20,
        4,
        15,
        31,
        17,
        9,
        6,
        27,
        14,
        1,
        22,
        30,
        24,
        8,
        18,
        0,
        5,
        29,
        23,
        13,
        19,
        2,
        26,
        10,
        21,
        28,
        7
    ];
    return Lo.permute = function(n) {
        for(var i1 = 0, o = 0; o < r.length; o++)i1 <<= 1, i1 |= n >>> r[o] & 1;
        return i1 >>> 0;
    }, Lo.padSplit = function(n, i1, o) {
        for(var a = n.toString(2); a.length < i1;)a = "0" + a;
        for(var s = [], c = 0; c < i1; c += o)s.push(a.slice(c, c + o));
        return s.join(" ");
    }, Lo;
}
var ZA, fx;
function Ua() {
    if (fx) return ZA;
    fx = 1, ZA = e;
    function e(t, r) {
        if (!t) throw new Error(r || "Assertion failed");
    }
    return e.equal = function(t, r, n) {
        if (t != r) throw new Error(n || "Assertion failed: " + t + " != " + r);
    }, ZA;
}
var XA, dx;
function $6() {
    if (dx) return XA;
    dx = 1;
    var e = Ua();
    function t(r) {
        this.options = r, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = r.padding !== !1;
    }
    return XA = t, t.prototype._init = function() {}, t.prototype.update = function(r) {
        return r.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(r) : this._updateEncrypt(r);
    }, t.prototype._buffer = function(r, n) {
        for(var i1 = Math.min(this.buffer.length - this.bufferOff, r.length - n), o = 0; o < i1; o++)this.buffer[this.bufferOff + o] = r[n + o];
        return this.bufferOff += i1, i1;
    }, t.prototype._flushBuffer = function(r, n) {
        return this._update(this.buffer, 0, r, n), this.bufferOff = 0, this.blockSize;
    }, t.prototype._updateEncrypt = function(r) {
        var n = 0, i1 = 0, o = (this.bufferOff + r.length) / this.blockSize | 0, a = new Array(o * this.blockSize);
        this.bufferOff !== 0 && (n += this._buffer(r, n), this.bufferOff === this.buffer.length && (i1 += this._flushBuffer(a, i1)));
        for(var s = r.length - (r.length - n) % this.blockSize; n < s; n += this.blockSize)this._update(r, n, a, i1), i1 += this.blockSize;
        for(; n < r.length; n++, this.bufferOff++)this.buffer[this.bufferOff] = r[n];
        return a;
    }, t.prototype._updateDecrypt = function(r) {
        for(var n = 0, i1 = 0, o = Math.ceil((this.bufferOff + r.length) / this.blockSize) - 1, a = new Array(o * this.blockSize); o > 0; o--)n += this._buffer(r, n), i1 += this._flushBuffer(a, i1);
        return n += this._buffer(r, n), a;
    }, t.prototype.final = function(r) {
        var n;
        r && (n = this.update(r));
        var i1;
        return this.type === "encrypt" ? i1 = this._finalEncrypt() : i1 = this._finalDecrypt(), n ? n.concat(i1) : i1;
    }, t.prototype._pad = function(r, n) {
        if (n === 0) return !1;
        for(; n < r.length;)r[n++] = 0;
        return !0;
    }, t.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff)) return [];
        var r = new Array(this.blockSize);
        return this._update(this.buffer, 0, r, 0), r;
    }, t.prototype._unpad = function(r) {
        return r;
    }, t.prototype._finalDecrypt = function() {
        e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var r = new Array(this.blockSize);
        return this._flushBuffer(r, 0), this._unpad(r);
    }, XA;
}
var YA, hx;
function EC() {
    if (hx) return YA;
    hx = 1;
    var e = Ua(), t = Nr(), r = vC(), n = $6();
    function i1() {
        this.tmp = new Array(2), this.keys = null;
    }
    function o(s) {
        n.call(this, s);
        var c = new i1();
        this._desState = c, this.deriveKeys(c, s.key);
    }
    t(o, n), YA = o, o.create = function(s) {
        return new o(s);
    };
    var a = [
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1
    ];
    return o.prototype.deriveKeys = function(s, c) {
        s.keys = new Array(16 * 2), e.equal(c.length, this.blockSize, "Invalid key length");
        var l = r.readUInt32BE(c, 0), u = r.readUInt32BE(c, 4);
        r.pc1(l, u, s.tmp, 0), l = s.tmp[0], u = s.tmp[1];
        for(var f = 0; f < s.keys.length; f += 2){
            var h = a[f >>> 1];
            l = r.r28shl(l, h), u = r.r28shl(u, h), r.pc2(l, u, s.keys, f);
        }
    }, o.prototype._update = function(s, c, l, u) {
        var f = this._desState, h = r.readUInt32BE(s, c), y = r.readUInt32BE(s, c + 4);
        r.ip(h, y, f.tmp, 0), h = f.tmp[0], y = f.tmp[1], this.type === "encrypt" ? this._encrypt(f, h, y, f.tmp, 0) : this._decrypt(f, h, y, f.tmp, 0), h = f.tmp[0], y = f.tmp[1], r.writeUInt32BE(l, h, u), r.writeUInt32BE(l, y, u + 4);
    }, o.prototype._pad = function(s, c) {
        if (this.padding === !1) return !1;
        for(var l = s.length - c, u = c; u < s.length; u++)s[u] = l;
        return !0;
    }, o.prototype._unpad = function(s) {
        if (this.padding === !1) return s;
        for(var c = s[s.length - 1], l = s.length - c; l < s.length; l++)e.equal(s[l], c);
        return s.slice(0, s.length - c);
    }, o.prototype._encrypt = function(s, c, l, u, f) {
        for(var h = c, y = l, S = 0; S < s.keys.length; S += 2){
            var k = s.keys[S], P = s.keys[S + 1];
            r.expand(y, s.tmp, 0), k ^= s.tmp[0], P ^= s.tmp[1];
            var M = r.substitute(k, P), N = r.permute(M), z = y;
            y = (h ^ N) >>> 0, h = z;
        }
        r.rip(y, h, u, f);
    }, o.prototype._decrypt = function(s, c, l, u, f) {
        for(var h = l, y = c, S = s.keys.length - 2; S >= 0; S -= 2){
            var k = s.keys[S], P = s.keys[S + 1];
            r.expand(h, s.tmp, 0), k ^= s.tmp[0], P ^= s.tmp[1];
            var M = r.substitute(k, P), N = r.permute(M), z = h;
            h = (y ^ N) >>> 0, y = z;
        }
        r.rip(h, y, u, f);
    }, YA;
}
var JA = {}, px;
function oJ() {
    if (px) return JA;
    px = 1;
    var e = Ua(), t = Nr(), r = {};
    function n(o) {
        e.equal(o.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for(var a = 0; a < this.iv.length; a++)this.iv[a] = o[a];
    }
    function i1(o) {
        function a(u) {
            o.call(this, u), this._cbcInit();
        }
        t(a, o);
        for(var s = Object.keys(r), c = 0; c < s.length; c++){
            var l = s[c];
            a.prototype[l] = r[l];
        }
        return a.create = function(u) {
            return new a(u);
        }, a;
    }
    return JA.instantiate = i1, r._cbcInit = function() {
        var o = new n(this.options.iv);
        this._cbcState = o;
    }, r._update = function(o, a, s, c) {
        var l = this._cbcState, u = this.constructor.super_.prototype, f = l.iv;
        if (this.type === "encrypt") {
            for(var h = 0; h < this.blockSize; h++)f[h] ^= o[a + h];
            u._update.call(this, f, 0, s, c);
            for(var h = 0; h < this.blockSize; h++)f[h] = s[c + h];
        } else {
            u._update.call(this, o, a, s, c);
            for(var h = 0; h < this.blockSize; h++)s[c + h] ^= f[h];
            for(var h = 0; h < this.blockSize; h++)f[h] = o[a + h];
        }
    }, JA;
}
var ev, gx;
function aJ() {
    if (gx) return ev;
    gx = 1;
    var e = Ua(), t = Nr(), r = $6(), n = EC();
    function i1(a, s) {
        e.equal(s.length, 24, "Invalid key length");
        var c = s.slice(0, 8), l = s.slice(8, 16), u = s.slice(16, 24);
        a === "encrypt" ? this.ciphers = [
            n.create({
                type: "encrypt",
                key: c
            }),
            n.create({
                type: "decrypt",
                key: l
            }),
            n.create({
                type: "encrypt",
                key: u
            })
        ] : this.ciphers = [
            n.create({
                type: "decrypt",
                key: u
            }),
            n.create({
                type: "encrypt",
                key: l
            }),
            n.create({
                type: "decrypt",
                key: c
            })
        ];
    }
    function o(a) {
        r.call(this, a);
        var s = new i1(this.type, this.options.key);
        this._edeState = s;
    }
    return t(o, r), ev = o, o.create = function(a) {
        return new o(a);
    }, o.prototype._update = function(a, s, c, l) {
        var u = this._edeState;
        u.ciphers[0]._update(a, s, c, l), u.ciphers[1]._update(c, l, c, l), u.ciphers[2]._update(c, l, c, l);
    }, o.prototype._pad = n.prototype._pad, o.prototype._unpad = n.prototype._unpad, ev;
}
var yx;
function sJ() {
    return yx || (yx = 1, fd.utils = vC(), fd.Cipher = $6(), fd.DES = EC(), fd.CBC = oJ(), fd.EDE = aJ()), fd;
}
var tv, mx;
function uJ() {
    if (mx) return tv;
    mx = 1;
    var e = ll(), t = sJ(), r = Nr(), n = Br().Buffer, i1 = {
        "des-ede3-cbc": t.CBC.instantiate(t.EDE),
        "des-ede3": t.EDE,
        "des-ede-cbc": t.CBC.instantiate(t.EDE),
        "des-ede": t.EDE,
        "des-cbc": t.CBC.instantiate(t.DES),
        "des-ecb": t.DES
    };
    i1.des = i1["des-cbc"], i1.des3 = i1["des-ede3-cbc"], tv = o, r(o, e);
    function o(a) {
        e.call(this);
        var s = a.mode.toLowerCase(), c = i1[s], l;
        a.decrypt ? l = "decrypt" : l = "encrypt";
        var u = a.key;
        n.isBuffer(u) || (u = n.from(u)), (s === "des-ede" || s === "des-ede-cbc") && (u = n.concat([
            u,
            u.slice(0, 8)
        ]));
        var f = a.iv;
        n.isBuffer(f) || (f = n.from(f)), this._des = c.create({
            key: u,
            iv: f,
            type: l
        });
    }
    return o.prototype._update = function(a) {
        return n.from(this._des.update(a));
    }, o.prototype._final = function() {
        return n.from(this._des.final());
    }, tv;
}
var ha = {}, Xg = {}, rv = {}, bx;
function cJ() {
    return bx || (bx = 1, rv.encrypt = function(e, t) {
        return e._cipher.encryptBlock(t);
    }, rv.decrypt = function(e, t) {
        return e._cipher.decryptBlock(t);
    }), rv;
}
var Yg = {}, wx, Ax;
function w1() {
    return Ax || (Ax = 1, wx = function(e, t) {
        for(var r = Math.min(e.length, t.length), n = new Ke(r), i1 = 0; i1 < r; ++i1)n[i1] = e[i1] ^ t[i1];
        return n;
    }), wx;
}
var vx;
function lJ() {
    if (vx) return Yg;
    vx = 1;
    var e = w1();
    return Yg.encrypt = function(t, r) {
        var n = e(r, t._prev);
        return t._prev = t._cipher.encryptBlock(n), t._prev;
    }, Yg.decrypt = function(t, r) {
        var n = t._prev;
        t._prev = r;
        var i1 = t._cipher.decryptBlock(r);
        return e(i1, n);
    }, Yg;
}
var nv = {}, Ex;
function fJ() {
    if (Ex) return nv;
    Ex = 1;
    var e = Br().Buffer, t = w1();
    function r(n, i1, o) {
        var a = i1.length, s = t(i1, n._cache);
        return n._cache = n._cache.slice(a), n._prev = e.concat([
            n._prev,
            o ? i1 : s
        ]), s;
    }
    return nv.encrypt = function(n, i1, o) {
        for(var a = e.allocUnsafe(0), s; i1.length;)if (n._cache.length === 0 && (n._cache = n._cipher.encryptBlock(n._prev), n._prev = e.allocUnsafe(0)), n._cache.length <= i1.length) s = n._cache.length, a = e.concat([
            a,
            r(n, i1.slice(0, s), o)
        ]), i1 = i1.slice(s);
        else {
            a = e.concat([
                a,
                r(n, i1, o)
            ]);
            break;
        }
        return a;
    }, nv;
}
var iv = {}, Sx;
function dJ() {
    if (Sx) return iv;
    Sx = 1;
    var e = Br().Buffer;
    function t(r, n, i1) {
        var o = r._cipher.encryptBlock(r._prev), a = o[0] ^ n;
        return r._prev = e.concat([
            r._prev.slice(1),
            e.from([
                i1 ? n : a
            ])
        ]), a;
    }
    return iv.encrypt = function(r, n, i1) {
        for(var o = n.length, a = e.allocUnsafe(o), s = -1; ++s < o;)a[s] = t(r, n[s], i1);
        return a;
    }, iv;
}
var ov = {}, xx;
function hJ() {
    if (xx) return ov;
    xx = 1;
    var e = Br().Buffer;
    function t(n, i1, o) {
        for(var a, s = -1, c = 8, l = 0, u, f; ++s < c;)a = n._cipher.encryptBlock(n._prev), u = i1 & 1 << 7 - s ? 128 : 0, f = a[0] ^ u, l += (f & 128) >> s % 8, n._prev = r(n._prev, o ? u : f);
        return l;
    }
    function r(n, i1) {
        var o = n.length, a = -1, s = e.allocUnsafe(n.length);
        for(n = e.concat([
            n,
            e.from([
                i1
            ])
        ]); ++a < o;)s[a] = n[a] << 1 | n[a + 1] >> 7;
        return s;
    }
    return ov.encrypt = function(n, i1, o) {
        for(var a = i1.length, s = e.allocUnsafe(a), c = -1; ++c < a;)s[c] = t(n, i1[c], o);
        return s;
    }, ov;
}
var av = {}, _x;
function pJ() {
    if (_x) return av;
    _x = 1;
    var e = w1();
    function t(r) {
        return r._prev = r._cipher.encryptBlock(r._prev), r._prev;
    }
    return av.encrypt = function(r, n) {
        for(; r._cache.length < n.length;)r._cache = Ke.concat([
            r._cache,
            t(r)
        ]);
        var i1 = r._cache.slice(0, n.length);
        return r._cache = r._cache.slice(n.length), e(n, i1);
    }, av;
}
var sv = {}, uv, kx;
function SC() {
    if (kx) return uv;
    kx = 1;
    function e(t) {
        for(var r = t.length, n; r--;)if (n = t.readUInt8(r), n === 255) t.writeUInt8(0, r);
        else {
            n++, t.writeUInt8(n, r);
            break;
        }
    }
    return uv = e, uv;
}
var Ox;
function Ix() {
    if (Ox) return sv;
    Ox = 1;
    var e = w1(), t = Br().Buffer, r = SC();
    function n(o) {
        var a = o._cipher.encryptBlockRaw(o._prev);
        return r(o._prev), a;
    }
    var i1 = 16;
    return sv.encrypt = function(o, a) {
        var s = Math.ceil(a.length / i1), c = o._cache.length;
        o._cache = t.concat([
            o._cache,
            t.allocUnsafe(s * i1)
        ]);
        for(var l = 0; l < s; l++){
            var u = n(o), f = c + l * i1;
            o._cache.writeUInt32BE(u[0], f + 0), o._cache.writeUInt32BE(u[1], f + 4), o._cache.writeUInt32BE(u[2], f + 8), o._cache.writeUInt32BE(u[3], f + 12);
        }
        var h = o._cache.slice(0, a.length);
        return o._cache = o._cache.slice(a.length), e(a, h);
    }, sv;
}
const gJ = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
}, yJ = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
}, mJ = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
}, xC = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128: gJ,
    aes192: yJ,
    aes256: mJ,
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
};
var cv, Bx;
function Z6() {
    if (Bx) return cv;
    Bx = 1;
    var e = {
        ECB: cJ(),
        CBC: lJ(),
        CFB: fJ(),
        CFB8: dJ(),
        CFB1: hJ(),
        OFB: pJ(),
        CTR: Ix(),
        GCM: Ix()
    }, t = xC;
    for(var r in t)t[r].module = e[t[r].mode];
    return cv = t, cv;
}
var lv = {}, Tx;
function H2() {
    if (Tx) return lv;
    Tx = 1;
    var e = Br().Buffer;
    function t(s) {
        e.isBuffer(s) || (s = e.from(s));
        for(var c = s.length / 4 | 0, l = new Array(c), u = 0; u < c; u++)l[u] = s.readUInt32BE(u * 4);
        return l;
    }
    function r(s) {
        for(var c = 0; c < s.length; s++)s[c] = 0;
    }
    function n(s, c, l, u, f) {
        for(var h = l[0], y = l[1], S = l[2], k = l[3], P = s[0] ^ c[0], M = s[1] ^ c[1], N = s[2] ^ c[2], z = s[3] ^ c[3], K, $, ne, ee, q = 4, U = 1; U < f; U++)K = h[P >>> 24] ^ y[M >>> 16 & 255] ^ S[N >>> 8 & 255] ^ k[z & 255] ^ c[q++], $ = h[M >>> 24] ^ y[N >>> 16 & 255] ^ S[z >>> 8 & 255] ^ k[P & 255] ^ c[q++], ne = h[N >>> 24] ^ y[z >>> 16 & 255] ^ S[P >>> 8 & 255] ^ k[M & 255] ^ c[q++], ee = h[z >>> 24] ^ y[P >>> 16 & 255] ^ S[M >>> 8 & 255] ^ k[N & 255] ^ c[q++], P = K, M = $, N = ne, z = ee;
        return K = (u[P >>> 24] << 24 | u[M >>> 16 & 255] << 16 | u[N >>> 8 & 255] << 8 | u[z & 255]) ^ c[q++], $ = (u[M >>> 24] << 24 | u[N >>> 16 & 255] << 16 | u[z >>> 8 & 255] << 8 | u[P & 255]) ^ c[q++], ne = (u[N >>> 24] << 24 | u[z >>> 16 & 255] << 16 | u[P >>> 8 & 255] << 8 | u[M & 255]) ^ c[q++], ee = (u[z >>> 24] << 24 | u[P >>> 16 & 255] << 16 | u[M >>> 8 & 255] << 8 | u[N & 255]) ^ c[q++], K = K >>> 0, $ = $ >>> 0, ne = ne >>> 0, ee = ee >>> 0, [
            K,
            $,
            ne,
            ee
        ];
    }
    var i1 = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], o = function() {
        for(var s = new Array(256), c = 0; c < 256; c++)c < 128 ? s[c] = c << 1 : s[c] = c << 1 ^ 283;
        for(var l = [], u = [], f = [
            [],
            [],
            [],
            []
        ], h = [
            [],
            [],
            [],
            []
        ], y = 0, S = 0, k = 0; k < 256; ++k){
            var P = S ^ S << 1 ^ S << 2 ^ S << 3 ^ S << 4;
            P = P >>> 8 ^ P & 255 ^ 99, l[y] = P, u[P] = y;
            var M = s[y], N = s[M], z = s[N], K = s[P] * 257 ^ P * 16843008;
            f[0][y] = K << 24 | K >>> 8, f[1][y] = K << 16 | K >>> 16, f[2][y] = K << 8 | K >>> 24, f[3][y] = K, K = z * 16843009 ^ N * 65537 ^ M * 257 ^ y * 16843008, h[0][P] = K << 24 | K >>> 8, h[1][P] = K << 16 | K >>> 16, h[2][P] = K << 8 | K >>> 24, h[3][P] = K, y === 0 ? y = S = 1 : (y = M ^ s[s[s[z ^ M]]], S ^= s[s[S]]);
        }
        return {
            SBOX: l,
            INV_SBOX: u,
            SUB_MIX: f,
            INV_SUB_MIX: h
        };
    }();
    function a(s) {
        this._key = t(s), this._reset();
    }
    return a.blockSize = 4 * 4, a.keySize = 256 / 8, a.prototype.blockSize = a.blockSize, a.prototype.keySize = a.keySize, a.prototype._reset = function() {
        for(var s = this._key, c = s.length, l = c + 6, u = (l + 1) * 4, f = [], h = 0; h < c; h++)f[h] = s[h];
        for(h = c; h < u; h++){
            var y = f[h - 1];
            h % c === 0 ? (y = y << 8 | y >>> 24, y = o.SBOX[y >>> 24] << 24 | o.SBOX[y >>> 16 & 255] << 16 | o.SBOX[y >>> 8 & 255] << 8 | o.SBOX[y & 255], y ^= i1[h / c | 0] << 24) : c > 6 && h % c === 4 && (y = o.SBOX[y >>> 24] << 24 | o.SBOX[y >>> 16 & 255] << 16 | o.SBOX[y >>> 8 & 255] << 8 | o.SBOX[y & 255]), f[h] = f[h - c] ^ y;
        }
        for(var S = [], k = 0; k < u; k++){
            var P = u - k, M = f[P - (k % 4 ? 0 : 4)];
            k < 4 || P <= 4 ? S[k] = M : S[k] = o.INV_SUB_MIX[0][o.SBOX[M >>> 24]] ^ o.INV_SUB_MIX[1][o.SBOX[M >>> 16 & 255]] ^ o.INV_SUB_MIX[2][o.SBOX[M >>> 8 & 255]] ^ o.INV_SUB_MIX[3][o.SBOX[M & 255]];
        }
        this._nRounds = l, this._keySchedule = f, this._invKeySchedule = S;
    }, a.prototype.encryptBlockRaw = function(s) {
        return s = t(s), n(s, this._keySchedule, o.SUB_MIX, o.SBOX, this._nRounds);
    }, a.prototype.encryptBlock = function(s) {
        var c = this.encryptBlockRaw(s), l = e.allocUnsafe(16);
        return l.writeUInt32BE(c[0], 0), l.writeUInt32BE(c[1], 4), l.writeUInt32BE(c[2], 8), l.writeUInt32BE(c[3], 12), l;
    }, a.prototype.decryptBlock = function(s) {
        s = t(s);
        var c = s[1];
        s[1] = s[3], s[3] = c;
        var l = n(s, this._invKeySchedule, o.INV_SUB_MIX, o.INV_SBOX, this._nRounds), u = e.allocUnsafe(16);
        return u.writeUInt32BE(l[0], 0), u.writeUInt32BE(l[3], 4), u.writeUInt32BE(l[2], 8), u.writeUInt32BE(l[1], 12), u;
    }, a.prototype.scrub = function() {
        r(this._keySchedule), r(this._invKeySchedule), r(this._key);
    }, lv.AES = a, lv;
}
var fv, Px;
function bJ() {
    if (Px) return fv;
    Px = 1;
    var e = Br().Buffer, t = e.alloc(16, 0);
    function r(o) {
        return [
            o.readUInt32BE(0),
            o.readUInt32BE(4),
            o.readUInt32BE(8),
            o.readUInt32BE(12)
        ];
    }
    function n(o) {
        var a = e.allocUnsafe(16);
        return a.writeUInt32BE(o[0] >>> 0, 0), a.writeUInt32BE(o[1] >>> 0, 4), a.writeUInt32BE(o[2] >>> 0, 8), a.writeUInt32BE(o[3] >>> 0, 12), a;
    }
    function i1(o) {
        this.h = o, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
    }
    return i1.prototype.ghash = function(o) {
        for(var a = -1; ++a < o.length;)this.state[a] ^= o[a];
        this._multiply();
    }, i1.prototype._multiply = function() {
        for(var o = r(this.h), a = [
            0,
            0,
            0,
            0
        ], s, c, l, u = -1; ++u < 128;){
            for(c = (this.state[~~(u / 8)] & 1 << 7 - u % 8) !== 0, c && (a[0] ^= o[0], a[1] ^= o[1], a[2] ^= o[2], a[3] ^= o[3]), l = (o[3] & 1) !== 0, s = 3; s > 0; s--)o[s] = o[s] >>> 1 | (o[s - 1] & 1) << 31;
            o[0] = o[0] >>> 1, l && (o[0] = o[0] ^ 225 << 24);
        }
        this.state = n(a);
    }, i1.prototype.update = function(o) {
        this.cache = e.concat([
            this.cache,
            o
        ]);
        for(var a; this.cache.length >= 16;)a = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(a);
    }, i1.prototype.final = function(o, a) {
        return this.cache.length && this.ghash(e.concat([
            this.cache,
            t
        ], 16)), this.ghash(n([
            0,
            o,
            0,
            a
        ])), this.state;
    }, fv = i1, fv;
}
var dv, Cx;
function _C() {
    if (Cx) return dv;
    Cx = 1;
    var e = H2(), t = Br().Buffer, r = ll(), n = Nr(), i1 = bJ(), o = w1(), a = SC();
    function s(u, f) {
        var h = 0;
        u.length !== f.length && h++;
        for(var y = Math.min(u.length, f.length), S = 0; S < y; ++S)h += u[S] ^ f[S];
        return h;
    }
    function c(u, f, h) {
        if (f.length === 12) return u._finID = t.concat([
            f,
            t.from([
                0,
                0,
                0,
                1
            ])
        ]), t.concat([
            f,
            t.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var y = new i1(h), S = f.length, k = S % 16;
        y.update(f), k && (k = 16 - k, y.update(t.alloc(k, 0))), y.update(t.alloc(8, 0));
        var P = S * 8, M = t.alloc(8);
        M.writeUIntBE(P, 0, 8), y.update(M), u._finID = y.state;
        var N = t.from(u._finID);
        return a(N), N;
    }
    function l(u, f, h, y) {
        r.call(this);
        var S = t.alloc(4, 0);
        this._cipher = new e.AES(f);
        var k = this._cipher.encryptBlock(S);
        this._ghash = new i1(k), h = c(this, h, k), this._prev = t.from(h), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = y, this._alen = 0, this._len = 0, this._mode = u, this._authTag = null, this._called = !1;
    }
    return n(l, r), l.prototype._update = function(u) {
        if (!this._called && this._alen) {
            var f = 16 - this._alen % 16;
            f < 16 && (f = t.alloc(f, 0), this._ghash.update(f));
        }
        this._called = !0;
        var h = this._mode.encrypt(this, u);
        return this._decrypt ? this._ghash.update(u) : this._ghash.update(h), this._len += u.length, h;
    }, l.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var u = o(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && s(u, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = u, this._cipher.scrub();
    }, l.prototype.getAuthTag = function() {
        if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    }, l.prototype.setAuthTag = function(u) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = u;
    }, l.prototype.setAAD = function(u) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(u), this._alen += u.length;
    }, dv = l, dv;
}
var hv, Mx;
function kC() {
    if (Mx) return hv;
    Mx = 1;
    var e = H2(), t = Br().Buffer, r = ll(), n = Nr();
    function i1(o, a, s, c) {
        r.call(this), this._cipher = new e.AES(a), this._prev = t.from(s), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = c, this._mode = o;
    }
    return n(i1, r), i1.prototype._update = function(o) {
        return this._mode.encrypt(this, o, this._decrypt);
    }, i1.prototype._final = function() {
        this._cipher.scrub();
    }, hv = i1, hv;
}
var pv, Nx;
function K2() {
    if (Nx) return pv;
    Nx = 1;
    var e = Br().Buffer, t = W6();
    function r(n, i1, o, a) {
        if (e.isBuffer(n) || (n = e.from(n, "binary")), i1 && (e.isBuffer(i1) || (i1 = e.from(i1, "binary")), i1.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
        for(var s = o / 8, c = e.alloc(s), l = e.alloc(a || 0), u = e.alloc(0); s > 0 || a > 0;){
            var f = new t();
            f.update(u), f.update(n), i1 && f.update(i1), u = f.digest();
            var h = 0;
            if (s > 0) {
                var y = c.length - s;
                h = Math.min(s, u.length), u.copy(c, y, 0, h), s -= h;
            }
            if (h < u.length && a > 0) {
                var S = l.length - a, k = Math.min(a, u.length - h);
                u.copy(l, S, h, h + k), a -= k;
            }
        }
        return u.fill(0), {
            key: c,
            iv: l
        };
    }
    return pv = r, pv;
}
var Rx;
function wJ() {
    if (Rx) return Xg;
    Rx = 1;
    var e = Z6(), t = _C(), r = Br().Buffer, n = kC(), i1 = ll(), o = H2(), a = K2(), s = Nr();
    function c(y, S, k) {
        i1.call(this), this._cache = new u(), this._cipher = new o.AES(S), this._prev = r.from(k), this._mode = y, this._autopadding = !0;
    }
    s(c, i1), c.prototype._update = function(y) {
        this._cache.add(y);
        for(var S, k, P = []; S = this._cache.get();)k = this._mode.encrypt(this, S), P.push(k);
        return r.concat(P);
    };
    var l = r.alloc(16, 16);
    c.prototype._final = function() {
        var y = this._cache.flush();
        if (this._autopadding) return y = this._mode.encrypt(this, y), this._cipher.scrub(), y;
        if (!y.equals(l)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    }, c.prototype.setAutoPadding = function(y) {
        return this._autopadding = !!y, this;
    };
    function u() {
        this.cache = r.allocUnsafe(0);
    }
    u.prototype.add = function(y) {
        this.cache = r.concat([
            this.cache,
            y
        ]);
    }, u.prototype.get = function() {
        if (this.cache.length > 15) {
            var y = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), y;
        }
        return null;
    }, u.prototype.flush = function() {
        for(var y = 16 - this.cache.length, S = r.allocUnsafe(y), k = -1; ++k < y;)S.writeUInt8(y, k);
        return r.concat([
            this.cache,
            S
        ]);
    };
    function f(y, S, k) {
        var P = e[y.toLowerCase()];
        if (!P) throw new TypeError("invalid suite type");
        if (typeof S == "string" && (S = r.from(S)), S.length !== P.key / 8) throw new TypeError("invalid key length " + S.length);
        if (typeof k == "string" && (k = r.from(k)), P.mode !== "GCM" && k.length !== P.iv) throw new TypeError("invalid iv length " + k.length);
        return P.type === "stream" ? new n(P.module, S, k) : P.type === "auth" ? new t(P.module, S, k) : new c(P.module, S, k);
    }
    function h(y, S) {
        var k = e[y.toLowerCase()];
        if (!k) throw new TypeError("invalid suite type");
        var P = a(S, !1, k.key, k.iv);
        return f(y, P.key, P.iv);
    }
    return Xg.createCipheriv = f, Xg.createCipher = h, Xg;
}
var Jg = {}, Ux;
function AJ() {
    if (Ux) return Jg;
    Ux = 1;
    var e = _C(), t = Br().Buffer, r = Z6(), n = kC(), i1 = ll(), o = H2(), a = K2(), s = Nr();
    function c(y, S, k) {
        i1.call(this), this._cache = new l(), this._last = void 0, this._cipher = new o.AES(S), this._prev = t.from(k), this._mode = y, this._autopadding = !0;
    }
    s(c, i1), c.prototype._update = function(y) {
        this._cache.add(y);
        for(var S, k, P = []; S = this._cache.get(this._autopadding);)k = this._mode.decrypt(this, S), P.push(k);
        return t.concat(P);
    }, c.prototype._final = function() {
        var y = this._cache.flush();
        if (this._autopadding) return u(this._mode.decrypt(this, y));
        if (y) throw new Error("data not multiple of block length");
    }, c.prototype.setAutoPadding = function(y) {
        return this._autopadding = !!y, this;
    };
    function l() {
        this.cache = t.allocUnsafe(0);
    }
    l.prototype.add = function(y) {
        this.cache = t.concat([
            this.cache,
            y
        ]);
    }, l.prototype.get = function(y) {
        var S;
        if (y) {
            if (this.cache.length > 16) return S = this.cache.slice(0, 16), this.cache = this.cache.slice(16), S;
        } else if (this.cache.length >= 16) return S = this.cache.slice(0, 16), this.cache = this.cache.slice(16), S;
        return null;
    }, l.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function u(y) {
        var S = y[15];
        if (S < 1 || S > 16) throw new Error("unable to decrypt data");
        for(var k = -1; ++k < S;)if (y[k + (16 - S)] !== S) throw new Error("unable to decrypt data");
        if (S !== 16) return y.slice(0, 16 - S);
    }
    function f(y, S, k) {
        var P = r[y.toLowerCase()];
        if (!P) throw new TypeError("invalid suite type");
        if (typeof k == "string" && (k = t.from(k)), P.mode !== "GCM" && k.length !== P.iv) throw new TypeError("invalid iv length " + k.length);
        if (typeof S == "string" && (S = t.from(S)), S.length !== P.key / 8) throw new TypeError("invalid key length " + S.length);
        return P.type === "stream" ? new n(P.module, S, k, !0) : P.type === "auth" ? new e(P.module, S, k, !0) : new c(P.module, S, k);
    }
    function h(y, S) {
        var k = r[y.toLowerCase()];
        if (!k) throw new TypeError("invalid suite type");
        var P = a(S, !1, k.key, k.iv);
        return f(y, P.key, P.iv);
    }
    return Jg.createDecipher = h, Jg.createDecipheriv = f, Jg;
}
var Dx;
function X6() {
    if (Dx) return ha;
    Dx = 1;
    var e = wJ(), t = AJ(), r = xC;
    function n() {
        return Object.keys(r);
    }
    return ha.createCipher = ha.Cipher = e.createCipher, ha.createCipheriv = ha.Cipheriv = e.createCipheriv, ha.createDecipher = ha.Decipher = t.createDecipher, ha.createDecipheriv = ha.Decipheriv = t.createDecipheriv, ha.listCiphers = ha.getCiphers = n, ha;
}
var jx = {}, Fx;
function vJ() {
    return Fx || (Fx = 1, function(e) {
        e["des-ecb"] = {
            key: 8,
            iv: 0
        }, e["des-cbc"] = e.des = {
            key: 8,
            iv: 8
        }, e["des-ede3-cbc"] = e.des3 = {
            key: 24,
            iv: 8
        }, e["des-ede3"] = {
            key: 24,
            iv: 0
        }, e["des-ede-cbc"] = {
            key: 16,
            iv: 8
        }, e["des-ede"] = {
            key: 16,
            iv: 0
        };
    }(jx)), jx;
}
var zx;
function EJ() {
    if (zx) return da;
    zx = 1;
    var e = uJ(), t = X6(), r = Z6(), n = vJ(), i1 = K2();
    function o(u, f) {
        u = u.toLowerCase();
        var h, y;
        if (r[u]) h = r[u].key, y = r[u].iv;
        else if (n[u]) h = n[u].key * 8, y = n[u].iv;
        else throw new TypeError("invalid suite type");
        var S = i1(f, !1, h, y);
        return s(u, S.key, S.iv);
    }
    function a(u, f) {
        u = u.toLowerCase();
        var h, y;
        if (r[u]) h = r[u].key, y = r[u].iv;
        else if (n[u]) h = n[u].key * 8, y = n[u].iv;
        else throw new TypeError("invalid suite type");
        var S = i1(f, !1, h, y);
        return c(u, S.key, S.iv);
    }
    function s(u, f, h) {
        if (u = u.toLowerCase(), r[u]) return t.createCipheriv(u, f, h);
        if (n[u]) return new e({
            key: f,
            iv: h,
            mode: u
        });
        throw new TypeError("invalid suite type");
    }
    function c(u, f, h) {
        if (u = u.toLowerCase(), r[u]) return t.createDecipheriv(u, f, h);
        if (n[u]) return new e({
            key: f,
            iv: h,
            mode: u,
            decrypt: !0
        });
        throw new TypeError("invalid suite type");
    }
    function l() {
        return Object.keys(n).concat(t.getCiphers());
    }
    return da.createCipher = da.Cipher = o, da.createCipheriv = da.Cipheriv = s, da.createDecipher = da.Decipher = a, da.createDecipheriv = da.Decipheriv = c, da.listCiphers = da.getCiphers = l, da;
}
var _l = {}, Lx = {
    exports: {}
}, Hx;
function Bi() {
    return Hx || (Hx = 1, function(e) {
        (function(t, r) {
            function n(v, B) {
                if (!v) throw new Error(B || "Assertion failed");
            }
            function i1(v, B) {
                v.super_ = B;
                var g = function() {};
                g.prototype = B.prototype, v.prototype = new g(), v.prototype.constructor = v;
            }
            function o(v, B, g) {
                if (o.isBN(v)) return v;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((B === "le" || B === "be") && (g = B, B = 10), this._init(v || 0, B || 10, g || "be"));
            }
            typeof t == "object" ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
            var a;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = cl.Buffer;
            } catch  {}
            o.isBN = function(v) {
                return v instanceof o ? !0 : v !== null && typeof v == "object" && v.constructor.wordSize === o.wordSize && Array.isArray(v.words);
            }, o.max = function(v, B) {
                return v.cmp(B) > 0 ? v : B;
            }, o.min = function(v, B) {
                return v.cmp(B) < 0 ? v : B;
            }, o.prototype._init = function(v, B, g) {
                if (typeof v == "number") return this._initNumber(v, B, g);
                if (typeof v == "object") return this._initArray(v, B, g);
                B === "hex" && (B = 16), n(B === (B | 0) && B >= 2 && B <= 36), v = v.toString().replace(/\s+/g, "");
                var E = 0;
                v[0] === "-" && (E++, this.negative = 1), E < v.length && (B === 16 ? this._parseHex(v, E, g) : (this._parseBase(v, B, E), g === "le" && this._initArray(this.toArray(), B, g)));
            }, o.prototype._initNumber = function(v, B, g) {
                v < 0 && (this.negative = 1, v = -v), v < 67108864 ? (this.words = [
                    v & 67108863
                ], this.length = 1) : v < 4503599627370496 ? (this.words = [
                    v & 67108863,
                    v / 67108864 & 67108863
                ], this.length = 2) : (n(v < 9007199254740992), this.words = [
                    v & 67108863,
                    v / 67108864 & 67108863,
                    1
                ], this.length = 3), g === "le" && this._initArray(this.toArray(), B, g);
            }, o.prototype._initArray = function(v, B, g) {
                if (n(typeof v.length == "number"), v.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(v.length / 3), this.words = new Array(this.length);
                for(var E = 0; E < this.length; E++)this.words[E] = 0;
                var w, _, O = 0;
                if (g === "be") for(E = v.length - 1, w = 0; E >= 0; E -= 3)_ = v[E] | v[E - 1] << 8 | v[E - 2] << 16, this.words[w] |= _ << O & 67108863, this.words[w + 1] = _ >>> 26 - O & 67108863, O += 24, O >= 26 && (O -= 26, w++);
                else if (g === "le") for(E = 0, w = 0; E < v.length; E += 3)_ = v[E] | v[E + 1] << 8 | v[E + 2] << 16, this.words[w] |= _ << O & 67108863, this.words[w + 1] = _ >>> 26 - O & 67108863, O += 24, O >= 26 && (O -= 26, w++);
                return this.strip();
            };
            function s(v, B) {
                var g = v.charCodeAt(B);
                return g >= 65 && g <= 70 ? g - 55 : g >= 97 && g <= 102 ? g - 87 : g - 48 & 15;
            }
            function c(v, B, g) {
                var E = s(v, g);
                return g - 1 >= B && (E |= s(v, g - 1) << 4), E;
            }
            o.prototype._parseHex = function(v, B, g) {
                this.length = Math.ceil((v.length - B) / 6), this.words = new Array(this.length);
                for(var E = 0; E < this.length; E++)this.words[E] = 0;
                var w = 0, _ = 0, O;
                if (g === "be") for(E = v.length - 1; E >= B; E -= 2)O = c(v, B, E) << w, this.words[_] |= O & 67108863, w >= 18 ? (w -= 18, _ += 1, this.words[_] |= O >>> 26) : w += 8;
                else {
                    var I = v.length - B;
                    for(E = I % 2 === 0 ? B + 1 : B; E < v.length; E += 2)O = c(v, B, E) << w, this.words[_] |= O & 67108863, w >= 18 ? (w -= 18, _ += 1, this.words[_] |= O >>> 26) : w += 8;
                }
                this.strip();
            };
            function l(v, B, g, E) {
                for(var w = 0, _ = Math.min(v.length, g), O = B; O < _; O++){
                    var I = v.charCodeAt(O) - 48;
                    w *= E, I >= 49 ? w += I - 49 + 10 : I >= 17 ? w += I - 17 + 10 : w += I;
                }
                return w;
            }
            o.prototype._parseBase = function(v, B, g) {
                this.words = [
                    0
                ], this.length = 1;
                for(var E = 0, w = 1; w <= 67108863; w *= B)E++;
                E--, w = w / B | 0;
                for(var _ = v.length - g, O = _ % E, I = Math.min(_, _ - O) + g, x = 0, R = g; R < I; R += E)x = l(v, R, R + E, B), this.imuln(w), this.words[0] + x < 67108864 ? this.words[0] += x : this._iaddn(x);
                if (O !== 0) {
                    var j = 1;
                    for(x = l(v, R, v.length, B), R = 0; R < O; R++)j *= B;
                    this.imuln(j), this.words[0] + x < 67108864 ? this.words[0] += x : this._iaddn(x);
                }
                this.strip();
            }, o.prototype.copy = function(v) {
                v.words = new Array(this.length);
                for(var B = 0; B < this.length; B++)v.words[B] = this.words[B];
                v.length = this.length, v.negative = this.negative, v.red = this.red;
            }, o.prototype.clone = function() {
                var v = new o(null);
                return this.copy(v), v;
            }, o.prototype._expand = function(v) {
                for(; this.length < v;)this.words[this.length++] = 0;
                return this;
            }, o.prototype.strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, o.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, o.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var u = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], f = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], h = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            o.prototype.toString = function(v, B) {
                v = v || 10, B = B | 0 || 1;
                var g;
                if (v === 16 || v === "hex") {
                    g = "";
                    for(var E = 0, w = 0, _ = 0; _ < this.length; _++){
                        var O = this.words[_], I = ((O << E | w) & 16777215).toString(16);
                        w = O >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, _--), w !== 0 || _ !== this.length - 1 ? g = u[6 - I.length] + I + g : g = I + g;
                    }
                    for(w !== 0 && (g = w.toString(16) + g); g.length % B !== 0;)g = "0" + g;
                    return this.negative !== 0 && (g = "-" + g), g;
                }
                if (v === (v | 0) && v >= 2 && v <= 36) {
                    var x = f[v], R = h[v];
                    g = "";
                    var j = this.clone();
                    for(j.negative = 0; !j.isZero();){
                        var Y = j.modn(R).toString(v);
                        j = j.idivn(R), j.isZero() ? g = Y + g : g = u[x - Y.length] + Y + g;
                    }
                    for(this.isZero() && (g = "0" + g); g.length % B !== 0;)g = "0" + g;
                    return this.negative !== 0 && (g = "-" + g), g;
                }
                n(!1, "Base should be between 2 and 36");
            }, o.prototype.toNumber = function() {
                var v = this.words[0];
                return this.length === 2 ? v += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? v += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -v : v;
            }, o.prototype.toJSON = function() {
                return this.toString(16);
            }, o.prototype.toBuffer = function(v, B) {
                return n(typeof a < "u"), this.toArrayLike(a, v, B);
            }, o.prototype.toArray = function(v, B) {
                return this.toArrayLike(Array, v, B);
            }, o.prototype.toArrayLike = function(v, B, g) {
                var E = this.byteLength(), w = g || Math.max(1, E);
                n(E <= w, "byte array longer than desired length"), n(w > 0, "Requested array length <= 0"), this.strip();
                var _ = B === "le", O = new v(w), I, x, R = this.clone();
                if (_) {
                    for(x = 0; !R.isZero(); x++)I = R.andln(255), R.iushrn(8), O[x] = I;
                    for(; x < w; x++)O[x] = 0;
                } else {
                    for(x = 0; x < w - E; x++)O[x] = 0;
                    for(x = 0; !R.isZero(); x++)I = R.andln(255), R.iushrn(8), O[w - x - 1] = I;
                }
                return O;
            }, Math.clz32 ? o.prototype._countBits = function(v) {
                return 32 - Math.clz32(v);
            } : o.prototype._countBits = function(v) {
                var B = v, g = 0;
                return B >= 4096 && (g += 13, B >>>= 13), B >= 64 && (g += 7, B >>>= 7), B >= 8 && (g += 4, B >>>= 4), B >= 2 && (g += 2, B >>>= 2), g + B;
            }, o.prototype._zeroBits = function(v) {
                if (v === 0) return 26;
                var B = v, g = 0;
                return B & 8191 || (g += 13, B >>>= 13), B & 127 || (g += 7, B >>>= 7), B & 15 || (g += 4, B >>>= 4), B & 3 || (g += 2, B >>>= 2), B & 1 || g++, g;
            }, o.prototype.bitLength = function() {
                var v = this.words[this.length - 1], B = this._countBits(v);
                return (this.length - 1) * 26 + B;
            };
            function y(v) {
                for(var B = new Array(v.bitLength()), g = 0; g < B.length; g++){
                    var E = g / 26 | 0, w = g % 26;
                    B[g] = (v.words[E] & 1 << w) >>> w;
                }
                return B;
            }
            o.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var v = 0, B = 0; B < this.length; B++){
                    var g = this._zeroBits(this.words[B]);
                    if (v += g, g !== 26) break;
                }
                return v;
            }, o.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, o.prototype.toTwos = function(v) {
                return this.negative !== 0 ? this.abs().inotn(v).iaddn(1) : this.clone();
            }, o.prototype.fromTwos = function(v) {
                return this.testn(v - 1) ? this.notn(v).iaddn(1).ineg() : this.clone();
            }, o.prototype.isNeg = function() {
                return this.negative !== 0;
            }, o.prototype.neg = function() {
                return this.clone().ineg();
            }, o.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, o.prototype.iuor = function(v) {
                for(; this.length < v.length;)this.words[this.length++] = 0;
                for(var B = 0; B < v.length; B++)this.words[B] = this.words[B] | v.words[B];
                return this.strip();
            }, o.prototype.ior = function(v) {
                return n((this.negative | v.negative) === 0), this.iuor(v);
            }, o.prototype.or = function(v) {
                return this.length > v.length ? this.clone().ior(v) : v.clone().ior(this);
            }, o.prototype.uor = function(v) {
                return this.length > v.length ? this.clone().iuor(v) : v.clone().iuor(this);
            }, o.prototype.iuand = function(v) {
                var B;
                this.length > v.length ? B = v : B = this;
                for(var g = 0; g < B.length; g++)this.words[g] = this.words[g] & v.words[g];
                return this.length = B.length, this.strip();
            }, o.prototype.iand = function(v) {
                return n((this.negative | v.negative) === 0), this.iuand(v);
            }, o.prototype.and = function(v) {
                return this.length > v.length ? this.clone().iand(v) : v.clone().iand(this);
            }, o.prototype.uand = function(v) {
                return this.length > v.length ? this.clone().iuand(v) : v.clone().iuand(this);
            }, o.prototype.iuxor = function(v) {
                var B, g;
                this.length > v.length ? (B = this, g = v) : (B = v, g = this);
                for(var E = 0; E < g.length; E++)this.words[E] = B.words[E] ^ g.words[E];
                if (this !== B) for(; E < B.length; E++)this.words[E] = B.words[E];
                return this.length = B.length, this.strip();
            }, o.prototype.ixor = function(v) {
                return n((this.negative | v.negative) === 0), this.iuxor(v);
            }, o.prototype.xor = function(v) {
                return this.length > v.length ? this.clone().ixor(v) : v.clone().ixor(this);
            }, o.prototype.uxor = function(v) {
                return this.length > v.length ? this.clone().iuxor(v) : v.clone().iuxor(this);
            }, o.prototype.inotn = function(v) {
                n(typeof v == "number" && v >= 0);
                var B = Math.ceil(v / 26) | 0, g = v % 26;
                this._expand(B), g > 0 && B--;
                for(var E = 0; E < B; E++)this.words[E] = ~this.words[E] & 67108863;
                return g > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - g), this.strip();
            }, o.prototype.notn = function(v) {
                return this.clone().inotn(v);
            }, o.prototype.setn = function(v, B) {
                n(typeof v == "number" && v >= 0);
                var g = v / 26 | 0, E = v % 26;
                return this._expand(g + 1), B ? this.words[g] = this.words[g] | 1 << E : this.words[g] = this.words[g] & ~(1 << E), this.strip();
            }, o.prototype.iadd = function(v) {
                var B;
                if (this.negative !== 0 && v.negative === 0) return this.negative = 0, B = this.isub(v), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && v.negative !== 0) return v.negative = 0, B = this.isub(v), v.negative = 1, B._normSign();
                var g, E;
                this.length > v.length ? (g = this, E = v) : (g = v, E = this);
                for(var w = 0, _ = 0; _ < E.length; _++)B = (g.words[_] | 0) + (E.words[_] | 0) + w, this.words[_] = B & 67108863, w = B >>> 26;
                for(; w !== 0 && _ < g.length; _++)B = (g.words[_] | 0) + w, this.words[_] = B & 67108863, w = B >>> 26;
                if (this.length = g.length, w !== 0) this.words[this.length] = w, this.length++;
                else if (g !== this) for(; _ < g.length; _++)this.words[_] = g.words[_];
                return this;
            }, o.prototype.add = function(v) {
                var B;
                return v.negative !== 0 && this.negative === 0 ? (v.negative = 0, B = this.sub(v), v.negative ^= 1, B) : v.negative === 0 && this.negative !== 0 ? (this.negative = 0, B = v.sub(this), this.negative = 1, B) : this.length > v.length ? this.clone().iadd(v) : v.clone().iadd(this);
            }, o.prototype.isub = function(v) {
                if (v.negative !== 0) {
                    v.negative = 0;
                    var B = this.iadd(v);
                    return v.negative = 1, B._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(v), this.negative = 1, this._normSign();
                var g = this.cmp(v);
                if (g === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var E, w;
                g > 0 ? (E = this, w = v) : (E = v, w = this);
                for(var _ = 0, O = 0; O < w.length; O++)B = (E.words[O] | 0) - (w.words[O] | 0) + _, _ = B >> 26, this.words[O] = B & 67108863;
                for(; _ !== 0 && O < E.length; O++)B = (E.words[O] | 0) + _, _ = B >> 26, this.words[O] = B & 67108863;
                if (_ === 0 && O < E.length && E !== this) for(; O < E.length; O++)this.words[O] = E.words[O];
                return this.length = Math.max(this.length, O), E !== this && (this.negative = 1), this.strip();
            }, o.prototype.sub = function(v) {
                return this.clone().isub(v);
            };
            function S(v, B, g) {
                g.negative = B.negative ^ v.negative;
                var E = v.length + B.length | 0;
                g.length = E, E = E - 1 | 0;
                var w = v.words[0] | 0, _ = B.words[0] | 0, O = w * _, I = O & 67108863, x = O / 67108864 | 0;
                g.words[0] = I;
                for(var R = 1; R < E; R++){
                    for(var j = x >>> 26, Y = x & 67108863, he = Math.min(R, B.length - 1), ue = Math.max(0, R - v.length + 1); ue <= he; ue++){
                        var G = R - ue | 0;
                        w = v.words[G] | 0, _ = B.words[ue] | 0, O = w * _ + Y, j += O / 67108864 | 0, Y = O & 67108863;
                    }
                    g.words[R] = Y | 0, x = j | 0;
                }
                return x !== 0 ? g.words[R] = x | 0 : g.length--, g.strip();
            }
            var k = function(v, B, g) {
                var E = v.words, w = B.words, _ = g.words, O = 0, I, x, R, j = E[0] | 0, Y = j & 8191, he = j >>> 13, ue = E[1] | 0, G = ue & 8191, se = ue >>> 13, Z = E[2] | 0, ie = Z & 8191, pe = Z >>> 13, ve = E[3] | 0, Ie = ve & 8191, Me = ve >>> 13, Re = E[4] | 0, C = Re & 8191, J = Re >>> 13, me = E[5] | 0, je = me & 8191, Ve = me >>> 13, nt = E[6] | 0, We = nt & 8191, Ge = nt >>> 13, p = E[7] | 0, A = p & 8191, V = p >>> 13, re = E[8] | 0, le = re & 8191, L = re >>> 13, X = E[9] | 0, ae = X & 8191, D = X >>> 13, H = w[0] | 0, te = H & 8191, ge = H >>> 13, ce = w[1] | 0, Ue = ce & 8191, qe = ce >>> 13, ot = w[2] | 0, yt = ot & 8191, Ut = ot >>> 13, Xe = w[3] | 0, _t = Xe & 8191, br = Xe >>> 13, Lr = w[4] | 0, Wt = Lr & 8191, Dt = Lr >>> 13, Yt = w[5] | 0, Lt = Yt & 8191, Dr = Yt >>> 13, xe = w[6] | 0, ye = xe & 8191, ke = xe >>> 13, Ce = w[7] | 0, De = Ce & 8191, Ye = Ce >>> 13, lt = w[8] | 0, et = lt & 8191, vt = lt >>> 13, At = w[9] | 0, dt = At & 8191, Tt = At >>> 13;
                g.negative = v.negative ^ B.negative, g.length = 19, I = Math.imul(Y, te), x = Math.imul(Y, ge), x = x + Math.imul(he, te) | 0, R = Math.imul(he, ge);
                var Pt = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, I = Math.imul(G, te), x = Math.imul(G, ge), x = x + Math.imul(se, te) | 0, R = Math.imul(se, ge), I = I + Math.imul(Y, Ue) | 0, x = x + Math.imul(Y, qe) | 0, x = x + Math.imul(he, Ue) | 0, R = R + Math.imul(he, qe) | 0;
                var Rt = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, I = Math.imul(ie, te), x = Math.imul(ie, ge), x = x + Math.imul(pe, te) | 0, R = Math.imul(pe, ge), I = I + Math.imul(G, Ue) | 0, x = x + Math.imul(G, qe) | 0, x = x + Math.imul(se, Ue) | 0, R = R + Math.imul(se, qe) | 0, I = I + Math.imul(Y, yt) | 0, x = x + Math.imul(Y, Ut) | 0, x = x + Math.imul(he, yt) | 0, R = R + Math.imul(he, Ut) | 0;
                var rt = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, I = Math.imul(Ie, te), x = Math.imul(Ie, ge), x = x + Math.imul(Me, te) | 0, R = Math.imul(Me, ge), I = I + Math.imul(ie, Ue) | 0, x = x + Math.imul(ie, qe) | 0, x = x + Math.imul(pe, Ue) | 0, R = R + Math.imul(pe, qe) | 0, I = I + Math.imul(G, yt) | 0, x = x + Math.imul(G, Ut) | 0, x = x + Math.imul(se, yt) | 0, R = R + Math.imul(se, Ut) | 0, I = I + Math.imul(Y, _t) | 0, x = x + Math.imul(Y, br) | 0, x = x + Math.imul(he, _t) | 0, R = R + Math.imul(he, br) | 0;
                var Et = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, I = Math.imul(C, te), x = Math.imul(C, ge), x = x + Math.imul(J, te) | 0, R = Math.imul(J, ge), I = I + Math.imul(Ie, Ue) | 0, x = x + Math.imul(Ie, qe) | 0, x = x + Math.imul(Me, Ue) | 0, R = R + Math.imul(Me, qe) | 0, I = I + Math.imul(ie, yt) | 0, x = x + Math.imul(ie, Ut) | 0, x = x + Math.imul(pe, yt) | 0, R = R + Math.imul(pe, Ut) | 0, I = I + Math.imul(G, _t) | 0, x = x + Math.imul(G, br) | 0, x = x + Math.imul(se, _t) | 0, R = R + Math.imul(se, br) | 0, I = I + Math.imul(Y, Wt) | 0, x = x + Math.imul(Y, Dt) | 0, x = x + Math.imul(he, Wt) | 0, R = R + Math.imul(he, Dt) | 0;
                var Pe = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, I = Math.imul(je, te), x = Math.imul(je, ge), x = x + Math.imul(Ve, te) | 0, R = Math.imul(Ve, ge), I = I + Math.imul(C, Ue) | 0, x = x + Math.imul(C, qe) | 0, x = x + Math.imul(J, Ue) | 0, R = R + Math.imul(J, qe) | 0, I = I + Math.imul(Ie, yt) | 0, x = x + Math.imul(Ie, Ut) | 0, x = x + Math.imul(Me, yt) | 0, R = R + Math.imul(Me, Ut) | 0, I = I + Math.imul(ie, _t) | 0, x = x + Math.imul(ie, br) | 0, x = x + Math.imul(pe, _t) | 0, R = R + Math.imul(pe, br) | 0, I = I + Math.imul(G, Wt) | 0, x = x + Math.imul(G, Dt) | 0, x = x + Math.imul(se, Wt) | 0, R = R + Math.imul(se, Dt) | 0, I = I + Math.imul(Y, Lt) | 0, x = x + Math.imul(Y, Dr) | 0, x = x + Math.imul(he, Lt) | 0, R = R + Math.imul(he, Dr) | 0;
                var mt = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, I = Math.imul(We, te), x = Math.imul(We, ge), x = x + Math.imul(Ge, te) | 0, R = Math.imul(Ge, ge), I = I + Math.imul(je, Ue) | 0, x = x + Math.imul(je, qe) | 0, x = x + Math.imul(Ve, Ue) | 0, R = R + Math.imul(Ve, qe) | 0, I = I + Math.imul(C, yt) | 0, x = x + Math.imul(C, Ut) | 0, x = x + Math.imul(J, yt) | 0, R = R + Math.imul(J, Ut) | 0, I = I + Math.imul(Ie, _t) | 0, x = x + Math.imul(Ie, br) | 0, x = x + Math.imul(Me, _t) | 0, R = R + Math.imul(Me, br) | 0, I = I + Math.imul(ie, Wt) | 0, x = x + Math.imul(ie, Dt) | 0, x = x + Math.imul(pe, Wt) | 0, R = R + Math.imul(pe, Dt) | 0, I = I + Math.imul(G, Lt) | 0, x = x + Math.imul(G, Dr) | 0, x = x + Math.imul(se, Lt) | 0, R = R + Math.imul(se, Dr) | 0, I = I + Math.imul(Y, ye) | 0, x = x + Math.imul(Y, ke) | 0, x = x + Math.imul(he, ye) | 0, R = R + Math.imul(he, ke) | 0;
                var ut = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, I = Math.imul(A, te), x = Math.imul(A, ge), x = x + Math.imul(V, te) | 0, R = Math.imul(V, ge), I = I + Math.imul(We, Ue) | 0, x = x + Math.imul(We, qe) | 0, x = x + Math.imul(Ge, Ue) | 0, R = R + Math.imul(Ge, qe) | 0, I = I + Math.imul(je, yt) | 0, x = x + Math.imul(je, Ut) | 0, x = x + Math.imul(Ve, yt) | 0, R = R + Math.imul(Ve, Ut) | 0, I = I + Math.imul(C, _t) | 0, x = x + Math.imul(C, br) | 0, x = x + Math.imul(J, _t) | 0, R = R + Math.imul(J, br) | 0, I = I + Math.imul(Ie, Wt) | 0, x = x + Math.imul(Ie, Dt) | 0, x = x + Math.imul(Me, Wt) | 0, R = R + Math.imul(Me, Dt) | 0, I = I + Math.imul(ie, Lt) | 0, x = x + Math.imul(ie, Dr) | 0, x = x + Math.imul(pe, Lt) | 0, R = R + Math.imul(pe, Dr) | 0, I = I + Math.imul(G, ye) | 0, x = x + Math.imul(G, ke) | 0, x = x + Math.imul(se, ye) | 0, R = R + Math.imul(se, ke) | 0, I = I + Math.imul(Y, De) | 0, x = x + Math.imul(Y, Ye) | 0, x = x + Math.imul(he, De) | 0, R = R + Math.imul(he, Ye) | 0;
                var Jt = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, I = Math.imul(le, te), x = Math.imul(le, ge), x = x + Math.imul(L, te) | 0, R = Math.imul(L, ge), I = I + Math.imul(A, Ue) | 0, x = x + Math.imul(A, qe) | 0, x = x + Math.imul(V, Ue) | 0, R = R + Math.imul(V, qe) | 0, I = I + Math.imul(We, yt) | 0, x = x + Math.imul(We, Ut) | 0, x = x + Math.imul(Ge, yt) | 0, R = R + Math.imul(Ge, Ut) | 0, I = I + Math.imul(je, _t) | 0, x = x + Math.imul(je, br) | 0, x = x + Math.imul(Ve, _t) | 0, R = R + Math.imul(Ve, br) | 0, I = I + Math.imul(C, Wt) | 0, x = x + Math.imul(C, Dt) | 0, x = x + Math.imul(J, Wt) | 0, R = R + Math.imul(J, Dt) | 0, I = I + Math.imul(Ie, Lt) | 0, x = x + Math.imul(Ie, Dr) | 0, x = x + Math.imul(Me, Lt) | 0, R = R + Math.imul(Me, Dr) | 0, I = I + Math.imul(ie, ye) | 0, x = x + Math.imul(ie, ke) | 0, x = x + Math.imul(pe, ye) | 0, R = R + Math.imul(pe, ke) | 0, I = I + Math.imul(G, De) | 0, x = x + Math.imul(G, Ye) | 0, x = x + Math.imul(se, De) | 0, R = R + Math.imul(se, Ye) | 0, I = I + Math.imul(Y, et) | 0, x = x + Math.imul(Y, vt) | 0, x = x + Math.imul(he, et) | 0, R = R + Math.imul(he, vt) | 0;
                var we = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, I = Math.imul(ae, te), x = Math.imul(ae, ge), x = x + Math.imul(D, te) | 0, R = Math.imul(D, ge), I = I + Math.imul(le, Ue) | 0, x = x + Math.imul(le, qe) | 0, x = x + Math.imul(L, Ue) | 0, R = R + Math.imul(L, qe) | 0, I = I + Math.imul(A, yt) | 0, x = x + Math.imul(A, Ut) | 0, x = x + Math.imul(V, yt) | 0, R = R + Math.imul(V, Ut) | 0, I = I + Math.imul(We, _t) | 0, x = x + Math.imul(We, br) | 0, x = x + Math.imul(Ge, _t) | 0, R = R + Math.imul(Ge, br) | 0, I = I + Math.imul(je, Wt) | 0, x = x + Math.imul(je, Dt) | 0, x = x + Math.imul(Ve, Wt) | 0, R = R + Math.imul(Ve, Dt) | 0, I = I + Math.imul(C, Lt) | 0, x = x + Math.imul(C, Dr) | 0, x = x + Math.imul(J, Lt) | 0, R = R + Math.imul(J, Dr) | 0, I = I + Math.imul(Ie, ye) | 0, x = x + Math.imul(Ie, ke) | 0, x = x + Math.imul(Me, ye) | 0, R = R + Math.imul(Me, ke) | 0, I = I + Math.imul(ie, De) | 0, x = x + Math.imul(ie, Ye) | 0, x = x + Math.imul(pe, De) | 0, R = R + Math.imul(pe, Ye) | 0, I = I + Math.imul(G, et) | 0, x = x + Math.imul(G, vt) | 0, x = x + Math.imul(se, et) | 0, R = R + Math.imul(se, vt) | 0, I = I + Math.imul(Y, dt) | 0, x = x + Math.imul(Y, Tt) | 0, x = x + Math.imul(he, dt) | 0, R = R + Math.imul(he, Tt) | 0;
                var Tr = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, I = Math.imul(ae, Ue), x = Math.imul(ae, qe), x = x + Math.imul(D, Ue) | 0, R = Math.imul(D, qe), I = I + Math.imul(le, yt) | 0, x = x + Math.imul(le, Ut) | 0, x = x + Math.imul(L, yt) | 0, R = R + Math.imul(L, Ut) | 0, I = I + Math.imul(A, _t) | 0, x = x + Math.imul(A, br) | 0, x = x + Math.imul(V, _t) | 0, R = R + Math.imul(V, br) | 0, I = I + Math.imul(We, Wt) | 0, x = x + Math.imul(We, Dt) | 0, x = x + Math.imul(Ge, Wt) | 0, R = R + Math.imul(Ge, Dt) | 0, I = I + Math.imul(je, Lt) | 0, x = x + Math.imul(je, Dr) | 0, x = x + Math.imul(Ve, Lt) | 0, R = R + Math.imul(Ve, Dr) | 0, I = I + Math.imul(C, ye) | 0, x = x + Math.imul(C, ke) | 0, x = x + Math.imul(J, ye) | 0, R = R + Math.imul(J, ke) | 0, I = I + Math.imul(Ie, De) | 0, x = x + Math.imul(Ie, Ye) | 0, x = x + Math.imul(Me, De) | 0, R = R + Math.imul(Me, Ye) | 0, I = I + Math.imul(ie, et) | 0, x = x + Math.imul(ie, vt) | 0, x = x + Math.imul(pe, et) | 0, R = R + Math.imul(pe, vt) | 0, I = I + Math.imul(G, dt) | 0, x = x + Math.imul(G, Tt) | 0, x = x + Math.imul(se, dt) | 0, R = R + Math.imul(se, Tt) | 0;
                var ar = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, I = Math.imul(ae, yt), x = Math.imul(ae, Ut), x = x + Math.imul(D, yt) | 0, R = Math.imul(D, Ut), I = I + Math.imul(le, _t) | 0, x = x + Math.imul(le, br) | 0, x = x + Math.imul(L, _t) | 0, R = R + Math.imul(L, br) | 0, I = I + Math.imul(A, Wt) | 0, x = x + Math.imul(A, Dt) | 0, x = x + Math.imul(V, Wt) | 0, R = R + Math.imul(V, Dt) | 0, I = I + Math.imul(We, Lt) | 0, x = x + Math.imul(We, Dr) | 0, x = x + Math.imul(Ge, Lt) | 0, R = R + Math.imul(Ge, Dr) | 0, I = I + Math.imul(je, ye) | 0, x = x + Math.imul(je, ke) | 0, x = x + Math.imul(Ve, ye) | 0, R = R + Math.imul(Ve, ke) | 0, I = I + Math.imul(C, De) | 0, x = x + Math.imul(C, Ye) | 0, x = x + Math.imul(J, De) | 0, R = R + Math.imul(J, Ye) | 0, I = I + Math.imul(Ie, et) | 0, x = x + Math.imul(Ie, vt) | 0, x = x + Math.imul(Me, et) | 0, R = R + Math.imul(Me, vt) | 0, I = I + Math.imul(ie, dt) | 0, x = x + Math.imul(ie, Tt) | 0, x = x + Math.imul(pe, dt) | 0, R = R + Math.imul(pe, Tt) | 0;
                var sr = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, I = Math.imul(ae, _t), x = Math.imul(ae, br), x = x + Math.imul(D, _t) | 0, R = Math.imul(D, br), I = I + Math.imul(le, Wt) | 0, x = x + Math.imul(le, Dt) | 0, x = x + Math.imul(L, Wt) | 0, R = R + Math.imul(L, Dt) | 0, I = I + Math.imul(A, Lt) | 0, x = x + Math.imul(A, Dr) | 0, x = x + Math.imul(V, Lt) | 0, R = R + Math.imul(V, Dr) | 0, I = I + Math.imul(We, ye) | 0, x = x + Math.imul(We, ke) | 0, x = x + Math.imul(Ge, ye) | 0, R = R + Math.imul(Ge, ke) | 0, I = I + Math.imul(je, De) | 0, x = x + Math.imul(je, Ye) | 0, x = x + Math.imul(Ve, De) | 0, R = R + Math.imul(Ve, Ye) | 0, I = I + Math.imul(C, et) | 0, x = x + Math.imul(C, vt) | 0, x = x + Math.imul(J, et) | 0, R = R + Math.imul(J, vt) | 0, I = I + Math.imul(Ie, dt) | 0, x = x + Math.imul(Ie, Tt) | 0, x = x + Math.imul(Me, dt) | 0, R = R + Math.imul(Me, Tt) | 0;
                var kt = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, I = Math.imul(ae, Wt), x = Math.imul(ae, Dt), x = x + Math.imul(D, Wt) | 0, R = Math.imul(D, Dt), I = I + Math.imul(le, Lt) | 0, x = x + Math.imul(le, Dr) | 0, x = x + Math.imul(L, Lt) | 0, R = R + Math.imul(L, Dr) | 0, I = I + Math.imul(A, ye) | 0, x = x + Math.imul(A, ke) | 0, x = x + Math.imul(V, ye) | 0, R = R + Math.imul(V, ke) | 0, I = I + Math.imul(We, De) | 0, x = x + Math.imul(We, Ye) | 0, x = x + Math.imul(Ge, De) | 0, R = R + Math.imul(Ge, Ye) | 0, I = I + Math.imul(je, et) | 0, x = x + Math.imul(je, vt) | 0, x = x + Math.imul(Ve, et) | 0, R = R + Math.imul(Ve, vt) | 0, I = I + Math.imul(C, dt) | 0, x = x + Math.imul(C, Tt) | 0, x = x + Math.imul(J, dt) | 0, R = R + Math.imul(J, Tt) | 0;
                var nn = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, I = Math.imul(ae, Lt), x = Math.imul(ae, Dr), x = x + Math.imul(D, Lt) | 0, R = Math.imul(D, Dr), I = I + Math.imul(le, ye) | 0, x = x + Math.imul(le, ke) | 0, x = x + Math.imul(L, ye) | 0, R = R + Math.imul(L, ke) | 0, I = I + Math.imul(A, De) | 0, x = x + Math.imul(A, Ye) | 0, x = x + Math.imul(V, De) | 0, R = R + Math.imul(V, Ye) | 0, I = I + Math.imul(We, et) | 0, x = x + Math.imul(We, vt) | 0, x = x + Math.imul(Ge, et) | 0, R = R + Math.imul(Ge, vt) | 0, I = I + Math.imul(je, dt) | 0, x = x + Math.imul(je, Tt) | 0, x = x + Math.imul(Ve, dt) | 0, R = R + Math.imul(Ve, Tt) | 0;
                var bi = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (bi >>> 26) | 0, bi &= 67108863, I = Math.imul(ae, ye), x = Math.imul(ae, ke), x = x + Math.imul(D, ye) | 0, R = Math.imul(D, ke), I = I + Math.imul(le, De) | 0, x = x + Math.imul(le, Ye) | 0, x = x + Math.imul(L, De) | 0, R = R + Math.imul(L, Ye) | 0, I = I + Math.imul(A, et) | 0, x = x + Math.imul(A, vt) | 0, x = x + Math.imul(V, et) | 0, R = R + Math.imul(V, vt) | 0, I = I + Math.imul(We, dt) | 0, x = x + Math.imul(We, Tt) | 0, x = x + Math.imul(Ge, dt) | 0, R = R + Math.imul(Ge, Tt) | 0;
                var b = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (b >>> 26) | 0, b &= 67108863, I = Math.imul(ae, De), x = Math.imul(ae, Ye), x = x + Math.imul(D, De) | 0, R = Math.imul(D, Ye), I = I + Math.imul(le, et) | 0, x = x + Math.imul(le, vt) | 0, x = x + Math.imul(L, et) | 0, R = R + Math.imul(L, vt) | 0, I = I + Math.imul(A, dt) | 0, x = x + Math.imul(A, Tt) | 0, x = x + Math.imul(V, dt) | 0, R = R + Math.imul(V, Tt) | 0;
                var T = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (T >>> 26) | 0, T &= 67108863, I = Math.imul(ae, et), x = Math.imul(ae, vt), x = x + Math.imul(D, et) | 0, R = Math.imul(D, vt), I = I + Math.imul(le, dt) | 0, x = x + Math.imul(le, Tt) | 0, x = x + Math.imul(L, dt) | 0, R = R + Math.imul(L, Tt) | 0;
                var W = (O + I | 0) + ((x & 8191) << 13) | 0;
                O = (R + (x >>> 13) | 0) + (W >>> 26) | 0, W &= 67108863, I = Math.imul(ae, dt), x = Math.imul(ae, Tt), x = x + Math.imul(D, dt) | 0, R = Math.imul(D, Tt);
                var fe = (O + I | 0) + ((x & 8191) << 13) | 0;
                return O = (R + (x >>> 13) | 0) + (fe >>> 26) | 0, fe &= 67108863, _[0] = Pt, _[1] = Rt, _[2] = rt, _[3] = Et, _[4] = Pe, _[5] = mt, _[6] = ut, _[7] = Jt, _[8] = we, _[9] = Tr, _[10] = ar, _[11] = sr, _[12] = kt, _[13] = nn, _[14] = bi, _[15] = b, _[16] = T, _[17] = W, _[18] = fe, O !== 0 && (_[19] = O, g.length++), g;
            };
            Math.imul || (k = S);
            function P(v, B, g) {
                g.negative = B.negative ^ v.negative, g.length = v.length + B.length;
                for(var E = 0, w = 0, _ = 0; _ < g.length - 1; _++){
                    var O = w;
                    w = 0;
                    for(var I = E & 67108863, x = Math.min(_, B.length - 1), R = Math.max(0, _ - v.length + 1); R <= x; R++){
                        var j = _ - R, Y = v.words[j] | 0, he = B.words[R] | 0, ue = Y * he, G = ue & 67108863;
                        O = O + (ue / 67108864 | 0) | 0, G = G + I | 0, I = G & 67108863, O = O + (G >>> 26) | 0, w += O >>> 26, O &= 67108863;
                    }
                    g.words[_] = I, E = O, O = w;
                }
                return E !== 0 ? g.words[_] = E : g.length--, g.strip();
            }
            function M(v, B, g) {
                var E = new N();
                return E.mulp(v, B, g);
            }
            o.prototype.mulTo = function(v, B) {
                var g, E = this.length + v.length;
                return this.length === 10 && v.length === 10 ? g = k(this, v, B) : E < 63 ? g = S(this, v, B) : E < 1024 ? g = P(this, v, B) : g = M(this, v, B), g;
            };
            function N(v, B) {
                this.x = v, this.y = B;
            }
            N.prototype.makeRBT = function(v) {
                for(var B = new Array(v), g = o.prototype._countBits(v) - 1, E = 0; E < v; E++)B[E] = this.revBin(E, g, v);
                return B;
            }, N.prototype.revBin = function(v, B, g) {
                if (v === 0 || v === g - 1) return v;
                for(var E = 0, w = 0; w < B; w++)E |= (v & 1) << B - w - 1, v >>= 1;
                return E;
            }, N.prototype.permute = function(v, B, g, E, w, _) {
                for(var O = 0; O < _; O++)E[O] = B[v[O]], w[O] = g[v[O]];
            }, N.prototype.transform = function(v, B, g, E, w, _) {
                this.permute(_, v, B, g, E, w);
                for(var O = 1; O < w; O <<= 1)for(var I = O << 1, x = Math.cos(2 * Math.PI / I), R = Math.sin(2 * Math.PI / I), j = 0; j < w; j += I)for(var Y = x, he = R, ue = 0; ue < O; ue++){
                    var G = g[j + ue], se = E[j + ue], Z = g[j + ue + O], ie = E[j + ue + O], pe = Y * Z - he * ie;
                    ie = Y * ie + he * Z, Z = pe, g[j + ue] = G + Z, E[j + ue] = se + ie, g[j + ue + O] = G - Z, E[j + ue + O] = se - ie, ue !== I && (pe = x * Y - R * he, he = x * he + R * Y, Y = pe);
                }
            }, N.prototype.guessLen13b = function(v, B) {
                var g = Math.max(B, v) | 1, E = g & 1, w = 0;
                for(g = g / 2 | 0; g; g = g >>> 1)w++;
                return 1 << w + 1 + E;
            }, N.prototype.conjugate = function(v, B, g) {
                if (!(g <= 1)) for(var E = 0; E < g / 2; E++){
                    var w = v[E];
                    v[E] = v[g - E - 1], v[g - E - 1] = w, w = B[E], B[E] = -B[g - E - 1], B[g - E - 1] = -w;
                }
            }, N.prototype.normalize13b = function(v, B) {
                for(var g = 0, E = 0; E < B / 2; E++){
                    var w = Math.round(v[2 * E + 1] / B) * 8192 + Math.round(v[2 * E] / B) + g;
                    v[E] = w & 67108863, w < 67108864 ? g = 0 : g = w / 67108864 | 0;
                }
                return v;
            }, N.prototype.convert13b = function(v, B, g, E) {
                for(var w = 0, _ = 0; _ < B; _++)w = w + (v[_] | 0), g[2 * _] = w & 8191, w = w >>> 13, g[2 * _ + 1] = w & 8191, w = w >>> 13;
                for(_ = 2 * B; _ < E; ++_)g[_] = 0;
                n(w === 0), n((w & -8192) === 0);
            }, N.prototype.stub = function(v) {
                for(var B = new Array(v), g = 0; g < v; g++)B[g] = 0;
                return B;
            }, N.prototype.mulp = function(v, B, g) {
                var E = 2 * this.guessLen13b(v.length, B.length), w = this.makeRBT(E), _ = this.stub(E), O = new Array(E), I = new Array(E), x = new Array(E), R = new Array(E), j = new Array(E), Y = new Array(E), he = g.words;
                he.length = E, this.convert13b(v.words, v.length, O, E), this.convert13b(B.words, B.length, R, E), this.transform(O, _, I, x, E, w), this.transform(R, _, j, Y, E, w);
                for(var ue = 0; ue < E; ue++){
                    var G = I[ue] * j[ue] - x[ue] * Y[ue];
                    x[ue] = I[ue] * Y[ue] + x[ue] * j[ue], I[ue] = G;
                }
                return this.conjugate(I, x, E), this.transform(I, x, he, _, E, w), this.conjugate(he, _, E), this.normalize13b(he, E), g.negative = v.negative ^ B.negative, g.length = v.length + B.length, g.strip();
            }, o.prototype.mul = function(v) {
                var B = new o(null);
                return B.words = new Array(this.length + v.length), this.mulTo(v, B);
            }, o.prototype.mulf = function(v) {
                var B = new o(null);
                return B.words = new Array(this.length + v.length), M(this, v, B);
            }, o.prototype.imul = function(v) {
                return this.clone().mulTo(v, this);
            }, o.prototype.imuln = function(v) {
                n(typeof v == "number"), n(v < 67108864);
                for(var B = 0, g = 0; g < this.length; g++){
                    var E = (this.words[g] | 0) * v, w = (E & 67108863) + (B & 67108863);
                    B >>= 26, B += E / 67108864 | 0, B += w >>> 26, this.words[g] = w & 67108863;
                }
                return B !== 0 && (this.words[g] = B, this.length++), this.length = v === 0 ? 1 : this.length, this;
            }, o.prototype.muln = function(v) {
                return this.clone().imuln(v);
            }, o.prototype.sqr = function() {
                return this.mul(this);
            }, o.prototype.isqr = function() {
                return this.imul(this.clone());
            }, o.prototype.pow = function(v) {
                var B = y(v);
                if (B.length === 0) return new o(1);
                for(var g = this, E = 0; E < B.length && B[E] === 0; E++, g = g.sqr());
                if (++E < B.length) for(var w = g.sqr(); E < B.length; E++, w = w.sqr())B[E] !== 0 && (g = g.mul(w));
                return g;
            }, o.prototype.iushln = function(v) {
                n(typeof v == "number" && v >= 0);
                var B = v % 26, g = (v - B) / 26, E = 67108863 >>> 26 - B << 26 - B, w;
                if (B !== 0) {
                    var _ = 0;
                    for(w = 0; w < this.length; w++){
                        var O = this.words[w] & E, I = (this.words[w] | 0) - O << B;
                        this.words[w] = I | _, _ = O >>> 26 - B;
                    }
                    _ && (this.words[w] = _, this.length++);
                }
                if (g !== 0) {
                    for(w = this.length - 1; w >= 0; w--)this.words[w + g] = this.words[w];
                    for(w = 0; w < g; w++)this.words[w] = 0;
                    this.length += g;
                }
                return this.strip();
            }, o.prototype.ishln = function(v) {
                return n(this.negative === 0), this.iushln(v);
            }, o.prototype.iushrn = function(v, B, g) {
                n(typeof v == "number" && v >= 0);
                var E;
                B ? E = (B - B % 26) / 26 : E = 0;
                var w = v % 26, _ = Math.min((v - w) / 26, this.length), O = 67108863 ^ 67108863 >>> w << w, I = g;
                if (E -= _, E = Math.max(0, E), I) {
                    for(var x = 0; x < _; x++)I.words[x] = this.words[x];
                    I.length = _;
                }
                if (_ !== 0) if (this.length > _) for(this.length -= _, x = 0; x < this.length; x++)this.words[x] = this.words[x + _];
                else this.words[0] = 0, this.length = 1;
                var R = 0;
                for(x = this.length - 1; x >= 0 && (R !== 0 || x >= E); x--){
                    var j = this.words[x] | 0;
                    this.words[x] = R << 26 - w | j >>> w, R = j & O;
                }
                return I && R !== 0 && (I.words[I.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
            }, o.prototype.ishrn = function(v, B, g) {
                return n(this.negative === 0), this.iushrn(v, B, g);
            }, o.prototype.shln = function(v) {
                return this.clone().ishln(v);
            }, o.prototype.ushln = function(v) {
                return this.clone().iushln(v);
            }, o.prototype.shrn = function(v) {
                return this.clone().ishrn(v);
            }, o.prototype.ushrn = function(v) {
                return this.clone().iushrn(v);
            }, o.prototype.testn = function(v) {
                n(typeof v == "number" && v >= 0);
                var B = v % 26, g = (v - B) / 26, E = 1 << B;
                if (this.length <= g) return !1;
                var w = this.words[g];
                return !!(w & E);
            }, o.prototype.imaskn = function(v) {
                n(typeof v == "number" && v >= 0);
                var B = v % 26, g = (v - B) / 26;
                if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g) return this;
                if (B !== 0 && g++, this.length = Math.min(g, this.length), B !== 0) {
                    var E = 67108863 ^ 67108863 >>> B << B;
                    this.words[this.length - 1] &= E;
                }
                return this.strip();
            }, o.prototype.maskn = function(v) {
                return this.clone().imaskn(v);
            }, o.prototype.iaddn = function(v) {
                return n(typeof v == "number"), n(v < 67108864), v < 0 ? this.isubn(-v) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < v ? (this.words[0] = v - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(v), this.negative = 1, this) : this._iaddn(v);
            }, o.prototype._iaddn = function(v) {
                this.words[0] += v;
                for(var B = 0; B < this.length && this.words[B] >= 67108864; B++)this.words[B] -= 67108864, B === this.length - 1 ? this.words[B + 1] = 1 : this.words[B + 1]++;
                return this.length = Math.max(this.length, B + 1), this;
            }, o.prototype.isubn = function(v) {
                if (n(typeof v == "number"), n(v < 67108864), v < 0) return this.iaddn(-v);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(v), this.negative = 1, this;
                if (this.words[0] -= v, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var B = 0; B < this.length && this.words[B] < 0; B++)this.words[B] += 67108864, this.words[B + 1] -= 1;
                return this.strip();
            }, o.prototype.addn = function(v) {
                return this.clone().iaddn(v);
            }, o.prototype.subn = function(v) {
                return this.clone().isubn(v);
            }, o.prototype.iabs = function() {
                return this.negative = 0, this;
            }, o.prototype.abs = function() {
                return this.clone().iabs();
            }, o.prototype._ishlnsubmul = function(v, B, g) {
                var E = v.length + g, w;
                this._expand(E);
                var _, O = 0;
                for(w = 0; w < v.length; w++){
                    _ = (this.words[w + g] | 0) + O;
                    var I = (v.words[w] | 0) * B;
                    _ -= I & 67108863, O = (_ >> 26) - (I / 67108864 | 0), this.words[w + g] = _ & 67108863;
                }
                for(; w < this.length - g; w++)_ = (this.words[w + g] | 0) + O, O = _ >> 26, this.words[w + g] = _ & 67108863;
                if (O === 0) return this.strip();
                for(n(O === -1), O = 0, w = 0; w < this.length; w++)_ = -(this.words[w] | 0) + O, O = _ >> 26, this.words[w] = _ & 67108863;
                return this.negative = 1, this.strip();
            }, o.prototype._wordDiv = function(v, B) {
                var g = this.length - v.length, E = this.clone(), w = v, _ = w.words[w.length - 1] | 0, O = this._countBits(_);
                g = 26 - O, g !== 0 && (w = w.ushln(g), E.iushln(g), _ = w.words[w.length - 1] | 0);
                var I = E.length - w.length, x;
                if (B !== "mod") {
                    x = new o(null), x.length = I + 1, x.words = new Array(x.length);
                    for(var R = 0; R < x.length; R++)x.words[R] = 0;
                }
                var j = E.clone()._ishlnsubmul(w, 1, I);
                j.negative === 0 && (E = j, x && (x.words[I] = 1));
                for(var Y = I - 1; Y >= 0; Y--){
                    var he = (E.words[w.length + Y] | 0) * 67108864 + (E.words[w.length + Y - 1] | 0);
                    for(he = Math.min(he / _ | 0, 67108863), E._ishlnsubmul(w, he, Y); E.negative !== 0;)he--, E.negative = 0, E._ishlnsubmul(w, 1, Y), E.isZero() || (E.negative ^= 1);
                    x && (x.words[Y] = he);
                }
                return x && x.strip(), E.strip(), B !== "div" && g !== 0 && E.iushrn(g), {
                    div: x || null,
                    mod: E
                };
            }, o.prototype.divmod = function(v, B, g) {
                if (n(!v.isZero()), this.isZero()) return {
                    div: new o(0),
                    mod: new o(0)
                };
                var E, w, _;
                return this.negative !== 0 && v.negative === 0 ? (_ = this.neg().divmod(v, B), B !== "mod" && (E = _.div.neg()), B !== "div" && (w = _.mod.neg(), g && w.negative !== 0 && w.iadd(v)), {
                    div: E,
                    mod: w
                }) : this.negative === 0 && v.negative !== 0 ? (_ = this.divmod(v.neg(), B), B !== "mod" && (E = _.div.neg()), {
                    div: E,
                    mod: _.mod
                }) : this.negative & v.negative ? (_ = this.neg().divmod(v.neg(), B), B !== "div" && (w = _.mod.neg(), g && w.negative !== 0 && w.isub(v)), {
                    div: _.div,
                    mod: w
                }) : v.length > this.length || this.cmp(v) < 0 ? {
                    div: new o(0),
                    mod: this
                } : v.length === 1 ? B === "div" ? {
                    div: this.divn(v.words[0]),
                    mod: null
                } : B === "mod" ? {
                    div: null,
                    mod: new o(this.modn(v.words[0]))
                } : {
                    div: this.divn(v.words[0]),
                    mod: new o(this.modn(v.words[0]))
                } : this._wordDiv(v, B);
            }, o.prototype.div = function(v) {
                return this.divmod(v, "div", !1).div;
            }, o.prototype.mod = function(v) {
                return this.divmod(v, "mod", !1).mod;
            }, o.prototype.umod = function(v) {
                return this.divmod(v, "mod", !0).mod;
            }, o.prototype.divRound = function(v) {
                var B = this.divmod(v);
                if (B.mod.isZero()) return B.div;
                var g = B.div.negative !== 0 ? B.mod.isub(v) : B.mod, E = v.ushrn(1), w = v.andln(1), _ = g.cmp(E);
                return _ < 0 || w === 1 && _ === 0 ? B.div : B.div.negative !== 0 ? B.div.isubn(1) : B.div.iaddn(1);
            }, o.prototype.modn = function(v) {
                n(v <= 67108863);
                for(var B = (1 << 26) % v, g = 0, E = this.length - 1; E >= 0; E--)g = (B * g + (this.words[E] | 0)) % v;
                return g;
            }, o.prototype.idivn = function(v) {
                n(v <= 67108863);
                for(var B = 0, g = this.length - 1; g >= 0; g--){
                    var E = (this.words[g] | 0) + B * 67108864;
                    this.words[g] = E / v | 0, B = E % v;
                }
                return this.strip();
            }, o.prototype.divn = function(v) {
                return this.clone().idivn(v);
            }, o.prototype.egcd = function(v) {
                n(v.negative === 0), n(!v.isZero());
                var B = this, g = v.clone();
                B.negative !== 0 ? B = B.umod(v) : B = B.clone();
                for(var E = new o(1), w = new o(0), _ = new o(0), O = new o(1), I = 0; B.isEven() && g.isEven();)B.iushrn(1), g.iushrn(1), ++I;
                for(var x = g.clone(), R = B.clone(); !B.isZero();){
                    for(var j = 0, Y = 1; !(B.words[0] & Y) && j < 26; ++j, Y <<= 1);
                    if (j > 0) for(B.iushrn(j); j-- > 0;)(E.isOdd() || w.isOdd()) && (E.iadd(x), w.isub(R)), E.iushrn(1), w.iushrn(1);
                    for(var he = 0, ue = 1; !(g.words[0] & ue) && he < 26; ++he, ue <<= 1);
                    if (he > 0) for(g.iushrn(he); he-- > 0;)(_.isOdd() || O.isOdd()) && (_.iadd(x), O.isub(R)), _.iushrn(1), O.iushrn(1);
                    B.cmp(g) >= 0 ? (B.isub(g), E.isub(_), w.isub(O)) : (g.isub(B), _.isub(E), O.isub(w));
                }
                return {
                    a: _,
                    b: O,
                    gcd: g.iushln(I)
                };
            }, o.prototype._invmp = function(v) {
                n(v.negative === 0), n(!v.isZero());
                var B = this, g = v.clone();
                B.negative !== 0 ? B = B.umod(v) : B = B.clone();
                for(var E = new o(1), w = new o(0), _ = g.clone(); B.cmpn(1) > 0 && g.cmpn(1) > 0;){
                    for(var O = 0, I = 1; !(B.words[0] & I) && O < 26; ++O, I <<= 1);
                    if (O > 0) for(B.iushrn(O); O-- > 0;)E.isOdd() && E.iadd(_), E.iushrn(1);
                    for(var x = 0, R = 1; !(g.words[0] & R) && x < 26; ++x, R <<= 1);
                    if (x > 0) for(g.iushrn(x); x-- > 0;)w.isOdd() && w.iadd(_), w.iushrn(1);
                    B.cmp(g) >= 0 ? (B.isub(g), E.isub(w)) : (g.isub(B), w.isub(E));
                }
                var j;
                return B.cmpn(1) === 0 ? j = E : j = w, j.cmpn(0) < 0 && j.iadd(v), j;
            }, o.prototype.gcd = function(v) {
                if (this.isZero()) return v.abs();
                if (v.isZero()) return this.abs();
                var B = this.clone(), g = v.clone();
                B.negative = 0, g.negative = 0;
                for(var E = 0; B.isEven() && g.isEven(); E++)B.iushrn(1), g.iushrn(1);
                do {
                    for(; B.isEven();)B.iushrn(1);
                    for(; g.isEven();)g.iushrn(1);
                    var w = B.cmp(g);
                    if (w < 0) {
                        var _ = B;
                        B = g, g = _;
                    } else if (w === 0 || g.cmpn(1) === 0) break;
                    B.isub(g);
                }while (!0)
                return g.iushln(E);
            }, o.prototype.invm = function(v) {
                return this.egcd(v).a.umod(v);
            }, o.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, o.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, o.prototype.andln = function(v) {
                return this.words[0] & v;
            }, o.prototype.bincn = function(v) {
                n(typeof v == "number");
                var B = v % 26, g = (v - B) / 26, E = 1 << B;
                if (this.length <= g) return this._expand(g + 1), this.words[g] |= E, this;
                for(var w = E, _ = g; w !== 0 && _ < this.length; _++){
                    var O = this.words[_] | 0;
                    O += w, w = O >>> 26, O &= 67108863, this.words[_] = O;
                }
                return w !== 0 && (this.words[_] = w, this.length++), this;
            }, o.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, o.prototype.cmpn = function(v) {
                var B = v < 0;
                if (this.negative !== 0 && !B) return -1;
                if (this.negative === 0 && B) return 1;
                this.strip();
                var g;
                if (this.length > 1) g = 1;
                else {
                    B && (v = -v), n(v <= 67108863, "Number is too big");
                    var E = this.words[0] | 0;
                    g = E === v ? 0 : E < v ? -1 : 1;
                }
                return this.negative !== 0 ? -g | 0 : g;
            }, o.prototype.cmp = function(v) {
                if (this.negative !== 0 && v.negative === 0) return -1;
                if (this.negative === 0 && v.negative !== 0) return 1;
                var B = this.ucmp(v);
                return this.negative !== 0 ? -B | 0 : B;
            }, o.prototype.ucmp = function(v) {
                if (this.length > v.length) return 1;
                if (this.length < v.length) return -1;
                for(var B = 0, g = this.length - 1; g >= 0; g--){
                    var E = this.words[g] | 0, w = v.words[g] | 0;
                    if (E !== w) {
                        E < w ? B = -1 : E > w && (B = 1);
                        break;
                    }
                }
                return B;
            }, o.prototype.gtn = function(v) {
                return this.cmpn(v) === 1;
            }, o.prototype.gt = function(v) {
                return this.cmp(v) === 1;
            }, o.prototype.gten = function(v) {
                return this.cmpn(v) >= 0;
            }, o.prototype.gte = function(v) {
                return this.cmp(v) >= 0;
            }, o.prototype.ltn = function(v) {
                return this.cmpn(v) === -1;
            }, o.prototype.lt = function(v) {
                return this.cmp(v) === -1;
            }, o.prototype.lten = function(v) {
                return this.cmpn(v) <= 0;
            }, o.prototype.lte = function(v) {
                return this.cmp(v) <= 0;
            }, o.prototype.eqn = function(v) {
                return this.cmpn(v) === 0;
            }, o.prototype.eq = function(v) {
                return this.cmp(v) === 0;
            }, o.red = function(v) {
                return new U(v);
            }, o.prototype.toRed = function(v) {
                return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), v.convertTo(this)._forceRed(v);
            }, o.prototype.fromRed = function() {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, o.prototype._forceRed = function(v) {
                return this.red = v, this;
            }, o.prototype.forceRed = function(v) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(v);
            }, o.prototype.redAdd = function(v) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, v);
            }, o.prototype.redIAdd = function(v) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, v);
            }, o.prototype.redSub = function(v) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, v);
            }, o.prototype.redISub = function(v) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, v);
            }, o.prototype.redShl = function(v) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, v);
            }, o.prototype.redMul = function(v) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, v), this.red.mul(this, v);
            }, o.prototype.redIMul = function(v) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, v), this.red.imul(this, v);
            }, o.prototype.redSqr = function() {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, o.prototype.redISqr = function() {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, o.prototype.redSqrt = function() {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, o.prototype.redInvm = function() {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, o.prototype.redNeg = function() {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, o.prototype.redPow = function(v) {
                return n(this.red && !v.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, v);
            };
            var z = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function K(v, B) {
                this.name = v, this.p = new o(B, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            K.prototype._tmp = function() {
                var v = new o(null);
                return v.words = new Array(Math.ceil(this.n / 13)), v;
            }, K.prototype.ireduce = function(v) {
                var B = v, g;
                do this.split(B, this.tmp), B = this.imulK(B), B = B.iadd(this.tmp), g = B.bitLength();
                while (g > this.n)
                var E = g < this.n ? -1 : B.ucmp(this.p);
                return E === 0 ? (B.words[0] = 0, B.length = 1) : E > 0 ? B.isub(this.p) : B.strip !== void 0 ? B.strip() : B._strip(), B;
            }, K.prototype.split = function(v, B) {
                v.iushrn(this.n, 0, B);
            }, K.prototype.imulK = function(v) {
                return v.imul(this.k);
            };
            function $() {
                K.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            i1($, K), $.prototype.split = function(v, B) {
                for(var g = 4194303, E = Math.min(v.length, 9), w = 0; w < E; w++)B.words[w] = v.words[w];
                if (B.length = E, v.length <= 9) {
                    v.words[0] = 0, v.length = 1;
                    return;
                }
                var _ = v.words[9];
                for(B.words[B.length++] = _ & g, w = 10; w < v.length; w++){
                    var O = v.words[w] | 0;
                    v.words[w - 10] = (O & g) << 4 | _ >>> 22, _ = O;
                }
                _ >>>= 22, v.words[w - 10] = _, _ === 0 && v.length > 10 ? v.length -= 10 : v.length -= 9;
            }, $.prototype.imulK = function(v) {
                v.words[v.length] = 0, v.words[v.length + 1] = 0, v.length += 2;
                for(var B = 0, g = 0; g < v.length; g++){
                    var E = v.words[g] | 0;
                    B += E * 977, v.words[g] = B & 67108863, B = E * 64 + (B / 67108864 | 0);
                }
                return v.words[v.length - 1] === 0 && (v.length--, v.words[v.length - 1] === 0 && v.length--), v;
            };
            function ne() {
                K.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            i1(ne, K);
            function ee() {
                K.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            i1(ee, K);
            function q() {
                K.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            i1(q, K), q.prototype.imulK = function(v) {
                for(var B = 0, g = 0; g < v.length; g++){
                    var E = (v.words[g] | 0) * 19 + B, w = E & 67108863;
                    E >>>= 26, v.words[g] = w, B = E;
                }
                return B !== 0 && (v.words[v.length++] = B), v;
            }, o._prime = function(v) {
                if (z[v]) return z[v];
                var B;
                if (v === "k256") B = new $();
                else if (v === "p224") B = new ne();
                else if (v === "p192") B = new ee();
                else if (v === "p25519") B = new q();
                else throw new Error("Unknown prime " + v);
                return z[v] = B, B;
            };
            function U(v) {
                if (typeof v == "string") {
                    var B = o._prime(v);
                    this.m = B.p, this.prime = B;
                } else n(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
            }
            U.prototype._verify1 = function(v) {
                n(v.negative === 0, "red works only with positives"), n(v.red, "red works only with red numbers");
            }, U.prototype._verify2 = function(v, B) {
                n((v.negative | B.negative) === 0, "red works only with positives"), n(v.red && v.red === B.red, "red works only with red numbers");
            }, U.prototype.imod = function(v) {
                return this.prime ? this.prime.ireduce(v)._forceRed(this) : v.umod(this.m)._forceRed(this);
            }, U.prototype.neg = function(v) {
                return v.isZero() ? v.clone() : this.m.sub(v)._forceRed(this);
            }, U.prototype.add = function(v, B) {
                this._verify2(v, B);
                var g = v.add(B);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
            }, U.prototype.iadd = function(v, B) {
                this._verify2(v, B);
                var g = v.iadd(B);
                return g.cmp(this.m) >= 0 && g.isub(this.m), g;
            }, U.prototype.sub = function(v, B) {
                this._verify2(v, B);
                var g = v.sub(B);
                return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
            }, U.prototype.isub = function(v, B) {
                this._verify2(v, B);
                var g = v.isub(B);
                return g.cmpn(0) < 0 && g.iadd(this.m), g;
            }, U.prototype.shl = function(v, B) {
                return this._verify1(v), this.imod(v.ushln(B));
            }, U.prototype.imul = function(v, B) {
                return this._verify2(v, B), this.imod(v.imul(B));
            }, U.prototype.mul = function(v, B) {
                return this._verify2(v, B), this.imod(v.mul(B));
            }, U.prototype.isqr = function(v) {
                return this.imul(v, v.clone());
            }, U.prototype.sqr = function(v) {
                return this.mul(v, v);
            }, U.prototype.sqrt = function(v) {
                if (v.isZero()) return v.clone();
                var B = this.m.andln(3);
                if (n(B % 2 === 1), B === 3) {
                    var g = this.m.add(new o(1)).iushrn(2);
                    return this.pow(v, g);
                }
                for(var E = this.m.subn(1), w = 0; !E.isZero() && E.andln(1) === 0;)w++, E.iushrn(1);
                n(!E.isZero());
                var _ = new o(1).toRed(this), O = _.redNeg(), I = this.m.subn(1).iushrn(1), x = this.m.bitLength();
                for(x = new o(2 * x * x).toRed(this); this.pow(x, I).cmp(O) !== 0;)x.redIAdd(O);
                for(var R = this.pow(x, E), j = this.pow(v, E.addn(1).iushrn(1)), Y = this.pow(v, E), he = w; Y.cmp(_) !== 0;){
                    for(var ue = Y, G = 0; ue.cmp(_) !== 0; G++)ue = ue.redSqr();
                    n(G < he);
                    var se = this.pow(R, new o(1).iushln(he - G - 1));
                    j = j.redMul(se), R = se.redSqr(), Y = Y.redMul(R), he = G;
                }
                return j;
            }, U.prototype.invm = function(v) {
                var B = v._invmp(this.m);
                return B.negative !== 0 ? (B.negative = 0, this.imod(B).redNeg()) : this.imod(B);
            }, U.prototype.pow = function(v, B) {
                if (B.isZero()) return new o(1).toRed(this);
                if (B.cmpn(1) === 0) return v.clone();
                var g = 4, E = new Array(1 << g);
                E[0] = new o(1).toRed(this), E[1] = v;
                for(var w = 2; w < E.length; w++)E[w] = this.mul(E[w - 1], v);
                var _ = E[0], O = 0, I = 0, x = B.bitLength() % 26;
                for(x === 0 && (x = 26), w = B.length - 1; w >= 0; w--){
                    for(var R = B.words[w], j = x - 1; j >= 0; j--){
                        var Y = R >> j & 1;
                        if (_ !== E[0] && (_ = this.sqr(_)), Y === 0 && O === 0) {
                            I = 0;
                            continue;
                        }
                        O <<= 1, O |= Y, I++, !(I !== g && (w !== 0 || j !== 0)) && (_ = this.mul(_, E[O]), I = 0, O = 0);
                    }
                    x = 26;
                }
                return _;
            }, U.prototype.convertTo = function(v) {
                var B = v.umod(this.m);
                return B === v ? B.clone() : B;
            }, U.prototype.convertFrom = function(v) {
                var B = v.clone();
                return B.red = null, B;
            }, o.mont = function(v) {
                return new Q(v);
            };
            function Q(v) {
                U.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            i1(Q, U), Q.prototype.convertTo = function(v) {
                return this.imod(v.ushln(this.shift));
            }, Q.prototype.convertFrom = function(v) {
                var B = this.imod(v.mul(this.rinv));
                return B.red = null, B;
            }, Q.prototype.imul = function(v, B) {
                if (v.isZero() || B.isZero()) return v.words[0] = 0, v.length = 1, v;
                var g = v.imul(B), E = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = g.isub(E).iushrn(this.shift), _ = w;
                return w.cmp(this.m) >= 0 ? _ = w.isub(this.m) : w.cmpn(0) < 0 && (_ = w.iadd(this.m)), _._forceRed(this);
            }, Q.prototype.mul = function(v, B) {
                if (v.isZero() || B.isZero()) return new o(0)._forceRed(this);
                var g = v.mul(B), E = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = g.isub(E).iushrn(this.shift), _ = w;
                return w.cmp(this.m) >= 0 ? _ = w.isub(this.m) : w.cmpn(0) < 0 && (_ = w.iadd(this.m)), _._forceRed(this);
            }, Q.prototype.invm = function(v) {
                var B = this.imod(v._invmp(this.m).mul(this.r2));
                return B._forceRed(this);
            };
        })(e, Qe);
    }(Lx)), Lx.exports;
}
var ey = {
    exports: {}
}, Kx;
function Y6() {
    if (Kx) return ey.exports;
    Kx = 1;
    var e;
    ey.exports = function(n) {
        return e || (e = new t(null)), e.generate(n);
    };
    function t(n) {
        this.rand = n;
    }
    if (ey.exports.Rand = t, t.prototype.generate = function(n) {
        return this._rand(n);
    }, t.prototype._rand = function(n) {
        if (this.rand.getBytes) return this.rand.getBytes(n);
        for(var i1 = new Uint8Array(n), o = 0; o < i1.length; o++)i1[o] = this.rand.getByte();
        return i1;
    }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(n) {
        var i1 = new Uint8Array(n);
        return self.crypto.getRandomValues(i1), i1;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(n) {
        var i1 = new Uint8Array(n);
        return self.msCrypto.getRandomValues(i1), i1;
    } : typeof window == "object" && (t.prototype._rand = function() {
        throw new Error("Not implemented yet");
    });
    else try {
        var r = i5();
        if (typeof r.randomBytes != "function") throw new Error("Not supported");
        t.prototype._rand = function(n) {
            return r.randomBytes(n);
        };
    } catch  {}
    return ey.exports;
}
var gv, qx;
function OC() {
    if (qx) return gv;
    qx = 1;
    var e = Bi(), t = Y6();
    function r(n) {
        this.rand = n || new t.Rand();
    }
    return gv = r, r.create = function(n) {
        return new r(n);
    }, r.prototype._randbelow = function(n) {
        var i1 = n.bitLength(), o = Math.ceil(i1 / 8);
        do var a = new e(this.rand.generate(o));
        while (a.cmp(n) >= 0)
        return a;
    }, r.prototype._randrange = function(n, i1) {
        var o = i1.sub(n);
        return n.add(this._randbelow(o));
    }, r.prototype.test = function(n, i1, o) {
        var a = n.bitLength(), s = e.mont(n), c = new e(1).toRed(s);
        i1 || (i1 = Math.max(1, a / 48 | 0));
        for(var l = n.subn(1), u = 0; !l.testn(u); u++);
        for(var f = n.shrn(u), h = l.toRed(s), y = !0; i1 > 0; i1--){
            var S = this._randrange(new e(2), l);
            o && o(S);
            var k = S.toRed(s).redPow(f);
            if (!(k.cmp(c) === 0 || k.cmp(h) === 0)) {
                for(var P = 1; P < u; P++){
                    if (k = k.redSqr(), k.cmp(c) === 0) return !1;
                    if (k.cmp(h) === 0) break;
                }
                if (P === u) return !1;
            }
        }
        return y;
    }, r.prototype.getDivisor = function(n, i1) {
        var o = n.bitLength(), a = e.mont(n), s = new e(1).toRed(a);
        i1 || (i1 = Math.max(1, o / 48 | 0));
        for(var c = n.subn(1), l = 0; !c.testn(l); l++);
        for(var u = n.shrn(l), f = c.toRed(a); i1 > 0; i1--){
            var h = this._randrange(new e(2), c), y = n.gcd(h);
            if (y.cmpn(1) !== 0) return y;
            var S = h.toRed(a).redPow(u);
            if (!(S.cmp(s) === 0 || S.cmp(f) === 0)) {
                for(var k = 1; k < l; k++){
                    if (S = S.redSqr(), S.cmp(s) === 0) return S.fromRed().subn(1).gcd(n);
                    if (S.cmp(f) === 0) break;
                }
                if (k === l) return S = S.redSqr(), S.fromRed().subn(1).gcd(n);
            }
        }
        return !1;
    }, gv;
}
var yv, Vx;
function IC() {
    if (Vx) return yv;
    Vx = 1;
    var e = Dh();
    yv = P, P.simpleSieve = S, P.fermatTest = k;
    var t = Bi(), r = new t(24), n = OC(), i1 = new n(), o = new t(1), a = new t(2), s = new t(5);
    new t(16), new t(8);
    var c = new t(10), l = new t(3);
    new t(7);
    var u = new t(11), f = new t(4);
    new t(12);
    var h = null;
    function y() {
        if (h !== null) return h;
        var M = 1048576, N = [];
        N[0] = 2;
        for(var z = 1, K = 3; K < M; K += 2){
            for(var $ = Math.ceil(Math.sqrt(K)), ne = 0; ne < z && N[ne] <= $ && K % N[ne] !== 0; ne++);
            z !== ne && N[ne] <= $ || (N[z++] = K);
        }
        return h = N, N;
    }
    function S(M) {
        for(var N = y(), z = 0; z < N.length; z++)if (M.modn(N[z]) === 0) return M.cmpn(N[z]) === 0;
        return !0;
    }
    function k(M) {
        var N = t.mont(M);
        return a.toRed(N).redPow(M.subn(1)).fromRed().cmpn(1) === 0;
    }
    function P(M, N) {
        if (M < 16) return N === 2 || N === 5 ? new t([
            140,
            123
        ]) : new t([
            140,
            39
        ]);
        N = new t(N);
        for(var z, K;;){
            for(z = new t(e(Math.ceil(M / 8))); z.bitLength() > M;)z.ishrn(1);
            if (z.isEven() && z.iadd(o), z.testn(1) || z.iadd(a), N.cmp(a)) {
                if (!N.cmp(s)) for(; z.mod(c).cmp(l);)z.iadd(f);
            } else for(; z.mod(r).cmp(u);)z.iadd(f);
            if (K = z.shrn(1), S(K) && S(z) && k(K) && k(z) && i1.test(K) && i1.test(z)) return z;
        }
    }
    return yv;
}
const SJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, xJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, _J = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, kJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, OJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, IJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, BJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, TJ = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, PJ = {
    modp1: SJ,
    modp2: xJ,
    modp5: _J,
    modp14: kJ,
    modp15: OJ,
    modp16: IJ,
    modp17: BJ,
    modp18: TJ
};
var mv, Wx;
function CJ() {
    if (Wx) return mv;
    Wx = 1;
    var e = Bi(), t = OC(), r = new t(), n = new e(24), i1 = new e(11), o = new e(10), a = new e(3), s = new e(7), c = IC(), l = Dh();
    mv = S;
    function u(P, M) {
        return M = M || "utf8", Ke.isBuffer(P) || (P = new Ke(P, M)), this._pub = new e(P), this;
    }
    function f(P, M) {
        return M = M || "utf8", Ke.isBuffer(P) || (P = new Ke(P, M)), this._priv = new e(P), this;
    }
    var h = {};
    function y(P, M) {
        var N = M.toString("hex"), z = [
            N,
            P.toString(16)
        ].join("_");
        if (z in h) return h[z];
        var K = 0;
        if (P.isEven() || !c.simpleSieve || !c.fermatTest(P) || !r.test(P)) return K += 1, N === "02" || N === "05" ? K += 8 : K += 4, h[z] = K, K;
        r.test(P.shrn(1)) || (K += 2);
        var $;
        switch(N){
            case "02":
                P.mod(n).cmp(i1) && (K += 8);
                break;
            case "05":
                $ = P.mod(o), $.cmp(a) && $.cmp(s) && (K += 8);
                break;
            default:
                K += 4;
        }
        return h[z] = K, K;
    }
    function S(P, M, N) {
        this.setGenerator(M), this.__prime = new e(P), this._prime = e.mont(this.__prime), this._primeLen = P.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, N ? (this.setPublicKey = u, this.setPrivateKey = f) : this._primeCode = 8;
    }
    Object.defineProperty(S.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = y(this.__prime, this.__gen)), this._primeCode;
        }
    }), S.prototype.generateKeys = function() {
        return this._priv || (this._priv = new e(l(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    }, S.prototype.computeSecret = function(P) {
        P = new e(P), P = P.toRed(this._prime);
        var M = P.redPow(this._priv).fromRed(), N = new Ke(M.toArray()), z = this.getPrime();
        if (N.length < z.length) {
            var K = new Ke(z.length - N.length);
            K.fill(0), N = Ke.concat([
                K,
                N
            ]);
        }
        return N;
    }, S.prototype.getPublicKey = function(P) {
        return k(this._pub, P);
    }, S.prototype.getPrivateKey = function(P) {
        return k(this._priv, P);
    }, S.prototype.getPrime = function(P) {
        return k(this.__prime, P);
    }, S.prototype.getGenerator = function(P) {
        return k(this._gen, P);
    }, S.prototype.setGenerator = function(P, M) {
        return M = M || "utf8", Ke.isBuffer(P) || (P = new Ke(P, M)), this.__gen = P, this._gen = new e(P), this;
    };
    function k(P, M) {
        var N = new Ke(P.toArray());
        return M ? N.toString(M) : N;
    }
    return mv;
}
var Gx;
function MJ() {
    if (Gx) return _l;
    Gx = 1;
    var e = IC(), t = PJ, r = CJ();
    function n(a) {
        var s = new Ke(t[a].prime, "hex"), c = new Ke(t[a].gen, "hex");
        return new r(s, c);
    }
    var i1 = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function o(a, s, c, l) {
        return Ke.isBuffer(s) || i1[s] === void 0 ? o(a, "binary", s, c) : (s = s || "binary", l = l || "binary", c = c || new Ke([
            2
        ]), Ke.isBuffer(c) || (c = new Ke(c, l)), typeof a == "number" ? new r(e(a, c), c, !0) : (Ke.isBuffer(a) || (a = new Ke(a, s)), new r(a, c, !0)));
    }
    return _l.DiffieHellmanGroup = _l.createDiffieHellmanGroup = _l.getDiffieHellman = n, _l.createDiffieHellman = _l.DiffieHellman = o, _l;
}
var bv = {
    exports: {}
}, ty = {
    exports: {}
}, Qx;
function q2() {
    if (Qx) return ty.exports;
    Qx = 1, typeof xn > "u" || !xn.version || xn.version.indexOf("v0.") === 0 || xn.version.indexOf("v1.") === 0 && xn.version.indexOf("v1.8.") !== 0 ? ty.exports = {
        nextTick: e
    } : ty.exports = xn;
    function e(t, r, n, i1) {
        if (typeof t != "function") throw new TypeError('"callback" argument must be a function');
        var o = arguments.length, a, s;
        switch(o){
            case 0:
            case 1:
                return xn.nextTick(t);
            case 2:
                return xn.nextTick(function() {
                    t.call(null, r);
                });
            case 3:
                return xn.nextTick(function() {
                    t.call(null, r, n);
                });
            case 4:
                return xn.nextTick(function() {
                    t.call(null, r, n, i1);
                });
            default:
                for(a = new Array(o - 1), s = 0; s < a.length;)a[s++] = arguments[s];
                return xn.nextTick(function() {
                    t.apply(null, a);
                });
        }
    }
    return ty.exports;
}
var wv, $x;
function NJ() {
    if ($x) return wv;
    $x = 1;
    var e = {}.toString;
    return wv = Array.isArray || function(t) {
        return e.call(t) == "[object Array]";
    }, wv;
}
var ry = {
    exports: {}
}, Zx;
function BC() {
    if (Zx) return ry.exports;
    Zx = 1;
    var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(K, $, ne) {
        return Function.prototype.apply.call(K, $, ne);
    }, r;
    e && typeof e.ownKeys == "function" ? r = e.ownKeys : Object.getOwnPropertySymbols ? r = function(K) {
        return Object.getOwnPropertyNames(K).concat(Object.getOwnPropertySymbols(K));
    } : r = function(K) {
        return Object.getOwnPropertyNames(K);
    };
    function n(K) {
        console && console.warn && console.warn(K);
    }
    var i1 = Number.isNaN || function(K) {
        return K !== K;
    };
    function o() {
        o.init.call(this);
    }
    ry.exports = o, ry.exports.once = M, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    var a = 10;
    function s(K) {
        if (typeof K != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof K);
    }
    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return a;
        },
        set: function(K) {
            if (typeof K != "number" || K < 0 || i1(K)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + K + ".");
            a = K;
        }
    }), o.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, o.prototype.setMaxListeners = function(K) {
        if (typeof K != "number" || K < 0 || i1(K)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + K + ".");
        return this._maxListeners = K, this;
    };
    function c(K) {
        return K._maxListeners === void 0 ? o.defaultMaxListeners : K._maxListeners;
    }
    o.prototype.getMaxListeners = function() {
        return c(this);
    }, o.prototype.emit = function(K) {
        for(var $ = [], ne = 1; ne < arguments.length; ne++)$.push(arguments[ne]);
        var ee = K === "error", q = this._events;
        if (q !== void 0) ee = ee && q.error === void 0;
        else if (!ee) return !1;
        if (ee) {
            var U;
            if ($.length > 0 && (U = $[0]), U instanceof Error) throw U;
            var Q = new Error("Unhandled error." + (U ? " (" + U.message + ")" : ""));
            throw Q.context = U, Q;
        }
        var v = q[K];
        if (v === void 0) return !1;
        if (typeof v == "function") t(v, this, $);
        else for(var B = v.length, g = S(v, B), ne = 0; ne < B; ++ne)t(g[ne], this, $);
        return !0;
    };
    function l(K, $, ne, ee) {
        var q, U, Q;
        if (s(ne), U = K._events, U === void 0 ? (U = K._events = /* @__PURE__ */ Object.create(null), K._eventsCount = 0) : (U.newListener !== void 0 && (K.emit("newListener", $, ne.listener ? ne.listener : ne), U = K._events), Q = U[$]), Q === void 0) Q = U[$] = ne, ++K._eventsCount;
        else if (typeof Q == "function" ? Q = U[$] = ee ? [
            ne,
            Q
        ] : [
            Q,
            ne
        ] : ee ? Q.unshift(ne) : Q.push(ne), q = c(K), q > 0 && Q.length > q && !Q.warned) {
            Q.warned = !0;
            var v = new Error("Possible EventEmitter memory leak detected. " + Q.length + " " + String($) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            v.name = "MaxListenersExceededWarning", v.emitter = K, v.type = $, v.count = Q.length, n(v);
        }
        return K;
    }
    o.prototype.addListener = function(K, $) {
        return l(this, K, $, !1);
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(K, $) {
        return l(this, K, $, !0);
    };
    function u() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function f(K, $, ne) {
        var ee = {
            fired: !1,
            wrapFn: void 0,
            target: K,
            type: $,
            listener: ne
        }, q = u.bind(ee);
        return q.listener = ne, ee.wrapFn = q, q;
    }
    o.prototype.once = function(K, $) {
        return s($), this.on(K, f(this, K, $)), this;
    }, o.prototype.prependOnceListener = function(K, $) {
        return s($), this.prependListener(K, f(this, K, $)), this;
    }, o.prototype.removeListener = function(K, $) {
        var ne, ee, q, U, Q;
        if (s($), ee = this._events, ee === void 0) return this;
        if (ne = ee[K], ne === void 0) return this;
        if (ne === $ || ne.listener === $) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ee[K], ee.removeListener && this.emit("removeListener", K, ne.listener || $));
        else if (typeof ne != "function") {
            for(q = -1, U = ne.length - 1; U >= 0; U--)if (ne[U] === $ || ne[U].listener === $) {
                Q = ne[U].listener, q = U;
                break;
            }
            if (q < 0) return this;
            q === 0 ? ne.shift() : k(ne, q), ne.length === 1 && (ee[K] = ne[0]), ee.removeListener !== void 0 && this.emit("removeListener", K, Q || $);
        }
        return this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(K) {
        var $, ne, ee;
        if (ne = this._events, ne === void 0) return this;
        if (ne.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ne[K] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ne[K]), this;
        if (arguments.length === 0) {
            var q = Object.keys(ne), U;
            for(ee = 0; ee < q.length; ++ee)U = q[ee], U !== "removeListener" && this.removeAllListeners(U);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ($ = ne[K], typeof $ == "function") this.removeListener(K, $);
        else if ($ !== void 0) for(ee = $.length - 1; ee >= 0; ee--)this.removeListener(K, $[ee]);
        return this;
    };
    function h(K, $, ne) {
        var ee = K._events;
        if (ee === void 0) return [];
        var q = ee[$];
        return q === void 0 ? [] : typeof q == "function" ? ne ? [
            q.listener || q
        ] : [
            q
        ] : ne ? P(q) : S(q, q.length);
    }
    o.prototype.listeners = function(K) {
        return h(this, K, !0);
    }, o.prototype.rawListeners = function(K) {
        return h(this, K, !1);
    }, o.listenerCount = function(K, $) {
        return typeof K.listenerCount == "function" ? K.listenerCount($) : y.call(K, $);
    }, o.prototype.listenerCount = y;
    function y(K) {
        var $ = this._events;
        if ($ !== void 0) {
            var ne = $[K];
            if (typeof ne == "function") return 1;
            if (ne !== void 0) return ne.length;
        }
        return 0;
    }
    o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r(this._events) : [];
    };
    function S(K, $) {
        for(var ne = new Array($), ee = 0; ee < $; ++ee)ne[ee] = K[ee];
        return ne;
    }
    function k(K, $) {
        for(; $ + 1 < K.length; $++)K[$] = K[$ + 1];
        K.pop();
    }
    function P(K) {
        for(var $ = new Array(K.length), ne = 0; ne < $.length; ++ne)$[ne] = K[ne].listener || K[ne];
        return $;
    }
    function M(K, $) {
        return new Promise(function(ne, ee) {
            function q(Q) {
                K.removeListener($, U), ee(Q);
            }
            function U() {
                typeof K.removeListener == "function" && K.removeListener("error", q), ne([].slice.call(arguments));
            }
            z(K, $, U, {
                once: !0
            }), $ !== "error" && N(K, q, {
                once: !0
            });
        });
    }
    function N(K, $, ne) {
        typeof K.on == "function" && z(K, "error", $, ne);
    }
    function z(K, $, ne, ee) {
        if (typeof K.on == "function") ee.once ? K.once($, ne) : K.on($, ne);
        else if (typeof K.addEventListener == "function") K.addEventListener($, function q(U) {
            ee.once && K.removeEventListener($, q), ne(U);
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof K);
    }
    return ry.exports;
}
var Xx, Yx;
function TC() {
    return Yx || (Yx = 1, Xx = BC().EventEmitter), Xx;
}
var Av = {
    exports: {}
}, Jx;
function V2() {
    return Jx || (Jx = 1, function(e, t) {
        var r = ul, n = r.Buffer;
        function i1(a, s) {
            for(var c in a)s[c] = a[c];
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i1(r, t), t.Buffer = o);
        function o(a, s, c) {
            return n(a, s, c);
        }
        i1(n, o), o.from = function(a, s, c) {
            if (typeof a == "number") throw new TypeError("Argument must not be a number");
            return n(a, s, c);
        }, o.alloc = function(a, s, c) {
            if (typeof a != "number") throw new TypeError("Argument must be a number");
            var l = n(a);
            return s !== void 0 ? typeof c == "string" ? l.fill(s, c) : l.fill(s) : l.fill(0), l;
        }, o.allocUnsafe = function(a) {
            if (typeof a != "number") throw new TypeError("Argument must be a number");
            return n(a);
        }, o.allocUnsafeSlow = function(a) {
            if (typeof a != "number") throw new TypeError("Argument must be a number");
            return r.SlowBuffer(a);
        };
    }(Av, Av.exports)), Av.exports;
}
var vi = {}, e_;
function A1() {
    if (e_) return vi;
    e_ = 1;
    function e(k) {
        return Array.isArray ? Array.isArray(k) : S(k) === "[object Array]";
    }
    vi.isArray = e;
    function t(k) {
        return typeof k == "boolean";
    }
    vi.isBoolean = t;
    function r(k) {
        return k === null;
    }
    vi.isNull = r;
    function n(k) {
        return k == null;
    }
    vi.isNullOrUndefined = n;
    function i1(k) {
        return typeof k == "number";
    }
    vi.isNumber = i1;
    function o(k) {
        return typeof k == "string";
    }
    vi.isString = o;
    function a(k) {
        return typeof k == "symbol";
    }
    vi.isSymbol = a;
    function s(k) {
        return k === void 0;
    }
    vi.isUndefined = s;
    function c(k) {
        return S(k) === "[object RegExp]";
    }
    vi.isRegExp = c;
    function l(k) {
        return typeof k == "object" && k !== null;
    }
    vi.isObject = l;
    function u(k) {
        return S(k) === "[object Date]";
    }
    vi.isDate = u;
    function f(k) {
        return S(k) === "[object Error]" || k instanceof Error;
    }
    vi.isError = f;
    function h(k) {
        return typeof k == "function";
    }
    vi.isFunction = h;
    function y(k) {
        return k === null || typeof k == "boolean" || typeof k == "number" || typeof k == "string" || typeof k == "symbol" || // ES6 symbol
        typeof k > "u";
    }
    vi.isPrimitive = y, vi.isBuffer = ul.Buffer.isBuffer;
    function S(k) {
        return Object.prototype.toString.call(k);
    }
    return vi;
}
var t_ = {
    exports: {}
}, r_;
function RJ() {
    return r_ || (r_ = 1, function(e) {
        function t(o, a) {
            if (!(o instanceof a)) throw new TypeError("Cannot call a class as a function");
        }
        var r = V2().Buffer, n = cl;
        function i1(o, a, s) {
            o.copy(a, s);
        }
        e.exports = function() {
            function o() {
                t(this, o), this.head = null, this.tail = null, this.length = 0;
            }
            return o.prototype.push = function(a) {
                var s = {
                    data: a,
                    next: null
                };
                this.length > 0 ? this.tail.next = s : this.head = s, this.tail = s, ++this.length;
            }, o.prototype.unshift = function(a) {
                var s = {
                    data: a,
                    next: this.head
                };
                this.length === 0 && (this.tail = s), this.head = s, ++this.length;
            }, o.prototype.shift = function() {
                if (this.length !== 0) {
                    var a = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, a;
                }
            }, o.prototype.clear = function() {
                this.head = this.tail = null, this.length = 0;
            }, o.prototype.join = function(a) {
                if (this.length === 0) return "";
                for(var s = this.head, c = "" + s.data; s = s.next;)c += a + s.data;
                return c;
            }, o.prototype.concat = function(a) {
                if (this.length === 0) return r.alloc(0);
                for(var s = r.allocUnsafe(a >>> 0), c = this.head, l = 0; c;)i1(c.data, s, l), l += c.data.length, c = c.next;
                return s;
            }, o;
        }(), n && n.inspect && n.inspect.custom && (e.exports.prototype[n.inspect.custom] = function() {
            var o = n.inspect({
                length: this.length
            });
            return this.constructor.name + " " + o;
        });
    }(t_)), t_.exports;
}
var vv, n_;
function PC() {
    if (n_) return vv;
    n_ = 1;
    var e = q2();
    function t(i1, o) {
        var a = this, s = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
        return s || c ? (o ? o(i1) : i1 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(n, this, i1)) : e.nextTick(n, this, i1)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i1 || null, function(l) {
            !o && l ? a._writableState ? a._writableState.errorEmitted || (a._writableState.errorEmitted = !0, e.nextTick(n, a, l)) : e.nextTick(n, a, l) : o && o(l);
        }), this);
    }
    function r() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function n(i1, o) {
        i1.emit("error", o);
    }
    return vv = {
        destroy: t,
        undestroy: r
    }, vv;
}
var Ev, i_;
function UJ() {
    if (i_) return Ev;
    i_ = 1, Ev = e;
    function e(r, n) {
        if (t("noDeprecation")) return r;
        var i1 = !1;
        function o() {
            if (!i1) {
                if (t("throwDeprecation")) throw new Error(n);
                t("traceDeprecation") ? console.trace(n) : console.warn(n), i1 = !0;
            }
            return r.apply(this, arguments);
        }
        return o;
    }
    function t(r) {
        try {
            if (!Qe.localStorage) return !1;
        } catch  {
            return !1;
        }
        var n = Qe.localStorage[r];
        return n == null ? !1 : String(n).toLowerCase() === "true";
    }
    return Ev;
}
var Sv, o_;
function CC() {
    if (o_) return Sv;
    o_ = 1;
    var e = q2();
    Sv = k;
    function t(O) {
        var I = this;
        this.next = null, this.entry = null, this.finish = function() {
            _(I, O);
        };
    }
    var r = !xn.browser && [
        "v0.10",
        "v0.9."
    ].indexOf(xn.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, n;
    k.WritableState = y;
    var i1 = Object.create(A1());
    i1.inherits = Nr();
    var o = {
        deprecate: UJ()
    }, a = TC(), s = V2().Buffer, c = (typeof Qe < "u" ? Qe : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function l(O) {
        return s.from(O);
    }
    function u(O) {
        return s.isBuffer(O) || O instanceof c;
    }
    var f = PC();
    i1.inherits(k, a);
    function h() {}
    function y(O, I) {
        n = n || dh(), O = O || {};
        var x = I instanceof n;
        this.objectMode = !!O.objectMode, x && (this.objectMode = this.objectMode || !!O.writableObjectMode);
        var R = O.highWaterMark, j = O.writableHighWaterMark, Y = this.objectMode ? 16 : 16 * 1024;
        R || R === 0 ? this.highWaterMark = R : x && (j || j === 0) ? this.highWaterMark = j : this.highWaterMark = Y, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var he = O.decodeStrings === !1;
        this.decodeStrings = !he, this.defaultEncoding = O.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ue) {
            ee(I, ue);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
    }
    y.prototype.getBuffer = function() {
        for(var O = this.bufferedRequest, I = []; O;)I.push(O), O = O.next;
        return I;
    }, function() {
        try {
            Object.defineProperty(y.prototype, "buffer", {
                get: o.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch  {}
    }();
    var S;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (S = Function.prototype[Symbol.hasInstance], Object.defineProperty(k, Symbol.hasInstance, {
        value: function(O) {
            return S.call(this, O) ? !0 : this !== k ? !1 : O && O._writableState instanceof y;
        }
    })) : S = function(O) {
        return O instanceof this;
    };
    function k(O) {
        if (n = n || dh(), !S.call(k, this) && !(this instanceof n)) return new k(O);
        this._writableState = new y(O, this), this.writable = !0, O && (typeof O.write == "function" && (this._write = O.write), typeof O.writev == "function" && (this._writev = O.writev), typeof O.destroy == "function" && (this._destroy = O.destroy), typeof O.final == "function" && (this._final = O.final)), a.call(this);
    }
    k.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function P(O, I) {
        var x = new Error("write after end");
        O.emit("error", x), e.nextTick(I, x);
    }
    function M(O, I, x, R) {
        var j = !0, Y = !1;
        return x === null ? Y = new TypeError("May not write null values to stream") : typeof x != "string" && x !== void 0 && !I.objectMode && (Y = new TypeError("Invalid non-string/buffer chunk")), Y && (O.emit("error", Y), e.nextTick(R, Y), j = !1), j;
    }
    k.prototype.write = function(O, I, x) {
        var R = this._writableState, j = !1, Y = !R.objectMode && u(O);
        return Y && !s.isBuffer(O) && (O = l(O)), typeof I == "function" && (x = I, I = null), Y ? I = "buffer" : I || (I = R.defaultEncoding), typeof x != "function" && (x = h), R.ended ? P(this, x) : (Y || M(this, R, O, x)) && (R.pendingcb++, j = z(this, R, Y, O, I, x)), j;
    }, k.prototype.cork = function() {
        var O = this._writableState;
        O.corked++;
    }, k.prototype.uncork = function() {
        var O = this._writableState;
        O.corked && (O.corked--, !O.writing && !O.corked && !O.bufferProcessing && O.bufferedRequest && Q(this, O));
    }, k.prototype.setDefaultEncoding = function(O) {
        if (typeof O == "string" && (O = O.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((O + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + O);
        return this._writableState.defaultEncoding = O, this;
    };
    function N(O, I, x) {
        return !O.objectMode && O.decodeStrings !== !1 && typeof I == "string" && (I = s.from(I, x)), I;
    }
    Object.defineProperty(k.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function z(O, I, x, R, j, Y) {
        if (!x) {
            var he = N(I, R, j);
            R !== he && (x = !0, j = "buffer", R = he);
        }
        var ue = I.objectMode ? 1 : R.length;
        I.length += ue;
        var G = I.length < I.highWaterMark;
        if (G || (I.needDrain = !0), I.writing || I.corked) {
            var se = I.lastBufferedRequest;
            I.lastBufferedRequest = {
                chunk: R,
                encoding: j,
                isBuf: x,
                callback: Y,
                next: null
            }, se ? se.next = I.lastBufferedRequest : I.bufferedRequest = I.lastBufferedRequest, I.bufferedRequestCount += 1;
        } else K(O, I, !1, ue, R, j, Y);
        return G;
    }
    function K(O, I, x, R, j, Y, he) {
        I.writelen = R, I.writecb = he, I.writing = !0, I.sync = !0, x ? O._writev(j, I.onwrite) : O._write(j, Y, I.onwrite), I.sync = !1;
    }
    function $(O, I, x, R, j) {
        --I.pendingcb, x ? (e.nextTick(j, R), e.nextTick(E, O, I), O._writableState.errorEmitted = !0, O.emit("error", R)) : (j(R), O._writableState.errorEmitted = !0, O.emit("error", R), E(O, I));
    }
    function ne(O) {
        O.writing = !1, O.writecb = null, O.length -= O.writelen, O.writelen = 0;
    }
    function ee(O, I) {
        var x = O._writableState, R = x.sync, j = x.writecb;
        if (ne(x), I) $(O, x, R, I, j);
        else {
            var Y = v(x);
            !Y && !x.corked && !x.bufferProcessing && x.bufferedRequest && Q(O, x), R ? r(q, O, x, Y, j) : q(O, x, Y, j);
        }
    }
    function q(O, I, x, R) {
        x || U(O, I), I.pendingcb--, R(), E(O, I);
    }
    function U(O, I) {
        I.length === 0 && I.needDrain && (I.needDrain = !1, O.emit("drain"));
    }
    function Q(O, I) {
        I.bufferProcessing = !0;
        var x = I.bufferedRequest;
        if (O._writev && x && x.next) {
            var R = I.bufferedRequestCount, j = new Array(R), Y = I.corkedRequestsFree;
            Y.entry = x;
            for(var he = 0, ue = !0; x;)j[he] = x, x.isBuf || (ue = !1), x = x.next, he += 1;
            j.allBuffers = ue, K(O, I, !0, I.length, j, "", Y.finish), I.pendingcb++, I.lastBufferedRequest = null, Y.next ? (I.corkedRequestsFree = Y.next, Y.next = null) : I.corkedRequestsFree = new t(I), I.bufferedRequestCount = 0;
        } else {
            for(; x;){
                var G = x.chunk, se = x.encoding, Z = x.callback, ie = I.objectMode ? 1 : G.length;
                if (K(O, I, !1, ie, G, se, Z), x = x.next, I.bufferedRequestCount--, I.writing) break;
            }
            x === null && (I.lastBufferedRequest = null);
        }
        I.bufferedRequest = x, I.bufferProcessing = !1;
    }
    k.prototype._write = function(O, I, x) {
        x(new Error("_write() is not implemented"));
    }, k.prototype._writev = null, k.prototype.end = function(O, I, x) {
        var R = this._writableState;
        typeof O == "function" ? (x = O, O = null, I = null) : typeof I == "function" && (x = I, I = null), O != null && this.write(O, I), R.corked && (R.corked = 1, this.uncork()), R.ending || w(this, R, x);
    };
    function v(O) {
        return O.ending && O.length === 0 && O.bufferedRequest === null && !O.finished && !O.writing;
    }
    function B(O, I) {
        O._final(function(x) {
            I.pendingcb--, x && O.emit("error", x), I.prefinished = !0, O.emit("prefinish"), E(O, I);
        });
    }
    function g(O, I) {
        !I.prefinished && !I.finalCalled && (typeof O._final == "function" ? (I.pendingcb++, I.finalCalled = !0, e.nextTick(B, O, I)) : (I.prefinished = !0, O.emit("prefinish")));
    }
    function E(O, I) {
        var x = v(I);
        return x && (g(O, I), I.pendingcb === 0 && (I.finished = !0, O.emit("finish"))), x;
    }
    function w(O, I, x) {
        I.ending = !0, E(O, I), x && (I.finished ? e.nextTick(x) : O.once("finish", x)), I.ended = !0, O.writable = !1;
    }
    function _(O, I, x) {
        var R = O.entry;
        for(O.entry = null; R;){
            var j = R.callback;
            I.pendingcb--, j(x), R = R.next;
        }
        I.corkedRequestsFree.next = O;
    }
    return Object.defineProperty(k.prototype, "destroyed", {
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(O) {
            this._writableState && (this._writableState.destroyed = O);
        }
    }), k.prototype.destroy = f.destroy, k.prototype._undestroy = f.undestroy, k.prototype._destroy = function(O, I) {
        this.end(), I(O);
    }, Sv;
}
var xv, a_;
function dh() {
    if (a_) return xv;
    a_ = 1;
    var e = q2(), t = Object.keys || function(f) {
        var h = [];
        for(var y in f)h.push(y);
        return h;
    };
    xv = c;
    var r = Object.create(A1());
    r.inherits = Nr();
    var n = MC(), i1 = CC();
    r.inherits(c, n);
    for(var o = t(i1.prototype), a = 0; a < o.length; a++){
        var s = o[a];
        c.prototype[s] || (c.prototype[s] = i1.prototype[s]);
    }
    function c(f) {
        if (!(this instanceof c)) return new c(f);
        n.call(this, f), i1.call(this, f), f && f.readable === !1 && (this.readable = !1), f && f.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, f && f.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", l);
    }
    Object.defineProperty(c.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function l() {
        this.allowHalfOpen || this._writableState.ended || e.nextTick(u, this);
    }
    function u(f) {
        f.end();
    }
    return Object.defineProperty(c.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(f) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
        }
    }), c.prototype._destroy = function(f, h) {
        this.push(null), this.end(), e.nextTick(h, f);
    }, xv;
}
var _v = {}, s_;
function u_() {
    if (s_) return _v;
    s_ = 1;
    var e = V2().Buffer, t = e.isEncoding || function(M) {
        switch(M = "" + M, M && M.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function r(M) {
        if (!M) return "utf8";
        for(var N;;)switch(M){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return M;
            default:
                if (N) return;
                M = ("" + M).toLowerCase(), N = !0;
        }
    }
    function n(M) {
        var N = r(M);
        if (typeof N != "string" && (e.isEncoding === t || !t(M))) throw new Error("Unknown encoding: " + M);
        return N || M;
    }
    _v.StringDecoder = i1;
    function i1(M) {
        this.encoding = n(M);
        var N;
        switch(this.encoding){
            case "utf16le":
                this.text = f, this.end = h, N = 4;
                break;
            case "utf8":
                this.fillLast = c, N = 4;
                break;
            case "base64":
                this.text = y, this.end = S, N = 3;
                break;
            default:
                this.write = k, this.end = P;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(N);
    }
    i1.prototype.write = function(M) {
        if (M.length === 0) return "";
        var N, z;
        if (this.lastNeed) {
            if (N = this.fillLast(M), N === void 0) return "";
            z = this.lastNeed, this.lastNeed = 0;
        } else z = 0;
        return z < M.length ? N ? N + this.text(M, z) : this.text(M, z) : N || "";
    }, i1.prototype.end = u, i1.prototype.text = l, i1.prototype.fillLast = function(M) {
        if (this.lastNeed <= M.length) return M.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        M.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, M.length), this.lastNeed -= M.length;
    };
    function o(M) {
        return M <= 127 ? 0 : M >> 5 === 6 ? 2 : M >> 4 === 14 ? 3 : M >> 3 === 30 ? 4 : M >> 6 === 2 ? -1 : -2;
    }
    function a(M, N, z) {
        var K = N.length - 1;
        if (K < z) return 0;
        var $ = o(N[K]);
        return $ >= 0 ? ($ > 0 && (M.lastNeed = $ - 1), $) : --K < z || $ === -2 ? 0 : ($ = o(N[K]), $ >= 0 ? ($ > 0 && (M.lastNeed = $ - 2), $) : --K < z || $ === -2 ? 0 : ($ = o(N[K]), $ >= 0 ? ($ > 0 && ($ === 2 ? $ = 0 : M.lastNeed = $ - 3), $) : 0));
    }
    function s(M, N, z) {
        if ((N[0] & 192) !== 128) return M.lastNeed = 0, "";
        if (M.lastNeed > 1 && N.length > 1) {
            if ((N[1] & 192) !== 128) return M.lastNeed = 1, "";
            if (M.lastNeed > 2 && N.length > 2 && (N[2] & 192) !== 128) return M.lastNeed = 2, "";
        }
    }
    function c(M) {
        var N = this.lastTotal - this.lastNeed, z = s(this, M);
        if (z !== void 0) return z;
        if (this.lastNeed <= M.length) return M.copy(this.lastChar, N, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        M.copy(this.lastChar, N, 0, M.length), this.lastNeed -= M.length;
    }
    function l(M, N) {
        var z = a(this, M, N);
        if (!this.lastNeed) return M.toString("utf8", N);
        this.lastTotal = z;
        var K = M.length - (z - this.lastNeed);
        return M.copy(this.lastChar, 0, K), M.toString("utf8", N, K);
    }
    function u(M) {
        var N = M && M.length ? this.write(M) : "";
        return this.lastNeed ? N + "" : N;
    }
    function f(M, N) {
        if ((M.length - N) % 2 === 0) {
            var z = M.toString("utf16le", N);
            if (z) {
                var K = z.charCodeAt(z.length - 1);
                if (K >= 55296 && K <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = M[M.length - 2], this.lastChar[1] = M[M.length - 1], z.slice(0, -1);
            }
            return z;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = M[M.length - 1], M.toString("utf16le", N, M.length - 1);
    }
    function h(M) {
        var N = M && M.length ? this.write(M) : "";
        if (this.lastNeed) {
            var z = this.lastTotal - this.lastNeed;
            return N + this.lastChar.toString("utf16le", 0, z);
        }
        return N;
    }
    function y(M, N) {
        var z = (M.length - N) % 3;
        return z === 0 ? M.toString("base64", N) : (this.lastNeed = 3 - z, this.lastTotal = 3, z === 1 ? this.lastChar[0] = M[M.length - 1] : (this.lastChar[0] = M[M.length - 2], this.lastChar[1] = M[M.length - 1]), M.toString("base64", N, M.length - z));
    }
    function S(M) {
        var N = M && M.length ? this.write(M) : "";
        return this.lastNeed ? N + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : N;
    }
    function k(M) {
        return M.toString(this.encoding);
    }
    function P(M) {
        return M && M.length ? this.write(M) : "";
    }
    return _v;
}
var kv, c_;
function MC() {
    if (c_) return kv;
    c_ = 1;
    var e = q2();
    kv = N;
    var t = NJ(), r;
    N.ReadableState = M, BC().EventEmitter;
    var n = function(Z, ie) {
        return Z.listeners(ie).length;
    }, i1 = TC(), o = V2().Buffer, a = (typeof Qe < "u" ? Qe : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
    function s(Z) {
        return o.from(Z);
    }
    function c(Z) {
        return o.isBuffer(Z) || Z instanceof a;
    }
    var l = Object.create(A1());
    l.inherits = Nr();
    var u = cl, f = void 0;
    u && u.debuglog ? f = u.debuglog("stream") : f = function() {};
    var h = RJ(), y = PC(), S;
    l.inherits(N, i1);
    var k = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function P(Z, ie, pe) {
        if (typeof Z.prependListener == "function") return Z.prependListener(ie, pe);
        !Z._events || !Z._events[ie] ? Z.on(ie, pe) : t(Z._events[ie]) ? Z._events[ie].unshift(pe) : Z._events[ie] = [
            pe,
            Z._events[ie]
        ];
    }
    function M(Z, ie) {
        r = r || dh(), Z = Z || {};
        var pe = ie instanceof r;
        this.objectMode = !!Z.objectMode, pe && (this.objectMode = this.objectMode || !!Z.readableObjectMode);
        var ve = Z.highWaterMark, Ie = Z.readableHighWaterMark, Me = this.objectMode ? 16 : 16 * 1024;
        ve || ve === 0 ? this.highWaterMark = ve : pe && (Ie || Ie === 0) ? this.highWaterMark = Ie : this.highWaterMark = Me, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Z.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Z.encoding && (S || (S = u_().StringDecoder), this.decoder = new S(Z.encoding), this.encoding = Z.encoding);
    }
    function N(Z) {
        if (r = r || dh(), !(this instanceof N)) return new N(Z);
        this._readableState = new M(Z, this), this.readable = !0, Z && (typeof Z.read == "function" && (this._read = Z.read), typeof Z.destroy == "function" && (this._destroy = Z.destroy)), i1.call(this);
    }
    Object.defineProperty(N.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(Z) {
            this._readableState && (this._readableState.destroyed = Z);
        }
    }), N.prototype.destroy = y.destroy, N.prototype._undestroy = y.undestroy, N.prototype._destroy = function(Z, ie) {
        this.push(null), ie(Z);
    }, N.prototype.push = function(Z, ie) {
        var pe = this._readableState, ve;
        return pe.objectMode ? ve = !0 : typeof Z == "string" && (ie = ie || pe.defaultEncoding, ie !== pe.encoding && (Z = o.from(Z, ie), ie = ""), ve = !0), z(this, Z, ie, !1, ve);
    }, N.prototype.unshift = function(Z) {
        return z(this, Z, null, !0, !1);
    };
    function z(Z, ie, pe, ve, Ie) {
        var Me = Z._readableState;
        if (ie === null) Me.reading = !1, Q(Z, Me);
        else {
            var Re;
            Ie || (Re = $(Me, ie)), Re ? Z.emit("error", Re) : Me.objectMode || ie && ie.length > 0 ? (typeof ie != "string" && !Me.objectMode && Object.getPrototypeOf(ie) !== o.prototype && (ie = s(ie)), ve ? Me.endEmitted ? Z.emit("error", new Error("stream.unshift() after end event")) : K(Z, Me, ie, !0) : Me.ended ? Z.emit("error", new Error("stream.push() after EOF")) : (Me.reading = !1, Me.decoder && !pe ? (ie = Me.decoder.write(ie), Me.objectMode || ie.length !== 0 ? K(Z, Me, ie, !1) : g(Z, Me)) : K(Z, Me, ie, !1))) : ve || (Me.reading = !1);
        }
        return ne(Me);
    }
    function K(Z, ie, pe, ve) {
        ie.flowing && ie.length === 0 && !ie.sync ? (Z.emit("data", pe), Z.read(0)) : (ie.length += ie.objectMode ? 1 : pe.length, ve ? ie.buffer.unshift(pe) : ie.buffer.push(pe), ie.needReadable && v(Z)), g(Z, ie);
    }
    function $(Z, ie) {
        var pe;
        return !c(ie) && typeof ie != "string" && ie !== void 0 && !Z.objectMode && (pe = new TypeError("Invalid non-string/buffer chunk")), pe;
    }
    function ne(Z) {
        return !Z.ended && (Z.needReadable || Z.length < Z.highWaterMark || Z.length === 0);
    }
    N.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    }, N.prototype.setEncoding = function(Z) {
        return S || (S = u_().StringDecoder), this._readableState.decoder = new S(Z), this._readableState.encoding = Z, this;
    };
    var ee = 8388608;
    function q(Z) {
        return Z >= ee ? Z = ee : (Z--, Z |= Z >>> 1, Z |= Z >>> 2, Z |= Z >>> 4, Z |= Z >>> 8, Z |= Z >>> 16, Z++), Z;
    }
    function U(Z, ie) {
        return Z <= 0 || ie.length === 0 && ie.ended ? 0 : ie.objectMode ? 1 : Z !== Z ? ie.flowing && ie.length ? ie.buffer.head.data.length : ie.length : (Z > ie.highWaterMark && (ie.highWaterMark = q(Z)), Z <= ie.length ? Z : ie.ended ? ie.length : (ie.needReadable = !0, 0));
    }
    N.prototype.read = function(Z) {
        f("read", Z), Z = parseInt(Z, 10);
        var ie = this._readableState, pe = Z;
        if (Z !== 0 && (ie.emittedReadable = !1), Z === 0 && ie.needReadable && (ie.length >= ie.highWaterMark || ie.ended)) return f("read: emitReadable", ie.length, ie.ended), ie.length === 0 && ie.ended ? ue(this) : v(this), null;
        if (Z = U(Z, ie), Z === 0 && ie.ended) return ie.length === 0 && ue(this), null;
        var ve = ie.needReadable;
        f("need readable", ve), (ie.length === 0 || ie.length - Z < ie.highWaterMark) && (ve = !0, f("length less than watermark", ve)), ie.ended || ie.reading ? (ve = !1, f("reading or ended", ve)) : ve && (f("do read"), ie.reading = !0, ie.sync = !0, ie.length === 0 && (ie.needReadable = !0), this._read(ie.highWaterMark), ie.sync = !1, ie.reading || (Z = U(pe, ie)));
        var Ie;
        return Z > 0 ? Ie = R(Z, ie) : Ie = null, Ie === null ? (ie.needReadable = !0, Z = 0) : ie.length -= Z, ie.length === 0 && (ie.ended || (ie.needReadable = !0), pe !== Z && ie.ended && ue(this)), Ie !== null && this.emit("data", Ie), Ie;
    };
    function Q(Z, ie) {
        if (!ie.ended) {
            if (ie.decoder) {
                var pe = ie.decoder.end();
                pe && pe.length && (ie.buffer.push(pe), ie.length += ie.objectMode ? 1 : pe.length);
            }
            ie.ended = !0, v(Z);
        }
    }
    function v(Z) {
        var ie = Z._readableState;
        ie.needReadable = !1, ie.emittedReadable || (f("emitReadable", ie.flowing), ie.emittedReadable = !0, ie.sync ? e.nextTick(B, Z) : B(Z));
    }
    function B(Z) {
        f("emit readable"), Z.emit("readable"), x(Z);
    }
    function g(Z, ie) {
        ie.readingMore || (ie.readingMore = !0, e.nextTick(E, Z, ie));
    }
    function E(Z, ie) {
        for(var pe = ie.length; !ie.reading && !ie.flowing && !ie.ended && ie.length < ie.highWaterMark && (f("maybeReadMore read 0"), Z.read(0), pe !== ie.length);)pe = ie.length;
        ie.readingMore = !1;
    }
    N.prototype._read = function(Z) {
        this.emit("error", new Error("_read() is not implemented"));
    }, N.prototype.pipe = function(Z, ie) {
        var pe = this, ve = this._readableState;
        switch(ve.pipesCount){
            case 0:
                ve.pipes = Z;
                break;
            case 1:
                ve.pipes = [
                    ve.pipes,
                    Z
                ];
                break;
            default:
                ve.pipes.push(Z);
                break;
        }
        ve.pipesCount += 1, f("pipe count=%d opts=%j", ve.pipesCount, ie);
        var Ie = (!ie || ie.end !== !1) && Z !== xn.stdout && Z !== xn.stderr, Me = Ie ? C : A;
        ve.endEmitted ? e.nextTick(Me) : pe.once("end", Me), Z.on("unpipe", Re);
        function Re(V, re) {
            f("onunpipe"), V === pe && re && re.hasUnpiped === !1 && (re.hasUnpiped = !0, je());
        }
        function C() {
            f("onend"), Z.end();
        }
        var J = w(pe);
        Z.on("drain", J);
        var me = !1;
        function je() {
            f("cleanup"), Z.removeListener("close", Ge), Z.removeListener("finish", p), Z.removeListener("drain", J), Z.removeListener("error", We), Z.removeListener("unpipe", Re), pe.removeListener("end", C), pe.removeListener("end", A), pe.removeListener("data", nt), me = !0, ve.awaitDrain && (!Z._writableState || Z._writableState.needDrain) && J();
        }
        var Ve = !1;
        pe.on("data", nt);
        function nt(V) {
            f("ondata"), Ve = !1;
            var re = Z.write(V);
            re === !1 && !Ve && ((ve.pipesCount === 1 && ve.pipes === Z || ve.pipesCount > 1 && se(ve.pipes, Z) !== -1) && !me && (f("false write response, pause", ve.awaitDrain), ve.awaitDrain++, Ve = !0), pe.pause());
        }
        function We(V) {
            f("onerror", V), A(), Z.removeListener("error", We), n(Z, "error") === 0 && Z.emit("error", V);
        }
        P(Z, "error", We);
        function Ge() {
            Z.removeListener("finish", p), A();
        }
        Z.once("close", Ge);
        function p() {
            f("onfinish"), Z.removeListener("close", Ge), A();
        }
        Z.once("finish", p);
        function A() {
            f("unpipe"), pe.unpipe(Z);
        }
        return Z.emit("pipe", pe), ve.flowing || (f("pipe resume"), pe.resume()), Z;
    };
    function w(Z) {
        return function() {
            var ie = Z._readableState;
            f("pipeOnDrain", ie.awaitDrain), ie.awaitDrain && ie.awaitDrain--, ie.awaitDrain === 0 && n(Z, "data") && (ie.flowing = !0, x(Z));
        };
    }
    N.prototype.unpipe = function(Z) {
        var ie = this._readableState, pe = {
            hasUnpiped: !1
        };
        if (ie.pipesCount === 0) return this;
        if (ie.pipesCount === 1) return Z && Z !== ie.pipes ? this : (Z || (Z = ie.pipes), ie.pipes = null, ie.pipesCount = 0, ie.flowing = !1, Z && Z.emit("unpipe", this, pe), this);
        if (!Z) {
            var ve = ie.pipes, Ie = ie.pipesCount;
            ie.pipes = null, ie.pipesCount = 0, ie.flowing = !1;
            for(var Me = 0; Me < Ie; Me++)ve[Me].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var Re = se(ie.pipes, Z);
        return Re === -1 ? this : (ie.pipes.splice(Re, 1), ie.pipesCount -= 1, ie.pipesCount === 1 && (ie.pipes = ie.pipes[0]), Z.emit("unpipe", this, pe), this);
    }, N.prototype.on = function(Z, ie) {
        var pe = i1.prototype.on.call(this, Z, ie);
        if (Z === "data") this._readableState.flowing !== !1 && this.resume();
        else if (Z === "readable") {
            var ve = this._readableState;
            !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.emittedReadable = !1, ve.reading ? ve.length && v(this) : e.nextTick(_, this));
        }
        return pe;
    }, N.prototype.addListener = N.prototype.on;
    function _(Z) {
        f("readable nexttick read 0"), Z.read(0);
    }
    N.prototype.resume = function() {
        var Z = this._readableState;
        return Z.flowing || (f("resume"), Z.flowing = !0, O(this, Z)), this;
    };
    function O(Z, ie) {
        ie.resumeScheduled || (ie.resumeScheduled = !0, e.nextTick(I, Z, ie));
    }
    function I(Z, ie) {
        ie.reading || (f("resume read 0"), Z.read(0)), ie.resumeScheduled = !1, ie.awaitDrain = 0, Z.emit("resume"), x(Z), ie.flowing && !ie.reading && Z.read(0);
    }
    N.prototype.pause = function() {
        return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    };
    function x(Z) {
        var ie = Z._readableState;
        for(f("flow", ie.flowing); ie.flowing && Z.read() !== null;);
    }
    N.prototype.wrap = function(Z) {
        var ie = this, pe = this._readableState, ve = !1;
        Z.on("end", function() {
            if (f("wrapped end"), pe.decoder && !pe.ended) {
                var Re = pe.decoder.end();
                Re && Re.length && ie.push(Re);
            }
            ie.push(null);
        }), Z.on("data", function(Re) {
            if (f("wrapped data"), pe.decoder && (Re = pe.decoder.write(Re)), !(pe.objectMode && Re == null) && !(!pe.objectMode && (!Re || !Re.length))) {
                var C = ie.push(Re);
                C || (ve = !0, Z.pause());
            }
        });
        for(var Ie in Z)this[Ie] === void 0 && typeof Z[Ie] == "function" && (this[Ie] = /* @__PURE__ */ function(Re) {
            return function() {
                return Z[Re].apply(Z, arguments);
            };
        }(Ie));
        for(var Me = 0; Me < k.length; Me++)Z.on(k[Me], this.emit.bind(this, k[Me]));
        return this._read = function(Re) {
            f("wrapped _read", Re), ve && (ve = !1, Z.resume());
        }, this;
    }, Object.defineProperty(N.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    }), N._fromList = R;
    function R(Z, ie) {
        if (ie.length === 0) return null;
        var pe;
        return ie.objectMode ? pe = ie.buffer.shift() : !Z || Z >= ie.length ? (ie.decoder ? pe = ie.buffer.join("") : ie.buffer.length === 1 ? pe = ie.buffer.head.data : pe = ie.buffer.concat(ie.length), ie.buffer.clear()) : pe = j(Z, ie.buffer, ie.decoder), pe;
    }
    function j(Z, ie, pe) {
        var ve;
        return Z < ie.head.data.length ? (ve = ie.head.data.slice(0, Z), ie.head.data = ie.head.data.slice(Z)) : Z === ie.head.data.length ? ve = ie.shift() : ve = pe ? Y(Z, ie) : he(Z, ie), ve;
    }
    function Y(Z, ie) {
        var pe = ie.head, ve = 1, Ie = pe.data;
        for(Z -= Ie.length; pe = pe.next;){
            var Me = pe.data, Re = Z > Me.length ? Me.length : Z;
            if (Re === Me.length ? Ie += Me : Ie += Me.slice(0, Z), Z -= Re, Z === 0) {
                Re === Me.length ? (++ve, pe.next ? ie.head = pe.next : ie.head = ie.tail = null) : (ie.head = pe, pe.data = Me.slice(Re));
                break;
            }
            ++ve;
        }
        return ie.length -= ve, Ie;
    }
    function he(Z, ie) {
        var pe = o.allocUnsafe(Z), ve = ie.head, Ie = 1;
        for(ve.data.copy(pe), Z -= ve.data.length; ve = ve.next;){
            var Me = ve.data, Re = Z > Me.length ? Me.length : Z;
            if (Me.copy(pe, pe.length - Z, 0, Re), Z -= Re, Z === 0) {
                Re === Me.length ? (++Ie, ve.next ? ie.head = ve.next : ie.head = ie.tail = null) : (ie.head = ve, ve.data = Me.slice(Re));
                break;
            }
            ++Ie;
        }
        return ie.length -= Ie, pe;
    }
    function ue(Z) {
        var ie = Z._readableState;
        if (ie.length > 0) throw new Error('"endReadable()" called on non-empty stream');
        ie.endEmitted || (ie.ended = !0, e.nextTick(G, ie, Z));
    }
    function G(Z, ie) {
        !Z.endEmitted && Z.length === 0 && (Z.endEmitted = !0, ie.readable = !1, ie.emit("end"));
    }
    function se(Z, ie) {
        for(var pe = 0, ve = Z.length; pe < ve; pe++)if (Z[pe] === ie) return pe;
        return -1;
    }
    return kv;
}
var Ov, l_;
function NC() {
    if (l_) return Ov;
    l_ = 1, Ov = n;
    var e = dh(), t = Object.create(A1());
    t.inherits = Nr(), t.inherits(n, e);
    function r(a, s) {
        var c = this._transformState;
        c.transforming = !1;
        var l = c.writecb;
        if (!l) return this.emit("error", new Error("write callback called multiple times"));
        c.writechunk = null, c.writecb = null, s != null && this.push(s), l(a);
        var u = this._readableState;
        u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
    }
    function n(a) {
        if (!(this instanceof n)) return new n(a);
        e.call(this, a), this._transformState = {
            afterTransform: r.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", i1);
    }
    function i1() {
        var a = this;
        typeof this._flush == "function" ? this._flush(function(s, c) {
            o(a, s, c);
        }) : o(this, null, null);
    }
    n.prototype.push = function(a, s) {
        return this._transformState.needTransform = !1, e.prototype.push.call(this, a, s);
    }, n.prototype._transform = function(a, s, c) {
        throw new Error("_transform() is not implemented");
    }, n.prototype._write = function(a, s, c) {
        var l = this._transformState;
        if (l.writecb = c, l.writechunk = a, l.writeencoding = s, !l.transforming) {
            var u = this._readableState;
            (l.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
        }
    }, n.prototype._read = function(a) {
        var s = this._transformState;
        s.writechunk !== null && s.writecb && !s.transforming ? (s.transforming = !0, this._transform(s.writechunk, s.writeencoding, s.afterTransform)) : s.needTransform = !0;
    }, n.prototype._destroy = function(a, s) {
        var c = this;
        e.prototype._destroy.call(this, a, function(l) {
            s(l), c.emit("close");
        });
    };
    function o(a, s, c) {
        if (s) return a.emit("error", s);
        if (c != null && a.push(c), a._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (a._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return a.push(null);
    }
    return Ov;
}
var Iv, f_;
function DJ() {
    if (f_) return Iv;
    f_ = 1, Iv = r;
    var e = NC(), t = Object.create(A1());
    t.inherits = Nr(), t.inherits(r, e);
    function r(n) {
        if (!(this instanceof r)) return new r(n);
        e.call(this, n);
    }
    return r.prototype._transform = function(n, i1, o) {
        o(null, n);
    }, Iv;
}
var d_;
function jJ() {
    return d_ || (d_ = 1, function(e, t) {
        t = e.exports = MC(), t.Stream = t, t.Readable = t, t.Writable = CC(), t.Duplex = dh(), t.Transform = NC(), t.PassThrough = DJ();
    }(bv, bv.exports)), bv.exports;
}
var Ep = {
    exports: {}
}, h_ = {
    exports: {}
}, p_;
function J6() {
    return p_ || (p_ = 1, function(e) {
        (function(t, r) {
            function n(g, E) {
                if (!g) throw new Error(E || "Assertion failed");
            }
            function i1(g, E) {
                g.super_ = E;
                var w = function() {};
                w.prototype = E.prototype, g.prototype = new w(), g.prototype.constructor = g;
            }
            function o(g, E, w) {
                if (o.isBN(g)) return g;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, g !== null && ((E === "le" || E === "be") && (w = E, E = 10), this._init(g || 0, E || 10, w || "be"));
            }
            typeof t == "object" ? t.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
            var a;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = cl.Buffer;
            } catch  {}
            o.isBN = function(g) {
                return g instanceof o ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === o.wordSize && Array.isArray(g.words);
            }, o.max = function(g, E) {
                return g.cmp(E) > 0 ? g : E;
            }, o.min = function(g, E) {
                return g.cmp(E) < 0 ? g : E;
            }, o.prototype._init = function(g, E, w) {
                if (typeof g == "number") return this._initNumber(g, E, w);
                if (typeof g == "object") return this._initArray(g, E, w);
                E === "hex" && (E = 16), n(E === (E | 0) && E >= 2 && E <= 36), g = g.toString().replace(/\s+/g, "");
                var _ = 0;
                g[0] === "-" && (_++, this.negative = 1), _ < g.length && (E === 16 ? this._parseHex(g, _, w) : (this._parseBase(g, E, _), w === "le" && this._initArray(this.toArray(), E, w)));
            }, o.prototype._initNumber = function(g, E, w) {
                g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [
                    g & 67108863
                ], this.length = 1) : g < 4503599627370496 ? (this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863
                ], this.length = 2) : (n(g < 9007199254740992), this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863,
                    1
                ], this.length = 3), w === "le" && this._initArray(this.toArray(), E, w);
            }, o.prototype._initArray = function(g, E, w) {
                if (n(typeof g.length == "number"), g.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
                for(var _ = 0; _ < this.length; _++)this.words[_] = 0;
                var O, I, x = 0;
                if (w === "be") for(_ = g.length - 1, O = 0; _ >= 0; _ -= 3)I = g[_] | g[_ - 1] << 8 | g[_ - 2] << 16, this.words[O] |= I << x & 67108863, this.words[O + 1] = I >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, O++);
                else if (w === "le") for(_ = 0, O = 0; _ < g.length; _ += 3)I = g[_] | g[_ + 1] << 8 | g[_ + 2] << 16, this.words[O] |= I << x & 67108863, this.words[O + 1] = I >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, O++);
                return this._strip();
            };
            function s(g, E) {
                var w = g.charCodeAt(E);
                if (w >= 48 && w <= 57) return w - 48;
                if (w >= 65 && w <= 70) return w - 55;
                if (w >= 97 && w <= 102) return w - 87;
                n(!1, "Invalid character in " + g);
            }
            function c(g, E, w) {
                var _ = s(g, w);
                return w - 1 >= E && (_ |= s(g, w - 1) << 4), _;
            }
            o.prototype._parseHex = function(g, E, w) {
                this.length = Math.ceil((g.length - E) / 6), this.words = new Array(this.length);
                for(var _ = 0; _ < this.length; _++)this.words[_] = 0;
                var O = 0, I = 0, x;
                if (w === "be") for(_ = g.length - 1; _ >= E; _ -= 2)x = c(g, E, _) << O, this.words[I] |= x & 67108863, O >= 18 ? (O -= 18, I += 1, this.words[I] |= x >>> 26) : O += 8;
                else {
                    var R = g.length - E;
                    for(_ = R % 2 === 0 ? E + 1 : E; _ < g.length; _ += 2)x = c(g, E, _) << O, this.words[I] |= x & 67108863, O >= 18 ? (O -= 18, I += 1, this.words[I] |= x >>> 26) : O += 8;
                }
                this._strip();
            };
            function l(g, E, w, _) {
                for(var O = 0, I = 0, x = Math.min(g.length, w), R = E; R < x; R++){
                    var j = g.charCodeAt(R) - 48;
                    O *= _, j >= 49 ? I = j - 49 + 10 : j >= 17 ? I = j - 17 + 10 : I = j, n(j >= 0 && I < _, "Invalid character"), O += I;
                }
                return O;
            }
            o.prototype._parseBase = function(g, E, w) {
                this.words = [
                    0
                ], this.length = 1;
                for(var _ = 0, O = 1; O <= 67108863; O *= E)_++;
                _--, O = O / E | 0;
                for(var I = g.length - w, x = I % _, R = Math.min(I, I - x) + w, j = 0, Y = w; Y < R; Y += _)j = l(g, Y, Y + _, E), this.imuln(O), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
                if (x !== 0) {
                    var he = 1;
                    for(j = l(g, Y, g.length, E), Y = 0; Y < x; Y++)he *= E;
                    this.imuln(he), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
                }
                this._strip();
            }, o.prototype.copy = function(g) {
                g.words = new Array(this.length);
                for(var E = 0; E < this.length; E++)g.words[E] = this.words[E];
                g.length = this.length, g.negative = this.negative, g.red = this.red;
            };
            function u(g, E) {
                g.words = E.words, g.length = E.length, g.negative = E.negative, g.red = E.red;
            }
            if (o.prototype._move = function(g) {
                u(g, this);
            }, o.prototype.clone = function() {
                var g = new o(null);
                return this.copy(g), g;
            }, o.prototype._expand = function(g) {
                for(; this.length < g;)this.words[this.length++] = 0;
                return this;
            }, o.prototype._strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, o.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
                o.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
            } catch  {
                o.prototype.inspect = f;
            }
            else o.prototype.inspect = f;
            function f() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            }
            var h = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], y = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], S = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            o.prototype.toString = function(g, E) {
                g = g || 10, E = E | 0 || 1;
                var w;
                if (g === 16 || g === "hex") {
                    w = "";
                    for(var _ = 0, O = 0, I = 0; I < this.length; I++){
                        var x = this.words[I], R = ((x << _ | O) & 16777215).toString(16);
                        O = x >>> 24 - _ & 16777215, _ += 2, _ >= 26 && (_ -= 26, I--), O !== 0 || I !== this.length - 1 ? w = h[6 - R.length] + R + w : w = R + w;
                    }
                    for(O !== 0 && (w = O.toString(16) + w); w.length % E !== 0;)w = "0" + w;
                    return this.negative !== 0 && (w = "-" + w), w;
                }
                if (g === (g | 0) && g >= 2 && g <= 36) {
                    var j = y[g], Y = S[g];
                    w = "";
                    var he = this.clone();
                    for(he.negative = 0; !he.isZero();){
                        var ue = he.modrn(Y).toString(g);
                        he = he.idivn(Y), he.isZero() ? w = ue + w : w = h[j - ue.length] + ue + w;
                    }
                    for(this.isZero() && (w = "0" + w); w.length % E !== 0;)w = "0" + w;
                    return this.negative !== 0 && (w = "-" + w), w;
                }
                n(!1, "Base should be between 2 and 36");
            }, o.prototype.toNumber = function() {
                var g = this.words[0];
                return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
            }, o.prototype.toJSON = function() {
                return this.toString(16, 2);
            }, a && (o.prototype.toBuffer = function(g, E) {
                return this.toArrayLike(a, g, E);
            }), o.prototype.toArray = function(g, E) {
                return this.toArrayLike(Array, g, E);
            };
            var k = function(g, E) {
                return g.allocUnsafe ? g.allocUnsafe(E) : new g(E);
            };
            o.prototype.toArrayLike = function(g, E, w) {
                this._strip();
                var _ = this.byteLength(), O = w || Math.max(1, _);
                n(_ <= O, "byte array longer than desired length"), n(O > 0, "Requested array length <= 0");
                var I = k(g, O), x = E === "le" ? "LE" : "BE";
                return this["_toArrayLike" + x](I, _), I;
            }, o.prototype._toArrayLikeLE = function(g, E) {
                for(var w = 0, _ = 0, O = 0, I = 0; O < this.length; O++){
                    var x = this.words[O] << I | _;
                    g[w++] = x & 255, w < g.length && (g[w++] = x >> 8 & 255), w < g.length && (g[w++] = x >> 16 & 255), I === 6 ? (w < g.length && (g[w++] = x >> 24 & 255), _ = 0, I = 0) : (_ = x >>> 24, I += 2);
                }
                if (w < g.length) for(g[w++] = _; w < g.length;)g[w++] = 0;
            }, o.prototype._toArrayLikeBE = function(g, E) {
                for(var w = g.length - 1, _ = 0, O = 0, I = 0; O < this.length; O++){
                    var x = this.words[O] << I | _;
                    g[w--] = x & 255, w >= 0 && (g[w--] = x >> 8 & 255), w >= 0 && (g[w--] = x >> 16 & 255), I === 6 ? (w >= 0 && (g[w--] = x >> 24 & 255), _ = 0, I = 0) : (_ = x >>> 24, I += 2);
                }
                if (w >= 0) for(g[w--] = _; w >= 0;)g[w--] = 0;
            }, Math.clz32 ? o.prototype._countBits = function(g) {
                return 32 - Math.clz32(g);
            } : o.prototype._countBits = function(g) {
                var E = g, w = 0;
                return E >= 4096 && (w += 13, E >>>= 13), E >= 64 && (w += 7, E >>>= 7), E >= 8 && (w += 4, E >>>= 4), E >= 2 && (w += 2, E >>>= 2), w + E;
            }, o.prototype._zeroBits = function(g) {
                if (g === 0) return 26;
                var E = g, w = 0;
                return E & 8191 || (w += 13, E >>>= 13), E & 127 || (w += 7, E >>>= 7), E & 15 || (w += 4, E >>>= 4), E & 3 || (w += 2, E >>>= 2), E & 1 || w++, w;
            }, o.prototype.bitLength = function() {
                var g = this.words[this.length - 1], E = this._countBits(g);
                return (this.length - 1) * 26 + E;
            };
            function P(g) {
                for(var E = new Array(g.bitLength()), w = 0; w < E.length; w++){
                    var _ = w / 26 | 0, O = w % 26;
                    E[w] = g.words[_] >>> O & 1;
                }
                return E;
            }
            o.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var g = 0, E = 0; E < this.length; E++){
                    var w = this._zeroBits(this.words[E]);
                    if (g += w, w !== 26) break;
                }
                return g;
            }, o.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, o.prototype.toTwos = function(g) {
                return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
            }, o.prototype.fromTwos = function(g) {
                return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
            }, o.prototype.isNeg = function() {
                return this.negative !== 0;
            }, o.prototype.neg = function() {
                return this.clone().ineg();
            }, o.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, o.prototype.iuor = function(g) {
                for(; this.length < g.length;)this.words[this.length++] = 0;
                for(var E = 0; E < g.length; E++)this.words[E] = this.words[E] | g.words[E];
                return this._strip();
            }, o.prototype.ior = function(g) {
                return n((this.negative | g.negative) === 0), this.iuor(g);
            }, o.prototype.or = function(g) {
                return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
            }, o.prototype.uor = function(g) {
                return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
            }, o.prototype.iuand = function(g) {
                var E;
                this.length > g.length ? E = g : E = this;
                for(var w = 0; w < E.length; w++)this.words[w] = this.words[w] & g.words[w];
                return this.length = E.length, this._strip();
            }, o.prototype.iand = function(g) {
                return n((this.negative | g.negative) === 0), this.iuand(g);
            }, o.prototype.and = function(g) {
                return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
            }, o.prototype.uand = function(g) {
                return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
            }, o.prototype.iuxor = function(g) {
                var E, w;
                this.length > g.length ? (E = this, w = g) : (E = g, w = this);
                for(var _ = 0; _ < w.length; _++)this.words[_] = E.words[_] ^ w.words[_];
                if (this !== E) for(; _ < E.length; _++)this.words[_] = E.words[_];
                return this.length = E.length, this._strip();
            }, o.prototype.ixor = function(g) {
                return n((this.negative | g.negative) === 0), this.iuxor(g);
            }, o.prototype.xor = function(g) {
                return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
            }, o.prototype.uxor = function(g) {
                return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
            }, o.prototype.inotn = function(g) {
                n(typeof g == "number" && g >= 0);
                var E = Math.ceil(g / 26) | 0, w = g % 26;
                this._expand(E), w > 0 && E--;
                for(var _ = 0; _ < E; _++)this.words[_] = ~this.words[_] & 67108863;
                return w > 0 && (this.words[_] = ~this.words[_] & 67108863 >> 26 - w), this._strip();
            }, o.prototype.notn = function(g) {
                return this.clone().inotn(g);
            }, o.prototype.setn = function(g, E) {
                n(typeof g == "number" && g >= 0);
                var w = g / 26 | 0, _ = g % 26;
                return this._expand(w + 1), E ? this.words[w] = this.words[w] | 1 << _ : this.words[w] = this.words[w] & ~(1 << _), this._strip();
            }, o.prototype.iadd = function(g) {
                var E;
                if (this.negative !== 0 && g.negative === 0) return this.negative = 0, E = this.isub(g), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && g.negative !== 0) return g.negative = 0, E = this.isub(g), g.negative = 1, E._normSign();
                var w, _;
                this.length > g.length ? (w = this, _ = g) : (w = g, _ = this);
                for(var O = 0, I = 0; I < _.length; I++)E = (w.words[I] | 0) + (_.words[I] | 0) + O, this.words[I] = E & 67108863, O = E >>> 26;
                for(; O !== 0 && I < w.length; I++)E = (w.words[I] | 0) + O, this.words[I] = E & 67108863, O = E >>> 26;
                if (this.length = w.length, O !== 0) this.words[this.length] = O, this.length++;
                else if (w !== this) for(; I < w.length; I++)this.words[I] = w.words[I];
                return this;
            }, o.prototype.add = function(g) {
                var E;
                return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, E = this.sub(g), g.negative ^= 1, E) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = g.sub(this), this.negative = 1, E) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
            }, o.prototype.isub = function(g) {
                if (g.negative !== 0) {
                    g.negative = 0;
                    var E = this.iadd(g);
                    return g.negative = 1, E._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
                var w = this.cmp(g);
                if (w === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var _, O;
                w > 0 ? (_ = this, O = g) : (_ = g, O = this);
                for(var I = 0, x = 0; x < O.length; x++)E = (_.words[x] | 0) - (O.words[x] | 0) + I, I = E >> 26, this.words[x] = E & 67108863;
                for(; I !== 0 && x < _.length; x++)E = (_.words[x] | 0) + I, I = E >> 26, this.words[x] = E & 67108863;
                if (I === 0 && x < _.length && _ !== this) for(; x < _.length; x++)this.words[x] = _.words[x];
                return this.length = Math.max(this.length, x), _ !== this && (this.negative = 1), this._strip();
            }, o.prototype.sub = function(g) {
                return this.clone().isub(g);
            };
            function M(g, E, w) {
                w.negative = E.negative ^ g.negative;
                var _ = g.length + E.length | 0;
                w.length = _, _ = _ - 1 | 0;
                var O = g.words[0] | 0, I = E.words[0] | 0, x = O * I, R = x & 67108863, j = x / 67108864 | 0;
                w.words[0] = R;
                for(var Y = 1; Y < _; Y++){
                    for(var he = j >>> 26, ue = j & 67108863, G = Math.min(Y, E.length - 1), se = Math.max(0, Y - g.length + 1); se <= G; se++){
                        var Z = Y - se | 0;
                        O = g.words[Z] | 0, I = E.words[se] | 0, x = O * I + ue, he += x / 67108864 | 0, ue = x & 67108863;
                    }
                    w.words[Y] = ue | 0, j = he | 0;
                }
                return j !== 0 ? w.words[Y] = j | 0 : w.length--, w._strip();
            }
            var N = function(g, E, w) {
                var _ = g.words, O = E.words, I = w.words, x = 0, R, j, Y, he = _[0] | 0, ue = he & 8191, G = he >>> 13, se = _[1] | 0, Z = se & 8191, ie = se >>> 13, pe = _[2] | 0, ve = pe & 8191, Ie = pe >>> 13, Me = _[3] | 0, Re = Me & 8191, C = Me >>> 13, J = _[4] | 0, me = J & 8191, je = J >>> 13, Ve = _[5] | 0, nt = Ve & 8191, We = Ve >>> 13, Ge = _[6] | 0, p = Ge & 8191, A = Ge >>> 13, V = _[7] | 0, re = V & 8191, le = V >>> 13, L = _[8] | 0, X = L & 8191, ae = L >>> 13, D = _[9] | 0, H = D & 8191, te = D >>> 13, ge = O[0] | 0, ce = ge & 8191, Ue = ge >>> 13, qe = O[1] | 0, ot = qe & 8191, yt = qe >>> 13, Ut = O[2] | 0, Xe = Ut & 8191, _t = Ut >>> 13, br = O[3] | 0, Lr = br & 8191, Wt = br >>> 13, Dt = O[4] | 0, Yt = Dt & 8191, Lt = Dt >>> 13, Dr = O[5] | 0, xe = Dr & 8191, ye = Dr >>> 13, ke = O[6] | 0, Ce = ke & 8191, De = ke >>> 13, Ye = O[7] | 0, lt = Ye & 8191, et = Ye >>> 13, vt = O[8] | 0, At = vt & 8191, dt = vt >>> 13, Tt = O[9] | 0, Pt = Tt & 8191, Rt = Tt >>> 13;
                w.negative = g.negative ^ E.negative, w.length = 19, R = Math.imul(ue, ce), j = Math.imul(ue, Ue), j = j + Math.imul(G, ce) | 0, Y = Math.imul(G, Ue);
                var rt = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, R = Math.imul(Z, ce), j = Math.imul(Z, Ue), j = j + Math.imul(ie, ce) | 0, Y = Math.imul(ie, Ue), R = R + Math.imul(ue, ot) | 0, j = j + Math.imul(ue, yt) | 0, j = j + Math.imul(G, ot) | 0, Y = Y + Math.imul(G, yt) | 0;
                var Et = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, R = Math.imul(ve, ce), j = Math.imul(ve, Ue), j = j + Math.imul(Ie, ce) | 0, Y = Math.imul(Ie, Ue), R = R + Math.imul(Z, ot) | 0, j = j + Math.imul(Z, yt) | 0, j = j + Math.imul(ie, ot) | 0, Y = Y + Math.imul(ie, yt) | 0, R = R + Math.imul(ue, Xe) | 0, j = j + Math.imul(ue, _t) | 0, j = j + Math.imul(G, Xe) | 0, Y = Y + Math.imul(G, _t) | 0;
                var Pe = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, R = Math.imul(Re, ce), j = Math.imul(Re, Ue), j = j + Math.imul(C, ce) | 0, Y = Math.imul(C, Ue), R = R + Math.imul(ve, ot) | 0, j = j + Math.imul(ve, yt) | 0, j = j + Math.imul(Ie, ot) | 0, Y = Y + Math.imul(Ie, yt) | 0, R = R + Math.imul(Z, Xe) | 0, j = j + Math.imul(Z, _t) | 0, j = j + Math.imul(ie, Xe) | 0, Y = Y + Math.imul(ie, _t) | 0, R = R + Math.imul(ue, Lr) | 0, j = j + Math.imul(ue, Wt) | 0, j = j + Math.imul(G, Lr) | 0, Y = Y + Math.imul(G, Wt) | 0;
                var mt = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, R = Math.imul(me, ce), j = Math.imul(me, Ue), j = j + Math.imul(je, ce) | 0, Y = Math.imul(je, Ue), R = R + Math.imul(Re, ot) | 0, j = j + Math.imul(Re, yt) | 0, j = j + Math.imul(C, ot) | 0, Y = Y + Math.imul(C, yt) | 0, R = R + Math.imul(ve, Xe) | 0, j = j + Math.imul(ve, _t) | 0, j = j + Math.imul(Ie, Xe) | 0, Y = Y + Math.imul(Ie, _t) | 0, R = R + Math.imul(Z, Lr) | 0, j = j + Math.imul(Z, Wt) | 0, j = j + Math.imul(ie, Lr) | 0, Y = Y + Math.imul(ie, Wt) | 0, R = R + Math.imul(ue, Yt) | 0, j = j + Math.imul(ue, Lt) | 0, j = j + Math.imul(G, Yt) | 0, Y = Y + Math.imul(G, Lt) | 0;
                var ut = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, R = Math.imul(nt, ce), j = Math.imul(nt, Ue), j = j + Math.imul(We, ce) | 0, Y = Math.imul(We, Ue), R = R + Math.imul(me, ot) | 0, j = j + Math.imul(me, yt) | 0, j = j + Math.imul(je, ot) | 0, Y = Y + Math.imul(je, yt) | 0, R = R + Math.imul(Re, Xe) | 0, j = j + Math.imul(Re, _t) | 0, j = j + Math.imul(C, Xe) | 0, Y = Y + Math.imul(C, _t) | 0, R = R + Math.imul(ve, Lr) | 0, j = j + Math.imul(ve, Wt) | 0, j = j + Math.imul(Ie, Lr) | 0, Y = Y + Math.imul(Ie, Wt) | 0, R = R + Math.imul(Z, Yt) | 0, j = j + Math.imul(Z, Lt) | 0, j = j + Math.imul(ie, Yt) | 0, Y = Y + Math.imul(ie, Lt) | 0, R = R + Math.imul(ue, xe) | 0, j = j + Math.imul(ue, ye) | 0, j = j + Math.imul(G, xe) | 0, Y = Y + Math.imul(G, ye) | 0;
                var Jt = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, R = Math.imul(p, ce), j = Math.imul(p, Ue), j = j + Math.imul(A, ce) | 0, Y = Math.imul(A, Ue), R = R + Math.imul(nt, ot) | 0, j = j + Math.imul(nt, yt) | 0, j = j + Math.imul(We, ot) | 0, Y = Y + Math.imul(We, yt) | 0, R = R + Math.imul(me, Xe) | 0, j = j + Math.imul(me, _t) | 0, j = j + Math.imul(je, Xe) | 0, Y = Y + Math.imul(je, _t) | 0, R = R + Math.imul(Re, Lr) | 0, j = j + Math.imul(Re, Wt) | 0, j = j + Math.imul(C, Lr) | 0, Y = Y + Math.imul(C, Wt) | 0, R = R + Math.imul(ve, Yt) | 0, j = j + Math.imul(ve, Lt) | 0, j = j + Math.imul(Ie, Yt) | 0, Y = Y + Math.imul(Ie, Lt) | 0, R = R + Math.imul(Z, xe) | 0, j = j + Math.imul(Z, ye) | 0, j = j + Math.imul(ie, xe) | 0, Y = Y + Math.imul(ie, ye) | 0, R = R + Math.imul(ue, Ce) | 0, j = j + Math.imul(ue, De) | 0, j = j + Math.imul(G, Ce) | 0, Y = Y + Math.imul(G, De) | 0;
                var we = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, R = Math.imul(re, ce), j = Math.imul(re, Ue), j = j + Math.imul(le, ce) | 0, Y = Math.imul(le, Ue), R = R + Math.imul(p, ot) | 0, j = j + Math.imul(p, yt) | 0, j = j + Math.imul(A, ot) | 0, Y = Y + Math.imul(A, yt) | 0, R = R + Math.imul(nt, Xe) | 0, j = j + Math.imul(nt, _t) | 0, j = j + Math.imul(We, Xe) | 0, Y = Y + Math.imul(We, _t) | 0, R = R + Math.imul(me, Lr) | 0, j = j + Math.imul(me, Wt) | 0, j = j + Math.imul(je, Lr) | 0, Y = Y + Math.imul(je, Wt) | 0, R = R + Math.imul(Re, Yt) | 0, j = j + Math.imul(Re, Lt) | 0, j = j + Math.imul(C, Yt) | 0, Y = Y + Math.imul(C, Lt) | 0, R = R + Math.imul(ve, xe) | 0, j = j + Math.imul(ve, ye) | 0, j = j + Math.imul(Ie, xe) | 0, Y = Y + Math.imul(Ie, ye) | 0, R = R + Math.imul(Z, Ce) | 0, j = j + Math.imul(Z, De) | 0, j = j + Math.imul(ie, Ce) | 0, Y = Y + Math.imul(ie, De) | 0, R = R + Math.imul(ue, lt) | 0, j = j + Math.imul(ue, et) | 0, j = j + Math.imul(G, lt) | 0, Y = Y + Math.imul(G, et) | 0;
                var Tr = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, R = Math.imul(X, ce), j = Math.imul(X, Ue), j = j + Math.imul(ae, ce) | 0, Y = Math.imul(ae, Ue), R = R + Math.imul(re, ot) | 0, j = j + Math.imul(re, yt) | 0, j = j + Math.imul(le, ot) | 0, Y = Y + Math.imul(le, yt) | 0, R = R + Math.imul(p, Xe) | 0, j = j + Math.imul(p, _t) | 0, j = j + Math.imul(A, Xe) | 0, Y = Y + Math.imul(A, _t) | 0, R = R + Math.imul(nt, Lr) | 0, j = j + Math.imul(nt, Wt) | 0, j = j + Math.imul(We, Lr) | 0, Y = Y + Math.imul(We, Wt) | 0, R = R + Math.imul(me, Yt) | 0, j = j + Math.imul(me, Lt) | 0, j = j + Math.imul(je, Yt) | 0, Y = Y + Math.imul(je, Lt) | 0, R = R + Math.imul(Re, xe) | 0, j = j + Math.imul(Re, ye) | 0, j = j + Math.imul(C, xe) | 0, Y = Y + Math.imul(C, ye) | 0, R = R + Math.imul(ve, Ce) | 0, j = j + Math.imul(ve, De) | 0, j = j + Math.imul(Ie, Ce) | 0, Y = Y + Math.imul(Ie, De) | 0, R = R + Math.imul(Z, lt) | 0, j = j + Math.imul(Z, et) | 0, j = j + Math.imul(ie, lt) | 0, Y = Y + Math.imul(ie, et) | 0, R = R + Math.imul(ue, At) | 0, j = j + Math.imul(ue, dt) | 0, j = j + Math.imul(G, At) | 0, Y = Y + Math.imul(G, dt) | 0;
                var ar = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, R = Math.imul(H, ce), j = Math.imul(H, Ue), j = j + Math.imul(te, ce) | 0, Y = Math.imul(te, Ue), R = R + Math.imul(X, ot) | 0, j = j + Math.imul(X, yt) | 0, j = j + Math.imul(ae, ot) | 0, Y = Y + Math.imul(ae, yt) | 0, R = R + Math.imul(re, Xe) | 0, j = j + Math.imul(re, _t) | 0, j = j + Math.imul(le, Xe) | 0, Y = Y + Math.imul(le, _t) | 0, R = R + Math.imul(p, Lr) | 0, j = j + Math.imul(p, Wt) | 0, j = j + Math.imul(A, Lr) | 0, Y = Y + Math.imul(A, Wt) | 0, R = R + Math.imul(nt, Yt) | 0, j = j + Math.imul(nt, Lt) | 0, j = j + Math.imul(We, Yt) | 0, Y = Y + Math.imul(We, Lt) | 0, R = R + Math.imul(me, xe) | 0, j = j + Math.imul(me, ye) | 0, j = j + Math.imul(je, xe) | 0, Y = Y + Math.imul(je, ye) | 0, R = R + Math.imul(Re, Ce) | 0, j = j + Math.imul(Re, De) | 0, j = j + Math.imul(C, Ce) | 0, Y = Y + Math.imul(C, De) | 0, R = R + Math.imul(ve, lt) | 0, j = j + Math.imul(ve, et) | 0, j = j + Math.imul(Ie, lt) | 0, Y = Y + Math.imul(Ie, et) | 0, R = R + Math.imul(Z, At) | 0, j = j + Math.imul(Z, dt) | 0, j = j + Math.imul(ie, At) | 0, Y = Y + Math.imul(ie, dt) | 0, R = R + Math.imul(ue, Pt) | 0, j = j + Math.imul(ue, Rt) | 0, j = j + Math.imul(G, Pt) | 0, Y = Y + Math.imul(G, Rt) | 0;
                var sr = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, R = Math.imul(H, ot), j = Math.imul(H, yt), j = j + Math.imul(te, ot) | 0, Y = Math.imul(te, yt), R = R + Math.imul(X, Xe) | 0, j = j + Math.imul(X, _t) | 0, j = j + Math.imul(ae, Xe) | 0, Y = Y + Math.imul(ae, _t) | 0, R = R + Math.imul(re, Lr) | 0, j = j + Math.imul(re, Wt) | 0, j = j + Math.imul(le, Lr) | 0, Y = Y + Math.imul(le, Wt) | 0, R = R + Math.imul(p, Yt) | 0, j = j + Math.imul(p, Lt) | 0, j = j + Math.imul(A, Yt) | 0, Y = Y + Math.imul(A, Lt) | 0, R = R + Math.imul(nt, xe) | 0, j = j + Math.imul(nt, ye) | 0, j = j + Math.imul(We, xe) | 0, Y = Y + Math.imul(We, ye) | 0, R = R + Math.imul(me, Ce) | 0, j = j + Math.imul(me, De) | 0, j = j + Math.imul(je, Ce) | 0, Y = Y + Math.imul(je, De) | 0, R = R + Math.imul(Re, lt) | 0, j = j + Math.imul(Re, et) | 0, j = j + Math.imul(C, lt) | 0, Y = Y + Math.imul(C, et) | 0, R = R + Math.imul(ve, At) | 0, j = j + Math.imul(ve, dt) | 0, j = j + Math.imul(Ie, At) | 0, Y = Y + Math.imul(Ie, dt) | 0, R = R + Math.imul(Z, Pt) | 0, j = j + Math.imul(Z, Rt) | 0, j = j + Math.imul(ie, Pt) | 0, Y = Y + Math.imul(ie, Rt) | 0;
                var kt = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, R = Math.imul(H, Xe), j = Math.imul(H, _t), j = j + Math.imul(te, Xe) | 0, Y = Math.imul(te, _t), R = R + Math.imul(X, Lr) | 0, j = j + Math.imul(X, Wt) | 0, j = j + Math.imul(ae, Lr) | 0, Y = Y + Math.imul(ae, Wt) | 0, R = R + Math.imul(re, Yt) | 0, j = j + Math.imul(re, Lt) | 0, j = j + Math.imul(le, Yt) | 0, Y = Y + Math.imul(le, Lt) | 0, R = R + Math.imul(p, xe) | 0, j = j + Math.imul(p, ye) | 0, j = j + Math.imul(A, xe) | 0, Y = Y + Math.imul(A, ye) | 0, R = R + Math.imul(nt, Ce) | 0, j = j + Math.imul(nt, De) | 0, j = j + Math.imul(We, Ce) | 0, Y = Y + Math.imul(We, De) | 0, R = R + Math.imul(me, lt) | 0, j = j + Math.imul(me, et) | 0, j = j + Math.imul(je, lt) | 0, Y = Y + Math.imul(je, et) | 0, R = R + Math.imul(Re, At) | 0, j = j + Math.imul(Re, dt) | 0, j = j + Math.imul(C, At) | 0, Y = Y + Math.imul(C, dt) | 0, R = R + Math.imul(ve, Pt) | 0, j = j + Math.imul(ve, Rt) | 0, j = j + Math.imul(Ie, Pt) | 0, Y = Y + Math.imul(Ie, Rt) | 0;
                var nn = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, R = Math.imul(H, Lr), j = Math.imul(H, Wt), j = j + Math.imul(te, Lr) | 0, Y = Math.imul(te, Wt), R = R + Math.imul(X, Yt) | 0, j = j + Math.imul(X, Lt) | 0, j = j + Math.imul(ae, Yt) | 0, Y = Y + Math.imul(ae, Lt) | 0, R = R + Math.imul(re, xe) | 0, j = j + Math.imul(re, ye) | 0, j = j + Math.imul(le, xe) | 0, Y = Y + Math.imul(le, ye) | 0, R = R + Math.imul(p, Ce) | 0, j = j + Math.imul(p, De) | 0, j = j + Math.imul(A, Ce) | 0, Y = Y + Math.imul(A, De) | 0, R = R + Math.imul(nt, lt) | 0, j = j + Math.imul(nt, et) | 0, j = j + Math.imul(We, lt) | 0, Y = Y + Math.imul(We, et) | 0, R = R + Math.imul(me, At) | 0, j = j + Math.imul(me, dt) | 0, j = j + Math.imul(je, At) | 0, Y = Y + Math.imul(je, dt) | 0, R = R + Math.imul(Re, Pt) | 0, j = j + Math.imul(Re, Rt) | 0, j = j + Math.imul(C, Pt) | 0, Y = Y + Math.imul(C, Rt) | 0;
                var bi = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (bi >>> 26) | 0, bi &= 67108863, R = Math.imul(H, Yt), j = Math.imul(H, Lt), j = j + Math.imul(te, Yt) | 0, Y = Math.imul(te, Lt), R = R + Math.imul(X, xe) | 0, j = j + Math.imul(X, ye) | 0, j = j + Math.imul(ae, xe) | 0, Y = Y + Math.imul(ae, ye) | 0, R = R + Math.imul(re, Ce) | 0, j = j + Math.imul(re, De) | 0, j = j + Math.imul(le, Ce) | 0, Y = Y + Math.imul(le, De) | 0, R = R + Math.imul(p, lt) | 0, j = j + Math.imul(p, et) | 0, j = j + Math.imul(A, lt) | 0, Y = Y + Math.imul(A, et) | 0, R = R + Math.imul(nt, At) | 0, j = j + Math.imul(nt, dt) | 0, j = j + Math.imul(We, At) | 0, Y = Y + Math.imul(We, dt) | 0, R = R + Math.imul(me, Pt) | 0, j = j + Math.imul(me, Rt) | 0, j = j + Math.imul(je, Pt) | 0, Y = Y + Math.imul(je, Rt) | 0;
                var b = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (b >>> 26) | 0, b &= 67108863, R = Math.imul(H, xe), j = Math.imul(H, ye), j = j + Math.imul(te, xe) | 0, Y = Math.imul(te, ye), R = R + Math.imul(X, Ce) | 0, j = j + Math.imul(X, De) | 0, j = j + Math.imul(ae, Ce) | 0, Y = Y + Math.imul(ae, De) | 0, R = R + Math.imul(re, lt) | 0, j = j + Math.imul(re, et) | 0, j = j + Math.imul(le, lt) | 0, Y = Y + Math.imul(le, et) | 0, R = R + Math.imul(p, At) | 0, j = j + Math.imul(p, dt) | 0, j = j + Math.imul(A, At) | 0, Y = Y + Math.imul(A, dt) | 0, R = R + Math.imul(nt, Pt) | 0, j = j + Math.imul(nt, Rt) | 0, j = j + Math.imul(We, Pt) | 0, Y = Y + Math.imul(We, Rt) | 0;
                var T = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (T >>> 26) | 0, T &= 67108863, R = Math.imul(H, Ce), j = Math.imul(H, De), j = j + Math.imul(te, Ce) | 0, Y = Math.imul(te, De), R = R + Math.imul(X, lt) | 0, j = j + Math.imul(X, et) | 0, j = j + Math.imul(ae, lt) | 0, Y = Y + Math.imul(ae, et) | 0, R = R + Math.imul(re, At) | 0, j = j + Math.imul(re, dt) | 0, j = j + Math.imul(le, At) | 0, Y = Y + Math.imul(le, dt) | 0, R = R + Math.imul(p, Pt) | 0, j = j + Math.imul(p, Rt) | 0, j = j + Math.imul(A, Pt) | 0, Y = Y + Math.imul(A, Rt) | 0;
                var W = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (W >>> 26) | 0, W &= 67108863, R = Math.imul(H, lt), j = Math.imul(H, et), j = j + Math.imul(te, lt) | 0, Y = Math.imul(te, et), R = R + Math.imul(X, At) | 0, j = j + Math.imul(X, dt) | 0, j = j + Math.imul(ae, At) | 0, Y = Y + Math.imul(ae, dt) | 0, R = R + Math.imul(re, Pt) | 0, j = j + Math.imul(re, Rt) | 0, j = j + Math.imul(le, Pt) | 0, Y = Y + Math.imul(le, Rt) | 0;
                var fe = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (fe >>> 26) | 0, fe &= 67108863, R = Math.imul(H, At), j = Math.imul(H, dt), j = j + Math.imul(te, At) | 0, Y = Math.imul(te, dt), R = R + Math.imul(X, Pt) | 0, j = j + Math.imul(X, Rt) | 0, j = j + Math.imul(ae, Pt) | 0, Y = Y + Math.imul(ae, Rt) | 0;
                var Oe = (x + R | 0) + ((j & 8191) << 13) | 0;
                x = (Y + (j >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, R = Math.imul(H, Pt), j = Math.imul(H, Rt), j = j + Math.imul(te, Pt) | 0, Y = Math.imul(te, Rt);
                var He = (x + R | 0) + ((j & 8191) << 13) | 0;
                return x = (Y + (j >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, I[0] = rt, I[1] = Et, I[2] = Pe, I[3] = mt, I[4] = ut, I[5] = Jt, I[6] = we, I[7] = Tr, I[8] = ar, I[9] = sr, I[10] = kt, I[11] = nn, I[12] = bi, I[13] = b, I[14] = T, I[15] = W, I[16] = fe, I[17] = Oe, I[18] = He, x !== 0 && (I[19] = x, w.length++), w;
            };
            Math.imul || (N = M);
            function z(g, E, w) {
                w.negative = E.negative ^ g.negative, w.length = g.length + E.length;
                for(var _ = 0, O = 0, I = 0; I < w.length - 1; I++){
                    var x = O;
                    O = 0;
                    for(var R = _ & 67108863, j = Math.min(I, E.length - 1), Y = Math.max(0, I - g.length + 1); Y <= j; Y++){
                        var he = I - Y, ue = g.words[he] | 0, G = E.words[Y] | 0, se = ue * G, Z = se & 67108863;
                        x = x + (se / 67108864 | 0) | 0, Z = Z + R | 0, R = Z & 67108863, x = x + (Z >>> 26) | 0, O += x >>> 26, x &= 67108863;
                    }
                    w.words[I] = R, _ = x, x = O;
                }
                return _ !== 0 ? w.words[I] = _ : w.length--, w._strip();
            }
            function K(g, E, w) {
                return z(g, E, w);
            }
            o.prototype.mulTo = function(g, E) {
                var w, _ = this.length + g.length;
                return this.length === 10 && g.length === 10 ? w = N(this, g, E) : _ < 63 ? w = M(this, g, E) : _ < 1024 ? w = z(this, g, E) : w = K(this, g, E), w;
            }, o.prototype.mul = function(g) {
                var E = new o(null);
                return E.words = new Array(this.length + g.length), this.mulTo(g, E);
            }, o.prototype.mulf = function(g) {
                var E = new o(null);
                return E.words = new Array(this.length + g.length), K(this, g, E);
            }, o.prototype.imul = function(g) {
                return this.clone().mulTo(g, this);
            }, o.prototype.imuln = function(g) {
                var E = g < 0;
                E && (g = -g), n(typeof g == "number"), n(g < 67108864);
                for(var w = 0, _ = 0; _ < this.length; _++){
                    var O = (this.words[_] | 0) * g, I = (O & 67108863) + (w & 67108863);
                    w >>= 26, w += O / 67108864 | 0, w += I >>> 26, this.words[_] = I & 67108863;
                }
                return w !== 0 && (this.words[_] = w, this.length++), this.length = g === 0 ? 1 : this.length, E ? this.ineg() : this;
            }, o.prototype.muln = function(g) {
                return this.clone().imuln(g);
            }, o.prototype.sqr = function() {
                return this.mul(this);
            }, o.prototype.isqr = function() {
                return this.imul(this.clone());
            }, o.prototype.pow = function(g) {
                var E = P(g);
                if (E.length === 0) return new o(1);
                for(var w = this, _ = 0; _ < E.length && E[_] === 0; _++, w = w.sqr());
                if (++_ < E.length) for(var O = w.sqr(); _ < E.length; _++, O = O.sqr())E[_] !== 0 && (w = w.mul(O));
                return w;
            }, o.prototype.iushln = function(g) {
                n(typeof g == "number" && g >= 0);
                var E = g % 26, w = (g - E) / 26, _ = 67108863 >>> 26 - E << 26 - E, O;
                if (E !== 0) {
                    var I = 0;
                    for(O = 0; O < this.length; O++){
                        var x = this.words[O] & _, R = (this.words[O] | 0) - x << E;
                        this.words[O] = R | I, I = x >>> 26 - E;
                    }
                    I && (this.words[O] = I, this.length++);
                }
                if (w !== 0) {
                    for(O = this.length - 1; O >= 0; O--)this.words[O + w] = this.words[O];
                    for(O = 0; O < w; O++)this.words[O] = 0;
                    this.length += w;
                }
                return this._strip();
            }, o.prototype.ishln = function(g) {
                return n(this.negative === 0), this.iushln(g);
            }, o.prototype.iushrn = function(g, E, w) {
                n(typeof g == "number" && g >= 0);
                var _;
                E ? _ = (E - E % 26) / 26 : _ = 0;
                var O = g % 26, I = Math.min((g - O) / 26, this.length), x = 67108863 ^ 67108863 >>> O << O, R = w;
                if (_ -= I, _ = Math.max(0, _), R) {
                    for(var j = 0; j < I; j++)R.words[j] = this.words[j];
                    R.length = I;
                }
                if (I !== 0) if (this.length > I) for(this.length -= I, j = 0; j < this.length; j++)this.words[j] = this.words[j + I];
                else this.words[0] = 0, this.length = 1;
                var Y = 0;
                for(j = this.length - 1; j >= 0 && (Y !== 0 || j >= _); j--){
                    var he = this.words[j] | 0;
                    this.words[j] = Y << 26 - O | he >>> O, Y = he & x;
                }
                return R && Y !== 0 && (R.words[R.length++] = Y), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
            }, o.prototype.ishrn = function(g, E, w) {
                return n(this.negative === 0), this.iushrn(g, E, w);
            }, o.prototype.shln = function(g) {
                return this.clone().ishln(g);
            }, o.prototype.ushln = function(g) {
                return this.clone().iushln(g);
            }, o.prototype.shrn = function(g) {
                return this.clone().ishrn(g);
            }, o.prototype.ushrn = function(g) {
                return this.clone().iushrn(g);
            }, o.prototype.testn = function(g) {
                n(typeof g == "number" && g >= 0);
                var E = g % 26, w = (g - E) / 26, _ = 1 << E;
                if (this.length <= w) return !1;
                var O = this.words[w];
                return !!(O & _);
            }, o.prototype.imaskn = function(g) {
                n(typeof g == "number" && g >= 0);
                var E = g % 26, w = (g - E) / 26;
                if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w) return this;
                if (E !== 0 && w++, this.length = Math.min(w, this.length), E !== 0) {
                    var _ = 67108863 ^ 67108863 >>> E << E;
                    this.words[this.length - 1] &= _;
                }
                return this._strip();
            }, o.prototype.maskn = function(g) {
                return this.clone().imaskn(g);
            }, o.prototype.iaddn = function(g) {
                return n(typeof g == "number"), n(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
            }, o.prototype._iaddn = function(g) {
                this.words[0] += g;
                for(var E = 0; E < this.length && this.words[E] >= 67108864; E++)this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
                return this.length = Math.max(this.length, E + 1), this;
            }, o.prototype.isubn = function(g) {
                if (n(typeof g == "number"), n(g < 67108864), g < 0) return this.iaddn(-g);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this;
                if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var E = 0; E < this.length && this.words[E] < 0; E++)this.words[E] += 67108864, this.words[E + 1] -= 1;
                return this._strip();
            }, o.prototype.addn = function(g) {
                return this.clone().iaddn(g);
            }, o.prototype.subn = function(g) {
                return this.clone().isubn(g);
            }, o.prototype.iabs = function() {
                return this.negative = 0, this;
            }, o.prototype.abs = function() {
                return this.clone().iabs();
            }, o.prototype._ishlnsubmul = function(g, E, w) {
                var _ = g.length + w, O;
                this._expand(_);
                var I, x = 0;
                for(O = 0; O < g.length; O++){
                    I = (this.words[O + w] | 0) + x;
                    var R = (g.words[O] | 0) * E;
                    I -= R & 67108863, x = (I >> 26) - (R / 67108864 | 0), this.words[O + w] = I & 67108863;
                }
                for(; O < this.length - w; O++)I = (this.words[O + w] | 0) + x, x = I >> 26, this.words[O + w] = I & 67108863;
                if (x === 0) return this._strip();
                for(n(x === -1), x = 0, O = 0; O < this.length; O++)I = -(this.words[O] | 0) + x, x = I >> 26, this.words[O] = I & 67108863;
                return this.negative = 1, this._strip();
            }, o.prototype._wordDiv = function(g, E) {
                var w = this.length - g.length, _ = this.clone(), O = g, I = O.words[O.length - 1] | 0, x = this._countBits(I);
                w = 26 - x, w !== 0 && (O = O.ushln(w), _.iushln(w), I = O.words[O.length - 1] | 0);
                var R = _.length - O.length, j;
                if (E !== "mod") {
                    j = new o(null), j.length = R + 1, j.words = new Array(j.length);
                    for(var Y = 0; Y < j.length; Y++)j.words[Y] = 0;
                }
                var he = _.clone()._ishlnsubmul(O, 1, R);
                he.negative === 0 && (_ = he, j && (j.words[R] = 1));
                for(var ue = R - 1; ue >= 0; ue--){
                    var G = (_.words[O.length + ue] | 0) * 67108864 + (_.words[O.length + ue - 1] | 0);
                    for(G = Math.min(G / I | 0, 67108863), _._ishlnsubmul(O, G, ue); _.negative !== 0;)G--, _.negative = 0, _._ishlnsubmul(O, 1, ue), _.isZero() || (_.negative ^= 1);
                    j && (j.words[ue] = G);
                }
                return j && j._strip(), _._strip(), E !== "div" && w !== 0 && _.iushrn(w), {
                    div: j || null,
                    mod: _
                };
            }, o.prototype.divmod = function(g, E, w) {
                if (n(!g.isZero()), this.isZero()) return {
                    div: new o(0),
                    mod: new o(0)
                };
                var _, O, I;
                return this.negative !== 0 && g.negative === 0 ? (I = this.neg().divmod(g, E), E !== "mod" && (_ = I.div.neg()), E !== "div" && (O = I.mod.neg(), w && O.negative !== 0 && O.iadd(g)), {
                    div: _,
                    mod: O
                }) : this.negative === 0 && g.negative !== 0 ? (I = this.divmod(g.neg(), E), E !== "mod" && (_ = I.div.neg()), {
                    div: _,
                    mod: I.mod
                }) : this.negative & g.negative ? (I = this.neg().divmod(g.neg(), E), E !== "div" && (O = I.mod.neg(), w && O.negative !== 0 && O.isub(g)), {
                    div: I.div,
                    mod: O
                }) : g.length > this.length || this.cmp(g) < 0 ? {
                    div: new o(0),
                    mod: this
                } : g.length === 1 ? E === "div" ? {
                    div: this.divn(g.words[0]),
                    mod: null
                } : E === "mod" ? {
                    div: null,
                    mod: new o(this.modrn(g.words[0]))
                } : {
                    div: this.divn(g.words[0]),
                    mod: new o(this.modrn(g.words[0]))
                } : this._wordDiv(g, E);
            }, o.prototype.div = function(g) {
                return this.divmod(g, "div", !1).div;
            }, o.prototype.mod = function(g) {
                return this.divmod(g, "mod", !1).mod;
            }, o.prototype.umod = function(g) {
                return this.divmod(g, "mod", !0).mod;
            }, o.prototype.divRound = function(g) {
                var E = this.divmod(g);
                if (E.mod.isZero()) return E.div;
                var w = E.div.negative !== 0 ? E.mod.isub(g) : E.mod, _ = g.ushrn(1), O = g.andln(1), I = w.cmp(_);
                return I < 0 || O === 1 && I === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
            }, o.prototype.modrn = function(g) {
                var E = g < 0;
                E && (g = -g), n(g <= 67108863);
                for(var w = (1 << 26) % g, _ = 0, O = this.length - 1; O >= 0; O--)_ = (w * _ + (this.words[O] | 0)) % g;
                return E ? -_ : _;
            }, o.prototype.modn = function(g) {
                return this.modrn(g);
            }, o.prototype.idivn = function(g) {
                var E = g < 0;
                E && (g = -g), n(g <= 67108863);
                for(var w = 0, _ = this.length - 1; _ >= 0; _--){
                    var O = (this.words[_] | 0) + w * 67108864;
                    this.words[_] = O / g | 0, w = O % g;
                }
                return this._strip(), E ? this.ineg() : this;
            }, o.prototype.divn = function(g) {
                return this.clone().idivn(g);
            }, o.prototype.egcd = function(g) {
                n(g.negative === 0), n(!g.isZero());
                var E = this, w = g.clone();
                E.negative !== 0 ? E = E.umod(g) : E = E.clone();
                for(var _ = new o(1), O = new o(0), I = new o(0), x = new o(1), R = 0; E.isEven() && w.isEven();)E.iushrn(1), w.iushrn(1), ++R;
                for(var j = w.clone(), Y = E.clone(); !E.isZero();){
                    for(var he = 0, ue = 1; !(E.words[0] & ue) && he < 26; ++he, ue <<= 1);
                    if (he > 0) for(E.iushrn(he); he-- > 0;)(_.isOdd() || O.isOdd()) && (_.iadd(j), O.isub(Y)), _.iushrn(1), O.iushrn(1);
                    for(var G = 0, se = 1; !(w.words[0] & se) && G < 26; ++G, se <<= 1);
                    if (G > 0) for(w.iushrn(G); G-- > 0;)(I.isOdd() || x.isOdd()) && (I.iadd(j), x.isub(Y)), I.iushrn(1), x.iushrn(1);
                    E.cmp(w) >= 0 ? (E.isub(w), _.isub(I), O.isub(x)) : (w.isub(E), I.isub(_), x.isub(O));
                }
                return {
                    a: I,
                    b: x,
                    gcd: w.iushln(R)
                };
            }, o.prototype._invmp = function(g) {
                n(g.negative === 0), n(!g.isZero());
                var E = this, w = g.clone();
                E.negative !== 0 ? E = E.umod(g) : E = E.clone();
                for(var _ = new o(1), O = new o(0), I = w.clone(); E.cmpn(1) > 0 && w.cmpn(1) > 0;){
                    for(var x = 0, R = 1; !(E.words[0] & R) && x < 26; ++x, R <<= 1);
                    if (x > 0) for(E.iushrn(x); x-- > 0;)_.isOdd() && _.iadd(I), _.iushrn(1);
                    for(var j = 0, Y = 1; !(w.words[0] & Y) && j < 26; ++j, Y <<= 1);
                    if (j > 0) for(w.iushrn(j); j-- > 0;)O.isOdd() && O.iadd(I), O.iushrn(1);
                    E.cmp(w) >= 0 ? (E.isub(w), _.isub(O)) : (w.isub(E), O.isub(_));
                }
                var he;
                return E.cmpn(1) === 0 ? he = _ : he = O, he.cmpn(0) < 0 && he.iadd(g), he;
            }, o.prototype.gcd = function(g) {
                if (this.isZero()) return g.abs();
                if (g.isZero()) return this.abs();
                var E = this.clone(), w = g.clone();
                E.negative = 0, w.negative = 0;
                for(var _ = 0; E.isEven() && w.isEven(); _++)E.iushrn(1), w.iushrn(1);
                do {
                    for(; E.isEven();)E.iushrn(1);
                    for(; w.isEven();)w.iushrn(1);
                    var O = E.cmp(w);
                    if (O < 0) {
                        var I = E;
                        E = w, w = I;
                    } else if (O === 0 || w.cmpn(1) === 0) break;
                    E.isub(w);
                }while (!0)
                return w.iushln(_);
            }, o.prototype.invm = function(g) {
                return this.egcd(g).a.umod(g);
            }, o.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, o.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, o.prototype.andln = function(g) {
                return this.words[0] & g;
            }, o.prototype.bincn = function(g) {
                n(typeof g == "number");
                var E = g % 26, w = (g - E) / 26, _ = 1 << E;
                if (this.length <= w) return this._expand(w + 1), this.words[w] |= _, this;
                for(var O = _, I = w; O !== 0 && I < this.length; I++){
                    var x = this.words[I] | 0;
                    x += O, O = x >>> 26, x &= 67108863, this.words[I] = x;
                }
                return O !== 0 && (this.words[I] = O, this.length++), this;
            }, o.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, o.prototype.cmpn = function(g) {
                var E = g < 0;
                if (this.negative !== 0 && !E) return -1;
                if (this.negative === 0 && E) return 1;
                this._strip();
                var w;
                if (this.length > 1) w = 1;
                else {
                    E && (g = -g), n(g <= 67108863, "Number is too big");
                    var _ = this.words[0] | 0;
                    w = _ === g ? 0 : _ < g ? -1 : 1;
                }
                return this.negative !== 0 ? -w | 0 : w;
            }, o.prototype.cmp = function(g) {
                if (this.negative !== 0 && g.negative === 0) return -1;
                if (this.negative === 0 && g.negative !== 0) return 1;
                var E = this.ucmp(g);
                return this.negative !== 0 ? -E | 0 : E;
            }, o.prototype.ucmp = function(g) {
                if (this.length > g.length) return 1;
                if (this.length < g.length) return -1;
                for(var E = 0, w = this.length - 1; w >= 0; w--){
                    var _ = this.words[w] | 0, O = g.words[w] | 0;
                    if (_ !== O) {
                        _ < O ? E = -1 : _ > O && (E = 1);
                        break;
                    }
                }
                return E;
            }, o.prototype.gtn = function(g) {
                return this.cmpn(g) === 1;
            }, o.prototype.gt = function(g) {
                return this.cmp(g) === 1;
            }, o.prototype.gten = function(g) {
                return this.cmpn(g) >= 0;
            }, o.prototype.gte = function(g) {
                return this.cmp(g) >= 0;
            }, o.prototype.ltn = function(g) {
                return this.cmpn(g) === -1;
            }, o.prototype.lt = function(g) {
                return this.cmp(g) === -1;
            }, o.prototype.lten = function(g) {
                return this.cmpn(g) <= 0;
            }, o.prototype.lte = function(g) {
                return this.cmp(g) <= 0;
            }, o.prototype.eqn = function(g) {
                return this.cmpn(g) === 0;
            }, o.prototype.eq = function(g) {
                return this.cmp(g) === 0;
            }, o.red = function(g) {
                return new v(g);
            }, o.prototype.toRed = function(g) {
                return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
            }, o.prototype.fromRed = function() {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, o.prototype._forceRed = function(g) {
                return this.red = g, this;
            }, o.prototype.forceRed = function(g) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(g);
            }, o.prototype.redAdd = function(g) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
            }, o.prototype.redIAdd = function(g) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
            }, o.prototype.redSub = function(g) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
            }, o.prototype.redISub = function(g) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
            }, o.prototype.redShl = function(g) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
            }, o.prototype.redMul = function(g) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
            }, o.prototype.redIMul = function(g) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
            }, o.prototype.redSqr = function() {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, o.prototype.redISqr = function() {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, o.prototype.redSqrt = function() {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, o.prototype.redInvm = function() {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, o.prototype.redNeg = function() {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, o.prototype.redPow = function(g) {
                return n(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
            };
            var $ = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function ne(g, E) {
                this.name = g, this.p = new o(E, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            ne.prototype._tmp = function() {
                var g = new o(null);
                return g.words = new Array(Math.ceil(this.n / 13)), g;
            }, ne.prototype.ireduce = function(g) {
                var E = g, w;
                do this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), w = E.bitLength();
                while (w > this.n)
                var _ = w < this.n ? -1 : E.ucmp(this.p);
                return _ === 0 ? (E.words[0] = 0, E.length = 1) : _ > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
            }, ne.prototype.split = function(g, E) {
                g.iushrn(this.n, 0, E);
            }, ne.prototype.imulK = function(g) {
                return g.imul(this.k);
            };
            function ee() {
                ne.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            i1(ee, ne), ee.prototype.split = function(g, E) {
                for(var w = 4194303, _ = Math.min(g.length, 9), O = 0; O < _; O++)E.words[O] = g.words[O];
                if (E.length = _, g.length <= 9) {
                    g.words[0] = 0, g.length = 1;
                    return;
                }
                var I = g.words[9];
                for(E.words[E.length++] = I & w, O = 10; O < g.length; O++){
                    var x = g.words[O] | 0;
                    g.words[O - 10] = (x & w) << 4 | I >>> 22, I = x;
                }
                I >>>= 22, g.words[O - 10] = I, I === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
            }, ee.prototype.imulK = function(g) {
                g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
                for(var E = 0, w = 0; w < g.length; w++){
                    var _ = g.words[w] | 0;
                    E += _ * 977, g.words[w] = E & 67108863, E = _ * 64 + (E / 67108864 | 0);
                }
                return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
            };
            function q() {
                ne.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            i1(q, ne);
            function U() {
                ne.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            i1(U, ne);
            function Q() {
                ne.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            i1(Q, ne), Q.prototype.imulK = function(g) {
                for(var E = 0, w = 0; w < g.length; w++){
                    var _ = (g.words[w] | 0) * 19 + E, O = _ & 67108863;
                    _ >>>= 26, g.words[w] = O, E = _;
                }
                return E !== 0 && (g.words[g.length++] = E), g;
            }, o._prime = function(g) {
                if ($[g]) return $[g];
                var E;
                if (g === "k256") E = new ee();
                else if (g === "p224") E = new q();
                else if (g === "p192") E = new U();
                else if (g === "p25519") E = new Q();
                else throw new Error("Unknown prime " + g);
                return $[g] = E, E;
            };
            function v(g) {
                if (typeof g == "string") {
                    var E = o._prime(g);
                    this.m = E.p, this.prime = E;
                } else n(g.gtn(1), "modulus must be greater than 1"), this.m = g, this.prime = null;
            }
            v.prototype._verify1 = function(g) {
                n(g.negative === 0, "red works only with positives"), n(g.red, "red works only with red numbers");
            }, v.prototype._verify2 = function(g, E) {
                n((g.negative | E.negative) === 0, "red works only with positives"), n(g.red && g.red === E.red, "red works only with red numbers");
            }, v.prototype.imod = function(g) {
                return this.prime ? this.prime.ireduce(g)._forceRed(this) : (u(g, g.umod(this.m)._forceRed(this)), g);
            }, v.prototype.neg = function(g) {
                return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
            }, v.prototype.add = function(g, E) {
                this._verify2(g, E);
                var w = g.add(E);
                return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
            }, v.prototype.iadd = function(g, E) {
                this._verify2(g, E);
                var w = g.iadd(E);
                return w.cmp(this.m) >= 0 && w.isub(this.m), w;
            }, v.prototype.sub = function(g, E) {
                this._verify2(g, E);
                var w = g.sub(E);
                return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
            }, v.prototype.isub = function(g, E) {
                this._verify2(g, E);
                var w = g.isub(E);
                return w.cmpn(0) < 0 && w.iadd(this.m), w;
            }, v.prototype.shl = function(g, E) {
                return this._verify1(g), this.imod(g.ushln(E));
            }, v.prototype.imul = function(g, E) {
                return this._verify2(g, E), this.imod(g.imul(E));
            }, v.prototype.mul = function(g, E) {
                return this._verify2(g, E), this.imod(g.mul(E));
            }, v.prototype.isqr = function(g) {
                return this.imul(g, g.clone());
            }, v.prototype.sqr = function(g) {
                return this.mul(g, g);
            }, v.prototype.sqrt = function(g) {
                if (g.isZero()) return g.clone();
                var E = this.m.andln(3);
                if (n(E % 2 === 1), E === 3) {
                    var w = this.m.add(new o(1)).iushrn(2);
                    return this.pow(g, w);
                }
                for(var _ = this.m.subn(1), O = 0; !_.isZero() && _.andln(1) === 0;)O++, _.iushrn(1);
                n(!_.isZero());
                var I = new o(1).toRed(this), x = I.redNeg(), R = this.m.subn(1).iushrn(1), j = this.m.bitLength();
                for(j = new o(2 * j * j).toRed(this); this.pow(j, R).cmp(x) !== 0;)j.redIAdd(x);
                for(var Y = this.pow(j, _), he = this.pow(g, _.addn(1).iushrn(1)), ue = this.pow(g, _), G = O; ue.cmp(I) !== 0;){
                    for(var se = ue, Z = 0; se.cmp(I) !== 0; Z++)se = se.redSqr();
                    n(Z < G);
                    var ie = this.pow(Y, new o(1).iushln(G - Z - 1));
                    he = he.redMul(ie), Y = ie.redSqr(), ue = ue.redMul(Y), G = Z;
                }
                return he;
            }, v.prototype.invm = function(g) {
                var E = g._invmp(this.m);
                return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
            }, v.prototype.pow = function(g, E) {
                if (E.isZero()) return new o(1).toRed(this);
                if (E.cmpn(1) === 0) return g.clone();
                var w = 4, _ = new Array(1 << w);
                _[0] = new o(1).toRed(this), _[1] = g;
                for(var O = 2; O < _.length; O++)_[O] = this.mul(_[O - 1], g);
                var I = _[0], x = 0, R = 0, j = E.bitLength() % 26;
                for(j === 0 && (j = 26), O = E.length - 1; O >= 0; O--){
                    for(var Y = E.words[O], he = j - 1; he >= 0; he--){
                        var ue = Y >> he & 1;
                        if (I !== _[0] && (I = this.sqr(I)), ue === 0 && x === 0) {
                            R = 0;
                            continue;
                        }
                        x <<= 1, x |= ue, R++, !(R !== w && (O !== 0 || he !== 0)) && (I = this.mul(I, _[x]), R = 0, x = 0);
                    }
                    j = 26;
                }
                return I;
            }, v.prototype.convertTo = function(g) {
                var E = g.umod(this.m);
                return E === g ? E.clone() : E;
            }, v.prototype.convertFrom = function(g) {
                var E = g.clone();
                return E.red = null, E;
            }, o.mont = function(g) {
                return new B(g);
            };
            function B(g) {
                v.call(this, g), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            i1(B, v), B.prototype.convertTo = function(g) {
                return this.imod(g.ushln(this.shift));
            }, B.prototype.convertFrom = function(g) {
                var E = this.imod(g.mul(this.rinv));
                return E.red = null, E;
            }, B.prototype.imul = function(g, E) {
                if (g.isZero() || E.isZero()) return g.words[0] = 0, g.length = 1, g;
                var w = g.imul(E), _ = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = w.isub(_).iushrn(this.shift), I = O;
                return O.cmp(this.m) >= 0 ? I = O.isub(this.m) : O.cmpn(0) < 0 && (I = O.iadd(this.m)), I._forceRed(this);
            }, B.prototype.mul = function(g, E) {
                if (g.isZero() || E.isZero()) return new o(0)._forceRed(this);
                var w = g.mul(E), _ = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = w.isub(_).iushrn(this.shift), I = O;
                return O.cmp(this.m) >= 0 ? I = O.isub(this.m) : O.cmpn(0) < 0 && (I = O.iadd(this.m)), I._forceRed(this);
            }, B.prototype.invm = function(g) {
                var E = this.imod(g._invmp(this.m).mul(this.r2));
                return E._forceRed(this);
            };
        })(e, Qe);
    }(h_)), h_.exports;
}
var Bv, g_;
function e5() {
    if (g_) return Bv;
    g_ = 1;
    var e = J6(), t = Dh(), r = Br().Buffer;
    function n(a) {
        var s = a.modulus.byteLength(), c;
        do c = new e(t(s));
        while (c.cmp(a.modulus) >= 0 || !c.umod(a.prime1) || !c.umod(a.prime2))
        return c;
    }
    function i1(a) {
        var s = n(a), c = s.toRed(e.mont(a.modulus)).redPow(new e(a.publicExponent)).fromRed();
        return {
            blinder: c,
            unblinder: s.invm(a.modulus)
        };
    }
    function o(a, s) {
        var c = i1(s), l = s.modulus.byteLength(), u = new e(a).mul(c.blinder).umod(s.modulus), f = u.toRed(e.mont(s.prime1)), h = u.toRed(e.mont(s.prime2)), y = s.coefficient, S = s.prime1, k = s.prime2, P = f.redPow(s.exponent1).fromRed(), M = h.redPow(s.exponent2).fromRed(), N = P.isub(M).imul(y).umod(S).imul(k);
        return M.iadd(N).imul(c.unblinder).umod(s.modulus).toArrayLike(r, "be", l);
    }
    return o.getr = n, Bv = o, Bv;
}
var y_ = {};
const FJ = "6.6.1", zJ = {
    version: FJ
};
var m_ = {}, b_ = {}, w_;
function RC() {
    return w_ || (w_ = 1, function(e) {
        var t = e;
        function r(o, a) {
            if (Array.isArray(o)) return o.slice();
            if (!o) return [];
            var s = [];
            if (typeof o != "string") {
                for(var c = 0; c < o.length; c++)s[c] = o[c] | 0;
                return s;
            }
            if (a === "hex") {
                o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
                for(var c = 0; c < o.length; c += 2)s.push(parseInt(o[c] + o[c + 1], 16));
            } else for(var c = 0; c < o.length; c++){
                var l = o.charCodeAt(c), u = l >> 8, f = l & 255;
                u ? s.push(u, f) : s.push(f);
            }
            return s;
        }
        t.toArray = r;
        function n(o) {
            return o.length === 1 ? "0" + o : o;
        }
        t.zero2 = n;
        function i1(o) {
            for(var a = "", s = 0; s < o.length; s++)a += n(o[s].toString(16));
            return a;
        }
        t.toHex = i1, t.encode = function(o, a) {
            return a === "hex" ? i1(o) : o;
        };
    }(b_)), b_;
}
var A_;
function Da() {
    return A_ || (A_ = 1, function(e) {
        var t = e, r = Bi(), n = Ua(), i1 = RC();
        t.assert = n, t.toArray = i1.toArray, t.zero2 = i1.zero2, t.toHex = i1.toHex, t.encode = i1.encode;
        function o(u, f, h) {
            var y = new Array(Math.max(u.bitLength(), h) + 1), S;
            for(S = 0; S < y.length; S += 1)y[S] = 0;
            var k = 1 << f + 1, P = u.clone();
            for(S = 0; S < y.length; S++){
                var M, N = P.andln(k - 1);
                P.isOdd() ? (N > (k >> 1) - 1 ? M = (k >> 1) - N : M = N, P.isubn(M)) : M = 0, y[S] = M, P.iushrn(1);
            }
            return y;
        }
        t.getNAF = o;
        function a(u, f) {
            var h = [
                [],
                []
            ];
            u = u.clone(), f = f.clone();
            for(var y = 0, S = 0, k; u.cmpn(-y) > 0 || f.cmpn(-S) > 0;){
                var P = u.andln(3) + y & 3, M = f.andln(3) + S & 3;
                P === 3 && (P = -1), M === 3 && (M = -1);
                var N;
                P & 1 ? (k = u.andln(7) + y & 7, (k === 3 || k === 5) && M === 2 ? N = -P : N = P) : N = 0, h[0].push(N);
                var z;
                M & 1 ? (k = f.andln(7) + S & 7, (k === 3 || k === 5) && P === 2 ? z = -M : z = M) : z = 0, h[1].push(z), 2 * y === N + 1 && (y = 1 - y), 2 * S === z + 1 && (S = 1 - S), u.iushrn(1), f.iushrn(1);
            }
            return h;
        }
        t.getJSF = a;
        function s(u, f, h) {
            var y = "_" + f;
            u.prototype[f] = function() {
                return this[y] !== void 0 ? this[y] : this[y] = h.call(this);
            };
        }
        t.cachedProperty = s;
        function c(u) {
            return typeof u == "string" ? t.toArray(u, "hex") : u;
        }
        t.parseBytes = c;
        function l(u) {
            return new r(u, "hex", "le");
        }
        t.intFromLE = l;
    }(m_)), m_;
}
var v_ = {}, Tv, E_;
function W2() {
    if (E_) return Tv;
    E_ = 1;
    var e = Bi(), t = Da(), r = t.getNAF, n = t.getJSF, i1 = t.assert;
    function o(s, c) {
        this.type = s, this.p = new e(c.p, 16), this.red = c.prime ? e.red(c.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = c.n && new e(c.n, 16), this.g = c.g && this.pointFromJSON(c.g, c.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var l = this.n && this.p.div(this.n);
        !l || l.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
    }
    Tv = o, o.prototype.point = function() {
        throw new Error("Not implemented");
    }, o.prototype.validate = function() {
        throw new Error("Not implemented");
    }, o.prototype._fixedNafMul = function(s, c) {
        i1(s.precomputed);
        var l = s._getDoubles(), u = r(c, 1, this._bitLength), f = (1 << l.step + 1) - (l.step % 2 === 0 ? 2 : 1);
        f /= 3;
        var h = [], y, S;
        for(y = 0; y < u.length; y += l.step){
            S = 0;
            for(var k = y + l.step - 1; k >= y; k--)S = (S << 1) + u[k];
            h.push(S);
        }
        for(var P = this.jpoint(null, null, null), M = this.jpoint(null, null, null), N = f; N > 0; N--){
            for(y = 0; y < h.length; y++)S = h[y], S === N ? M = M.mixedAdd(l.points[y]) : S === -N && (M = M.mixedAdd(l.points[y].neg()));
            P = P.add(M);
        }
        return P.toP();
    }, o.prototype._wnafMul = function(s, c) {
        var l = 4, u = s._getNAFPoints(l);
        l = u.wnd;
        for(var f = u.points, h = r(c, l, this._bitLength), y = this.jpoint(null, null, null), S = h.length - 1; S >= 0; S--){
            for(var k = 0; S >= 0 && h[S] === 0; S--)k++;
            if (S >= 0 && k++, y = y.dblp(k), S < 0) break;
            var P = h[S];
            i1(P !== 0), s.type === "affine" ? P > 0 ? y = y.mixedAdd(f[P - 1 >> 1]) : y = y.mixedAdd(f[-P - 1 >> 1].neg()) : P > 0 ? y = y.add(f[P - 1 >> 1]) : y = y.add(f[-P - 1 >> 1].neg());
        }
        return s.type === "affine" ? y.toP() : y;
    }, o.prototype._wnafMulAdd = function(s, c, l, u, f) {
        var h = this._wnafT1, y = this._wnafT2, S = this._wnafT3, k = 0, P, M, N;
        for(P = 0; P < u; P++){
            N = c[P];
            var z = N._getNAFPoints(s);
            h[P] = z.wnd, y[P] = z.points;
        }
        for(P = u - 1; P >= 1; P -= 2){
            var K = P - 1, $ = P;
            if (h[K] !== 1 || h[$] !== 1) {
                S[K] = r(l[K], h[K], this._bitLength), S[$] = r(l[$], h[$], this._bitLength), k = Math.max(S[K].length, k), k = Math.max(S[$].length, k);
                continue;
            }
            var ne = [
                c[K],
                /* 1 */ null,
                /* 3 */ null,
                /* 5 */ c[$]
            ];
            c[K].y.cmp(c[$].y) === 0 ? (ne[1] = c[K].add(c[$]), ne[2] = c[K].toJ().mixedAdd(c[$].neg())) : c[K].y.cmp(c[$].y.redNeg()) === 0 ? (ne[1] = c[K].toJ().mixedAdd(c[$]), ne[2] = c[K].add(c[$].neg())) : (ne[1] = c[K].toJ().mixedAdd(c[$]), ne[2] = c[K].toJ().mixedAdd(c[$].neg()));
            var ee = [
                -3,
                /* -1 -1 */ -1,
                /* -1 0 */ -5,
                /* -1 1 */ -7,
                /* 0 -1 */ 0,
                /* 0 0 */ 7,
                /* 0 1 */ 5,
                /* 1 -1 */ 1,
                /* 1 0 */ 3
            ], q = n(l[K], l[$]);
            for(k = Math.max(q[0].length, k), S[K] = new Array(k), S[$] = new Array(k), M = 0; M < k; M++){
                var U = q[0][M] | 0, Q = q[1][M] | 0;
                S[K][M] = ee[(U + 1) * 3 + (Q + 1)], S[$][M] = 0, y[K] = ne;
            }
        }
        var v = this.jpoint(null, null, null), B = this._wnafT4;
        for(P = k; P >= 0; P--){
            for(var g = 0; P >= 0;){
                var E = !0;
                for(M = 0; M < u; M++)B[M] = S[M][P] | 0, B[M] !== 0 && (E = !1);
                if (!E) break;
                g++, P--;
            }
            if (P >= 0 && g++, v = v.dblp(g), P < 0) break;
            for(M = 0; M < u; M++){
                var w = B[M];
                w !== 0 && (w > 0 ? N = y[M][w - 1 >> 1] : w < 0 && (N = y[M][-w - 1 >> 1].neg()), N.type === "affine" ? v = v.mixedAdd(N) : v = v.add(N));
            }
        }
        for(P = 0; P < u; P++)y[P] = null;
        return f ? v : v.toP();
    };
    function a(s, c) {
        this.curve = s, this.type = c, this.precomputed = null;
    }
    return o.BasePoint = a, a.prototype.eq = function() {
        throw new Error("Not implemented");
    }, a.prototype.validate = function() {
        return this.curve.validate(this);
    }, o.prototype.decodePoint = function(s, c) {
        s = t.toArray(s, c);
        var l = this.p.byteLength();
        if ((s[0] === 4 || s[0] === 6 || s[0] === 7) && s.length - 1 === 2 * l) {
            s[0] === 6 ? i1(s[s.length - 1] % 2 === 0) : s[0] === 7 && i1(s[s.length - 1] % 2 === 1);
            var u = this.point(s.slice(1, 1 + l), s.slice(1 + l, 1 + 2 * l));
            return u;
        } else if ((s[0] === 2 || s[0] === 3) && s.length - 1 === l) return this.pointFromX(s.slice(1, 1 + l), s[0] === 3);
        throw new Error("Unknown point format");
    }, a.prototype.encodeCompressed = function(s) {
        return this.encode(s, !0);
    }, a.prototype._encode = function(s) {
        var c = this.curve.p.byteLength(), l = this.getX().toArray("be", c);
        return s ? [
            this.getY().isEven() ? 2 : 3
        ].concat(l) : [
            4
        ].concat(l, this.getY().toArray("be", c));
    }, a.prototype.encode = function(s, c) {
        return t.encode(this._encode(c), s);
    }, a.prototype.precompute = function(s) {
        if (this.precomputed) return this;
        var c = {
            doubles: null,
            naf: null,
            beta: null
        };
        return c.naf = this._getNAFPoints(8), c.doubles = this._getDoubles(4, s), c.beta = this._getBeta(), this.precomputed = c, this;
    }, a.prototype._hasDoubles = function(s) {
        if (!this.precomputed) return !1;
        var c = this.precomputed.doubles;
        return c ? c.points.length >= Math.ceil((s.bitLength() + 1) / c.step) : !1;
    }, a.prototype._getDoubles = function(s, c) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        for(var l = [
            this
        ], u = this, f = 0; f < c; f += s){
            for(var h = 0; h < s; h++)u = u.dbl();
            l.push(u);
        }
        return {
            step: s,
            points: l
        };
    }, a.prototype._getNAFPoints = function(s) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        for(var c = [
            this
        ], l = (1 << s) - 1, u = l === 1 ? null : this.dbl(), f = 1; f < l; f++)c[f] = c[f - 1].add(u);
        return {
            wnd: s,
            points: c
        };
    }, a.prototype._getBeta = function() {
        return null;
    }, a.prototype.dblp = function(s) {
        for(var c = this, l = 0; l < s; l++)c = c.dbl();
        return c;
    }, Tv;
}
var Pv, S_;
function LJ() {
    if (S_) return Pv;
    S_ = 1;
    var e = Da(), t = Bi(), r = Nr(), n = W2(), i1 = e.assert;
    function o(c) {
        n.call(this, "short", c), this.a = new t(c.a, 16).toRed(this.red), this.b = new t(c.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(c), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    r(o, n), Pv = o, o.prototype._getEndomorphism = function(c) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var l, u;
            if (c.beta) l = new t(c.beta, 16).toRed(this.red);
            else {
                var f = this._getEndoRoots(this.p);
                l = f[0].cmp(f[1]) < 0 ? f[0] : f[1], l = l.toRed(this.red);
            }
            if (c.lambda) u = new t(c.lambda, 16);
            else {
                var h = this._getEndoRoots(this.n);
                this.g.mul(h[0]).x.cmp(this.g.x.redMul(l)) === 0 ? u = h[0] : (u = h[1], i1(this.g.mul(u).x.cmp(this.g.x.redMul(l)) === 0));
            }
            var y;
            return c.basis ? y = c.basis.map(function(S) {
                return {
                    a: new t(S.a, 16),
                    b: new t(S.b, 16)
                };
            }) : y = this._getEndoBasis(u), {
                beta: l,
                lambda: u,
                basis: y
            };
        }
    }, o.prototype._getEndoRoots = function(c) {
        var l = c === this.p ? this.red : t.mont(c), u = new t(2).toRed(l).redInvm(), f = u.redNeg(), h = new t(3).toRed(l).redNeg().redSqrt().redMul(u), y = f.redAdd(h).fromRed(), S = f.redSub(h).fromRed();
        return [
            y,
            S
        ];
    }, o.prototype._getEndoBasis = function(c) {
        for(var l = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = c, f = this.n.clone(), h = new t(1), y = new t(0), S = new t(0), k = new t(1), P, M, N, z, K, $, ne, ee = 0, q, U; u.cmpn(0) !== 0;){
            var Q = f.div(u);
            q = f.sub(Q.mul(u)), U = S.sub(Q.mul(h));
            var v = k.sub(Q.mul(y));
            if (!N && q.cmp(l) < 0) P = ne.neg(), M = h, N = q.neg(), z = U;
            else if (N && ++ee === 2) break;
            ne = q, f = u, u = q, S = h, h = U, k = y, y = v;
        }
        K = q.neg(), $ = U;
        var B = N.sqr().add(z.sqr()), g = K.sqr().add($.sqr());
        return g.cmp(B) >= 0 && (K = P, $ = M), N.negative && (N = N.neg(), z = z.neg()), K.negative && (K = K.neg(), $ = $.neg()), [
            {
                a: N,
                b: z
            },
            {
                a: K,
                b: $
            }
        ];
    }, o.prototype._endoSplit = function(c) {
        var l = this.endo.basis, u = l[0], f = l[1], h = f.b.mul(c).divRound(this.n), y = u.b.neg().mul(c).divRound(this.n), S = h.mul(u.a), k = y.mul(f.a), P = h.mul(u.b), M = y.mul(f.b), N = c.sub(S).sub(k), z = P.add(M).neg();
        return {
            k1: N,
            k2: z
        };
    }, o.prototype.pointFromX = function(c, l) {
        c = new t(c, 16), c.red || (c = c.toRed(this.red));
        var u = c.redSqr().redMul(c).redIAdd(c.redMul(this.a)).redIAdd(this.b), f = u.redSqrt();
        if (f.redSqr().redSub(u).cmp(this.zero) !== 0) throw new Error("invalid point");
        var h = f.fromRed().isOdd();
        return (l && !h || !l && h) && (f = f.redNeg()), this.point(c, f);
    }, o.prototype.validate = function(c) {
        if (c.inf) return !0;
        var l = c.x, u = c.y, f = this.a.redMul(l), h = l.redSqr().redMul(l).redIAdd(f).redIAdd(this.b);
        return u.redSqr().redISub(h).cmpn(0) === 0;
    }, o.prototype._endoWnafMulAdd = function(c, l, u) {
        for(var f = this._endoWnafT1, h = this._endoWnafT2, y = 0; y < c.length; y++){
            var S = this._endoSplit(l[y]), k = c[y], P = k._getBeta();
            S.k1.negative && (S.k1.ineg(), k = k.neg(!0)), S.k2.negative && (S.k2.ineg(), P = P.neg(!0)), f[y * 2] = k, f[y * 2 + 1] = P, h[y * 2] = S.k1, h[y * 2 + 1] = S.k2;
        }
        for(var M = this._wnafMulAdd(1, f, h, y * 2, u), N = 0; N < y * 2; N++)f[N] = null, h[N] = null;
        return M;
    };
    function a(c, l, u, f) {
        n.BasePoint.call(this, c, "affine"), l === null && u === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(l, 16), this.y = new t(u, 16), f && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
    }
    r(a, n.BasePoint), o.prototype.point = function(c, l, u) {
        return new a(this, c, l, u);
    }, o.prototype.pointFromJSON = function(c, l) {
        return a.fromJSON(this, c, l);
    }, a.prototype._getBeta = function() {
        if (this.curve.endo) {
            var c = this.precomputed;
            if (c && c.beta) return c.beta;
            var l = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (c) {
                var u = this.curve, f = function(h) {
                    return u.point(h.x.redMul(u.endo.beta), h.y);
                };
                c.beta = l, l.precomputed = {
                    beta: null,
                    naf: c.naf && {
                        wnd: c.naf.wnd,
                        points: c.naf.points.map(f)
                    },
                    doubles: c.doubles && {
                        step: c.doubles.step,
                        points: c.doubles.points.map(f)
                    }
                };
            }
            return l;
        }
    }, a.prototype.toJSON = function() {
        return this.precomputed ? [
            this.x,
            this.y,
            this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }
        ] : [
            this.x,
            this.y
        ];
    }, a.fromJSON = function(c, l, u) {
        typeof l == "string" && (l = JSON.parse(l));
        var f = c.point(l[0], l[1], u);
        if (!l[2]) return f;
        function h(S) {
            return c.point(S[0], S[1], u);
        }
        var y = l[2];
        return f.precomputed = {
            beta: null,
            doubles: y.doubles && {
                step: y.doubles.step,
                points: [
                    f
                ].concat(y.doubles.points.map(h))
            },
            naf: y.naf && {
                wnd: y.naf.wnd,
                points: [
                    f
                ].concat(y.naf.points.map(h))
            }
        }, f;
    }, a.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, a.prototype.isInfinity = function() {
        return this.inf;
    }, a.prototype.add = function(c) {
        if (this.inf) return c;
        if (c.inf) return this;
        if (this.eq(c)) return this.dbl();
        if (this.neg().eq(c)) return this.curve.point(null, null);
        if (this.x.cmp(c.x) === 0) return this.curve.point(null, null);
        var l = this.y.redSub(c.y);
        l.cmpn(0) !== 0 && (l = l.redMul(this.x.redSub(c.x).redInvm()));
        var u = l.redSqr().redISub(this.x).redISub(c.x), f = l.redMul(this.x.redSub(u)).redISub(this.y);
        return this.curve.point(u, f);
    }, a.prototype.dbl = function() {
        if (this.inf) return this;
        var c = this.y.redAdd(this.y);
        if (c.cmpn(0) === 0) return this.curve.point(null, null);
        var l = this.curve.a, u = this.x.redSqr(), f = c.redInvm(), h = u.redAdd(u).redIAdd(u).redIAdd(l).redMul(f), y = h.redSqr().redISub(this.x.redAdd(this.x)), S = h.redMul(this.x.redSub(y)).redISub(this.y);
        return this.curve.point(y, S);
    }, a.prototype.getX = function() {
        return this.x.fromRed();
    }, a.prototype.getY = function() {
        return this.y.fromRed();
    }, a.prototype.mul = function(c) {
        return c = new t(c, 16), this.isInfinity() ? this : this._hasDoubles(c) ? this.curve._fixedNafMul(this, c) : this.curve.endo ? this.curve._endoWnafMulAdd([
            this
        ], [
            c
        ]) : this.curve._wnafMul(this, c);
    }, a.prototype.mulAdd = function(c, l, u) {
        var f = [
            this,
            l
        ], h = [
            c,
            u
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(f, h) : this.curve._wnafMulAdd(1, f, h, 2);
    }, a.prototype.jmulAdd = function(c, l, u) {
        var f = [
            this,
            l
        ], h = [
            c,
            u
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(f, h, !0) : this.curve._wnafMulAdd(1, f, h, 2, !0);
    }, a.prototype.eq = function(c) {
        return this === c || this.inf === c.inf && (this.inf || this.x.cmp(c.x) === 0 && this.y.cmp(c.y) === 0);
    }, a.prototype.neg = function(c) {
        if (this.inf) return this;
        var l = this.curve.point(this.x, this.y.redNeg());
        if (c && this.precomputed) {
            var u = this.precomputed, f = function(h) {
                return h.neg();
            };
            l.precomputed = {
                naf: u.naf && {
                    wnd: u.naf.wnd,
                    points: u.naf.points.map(f)
                },
                doubles: u.doubles && {
                    step: u.doubles.step,
                    points: u.doubles.points.map(f)
                }
            };
        }
        return l;
    }, a.prototype.toJ = function() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var c = this.curve.jpoint(this.x, this.y, this.curve.one);
        return c;
    };
    function s(c, l, u, f) {
        n.BasePoint.call(this, c, "jacobian"), l === null && u === null && f === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(l, 16), this.y = new t(u, 16), this.z = new t(f, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    return r(s, n.BasePoint), o.prototype.jpoint = function(c, l, u) {
        return new s(this, c, l, u);
    }, s.prototype.toP = function() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var c = this.z.redInvm(), l = c.redSqr(), u = this.x.redMul(l), f = this.y.redMul(l).redMul(c);
        return this.curve.point(u, f);
    }, s.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, s.prototype.add = function(c) {
        if (this.isInfinity()) return c;
        if (c.isInfinity()) return this;
        var l = c.z.redSqr(), u = this.z.redSqr(), f = this.x.redMul(l), h = c.x.redMul(u), y = this.y.redMul(l.redMul(c.z)), S = c.y.redMul(u.redMul(this.z)), k = f.redSub(h), P = y.redSub(S);
        if (k.cmpn(0) === 0) return P.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var M = k.redSqr(), N = M.redMul(k), z = f.redMul(M), K = P.redSqr().redIAdd(N).redISub(z).redISub(z), $ = P.redMul(z.redISub(K)).redISub(y.redMul(N)), ne = this.z.redMul(c.z).redMul(k);
        return this.curve.jpoint(K, $, ne);
    }, s.prototype.mixedAdd = function(c) {
        if (this.isInfinity()) return c.toJ();
        if (c.isInfinity()) return this;
        var l = this.z.redSqr(), u = this.x, f = c.x.redMul(l), h = this.y, y = c.y.redMul(l).redMul(this.z), S = u.redSub(f), k = h.redSub(y);
        if (S.cmpn(0) === 0) return k.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var P = S.redSqr(), M = P.redMul(S), N = u.redMul(P), z = k.redSqr().redIAdd(M).redISub(N).redISub(N), K = k.redMul(N.redISub(z)).redISub(h.redMul(M)), $ = this.z.redMul(S);
        return this.curve.jpoint(z, K, $);
    }, s.prototype.dblp = function(c) {
        if (c === 0) return this;
        if (this.isInfinity()) return this;
        if (!c) return this.dbl();
        var l;
        if (this.curve.zeroA || this.curve.threeA) {
            var u = this;
            for(l = 0; l < c; l++)u = u.dbl();
            return u;
        }
        var f = this.curve.a, h = this.curve.tinv, y = this.x, S = this.y, k = this.z, P = k.redSqr().redSqr(), M = S.redAdd(S);
        for(l = 0; l < c; l++){
            var N = y.redSqr(), z = M.redSqr(), K = z.redSqr(), $ = N.redAdd(N).redIAdd(N).redIAdd(f.redMul(P)), ne = y.redMul(z), ee = $.redSqr().redISub(ne.redAdd(ne)), q = ne.redISub(ee), U = $.redMul(q);
            U = U.redIAdd(U).redISub(K);
            var Q = M.redMul(k);
            l + 1 < c && (P = P.redMul(K)), y = ee, k = Q, M = U;
        }
        return this.curve.jpoint(y, M.redMul(h), k);
    }, s.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, s.prototype._zeroDbl = function() {
        var c, l, u;
        if (this.zOne) {
            var f = this.x.redSqr(), h = this.y.redSqr(), y = h.redSqr(), S = this.x.redAdd(h).redSqr().redISub(f).redISub(y);
            S = S.redIAdd(S);
            var k = f.redAdd(f).redIAdd(f), P = k.redSqr().redISub(S).redISub(S), M = y.redIAdd(y);
            M = M.redIAdd(M), M = M.redIAdd(M), c = P, l = k.redMul(S.redISub(P)).redISub(M), u = this.y.redAdd(this.y);
        } else {
            var N = this.x.redSqr(), z = this.y.redSqr(), K = z.redSqr(), $ = this.x.redAdd(z).redSqr().redISub(N).redISub(K);
            $ = $.redIAdd($);
            var ne = N.redAdd(N).redIAdd(N), ee = ne.redSqr(), q = K.redIAdd(K);
            q = q.redIAdd(q), q = q.redIAdd(q), c = ee.redISub($).redISub($), l = ne.redMul($.redISub(c)).redISub(q), u = this.y.redMul(this.z), u = u.redIAdd(u);
        }
        return this.curve.jpoint(c, l, u);
    }, s.prototype._threeDbl = function() {
        var c, l, u;
        if (this.zOne) {
            var f = this.x.redSqr(), h = this.y.redSqr(), y = h.redSqr(), S = this.x.redAdd(h).redSqr().redISub(f).redISub(y);
            S = S.redIAdd(S);
            var k = f.redAdd(f).redIAdd(f).redIAdd(this.curve.a), P = k.redSqr().redISub(S).redISub(S);
            c = P;
            var M = y.redIAdd(y);
            M = M.redIAdd(M), M = M.redIAdd(M), l = k.redMul(S.redISub(P)).redISub(M), u = this.y.redAdd(this.y);
        } else {
            var N = this.z.redSqr(), z = this.y.redSqr(), K = this.x.redMul(z), $ = this.x.redSub(N).redMul(this.x.redAdd(N));
            $ = $.redAdd($).redIAdd($);
            var ne = K.redIAdd(K);
            ne = ne.redIAdd(ne);
            var ee = ne.redAdd(ne);
            c = $.redSqr().redISub(ee), u = this.y.redAdd(this.z).redSqr().redISub(z).redISub(N);
            var q = z.redSqr();
            q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q), l = $.redMul(ne.redISub(c)).redISub(q);
        }
        return this.curve.jpoint(c, l, u);
    }, s.prototype._dbl = function() {
        var c = this.curve.a, l = this.x, u = this.y, f = this.z, h = f.redSqr().redSqr(), y = l.redSqr(), S = u.redSqr(), k = y.redAdd(y).redIAdd(y).redIAdd(c.redMul(h)), P = l.redAdd(l);
        P = P.redIAdd(P);
        var M = P.redMul(S), N = k.redSqr().redISub(M.redAdd(M)), z = M.redISub(N), K = S.redSqr();
        K = K.redIAdd(K), K = K.redIAdd(K), K = K.redIAdd(K);
        var $ = k.redMul(z).redISub(K), ne = u.redAdd(u).redMul(f);
        return this.curve.jpoint(N, $, ne);
    }, s.prototype.trpl = function() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var c = this.x.redSqr(), l = this.y.redSqr(), u = this.z.redSqr(), f = l.redSqr(), h = c.redAdd(c).redIAdd(c), y = h.redSqr(), S = this.x.redAdd(l).redSqr().redISub(c).redISub(f);
        S = S.redIAdd(S), S = S.redAdd(S).redIAdd(S), S = S.redISub(y);
        var k = S.redSqr(), P = f.redIAdd(f);
        P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P);
        var M = h.redIAdd(S).redSqr().redISub(y).redISub(k).redISub(P), N = l.redMul(M);
        N = N.redIAdd(N), N = N.redIAdd(N);
        var z = this.x.redMul(k).redISub(N);
        z = z.redIAdd(z), z = z.redIAdd(z);
        var K = this.y.redMul(M.redMul(P.redISub(M)).redISub(S.redMul(k)));
        K = K.redIAdd(K), K = K.redIAdd(K), K = K.redIAdd(K);
        var $ = this.z.redAdd(S).redSqr().redISub(u).redISub(k);
        return this.curve.jpoint(z, K, $);
    }, s.prototype.mul = function(c, l) {
        return c = new t(c, l), this.curve._wnafMul(this, c);
    }, s.prototype.eq = function(c) {
        if (c.type === "affine") return this.eq(c.toJ());
        if (this === c) return !0;
        var l = this.z.redSqr(), u = c.z.redSqr();
        if (this.x.redMul(u).redISub(c.x.redMul(l)).cmpn(0) !== 0) return !1;
        var f = l.redMul(this.z), h = u.redMul(c.z);
        return this.y.redMul(h).redISub(c.y.redMul(f)).cmpn(0) === 0;
    }, s.prototype.eqXToP = function(c) {
        var l = this.z.redSqr(), u = c.toRed(this.curve.red).redMul(l);
        if (this.x.cmp(u) === 0) return !0;
        for(var f = c.clone(), h = this.curve.redN.redMul(l);;){
            if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0) return !1;
            if (u.redIAdd(h), this.x.cmp(u) === 0) return !0;
        }
    }, s.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, s.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    }, Pv;
}
var Cv, x_;
function HJ() {
    if (x_) return Cv;
    x_ = 1;
    var e = Bi(), t = Nr(), r = W2(), n = Da();
    function i1(a) {
        r.call(this, "mont", a), this.a = new e(a.a, 16).toRed(this.red), this.b = new e(a.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    t(i1, r), Cv = i1, i1.prototype.validate = function(a) {
        var s = a.normalize().x, c = s.redSqr(), l = c.redMul(s).redAdd(c.redMul(this.a)).redAdd(s), u = l.redSqrt();
        return u.redSqr().cmp(l) === 0;
    };
    function o(a, s, c) {
        r.BasePoint.call(this, a, "projective"), s === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(s, 16), this.z = new e(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    return t(o, r.BasePoint), i1.prototype.decodePoint = function(a, s) {
        return this.point(n.toArray(a, s), 1);
    }, i1.prototype.point = function(a, s) {
        return new o(this, a, s);
    }, i1.prototype.pointFromJSON = function(a) {
        return o.fromJSON(this, a);
    }, o.prototype.precompute = function() {}, o.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    }, o.fromJSON = function(a, s) {
        return new o(a, s[0], s[1] || a.one);
    }, o.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, o.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    }, o.prototype.dbl = function() {
        var a = this.x.redAdd(this.z), s = a.redSqr(), c = this.x.redSub(this.z), l = c.redSqr(), u = s.redSub(l), f = s.redMul(l), h = u.redMul(l.redAdd(this.curve.a24.redMul(u)));
        return this.curve.point(f, h);
    }, o.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.diffAdd = function(a, s) {
        var c = this.x.redAdd(this.z), l = this.x.redSub(this.z), u = a.x.redAdd(a.z), f = a.x.redSub(a.z), h = f.redMul(c), y = u.redMul(l), S = s.z.redMul(h.redAdd(y).redSqr()), k = s.x.redMul(h.redISub(y).redSqr());
        return this.curve.point(S, k);
    }, o.prototype.mul = function(a) {
        for(var s = a.clone(), c = this, l = this.curve.point(null, null), u = this, f = []; s.cmpn(0) !== 0; s.iushrn(1))f.push(s.andln(1));
        for(var h = f.length - 1; h >= 0; h--)f[h] === 0 ? (c = c.diffAdd(l, u), l = l.dbl()) : (l = c.diffAdd(l, u), c = c.dbl());
        return l;
    }, o.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    }, o.prototype.eq = function(a) {
        return this.getX().cmp(a.getX()) === 0;
    }, o.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, o.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    }, Cv;
}
var Mv, __;
function KJ() {
    if (__) return Mv;
    __ = 1;
    var e = Da(), t = Bi(), r = Nr(), n = W2(), i1 = e.assert;
    function o(s) {
        this.twisted = (s.a | 0) !== 1, this.mOneA = this.twisted && (s.a | 0) === -1, this.extended = this.mOneA, n.call(this, "edwards", s), this.a = new t(s.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(s.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(s.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), i1(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (s.c | 0) === 1;
    }
    r(o, n), Mv = o, o.prototype._mulA = function(s) {
        return this.mOneA ? s.redNeg() : this.a.redMul(s);
    }, o.prototype._mulC = function(s) {
        return this.oneC ? s : this.c.redMul(s);
    }, o.prototype.jpoint = function(s, c, l, u) {
        return this.point(s, c, l, u);
    }, o.prototype.pointFromX = function(s, c) {
        s = new t(s, 16), s.red || (s = s.toRed(this.red));
        var l = s.redSqr(), u = this.c2.redSub(this.a.redMul(l)), f = this.one.redSub(this.c2.redMul(this.d).redMul(l)), h = u.redMul(f.redInvm()), y = h.redSqrt();
        if (y.redSqr().redSub(h).cmp(this.zero) !== 0) throw new Error("invalid point");
        var S = y.fromRed().isOdd();
        return (c && !S || !c && S) && (y = y.redNeg()), this.point(s, y);
    }, o.prototype.pointFromY = function(s, c) {
        s = new t(s, 16), s.red || (s = s.toRed(this.red));
        var l = s.redSqr(), u = l.redSub(this.c2), f = l.redMul(this.d).redMul(this.c2).redSub(this.a), h = u.redMul(f.redInvm());
        if (h.cmp(this.zero) === 0) {
            if (c) throw new Error("invalid point");
            return this.point(this.zero, s);
        }
        var y = h.redSqrt();
        if (y.redSqr().redSub(h).cmp(this.zero) !== 0) throw new Error("invalid point");
        return y.fromRed().isOdd() !== c && (y = y.redNeg()), this.point(y, s);
    }, o.prototype.validate = function(s) {
        if (s.isInfinity()) return !0;
        s.normalize();
        var c = s.x.redSqr(), l = s.y.redSqr(), u = c.redMul(this.a).redAdd(l), f = this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(l)));
        return u.cmp(f) === 0;
    };
    function a(s, c, l, u, f) {
        n.BasePoint.call(this, s, "projective"), c === null && l === null && u === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(c, 16), this.y = new t(l, 16), this.z = u ? new t(u, 16) : this.curve.one, this.t = f && new t(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    return r(a, n.BasePoint), o.prototype.pointFromJSON = function(s) {
        return a.fromJSON(this, s);
    }, o.prototype.point = function(s, c, l, u) {
        return new a(this, s, c, l, u);
    }, a.fromJSON = function(s, c) {
        return new a(s, c[0], c[1], c[2]);
    }, a.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, a.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, a.prototype._extDbl = function() {
        var s = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr();
        l = l.redIAdd(l);
        var u = this.curve._mulA(s), f = this.x.redAdd(this.y).redSqr().redISub(s).redISub(c), h = u.redAdd(c), y = h.redSub(l), S = u.redSub(c), k = f.redMul(y), P = h.redMul(S), M = f.redMul(S), N = y.redMul(h);
        return this.curve.point(k, P, N, M);
    }, a.prototype._projDbl = function() {
        var s = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), l = this.y.redSqr(), u, f, h, y, S, k;
        if (this.curve.twisted) {
            y = this.curve._mulA(c);
            var P = y.redAdd(l);
            this.zOne ? (u = s.redSub(c).redSub(l).redMul(P.redSub(this.curve.two)), f = P.redMul(y.redSub(l)), h = P.redSqr().redSub(P).redSub(P)) : (S = this.z.redSqr(), k = P.redSub(S).redISub(S), u = s.redSub(c).redISub(l).redMul(k), f = P.redMul(y.redSub(l)), h = P.redMul(k));
        } else y = c.redAdd(l), S = this.curve._mulC(this.z).redSqr(), k = y.redSub(S).redSub(S), u = this.curve._mulC(s.redISub(y)).redMul(k), f = this.curve._mulC(y).redMul(c.redISub(l)), h = y.redMul(k);
        return this.curve.point(u, f, h);
    }, a.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }, a.prototype._extAdd = function(s) {
        var c = this.y.redSub(this.x).redMul(s.y.redSub(s.x)), l = this.y.redAdd(this.x).redMul(s.y.redAdd(s.x)), u = this.t.redMul(this.curve.dd).redMul(s.t), f = this.z.redMul(s.z.redAdd(s.z)), h = l.redSub(c), y = f.redSub(u), S = f.redAdd(u), k = l.redAdd(c), P = h.redMul(y), M = S.redMul(k), N = h.redMul(k), z = y.redMul(S);
        return this.curve.point(P, M, z, N);
    }, a.prototype._projAdd = function(s) {
        var c = this.z.redMul(s.z), l = c.redSqr(), u = this.x.redMul(s.x), f = this.y.redMul(s.y), h = this.curve.d.redMul(u).redMul(f), y = l.redSub(h), S = l.redAdd(h), k = this.x.redAdd(this.y).redMul(s.x.redAdd(s.y)).redISub(u).redISub(f), P = c.redMul(y).redMul(k), M, N;
        return this.curve.twisted ? (M = c.redMul(S).redMul(f.redSub(this.curve._mulA(u))), N = y.redMul(S)) : (M = c.redMul(S).redMul(f.redSub(u)), N = this.curve._mulC(y).redMul(S)), this.curve.point(P, M, N);
    }, a.prototype.add = function(s) {
        return this.isInfinity() ? s : s.isInfinity() ? this : this.curve.extended ? this._extAdd(s) : this._projAdd(s);
    }, a.prototype.mul = function(s) {
        return this._hasDoubles(s) ? this.curve._fixedNafMul(this, s) : this.curve._wnafMul(this, s);
    }, a.prototype.mulAdd = function(s, c, l) {
        return this.curve._wnafMulAdd(1, [
            this,
            c
        ], [
            s,
            l
        ], 2, !1);
    }, a.prototype.jmulAdd = function(s, c, l) {
        return this.curve._wnafMulAdd(1, [
            this,
            c
        ], [
            s,
            l
        ], 2, !0);
    }, a.prototype.normalize = function() {
        if (this.zOne) return this;
        var s = this.z.redInvm();
        return this.x = this.x.redMul(s), this.y = this.y.redMul(s), this.t && (this.t = this.t.redMul(s)), this.z = this.curve.one, this.zOne = !0, this;
    }, a.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, a.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    }, a.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
    }, a.prototype.eq = function(s) {
        return this === s || this.getX().cmp(s.getX()) === 0 && this.getY().cmp(s.getY()) === 0;
    }, a.prototype.eqXToP = function(s) {
        var c = s.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(c) === 0) return !0;
        for(var l = s.clone(), u = this.curve.redN.redMul(this.z);;){
            if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0) return !1;
            if (c.redIAdd(u), this.x.cmp(c) === 0) return !0;
        }
    }, a.prototype.toP = a.prototype.normalize, a.prototype.mixedAdd = a.prototype.add, Mv;
}
var k_;
function UC() {
    return k_ || (k_ = 1, function(e) {
        var t = e;
        t.base = W2(), t.short = LJ(), t.mont = HJ(), t.edwards = KJ();
    }(v_)), v_;
}
var O_ = {}, I_ = {}, cn = {}, B_;
function Ys() {
    if (B_) return cn;
    B_ = 1;
    var e = Ua(), t = Nr();
    cn.inherits = t;
    function r(B, g) {
        return (B.charCodeAt(g) & 64512) !== 55296 || g < 0 || g + 1 >= B.length ? !1 : (B.charCodeAt(g + 1) & 64512) === 56320;
    }
    function n(B, g) {
        if (Array.isArray(B)) return B.slice();
        if (!B) return [];
        var E = [];
        if (typeof B == "string") if (g) {
            if (g === "hex") for(B = B.replace(/[^a-z0-9]+/ig, ""), B.length % 2 !== 0 && (B = "0" + B), _ = 0; _ < B.length; _ += 2)E.push(parseInt(B[_] + B[_ + 1], 16));
        } else for(var w = 0, _ = 0; _ < B.length; _++){
            var O = B.charCodeAt(_);
            O < 128 ? E[w++] = O : O < 2048 ? (E[w++] = O >> 6 | 192, E[w++] = O & 63 | 128) : r(B, _) ? (O = 65536 + ((O & 1023) << 10) + (B.charCodeAt(++_) & 1023), E[w++] = O >> 18 | 240, E[w++] = O >> 12 & 63 | 128, E[w++] = O >> 6 & 63 | 128, E[w++] = O & 63 | 128) : (E[w++] = O >> 12 | 224, E[w++] = O >> 6 & 63 | 128, E[w++] = O & 63 | 128);
        }
        else for(_ = 0; _ < B.length; _++)E[_] = B[_] | 0;
        return E;
    }
    cn.toArray = n;
    function i1(B) {
        for(var g = "", E = 0; E < B.length; E++)g += s(B[E].toString(16));
        return g;
    }
    cn.toHex = i1;
    function o(B) {
        var g = B >>> 24 | B >>> 8 & 65280 | B << 8 & 16711680 | (B & 255) << 24;
        return g >>> 0;
    }
    cn.htonl = o;
    function a(B, g) {
        for(var E = "", w = 0; w < B.length; w++){
            var _ = B[w];
            g === "little" && (_ = o(_)), E += c(_.toString(16));
        }
        return E;
    }
    cn.toHex32 = a;
    function s(B) {
        return B.length === 1 ? "0" + B : B;
    }
    cn.zero2 = s;
    function c(B) {
        return B.length === 7 ? "0" + B : B.length === 6 ? "00" + B : B.length === 5 ? "000" + B : B.length === 4 ? "0000" + B : B.length === 3 ? "00000" + B : B.length === 2 ? "000000" + B : B.length === 1 ? "0000000" + B : B;
    }
    cn.zero8 = c;
    function l(B, g, E, w) {
        var _ = E - g;
        e(_ % 4 === 0);
        for(var O = new Array(_ / 4), I = 0, x = g; I < O.length; I++, x += 4){
            var R;
            w === "big" ? R = B[x] << 24 | B[x + 1] << 16 | B[x + 2] << 8 | B[x + 3] : R = B[x + 3] << 24 | B[x + 2] << 16 | B[x + 1] << 8 | B[x], O[I] = R >>> 0;
        }
        return O;
    }
    cn.join32 = l;
    function u(B, g) {
        for(var E = new Array(B.length * 4), w = 0, _ = 0; w < B.length; w++, _ += 4){
            var O = B[w];
            g === "big" ? (E[_] = O >>> 24, E[_ + 1] = O >>> 16 & 255, E[_ + 2] = O >>> 8 & 255, E[_ + 3] = O & 255) : (E[_ + 3] = O >>> 24, E[_ + 2] = O >>> 16 & 255, E[_ + 1] = O >>> 8 & 255, E[_] = O & 255);
        }
        return E;
    }
    cn.split32 = u;
    function f(B, g) {
        return B >>> g | B << 32 - g;
    }
    cn.rotr32 = f;
    function h(B, g) {
        return B << g | B >>> 32 - g;
    }
    cn.rotl32 = h;
    function y(B, g) {
        return B + g >>> 0;
    }
    cn.sum32 = y;
    function S(B, g, E) {
        return B + g + E >>> 0;
    }
    cn.sum32_3 = S;
    function k(B, g, E, w) {
        return B + g + E + w >>> 0;
    }
    cn.sum32_4 = k;
    function P(B, g, E, w, _) {
        return B + g + E + w + _ >>> 0;
    }
    cn.sum32_5 = P;
    function M(B, g, E, w) {
        var _ = B[g], O = B[g + 1], I = w + O >>> 0, x = (I < w ? 1 : 0) + E + _;
        B[g] = x >>> 0, B[g + 1] = I;
    }
    cn.sum64 = M;
    function N(B, g, E, w) {
        var _ = g + w >>> 0, O = (_ < g ? 1 : 0) + B + E;
        return O >>> 0;
    }
    cn.sum64_hi = N;
    function z(B, g, E, w) {
        var _ = g + w;
        return _ >>> 0;
    }
    cn.sum64_lo = z;
    function K(B, g, E, w, _, O, I, x) {
        var R = 0, j = g;
        j = j + w >>> 0, R += j < g ? 1 : 0, j = j + O >>> 0, R += j < O ? 1 : 0, j = j + x >>> 0, R += j < x ? 1 : 0;
        var Y = B + E + _ + I + R;
        return Y >>> 0;
    }
    cn.sum64_4_hi = K;
    function $(B, g, E, w, _, O, I, x) {
        var R = g + w + O + x;
        return R >>> 0;
    }
    cn.sum64_4_lo = $;
    function ne(B, g, E, w, _, O, I, x, R, j) {
        var Y = 0, he = g;
        he = he + w >>> 0, Y += he < g ? 1 : 0, he = he + O >>> 0, Y += he < O ? 1 : 0, he = he + x >>> 0, Y += he < x ? 1 : 0, he = he + j >>> 0, Y += he < j ? 1 : 0;
        var ue = B + E + _ + I + R + Y;
        return ue >>> 0;
    }
    cn.sum64_5_hi = ne;
    function ee(B, g, E, w, _, O, I, x, R, j) {
        var Y = g + w + O + x + j;
        return Y >>> 0;
    }
    cn.sum64_5_lo = ee;
    function q(B, g, E) {
        var w = g << 32 - E | B >>> E;
        return w >>> 0;
    }
    cn.rotr64_hi = q;
    function U(B, g, E) {
        var w = B << 32 - E | g >>> E;
        return w >>> 0;
    }
    cn.rotr64_lo = U;
    function Q(B, g, E) {
        return B >>> E;
    }
    cn.shr64_hi = Q;
    function v(B, g, E) {
        var w = B << 32 - E | g >>> E;
        return w >>> 0;
    }
    return cn.shr64_lo = v, cn;
}
var Nv = {}, T_;
function v1() {
    if (T_) return Nv;
    T_ = 1;
    var e = Ys(), t = Ua();
    function r() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    return Nv.BlockHash = r, r.prototype.update = function(n, i1) {
        if (n = e.toArray(n, i1), this.pending ? this.pending = this.pending.concat(n) : this.pending = n, this.pendingTotal += n.length, this.pending.length >= this._delta8) {
            n = this.pending;
            var o = n.length % this._delta8;
            this.pending = n.slice(n.length - o, n.length), this.pending.length === 0 && (this.pending = null), n = e.join32(n, 0, n.length - o, this.endian);
            for(var a = 0; a < n.length; a += this._delta32)this._update(n, a, a + this._delta32);
        }
        return this;
    }, r.prototype.digest = function(n) {
        return this.update(this._pad()), t(this.pending === null), this._digest(n);
    }, r.prototype._pad = function() {
        var n = this.pendingTotal, i1 = this._delta8, o = i1 - (n + this.padLength) % i1, a = new Array(o + this.padLength);
        a[0] = 128;
        for(var s = 1; s < o; s++)a[s] = 0;
        if (n <<= 3, this.endian === "big") {
            for(var c = 8; c < this.padLength; c++)a[s++] = 0;
            a[s++] = 0, a[s++] = 0, a[s++] = 0, a[s++] = 0, a[s++] = n >>> 24 & 255, a[s++] = n >>> 16 & 255, a[s++] = n >>> 8 & 255, a[s++] = n & 255;
        } else for(a[s++] = n & 255, a[s++] = n >>> 8 & 255, a[s++] = n >>> 16 & 255, a[s++] = n >>> 24 & 255, a[s++] = 0, a[s++] = 0, a[s++] = 0, a[s++] = 0, c = 8; c < this.padLength; c++)a[s++] = 0;
        return a;
    }, Nv;
}
var dd = {}, As = {}, P_;
function DC() {
    if (P_) return As;
    P_ = 1;
    var e = Ys(), t = e.rotr32;
    function r(u, f, h, y) {
        if (u === 0) return n(f, h, y);
        if (u === 1 || u === 3) return o(f, h, y);
        if (u === 2) return i1(f, h, y);
    }
    As.ft_1 = r;
    function n(u, f, h) {
        return u & f ^ ~u & h;
    }
    As.ch32 = n;
    function i1(u, f, h) {
        return u & f ^ u & h ^ f & h;
    }
    As.maj32 = i1;
    function o(u, f, h) {
        return u ^ f ^ h;
    }
    As.p32 = o;
    function a(u) {
        return t(u, 2) ^ t(u, 13) ^ t(u, 22);
    }
    As.s0_256 = a;
    function s(u) {
        return t(u, 6) ^ t(u, 11) ^ t(u, 25);
    }
    As.s1_256 = s;
    function c(u) {
        return t(u, 7) ^ t(u, 18) ^ u >>> 3;
    }
    As.g0_256 = c;
    function l(u) {
        return t(u, 17) ^ t(u, 19) ^ u >>> 10;
    }
    return As.g1_256 = l, As;
}
var Rv, C_;
function qJ() {
    if (C_) return Rv;
    C_ = 1;
    var e = Ys(), t = v1(), r = DC(), n = e.rotl32, i1 = e.sum32, o = e.sum32_5, a = r.ft_1, s = t.BlockHash, c = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    function l() {
        if (!(this instanceof l)) return new l();
        s.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.W = new Array(80);
    }
    return e.inherits(l, s), Rv = l, l.blockSize = 512, l.outSize = 160, l.hmacStrength = 80, l.padLength = 64, l.prototype._update = function(u, f) {
        for(var h = this.W, y = 0; y < 16; y++)h[y] = u[f + y];
        for(; y < h.length; y++)h[y] = n(h[y - 3] ^ h[y - 8] ^ h[y - 14] ^ h[y - 16], 1);
        var S = this.h[0], k = this.h[1], P = this.h[2], M = this.h[3], N = this.h[4];
        for(y = 0; y < h.length; y++){
            var z = ~~(y / 20), K = o(n(S, 5), a(z, k, P, M), N, h[y], c[z]);
            N = M, M = P, P = n(k, 30), k = S, S = K;
        }
        this.h[0] = i1(this.h[0], S), this.h[1] = i1(this.h[1], k), this.h[2] = i1(this.h[2], P), this.h[3] = i1(this.h[3], M), this.h[4] = i1(this.h[4], N);
    }, l.prototype._digest = function(u) {
        return u === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    }, Rv;
}
var Uv, M_;
function jC() {
    if (M_) return Uv;
    M_ = 1;
    var e = Ys(), t = v1(), r = DC(), n = Ua(), i1 = e.sum32, o = e.sum32_4, a = e.sum32_5, s = r.ch32, c = r.maj32, l = r.s0_256, u = r.s1_256, f = r.g0_256, h = r.g1_256, y = t.BlockHash, S = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ];
    function k() {
        if (!(this instanceof k)) return new k();
        y.call(this), this.h = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
        ], this.k = S, this.W = new Array(64);
    }
    return e.inherits(k, y), Uv = k, k.blockSize = 512, k.outSize = 256, k.hmacStrength = 192, k.padLength = 64, k.prototype._update = function(P, M) {
        for(var N = this.W, z = 0; z < 16; z++)N[z] = P[M + z];
        for(; z < N.length; z++)N[z] = o(h(N[z - 2]), N[z - 7], f(N[z - 15]), N[z - 16]);
        var K = this.h[0], $ = this.h[1], ne = this.h[2], ee = this.h[3], q = this.h[4], U = this.h[5], Q = this.h[6], v = this.h[7];
        for(n(this.k.length === N.length), z = 0; z < N.length; z++){
            var B = a(v, u(q), s(q, U, Q), this.k[z], N[z]), g = i1(l(K), c(K, $, ne));
            v = Q, Q = U, U = q, q = i1(ee, B), ee = ne, ne = $, $ = K, K = i1(B, g);
        }
        this.h[0] = i1(this.h[0], K), this.h[1] = i1(this.h[1], $), this.h[2] = i1(this.h[2], ne), this.h[3] = i1(this.h[3], ee), this.h[4] = i1(this.h[4], q), this.h[5] = i1(this.h[5], U), this.h[6] = i1(this.h[6], Q), this.h[7] = i1(this.h[7], v);
    }, k.prototype._digest = function(P) {
        return P === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    }, Uv;
}
var Dv, N_;
function VJ() {
    if (N_) return Dv;
    N_ = 1;
    var e = Ys(), t = jC();
    function r() {
        if (!(this instanceof r)) return new r();
        t.call(this), this.h = [
            3238371032,
            914150663,
            812702999,
            4144912697,
            4290775857,
            1750603025,
            1694076839,
            3204075428
        ];
    }
    return e.inherits(r, t), Dv = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(n) {
        return n === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
    }, Dv;
}
var jv, R_;
function FC() {
    if (R_) return jv;
    R_ = 1;
    var e = Ys(), t = v1(), r = Ua(), n = e.rotr64_hi, i1 = e.rotr64_lo, o = e.shr64_hi, a = e.shr64_lo, s = e.sum64, c = e.sum64_hi, l = e.sum64_lo, u = e.sum64_4_hi, f = e.sum64_4_lo, h = e.sum64_5_hi, y = e.sum64_5_lo, S = t.BlockHash, k = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ];
    function P() {
        if (!(this instanceof P)) return new P();
        S.call(this), this.h = [
            1779033703,
            4089235720,
            3144134277,
            2227873595,
            1013904242,
            4271175723,
            2773480762,
            1595750129,
            1359893119,
            2917565137,
            2600822924,
            725511199,
            528734635,
            4215389547,
            1541459225,
            327033209
        ], this.k = k, this.W = new Array(160);
    }
    e.inherits(P, S), jv = P, P.blockSize = 1024, P.outSize = 512, P.hmacStrength = 192, P.padLength = 128, P.prototype._prepareBlock = function(g, E) {
        for(var w = this.W, _ = 0; _ < 32; _++)w[_] = g[E + _];
        for(; _ < w.length; _ += 2){
            var O = v(w[_ - 4], w[_ - 3]), I = B(w[_ - 4], w[_ - 3]), x = w[_ - 14], R = w[_ - 13], j = U(w[_ - 30], w[_ - 29]), Y = Q(w[_ - 30], w[_ - 29]), he = w[_ - 32], ue = w[_ - 31];
            w[_] = u(O, I, x, R, j, Y, he, ue), w[_ + 1] = f(O, I, x, R, j, Y, he, ue);
        }
    }, P.prototype._update = function(g, E) {
        this._prepareBlock(g, E);
        var w = this.W, _ = this.h[0], O = this.h[1], I = this.h[2], x = this.h[3], R = this.h[4], j = this.h[5], Y = this.h[6], he = this.h[7], ue = this.h[8], G = this.h[9], se = this.h[10], Z = this.h[11], ie = this.h[12], pe = this.h[13], ve = this.h[14], Ie = this.h[15];
        r(this.k.length === w.length);
        for(var Me = 0; Me < w.length; Me += 2){
            var Re = ve, C = Ie, J = ee(ue, G), me = q(ue, G), je = M(ue, G, se, Z, ie), Ve = N(ue, G, se, Z, ie, pe), nt = this.k[Me], We = this.k[Me + 1], Ge = w[Me], p = w[Me + 1], A = h(Re, C, J, me, je, Ve, nt, We, Ge, p), V = y(Re, C, J, me, je, Ve, nt, We, Ge, p);
            Re = $(_, O), C = ne(_, O), J = z(_, O, I, x, R), me = K(_, O, I, x, R, j);
            var re = c(Re, C, J, me), le = l(Re, C, J, me);
            ve = ie, Ie = pe, ie = se, pe = Z, se = ue, Z = G, ue = c(Y, he, A, V), G = l(he, he, A, V), Y = R, he = j, R = I, j = x, I = _, x = O, _ = c(A, V, re, le), O = l(A, V, re, le);
        }
        s(this.h, 0, _, O), s(this.h, 2, I, x), s(this.h, 4, R, j), s(this.h, 6, Y, he), s(this.h, 8, ue, G), s(this.h, 10, se, Z), s(this.h, 12, ie, pe), s(this.h, 14, ve, Ie);
    }, P.prototype._digest = function(g) {
        return g === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
    };
    function M(g, E, w, _, O) {
        var I = g & w ^ ~g & O;
        return I < 0 && (I += 4294967296), I;
    }
    function N(g, E, w, _, O, I) {
        var x = E & _ ^ ~E & I;
        return x < 0 && (x += 4294967296), x;
    }
    function z(g, E, w, _, O) {
        var I = g & w ^ g & O ^ w & O;
        return I < 0 && (I += 4294967296), I;
    }
    function K(g, E, w, _, O, I) {
        var x = E & _ ^ E & I ^ _ & I;
        return x < 0 && (x += 4294967296), x;
    }
    function $(g, E) {
        var w = n(g, E, 28), _ = n(E, g, 2), O = n(E, g, 7), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function ne(g, E) {
        var w = i1(g, E, 28), _ = i1(E, g, 2), O = i1(E, g, 7), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function ee(g, E) {
        var w = n(g, E, 14), _ = n(g, E, 18), O = n(E, g, 9), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function q(g, E) {
        var w = i1(g, E, 14), _ = i1(g, E, 18), O = i1(E, g, 9), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function U(g, E) {
        var w = n(g, E, 1), _ = n(g, E, 8), O = o(g, E, 7), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function Q(g, E) {
        var w = i1(g, E, 1), _ = i1(g, E, 8), O = a(g, E, 7), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function v(g, E) {
        var w = n(g, E, 19), _ = n(E, g, 29), O = o(g, E, 6), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    function B(g, E) {
        var w = i1(g, E, 19), _ = i1(E, g, 29), O = a(g, E, 6), I = w ^ _ ^ O;
        return I < 0 && (I += 4294967296), I;
    }
    return jv;
}
var Fv, U_;
function WJ() {
    if (U_) return Fv;
    U_ = 1;
    var e = Ys(), t = FC();
    function r() {
        if (!(this instanceof r)) return new r();
        t.call(this), this.h = [
            3418070365,
            3238371032,
            1654270250,
            914150663,
            2438529370,
            812702999,
            355462360,
            4144912697,
            1731405415,
            4290775857,
            2394180231,
            1750603025,
            3675008525,
            1694076839,
            1203062813,
            3204075428
        ];
    }
    return e.inherits(r, t), Fv = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(n) {
        return n === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
    }, Fv;
}
var D_;
function GJ() {
    return D_ || (D_ = 1, dd.sha1 = qJ(), dd.sha224 = VJ(), dd.sha256 = jC(), dd.sha384 = WJ(), dd.sha512 = FC()), dd;
}
var zv = {}, j_;
function QJ() {
    if (j_) return zv;
    j_ = 1;
    var e = Ys(), t = v1(), r = e.rotl32, n = e.sum32, i1 = e.sum32_3, o = e.sum32_4, a = t.BlockHash;
    function s() {
        if (!(this instanceof s)) return new s();
        a.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.endian = "little";
    }
    e.inherits(s, a), zv.ripemd160 = s, s.blockSize = 512, s.outSize = 160, s.hmacStrength = 192, s.padLength = 64, s.prototype._update = function(k, P) {
        for(var M = this.h[0], N = this.h[1], z = this.h[2], K = this.h[3], $ = this.h[4], ne = M, ee = N, q = z, U = K, Q = $, v = 0; v < 80; v++){
            var B = n(r(o(M, c(v, N, z, K), k[f[v] + P], l(v)), y[v]), $);
            M = $, $ = K, K = r(z, 10), z = N, N = B, B = n(r(o(ne, c(79 - v, ee, q, U), k[h[v] + P], u(v)), S[v]), Q), ne = Q, Q = U, U = r(q, 10), q = ee, ee = B;
        }
        B = i1(this.h[1], z, U), this.h[1] = i1(this.h[2], K, Q), this.h[2] = i1(this.h[3], $, ne), this.h[3] = i1(this.h[4], M, ee), this.h[4] = i1(this.h[0], N, q), this.h[0] = B;
    }, s.prototype._digest = function(k) {
        return k === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
    };
    function c(k, P, M, N) {
        return k <= 15 ? P ^ M ^ N : k <= 31 ? P & M | ~P & N : k <= 47 ? (P | ~M) ^ N : k <= 63 ? P & N | M & ~N : P ^ (M | ~N);
    }
    function l(k) {
        return k <= 15 ? 0 : k <= 31 ? 1518500249 : k <= 47 ? 1859775393 : k <= 63 ? 2400959708 : 2840853838;
    }
    function u(k) {
        return k <= 15 ? 1352829926 : k <= 31 ? 1548603684 : k <= 47 ? 1836072691 : k <= 63 ? 2053994217 : 0;
    }
    var f = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], h = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], y = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], S = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ];
    return zv;
}
var Lv, F_;
function $J() {
    if (F_) return Lv;
    F_ = 1;
    var e = Ys(), t = Ua();
    function r(n, i1, o) {
        if (!(this instanceof r)) return new r(n, i1, o);
        this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(i1, o));
    }
    return Lv = r, r.prototype._init = function(n) {
        n.length > this.blockSize && (n = new this.Hash().update(n).digest()), t(n.length <= this.blockSize);
        for(var i1 = n.length; i1 < this.blockSize; i1++)n.push(0);
        for(i1 = 0; i1 < n.length; i1++)n[i1] ^= 54;
        for(this.inner = new this.Hash().update(n), i1 = 0; i1 < n.length; i1++)n[i1] ^= 106;
        this.outer = new this.Hash().update(n);
    }, r.prototype.update = function(n, i1) {
        return this.inner.update(n, i1), this;
    }, r.prototype.digest = function(n) {
        return this.outer.update(this.inner.digest()), this.outer.digest(n);
    }, Lv;
}
var z_;
function t5() {
    return z_ || (z_ = 1, function(e) {
        var t = e;
        t.utils = Ys(), t.common = v1(), t.sha = GJ(), t.ripemd = QJ(), t.hmac = $J(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
    }(I_)), I_;
}
var L_, H_;
function ZJ() {
    return H_ || (H_ = 1, L_ = {
        doubles: {
            step: 4,
            points: [
                [
                    "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                    "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
                ],
                [
                    "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                    "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
                ],
                [
                    "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                    "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
                ],
                [
                    "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                    "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
                ],
                [
                    "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                    "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
                ],
                [
                    "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                    "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
                ],
                [
                    "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                    "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
                ],
                [
                    "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                    "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
                ],
                [
                    "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                    "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
                ],
                [
                    "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                    "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
                ],
                [
                    "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                    "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
                ],
                [
                    "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                    "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
                ],
                [
                    "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                    "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
                ],
                [
                    "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                    "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
                ],
                [
                    "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                    "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
                ],
                [
                    "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                    "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
                ],
                [
                    "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                    "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
                ],
                [
                    "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                    "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
                ],
                [
                    "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                    "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
                ],
                [
                    "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                    "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
                ],
                [
                    "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                    "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
                ],
                [
                    "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                    "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
                ],
                [
                    "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                    "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
                ],
                [
                    "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                    "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
                ],
                [
                    "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                    "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
                ],
                [
                    "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                    "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
                ],
                [
                    "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                    "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
                ],
                [
                    "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                    "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
                ],
                [
                    "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                    "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
                ],
                [
                    "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                    "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
                ],
                [
                    "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                    "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
                ],
                [
                    "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                    "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
                ],
                [
                    "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                    "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
                ],
                [
                    "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                    "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
                ],
                [
                    "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                    "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
                ],
                [
                    "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                    "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
                ],
                [
                    "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                    "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
                ],
                [
                    "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                    "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
                ],
                [
                    "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                    "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
                ],
                [
                    "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                    "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
                ],
                [
                    "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                    "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
                ],
                [
                    "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                    "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
                ],
                [
                    "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                    "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
                ],
                [
                    "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                    "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
                ],
                [
                    "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                    "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
                ],
                [
                    "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                    "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
                ],
                [
                    "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                    "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
                ],
                [
                    "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                    "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
                ],
                [
                    "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                    "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
                ],
                [
                    "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                    "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
                ],
                [
                    "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                    "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
                ],
                [
                    "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                    "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
                ],
                [
                    "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                    "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
                ],
                [
                    "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                    "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
                ],
                [
                    "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                    "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
                ],
                [
                    "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                    "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
                ],
                [
                    "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                    "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
                ],
                [
                    "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                    "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
                ],
                [
                    "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                    "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
                ],
                [
                    "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                    "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
                ],
                [
                    "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                    "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
                ],
                [
                    "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                    "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
                ],
                [
                    "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                    "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
                ],
                [
                    "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                    "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
                ],
                [
                    "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                    "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
                ]
            ]
        },
        naf: {
            wnd: 7,
            points: [
                [
                    "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                    "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
                ],
                [
                    "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                    "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
                ],
                [
                    "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                    "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
                ],
                [
                    "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                    "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
                ],
                [
                    "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                    "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
                ],
                [
                    "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                    "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
                ],
                [
                    "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                    "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
                ],
                [
                    "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                    "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
                ],
                [
                    "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                    "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
                ],
                [
                    "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                    "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
                ],
                [
                    "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                    "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
                ],
                [
                    "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                    "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
                ],
                [
                    "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                    "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
                ],
                [
                    "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                    "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
                ],
                [
                    "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                    "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
                ],
                [
                    "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                    "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
                ],
                [
                    "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                    "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
                ],
                [
                    "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                    "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
                ],
                [
                    "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                    "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
                ],
                [
                    "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                    "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
                ],
                [
                    "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                    "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
                ],
                [
                    "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                    "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
                ],
                [
                    "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                    "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
                ],
                [
                    "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                    "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
                ],
                [
                    "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                    "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
                ],
                [
                    "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                    "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
                ],
                [
                    "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                    "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
                ],
                [
                    "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                    "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
                ],
                [
                    "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                    "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
                ],
                [
                    "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                    "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
                ],
                [
                    "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                    "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
                ],
                [
                    "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                    "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
                ],
                [
                    "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                    "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
                ],
                [
                    "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                    "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
                ],
                [
                    "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                    "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
                ],
                [
                    "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                    "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
                ],
                [
                    "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                    "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
                ],
                [
                    "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                    "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
                ],
                [
                    "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                    "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
                ],
                [
                    "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                    "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
                ],
                [
                    "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                    "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
                ],
                [
                    "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                    "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
                ],
                [
                    "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                    "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
                ],
                [
                    "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                    "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
                ],
                [
                    "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                    "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
                ],
                [
                    "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                    "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
                ],
                [
                    "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                    "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
                ],
                [
                    "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                    "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
                ],
                [
                    "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                    "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
                ],
                [
                    "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                    "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
                ],
                [
                    "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                    "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
                ],
                [
                    "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                    "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
                ],
                [
                    "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                    "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
                ],
                [
                    "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                    "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
                ],
                [
                    "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                    "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
                ],
                [
                    "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                    "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
                ],
                [
                    "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                    "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
                ],
                [
                    "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                    "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
                ],
                [
                    "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                    "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
                ],
                [
                    "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                    "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
                ],
                [
                    "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                    "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
                ],
                [
                    "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                    "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
                ],
                [
                    "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                    "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
                ],
                [
                    "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                    "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
                ],
                [
                    "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                    "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
                ],
                [
                    "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                    "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
                ],
                [
                    "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                    "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
                ],
                [
                    "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                    "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
                ],
                [
                    "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                    "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
                ],
                [
                    "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                    "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
                ],
                [
                    "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                    "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
                ],
                [
                    "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                    "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
                ],
                [
                    "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                    "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
                ],
                [
                    "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                    "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
                ],
                [
                    "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                    "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
                ],
                [
                    "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                    "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
                ],
                [
                    "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                    "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
                ],
                [
                    "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                    "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
                ],
                [
                    "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                    "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
                ],
                [
                    "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                    "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
                ],
                [
                    "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                    "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
                ],
                [
                    "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                    "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
                ],
                [
                    "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                    "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
                ],
                [
                    "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                    "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
                ],
                [
                    "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                    "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
                ],
                [
                    "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                    "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
                ],
                [
                    "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                    "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
                ],
                [
                    "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                    "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
                ],
                [
                    "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                    "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
                ],
                [
                    "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                    "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
                ],
                [
                    "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                    "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
                ],
                [
                    "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                    "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
                ],
                [
                    "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                    "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
                ],
                [
                    "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                    "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
                ],
                [
                    "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                    "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
                ],
                [
                    "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                    "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
                ],
                [
                    "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                    "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
                ],
                [
                    "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                    "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
                ],
                [
                    "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                    "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
                ],
                [
                    "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                    "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
                ],
                [
                    "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                    "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
                ],
                [
                    "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                    "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
                ],
                [
                    "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                    "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
                ],
                [
                    "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                    "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
                ],
                [
                    "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                    "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
                ],
                [
                    "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                    "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
                ],
                [
                    "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                    "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
                ],
                [
                    "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                    "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
                ],
                [
                    "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                    "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
                ],
                [
                    "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                    "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
                ],
                [
                    "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                    "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
                ],
                [
                    "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                    "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
                ],
                [
                    "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                    "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
                ],
                [
                    "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                    "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
                ],
                [
                    "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                    "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
                ],
                [
                    "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                    "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
                ],
                [
                    "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                    "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
                ],
                [
                    "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                    "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
                ],
                [
                    "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                    "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
                ],
                [
                    "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                    "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
                ],
                [
                    "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                    "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
                ],
                [
                    "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                    "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
                ],
                [
                    "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                    "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
                ],
                [
                    "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                    "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
                ],
                [
                    "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                    "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
                ],
                [
                    "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                    "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
                ],
                [
                    "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                    "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
                ]
            ]
        }
    }), L_;
}
var K_;
function r5() {
    return K_ || (K_ = 1, function(e) {
        var t = e, r = t5(), n = UC(), i1 = Da(), o = i1.assert;
        function a(l) {
            l.type === "short" ? this.curve = new n.short(l) : l.type === "edwards" ? this.curve = new n.edwards(l) : this.curve = new n.mont(l), this.g = this.curve.g, this.n = this.curve.n, this.hash = l.hash, o(this.g.validate(), "Invalid curve"), o(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        t.PresetCurve = a;
        function s(l, u) {
            Object.defineProperty(t, l, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var f = new a(u);
                    return Object.defineProperty(t, l, {
                        configurable: !0,
                        enumerable: !0,
                        value: f
                    }), f;
                }
            });
        }
        s("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: r.sha256,
            gRed: !1,
            g: [
                "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
                "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
            ]
        }), s("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: r.sha256,
            gRed: !1,
            g: [
                "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
                "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
            ]
        }), s("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: r.sha256,
            gRed: !1,
            g: [
                "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
                "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
            ]
        }), s("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: r.sha384,
            gRed: !1,
            g: [
                "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
            ]
        }), s("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: r.sha512,
            gRed: !1,
            g: [
                "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
            ]
        }), s("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: r.sha256,
            gRed: !1,
            g: [
                "9"
            ]
        }), s("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            // -121665 * (121666^(-1)) (mod P)
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: r.sha256,
            gRed: !1,
            g: [
                "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
                // 4/5
                "6666666666666666666666666666666666666666666666666666666666666658"
            ]
        });
        var c;
        try {
            c = ZJ();
        } catch  {
            c = void 0;
        }
        s("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: r.sha256,
            // Precomputed endomorphism
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                {
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                },
                {
                    a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                    b: "3086d221a7d46bcde86c90e49284eb15"
                }
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                c
            ]
        });
    }(O_)), O_;
}
var Hv, q_;
function XJ() {
    if (q_) return Hv;
    q_ = 1;
    var e = t5(), t = RC(), r = Ua();
    function n(i1) {
        if (!(this instanceof n)) return new n(i1);
        this.hash = i1.hash, this.predResist = !!i1.predResist, this.outLen = this.hash.outSize, this.minEntropy = i1.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var o = t.toArray(i1.entropy, i1.entropyEnc || "hex"), a = t.toArray(i1.nonce, i1.nonceEnc || "hex"), s = t.toArray(i1.pers, i1.persEnc || "hex");
        r(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(o, a, s);
    }
    return Hv = n, n.prototype._init = function(i1, o, a) {
        var s = i1.concat(o).concat(a);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for(var c = 0; c < this.V.length; c++)this.K[c] = 0, this.V[c] = 1;
        this._update(s), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, n.prototype._hmac = function() {
        return new e.hmac(this.hash, this.K);
    }, n.prototype._update = function(i1) {
        var o = this._hmac().update(this.V).update([
            0
        ]);
        i1 && (o = o.update(i1)), this.K = o.digest(), this.V = this._hmac().update(this.V).digest(), i1 && (this.K = this._hmac().update(this.V).update([
            1
        ]).update(i1).digest(), this.V = this._hmac().update(this.V).digest());
    }, n.prototype.reseed = function(i1, o, a, s) {
        typeof o != "string" && (s = a, a = o, o = null), i1 = t.toArray(i1, o), a = t.toArray(a, s), r(i1.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(i1.concat(a || [])), this._reseed = 1;
    }, n.prototype.generate = function(i1, o, a, s) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        typeof o != "string" && (s = a, a = o, o = null), a && (a = t.toArray(a, s || "hex"), this._update(a));
        for(var c = []; c.length < i1;)this.V = this._hmac().update(this.V).digest(), c = c.concat(this.V);
        var l = c.slice(0, i1);
        return this._update(a), this._reseed++, t.encode(l, o);
    }, Hv;
}
var Kv, V_;
function YJ() {
    if (V_) return Kv;
    V_ = 1;
    var e = Bi(), t = Da(), r = t.assert;
    function n(i1, o) {
        this.ec = i1, this.priv = null, this.pub = null, o.priv && this._importPrivate(o.priv, o.privEnc), o.pub && this._importPublic(o.pub, o.pubEnc);
    }
    return Kv = n, n.fromPublic = function(i1, o, a) {
        return o instanceof n ? o : new n(i1, {
            pub: o,
            pubEnc: a
        });
    }, n.fromPrivate = function(i1, o, a) {
        return o instanceof n ? o : new n(i1, {
            priv: o,
            privEnc: a
        });
    }, n.prototype.validate = function() {
        var i1 = this.getPublic();
        return i1.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : i1.validate() ? i1.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        };
    }, n.prototype.getPublic = function(i1, o) {
        return typeof i1 == "string" && (o = i1, i1 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), o ? this.pub.encode(o, i1) : this.pub;
    }, n.prototype.getPrivate = function(i1) {
        return i1 === "hex" ? this.priv.toString(16, 2) : this.priv;
    }, n.prototype._importPrivate = function(i1, o) {
        this.priv = new e(i1, o || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, n.prototype._importPublic = function(i1, o) {
        if (i1.x || i1.y) {
            this.ec.curve.type === "mont" ? r(i1.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && r(i1.x && i1.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(i1.x, i1.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(i1, o);
    }, n.prototype.derive = function(i1) {
        return i1.validate() || r(i1.validate(), "public point not validated"), i1.mul(this.priv).getX();
    }, n.prototype.sign = function(i1, o, a) {
        return this.ec.sign(i1, this, o, a);
    }, n.prototype.verify = function(i1, o, a) {
        return this.ec.verify(i1, o, this, void 0, a);
    }, n.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    }, Kv;
}
var qv, W_;
function JJ() {
    if (W_) return qv;
    W_ = 1;
    var e = Bi(), t = Da(), r = t.assert;
    function n(c, l) {
        if (c instanceof n) return c;
        this._importDER(c, l) || (r(c.r && c.s, "Signature without r or s"), this.r = new e(c.r, 16), this.s = new e(c.s, 16), c.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = c.recoveryParam);
    }
    qv = n;
    function i1() {
        this.place = 0;
    }
    function o(c, l) {
        var u = c[l.place++];
        if (!(u & 128)) return u;
        var f = u & 15;
        if (f === 0 || f > 4 || c[l.place] === 0) return !1;
        for(var h = 0, y = 0, S = l.place; y < f; y++, S++)h <<= 8, h |= c[S], h >>>= 0;
        return h <= 127 ? !1 : (l.place = S, h);
    }
    function a(c) {
        for(var l = 0, u = c.length - 1; !c[l] && !(c[l + 1] & 128) && l < u;)l++;
        return l === 0 ? c : c.slice(l);
    }
    n.prototype._importDER = function(c, l) {
        c = t.toArray(c, l);
        var u = new i1();
        if (c[u.place++] !== 48) return !1;
        var f = o(c, u);
        if (f === !1 || f + u.place !== c.length || c[u.place++] !== 2) return !1;
        var h = o(c, u);
        if (h === !1 || c[u.place] & 128) return !1;
        var y = c.slice(u.place, h + u.place);
        if (u.place += h, c[u.place++] !== 2) return !1;
        var S = o(c, u);
        if (S === !1 || c.length !== S + u.place || c[u.place] & 128) return !1;
        var k = c.slice(u.place, S + u.place);
        if (y[0] === 0) if (y[1] & 128) y = y.slice(1);
        else return !1;
        if (k[0] === 0) if (k[1] & 128) k = k.slice(1);
        else return !1;
        return this.r = new e(y), this.s = new e(k), this.recoveryParam = null, !0;
    };
    function s(c, l) {
        if (l < 128) {
            c.push(l);
            return;
        }
        var u = 1 + (Math.log(l) / Math.LN2 >>> 3);
        for(c.push(u | 128); --u;)c.push(l >>> (u << 3) & 255);
        c.push(l);
    }
    return n.prototype.toDER = function(c) {
        var l = this.r.toArray(), u = this.s.toArray();
        for(l[0] & 128 && (l = [
            0
        ].concat(l)), u[0] & 128 && (u = [
            0
        ].concat(u)), l = a(l), u = a(u); !u[0] && !(u[1] & 128);)u = u.slice(1);
        var f = [
            2
        ];
        s(f, l.length), f = f.concat(l), f.push(2), s(f, u.length);
        var h = f.concat(u), y = [
            48
        ];
        return s(y, h.length), y = y.concat(h), t.encode(y, c);
    }, qv;
}
var Vv, G_;
function eee() {
    if (G_) return Vv;
    G_ = 1;
    var e = Bi(), t = XJ(), r = Da(), n = r5(), i1 = Y6(), o = r.assert, a = YJ(), s = JJ();
    function c(l) {
        if (!(this instanceof c)) return new c(l);
        typeof l == "string" && (o(Object.prototype.hasOwnProperty.call(n, l), "Unknown curve " + l), l = n[l]), l instanceof n.PresetCurve && (l = {
            curve: l
        }), this.curve = l.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = l.curve.g, this.g.precompute(l.curve.n.bitLength() + 1), this.hash = l.hash || l.curve.hash;
    }
    return Vv = c, c.prototype.keyPair = function(l) {
        return new a(this, l);
    }, c.prototype.keyFromPrivate = function(l, u) {
        return a.fromPrivate(this, l, u);
    }, c.prototype.keyFromPublic = function(l, u) {
        return a.fromPublic(this, l, u);
    }, c.prototype.genKeyPair = function(l) {
        l || (l = {});
        for(var u = new t({
            hash: this.hash,
            pers: l.pers,
            persEnc: l.persEnc || "utf8",
            entropy: l.entropy || i1(this.hash.hmacStrength),
            entropyEnc: l.entropy && l.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), f = this.n.byteLength(), h = this.n.sub(new e(2));;){
            var y = new e(u.generate(f));
            if (!(y.cmp(h) > 0)) return y.iaddn(1), this.keyFromPrivate(y);
        }
    }, c.prototype._truncateToN = function(l, u, f) {
        var h;
        if (e.isBN(l) || typeof l == "number") l = new e(l, 16), h = l.byteLength();
        else if (typeof l == "object") h = l.length, l = new e(l, 16);
        else {
            var y = l.toString();
            h = y.length + 1 >>> 1, l = new e(y, 16);
        }
        typeof f != "number" && (f = h * 8);
        var S = f - this.n.bitLength();
        return S > 0 && (l = l.ushrn(S)), !u && l.cmp(this.n) >= 0 ? l.sub(this.n) : l;
    }, c.prototype.sign = function(l, u, f, h) {
        if (typeof f == "object" && (h = f, f = null), h || (h = {}), typeof l != "string" && typeof l != "number" && !e.isBN(l)) {
            o(typeof l == "object" && l && typeof l.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), o(l.length >>> 0 === l.length);
            for(var y = 0; y < l.length; y++)o((l[y] & 255) === l[y]);
        }
        u = this.keyFromPrivate(u, f), l = this._truncateToN(l, !1, h.msgBitLength), o(!l.isNeg(), "Can not sign a negative message");
        var S = this.n.byteLength(), k = u.getPrivate().toArray("be", S), P = l.toArray("be", S);
        o(new e(P).eq(l), "Can not sign message");
        for(var M = new t({
            hash: this.hash,
            entropy: k,
            nonce: P,
            pers: h.pers,
            persEnc: h.persEnc || "utf8"
        }), N = this.n.sub(new e(1)), z = 0;; z++){
            var K = h.k ? h.k(z) : new e(M.generate(this.n.byteLength()));
            if (K = this._truncateToN(K, !0), !(K.cmpn(1) <= 0 || K.cmp(N) >= 0)) {
                var $ = this.g.mul(K);
                if (!$.isInfinity()) {
                    var ne = $.getX(), ee = ne.umod(this.n);
                    if (ee.cmpn(0) !== 0) {
                        var q = K.invm(this.n).mul(ee.mul(u.getPrivate()).iadd(l));
                        if (q = q.umod(this.n), q.cmpn(0) !== 0) {
                            var U = ($.getY().isOdd() ? 1 : 0) | (ne.cmp(ee) !== 0 ? 2 : 0);
                            return h.canonical && q.cmp(this.nh) > 0 && (q = this.n.sub(q), U ^= 1), new s({
                                r: ee,
                                s: q,
                                recoveryParam: U
                            });
                        }
                    }
                }
            }
        }
    }, c.prototype.verify = function(l, u, f, h, y) {
        y || (y = {}), l = this._truncateToN(l, !1, y.msgBitLength), f = this.keyFromPublic(f, h), u = new s(u, "hex");
        var S = u.r, k = u.s;
        if (S.cmpn(1) < 0 || S.cmp(this.n) >= 0 || k.cmpn(1) < 0 || k.cmp(this.n) >= 0) return !1;
        var P = k.invm(this.n), M = P.mul(l).umod(this.n), N = P.mul(S).umod(this.n), z;
        return this.curve._maxwellTrick ? (z = this.g.jmulAdd(M, f.getPublic(), N), z.isInfinity() ? !1 : z.eqXToP(S)) : (z = this.g.mulAdd(M, f.getPublic(), N), z.isInfinity() ? !1 : z.getX().umod(this.n).cmp(S) === 0);
    }, c.prototype.recoverPubKey = function(l, u, f, h) {
        o((3 & f) === f, "The recovery param is more than two bits"), u = new s(u, h);
        var y = this.n, S = new e(l), k = u.r, P = u.s, M = f & 1, N = f >> 1;
        if (k.cmp(this.curve.p.umod(this.curve.n)) >= 0 && N) throw new Error("Unable to find sencond key candinate");
        N ? k = this.curve.pointFromX(k.add(this.curve.n), M) : k = this.curve.pointFromX(k, M);
        var z = u.r.invm(y), K = y.sub(S).mul(z).umod(y), $ = P.mul(z).umod(y);
        return this.g.mulAdd(K, k, $);
    }, c.prototype.getKeyRecoveryParam = function(l, u, f, h) {
        if (u = new s(u, h), u.recoveryParam !== null) return u.recoveryParam;
        for(var y = 0; y < 4; y++){
            var S;
            try {
                S = this.recoverPubKey(l, u, y);
            } catch  {
                continue;
            }
            if (S.eq(f)) return y;
        }
        throw new Error("Unable to find valid recovery factor");
    }, Vv;
}
var Wv, Q_;
function tee() {
    if (Q_) return Wv;
    Q_ = 1;
    var e = Da(), t = e.assert, r = e.parseBytes, n = e.cachedProperty;
    function i1(o, a) {
        this.eddsa = o, this._secret = r(a.secret), o.isPoint(a.pub) ? this._pub = a.pub : this._pubBytes = r(a.pub);
    }
    return i1.fromPublic = function(o, a) {
        return a instanceof i1 ? a : new i1(o, {
            pub: a
        });
    }, i1.fromSecret = function(o, a) {
        return a instanceof i1 ? a : new i1(o, {
            secret: a
        });
    }, i1.prototype.secret = function() {
        return this._secret;
    }, n(i1, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
    }), n(i1, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    }), n(i1, "privBytes", function() {
        var o = this.eddsa, a = this.hash(), s = o.encodingLength - 1, c = a.slice(0, o.encodingLength);
        return c[0] &= 248, c[s] &= 127, c[s] |= 64, c;
    }), n(i1, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
    }), n(i1, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
    }), n(i1, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
    }), i1.prototype.sign = function(o) {
        return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(o, this);
    }, i1.prototype.verify = function(o, a) {
        return this.eddsa.verify(o, a, this);
    }, i1.prototype.getSecret = function(o) {
        return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), o);
    }, i1.prototype.getPublic = function(o) {
        return e.encode(this.pubBytes(), o);
    }, Wv = i1, Wv;
}
var Gv, $_;
function ree() {
    if ($_) return Gv;
    $_ = 1;
    var e = Bi(), t = Da(), r = t.assert, n = t.cachedProperty, i1 = t.parseBytes;
    function o(a, s) {
        this.eddsa = a, typeof s != "object" && (s = i1(s)), Array.isArray(s) && (r(s.length === a.encodingLength * 2, "Signature has invalid size"), s = {
            R: s.slice(0, a.encodingLength),
            S: s.slice(a.encodingLength)
        }), r(s.R && s.S, "Signature without R or S"), a.isPoint(s.R) && (this._R = s.R), s.S instanceof e && (this._S = s.S), this._Rencoded = Array.isArray(s.R) ? s.R : s.Rencoded, this._Sencoded = Array.isArray(s.S) ? s.S : s.Sencoded;
    }
    return n(o, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
    }), n(o, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
    }), n(o, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
    }), n(o, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
    }), o.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
    }, o.prototype.toHex = function() {
        return t.encode(this.toBytes(), "hex").toUpperCase();
    }, Gv = o, Gv;
}
var Qv, Z_;
function nee() {
    if (Z_) return Qv;
    Z_ = 1;
    var e = t5(), t = r5(), r = Da(), n = r.assert, i1 = r.parseBytes, o = tee(), a = ree();
    function s(c) {
        if (n(c === "ed25519", "only tested with ed25519 so far"), !(this instanceof s)) return new s(c);
        c = t[c].curve, this.curve = c, this.g = c.g, this.g.precompute(c.n.bitLength() + 1), this.pointClass = c.point().constructor, this.encodingLength = Math.ceil(c.n.bitLength() / 8), this.hash = e.sha512;
    }
    return Qv = s, s.prototype.sign = function(c, l) {
        c = i1(c);
        var u = this.keyFromSecret(l), f = this.hashInt(u.messagePrefix(), c), h = this.g.mul(f), y = this.encodePoint(h), S = this.hashInt(y, u.pubBytes(), c).mul(u.priv()), k = f.add(S).umod(this.curve.n);
        return this.makeSignature({
            R: h,
            S: k,
            Rencoded: y
        });
    }, s.prototype.verify = function(c, l, u) {
        if (c = i1(c), l = this.makeSignature(l), l.S().gte(l.eddsa.curve.n) || l.S().isNeg()) return !1;
        var f = this.keyFromPublic(u), h = this.hashInt(l.Rencoded(), f.pubBytes(), c), y = this.g.mul(l.S()), S = l.R().add(f.pub().mul(h));
        return S.eq(y);
    }, s.prototype.hashInt = function() {
        for(var c = this.hash(), l = 0; l < arguments.length; l++)c.update(arguments[l]);
        return r.intFromLE(c.digest()).umod(this.curve.n);
    }, s.prototype.keyFromPublic = function(c) {
        return o.fromPublic(this, c);
    }, s.prototype.keyFromSecret = function(c) {
        return o.fromSecret(this, c);
    }, s.prototype.makeSignature = function(c) {
        return c instanceof a ? c : new a(this, c);
    }, s.prototype.encodePoint = function(c) {
        var l = c.getY().toArray("le", this.encodingLength);
        return l[this.encodingLength - 1] |= c.getX().isOdd() ? 128 : 0, l;
    }, s.prototype.decodePoint = function(c) {
        c = r.parseBytes(c);
        var l = c.length - 1, u = c.slice(0, l).concat(c[l] & -129), f = (c[l] & 128) !== 0, h = r.intFromLE(u);
        return this.curve.pointFromY(h, f);
    }, s.prototype.encodeInt = function(c) {
        return c.toArray("le", this.encodingLength);
    }, s.prototype.decodeInt = function(c) {
        return r.intFromLE(c);
    }, s.prototype.isPoint = function(c) {
        return c instanceof this.pointClass;
    }, Qv;
}
var X_;
function n5() {
    return X_ || (X_ = 1, function(e) {
        var t = e;
        t.version = zJ.version, t.utils = Da(), t.rand = Y6(), t.curve = UC(), t.curves = r5(), t.ec = eee(), t.eddsa = nee();
    }(y_)), y_;
}
var pa = {}, Y_ = {}, J_ = {}, ek;
function iee() {
    return ek || (ek = 1, function(e) {
        var t = E1(), r = Nr(), n = e;
        n.define = function(o, a) {
            return new i1(o, a);
        };
        function i1(o, a) {
            this.name = o, this.body = a, this.decoders = {}, this.encoders = {};
        }
        i1.prototype._createNamed = function(o) {
            var a;
            try {
                a = cl.runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
            } catch  {
                a = function(s) {
                    this._initNamed(s);
                };
            }
            return r(a, o), a.prototype._initNamed = function(s) {
                o.call(this, s);
            }, new a(this);
        }, i1.prototype._getDecoder = function(o) {
            return o = o || "der", this.decoders.hasOwnProperty(o) || (this.decoders[o] = this._createNamed(t.decoders[o])), this.decoders[o];
        }, i1.prototype.decode = function(o, a, s) {
            return this._getDecoder(a).decode(o, s);
        }, i1.prototype._getEncoder = function(o) {
            return o = o || "der", this.encoders.hasOwnProperty(o) || (this.encoders[o] = this._createNamed(t.encoders[o])), this.encoders[o];
        }, i1.prototype.encode = function(o, a, s) {
            return this._getEncoder(a).encode(o, s);
        };
    }(J_)), J_;
}
var tk = {}, $v = {}, rk;
function oee() {
    if (rk) return $v;
    rk = 1;
    var e = Nr();
    function t(n) {
        this._reporterState = {
            obj: null,
            path: [],
            options: n || {},
            errors: []
        };
    }
    $v.Reporter = t, t.prototype.isError = function(n) {
        return n instanceof r;
    }, t.prototype.save = function() {
        var n = this._reporterState;
        return {
            obj: n.obj,
            pathLen: n.path.length
        };
    }, t.prototype.restore = function(n) {
        var i1 = this._reporterState;
        i1.obj = n.obj, i1.path = i1.path.slice(0, n.pathLen);
    }, t.prototype.enterKey = function(n) {
        return this._reporterState.path.push(n);
    }, t.prototype.exitKey = function(n) {
        var i1 = this._reporterState;
        i1.path = i1.path.slice(0, n - 1);
    }, t.prototype.leaveKey = function(n, i1, o) {
        var a = this._reporterState;
        this.exitKey(n), a.obj !== null && (a.obj[i1] = o);
    }, t.prototype.path = function() {
        return this._reporterState.path.join("/");
    }, t.prototype.enterObject = function() {
        var n = this._reporterState, i1 = n.obj;
        return n.obj = {}, i1;
    }, t.prototype.leaveObject = function(n) {
        var i1 = this._reporterState, o = i1.obj;
        return i1.obj = n, o;
    }, t.prototype.error = function(n) {
        var i1, o = this._reporterState, a = n instanceof r;
        if (a ? i1 = n : i1 = new r(o.path.map(function(s) {
            return "[" + JSON.stringify(s) + "]";
        }).join(""), n.message || n, n.stack), !o.options.partial) throw i1;
        return a || o.errors.push(i1), i1;
    }, t.prototype.wrapResult = function(n) {
        var i1 = this._reporterState;
        return i1.options.partial ? {
            result: this.isError(n) ? null : n,
            errors: i1.errors
        } : n;
    };
    function r(n, i1) {
        this.path = n, this.rethrow(i1);
    }
    return e(r, Error), r.prototype.rethrow = function(n) {
        if (this.message = n + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, r), !this.stack) try {
            throw new Error(this.message);
        } catch (i1) {
            this.stack = i1.stack;
        }
        return this;
    }, $v;
}
var ny = {}, nk;
function ik() {
    if (nk) return ny;
    nk = 1;
    var e = Nr(), t = Qp().Reporter, r = ul.Buffer;
    function n(o, a) {
        if (t.call(this, a), !r.isBuffer(o)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = o, this.offset = 0, this.length = o.length;
    }
    e(n, t), ny.DecoderBuffer = n, n.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: t.prototype.save.call(this)
        };
    }, n.prototype.restore = function(o) {
        var a = new n(this.base);
        return a.offset = o.offset, a.length = this.offset, this.offset = o.offset, t.prototype.restore.call(this, o.reporter), a;
    }, n.prototype.isEmpty = function() {
        return this.offset === this.length;
    }, n.prototype.readUInt8 = function(o) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(o || "DecoderBuffer overrun");
    }, n.prototype.skip = function(o, a) {
        if (!(this.offset + o <= this.length)) return this.error(a || "DecoderBuffer overrun");
        var s = new n(this.base);
        return s._reporterState = this._reporterState, s.offset = this.offset, s.length = this.offset + o, this.offset += o, s;
    }, n.prototype.raw = function(o) {
        return this.base.slice(o ? o.offset : this.offset, this.length);
    };
    function i1(o, a) {
        if (Array.isArray(o)) this.length = 0, this.value = o.map(function(s) {
            return s instanceof i1 || (s = new i1(s, a)), this.length += s.length, s;
        }, this);
        else if (typeof o == "number") {
            if (!(0 <= o && o <= 255)) return a.error("non-byte EncoderBuffer value");
            this.value = o, this.length = 1;
        } else if (typeof o == "string") this.value = o, this.length = r.byteLength(o);
        else if (r.isBuffer(o)) this.value = o, this.length = o.length;
        else return a.error("Unsupported type: " + typeof o);
    }
    return ny.EncoderBuffer = i1, i1.prototype.join = function(o, a) {
        return o || (o = new r(this.length)), a || (a = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(s) {
            s.join(o, a), a += s.length;
        }) : (typeof this.value == "number" ? o[a] = this.value : typeof this.value == "string" ? o.write(this.value, a) : r.isBuffer(this.value) && this.value.copy(o, a), a += this.length)), o;
    }, ny;
}
var Zv, ok;
function aee() {
    if (ok) return Zv;
    ok = 1;
    var e = Qp().Reporter, t = Qp().EncoderBuffer, r = Qp().DecoderBuffer, n = Ua(), i1 = [
        "seq",
        "seqof",
        "set",
        "setof",
        "objid",
        "bool",
        "gentime",
        "utctime",
        "null_",
        "enum",
        "int",
        "objDesc",
        "bitstr",
        "bmpstr",
        "charstr",
        "genstr",
        "graphstr",
        "ia5str",
        "iso646str",
        "numstr",
        "octstr",
        "printstr",
        "t61str",
        "unistr",
        "utf8str",
        "videostr"
    ], o = [
        "key",
        "obj",
        "use",
        "optional",
        "explicit",
        "implicit",
        "def",
        "choice",
        "any",
        "contains"
    ].concat(i1), a = [
        "_peekTag",
        "_decodeTag",
        "_use",
        "_decodeStr",
        "_decodeObjid",
        "_decodeTime",
        "_decodeNull",
        "_decodeInt",
        "_decodeBool",
        "_decodeList",
        "_encodeComposite",
        "_encodeStr",
        "_encodeObjid",
        "_encodeTime",
        "_encodeNull",
        "_encodeInt",
        "_encodeBool"
    ];
    function s(l, u) {
        var f = {};
        this._baseState = f, f.enc = l, f.parent = u || null, f.children = null, f.tag = null, f.args = null, f.reverseArgs = null, f.choice = null, f.optional = !1, f.any = !1, f.obj = !1, f.use = null, f.useDecoder = null, f.key = null, f.default = null, f.explicit = null, f.implicit = null, f.contains = null, f.parent || (f.children = [], this._wrap());
    }
    Zv = s;
    var c = [
        "enc",
        "parent",
        "children",
        "tag",
        "args",
        "reverseArgs",
        "choice",
        "optional",
        "any",
        "obj",
        "use",
        "alteredUse",
        "key",
        "default",
        "explicit",
        "implicit",
        "contains"
    ];
    return s.prototype.clone = function() {
        var l = this._baseState, u = {};
        c.forEach(function(h) {
            u[h] = l[h];
        });
        var f = new this.constructor(u.parent);
        return f._baseState = u, f;
    }, s.prototype._wrap = function() {
        var l = this._baseState;
        o.forEach(function(u) {
            this[u] = function() {
                var f = new this.constructor(this);
                return l.children.push(f), f[u].apply(f, arguments);
            };
        }, this);
    }, s.prototype._init = function(l) {
        var u = this._baseState;
        n(u.parent === null), l.call(this), u.children = u.children.filter(function(f) {
            return f._baseState.parent === this;
        }, this), n.equal(u.children.length, 1, "Root node can have only one child");
    }, s.prototype._useArgs = function(l) {
        var u = this._baseState, f = l.filter(function(h) {
            return h instanceof this.constructor;
        }, this);
        l = l.filter(function(h) {
            return !(h instanceof this.constructor);
        }, this), f.length !== 0 && (n(u.children === null), u.children = f, f.forEach(function(h) {
            h._baseState.parent = this;
        }, this)), l.length !== 0 && (n(u.args === null), u.args = l, u.reverseArgs = l.map(function(h) {
            if (typeof h != "object" || h.constructor !== Object) return h;
            var y = {};
            return Object.keys(h).forEach(function(S) {
                S == (S | 0) && (S |= 0);
                var k = h[S];
                y[k] = S;
            }), y;
        }));
    }, a.forEach(function(l) {
        s.prototype[l] = function() {
            var u = this._baseState;
            throw new Error(l + " not implemented for encoding: " + u.enc);
        };
    }), i1.forEach(function(l) {
        s.prototype[l] = function() {
            var u = this._baseState, f = Array.prototype.slice.call(arguments);
            return n(u.tag === null), u.tag = l, this._useArgs(f), this;
        };
    }), s.prototype.use = function(l) {
        n(l);
        var u = this._baseState;
        return n(u.use === null), u.use = l, this;
    }, s.prototype.optional = function() {
        var l = this._baseState;
        return l.optional = !0, this;
    }, s.prototype.def = function(l) {
        var u = this._baseState;
        return n(u.default === null), u.default = l, u.optional = !0, this;
    }, s.prototype.explicit = function(l) {
        var u = this._baseState;
        return n(u.explicit === null && u.implicit === null), u.explicit = l, this;
    }, s.prototype.implicit = function(l) {
        var u = this._baseState;
        return n(u.explicit === null && u.implicit === null), u.implicit = l, this;
    }, s.prototype.obj = function() {
        var l = this._baseState, u = Array.prototype.slice.call(arguments);
        return l.obj = !0, u.length !== 0 && this._useArgs(u), this;
    }, s.prototype.key = function(l) {
        var u = this._baseState;
        return n(u.key === null), u.key = l, this;
    }, s.prototype.any = function() {
        var l = this._baseState;
        return l.any = !0, this;
    }, s.prototype.choice = function(l) {
        var u = this._baseState;
        return n(u.choice === null), u.choice = l, this._useArgs(Object.keys(l).map(function(f) {
            return l[f];
        })), this;
    }, s.prototype.contains = function(l) {
        var u = this._baseState;
        return n(u.use === null), u.contains = l, this;
    }, s.prototype._decode = function(l, u) {
        var f = this._baseState;
        if (f.parent === null) return l.wrapResult(f.children[0]._decode(l, u));
        var h = f.default, y = !0, S = null;
        if (f.key !== null && (S = l.enterKey(f.key)), f.optional) {
            var k = null;
            if (f.explicit !== null ? k = f.explicit : f.implicit !== null ? k = f.implicit : f.tag !== null && (k = f.tag), k === null && !f.any) {
                var P = l.save();
                try {
                    f.choice === null ? this._decodeGeneric(f.tag, l, u) : this._decodeChoice(l, u), y = !0;
                } catch  {
                    y = !1;
                }
                l.restore(P);
            } else if (y = this._peekTag(l, k, f.any), l.isError(y)) return y;
        }
        var M;
        if (f.obj && y && (M = l.enterObject()), y) {
            if (f.explicit !== null) {
                var N = this._decodeTag(l, f.explicit);
                if (l.isError(N)) return N;
                l = N;
            }
            var z = l.offset;
            if (f.use === null && f.choice === null) {
                if (f.any) var P = l.save();
                var K = this._decodeTag(l, f.implicit !== null ? f.implicit : f.tag, f.any);
                if (l.isError(K)) return K;
                f.any ? h = l.raw(P) : l = K;
            }
            if (u && u.track && f.tag !== null && u.track(l.path(), z, l.length, "tagged"), u && u.track && f.tag !== null && u.track(l.path(), l.offset, l.length, "content"), f.any ? h = h : f.choice === null ? h = this._decodeGeneric(f.tag, l, u) : h = this._decodeChoice(l, u), l.isError(h)) return h;
            if (!f.any && f.choice === null && f.children !== null && f.children.forEach(function(ne) {
                ne._decode(l, u);
            }), f.contains && (f.tag === "octstr" || f.tag === "bitstr")) {
                var $ = new r(h);
                h = this._getUse(f.contains, l._reporterState.obj)._decode($, u);
            }
        }
        return f.obj && y && (h = l.leaveObject(M)), f.key !== null && (h !== null || y === !0) ? l.leaveKey(S, f.key, h) : S !== null && l.exitKey(S), h;
    }, s.prototype._decodeGeneric = function(l, u, f) {
        var h = this._baseState;
        return l === "seq" || l === "set" ? null : l === "seqof" || l === "setof" ? this._decodeList(u, l, h.args[0], f) : /str$/.test(l) ? this._decodeStr(u, l, f) : l === "objid" && h.args ? this._decodeObjid(u, h.args[0], h.args[1], f) : l === "objid" ? this._decodeObjid(u, null, null, f) : l === "gentime" || l === "utctime" ? this._decodeTime(u, l, f) : l === "null_" ? this._decodeNull(u, f) : l === "bool" ? this._decodeBool(u, f) : l === "objDesc" ? this._decodeStr(u, l, f) : l === "int" || l === "enum" ? this._decodeInt(u, h.args && h.args[0], f) : h.use !== null ? this._getUse(h.use, u._reporterState.obj)._decode(u, f) : u.error("unknown tag: " + l);
    }, s.prototype._getUse = function(l, u) {
        var f = this._baseState;
        return f.useDecoder = this._use(l, u), n(f.useDecoder._baseState.parent === null), f.useDecoder = f.useDecoder._baseState.children[0], f.implicit !== f.useDecoder._baseState.implicit && (f.useDecoder = f.useDecoder.clone(), f.useDecoder._baseState.implicit = f.implicit), f.useDecoder;
    }, s.prototype._decodeChoice = function(l, u) {
        var f = this._baseState, h = null, y = !1;
        return Object.keys(f.choice).some(function(S) {
            var k = l.save(), P = f.choice[S];
            try {
                var M = P._decode(l, u);
                if (l.isError(M)) return !1;
                h = {
                    type: S,
                    value: M
                }, y = !0;
            } catch  {
                return l.restore(k), !1;
            }
            return !0;
        }, this), y ? h : l.error("Choice not matched");
    }, s.prototype._createEncoderBuffer = function(l) {
        return new t(l, this.reporter);
    }, s.prototype._encode = function(l, u, f) {
        var h = this._baseState;
        if (!(h.default !== null && h.default === l)) {
            var y = this._encodeValue(l, u, f);
            if (y !== void 0 && !this._skipDefault(y, u, f)) return y;
        }
    }, s.prototype._encodeValue = function(l, u, f) {
        var h = this._baseState;
        if (h.parent === null) return h.children[0]._encode(l, u || new e());
        var P = null;
        if (this.reporter = u, h.optional && l === void 0) if (h.default !== null) l = h.default;
        else return;
        var y = null, S = !1;
        if (h.any) P = this._createEncoderBuffer(l);
        else if (h.choice) P = this._encodeChoice(l, u);
        else if (h.contains) y = this._getUse(h.contains, f)._encode(l, u), S = !0;
        else if (h.children) y = h.children.map(function(z) {
            if (z._baseState.tag === "null_") return z._encode(null, u, l);
            if (z._baseState.key === null) return u.error("Child should have a key");
            var K = u.enterKey(z._baseState.key);
            if (typeof l != "object") return u.error("Child expected, but input is not object");
            var $ = z._encode(l[z._baseState.key], u, l);
            return u.leaveKey(K), $;
        }, this).filter(function(z) {
            return z;
        }), y = this._createEncoderBuffer(y);
        else if (h.tag === "seqof" || h.tag === "setof") {
            if (!(h.args && h.args.length === 1)) return u.error("Too many args for : " + h.tag);
            if (!Array.isArray(l)) return u.error("seqof/setof, but data is not Array");
            var k = this.clone();
            k._baseState.implicit = null, y = this._createEncoderBuffer(l.map(function(z) {
                var K = this._baseState;
                return this._getUse(K.args[0], l)._encode(z, u);
            }, k));
        } else h.use !== null ? P = this._getUse(h.use, f)._encode(l, u) : (y = this._encodePrimitive(h.tag, l), S = !0);
        var P;
        if (!h.any && h.choice === null) {
            var M = h.implicit !== null ? h.implicit : h.tag, N = h.implicit === null ? "universal" : "context";
            M === null ? h.use === null && u.error("Tag could be omitted only for .use()") : h.use === null && (P = this._encodeComposite(M, S, N, y));
        }
        return h.explicit !== null && (P = this._encodeComposite(h.explicit, !1, "context", P)), P;
    }, s.prototype._encodeChoice = function(l, u) {
        var f = this._baseState, h = f.choice[l.type];
        return h || n(!1, l.type + " not found in " + JSON.stringify(Object.keys(f.choice))), h._encode(l.value, u);
    }, s.prototype._encodePrimitive = function(l, u) {
        var f = this._baseState;
        if (/str$/.test(l)) return this._encodeStr(u, l);
        if (l === "objid" && f.args) return this._encodeObjid(u, f.reverseArgs[0], f.args[1]);
        if (l === "objid") return this._encodeObjid(u, null, null);
        if (l === "gentime" || l === "utctime") return this._encodeTime(u, l);
        if (l === "null_") return this._encodeNull();
        if (l === "int" || l === "enum") return this._encodeInt(u, f.args && f.reverseArgs[0]);
        if (l === "bool") return this._encodeBool(u);
        if (l === "objDesc") return this._encodeStr(u, l);
        throw new Error("Unsupported tag: " + l);
    }, s.prototype._isNumstr = function(l) {
        return /^[0-9 ]*$/.test(l);
    }, s.prototype._isPrintstr = function(l) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(l);
    }, Zv;
}
var ak;
function Qp() {
    return ak || (ak = 1, function(e) {
        var t = e;
        t.Reporter = oee().Reporter, t.DecoderBuffer = ik().DecoderBuffer, t.EncoderBuffer = ik().EncoderBuffer, t.Node = aee();
    }(tk)), tk;
}
var sk = {}, uk = {}, ck;
function see() {
    return ck || (ck = 1, function(e) {
        var t = zC();
        e.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        }, e.tagByName = t._reverse(e.tag);
    }(uk)), uk;
}
var lk;
function zC() {
    return lk || (lk = 1, function(e) {
        var t = e;
        t._reverse = function(r) {
            var n = {};
            return Object.keys(r).forEach(function(i1) {
                (i1 | 0) == i1 && (i1 = i1 | 0);
                var o = r[i1];
                n[o] = i1;
            }), n;
        }, t.der = see();
    }(sk)), sk;
}
var fk = {}, Xv, dk;
function LC() {
    if (dk) return Xv;
    dk = 1;
    var e = Nr(), t = E1(), r = t.base, n = t.bignum, i1 = t.constants.der;
    function o(l) {
        this.enc = "der", this.name = l.name, this.entity = l, this.tree = new a(), this.tree._init(l.body);
    }
    Xv = o, o.prototype.decode = function(l, u) {
        return l instanceof r.DecoderBuffer || (l = new r.DecoderBuffer(l, u)), this.tree._decode(l, u);
    };
    function a(l) {
        r.Node.call(this, "der", l);
    }
    e(a, r.Node), a.prototype._peekTag = function(l, u, f) {
        if (l.isEmpty()) return !1;
        var h = l.save(), y = s(l, 'Failed to peek tag: "' + u + '"');
        return l.isError(y) ? y : (l.restore(h), y.tag === u || y.tagStr === u || y.tagStr + "of" === u || f);
    }, a.prototype._decodeTag = function(l, u, f) {
        var h = s(l, 'Failed to decode tag of "' + u + '"');
        if (l.isError(h)) return h;
        var y = c(l, h.primitive, 'Failed to get length of "' + u + '"');
        if (l.isError(y)) return y;
        if (!f && h.tag !== u && h.tagStr !== u && h.tagStr + "of" !== u) return l.error('Failed to match tag: "' + u + '"');
        if (h.primitive || y !== null) return l.skip(y, 'Failed to match body of: "' + u + '"');
        var S = l.save(), k = this._skipUntilEnd(l, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return l.isError(k) ? k : (y = l.offset - S.offset, l.restore(S), l.skip(y, 'Failed to match body of: "' + u + '"'));
    }, a.prototype._skipUntilEnd = function(l, u) {
        for(;;){
            var f = s(l, u);
            if (l.isError(f)) return f;
            var h = c(l, f.primitive, u);
            if (l.isError(h)) return h;
            var y;
            if (f.primitive || h !== null ? y = l.skip(h) : y = this._skipUntilEnd(l, u), l.isError(y)) return y;
            if (f.tagStr === "end") break;
        }
    }, a.prototype._decodeList = function(l, u, f, h) {
        for(var y = []; !l.isEmpty();){
            var S = this._peekTag(l, "end");
            if (l.isError(S)) return S;
            var k = f.decode(l, "der", h);
            if (l.isError(k) && S) break;
            y.push(k);
        }
        return y;
    }, a.prototype._decodeStr = function(l, u) {
        if (u === "bitstr") {
            var f = l.readUInt8();
            return l.isError(f) ? f : {
                unused: f,
                data: l.raw()
            };
        } else if (u === "bmpstr") {
            var h = l.raw();
            if (h.length % 2 === 1) return l.error("Decoding of string type: bmpstr length mismatch");
            for(var y = "", S = 0; S < h.length / 2; S++)y += String.fromCharCode(h.readUInt16BE(S * 2));
            return y;
        } else if (u === "numstr") {
            var k = l.raw().toString("ascii");
            return this._isNumstr(k) ? k : l.error("Decoding of string type: numstr unsupported characters");
        } else {
            if (u === "octstr" || u === "objDesc") return l.raw();
            if (u === "printstr") {
                var P = l.raw().toString("ascii");
                return this._isPrintstr(P) ? P : l.error("Decoding of string type: printstr unsupported characters");
            } else return /str$/.test(u) ? l.raw().toString() : l.error("Decoding of string type: " + u + " unsupported");
        }
    }, a.prototype._decodeObjid = function(l, u, f) {
        for(var h, y = [], S = 0; !l.isEmpty();){
            var k = l.readUInt8();
            S <<= 7, S |= k & 127, k & 128 || (y.push(S), S = 0);
        }
        k & 128 && y.push(S);
        var P = y[0] / 40 | 0, M = y[0] % 40;
        if (f ? h = y : h = [
            P,
            M
        ].concat(y.slice(1)), u) {
            var N = u[h.join(" ")];
            N === void 0 && (N = u[h.join(".")]), N !== void 0 && (h = N);
        }
        return h;
    }, a.prototype._decodeTime = function(l, u) {
        var f = l.raw().toString();
        if (u === "gentime") var h = f.slice(0, 4) | 0, y = f.slice(4, 6) | 0, S = f.slice(6, 8) | 0, k = f.slice(8, 10) | 0, P = f.slice(10, 12) | 0, M = f.slice(12, 14) | 0;
        else if (u === "utctime") {
            var h = f.slice(0, 2) | 0, y = f.slice(2, 4) | 0, S = f.slice(4, 6) | 0, k = f.slice(6, 8) | 0, P = f.slice(8, 10) | 0, M = f.slice(10, 12) | 0;
            h < 70 ? h = 2e3 + h : h = 1900 + h;
        } else return l.error("Decoding " + u + " time is not supported yet");
        return Date.UTC(h, y - 1, S, k, P, M, 0);
    }, a.prototype._decodeNull = function(l) {
        return null;
    }, a.prototype._decodeBool = function(l) {
        var u = l.readUInt8();
        return l.isError(u) ? u : u !== 0;
    }, a.prototype._decodeInt = function(l, u) {
        var f = l.raw(), h = new n(f);
        return u && (h = u[h.toString(10)] || h), h;
    }, a.prototype._use = function(l, u) {
        return typeof l == "function" && (l = l(u)), l._getDecoder("der").tree;
    };
    function s(l, u) {
        var f = l.readUInt8(u);
        if (l.isError(f)) return f;
        var h = i1.tagClass[f >> 6], y = (f & 32) === 0;
        if ((f & 31) === 31) {
            var S = f;
            for(f = 0; (S & 128) === 128;){
                if (S = l.readUInt8(u), l.isError(S)) return S;
                f <<= 7, f |= S & 127;
            }
        } else f &= 31;
        var k = i1.tag[f];
        return {
            cls: h,
            primitive: y,
            tag: f,
            tagStr: k
        };
    }
    function c(l, u, f) {
        var h = l.readUInt8(f);
        if (l.isError(h)) return h;
        if (!u && h === 128) return null;
        if (!(h & 128)) return h;
        var y = h & 127;
        if (y > 4) return l.error("length octect is too long");
        h = 0;
        for(var S = 0; S < y; S++){
            h <<= 8;
            var k = l.readUInt8(f);
            if (l.isError(k)) return k;
            h |= k;
        }
        return h;
    }
    return Xv;
}
var Yv, hk;
function uee() {
    if (hk) return Yv;
    hk = 1;
    var e = Nr(), t = ul.Buffer, r = LC();
    function n(i1) {
        r.call(this, i1), this.enc = "pem";
    }
    return e(n, r), Yv = n, n.prototype.decode = function(i1, o) {
        for(var a = i1.toString().split(/[\r\n]+/g), s = o.label.toUpperCase(), c = /^-----(BEGIN|END) ([^-]+)-----$/, l = -1, u = -1, f = 0; f < a.length; f++){
            var h = a[f].match(c);
            if (h !== null && h[2] === s) if (l === -1) {
                if (h[1] !== "BEGIN") break;
                l = f;
            } else {
                if (h[1] !== "END") break;
                u = f;
                break;
            }
        }
        if (l === -1 || u === -1) throw new Error("PEM section not found for: " + s);
        var y = a.slice(l + 1, u).join("");
        y.replace(/[^a-z0-9\+\/=]+/gi, "");
        var S = new t(y, "base64");
        return r.prototype.decode.call(this, S, o);
    }, Yv;
}
var pk;
function cee() {
    return pk || (pk = 1, function(e) {
        var t = e;
        t.der = LC(), t.pem = uee();
    }(fk)), fk;
}
var gk = {}, Jv, yk;
function HC() {
    if (yk) return Jv;
    yk = 1;
    var e = Nr(), t = ul.Buffer, r = E1(), n = r.base, i1 = r.constants.der;
    function o(l) {
        this.enc = "der", this.name = l.name, this.entity = l, this.tree = new a(), this.tree._init(l.body);
    }
    Jv = o, o.prototype.encode = function(l, u) {
        return this.tree._encode(l, u).join();
    };
    function a(l) {
        n.Node.call(this, "der", l);
    }
    e(a, n.Node), a.prototype._encodeComposite = function(l, u, f, h) {
        var y = c(l, u, f, this.reporter);
        if (h.length < 128) {
            var P = new t(2);
            return P[0] = y, P[1] = h.length, this._createEncoderBuffer([
                P,
                h
            ]);
        }
        for(var S = 1, k = h.length; k >= 256; k >>= 8)S++;
        var P = new t(2 + S);
        P[0] = y, P[1] = 128 | S;
        for(var k = 1 + S, M = h.length; M > 0; k--, M >>= 8)P[k] = M & 255;
        return this._createEncoderBuffer([
            P,
            h
        ]);
    }, a.prototype._encodeStr = function(l, u) {
        if (u === "bitstr") return this._createEncoderBuffer([
            l.unused | 0,
            l.data
        ]);
        if (u === "bmpstr") {
            for(var f = new t(l.length * 2), h = 0; h < l.length; h++)f.writeUInt16BE(l.charCodeAt(h), h * 2);
            return this._createEncoderBuffer(f);
        } else return u === "numstr" ? this._isNumstr(l) ? this._createEncoderBuffer(l) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : u === "printstr" ? this._isPrintstr(l) ? this._createEncoderBuffer(l) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(u) ? this._createEncoderBuffer(l) : u === "objDesc" ? this._createEncoderBuffer(l) : this.reporter.error("Encoding of string type: " + u + " unsupported");
    }, a.prototype._encodeObjid = function(l, u, f) {
        if (typeof l == "string") {
            if (!u) return this.reporter.error("string objid given, but no values map found");
            if (!u.hasOwnProperty(l)) return this.reporter.error("objid not found in values map");
            l = u[l].split(/[\s\.]+/g);
            for(var h = 0; h < l.length; h++)l[h] |= 0;
        } else if (Array.isArray(l)) {
            l = l.slice();
            for(var h = 0; h < l.length; h++)l[h] |= 0;
        }
        if (!Array.isArray(l)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(l));
        if (!f) {
            if (l[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            l.splice(0, 2, l[0] * 40 + l[1]);
        }
        for(var y = 0, h = 0; h < l.length; h++){
            var S = l[h];
            for(y++; S >= 128; S >>= 7)y++;
        }
        for(var k = new t(y), P = k.length - 1, h = l.length - 1; h >= 0; h--){
            var S = l[h];
            for(k[P--] = S & 127; (S >>= 7) > 0;)k[P--] = 128 | S & 127;
        }
        return this._createEncoderBuffer(k);
    };
    function s(l) {
        return l < 10 ? "0" + l : l;
    }
    a.prototype._encodeTime = function(l, u) {
        var f, h = new Date(l);
        return u === "gentime" ? f = [
            s(h.getFullYear()),
            s(h.getUTCMonth() + 1),
            s(h.getUTCDate()),
            s(h.getUTCHours()),
            s(h.getUTCMinutes()),
            s(h.getUTCSeconds()),
            "Z"
        ].join("") : u === "utctime" ? f = [
            s(h.getFullYear() % 100),
            s(h.getUTCMonth() + 1),
            s(h.getUTCDate()),
            s(h.getUTCHours()),
            s(h.getUTCMinutes()),
            s(h.getUTCSeconds()),
            "Z"
        ].join("") : this.reporter.error("Encoding " + u + " time is not supported yet"), this._encodeStr(f, "octstr");
    }, a.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
    }, a.prototype._encodeInt = function(l, u) {
        if (typeof l == "string") {
            if (!u) return this.reporter.error("String int or enum given, but no values map");
            if (!u.hasOwnProperty(l)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(l));
            l = u[l];
        }
        if (typeof l != "number" && !t.isBuffer(l)) {
            var f = l.toArray();
            !l.sign && f[0] & 128 && f.unshift(0), l = new t(f);
        }
        if (t.isBuffer(l)) {
            var h = l.length;
            l.length === 0 && h++;
            var y = new t(h);
            return l.copy(y), l.length === 0 && (y[0] = 0), this._createEncoderBuffer(y);
        }
        if (l < 128) return this._createEncoderBuffer(l);
        if (l < 256) return this._createEncoderBuffer([
            0,
            l
        ]);
        for(var h = 1, S = l; S >= 256; S >>= 8)h++;
        for(var y = new Array(h), S = y.length - 1; S >= 0; S--)y[S] = l & 255, l >>= 8;
        return y[0] & 128 && y.unshift(0), this._createEncoderBuffer(new t(y));
    }, a.prototype._encodeBool = function(l) {
        return this._createEncoderBuffer(l ? 255 : 0);
    }, a.prototype._use = function(l, u) {
        return typeof l == "function" && (l = l(u)), l._getEncoder("der").tree;
    }, a.prototype._skipDefault = function(l, u, f) {
        var h = this._baseState, y;
        if (h.default === null) return !1;
        var S = l.join();
        if (h.defaultBuffer === void 0 && (h.defaultBuffer = this._encodeValue(h.default, u, f).join()), S.length !== h.defaultBuffer.length) return !1;
        for(y = 0; y < S.length; y++)if (S[y] !== h.defaultBuffer[y]) return !1;
        return !0;
    };
    function c(l, u, f, h) {
        var y;
        if (l === "seqof" ? l = "seq" : l === "setof" && (l = "set"), i1.tagByName.hasOwnProperty(l)) y = i1.tagByName[l];
        else if (typeof l == "number" && (l | 0) === l) y = l;
        else return h.error("Unknown tag: " + l);
        return y >= 31 ? h.error("Multi-octet tag encoding unsupported") : (u || (y |= 32), y |= i1.tagClassByName[f || "universal"] << 6, y);
    }
    return Jv;
}
var e3, mk;
function lee() {
    if (mk) return e3;
    mk = 1;
    var e = Nr(), t = HC();
    function r(n) {
        t.call(this, n), this.enc = "pem";
    }
    return e(r, t), e3 = r, r.prototype.encode = function(n, i1) {
        for(var o = t.prototype.encode.call(this, n), a = o.toString("base64"), s = [
            "-----BEGIN " + i1.label + "-----"
        ], c = 0; c < a.length; c += 64)s.push(a.slice(c, c + 64));
        return s.push("-----END " + i1.label + "-----"), s.join(`
`);
    }, e3;
}
var bk;
function fee() {
    return bk || (bk = 1, function(e) {
        var t = e;
        t.der = HC(), t.pem = lee();
    }(gk)), gk;
}
var wk;
function E1() {
    return wk || (wk = 1, function(e) {
        var t = e;
        t.bignum = Bi(), t.define = iee().define, t.base = Qp(), t.constants = zC(), t.decoders = cee(), t.encoders = fee();
    }(Y_)), Y_;
}
var t3, Ak;
function dee() {
    if (Ak) return t3;
    Ak = 1;
    var e = E1(), t = e.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        });
    }), r = e.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), i1 = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr());
    }), o = e.define("RelativeDistinguishedName", function() {
        this.setof(r);
    }), a = e.define("RDNSequence", function() {
        this.seqof(o);
    }), s = e.define("Name", function() {
        this.choice({
            rdnSequence: this.use(a)
        });
    }), c = e.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(t), this.key("notAfter").use(t));
    }), l = e.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
    }), u = e.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(n), this.key("issuer").use(s), this.key("validity").use(c), this.key("subject").use(s), this.key("subjectPublicKeyInfo").use(i1), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(l).optional());
    }), f = e.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(u), this.key("signatureAlgorithm").use(n), this.key("signatureValue").bitstr());
    });
    return t3 = f, t3;
}
var vk;
function hee() {
    if (vk) return pa;
    vk = 1;
    var e = E1();
    pa.certificate = dee();
    var t = e.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    pa.RSAPrivateKey = t;
    var r = e.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    pa.RSAPublicKey = r;
    var n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), i1 = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr());
    });
    pa.PublicKey = i1;
    var o = e.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(n), this.key("subjectPrivateKey").octstr());
    });
    pa.PrivateKey = o;
    var a = e.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    pa.EncryptedPrivateKey = a;
    var s = e.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    pa.DSAPrivateKey = s, pa.DSAparam = e.define("DSAparam", function() {
        this.int();
    });
    var c = e.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        });
    }), l = e.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(c), this.key("publicKey").optional().explicit(1).bitstr());
    });
    return pa.ECPrivateKey = l, pa.signature = e.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
    }), pa;
}
const pee = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var r3, Ek;
function gee() {
    if (Ek) return r3;
    Ek = 1;
    var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, n = K2(), i1 = X6(), o = Br().Buffer;
    return r3 = function(a, s) {
        var c = a.toString(), l = c.match(e), u;
        if (l) {
            var f = "aes" + l[1], h = o.from(l[2], "hex"), y = o.from(l[3].replace(/[\r\n]/g, ""), "base64"), S = n(s, h.slice(0, 8), parseInt(l[1], 10)).key, k = [], P = i1.createDecipheriv(f, S, h);
            k.push(P.update(y)), k.push(P.final()), u = o.concat(k);
        } else {
            var M = c.match(r);
            u = o.from(M[2].replace(/[\r\n]/g, ""), "base64");
        }
        var N = c.match(t)[1];
        return {
            tag: N,
            data: u
        };
    }, r3;
}
var n3, Sk;
function G2() {
    if (Sk) return n3;
    Sk = 1;
    var e = hee(), t = pee, r = gee(), n = X6(), i1 = AC(), o = Br().Buffer;
    function a(c, l) {
        var u = c.algorithm.decrypt.kde.kdeparams.salt, f = parseInt(c.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), h = t[c.algorithm.decrypt.cipher.algo.join(".")], y = c.algorithm.decrypt.cipher.iv, S = c.subjectPrivateKey, k = parseInt(h.split("-")[1], 10) / 8, P = i1.pbkdf2Sync(l, u, f, k, "sha1"), M = n.createDecipheriv(h, P, y), N = [];
        return N.push(M.update(S)), N.push(M.final()), o.concat(N);
    }
    function s(c) {
        var l;
        typeof c == "object" && !o.isBuffer(c) && (l = c.passphrase, c = c.key), typeof c == "string" && (c = o.from(c));
        var u = r(c, l), f = u.tag, h = u.data, y, S;
        switch(f){
            case "CERTIFICATE":
                S = e.certificate.decode(h, "der").tbsCertificate.subjectPublicKeyInfo;
            case "PUBLIC KEY":
                switch(S || (S = e.PublicKey.decode(h, "der")), y = S.algorithm.algorithm.join("."), y){
                    case "1.2.840.113549.1.1.1":
                        return e.RSAPublicKey.decode(S.subjectPublicKey.data, "der");
                    case "1.2.840.10045.2.1":
                        return S.subjectPrivateKey = S.subjectPublicKey, {
                            type: "ec",
                            data: S
                        };
                    case "1.2.840.10040.4.1":
                        return S.algorithm.params.pub_key = e.DSAparam.decode(S.subjectPublicKey.data, "der"), {
                            type: "dsa",
                            data: S.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + y);
                }
            case "ENCRYPTED PRIVATE KEY":
                h = e.EncryptedPrivateKey.decode(h, "der"), h = a(h, l);
            case "PRIVATE KEY":
                switch(S = e.PrivateKey.decode(h, "der"), y = S.algorithm.algorithm.join("."), y){
                    case "1.2.840.113549.1.1.1":
                        return e.RSAPrivateKey.decode(S.subjectPrivateKey, "der");
                    case "1.2.840.10045.2.1":
                        return {
                            curve: S.algorithm.curve,
                            privateKey: e.ECPrivateKey.decode(S.subjectPrivateKey, "der").privateKey
                        };
                    case "1.2.840.10040.4.1":
                        return S.algorithm.params.priv_key = e.DSAparam.decode(S.subjectPrivateKey, "der"), {
                            type: "dsa",
                            params: S.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + y);
                }
            case "RSA PUBLIC KEY":
                return e.RSAPublicKey.decode(h, "der");
            case "RSA PRIVATE KEY":
                return e.RSAPrivateKey.decode(h, "der");
            case "DSA PRIVATE KEY":
                return {
                    type: "dsa",
                    params: e.DSAPrivateKey.decode(h, "der")
                };
            case "EC PRIVATE KEY":
                return h = e.ECPrivateKey.decode(h, "der"), {
                    curve: h.parameters.value,
                    privateKey: h.privateKey
                };
            default:
                throw new Error("unknown key type " + f);
        }
    }
    return s.signature = e.signature, n3 = s, n3;
}
const KC = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var xk;
function yee() {
    if (xk) return Ep.exports;
    xk = 1;
    var e = Br().Buffer, t = pC(), r = e5(), n = n5().ec, i1 = J6(), o = G2(), a = KC, s = 1;
    function c(M, N, z, K, $) {
        var ne = o(N);
        if (ne.curve) {
            if (K !== "ecdsa" && K !== "ecdsa/rsa") throw new Error("wrong private key type");
            return l(M, ne);
        } else if (ne.type === "dsa") {
            if (K !== "dsa") throw new Error("wrong private key type");
            return u(M, ne, z);
        }
        if (K !== "rsa" && K !== "ecdsa/rsa") throw new Error("wrong private key type");
        if (N.padding !== void 0 && N.padding !== s) throw new Error("illegal or unsupported padding mode");
        M = e.concat([
            $,
            M
        ]);
        for(var ee = ne.modulus.byteLength(), q = [
            0,
            1
        ]; M.length + q.length + 1 < ee;)q.push(255);
        q.push(0);
        for(var U = -1; ++U < M.length;)q.push(M[U]);
        var Q = r(q, ne);
        return Q;
    }
    function l(M, N) {
        var z = a[N.curve.join(".")];
        if (!z) throw new Error("unknown curve " + N.curve.join("."));
        var K = new n(z), $ = K.keyFromPrivate(N.privateKey), ne = $.sign(M);
        return e.from(ne.toDER());
    }
    function u(M, N, z) {
        for(var K = N.params.priv_key, $ = N.params.p, ne = N.params.q, ee = N.params.g, q = new i1(0), U, Q = y(M, ne).mod(ne), v = !1, B = h(K, ne, M, z); v === !1;)U = k(ne, B, z), q = P(ee, U, $, ne), v = U.invm(ne).imul(Q.add(K.mul(q))).mod(ne), v.cmpn(0) === 0 && (v = !1, q = new i1(0));
        return f(q, v);
    }
    function f(M, N) {
        M = M.toArray(), N = N.toArray(), M[0] & 128 && (M = [
            0
        ].concat(M)), N[0] & 128 && (N = [
            0
        ].concat(N));
        var z = M.length + N.length + 4, K = [
            48,
            z,
            2,
            M.length
        ];
        return K = K.concat(M, [
            2,
            N.length
        ], N), e.from(K);
    }
    function h(M, N, z, K) {
        if (M = e.from(M.toArray()), M.length < N.byteLength()) {
            var $ = e.alloc(N.byteLength() - M.length);
            M = e.concat([
                $,
                M
            ]);
        }
        var ne = z.length, ee = S(z, N), q = e.alloc(ne);
        q.fill(1);
        var U = e.alloc(ne);
        return U = t(K, U).update(q).update(e.from([
            0
        ])).update(M).update(ee).digest(), q = t(K, U).update(q).digest(), U = t(K, U).update(q).update(e.from([
            1
        ])).update(M).update(ee).digest(), q = t(K, U).update(q).digest(), {
            k: U,
            v: q
        };
    }
    function y(M, N) {
        var z = new i1(M), K = (M.length << 3) - N.bitLength();
        return K > 0 && z.ishrn(K), z;
    }
    function S(M, N) {
        M = y(M, N), M = M.mod(N);
        var z = e.from(M.toArray());
        if (z.length < N.byteLength()) {
            var K = e.alloc(N.byteLength() - z.length);
            z = e.concat([
                K,
                z
            ]);
        }
        return z;
    }
    function k(M, N, z) {
        var K, $;
        do {
            for(K = e.alloc(0); K.length * 8 < M.bitLength();)N.v = t(z, N.k).update(N.v).digest(), K = e.concat([
                K,
                N.v
            ]);
            $ = y(K, M), N.k = t(z, N.k).update(N.v).update(e.from([
                0
            ])).digest(), N.v = t(z, N.k).update(N.v).digest();
        }while ($.cmp(M) !== -1)
        return $;
    }
    function P(M, N, z, K) {
        return M.toRed(i1.mont(z)).redPow(N).fromRed().mod(K);
    }
    return Ep.exports = c, Ep.exports.getKey = h, Ep.exports.makeKey = k, Ep.exports;
}
var i3, _k;
function mee() {
    if (_k) return i3;
    _k = 1;
    var e = Br().Buffer, t = J6(), r = n5().ec, n = G2(), i1 = KC;
    function o(l, u, f, h, y) {
        var S = n(f);
        if (S.type === "ec") {
            if (h !== "ecdsa" && h !== "ecdsa/rsa") throw new Error("wrong public key type");
            return a(l, u, S);
        } else if (S.type === "dsa") {
            if (h !== "dsa") throw new Error("wrong public key type");
            return s(l, u, S);
        }
        if (h !== "rsa" && h !== "ecdsa/rsa") throw new Error("wrong public key type");
        u = e.concat([
            y,
            u
        ]);
        for(var k = S.modulus.byteLength(), P = [
            1
        ], M = 0; u.length + P.length + 2 < k;)P.push(255), M += 1;
        P.push(0);
        for(var N = -1; ++N < u.length;)P.push(u[N]);
        P = e.from(P);
        var z = t.mont(S.modulus);
        l = new t(l).toRed(z), l = l.redPow(new t(S.publicExponent)), l = e.from(l.fromRed().toArray());
        var K = M < 8 ? 1 : 0;
        for(k = Math.min(l.length, P.length), l.length !== P.length && (K = 1), N = -1; ++N < k;)K |= l[N] ^ P[N];
        return K === 0;
    }
    function a(l, u, f) {
        var h = i1[f.data.algorithm.curve.join(".")];
        if (!h) throw new Error("unknown curve " + f.data.algorithm.curve.join("."));
        var y = new r(h), S = f.data.subjectPrivateKey.data;
        return y.verify(u, l, S);
    }
    function s(l, u, f) {
        var h = f.data.p, y = f.data.q, S = f.data.g, k = f.data.pub_key, P = n.signature.decode(l, "der"), M = P.s, N = P.r;
        c(M, y), c(N, y);
        var z = t.mont(h), K = M.invm(y), $ = S.toRed(z).redPow(new t(u).mul(K).mod(y)).fromRed().mul(k.toRed(z).redPow(N.mul(K).mod(y)).fromRed()).mod(h).mod(y);
        return $.cmp(N) === 0;
    }
    function c(l, u) {
        if (l.cmpn(0) <= 0) throw new Error("invalid sig");
        if (l.cmp(u) >= 0) throw new Error("invalid sig");
    }
    return i3 = o, i3;
}
var o3, kk;
function bee() {
    if (kk) return o3;
    kk = 1;
    var e = Br().Buffer, t = b1(), r = jJ(), n = Nr(), i1 = yee(), o = mee(), a = gC;
    Object.keys(a).forEach(function(f) {
        a[f].id = e.from(a[f].id, "hex"), a[f.toLowerCase()] = a[f];
    });
    function s(f) {
        r.Writable.call(this);
        var h = a[f];
        if (!h) throw new Error("Unknown message digest");
        this._hashType = h.hash, this._hash = t(h.hash), this._tag = h.id, this._signType = h.sign;
    }
    n(s, r.Writable), s.prototype._write = function(f, h, y) {
        this._hash.update(f), y();
    }, s.prototype.update = function(f, h) {
        return this._hash.update(typeof f == "string" ? e.from(f, h) : f), this;
    }, s.prototype.sign = function(f, h) {
        this.end();
        var y = this._hash.digest(), S = i1(y, f, this._hashType, this._signType, this._tag);
        return h ? S.toString(h) : S;
    };
    function c(f) {
        r.Writable.call(this);
        var h = a[f];
        if (!h) throw new Error("Unknown message digest");
        this._hash = t(h.hash), this._tag = h.id, this._signType = h.sign;
    }
    n(c, r.Writable), c.prototype._write = function(f, h, y) {
        this._hash.update(f), y();
    }, c.prototype.update = function(f, h) {
        return this._hash.update(typeof f == "string" ? e.from(f, h) : f), this;
    }, c.prototype.verify = function(f, h, y) {
        var S = typeof h == "string" ? e.from(h, y) : h;
        this.end();
        var k = this._hash.digest();
        return o(S, k, f, this._signType, this._tag);
    };
    function l(f) {
        return new s(f);
    }
    function u(f) {
        return new c(f);
    }
    return o3 = {
        Sign: l,
        Verify: u,
        createSign: l,
        createVerify: u
    }, o3;
}
var a3, Ok;
function wee() {
    if (Ok) return a3;
    Ok = 1;
    var e = n5(), t = Bi();
    a3 = function(o) {
        return new n(o);
    };
    var r = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
    function n(o) {
        this.curveType = r[o], this.curveType || (this.curveType = {
            name: o
        }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
    }
    n.prototype.generateKeys = function(o, a) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(o, a);
    }, n.prototype.computeSecret = function(o, a, s) {
        a = a || "utf8", Ke.isBuffer(o) || (o = new Ke(o, a));
        var c = this.curve.keyFromPublic(o).getPublic(), l = c.mul(this.keys.getPrivate()).getX();
        return i1(l, s, this.curveType.byteLength);
    }, n.prototype.getPublicKey = function(o, a) {
        var s = this.keys.getPublic(a === "compressed", !0);
        return a === "hybrid" && (s[s.length - 1] % 2 ? s[0] = 7 : s[0] = 6), i1(s, o);
    }, n.prototype.getPrivateKey = function(o) {
        return i1(this.keys.getPrivate(), o);
    }, n.prototype.setPublicKey = function(o, a) {
        return a = a || "utf8", Ke.isBuffer(o) || (o = new Ke(o, a)), this.keys._importPublic(o), this;
    }, n.prototype.setPrivateKey = function(o, a) {
        a = a || "utf8", Ke.isBuffer(o) || (o = new Ke(o, a));
        var s = new t(o);
        return s = s.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(s), this;
    };
    function i1(o, a, s) {
        Array.isArray(o) || (o = o.toArray());
        var c = new Ke(o);
        if (s && c.length < s) {
            var l = new Ke(s - c.length);
            l.fill(0), c = Ke.concat([
                l,
                c
            ]);
        }
        return a ? c.toString(a) : c;
    }
    return a3;
}
var Ik = {}, s3, Bk;
function qC() {
    if (Bk) return s3;
    Bk = 1;
    var e = b1(), t = Br().Buffer;
    s3 = function(n, i1) {
        for(var o = t.alloc(0), a = 0, s; o.length < i1;)s = r(a++), o = t.concat([
            o,
            e("sha1").update(n).update(s).digest()
        ]);
        return o.slice(0, i1);
    };
    function r(n) {
        var i1 = t.allocUnsafe(4);
        return i1.writeUInt32BE(n, 0), i1;
    }
    return s3;
}
var Tk, Pk;
function VC() {
    return Pk || (Pk = 1, Tk = function(e, t) {
        for(var r = e.length, n = -1; ++n < r;)e[n] ^= t[n];
        return e;
    }), Tk;
}
var u3, Ck;
function WC() {
    if (Ck) return u3;
    Ck = 1;
    var e = Bi(), t = Br().Buffer;
    function r(n, i1) {
        return t.from(n.toRed(e.mont(i1.modulus)).redPow(new e(i1.publicExponent)).fromRed().toArray());
    }
    return u3 = r, u3;
}
var c3, Mk;
function Aee() {
    if (Mk) return c3;
    Mk = 1;
    var e = G2(), t = Dh(), r = b1(), n = qC(), i1 = VC(), o = Bi(), a = WC(), s = e5(), c = Br().Buffer;
    c3 = function(h, y, S) {
        var k;
        h.padding ? k = h.padding : S ? k = 1 : k = 4;
        var P = e(h), M;
        if (k === 4) M = l(P, y);
        else if (k === 1) M = u(P, y, S);
        else if (k === 3) {
            if (M = new o(y), M.cmp(P.modulus) >= 0) throw new Error("data too long for modulus");
        } else throw new Error("unknown padding");
        return S ? s(M, P) : a(M, P);
    };
    function l(h, y) {
        var S = h.modulus.byteLength(), k = y.length, P = r("sha1").update(c.alloc(0)).digest(), M = P.length, N = 2 * M;
        if (k > S - N - 2) throw new Error("message too long");
        var z = c.alloc(S - k - N - 2), K = S - M - 1, $ = t(M), ne = i1(c.concat([
            P,
            z,
            c.alloc(1, 1),
            y
        ], K), n($, K)), ee = i1($, n(ne, M));
        return new o(c.concat([
            c.alloc(1),
            ee,
            ne
        ], S));
    }
    function u(h, y, S) {
        var k = y.length, P = h.modulus.byteLength();
        if (k > P - 11) throw new Error("message too long");
        var M;
        return S ? M = c.alloc(P - k - 3, 255) : M = f(P - k - 3), new o(c.concat([
            c.from([
                0,
                S ? 1 : 2
            ]),
            M,
            c.alloc(1),
            y
        ], P));
    }
    function f(h) {
        for(var y = c.allocUnsafe(h), S = 0, k = t(h * 2), P = 0, M; S < h;)P === k.length && (k = t(h * 2), P = 0), M = k[P++], M && (y[S++] = M);
        return y;
    }
    return c3;
}
var l3, Nk;
function vee() {
    if (Nk) return l3;
    Nk = 1;
    var e = G2(), t = qC(), r = VC(), n = Bi(), i1 = e5(), o = b1(), a = WC(), s = Br().Buffer;
    l3 = function(f, h, y) {
        var S;
        f.padding ? S = f.padding : y ? S = 1 : S = 4;
        var k = e(f), P = k.modulus.byteLength();
        if (h.length > P || new n(h).cmp(k.modulus) >= 0) throw new Error("decryption error");
        var M;
        y ? M = a(new n(h), k) : M = i1(h, k);
        var N = s.alloc(P - M.length);
        if (M = s.concat([
            N,
            M
        ], P), S === 4) return c(k, M);
        if (S === 1) return l(k, M, y);
        if (S === 3) return M;
        throw new Error("unknown padding");
    };
    function c(f, h) {
        var y = f.modulus.byteLength(), S = o("sha1").update(s.alloc(0)).digest(), k = S.length;
        if (h[0] !== 0) throw new Error("decryption error");
        var P = h.slice(1, k + 1), M = h.slice(k + 1), N = r(P, t(M, k)), z = r(M, t(N, y - k - 1));
        if (u(S, z.slice(0, k))) throw new Error("decryption error");
        for(var K = k; z[K] === 0;)K++;
        if (z[K++] !== 1) throw new Error("decryption error");
        return z.slice(K);
    }
    function l(f, h, y) {
        for(var S = h.slice(0, 2), k = 2, P = 0; h[k++] !== 0;)if (k >= h.length) {
            P++;
            break;
        }
        var M = h.slice(2, k - 1);
        if ((S.toString("hex") !== "0002" && !y || S.toString("hex") !== "0001" && y) && P++, M.length < 8 && P++, P) throw new Error("decryption error");
        return h.slice(k);
    }
    function u(f, h) {
        f = s.from(f), h = s.from(h);
        var y = 0, S = f.length;
        f.length !== h.length && (y++, S = Math.min(f.length, h.length));
        for(var k = -1; ++k < S;)y += f[k] ^ h[k];
        return y;
    }
    return l3;
}
var Rk;
function Eee() {
    return Rk || (Rk = 1, function(e) {
        e.publicEncrypt = Aee(), e.privateDecrypt = vee(), e.privateEncrypt = function(t, r) {
            return e.publicEncrypt(t, r, !0);
        }, e.publicDecrypt = function(t, r) {
            return e.privateDecrypt(t, r, !0);
        };
    }(Ik)), Ik;
}
var hd = {}, Uk;
function See() {
    if (Uk) return hd;
    Uk = 1;
    function e() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var t = Br(), r = Dh(), n = t.Buffer, i1 = t.kMaxLength, o = Qe.crypto || Qe.msCrypto, a = Math.pow(2, 32) - 1;
    function s(h, y) {
        if (typeof h != "number" || h !== h) throw new TypeError("offset must be a number");
        if (h > a || h < 0) throw new TypeError("offset must be a uint32");
        if (h > i1 || h > y) throw new RangeError("offset out of range");
    }
    function c(h, y, S) {
        if (typeof h != "number" || h !== h) throw new TypeError("size must be a number");
        if (h > a || h < 0) throw new TypeError("size must be a uint32");
        if (h + y > S || h > i1) throw new RangeError("buffer too small");
    }
    o && o.getRandomValues || !xn.browser ? (hd.randomFill = l, hd.randomFillSync = f) : (hd.randomFill = e, hd.randomFillSync = e);
    function l(h, y, S, k) {
        if (!n.isBuffer(h) && !(h instanceof Qe.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof y == "function") k = y, y = 0, S = h.length;
        else if (typeof S == "function") k = S, S = h.length - y;
        else if (typeof k != "function") throw new TypeError('"cb" argument must be a function');
        return s(y, h.length), c(S, y, h.length), u(h, y, S, k);
    }
    function u(h, y, S, k) {
        if (xn.browser) {
            var P = h.buffer, M = new Uint8Array(P, y, S);
            if (o.getRandomValues(M), k) {
                xn.nextTick(function() {
                    k(null, h);
                });
                return;
            }
            return h;
        }
        if (k) {
            r(S, function(z, K) {
                if (z) return k(z);
                K.copy(h, y), k(null, h);
            });
            return;
        }
        var N = r(S);
        return N.copy(h, y), h;
    }
    function f(h, y, S) {
        if (typeof y > "u" && (y = 0), !n.isBuffer(h) && !(h instanceof Qe.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return s(y, h.length), S === void 0 && (S = h.length - y), c(S, y, h.length), u(h, y, S);
    }
    return hd;
}
var Dk;
function i5() {
    if (Dk) return Ar;
    Dk = 1, Ar.randomBytes = Ar.rng = Ar.pseudoRandomBytes = Ar.prng = Dh(), Ar.createHash = Ar.Hash = b1(), Ar.createHmac = Ar.Hmac = pC();
    var e = nJ(), t = Object.keys(e), r = [
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "md5",
        "rmd160"
    ].concat(t);
    Ar.getHashes = function() {
        return r;
    };
    var n = AC();
    Ar.pbkdf2 = n.pbkdf2, Ar.pbkdf2Sync = n.pbkdf2Sync;
    var i1 = EJ();
    Ar.Cipher = i1.Cipher, Ar.createCipher = i1.createCipher, Ar.Cipheriv = i1.Cipheriv, Ar.createCipheriv = i1.createCipheriv, Ar.Decipher = i1.Decipher, Ar.createDecipher = i1.createDecipher, Ar.Decipheriv = i1.Decipheriv, Ar.createDecipheriv = i1.createDecipheriv, Ar.getCiphers = i1.getCiphers, Ar.listCiphers = i1.listCiphers;
    var o = MJ();
    Ar.DiffieHellmanGroup = o.DiffieHellmanGroup, Ar.createDiffieHellmanGroup = o.createDiffieHellmanGroup, Ar.getDiffieHellman = o.getDiffieHellman, Ar.createDiffieHellman = o.createDiffieHellman, Ar.DiffieHellman = o.DiffieHellman;
    var a = bee();
    Ar.createSign = a.createSign, Ar.Sign = a.Sign, Ar.createVerify = a.createVerify, Ar.Verify = a.Verify, Ar.createECDH = wee();
    var s = Eee();
    Ar.publicEncrypt = s.publicEncrypt, Ar.privateEncrypt = s.privateEncrypt, Ar.publicDecrypt = s.publicDecrypt, Ar.privateDecrypt = s.privateDecrypt;
    var c = See();
    return Ar.randomFill = c.randomFill, Ar.randomFillSync = c.randomFillSync, Ar.createCredentials = function() {
        throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    }, Ar.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    }, Ar;
}
(function(e) {
    /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.hexToBytes = e.bytesToHex = e.Signature = e.Point = e.CURVE = void 0;
    const t = i5(), r = BigInt(0), n = BigInt(1), i1 = BigInt(2), o = BigInt(3), a = BigInt(8), s = Object.freeze({
        a: r,
        b: BigInt(7),
        P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: n,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    e.CURVE = s;
    const c = (xe, ye)=>(xe + ye / i1) / ye, l = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar (xe) {
            const { n: ye } = s, ke = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ce = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), De = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Ye = ke, lt = BigInt("0x100000000000000000000000000000000"), et = c(Ye * xe, ye), vt = c(-Ce * xe, ye);
            let At = Z(xe - et * ke - vt * De, ye), dt = Z(-et * Ce - vt * Ye, ye);
            const Tt = At > lt, Pt = dt > lt;
            if (Tt && (At = ye - At), Pt && (dt = ye - dt), At > lt || dt > lt) throw new Error("splitScalarEndo: Endomorphism failed, k=" + xe);
            return {
                k1neg: Tt,
                k1: At,
                k2neg: Pt,
                k2: dt
            };
        }
    }, u = 32, f = 32, h = 32, y = u + 1, S = 2 * u + 1;
    function k(xe) {
        const { a: ye, b: ke } = s, Ce = Z(xe * xe), De = Z(Ce * xe);
        return Z(De + ye * xe + ke);
    }
    const P = s.a === r;
    class M extends Error {
        constructor(ye){
            super(ye);
        }
    }
    function N(xe) {
        if (!(xe instanceof z)) throw new TypeError("JacobianPoint expected");
    }
    class z {
        constructor(ye, ke, Ce){
            this.x = ye, this.y = ke, this.z = Ce;
        }
        static fromAffine(ye) {
            if (!(ye instanceof ne)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return ye.equals(ne.ZERO) ? z.ZERO : new z(ye.x, ye.y, n);
        }
        static toAffineBatch(ye) {
            const ke = Ie(ye.map((Ce)=>Ce.z));
            return ye.map((Ce, De)=>Ce.toAffine(ke[De]));
        }
        static normalizeZ(ye) {
            return z.toAffineBatch(ye).map(z.fromAffine);
        }
        equals(ye) {
            N(ye);
            const { x: ke, y: Ce, z: De } = this, { x: Ye, y: lt, z: et } = ye, vt = Z(De * De), At = Z(et * et), dt = Z(ke * At), Tt = Z(Ye * vt), Pt = Z(Z(Ce * et) * At), Rt = Z(Z(lt * De) * vt);
            return dt === Tt && Pt === Rt;
        }
        negate() {
            return new z(this.x, Z(-this.y), this.z);
        }
        double() {
            const { x: ye, y: ke, z: Ce } = this, De = Z(ye * ye), Ye = Z(ke * ke), lt = Z(Ye * Ye), et = ye + Ye, vt = Z(i1 * (Z(et * et) - De - lt)), At = Z(o * De), dt = Z(At * At), Tt = Z(dt - i1 * vt), Pt = Z(At * (vt - Tt) - a * lt), Rt = Z(i1 * ke * Ce);
            return new z(Tt, Pt, Rt);
        }
        add(ye) {
            N(ye);
            const { x: ke, y: Ce, z: De } = this, { x: Ye, y: lt, z: et } = ye;
            if (Ye === r || lt === r) return this;
            if (ke === r || Ce === r) return ye;
            const vt = Z(De * De), At = Z(et * et), dt = Z(ke * At), Tt = Z(Ye * vt), Pt = Z(Z(Ce * et) * At), Rt = Z(Z(lt * De) * vt), rt = Z(Tt - dt), Et = Z(Rt - Pt);
            if (rt === r) return Et === r ? this.double() : z.ZERO;
            const Pe = Z(rt * rt), mt = Z(rt * Pe), ut = Z(dt * Pe), Jt = Z(Et * Et - mt - i1 * ut), we = Z(Et * (ut - Jt) - Pt * mt), Tr = Z(De * et * rt);
            return new z(Jt, we, Tr);
        }
        subtract(ye) {
            return this.add(ye.negate());
        }
        multiplyUnsafe(ye) {
            const ke = z.ZERO;
            if (typeof ye == "bigint" && ye === r) return ke;
            let Ce = se(ye);
            if (Ce === n) return this;
            if (!P) {
                let Tt = ke, Pt = this;
                for(; Ce > r;)Ce & n && (Tt = Tt.add(Pt)), Pt = Pt.double(), Ce >>= n;
                return Tt;
            }
            let { k1neg: De, k1: Ye, k2neg: lt, k2: et } = l.splitScalar(Ce), vt = ke, At = ke, dt = this;
            for(; Ye > r || et > r;)Ye & n && (vt = vt.add(dt)), et & n && (At = At.add(dt)), dt = dt.double(), Ye >>= n, et >>= n;
            return De && (vt = vt.negate()), lt && (At = At.negate()), At = new z(Z(At.x * l.beta), At.y, At.z), vt.add(At);
        }
        precomputeWindow(ye) {
            const ke = P ? 128 / ye + 1 : 256 / ye + 1, Ce = [];
            let De = this, Ye = De;
            for(let lt = 0; lt < ke; lt++){
                Ye = De, Ce.push(Ye);
                for(let et = 1; et < 2 ** (ye - 1); et++)Ye = Ye.add(De), Ce.push(Ye);
                De = Ye.double();
            }
            return Ce;
        }
        wNAF(ye, ke) {
            !ke && this.equals(z.BASE) && (ke = ne.BASE);
            const Ce = ke && ke._WINDOW_SIZE || 1;
            if (256 % Ce) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let De = ke && $.get(ke);
            De || (De = this.precomputeWindow(Ce), ke && Ce !== 1 && (De = z.normalizeZ(De), $.set(ke, De)));
            let Ye = z.ZERO, lt = z.BASE;
            const et = 1 + (P ? 128 / Ce : 256 / Ce), vt = 2 ** (Ce - 1), At = BigInt(2 ** Ce - 1), dt = 2 ** Ce, Tt = BigInt(Ce);
            for(let Pt = 0; Pt < et; Pt++){
                const Rt = Pt * vt;
                let rt = Number(ye & At);
                ye >>= Tt, rt > vt && (rt -= dt, ye += n);
                const Et = Rt, Pe = Rt + Math.abs(rt) - 1, mt = Pt % 2 !== 0, ut = rt < 0;
                rt === 0 ? lt = lt.add(K(mt, De[Et])) : Ye = Ye.add(K(ut, De[Pe]));
            }
            return {
                p: Ye,
                f: lt
            };
        }
        multiply(ye, ke) {
            let Ce = se(ye), De, Ye;
            if (P) {
                const { k1neg: lt, k1: et, k2neg: vt, k2: At } = l.splitScalar(Ce);
                let { p: dt, f: Tt } = this.wNAF(et, ke), { p: Pt, f: Rt } = this.wNAF(At, ke);
                dt = K(lt, dt), Pt = K(vt, Pt), Pt = new z(Z(Pt.x * l.beta), Pt.y, Pt.z), De = dt.add(Pt), Ye = Tt.add(Rt);
            } else {
                const { p: lt, f: et } = this.wNAF(Ce, ke);
                De = lt, Ye = et;
            }
            return z.normalizeZ([
                De,
                Ye
            ])[0];
        }
        toAffine(ye) {
            const { x: ke, y: Ce, z: De } = this, Ye = this.equals(z.ZERO);
            ye == null && (ye = Ye ? a : ve(De));
            const lt = ye, et = Z(lt * lt), vt = Z(et * lt), At = Z(ke * et), dt = Z(Ce * vt), Tt = Z(De * lt);
            if (Ye) return ne.ZERO;
            if (Tt !== n) throw new Error("invZ was invalid");
            return new ne(At, dt);
        }
    }
    z.BASE = new z(s.Gx, s.Gy, n), z.ZERO = new z(r, n, r);
    function K(xe, ye) {
        const ke = ye.negate();
        return xe ? ke : ye;
    }
    const $ = /* @__PURE__ */ new WeakMap();
    class ne {
        constructor(ye, ke){
            this.x = ye, this.y = ke;
        }
        _setWindowSize(ye) {
            this._WINDOW_SIZE = ye, $.delete(this);
        }
        hasEvenY() {
            return this.y % i1 === r;
        }
        static fromCompressedHex(ye) {
            const ke = ye.length === 32, Ce = ue(ke ? ye : ye.subarray(1));
            if (!Ve(Ce)) throw new Error("Point is not on curve");
            const De = k(Ce);
            let Ye = pe(De);
            const lt = (Ye & n) === n;
            ke ? lt && (Ye = Z(-Ye)) : (ye[0] & 1) === 1 !== lt && (Ye = Z(-Ye));
            const et = new ne(Ce, Ye);
            return et.assertValidity(), et;
        }
        static fromUncompressedHex(ye) {
            const ke = ue(ye.subarray(1, u + 1)), Ce = ue(ye.subarray(u + 1, u * 2 + 1)), De = new ne(ke, Ce);
            return De.assertValidity(), De;
        }
        static fromHex(ye) {
            const ke = G(ye), Ce = ke.length, De = ke[0];
            if (Ce === u) return this.fromCompressedHex(ke);
            if (Ce === y && (De === 2 || De === 3)) return this.fromCompressedHex(ke);
            if (Ce === S && De === 4) return this.fromUncompressedHex(ke);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${S} uncompressed bytes, not ${Ce}`);
        }
        static fromPrivateKey(ye) {
            return ne.BASE.multiply(We(ye));
        }
        static fromSignature(ye, ke, Ce) {
            const { r: De, s: Ye } = p(ke);
            if (![
                0,
                1,
                2,
                3
            ].includes(Ce)) throw new Error("Cannot recover: invalid recovery bit");
            const lt = Re(G(ye)), { n: et } = s, vt = Ce === 2 || Ce === 3 ? De + et : De, At = ve(vt, et), dt = Z(-lt * At, et), Tt = Z(Ye * At, et), Pt = Ce & 1 ? "03" : "02", Rt = ne.fromHex(Pt + R(vt)), rt = ne.BASE.multiplyAndAddUnsafe(Rt, dt, Tt);
            if (!rt) throw new Error("Cannot recover signature: point at infinify");
            return rt.assertValidity(), rt;
        }
        toRawBytes(ye = !1) {
            return I(this.toHex(ye));
        }
        toHex(ye = !1) {
            const ke = R(this.x);
            return ye ? `${this.hasEvenY() ? "02" : "03"}${ke}` : `04${ke}${R(this.y)}`;
        }
        toHexX() {
            return this.toHex(!0).slice(2);
        }
        toRawX() {
            return this.toRawBytes(!0).slice(1);
        }
        assertValidity() {
            const ye = "Point is not on elliptic curve", { x: ke, y: Ce } = this;
            if (!Ve(ke) || !Ve(Ce)) throw new Error(ye);
            const De = Z(Ce * Ce), Ye = k(ke);
            if (Z(De - Ye) !== r) throw new Error(ye);
        }
        equals(ye) {
            return this.x === ye.x && this.y === ye.y;
        }
        negate() {
            return new ne(this.x, Z(-this.y));
        }
        double() {
            return z.fromAffine(this).double().toAffine();
        }
        add(ye) {
            return z.fromAffine(this).add(z.fromAffine(ye)).toAffine();
        }
        subtract(ye) {
            return this.add(ye.negate());
        }
        multiply(ye) {
            return z.fromAffine(this).multiply(ye, this).toAffine();
        }
        multiplyAndAddUnsafe(ye, ke, Ce) {
            const De = z.fromAffine(this), Ye = ke === r || ke === n || this !== ne.BASE ? De.multiplyUnsafe(ke) : De.multiply(ke), lt = z.fromAffine(ye).multiplyUnsafe(Ce), et = Ye.add(lt);
            return et.equals(z.ZERO) ? void 0 : et.toAffine();
        }
    }
    e.Point = ne, ne.BASE = new ne(s.Gx, s.Gy), ne.ZERO = new ne(r, r);
    function ee(xe) {
        return Number.parseInt(xe[0], 16) >= 8 ? "00" + xe : xe;
    }
    function q(xe) {
        if (xe.length < 2 || xe[0] !== 2) throw new Error(`Invalid signature integer tag: ${w(xe)}`);
        const ye = xe[1], ke = xe.subarray(2, ye + 2);
        if (!ye || ke.length !== ye) throw new Error("Invalid signature integer: wrong length");
        if (ke[0] === 0 && ke[1] <= 127) throw new Error("Invalid signature integer: trailing length");
        return {
            data: ue(ke),
            left: xe.subarray(ye + 2)
        };
    }
    function U(xe) {
        if (xe.length < 2 || xe[0] != 48) throw new Error(`Invalid signature tag: ${w(xe)}`);
        if (xe[1] !== xe.length - 2) throw new Error("Invalid signature: incorrect length");
        const { data: ye, left: ke } = q(xe.subarray(2)), { data: Ce, left: De } = q(ke);
        if (De.length) throw new Error(`Invalid signature: left bytes after parsing: ${w(De)}`);
        return {
            r: ye,
            s: Ce
        };
    }
    class Q {
        constructor(ye, ke){
            this.r = ye, this.s = ke, this.assertValidity();
        }
        static fromCompact(ye) {
            const ke = v(ye), Ce = "Signature.fromCompact";
            if (typeof ye != "string" && !ke) throw new TypeError(`${Ce}: Expected string or Uint8Array`);
            const De = ke ? w(ye) : ye;
            if (De.length !== 128) throw new Error(`${Ce}: Expected 64-byte hex`);
            return new Q(he(De.slice(0, 64)), he(De.slice(64, 128)));
        }
        static fromDER(ye) {
            const ke = v(ye);
            if (typeof ye != "string" && !ke) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
            const { r: Ce, s: De } = U(ke ? ye : I(ye));
            return new Q(Ce, De);
        }
        static fromHex(ye) {
            return this.fromDER(ye);
        }
        assertValidity() {
            const { r: ye, s: ke } = this;
            if (!je(ye)) throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!je(ke)) throw new Error("Invalid Signature: s must be 0 < s < n");
        }
        hasHighS() {
            const ye = s.n >> n;
            return this.s > ye;
        }
        normalizeS() {
            return this.hasHighS() ? new Q(this.r, Z(-this.s, s.n)) : this;
        }
        toDERRawBytes() {
            return I(this.toDERHex());
        }
        toDERHex() {
            const ye = ee(Y(this.s)), ke = ee(Y(this.r)), Ce = ye.length / 2, De = ke.length / 2, Ye = Y(Ce), lt = Y(De);
            return `30${Y(De + Ce + 4)}02${lt}${ke}02${Ye}${ye}`;
        }
        toRawBytes() {
            return this.toDERRawBytes();
        }
        toHex() {
            return this.toDERHex();
        }
        toCompactRawBytes() {
            return I(this.toCompactHex());
        }
        toCompactHex() {
            return R(this.r) + R(this.s);
        }
    }
    e.Signature = Q;
    function v(xe) {
        return xe instanceof Uint8Array || ArrayBuffer.isView(xe) && xe.constructor.name === "Uint8Array";
    }
    function B(xe) {
        if (!v(xe)) throw new Error("Uint8Array expected");
    }
    function g(...xe) {
        if (xe.every(B), xe.length === 1) return xe[0];
        const ye = xe.reduce((Ce, De)=>Ce + De.length, 0), ke = new Uint8Array(ye);
        for(let Ce = 0, De = 0; Ce < xe.length; Ce++){
            const Ye = xe[Ce];
            ke.set(Ye, De), De += Ye.length;
        }
        return ke;
    }
    const E = Array.from({
        length: 256
    }, (xe, ye)=>ye.toString(16).padStart(2, "0"));
    function w(xe) {
        B(xe);
        let ye = "";
        for(let ke = 0; ke < xe.length; ke++)ye += E[xe[ke]];
        return ye;
    }
    e.bytesToHex = w;
    const _ = {
        _0: 48,
        _9: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function O(xe) {
        if (xe >= _._0 && xe <= _._9) return xe - _._0;
        if (xe >= _.A && xe <= _.F) return xe - (_.A - 10);
        if (xe >= _.a && xe <= _.f) return xe - (_.a - 10);
    }
    function I(xe) {
        if (typeof xe != "string") throw new Error("hex string expected, got " + typeof xe);
        const ye = xe.length, ke = ye / 2;
        if (ye % 2) throw new Error("hex string expected, got unpadded hex of length " + ye);
        const Ce = new Uint8Array(ke);
        for(let De = 0, Ye = 0; De < ke; De++, Ye += 2){
            const lt = O(xe.charCodeAt(Ye)), et = O(xe.charCodeAt(Ye + 1));
            if (lt === void 0 || et === void 0) {
                const vt = xe[Ye] + xe[Ye + 1];
                throw new Error('hex string expected, got non-hex character "' + vt + '" at index ' + Ye);
            }
            Ce[De] = lt * 16 + et;
        }
        return Ce;
    }
    e.hexToBytes = I;
    const x = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function R(xe) {
        if (typeof xe != "bigint") throw new Error("Expected bigint");
        if (!(r <= xe && xe < x)) throw new Error("Expected number 0 <= n < 2^256");
        return xe.toString(16).padStart(64, "0");
    }
    function j(xe) {
        const ye = I(R(xe));
        if (ye.length !== 32) throw new Error("Error: expected 32 bytes");
        return ye;
    }
    function Y(xe) {
        const ye = xe.toString(16);
        return ye.length & 1 ? `0${ye}` : ye;
    }
    function he(xe) {
        if (typeof xe != "string") throw new TypeError("hexToNumber: expected string, got " + typeof xe);
        return BigInt(`0x${xe}`);
    }
    function ue(xe) {
        return he(w(xe));
    }
    function G(xe) {
        return v(xe) ? Uint8Array.from(xe) : I(xe);
    }
    function se(xe) {
        if (typeof xe == "number" && Number.isSafeInteger(xe) && xe > 0) return BigInt(xe);
        if (typeof xe == "bigint" && je(xe)) return xe;
        throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function Z(xe, ye = s.P) {
        const ke = xe % ye;
        return ke >= r ? ke : ye + ke;
    }
    function ie(xe, ye) {
        const { P: ke } = s;
        let Ce = xe;
        for(; ye-- > r;)Ce *= Ce, Ce %= ke;
        return Ce;
    }
    function pe(xe) {
        const { P: ye } = s, ke = BigInt(6), Ce = BigInt(11), De = BigInt(22), Ye = BigInt(23), lt = BigInt(44), et = BigInt(88), vt = xe * xe * xe % ye, At = vt * vt * xe % ye, dt = ie(At, o) * At % ye, Tt = ie(dt, o) * At % ye, Pt = ie(Tt, i1) * vt % ye, Rt = ie(Pt, Ce) * Pt % ye, rt = ie(Rt, De) * Rt % ye, Et = ie(rt, lt) * rt % ye, Pe = ie(Et, et) * Et % ye, mt = ie(Pe, lt) * rt % ye, ut = ie(mt, o) * At % ye, Jt = ie(ut, Ye) * Rt % ye, we = ie(Jt, ke) * vt % ye, Tr = ie(we, i1);
        if (Tr * Tr % ye !== xe) throw new Error("Cannot find square root");
        return Tr;
    }
    function ve(xe, ye = s.P) {
        if (xe === r || ye <= r) throw new Error(`invert: expected positive integers, got n=${xe} mod=${ye}`);
        let ke = Z(xe, ye), Ce = ye, De = r, Ye = n;
        for(; ke !== r;){
            const lt = Ce / ke, et = Ce % ke, vt = De - Ye * lt;
            Ce = ke, ke = et, De = Ye, Ye = vt;
        }
        if (Ce !== n) throw new Error("invert: does not exist");
        return Z(De, ye);
    }
    function Ie(xe, ye = s.P) {
        const ke = new Array(xe.length), Ce = xe.reduce((Ye, lt, et)=>lt === r ? Ye : (ke[et] = Ye, Z(Ye * lt, ye)), n), De = ve(Ce, ye);
        return xe.reduceRight((Ye, lt, et)=>lt === r ? Ye : (ke[et] = Z(Ye * ke[et], ye), Z(Ye * lt, ye)), De), ke;
    }
    function Me(xe) {
        const ye = xe.length * 8 - f * 8, ke = ue(xe);
        return ye > 0 ? ke >> BigInt(ye) : ke;
    }
    function Re(xe, ye = !1) {
        const ke = Me(xe);
        if (ye) return ke;
        const { n: Ce } = s;
        return ke >= Ce ? ke - Ce : ke;
    }
    let C, J;
    class me {
        constructor(ye, ke){
            if (this.hashLen = ye, this.qByteLen = ke, typeof ye != "number" || ye < 2) throw new Error("hashLen must be a number");
            if (typeof ke != "number" || ke < 2) throw new Error("qByteLen must be a number");
            this.v = new Uint8Array(ye).fill(1), this.k = new Uint8Array(ye).fill(0), this.counter = 0;
        }
        hmac(...ye) {
            return e.utils.hmacSha256(this.k, ...ye);
        }
        hmacSync(...ye) {
            return J(this.k, ...ye);
        }
        checkSync() {
            if (typeof J != "function") throw new M("hmacSha256Sync needs to be set");
        }
        incr() {
            if (this.counter >= 1e3) throw new Error("Tried 1,000 k values for sign(), all were invalid");
            this.counter += 1;
        }
        async reseed(ye = new Uint8Array()) {
            this.k = await this.hmac(this.v, Uint8Array.from([
                0
            ]), ye), this.v = await this.hmac(this.v), ye.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([
                1
            ]), ye), this.v = await this.hmac(this.v));
        }
        reseedSync(ye = new Uint8Array()) {
            this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([
                0
            ]), ye), this.v = this.hmacSync(this.v), ye.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([
                1
            ]), ye), this.v = this.hmacSync(this.v));
        }
        async generate() {
            this.incr();
            let ye = 0;
            const ke = [];
            for(; ye < this.qByteLen;){
                this.v = await this.hmac(this.v);
                const Ce = this.v.slice();
                ke.push(Ce), ye += this.v.length;
            }
            return g(...ke);
        }
        generateSync() {
            this.checkSync(), this.incr();
            let ye = 0;
            const ke = [];
            for(; ye < this.qByteLen;){
                this.v = this.hmacSync(this.v);
                const Ce = this.v.slice();
                ke.push(Ce), ye += this.v.length;
            }
            return g(...ke);
        }
    }
    function je(xe) {
        return r < xe && xe < s.n;
    }
    function Ve(xe) {
        return r < xe && xe < s.P;
    }
    function nt(xe, ye, ke, Ce = !0) {
        const { n: De } = s, Ye = Re(xe, !0);
        if (!je(Ye)) return;
        const lt = ve(Ye, De), et = ne.BASE.multiply(Ye), vt = Z(et.x, De);
        if (vt === r) return;
        const At = Z(lt * Z(ye + ke * vt, De), De);
        if (At === r) return;
        let dt = new Q(vt, At), Tt = (et.x === dt.r ? 0 : 2) | Number(et.y & n);
        return Ce && dt.hasHighS() && (dt = dt.normalizeS(), Tt ^= 1), {
            sig: dt,
            recovery: Tt
        };
    }
    function We(xe) {
        let ye;
        if (typeof xe == "bigint") ye = xe;
        else if (typeof xe == "number" && Number.isSafeInteger(xe) && xe > 0) ye = BigInt(xe);
        else if (typeof xe == "string") {
            if (xe.length !== 2 * f) throw new Error("Expected 32 bytes of private key");
            ye = he(xe);
        } else if (v(xe)) {
            if (xe.length !== f) throw new Error("Expected 32 bytes of private key");
            ye = ue(xe);
        } else throw new TypeError("Expected valid private key");
        if (!je(ye)) throw new Error("Expected private key: 0 < key < n");
        return ye;
    }
    function Ge(xe) {
        return xe instanceof ne ? (xe.assertValidity(), xe) : ne.fromHex(xe);
    }
    function p(xe) {
        if (xe instanceof Q) return xe.assertValidity(), xe;
        try {
            return Q.fromDER(xe);
        } catch  {
            return Q.fromCompact(xe);
        }
    }
    function A(xe, ye = !1) {
        return ne.fromPrivateKey(xe).toRawBytes(ye);
    }
    e.getPublicKey = A;
    function V(xe, ye, ke, Ce = !1) {
        return ne.fromSignature(xe, ye, ke).toRawBytes(Ce);
    }
    e.recoverPublicKey = V;
    function re(xe) {
        const ye = v(xe), ke = typeof xe == "string", Ce = (ye || ke) && xe.length;
        return ye ? Ce === y || Ce === S : ke ? Ce === y * 2 || Ce === S * 2 : xe instanceof ne;
    }
    function le(xe, ye, ke = !1) {
        if (re(xe)) throw new TypeError("getSharedSecret: first arg must be private key");
        if (!re(ye)) throw new TypeError("getSharedSecret: second arg must be public key");
        const Ce = Ge(ye);
        return Ce.assertValidity(), Ce.multiply(We(xe)).toRawBytes(ke);
    }
    e.getSharedSecret = le;
    function L(xe) {
        const ye = xe.length > u ? xe.slice(0, u) : xe;
        return ue(ye);
    }
    function X(xe) {
        const ye = L(xe), ke = Z(ye, s.n);
        return ae(ke < r ? ye : ke);
    }
    function ae(xe) {
        return j(xe);
    }
    function D(xe, ye, ke) {
        if (xe == null) throw new Error(`sign: expected valid message hash, not "${xe}"`);
        const Ce = G(xe), De = We(ye), Ye = [
            ae(De),
            X(Ce)
        ];
        if (ke != null) {
            ke === !0 && (ke = e.utils.randomBytes(u));
            const vt = G(ke);
            if (vt.length !== u) throw new Error(`sign: Expected ${u} bytes of extra data`);
            Ye.push(vt);
        }
        const lt = g(...Ye), et = L(Ce);
        return {
            seed: lt,
            m: et,
            d: De
        };
    }
    function H(xe, ye) {
        const { sig: ke, recovery: Ce } = xe, { der: De, recovered: Ye } = Object.assign({
            canonical: !0,
            der: !0
        }, ye), lt = De ? ke.toDERRawBytes() : ke.toCompactRawBytes();
        return Ye ? [
            lt,
            Ce
        ] : lt;
    }
    async function te(xe, ye, ke = {}) {
        const { seed: Ce, m: De, d: Ye } = D(xe, ye, ke.extraEntropy), lt = new me(h, f);
        await lt.reseed(Ce);
        let et;
        for(; !(et = nt(await lt.generate(), De, Ye, ke.canonical));)await lt.reseed();
        return H(et, ke);
    }
    e.sign = te;
    function ge(xe, ye, ke = {}) {
        const { seed: Ce, m: De, d: Ye } = D(xe, ye, ke.extraEntropy), lt = new me(h, f);
        lt.reseedSync(Ce);
        let et;
        for(; !(et = nt(lt.generateSync(), De, Ye, ke.canonical));)lt.reseedSync();
        return H(et, ke);
    }
    e.signSync = ge;
    const ce = {
        strict: !0
    };
    function Ue(xe, ye, ke, Ce = ce) {
        let De;
        try {
            De = p(xe), ye = G(ye);
        } catch  {
            return !1;
        }
        const { r: Ye, s: lt } = De;
        if (Ce.strict && De.hasHighS()) return !1;
        const et = Re(ye);
        let vt;
        try {
            vt = Ge(ke);
        } catch  {
            return !1;
        }
        const { n: At } = s, dt = ve(lt, At), Tt = Z(et * dt, At), Pt = Z(Ye * dt, At), Rt = ne.BASE.multiplyAndAddUnsafe(vt, Tt, Pt);
        return Rt ? Z(Rt.x, At) === Ye : !1;
    }
    e.verify = Ue;
    function qe(xe) {
        return Z(ue(xe), s.n);
    }
    class ot {
        constructor(ye, ke){
            this.r = ye, this.s = ke, this.assertValidity();
        }
        static fromHex(ye) {
            const ke = G(ye);
            if (ke.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${ke.length}`);
            const Ce = ue(ke.subarray(0, 32)), De = ue(ke.subarray(32, 64));
            return new ot(Ce, De);
        }
        assertValidity() {
            const { r: ye, s: ke } = this;
            if (!Ve(ye) || !je(ke)) throw new Error("Invalid signature");
        }
        toHex() {
            return R(this.r) + R(this.s);
        }
        toRawBytes() {
            return I(this.toHex());
        }
    }
    function yt(xe) {
        return ne.fromPrivateKey(xe).toRawX();
    }
    class Ut {
        constructor(ye, ke, Ce = e.utils.randomBytes()){
            if (ye == null) throw new TypeError(`sign: Expected valid message, not "${ye}"`);
            this.m = G(ye);
            const { x: De, scalar: Ye } = this.getScalar(We(ke));
            if (this.px = De, this.d = Ye, this.rand = G(Ce), this.rand.length !== 32) throw new TypeError("sign: Expected 32 bytes of aux randomness");
        }
        getScalar(ye) {
            const ke = ne.fromPrivateKey(ye), Ce = ke.hasEvenY() ? ye : s.n - ye;
            return {
                point: ke,
                scalar: Ce,
                x: ke.toRawX()
            };
        }
        initNonce(ye, ke) {
            return j(ye ^ ue(ke));
        }
        finalizeNonce(ye) {
            const ke = Z(ue(ye), s.n);
            if (ke === r) throw new Error("sign: Creation of signature failed. k is zero");
            const { point: Ce, x: De, scalar: Ye } = this.getScalar(ke);
            return {
                R: Ce,
                rx: De,
                k: Ye
            };
        }
        finalizeSig(ye, ke, Ce, De) {
            return new ot(ye.x, Z(ke + Ce * De, s.n)).toRawBytes();
        }
        error() {
            throw new Error("sign: Invalid signature produced");
        }
        async calc() {
            const { m: ye, d: ke, px: Ce, rand: De } = this, Ye = e.utils.taggedHash, lt = this.initNonce(ke, await Ye(Lt.aux, De)), { R: et, rx: vt, k: At } = this.finalizeNonce(await Ye(Lt.nonce, lt, Ce, ye)), dt = qe(await Ye(Lt.challenge, vt, Ce, ye)), Tt = this.finalizeSig(et, At, dt, ke);
            return await Wt(Tt, ye, Ce) || this.error(), Tt;
        }
        calcSync() {
            const { m: ye, d: ke, px: Ce, rand: De } = this, Ye = e.utils.taggedHashSync, lt = this.initNonce(ke, Ye(Lt.aux, De)), { R: et, rx: vt, k: At } = this.finalizeNonce(Ye(Lt.nonce, lt, Ce, ye)), dt = qe(Ye(Lt.challenge, vt, Ce, ye)), Tt = this.finalizeSig(et, At, dt, ke);
            return Dt(Tt, ye, Ce) || this.error(), Tt;
        }
    }
    async function Xe(xe, ye, ke) {
        return new Ut(xe, ye, ke).calc();
    }
    function _t(xe, ye, ke) {
        return new Ut(xe, ye, ke).calcSync();
    }
    function br(xe, ye, ke) {
        const Ce = xe instanceof ot, De = Ce ? xe : ot.fromHex(xe);
        return Ce && De.assertValidity(), {
            ...De,
            m: G(ye),
            P: Ge(ke)
        };
    }
    function Lr(xe, ye, ke, Ce) {
        const De = ne.BASE.multiplyAndAddUnsafe(ye, We(ke), Z(-Ce, s.n));
        return !(!De || !De.hasEvenY() || De.x !== xe);
    }
    async function Wt(xe, ye, ke) {
        try {
            const { r: Ce, s: De, m: Ye, P: lt } = br(xe, ye, ke), et = qe(await e.utils.taggedHash(Lt.challenge, j(Ce), lt.toRawX(), Ye));
            return Lr(Ce, lt, De, et);
        } catch  {
            return !1;
        }
    }
    function Dt(xe, ye, ke) {
        try {
            const { r: Ce, s: De, m: Ye, P: lt } = br(xe, ye, ke), et = qe(e.utils.taggedHashSync(Lt.challenge, j(Ce), lt.toRawX(), Ye));
            return Lr(Ce, lt, De, et);
        } catch (Ce) {
            if (Ce instanceof M) throw Ce;
            return !1;
        }
    }
    e.schnorr = {
        Signature: ot,
        getPublicKey: yt,
        sign: Xe,
        verify: Wt,
        signSync: _t,
        verifySync: Dt
    }, ne.BASE._setWindowSize(8);
    const Yt = {
        node: t,
        web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
    }, Lt = {
        challenge: "BIP0340/challenge",
        aux: "BIP0340/aux",
        nonce: "BIP0340/nonce"
    }, Dr = {};
    e.utils = {
        bytesToHex: w,
        hexToBytes: I,
        concatBytes: g,
        mod: Z,
        invert: ve,
        isValidPrivateKey (xe) {
            try {
                return We(xe), !0;
            } catch  {
                return !1;
            }
        },
        _bigintTo32Bytes: j,
        _normalizePrivateKey: We,
        hashToPrivateKey: (xe)=>{
            xe = G(xe);
            const ye = f + 8;
            if (xe.length < ye || xe.length > 1024) throw new Error("Expected valid bytes of private key as per FIPS 186");
            const ke = Z(ue(xe), s.n - n) + n;
            return j(ke);
        },
        randomBytes: (xe = 32)=>{
            if (Yt.web) return Yt.web.getRandomValues(new Uint8Array(xe));
            if (Yt.node) {
                const { randomBytes: ye } = Yt.node;
                return Uint8Array.from(ye(xe));
            } else throw new Error("The environment doesn't have randomBytes function");
        },
        randomPrivateKey: ()=>e.utils.hashToPrivateKey(e.utils.randomBytes(f + 8)),
        precompute (xe = 8, ye = ne.BASE) {
            const ke = ye === ne.BASE ? ye : new ne(ye.x, ye.y);
            return ke._setWindowSize(xe), ke.multiply(o), ke;
        },
        sha256: async (...xe)=>{
            if (Yt.web) {
                const ye = await Yt.web.subtle.digest("SHA-256", g(...xe));
                return new Uint8Array(ye);
            } else if (Yt.node) {
                const { createHash: ye } = Yt.node, ke = ye("sha256");
                return xe.forEach((Ce)=>ke.update(Ce)), Uint8Array.from(ke.digest());
            } else throw new Error("The environment doesn't have sha256 function");
        },
        hmacSha256: async (xe, ...ye)=>{
            if (Yt.web) {
                const ke = await Yt.web.subtle.importKey("raw", xe, {
                    name: "HMAC",
                    hash: {
                        name: "SHA-256"
                    }
                }, !1, [
                    "sign"
                ]), Ce = g(...ye), De = await Yt.web.subtle.sign("HMAC", ke, Ce);
                return new Uint8Array(De);
            } else if (Yt.node) {
                const { createHmac: ke } = Yt.node, Ce = ke("sha256", xe);
                return ye.forEach((De)=>Ce.update(De)), Uint8Array.from(Ce.digest());
            } else throw new Error("The environment doesn't have hmac-sha256 function");
        },
        sha256Sync: void 0,
        hmacSha256Sync: void 0,
        taggedHash: async (xe, ...ye)=>{
            let ke = Dr[xe];
            if (ke === void 0) {
                const Ce = await e.utils.sha256(Uint8Array.from(xe, (De)=>De.charCodeAt(0)));
                ke = g(Ce, Ce), Dr[xe] = ke;
            }
            return e.utils.sha256(ke, ...ye);
        },
        taggedHashSync: (xe, ...ye)=>{
            if (typeof C != "function") throw new M("sha256Sync is undefined, you need to set it");
            let ke = Dr[xe];
            if (ke === void 0) {
                const Ce = C(Uint8Array.from(xe, (De)=>De.charCodeAt(0)));
                ke = g(Ce, Ce), Dr[xe] = ke;
            }
            return C(ke, ...ye);
        },
        _JacobianPoint: z
    }, Object.defineProperties(e.utils, {
        sha256Sync: {
            configurable: !1,
            get () {
                return C;
            },
            set (xe) {
                C || (C = xe);
            }
        },
        hmacSha256Sync: {
            configurable: !1,
            get () {
                return J;
            },
            set (xe) {
                J || (J = xe);
            }
        }
    });
})(cC);
var hh = {};
Object.defineProperty(hh, "__esModule", {
    value: !0
});
hh.joseToDer = hh.derToJose = void 0;
const GC = Uh, QC = ro;
function f3(e) {
    return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
const xee = {
    ES256: f3(256),
    ES384: f3(384),
    ES512: f3(521)
};
function $C(e) {
    const t = xee[e];
    if (t) return t;
    throw new Error(`Unknown algorithm "${e}"`);
}
const bm = 128, ZC = 0, _ee = 32, kee = 16, Oee = 2, XC = kee | _ee | ZC << 6, wm = Oee | ZC << 6;
function YC(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return (0, GC.toByteArray)((0, QC.pad)(e));
    throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function Iee(e, t) {
    const r = YC(e), n = $C(t), i1 = n + 1, o = r.length;
    let a = 0;
    if (r[a++] !== XC) throw new Error('Could not find expected "seq"');
    let s = r[a++];
    if (s === (bm | 1) && (s = r[a++]), o - a < s) throw new Error(`"seq" specified length of "${s}", only "${o - a}" remaining`);
    if (r[a++] !== wm) throw new Error('Could not find expected "int" for "r"');
    const c = r[a++];
    if (o - a - 2 < c) throw new Error(`"r" specified length of "${c}", only "${o - a - 2}" available`);
    if (i1 < c) throw new Error(`"r" specified length of "${c}", max of "${i1}" is acceptable`);
    const l = a;
    if (a += c, r[a++] !== wm) throw new Error('Could not find expected "int" for "s"');
    const u = r[a++];
    if (o - a !== u) throw new Error(`"s" specified length of "${u}", expected "${o - a}"`);
    if (i1 < u) throw new Error(`"s" specified length of "${u}", max of "${i1}" is acceptable`);
    const f = a;
    if (a += u, a !== o) throw new Error(`Expected to consume entire array, but "${o - a}" bytes remain`);
    const h = n - c, y = n - u, S = new Uint8Array(h + c + y + u);
    for(a = 0; a < h; ++a)S[a] = 0;
    S.set(r.subarray(l + Math.max(-h, 0), l + c), a), a = n;
    for(const k = a; a < k + y; ++a)S[a] = 0;
    return S.set(r.subarray(f + Math.max(-y, 0), f + u), a), (0, QC.escape)((0, GC.fromByteArray)(S));
}
hh.derToJose = Iee;
function jk(e, t, r) {
    let n = 0;
    for(; t + n < r && e[t + n] === 0;)++n;
    return e[t + n] >= bm && --n, n;
}
function Bee(e, t) {
    e = YC(e);
    const r = $C(t), n = e.length;
    if (n !== r * 2) throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
    const i1 = jk(e, 0, r), o = jk(e, r, e.length), a = r - i1, s = r - o, c = 2 + a + 1 + 1 + s, l = c < bm, u = new Uint8Array((l ? 2 : 3) + c);
    let f = 0;
    return u[f++] = XC, l ? u[f++] = c : (u[f++] = bm | 1, u[f++] = c & 255), u[f++] = wm, u[f++] = a, i1 < 0 ? (u[f++] = 0, u.set(e.subarray(0, r), f), f += r) : (u.set(e.subarray(i1, r), f), f += r - i1), u[f++] = wm, u[f++] = s, o < 0 ? (u[f++] = 0, u.set(e.subarray(r), f)) : u.set(e.subarray(r + o), f), u;
}
hh.joseToDer = Bee;
var Uu = {};
Object.defineProperty(Uu, "__esModule", {
    value: !0
});
Uu.InvalidTokenError = Uu.MissingParametersError = void 0;
class Tee extends Error {
    constructor(t){
        super(), this.name = "MissingParametersError", this.message = t || "";
    }
}
Uu.MissingParametersError = Tee;
class Pee extends Error {
    constructor(t){
        super(), this.name = "InvalidTokenError", this.message = t || "";
    }
}
Uu.InvalidTokenError = Pee;
Object.defineProperty(z2, "__esModule", {
    value: !0
});
z2.SECP256K1Client = void 0;
const Cee = p1, Mee = Ba, Hy = cC, Fk = hh, zk = Uu, Lk = Qr;
Hy.utils.hmacSha256Sync = (e, ...t)=>{
    const r = Cee.hmac.create(Mee.sha256, e);
    return t.forEach((n)=>r.update(n)), r.digest();
};
class JC {
    static derivePublicKey(t, r = !0) {
        return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, Lk.bytesToHex)(Hy.getPublicKey(t, r));
    }
    static signHash(t, r, n = "jose") {
        if (!t || !r) throw new zk.MissingParametersError("a signing input hash and private key are all required");
        const i1 = Hy.signSync(t, r.slice(0, 64), {
            der: !0,
            canonical: !1
        });
        if (n === "der") return (0, Lk.bytesToHex)(i1);
        if (n === "jose") return (0, Fk.derToJose)(i1, "ES256");
        throw Error("Invalid signature format");
    }
    static loadSignature(t) {
        return (0, Fk.joseToDer)(t, "ES256");
    }
    static verifyHash(t, r, n) {
        if (!t || !r || !n) throw new zk.MissingParametersError("a signing input hash, der signature, and public key are all required");
        return Hy.verify(r, t, n, {
            strict: !1
        });
    }
}
z2.SECP256K1Client = JC;
JC.algorithmName = "ES256K";
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.cryptoClients = e.SECP256K1Client = void 0;
    const t = z2;
    Object.defineProperty(e, "SECP256K1Client", {
        enumerable: !0,
        get: function() {
            return t.SECP256K1Client;
        }
    });
    const r = {
        ES256K: t.SECP256K1Client
    };
    e.cryptoClients = r;
})(F2);
var gf = {}, Nee = Qe && Qe.__awaiter || function(e, t, r, n) {
    function i1(o) {
        return o instanceof r ? o : new r(function(a) {
            a(o);
        });
    }
    return new (r || (r = Promise))(function(o, a) {
        function s(u) {
            try {
                l(n.next(u));
            } catch (f) {
                a(f);
            }
        }
        function c(u) {
            try {
                l(n.throw(u));
            } catch (f) {
                a(f);
            }
        }
        function l(u) {
            u.done ? o(u.value) : i1(u.value).then(s, c);
        }
        l((n = n.apply(e, t || [])).next());
    });
};
Object.defineProperty(gf, "__esModule", {
    value: !0
});
gf.hashSha256Async = gf.hashSha256 = void 0;
const Ree = Ba;
function eM(e) {
    return (0, Ree.sha256)(e);
}
gf.hashSha256 = eM;
function Uee(e) {
    return Nee(this, void 0, void 0, function*() {
        try {
            if (typeof crypto < "u" && typeof crypto.subtle < "u") {
                const t = typeof e == "string" ? new TextEncoder().encode(e) : e, r = yield crypto.subtle.digest("SHA-256", t);
                return new Uint8Array(r);
            } else {
                const t = i5();
                if (!t.createHash) throw new Error("`crypto` module does not contain `createHash`");
                return Promise.resolve(t.createHash("sha256").update(e).digest());
            }
        } catch (t) {
            return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(eM(e));
        }
    });
}
gf.hashSha256Async = Uee;
var Dee = Qe && Qe.__awaiter || function(e, t, r, n) {
    function i1(o) {
        return o instanceof r ? o : new r(function(a) {
            a(o);
        });
    }
    return new (r || (r = Promise))(function(o, a) {
        function s(u) {
            try {
                l(n.next(u));
            } catch (f) {
                a(f);
            }
        }
        function c(u) {
            try {
                l(n.throw(u));
            } catch (f) {
                a(f);
            }
        }
        function l(u) {
            u.done ? o(u.value) : i1(u.value).then(s, c);
        }
        l((n = n.apply(e, t || [])).next());
    });
};
Object.defineProperty(fh, "__esModule", {
    value: !0
});
fh.TokenSigner = fh.createUnsecuredToken = void 0;
const M8 = ro, Hk = F2, jee = Uu, Kk = gf;
function N8(e, t) {
    const r = [], n = M8.encode(JSON.stringify(t));
    r.push(n);
    const i1 = M8.encode(JSON.stringify(e));
    return r.push(i1), r.join(".");
}
function Fee(e) {
    return N8(e, {
        typ: "JWT",
        alg: "none"
    }) + ".";
}
fh.createUnsecuredToken = Fee;
class zee {
    constructor(t, r){
        if (!(t && r)) throw new jee.MissingParametersError("a signing algorithm and private key are required");
        if (typeof t != "string") throw new Error("signing algorithm parameter must be a string");
        if (t = t.toUpperCase(), !Hk.cryptoClients.hasOwnProperty(t)) throw new Error("invalid signing algorithm");
        this.tokenType = "JWT", this.cryptoClient = Hk.cryptoClients[t], this.rawPrivateKey = r;
    }
    header(t = {}) {
        const r = {
            typ: this.tokenType,
            alg: this.cryptoClient.algorithmName
        };
        return Object.assign({}, r, t);
    }
    sign(t, r = !1, n = {}) {
        const i1 = this.header(n), o = N8(t, i1), a = (0, Kk.hashSha256)(o);
        return this.createWithSignedHash(t, r, i1, o, a);
    }
    signAsync(t, r = !1, n = {}) {
        return Dee(this, void 0, void 0, function*() {
            const i1 = this.header(n), o = N8(t, i1), a = yield (0, Kk.hashSha256Async)(o);
            return this.createWithSignedHash(t, r, i1, o, a);
        });
    }
    createWithSignedHash(t, r, n, i1, o) {
        const a = this.cryptoClient.signHash(o, this.rawPrivateKey);
        return r ? {
            header: [
                M8.encode(JSON.stringify(n))
            ],
            payload: JSON.stringify(t),
            signature: [
                a
            ]
        } : [
            i1,
            a
        ].join(".");
    }
}
fh.TokenSigner = zee;
var Q2 = {};
Object.defineProperty(Q2, "__esModule", {
    value: !0
});
Q2.TokenVerifier = void 0;
const Lee = ro, qk = F2, Hee = Uu, iy = gf;
class Kee {
    constructor(t, r){
        if (!(t && r)) throw new Hee.MissingParametersError("a signing algorithm and public key are required");
        if (typeof t != "string") throw "signing algorithm parameter must be a string";
        if (t = t.toUpperCase(), !qk.cryptoClients.hasOwnProperty(t)) throw "invalid signing algorithm";
        this.tokenType = "JWT", this.cryptoClient = qk.cryptoClients[t], this.rawPublicKey = r;
    }
    verify(t) {
        return typeof t == "string" ? this.verifyCompact(t, !1) : typeof t == "object" ? this.verifyExpanded(t, !1) : !1;
    }
    verifyAsync(t) {
        return typeof t == "string" ? this.verifyCompact(t, !0) : typeof t == "object" ? this.verifyExpanded(t, !0) : Promise.resolve(!1);
    }
    verifyCompact(t, r) {
        const n = t.split("."), i1 = n[0] + "." + n[1], o = (a)=>{
            const s = this.cryptoClient.loadSignature(n[2]);
            return this.cryptoClient.verifyHash(a, s, this.rawPublicKey);
        };
        if (r) return (0, iy.hashSha256Async)(i1).then((a)=>o(a));
        {
            const a = (0, iy.hashSha256)(i1);
            return o(a);
        }
    }
    verifyExpanded(t, r) {
        const n = [
            t.header.join("."),
            Lee.encode(t.payload)
        ].join(".");
        let i1 = !0;
        const o = (a)=>(t.signature.map((s)=>{
                const c = this.cryptoClient.loadSignature(s);
                this.cryptoClient.verifyHash(a, c, this.rawPublicKey) || (i1 = !1);
            }), i1);
        if (r) return (0, iy.hashSha256Async)(n).then((a)=>o(a));
        {
            const a = (0, iy.hashSha256)(n);
            return o(a);
        }
    }
}
Q2.TokenVerifier = Kee;
var $2 = {};
Object.defineProperty($2, "__esModule", {
    value: !0
});
$2.decodeToken = void 0;
const oy = ro;
function qee(e) {
    if (typeof e == "string") {
        const t = e.split("."), r = JSON.parse(oy.decode(t[0])), n = JSON.parse(oy.decode(t[1])), i1 = t[2];
        return {
            header: r,
            payload: n,
            signature: i1
        };
    } else if (typeof e == "object") {
        if (typeof e.payload != "string") throw new Error("Expected token payload to be a base64 or json string");
        let t = e.payload;
        e.payload[0] !== "{" && (t = oy.decode(t));
        const r = [];
        return e.header.map((n)=>{
            const i1 = JSON.parse(oy.decode(n));
            r.push(i1);
        }), {
            header: r,
            payload: JSON.parse(t),
            signature: e.signature
        };
    }
}
$2.decodeToken = qee;
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(fh, e), r(Q2, e), r($2, e), r(Uu, e), r(F2, e);
})(ta);
function Vee(e, t) {
    var r;
    return (r = void 0) == null ? void 0 : r.get(t);
}
function Z2(e) {
    var t, r;
    const n = typeof e;
    return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function si(e, t, r, n, i1) {
    const o = i1 && "input" in i1 ? i1.input : r.value, a = (i1 == null ? void 0 : i1.expected) ?? e.expects ?? null, s = (i1 == null ? void 0 : i1.received) ?? Z2(o), c = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: a,
        received: s,
        message: `Invalid ${t}: ${a ? `Expected ${a} but r` : "R"}eceived ${s}`,
        requirement: e.requirement,
        path: i1 == null ? void 0 : i1.path,
        issues: i1 == null ? void 0 : i1.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, l = e.kind === "schema", u = (i1 == null ? void 0 : i1.message) ?? e.message ?? Vee(e.reference, c.lang) ?? (l ? (c.lang, void 0) : null) ?? n.message ?? (c.lang, void 0);
    u && (c.message = typeof u == "function" ? // @ts-expect-error
    u(c) : u), l && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [
        c
    ];
}
function tM(e, t) {
    return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function X2(e, t) {
    const r = [
        ...new Set(e)
    ];
    return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
function rM(e, t) {
    return {
        kind: "validation",
        type: "check",
        reference: rM,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement(r.value) && si(this, "input", r, n), r;
        }
    };
}
function nM(e, t) {
    return {
        kind: "validation",
        type: "max_length",
        reference: nM,
        async: !1,
        expects: `<=${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length > this.requirement && si(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function iM(e, t) {
    return {
        kind: "validation",
        type: "min_length",
        reference: iM,
        async: !1,
        expects: `>=${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length < this.requirement && si(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function oM(e, t, r) {
    return typeof e.default == "function" ? // @ts-expect-error
    e.default(t, r) : // @ts-expect-error
    e.default;
}
function Vk(e, t) {
    return !e._run({
        typed: !1,
        value: t
    }, {
        abortEarly: !0
    }).issues;
}
function Pn(e, t) {
    return {
        kind: "schema",
        type: "array",
        reference: Pn,
        expects: "Array",
        async: !1,
        item: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (Array.isArray(o)) {
                r.typed = !0, r.value = [];
                for(let a = 0; a < o.length; a++){
                    const s = o[a], c = this.item._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "array",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), r.value.push(c.value);
                }
            } else si(this, "type", r, n);
            return r;
        }
    };
}
function Mf(e) {
    return {
        kind: "schema",
        type: "boolean",
        reference: Mf,
        expects: "boolean",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "boolean" ? t.typed = !0 : si(this, "type", t, r), t;
        }
    };
}
function Co(e, t) {
    const r = Object.entries(e).filter(([n])=>isNaN(+n)).map(([, n])=>n);
    return {
        kind: "schema",
        type: "enum",
        reference: Co,
        expects: X2(r.map(Z2), "|"),
        async: !1,
        enum: e,
        options: r,
        message: t,
        _run (n, i1) {
            return this.options.includes(n.value) ? n.typed = !0 : si(this, "type", n, i1), n;
        }
    };
}
function cr(e, t) {
    return {
        kind: "schema",
        type: "literal",
        reference: cr,
        expects: Z2(e),
        async: !1,
        literal: e,
        message: t,
        _run (r, n) {
            return r.value === this.literal ? r.typed = !0 : si(this, "type", r, n), r;
        }
    };
}
function aM(e, t) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: aM,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (o && typeof o == "object") {
                r.typed = !0, r.value = {};
                for(const a in this.entries){
                    const s = o[a], c = this.entries[a]._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), (c.value !== void 0 || a in o) && (r.value[a] = c.value);
                }
                if (!r.issues || !n.abortEarly) for(const a in o)tM(o, a) && !(a in this.entries) && (r.value[a] = o[a]);
            } else si(this, "type", r, n);
            return r;
        }
    };
}
function o5(e, t) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: o5,
        expects: "!undefined",
        async: !1,
        wrapped: e,
        message: t,
        _run (r, n) {
            return r.value === void 0 ? (si(this, "type", r, n), r) : this.wrapped._run(r, n);
        }
    };
}
function Qi(e) {
    return {
        kind: "schema",
        type: "null",
        reference: Qi,
        expects: "null",
        async: !1,
        message: e,
        _run (t, r) {
            return t.value === null ? t.typed = !0 : si(this, "type", t, r), t;
        }
    };
}
function mi(e, ...t) {
    const r = {
        kind: "schema",
        type: "nullish",
        reference: mi,
        expects: `(${e.expects} | null | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i1) {
            return (n.value === null || n.value === void 0) && ("default" in this && (n.value = oM(this, n, i1)), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i1);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function $n(e) {
    return {
        kind: "schema",
        type: "number",
        reference: $n,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : si(this, "type", t, r), t;
        }
    };
}
function st(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: st,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (o && typeof o == "object") {
                r.typed = !0, r.value = {};
                for(const a in this.entries){
                    const s = o[a], c = this.entries[a]._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), (c.value !== void 0 || a in o) && (r.value[a] = c.value);
                }
            } else si(this, "type", r, n);
            return r;
        }
    };
}
function Xt(e, ...t) {
    const r = {
        kind: "schema",
        type: "optional",
        reference: Xt,
        expects: `(${e.expects} | undefined)`,
        async: !1,
        wrapped: e,
        _run (n, i1) {
            return n.value === void 0 && ("default" in this && (n.value = oM(this, n, i1)), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i1);
        }
    };
    return 0 in t && (r.default = t[0]), r;
}
function sM(e, t) {
    return {
        kind: "schema",
        type: "picklist",
        reference: sM,
        expects: X2(e.map(Z2), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            return this.options.includes(r.value) ? r.typed = !0 : si(this, "type", r, n), r;
        }
    };
}
function uM(e, t, r) {
    return {
        kind: "schema",
        type: "record",
        reference: uM,
        expects: "Object",
        async: !1,
        key: e,
        value: t,
        message: r,
        _run (n, i1) {
            var o, a;
            const s = n.value;
            if (s && typeof s == "object") {
                n.typed = !0, n.value = {};
                for(const c in s)if (tM(s, c)) {
                    const l = s[c], u = this.key._run({
                        typed: !1,
                        value: c
                    }, i1);
                    if (u.issues) {
                        const h = {
                            type: "object",
                            origin: "key",
                            input: s,
                            key: c,
                            value: l
                        };
                        for (const y of u.issues)y.path = [
                            h
                        ], (o = n.issues) == null || o.push(y);
                        if (n.issues || (n.issues = u.issues), i1.abortEarly) {
                            n.typed = !1;
                            break;
                        }
                    }
                    const f = this.value._run({
                        typed: !1,
                        value: l
                    }, i1);
                    if (f.issues) {
                        const h = {
                            type: "object",
                            origin: "value",
                            input: s,
                            key: c,
                            value: l
                        };
                        for (const y of f.issues)y.path ? y.path.unshift(h) : y.path = [
                            h
                        ], (a = n.issues) == null || a.push(y);
                        if (n.issues || (n.issues = f.issues), i1.abortEarly) {
                            n.typed = !1;
                            break;
                        }
                    }
                    (!u.typed || !f.typed) && (n.typed = !1), u.typed && (n.value[u.value] = f.value);
                }
            } else si(this, "type", n, i1);
            return n;
        }
    };
}
function it(e) {
    return {
        kind: "schema",
        type: "string",
        reference: it,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : si(this, "type", t, r), t;
        }
    };
}
function Wk(e) {
    let t;
    if (e) for (const r of e)t ? t.push(...r.issues) : t = r.issues;
    return t;
}
function Nf(e, t) {
    return {
        kind: "schema",
        type: "union",
        reference: Nf,
        expects: X2(e.map((r)=>r.expects), "|"),
        async: !1,
        options: e,
        message: t,
        _run (r, n) {
            let i1, o, a;
            for (const s of this.options){
                const c = s._run({
                    typed: !1,
                    value: r.value
                }, n);
                if (c.typed) if (c.issues) o ? o.push(c) : o = [
                    c
                ];
                else {
                    i1 = c;
                    break;
                }
                else a ? a.push(c) : a = [
                    c
                ];
            }
            if (i1) return i1;
            if (o) {
                if (o.length === 1) return o[0];
                si(this, "type", r, n, {
                    issues: Wk(o)
                }), r.typed = !0;
            } else {
                if ((a == null ? void 0 : a.length) === 1) return a[0];
                si(this, "type", r, n, {
                    issues: Wk(a)
                });
            }
            return r;
        }
    };
}
function Y2() {
    return {
        kind: "schema",
        type: "unknown",
        reference: Y2,
        expects: "unknown",
        async: !1,
        _run (e) {
            return e.typed = !0, e;
        }
    };
}
function cM(e, t, r) {
    return {
        kind: "schema",
        type: "variant",
        reference: cM,
        expects: "Object",
        async: !1,
        key: e,
        options: t,
        message: r,
        _run (n, i1) {
            const o = n.value;
            if (o && typeof o == "object") {
                let a, s = 0, c = this.key, l = [];
                const u = (f, h)=>{
                    for (const y of f.options){
                        if (y.type === "variant") u(y, new Set(h).add(y.key));
                        else {
                            let S = !0, k = 0;
                            for (const P of h){
                                if (y.entries[P]._run(// @ts-expect-error
                                {
                                    typed: !1,
                                    value: o[P]
                                }, i1).issues) {
                                    S = !1, c !== P && (s < k || s === k && P in o && !(c in o)) && (s = k, c = P, l = []), c === P && l.push(y.entries[P].expects);
                                    break;
                                }
                                k++;
                            }
                            if (S) {
                                const P = y._run({
                                    typed: !1,
                                    value: o
                                }, i1);
                                (!a || !a.typed && P.typed) && (a = P);
                            }
                        }
                        if (a && !a.issues) break;
                    }
                };
                if (u(this, /* @__PURE__ */ new Set([
                    this.key
                ])), a) return a;
                si(this, "type", n, i1, {
                    // @ts-expect-error
                    input: o[c],
                    expected: X2(l, "|"),
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: c,
                            // @ts-expect-error
                            value: o[c]
                        }
                    ]
                });
            } else si(this, "type", n, i1);
            return n;
        }
    };
}
function Gk(e, t) {
    const r = {
        ...e.entries
    };
    for (const n of t)delete r[n];
    return {
        ...e,
        entries: r
    };
}
function R8(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
function Wee(e) {
    return e.wrapped;
}
const Gee = globalThis || void 0 || self;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var Qk = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(()=>{
    const e = Array(256).fill(-1);
    for(let t = 0; t < Qk.length; ++t)e[Qk.charCodeAt(t)] = t;
})();
var $k, d3, ay, a5 = ($k = function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.bech32m = t.bech32 = void 0;
    const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
    for(let f = 0; f < 32; f++){
        const h = r.charAt(f);
        n[h] = f;
    }
    function i1(f) {
        const h = f >> 25;
        return (33554431 & f) << 5 ^ 996825010 & -(h >> 0 & 1) ^ 642813549 & -(h >> 1 & 1) ^ 513874426 & -(h >> 2 & 1) ^ 1027748829 & -(h >> 3 & 1) ^ 705979059 & -(h >> 4 & 1);
    }
    function o(f) {
        let h = 1;
        for(let y = 0; y < f.length; ++y){
            const S = f.charCodeAt(y);
            if (S < 33 || S > 126) return "Invalid prefix (" + f + ")";
            h = i1(h) ^ S >> 5;
        }
        h = i1(h);
        for(let y = 0; y < f.length; ++y){
            const S = f.charCodeAt(y);
            h = i1(h) ^ 31 & S;
        }
        return h;
    }
    function a(f, h, y, S) {
        let k = 0, P = 0;
        const M = (1 << y) - 1, N = [];
        for(let z = 0; z < f.length; ++z)for(k = k << h | f[z], P += h; P >= y;)P -= y, N.push(k >> P & M);
        if (S) P > 0 && N.push(k << y - P & M);
        else {
            if (P >= h) return "Excess padding";
            if (k << y - P & M) return "Non-zero padding";
        }
        return N;
    }
    function s(f) {
        return a(f, 8, 5, !0);
    }
    function c(f) {
        const h = a(f, 5, 8, !1);
        if (Array.isArray(h)) return h;
    }
    function l(f) {
        const h = a(f, 5, 8, !1);
        if (Array.isArray(h)) return h;
        throw new Error(h);
    }
    function u(f) {
        let h;
        function y(S, k) {
            if (k = k || 90, S.length < 8) return S + " too short";
            if (S.length > k) return "Exceeds length limit";
            const P = S.toLowerCase(), M = S.toUpperCase();
            if (S !== P && S !== M) return "Mixed-case string " + S;
            const N = (S = P).lastIndexOf("1");
            if (N === -1) return "No separator character for " + S;
            if (N === 0) return "Missing prefix for " + S;
            const z = S.slice(0, N), K = S.slice(N + 1);
            if (K.length < 6) return "Data too short";
            let $ = o(z);
            if (typeof $ == "string") return $;
            const ne = [];
            for(let ee = 0; ee < K.length; ++ee){
                const q = K.charAt(ee), U = n[q];
                if (U === void 0) return "Unknown character " + q;
                $ = i1($) ^ U, ee + 6 >= K.length || ne.push(U);
            }
            return $ !== h ? "Invalid checksum for " + S : {
                prefix: z,
                words: ne
            };
        }
        return h = f === "bech32" ? 1 : 734539939, {
            decodeUnsafe: function(S, k) {
                const P = y(S, k);
                if (typeof P == "object") return P;
            },
            decode: function(S, k) {
                const P = y(S, k);
                if (typeof P == "object") return P;
                throw new Error(P);
            },
            encode: function(S, k, P) {
                if (P = P || 90, S.length + 7 + k.length > P) throw new TypeError("Exceeds length limit");
                let M = o(S = S.toLowerCase());
                if (typeof M == "string") throw new Error(M);
                let N = S + "1";
                for(let z = 0; z < k.length; ++z){
                    const K = k[z];
                    if (K >> 5) throw new Error("Non 5-bit word");
                    M = i1(M) ^ K, N += r.charAt(K);
                }
                for(let z = 0; z < 6; ++z)M = i1(M);
                M ^= h;
                for(let z = 0; z < 6; ++z)N += r.charAt(M >> 5 * (5 - z) & 31);
                return N;
            },
            toWords: s,
            fromWordsUnsafe: c,
            fromWords: l
        };
    }
    t.bech32 = u("bech32"), t.bech32m = u("bech32m");
}, $k(d3 = {
    exports: {}
}, d3.exports), d3.exports);
(ay = a5) && ay.__esModule && Object.prototype.hasOwnProperty.call(ay, "default") && ay.default;
a5.bech32m;
a5.bech32;
new Uint8Array(new Uint16Array([
    65279
]).buffer)[0];
var Td, Pd;
(function(e) {
    e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Td || (Td = {})), function(e) {
    e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Pd || (Pd = {}));
Pd.p2pkh, Td.mainnet, Pd.p2pkh, Td.testnet, Pd.p2sh, Td.mainnet, Pd.p2sh, Td.testnet;
var Qee = [
    "software",
    "ledger",
    "keystone"
], lM = sM(Qee), yf = /* @__PURE__ */ ((e)=>(e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(yf || {}), fM = /* @__PURE__ */ ((e)=>(e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(fM || {}), dM = st({
    address: it(),
    publicKey: it(),
    purpose: Co(yf),
    addressType: Co(fM),
    walletType: lM
}), $ee = async (e)=>{
    var t, r;
    const n = await J2(e.getProvider), { purposes: i1 } = e.payload;
    if (!i1) throw new Error("Address purposes are required");
    try {
        const o = ta.createUnsecuredToken(e.payload), a = await n.connect(o);
        (t = e.onFinish) == null || t.call(e, a);
    } catch (o) {
        console.error("[Connect] Error during address request", o), (r = e.onCancel) == null || r.call(e);
    }
}, Qn = /* @__PURE__ */ ((e)=>(e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Testnet4 = "Testnet4", e.Signet = "Signet", e.Regtest = "Regtest", e))(Qn || {}), s5 = Xt(Nf([
    it(),
    $n(),
    Qi()
])), Yr = st({
    jsonrpc: cr("2.0"),
    method: it(),
    params: Xt(Nf([
        Pn(Y2()),
        aM({}),
        // Note: This is to support current incorrect usage of RPC 2.0. Params need
        // to be either an array or an object when provided. Changing this now would
        // be a breaking change, so accepting null values for now. Tracking in
        // https://linear.app/xverseapp/issue/ENG-4538.
        Qi()
    ])),
    id: Wee(s5)
}), jp = /* @__PURE__ */ ((e)=>(e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(jp || {}), hM = st({
    jsonrpc: cr("2.0"),
    result: o5(Y2()),
    id: s5
}), pM = st({
    jsonrpc: cr("2.0"),
    error: o5(Y2()),
    id: s5
});
Nf([
    hM,
    pM
]);
var Zee = "accountChange";
st({
    type: cr(Zee),
    addresses: Xt(Pn(dM))
});
var Xee = "networkChange";
st({
    type: cr(Xee),
    bitcoin: st({
        name: Co(Qn)
    }),
    stacks: st({
        name: it()
    })
});
var Yee = "disconnect";
st({
    type: cr(Yee)
});
async function J2(e) {
    var t;
    const r = await (e == null ? void 0 : e()) || ((t = window.XverseProviders) == null ? void 0 : t.BitcoinProvider) || window.BitcoinProvider;
    if (!r) throw new Error("No Bitcoin wallet installed");
    return r;
}
var Jee = "stx_callContract", ete = st({
    /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */ contract: it(),
    /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */ functionName: it(),
    /**
   * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
   */ arguments: Xt(Pn(it())),
    /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */ functionArgs: Xt(Pn(it())),
    /**
   * The post conditions to apply to the contract call.
   */ postConditions: Xt(Pn(it())),
    /**
   * The mode to apply to the post conditions.
   */ postConditionMode: Xt(Nf([
        cr("allow"),
        cr("deny")
    ]))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Jee),
        params: ete,
        id: it()
    }).entries
});
var tte = "stx_deployContract", rte = st({
    /**
   * Name of the contract.
   */ name: it(),
    /**
   * The source code of the Clarity contract.
   */ clarityCode: it(),
    /**
   * The version of the Clarity contract.
   */ clarityVersion: Xt(it()),
    /**
   * The post conditions to apply to the contract call.
   */ postConditions: Xt(Pn(it())),
    /**
   * The mode to apply to the post conditions.
   */ postConditionMode: Xt(Nf([
        cr("allow"),
        cr("deny")
    ]))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(tte),
        params: rte,
        id: it()
    }).entries
});
var nte = st({
    read: Xt(Mf())
}), ite = st({
    readNetwork: Xt(Mf())
}), ote = st({
    type: cr("account"),
    resourceId: it(),
    clientId: it(),
    actions: nte
}), ate = st({
    type: cr("wallet"),
    resourceId: it(),
    clientId: it(),
    actions: ite
}), gM = cM("type", [
    st({
        ...Gk(ote, [
            "clientId"
        ]).entries
    }),
    st({
        ...Gk(ate, [
            "clientId"
        ]).entries
    })
]), ste = "wallet_requestPermissions", ute = mi(Pn(gM));
cr(!0);
st({
    ...Yr.entries,
    ...st({
        method: cr(ste),
        params: ute,
        id: it()
    }).entries
});
var cte = "wallet_renouncePermissions", lte = mi(Qi());
mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(cte),
        params: lte,
        id: it()
    }).entries
});
var fte = "wallet_disconnect", dte = mi(Qi());
mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(fte),
        params: dte,
        id: it()
    }).entries
});
var hte = "wallet_getWalletType", pte = mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(hte),
        params: pte,
        id: it()
    }).entries
});
var gte = "wallet_getCurrentPermissions", yte = mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(gte),
        params: yte,
        id: it()
    }).entries
});
var mte = "wallet_getNetwork", bte = mi(Qi());
st({
    bitcoin: st({
        name: Co(Qn)
    }),
    stacks: st({
        name: it()
    })
});
st({
    ...Yr.entries,
    ...st({
        method: cr(mte),
        params: bte,
        id: it()
    }).entries
});
var wte = "wallet_changeNetwork", Ate = st({
    name: Co(Qn)
});
mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(wte),
        params: Ate,
        id: it()
    }).entries
});
var vte = "wallet_getAccount", Ete = mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(vte),
        params: Ete,
        id: it()
    }).entries
});
var Ste = "wallet_connect", xte = mi(st({
    permissions: Xt(Pn(gM)),
    addresses: Xt(Pn(Co(yf))),
    message: Xt(R8(it(), nM(80, "The message must not exceed 80 characters."))),
    network: Xt(Co(Qn))
}));
st({
    ...Yr.entries,
    ...st({
        method: cr(Ste),
        params: xte,
        id: it()
    }).entries
});
var _te = "stx_getAccounts", kte = mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(_te),
        params: kte,
        id: it()
    }).entries
});
var Ote = "stx_getAddresses", Ite = mi(st({
    /**
     * A message to be displayed to the user in the request prompt.
     */ message: Xt(it())
}));
st({
    ...Yr.entries,
    ...st({
        method: cr(Ote),
        params: Ite,
        id: it()
    }).entries
});
var Bte = "stx_signMessage", Tte = st({
    /**
   * The message to sign.
   */ message: it()
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Bte),
        params: Tte,
        id: it()
    }).entries
});
var Pte = "stx_signStructuredMessage", Cte = st({
    /**
   * The domain to be signed.
   */ domain: it(),
    /**
   * Message payload to be signed.
   */ message: it(),
    /**
   * The public key to sign the message with.
   */ publicKey: Xt(it())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Pte),
        params: Cte,
        id: it()
    }).entries
});
var Mte = "stx_signTransaction", Nte = st({
    /**
   * The transaction to sign as a hex-encoded string.
   */ transaction: it(),
    /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */ pubkey: Xt(it()),
    /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */ broadcast: Xt(Mf())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Mte),
        params: Nte,
        id: it()
    }).entries
});
var Rte = "stx_signTransactions", Ute = st({
    /**
   * The transactions to sign as hex-encoded strings.
   */ transactions: R8(Pn(R8(it(), rM((e)=>!0, "Invalid hex-encoded Stacks transaction."))), iM(1)),
    /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */ broadcast: Xt(Mf())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Rte),
        params: Ute,
        id: it()
    }).entries
});
var Dte = "stx_transferStx", jte = st({
    /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */ amount: Nf([
        $n(),
        it()
    ]),
    /**
   * The recipeint's principal.
   */ recipient: it(),
    /**
   * A string representing the memo.
   */ memo: Xt(it()),
    /**
   * Version of parameter format.
   */ version: Xt(it()),
    /**
   * The mode of the post conditions.
   */ postConditionMode: Xt($n()),
    /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */ postConditions: Xt(Pn(it())),
    /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */ pubkey: Xt(it())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Dte),
        params: jte,
        id: it()
    }).entries
});
var Fte = "getInfo", zte = mi(Qi());
st({
    /**
   * Version of the wallet.
   */ version: it(),
    /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */ methods: Xt(Pn(it())),
    /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */ supports: Pn(it())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Fte),
        params: zte,
        id: it()
    }).entries
});
var Lte = "getAddresses", Hte = st({
    /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */ purposes: Pn(Co(yf)),
    /**
   * A message to be displayed to the user in the request prompt.
   */ message: Xt(it())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Lte),
        params: Hte,
        id: it()
    }).entries
});
var Kte = "signMessage", mf = /* @__PURE__ */ ((e)=>(e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(mf || {}), qte = st({
    /**
   * The address used for signing.
   **/ address: it(),
    /**
   * The message to sign.
   **/ message: it(),
    /**
   * The protocol to use for signing the message.
   */ protocol: Xt(Co(mf))
});
st({
    /**
   * The signature of the message.
   */ signature: it(),
    /**
   * hash of the message.
   */ messageHash: it(),
    /**
   * The address used for signing.
   */ address: it(),
    /**
   * The protocol to use for signing the message.
   */ protocol: Co(mf)
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Kte),
        params: qte,
        id: it()
    }).entries
});
var Vte = "sendTransfer", Wte = st({
    /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */ recipients: Pn(st({
        address: it(),
        amount: $n()
    }))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Vte),
        params: Wte,
        id: it()
    }).entries
});
var Gte = "signPsbt", Qte = st({
    /**
   * The base64 encoded PSBT to sign.
   */ psbt: it(),
    /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */ signInputs: uM(it(), Pn($n())),
    /**
   * Whether to broadcast the transaction after signing.
   **/ broadcast: Xt(Mf())
});
st({
    /**
   * The base64 encoded PSBT after signing.
   */ psbt: it(),
    /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/ txid: Xt(it())
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Gte),
        params: Qte,
        id: it()
    }).entries
});
var $te = "getAccounts", Zte = st({
    /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */ purposes: Pn(Co(yf)),
    /**
   * A message to be displayed to the user in the request prompt.
   */ message: Xt(it())
});
Pn(st({
    ...dM.entries,
    ...st({
        walletType: lM
    }).entries
}));
st({
    ...Yr.entries,
    ...st({
        method: cr($te),
        params: Zte,
        id: it()
    }).entries
});
var Xte = "getBalance";
mi(Qi());
st({
    ...Yr.entries,
    ...st({
        method: cr(Xte),
        id: it()
    }).entries
});
var Yte = "runes_etch", Jte = st({
    amount: it(),
    cap: it(),
    heightStart: Xt(it()),
    heightEnd: Xt(it()),
    offsetStart: Xt(it()),
    offsetEnd: Xt(it())
}), ere = st({
    contentType: it(),
    contentBase64: it()
}), tre = st({
    runeName: it(),
    divisibility: Xt($n()),
    symbol: Xt(it()),
    premine: Xt(it()),
    isMintable: Mf(),
    delegateInscriptionId: Xt(it()),
    destinationAddress: it(),
    refundAddress: it(),
    feeRate: $n(),
    appServiceFee: Xt($n()),
    appServiceFeeAddress: Xt(it()),
    terms: Xt(Jte),
    inscriptionDetails: Xt(ere),
    network: Xt(Co(Qn))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(Yte),
        params: tre,
        id: it()
    }).entries
});
var rre = "runes_getBalance", nre = mi(Qi());
st({
    balances: Pn(st({
        runeName: it(),
        amount: it(),
        divisibility: $n(),
        symbol: it(),
        inscriptionId: mi(it()),
        spendableBalance: it()
    }))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(rre),
        params: nre,
        id: it()
    }).entries
});
var ire = "runes_mint", ore = st({
    appServiceFee: Xt($n()),
    appServiceFeeAddress: Xt(it()),
    destinationAddress: it(),
    feeRate: $n(),
    refundAddress: it(),
    repeats: $n(),
    runeName: it(),
    network: Xt(Co(Qn))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(ire),
        params: ore,
        id: it()
    }).entries
});
var are = "runes_transfer", sre = st({
    recipients: Pn(st({
        runeName: it(),
        amount: it(),
        address: it()
    }))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(are),
        params: sre,
        id: it()
    }).entries
});
var ure = "ord_getInscriptions", cre = st({
    offset: $n(),
    limit: $n()
});
st({
    total: $n(),
    limit: $n(),
    offset: $n(),
    inscriptions: Pn(st({
        inscriptionId: it(),
        inscriptionNumber: it(),
        address: it(),
        collectionName: Xt(it()),
        postage: it(),
        contentLength: it(),
        contentType: it(),
        timestamp: $n(),
        offset: $n(),
        genesisTransaction: it(),
        output: it()
    }))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(ure),
        params: cre,
        id: it()
    }).entries
});
var lre = "ord_sendInscriptions", fre = st({
    transfers: Pn(st({
        address: it(),
        inscriptionId: it()
    }))
});
st({
    ...Yr.entries,
    ...st({
        method: cr(lre),
        params: fre,
        id: it()
    }).entries
});
var kl = async (e, t, r)=>{
    var n;
    let i1 = ((n = window.XverseProviders) == null ? void 0 : n.BitcoinProvider) || window.BitcoinProvider;
    if (!i1) throw new Error("no wallet provider was found");
    if (!e) throw new Error("A wallet method is required");
    const o = await i1.request(e, t);
    return Vk(pM, o) ? {
        status: "error",
        error: o.error
    } : Vk(hM, o) ? {
        status: "success",
        result: o.result
    } : {
        status: "error",
        error: {
            code: -32603,
            message: "Received unknown response from provider.",
            data: o
        }
    };
}, Zk = (e, t, r)=>{
    var n;
    let i1 = ((n = window.XverseProviders) == null ? void 0 : n.BitcoinProvider) || window.BitcoinProvider;
    if (!i1) throw new Error("no wallet provider was found");
    return i1.addListener ? i1.addListener(e, t) : (console.error("The wallet provider you are using does not support the addListener method. Please update your wallet provider."), ()=>{});
}, dre = async (e)=>{
    var t, r;
    const n = await J2(e.getProvider), { address: i1, message: o } = e.payload;
    if (!i1) throw new Error("An address is required to sign a message");
    if (!o) throw new Error("A message to be signed is required");
    try {
        const a = ta.createUnsecuredToken(e.payload), s = await n.signMessage(a);
        (t = e.onFinish) == null || t.call(e, s);
    } catch (a) {
        console.error("[Connect] Error during sign message request", a), (r = e.onCancel) == null || r.call(e);
    }
}, hre = (e)=>e.map((t)=>{
        const { address: r, amountSats: n } = t;
        return {
            address: r,
            amountSats: n.toString()
        };
    }), pre = async (e)=>{
    var t, r;
    const n = await J2(e.getProvider), { recipients: i1, senderAddress: o, network: a, message: s } = e.payload;
    if (!i1 || i1.length === 0) throw new Error("At least one recipient is required");
    if (i1.some((c)=>typeof c.address != "string" || typeof c.amountSats != "bigint")) throw new Error("Incorrect recipient format");
    if (!o) throw new Error("The sender address is required");
    try {
        const c = hre(i1), l = {
            network: a,
            senderAddress: o,
            message: s,
            recipients: c
        }, u = ta.createUnsecuredToken(l), f = await n.sendBtcTransaction(u);
        (t = e.onFinish) == null || t.call(e, f);
    } catch (c) {
        console.error("[Connect] Error during send BTC transaction request", c), (r = e.onCancel) == null || r.call(e);
    }
}, gre = async (e)=>{
    var t, r;
    const n = await J2(e.getProvider), { psbtBase64: i1, inputsToSign: o } = e.payload;
    if (!i1) throw new Error("A value for psbtBase64 representing the tx hash is required");
    if (!o) throw new Error("An array specifying the inputs to be signed by the wallet is required");
    try {
        const a = ta.createUnsecuredToken(e.payload), s = await n.signTransaction(a);
        (t = e.onFinish) == null || t.call(e, s);
    } catch (a) {
        console.error("[Connect] Error during sign transaction request", a), (r = e.onCancel) == null || r.call(e);
    }
};
const mn = pt.MAINNET, Xo = pt.SIGNET, Ki = pt.TESTNET, _o = pt.TESTNET4, Ku = pt.FRACTAL_MAINNET, ko = pt.FRACTAL_TESTNET, R3e = pt.REGTEST, yM = pt.OYLNET, h3 = (e)=>e === pt.MAINNET ? Qn.Mainnet : e === pt.TESTNET ? Qn.Testnet : e === pt.TESTNET4 ? Qn.Testnet4 : e === pt.SIGNET ? Qn.Signet : (e === pt.FRACTAL_MAINNET || pt.FRACTAL_TESTNET, Qn.Mainnet), U3e = (e)=>e === pt.MAINNET ? Hd.MAINNET : e === pt.TESTNET ? Hd.TESTNET : Hd.MAINNET, mM = (e)=>e === pt.MAINNET ? Ao.MAINNET : e === pt.TESTNET ? Ao.TESTNET : e === pt.TESTNET4 ? Ao.TESTNET4 : e === pt.SIGNET ? Ao.SIGNET : e === pt.FRACTAL_MAINNET ? Ao.FRACTAL_MAINNET : e === pt.FRACTAL_TESTNET ? Ao.FRACTAL_TESTNET : Ao.MAINNET, yre = (e)=>e === pt.MAINNET ? Kc.BITCOIN_MAINNET : e === pt.TESTNET ? Kc.BITCOIN_TESTNET : e === pt.SIGNET ? Kc.BITCOIN_SIGNET : Kc.BITCOIN_MAINNET, D3e = (e)=>e === pt.MAINNET ? Oa.MAINNET : e === pt.TESTNET ? Oa.TESTNET : e === pt.TESTNET4 ? Oa.TESTNET4 : e === pt.SIGNET ? Oa.SIGNET : e === pt.FRACTAL_TESTNET ? Oa.TESTNET : (pt.FRACTAL_MAINNET, Oa.MAINNET), p3 = (e)=>e === pt.MAINNET ? zy.MAINNET : e === pt.TESTNET || e === pt.TESTNET4 || e === pt.SIGNET ? zy.TESTNET : (e === pt.FRACTAL_MAINNET || pt.FRACTAL_TESTNET, zy.MAINNET), mre = (e)=>e === pt.MAINNET ? Dp.MAINNET : e === pt.TESTNET4 || e === pt.TESTNET ? Dp.TESTNET : e === pt.SIGNET ? Dp.SIGNET : (e === pt.MAINNET || pt.TESTNET, Dp.MAINNET), Am = (e)=>e === Ao.MAINNET ? pt.MAINNET : e === Ao.TESTNET ? pt.TESTNET : e === Ao.TESTNET4 ? pt.TESTNET4 : e === Ao.SIGNET ? pt.SIGNET : e === Ao.FRACTAL_MAINNET ? pt.FRACTAL_MAINNET : e === Ao.FRACTAL_TESTNET ? pt.TESTNET : pt.MAINNET, bre = (e)=>e === Kc.BITCOIN_MAINNET ? pt.MAINNET : e === Kc.BITCOIN_TESTNET ? pt.TESTNET : e === Kc.BITCOIN_SIGNET ? pt.SIGNET : pt.MAINNET, g3 = (e)=>e === Tl.MAINNET ? pt.MAINNET : e === Tl.TESTNET ? pt.TESTNET : e === Tl.TESTNET4 ? pt.TESTNET4 : e === Tl.SIGNET ? pt.SIGNET : e === Tl.FRACTAL_MAINNET ? pt.FRACTAL_MAINNET : e === Tl.FRACTAL_TESTNET ? pt.FRACTAL_TESTNET : pt.MAINNET, j3e = (e)=>e === Hd.MAINNET ? pt.MAINNET : e === Hd.TESTNET ? pt.TESTNET : pt.MAINNET, wre = (e)=>e === B8.MAINNET ? pt.MAINNET : e === B8.TESTNET ? pt.TESTNET : pt.MAINNET, Xk = (e)=>e === Oa.MAINNET ? pt.MAINNET : e === Oa.TESTNET ? pt.TESTNET : e === Oa.TESTNET4 ? pt.TESTNET4 : e === Oa.SIGNET ? pt.SIGNET : e === I8.TESTNET ? pt.TESTNET : (I8.MAINNET, pt.MAINNET);
function bM(e, t) {
    return function() {
        return e.apply(t, arguments);
    };
}
const { toString: Are } = Object.prototype, { getPrototypeOf: u5 } = Object, { iterator: eb, toStringTag: wM } = Symbol, tb = /* @__PURE__ */ ((e)=>(t)=>{
        const r = Are.call(t);
        return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null)), hs = (e)=>(e = e.toLowerCase(), (t)=>tb(t) === e), rb = (e)=>(t)=>typeof t === e, { isArray: Fh } = Array, b0 = rb("undefined");
function vre(e) {
    return e !== null && !b0(e) && e.constructor !== null && !b0(e.constructor) && To(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const AM = hs("ArrayBuffer");
function Ere(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && AM(e.buffer), t;
}
const Sre = rb("string"), To = rb("function"), vM = rb("number"), nb = (e)=>e !== null && typeof e == "object", xre = (e)=>e === !0 || e === !1, Ky = (e)=>{
    if (tb(e) !== "object") return !1;
    const t = u5(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(wM in e) && !(eb in e);
}, _re = hs("Date"), kre = hs("File"), Ore = hs("Blob"), Ire = hs("FileList"), Bre = (e)=>nb(e) && To(e.pipe), Tre = (e)=>{
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || To(e.append) && ((t = tb(e)) === "formdata" || // detect form-data instance
    t === "object" && To(e.toString) && e.toString() === "[object FormData]"));
}, Pre = hs("URLSearchParams"), [Cre, Mre, Nre, Rre] = [
    "ReadableStream",
    "Request",
    "Response",
    "Headers"
].map(hs), Ure = (e)=>e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function S1(e, t, { allOwnKeys: r = !1 } = {}) {
    if (e === null || typeof e > "u") return;
    let n, i1;
    if (typeof e != "object" && (e = [
        e
    ]), Fh(e)) for(n = 0, i1 = e.length; n < i1; n++)t.call(null, e[n], n, e);
    else {
        const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), a = o.length;
        let s;
        for(n = 0; n < a; n++)s = o[n], t.call(null, e[s], s, e);
    }
}
function EM(e, t) {
    t = t.toLowerCase();
    const r = Object.keys(e);
    let n = r.length, i1;
    for(; n-- > 0;)if (i1 = r[n], t === i1.toLowerCase()) return i1;
    return null;
}
const Vl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Gee, SM = (e)=>!b0(e) && e !== Vl;
function U8() {
    const { caseless: e } = SM(this) && this || {}, t = {}, r = (n, i1)=>{
        const o = e && EM(t, i1) || i1;
        Ky(t[o]) && Ky(n) ? t[o] = U8(t[o], n) : Ky(n) ? t[o] = U8({}, n) : Fh(n) ? t[o] = n.slice() : t[o] = n;
    };
    for(let n = 0, i1 = arguments.length; n < i1; n++)arguments[n] && S1(arguments[n], r);
    return t;
}
const Dre = (e, t, r, { allOwnKeys: n } = {})=>(S1(t, (i1, o)=>{
        r && To(i1) ? e[o] = bM(i1, r) : e[o] = i1;
    }, {
        allOwnKeys: n
    }), e), jre = (e)=>(e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Fre = (e, t, r, n)=>{
    e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
        value: t.prototype
    }), r && Object.assign(e.prototype, r);
}, zre = (e, t, r, n)=>{
    let i1, o, a;
    const s = {};
    if (t = t || {}, e == null) return t;
    do {
        for(i1 = Object.getOwnPropertyNames(e), o = i1.length; o-- > 0;)a = i1[o], (!n || n(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
        e = r !== !1 && u5(e);
    }while (e && (!r || r(e, t)) && e !== Object.prototype)
    return t;
}, Lre = (e, t, r)=>{
    e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
    const n = e.indexOf(t, r);
    return n !== -1 && n === r;
}, Hre = (e)=>{
    if (!e) return null;
    if (Fh(e)) return e;
    let t = e.length;
    if (!vM(t)) return null;
    const r = new Array(t);
    for(; t-- > 0;)r[t] = e[t];
    return r;
}, Kre = /* @__PURE__ */ ((e)=>(t)=>e && t instanceof e)(typeof Uint8Array < "u" && u5(Uint8Array)), qre = (e, t)=>{
    const r = (e && e[eb]).call(e);
    let n;
    for(; (n = r.next()) && !n.done;){
        const i1 = n.value;
        t.call(e, i1[0], i1[1]);
    }
}, Vre = (e, t)=>{
    let r;
    const n = [];
    for(; (r = e.exec(t)) !== null;)n.push(r);
    return n;
}, Wre = hs("HTMLFormElement"), Gre = (e)=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, r, n) {
        return r.toUpperCase() + n;
    }), Yk = (({ hasOwnProperty: e })=>(t, r)=>e.call(t, r))(Object.prototype), Qre = hs("RegExp"), xM = (e, t)=>{
    const r = Object.getOwnPropertyDescriptors(e), n = {};
    S1(r, (i1, o)=>{
        let a;
        (a = t(i1, o, e)) !== !1 && (n[o] = a || i1);
    }), Object.defineProperties(e, n);
}, $re = (e)=>{
    xM(e, (t, r)=>{
        if (To(e) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(r) !== -1) return !1;
        const n = e[r];
        if (To(n)) {
            if (t.enumerable = !1, "writable" in t) {
                t.writable = !1;
                return;
            }
            t.set || (t.set = ()=>{
                throw Error("Can not rewrite read-only method '" + r + "'");
            });
        }
    });
}, Zre = (e, t)=>{
    const r = {}, n = (i1)=>{
        i1.forEach((o)=>{
            r[o] = !0;
        });
    };
    return Fh(e) ? n(e) : n(String(e).split(t)), r;
}, Xre = ()=>{}, Yre = (e, t)=>e != null && Number.isFinite(e = +e) ? e : t;
function Jre(e) {
    return !!(e && To(e.append) && e[wM] === "FormData" && e[eb]);
}
const ene = (e)=>{
    const t = new Array(10), r = (n, i1)=>{
        if (nb(n)) {
            if (t.indexOf(n) >= 0) return;
            if (!("toJSON" in n)) {
                t[i1] = n;
                const o = Fh(n) ? [] : {};
                return S1(n, (a, s)=>{
                    const c = r(a, i1 + 1);
                    !b0(c) && (o[s] = c);
                }), t[i1] = void 0, o;
            }
        }
        return n;
    };
    return r(e, 0);
}, tne = hs("AsyncFunction"), rne = (e)=>e && (nb(e) || To(e)) && To(e.then) && To(e.catch), _M = ((e, t)=>e ? setImmediate : t ? ((r, n)=>(Vl.addEventListener("message", ({ source: i1, data: o })=>{
            i1 === Vl && o === r && n.length && n.shift()();
        }, !1), (i1)=>{
            n.push(i1), Vl.postMessage(r, "*");
        }))(`axios@${Math.random()}`, []) : (r)=>setTimeout(r))(typeof setImmediate == "function", To(Vl.postMessage)), nne = typeof queueMicrotask < "u" ? queueMicrotask.bind(Vl) : typeof xn < "u" && xn.nextTick || _M, ine = (e)=>e != null && To(e[eb]), Je = {
    isArray: Fh,
    isArrayBuffer: AM,
    isBuffer: vre,
    isFormData: Tre,
    isArrayBufferView: Ere,
    isString: Sre,
    isNumber: vM,
    isBoolean: xre,
    isObject: nb,
    isPlainObject: Ky,
    isReadableStream: Cre,
    isRequest: Mre,
    isResponse: Nre,
    isHeaders: Rre,
    isUndefined: b0,
    isDate: _re,
    isFile: kre,
    isBlob: Ore,
    isRegExp: Qre,
    isFunction: To,
    isStream: Bre,
    isURLSearchParams: Pre,
    isTypedArray: Kre,
    isFileList: Ire,
    forEach: S1,
    merge: U8,
    extend: Dre,
    trim: Ure,
    stripBOM: jre,
    inherits: Fre,
    toFlatObject: zre,
    kindOf: tb,
    kindOfTest: hs,
    endsWith: Lre,
    toArray: Hre,
    forEachEntry: qre,
    matchAll: Vre,
    isHTMLForm: Wre,
    hasOwnProperty: Yk,
    hasOwnProp: Yk,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: xM,
    freezeMethods: $re,
    toObjectSet: Zre,
    toCamelCase: Gre,
    noop: Xre,
    toFiniteNumber: Yre,
    findKey: EM,
    global: Vl,
    isContextDefined: SM,
    isSpecCompliantForm: Jre,
    toJSONObject: ene,
    isAsyncFn: tne,
    isThenable: rne,
    setImmediate: _M,
    asap: nne,
    isIterable: ine
};
function yr(e, t, r, n, i1) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i1 && (this.response = i1, this.status = i1.status ? i1.status : null);
}
Je.inherits(yr, Error, {
    toJSON: function() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: Je.toJSONObject(this.config),
            code: this.code,
            status: this.status
        };
    }
});
const kM = yr.prototype, OM = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((e)=>{
    OM[e] = {
        value: e
    };
});
Object.defineProperties(yr, OM);
Object.defineProperty(kM, "isAxiosError", {
    value: !0
});
yr.from = (e, t, r, n, i1, o)=>{
    const a = Object.create(kM);
    return Je.toFlatObject(e, a, function(s) {
        return s !== Error.prototype;
    }, (s)=>s !== "isAxiosError"), yr.call(a, e.message, t, r, n, i1), a.cause = e, a.name = e.name, o && Object.assign(a, o), a;
};
const one = null;
function D8(e) {
    return Je.isPlainObject(e) || Je.isArray(e);
}
function IM(e) {
    return Je.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Jk(e, t, r) {
    return e ? e.concat(t).map(function(n, i1) {
        return n = IM(n), !r && i1 ? "[" + n + "]" : n;
    }).join(r ? "." : "") : t;
}
function ane(e) {
    return Je.isArray(e) && !e.some(D8);
}
const sne = Je.toFlatObject(Je, {}, null, function(e) {
    return /^is[A-Z]/.test(e);
});
function ib(e, t, r) {
    if (!Je.isObject(e)) throw new TypeError("target must be an object");
    t = t || new FormData(), r = Je.toFlatObject(r, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(y, S) {
        return !Je.isUndefined(S[y]);
    });
    const n = r.metaTokens, i1 = r.visitor || l, o = r.dots, a = r.indexes, s = (r.Blob || typeof Blob < "u" && Blob) && Je.isSpecCompliantForm(t);
    if (!Je.isFunction(i1)) throw new TypeError("visitor must be a function");
    function c(y) {
        if (y === null) return "";
        if (Je.isDate(y)) return y.toISOString();
        if (Je.isBoolean(y)) return y.toString();
        if (!s && Je.isBlob(y)) throw new yr("Blob is not supported. Use a Buffer instead.");
        return Je.isArrayBuffer(y) || Je.isTypedArray(y) ? s && typeof Blob == "function" ? new Blob([
            y
        ]) : Ke.from(y) : y;
    }
    function l(y, S, k) {
        let P = y;
        if (y && !k && typeof y == "object") {
            if (Je.endsWith(S, "{}")) S = n ? S : S.slice(0, -2), y = JSON.stringify(y);
            else if (Je.isArray(y) && ane(y) || (Je.isFileList(y) || Je.endsWith(S, "[]")) && (P = Je.toArray(y))) return S = IM(S), P.forEach(function(M, N) {
                !(Je.isUndefined(M) || M === null) && t.append(// eslint-disable-next-line no-nested-ternary
                a === !0 ? Jk([
                    S
                ], N, o) : a === null ? S : S + "[]", c(M));
            }), !1;
        }
        return D8(y) ? !0 : (t.append(Jk(k, S, o), c(y)), !1);
    }
    const u = [], f = Object.assign(sne, {
        defaultVisitor: l,
        convertValue: c,
        isVisitable: D8
    });
    function h(y, S) {
        if (!Je.isUndefined(y)) {
            if (u.indexOf(y) !== -1) throw Error("Circular reference detected in " + S.join("."));
            u.push(y), Je.forEach(y, function(k, P) {
                (!(Je.isUndefined(k) || k === null) && i1.call(t, k, Je.isString(P) ? P.trim() : P, S, f)) === !0 && h(k, S ? S.concat(P) : [
                    P
                ]);
            }), u.pop();
        }
    }
    if (!Je.isObject(e)) throw new TypeError("data must be an object");
    return h(e), t;
}
function eO(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
        return t[r];
    });
}
function c5(e, t) {
    this._pairs = [], e && ib(e, this, t);
}
const BM = c5.prototype;
BM.append = function(e, t) {
    this._pairs.push([
        e,
        t
    ]);
};
BM.toString = function(e) {
    const t = e ? function(r) {
        return e.call(this, r, eO);
    } : eO;
    return this._pairs.map(function(r) {
        return t(r[0]) + "=" + t(r[1]);
    }, "").join("&");
};
function une(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function TM(e, t, r) {
    if (!t) return e;
    const n = r && r.encode || une;
    Je.isFunction(r) && (r = {
        serialize: r
    });
    const i1 = r && r.serialize;
    let o;
    if (i1 ? o = i1(t, r) : o = Je.isURLSearchParams(t) ? t.toString() : new c5(t, r).toString(n), o) {
        const a = e.indexOf("#");
        a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
    }
    return e;
}
class tO {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(t, r, n) {
        return this.handlers.push({
            fulfilled: t,
            rejected: r,
            synchronous: n ? n.synchronous : !1,
            runWhen: n ? n.runWhen : null
        }), this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(t) {
        this.handlers[t] && (this.handlers[t] = null);
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        this.handlers && (this.handlers = []);
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(t) {
        Je.forEach(this.handlers, function(r) {
            r !== null && t(r);
        });
    }
}
const PM = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}, cne = typeof URLSearchParams < "u" ? URLSearchParams : c5, lne = typeof FormData < "u" ? FormData : null, fne = typeof Blob < "u" ? Blob : null, dne = {
    isBrowser: !0,
    classes: {
        URLSearchParams: cne,
        FormData: lne,
        Blob: fne
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
}, l5 = typeof window < "u" && typeof document < "u", j8 = typeof navigator == "object" && navigator || void 0, hne = l5 && (!j8 || [
    "ReactNative",
    "NativeScript",
    "NS"
].indexOf(j8.product) < 0), pne = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", gne = l5 && window.location.href || "http://localhost", yne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: l5,
    hasStandardBrowserEnv: hne,
    hasStandardBrowserWebWorkerEnv: pne,
    navigator: j8,
    origin: gne
}, Symbol.toStringTag, {
    value: "Module"
})), qi = {
    ...yne,
    ...dne
};
function mne(e, t) {
    return ib(e, new qi.classes.URLSearchParams(), Object.assign({
        visitor: function(r, n, i1, o) {
            return qi.isNode && Je.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
        }
    }, t));
}
function bne(e) {
    return Je.matchAll(/\w+|\[(\w*)]/g, e).map((t)=>t[0] === "[]" ? "" : t[1] || t[0]);
}
function wne(e) {
    const t = {}, r = Object.keys(e);
    let n;
    const i1 = r.length;
    let o;
    for(n = 0; n < i1; n++)o = r[n], t[o] = e[o];
    return t;
}
function CM(e) {
    function t(r, n, i1, o) {
        let a = r[o++];
        if (a === "__proto__") return !0;
        const s = Number.isFinite(+a), c = o >= r.length;
        return a = !a && Je.isArray(i1) ? i1.length : a, c ? (Je.hasOwnProp(i1, a) ? i1[a] = [
            i1[a],
            n
        ] : i1[a] = n, !s) : ((!i1[a] || !Je.isObject(i1[a])) && (i1[a] = []), t(r, n, i1[a], o) && Je.isArray(i1[a]) && (i1[a] = wne(i1[a])), !s);
    }
    if (Je.isFormData(e) && Je.isFunction(e.entries)) {
        const r = {};
        return Je.forEachEntry(e, (n, i1)=>{
            t(bne(n), i1, r, 0);
        }), r;
    }
    return null;
}
function Ane(e, t, r) {
    if (Je.isString(e)) try {
        return (t || JSON.parse)(e), Je.trim(e);
    } catch (n) {
        if (n.name !== "SyntaxError") throw n;
    }
    return (r || JSON.stringify)(e);
}
const x1 = {
    transitional: PM,
    adapter: [
        "xhr",
        "http",
        "fetch"
    ],
    transformRequest: [
        function(e, t) {
            const r = t.getContentType() || "", n = r.indexOf("application/json") > -1, i1 = Je.isObject(e);
            if (i1 && Je.isHTMLForm(e) && (e = new FormData(e)), Je.isFormData(e)) return n ? JSON.stringify(CM(e)) : e;
            if (Je.isArrayBuffer(e) || Je.isBuffer(e) || Je.isStream(e) || Je.isFile(e) || Je.isBlob(e) || Je.isReadableStream(e)) return e;
            if (Je.isArrayBufferView(e)) return e.buffer;
            if (Je.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
            let o;
            if (i1) {
                if (r.indexOf("application/x-www-form-urlencoded") > -1) return mne(e, this.formSerializer).toString();
                if ((o = Je.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                    const a = this.env && this.env.FormData;
                    return ib(o ? {
                        "files[]": e
                    } : e, a && new a(), this.formSerializer);
                }
            }
            return i1 || n ? (t.setContentType("application/json", !1), Ane(e)) : e;
        }
    ],
    transformResponse: [
        function(e) {
            const t = this.transitional || x1.transitional, r = t && t.forcedJSONParsing, n = this.responseType === "json";
            if (Je.isResponse(e) || Je.isReadableStream(e)) return e;
            if (e && Je.isString(e) && (r && !this.responseType || n)) {
                const i1 = !(t && t.silentJSONParsing) && n;
                try {
                    return JSON.parse(e);
                } catch (o) {
                    if (i1) throw o.name === "SyntaxError" ? yr.from(o, yr.ERR_BAD_RESPONSE, this, null, this.response) : o;
                }
            }
            return e;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: qi.classes.FormData,
        Blob: qi.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300;
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Je.forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (e)=>{
    x1.headers[e] = {};
});
const vne = Je.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]), Ene = (e)=>{
    const t = {};
    let r, n, i1;
    return e && e.split(`
`).forEach(function(o) {
        i1 = o.indexOf(":"), r = o.substring(0, i1).trim().toLowerCase(), n = o.substring(i1 + 1).trim(), !(!r || t[r] && vne[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [
            n
        ] : t[r] = t[r] ? t[r] + ", " + n : n);
    }), t;
}, rO = Symbol("internals");
function Sp(e) {
    return e && String(e).trim().toLowerCase();
}
function qy(e) {
    return e === !1 || e == null ? e : Je.isArray(e) ? e.map(qy) : String(e);
}
function Sne(e) {
    const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let n;
    for(; n = r.exec(e);)t[n[1]] = n[2];
    return t;
}
const xne = (e)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function y3(e, t, r, n, i1) {
    if (Je.isFunction(n)) return n.call(this, t, r);
    if (i1 && (t = r), !!Je.isString(t)) {
        if (Je.isString(n)) return t.indexOf(n) !== -1;
        if (Je.isRegExp(n)) return n.test(t);
    }
}
function _ne(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n)=>r.toUpperCase() + n);
}
function kne(e, t) {
    const r = Je.toCamelCase(" " + t);
    [
        "get",
        "set",
        "has"
    ].forEach((n)=>{
        Object.defineProperty(e, n + r, {
            value: function(i1, o, a) {
                return this[n].call(this, t, i1, o, a);
            },
            configurable: !0
        });
    });
}
let Po = class {
    constructor(e){
        e && this.set(e);
    }
    set(e, t, r) {
        const n = this;
        function i1(a, s, c) {
            const l = Sp(s);
            if (!l) throw new Error("header name must be a non-empty string");
            const u = Je.findKey(n, l);
            (!u || n[u] === void 0 || c === !0 || c === void 0 && n[u] !== !1) && (n[u || s] = qy(a));
        }
        const o = (a, s)=>Je.forEach(a, (c, l)=>i1(c, l, s));
        if (Je.isPlainObject(e) || e instanceof this.constructor) o(e, t);
        else if (Je.isString(e) && (e = e.trim()) && !xne(e)) o(Ene(e), t);
        else if (Je.isObject(e) && Je.isIterable(e)) {
            let a = {}, s, c;
            for (const l of e){
                if (!Je.isArray(l)) throw TypeError("Object iterator must return a key-value pair");
                a[c = l[0]] = (s = a[c]) ? Je.isArray(s) ? [
                    ...s,
                    l[1]
                ] : [
                    s,
                    l[1]
                ] : l[1];
            }
            o(a, t);
        } else e != null && i1(t, e, r);
        return this;
    }
    get(e, t) {
        if (e = Sp(e), e) {
            const r = Je.findKey(this, e);
            if (r) {
                const n = this[r];
                if (!t) return n;
                if (t === !0) return Sne(n);
                if (Je.isFunction(t)) return t.call(this, n, r);
                if (Je.isRegExp(t)) return t.exec(n);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(e, t) {
        if (e = Sp(e), e) {
            const r = Je.findKey(this, e);
            return !!(r && this[r] !== void 0 && (!t || y3(this, this[r], r, t)));
        }
        return !1;
    }
    delete(e, t) {
        const r = this;
        let n = !1;
        function i1(o) {
            if (o = Sp(o), o) {
                const a = Je.findKey(r, o);
                a && (!t || y3(r, r[a], a, t)) && (delete r[a], n = !0);
            }
        }
        return Je.isArray(e) ? e.forEach(i1) : i1(e), n;
    }
    clear(e) {
        const t = Object.keys(this);
        let r = t.length, n = !1;
        for(; r--;){
            const i1 = t[r];
            (!e || y3(this, this[i1], i1, e, !0)) && (delete this[i1], n = !0);
        }
        return n;
    }
    normalize(e) {
        const t = this, r = {};
        return Je.forEach(this, (n, i1)=>{
            const o = Je.findKey(r, i1);
            if (o) {
                t[o] = qy(n), delete t[i1];
                return;
            }
            const a = e ? _ne(i1) : String(i1).trim();
            a !== i1 && delete t[i1], t[a] = qy(n), r[a] = !0;
        }), this;
    }
    concat(...e) {
        return this.constructor.concat(this, ...e);
    }
    toJSON(e) {
        const t = /* @__PURE__ */ Object.create(null);
        return Je.forEach(this, (r, n)=>{
            r != null && r !== !1 && (t[n] = e && Je.isArray(r) ? r.join(", ") : r);
        }), t;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([e, t])=>e + ": " + t).join(`
`);
    }
    getSetCookie() {
        return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(e) {
        return e instanceof this ? e : new this(e);
    }
    static concat(e, ...t) {
        const r = new this(e);
        return t.forEach((n)=>r.set(n)), r;
    }
    static accessor(e) {
        const t = (this[rO] = this[rO] = {
            accessors: {}
        }).accessors, r = this.prototype;
        function n(i1) {
            const o = Sp(i1);
            t[o] || (kne(r, i1), t[o] = !0);
        }
        return Je.isArray(e) ? e.forEach(n) : n(e), this;
    }
};
Po.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
Je.reduceDescriptors(Po.prototype, ({ value: e }, t)=>{
    let r = t[0].toUpperCase() + t.slice(1);
    return {
        get: ()=>e,
        set (n) {
            this[r] = n;
        }
    };
});
Je.freezeMethods(Po);
function m3(e, t) {
    const r = this || x1, n = t || r, i1 = Po.from(n.headers);
    let o = n.data;
    return Je.forEach(e, function(a) {
        o = a.call(r, o, i1.normalize(), t ? t.status : void 0);
    }), i1.normalize(), o;
}
function MM(e) {
    return !!(e && e.__CANCEL__);
}
function zh(e, t, r) {
    yr.call(this, e ?? "canceled", yr.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Je.inherits(zh, yr, {
    __CANCEL__: !0
});
function NM(e, t, r) {
    const n = r.config.validateStatus;
    !r.status || !n || n(r.status) ? e(r) : t(new yr("Request failed with status code " + r.status, [
        yr.ERR_BAD_REQUEST,
        yr.ERR_BAD_RESPONSE
    ][Math.floor(r.status / 100) - 4], r.config, r.request, r));
}
function One(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
}
function Ine(e, t) {
    e = e || 10;
    const r = new Array(e), n = new Array(e);
    let i1 = 0, o = 0, a;
    return t = t !== void 0 ? t : 1e3, function(s) {
        const c = Date.now(), l = n[o];
        a || (a = c), r[i1] = s, n[i1] = c;
        let u = o, f = 0;
        for(; u !== i1;)f += r[u++], u = u % e;
        if (i1 = (i1 + 1) % e, i1 === o && (o = (o + 1) % e), c - a < t) return;
        const h = l && c - l;
        return h ? Math.round(f * 1e3 / h) : void 0;
    };
}
function Bne(e, t) {
    let r = 0, n = 1e3 / t, i1, o;
    const a = (s, c = Date.now())=>{
        r = c, i1 = null, o && (clearTimeout(o), o = null), e.apply(null, s);
    };
    return [
        (...s)=>{
            const c = Date.now(), l = c - r;
            l >= n ? a(s, c) : (i1 = s, o || (o = setTimeout(()=>{
                o = null, a(i1);
            }, n - l)));
        },
        ()=>i1 && a(i1)
    ];
}
const vm = (e, t, r = 3)=>{
    let n = 0;
    const i1 = Ine(50, 250);
    return Bne((o)=>{
        const a = o.loaded, s = o.lengthComputable ? o.total : void 0, c = a - n, l = i1(c), u = a <= s;
        n = a;
        const f = {
            loaded: a,
            total: s,
            progress: s ? a / s : void 0,
            bytes: c,
            rate: l || void 0,
            estimated: l && s && u ? (s - a) / l : void 0,
            event: o,
            lengthComputable: s != null,
            [t ? "download" : "upload"]: !0
        };
        e(f);
    }, r);
}, nO = (e, t)=>{
    const r = e != null;
    return [
        (n)=>t[0]({
                lengthComputable: r,
                total: e,
                loaded: n
            }),
        t[1]
    ];
}, iO = (e)=>(...t)=>Je.asap(()=>e(...t)), Tne = qi.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t)=>(r)=>(r = new URL(r, qi.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(new URL(qi.origin), qi.navigator && /(msie|trident)/i.test(qi.navigator.userAgent)) : ()=>!0, Pne = qi.hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (e, t, r, n, i1, o) {
        const a = [
            e + "=" + encodeURIComponent(t)
        ];
        Je.isNumber(r) && a.push("expires=" + new Date(r).toGMTString()), Je.isString(n) && a.push("path=" + n), Je.isString(i1) && a.push("domain=" + i1), o === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read (e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null;
    },
    remove (e) {
        this.write(e, "", Date.now() - 864e5);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};
function Cne(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Mne(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function RM(e, t, r) {
    let n = !Cne(t);
    return e && (n || r == !1) ? Mne(e, t) : t;
}
const oO = (e)=>e instanceof Po ? {
        ...e
    } : e;
function bf(e, t) {
    t = t || {};
    const r = {};
    function n(l, u, f, h) {
        return Je.isPlainObject(l) && Je.isPlainObject(u) ? Je.merge.call({
            caseless: h
        }, l, u) : Je.isPlainObject(u) ? Je.merge({}, u) : Je.isArray(u) ? u.slice() : u;
    }
    function i1(l, u, f, h) {
        if (Je.isUndefined(u)) {
            if (!Je.isUndefined(l)) return n(void 0, l, f, h);
        } else return n(l, u, f, h);
    }
    function o(l, u) {
        if (!Je.isUndefined(u)) return n(void 0, u);
    }
    function a(l, u) {
        if (Je.isUndefined(u)) {
            if (!Je.isUndefined(l)) return n(void 0, l);
        } else return n(void 0, u);
    }
    function s(l, u, f) {
        if (f in t) return n(l, u);
        if (f in e) return n(void 0, l);
    }
    const c = {
        url: o,
        method: o,
        data: o,
        baseURL: a,
        transformRequest: a,
        transformResponse: a,
        paramsSerializer: a,
        timeout: a,
        timeoutMessage: a,
        withCredentials: a,
        withXSRFToken: a,
        adapter: a,
        responseType: a,
        xsrfCookieName: a,
        xsrfHeaderName: a,
        onUploadProgress: a,
        onDownloadProgress: a,
        decompress: a,
        maxContentLength: a,
        maxBodyLength: a,
        beforeRedirect: a,
        transport: a,
        httpAgent: a,
        httpsAgent: a,
        cancelToken: a,
        socketPath: a,
        responseEncoding: a,
        validateStatus: s,
        headers: (l, u, f)=>i1(oO(l), oO(u), f, !0)
    };
    return Je.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
        const u = c[l] || i1, f = u(e[l], t[l], l);
        Je.isUndefined(f) && u !== s || (r[l] = f);
    }), r;
}
const UM = (e)=>{
    const t = bf({}, e);
    let { data: r, withXSRFToken: n, xsrfHeaderName: i1, xsrfCookieName: o, headers: a, auth: s } = t;
    t.headers = a = Po.from(a), t.url = TM(RM(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), s && a.set("Authorization", "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : "")));
    let c;
    if (Je.isFormData(r)) {
        if (qi.hasStandardBrowserEnv || qi.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0);
        else if ((c = a.getContentType()) !== !1) {
            const [l, ...u] = c ? c.split(";").map((f)=>f.trim()).filter(Boolean) : [];
            a.setContentType([
                l || "multipart/form-data",
                ...u
            ].join("; "));
        }
    }
    if (qi.hasStandardBrowserEnv && (n && Je.isFunction(n) && (n = n(t)), n || n !== !1 && Tne(t.url))) {
        const l = i1 && o && Pne.read(o);
        l && a.set(i1, l);
    }
    return t;
}, Nne = typeof XMLHttpRequest < "u", Rne = Nne && function(e) {
    return new Promise(function(t, r) {
        const n = UM(e);
        let i1 = n.data;
        const o = Po.from(n.headers).normalize();
        let { responseType: a, onUploadProgress: s, onDownloadProgress: c } = n, l, u, f, h, y;
        function S() {
            h && h(), y && y(), n.cancelToken && n.cancelToken.unsubscribe(l), n.signal && n.signal.removeEventListener("abort", l);
        }
        let k = new XMLHttpRequest();
        k.open(n.method.toUpperCase(), n.url, !0), k.timeout = n.timeout;
        function P() {
            if (!k) return;
            const N = Po.from("getAllResponseHeaders" in k && k.getAllResponseHeaders()), z = {
                data: !a || a === "text" || a === "json" ? k.responseText : k.response,
                status: k.status,
                statusText: k.statusText,
                headers: N,
                config: e,
                request: k
            };
            NM(function(K) {
                t(K), S();
            }, function(K) {
                r(K), S();
            }, z), k = null;
        }
        "onloadend" in k ? k.onloadend = P : k.onreadystatechange = function() {
            !k || k.readyState !== 4 || k.status === 0 && !(k.responseURL && k.responseURL.indexOf("file:") === 0) || setTimeout(P);
        }, k.onabort = function() {
            k && (r(new yr("Request aborted", yr.ECONNABORTED, e, k)), k = null);
        }, k.onerror = function() {
            r(new yr("Network Error", yr.ERR_NETWORK, e, k)), k = null;
        }, k.ontimeout = function() {
            let N = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
            const z = n.transitional || PM;
            n.timeoutErrorMessage && (N = n.timeoutErrorMessage), r(new yr(N, z.clarifyTimeoutError ? yr.ETIMEDOUT : yr.ECONNABORTED, e, k)), k = null;
        }, i1 === void 0 && o.setContentType(null), "setRequestHeader" in k && Je.forEach(o.toJSON(), function(N, z) {
            k.setRequestHeader(z, N);
        }), Je.isUndefined(n.withCredentials) || (k.withCredentials = !!n.withCredentials), a && a !== "json" && (k.responseType = n.responseType), c && ([f, y] = vm(c, !0), k.addEventListener("progress", f)), s && k.upload && ([u, h] = vm(s), k.upload.addEventListener("progress", u), k.upload.addEventListener("loadend", h)), (n.cancelToken || n.signal) && (l = (N)=>{
            k && (r(!N || N.type ? new zh(null, e, k) : N), k.abort(), k = null);
        }, n.cancelToken && n.cancelToken.subscribe(l), n.signal && (n.signal.aborted ? l() : n.signal.addEventListener("abort", l)));
        const M = One(n.url);
        if (M && qi.protocols.indexOf(M) === -1) {
            r(new yr("Unsupported protocol " + M + ":", yr.ERR_BAD_REQUEST, e));
            return;
        }
        k.send(i1 || null);
    });
}, Une = (e, t)=>{
    const { length: r } = e = e ? e.filter(Boolean) : [];
    if (t || r) {
        let n = new AbortController(), i1;
        const o = function(l) {
            if (!i1) {
                i1 = !0, s();
                const u = l instanceof Error ? l : this.reason;
                n.abort(u instanceof yr ? u : new zh(u instanceof Error ? u.message : u));
            }
        };
        let a = t && setTimeout(()=>{
            a = null, o(new yr(`timeout ${t} of ms exceeded`, yr.ETIMEDOUT));
        }, t);
        const s = ()=>{
            e && (a && clearTimeout(a), a = null, e.forEach((l)=>{
                l.unsubscribe ? l.unsubscribe(o) : l.removeEventListener("abort", o);
            }), e = null);
        };
        e.forEach((l)=>l.addEventListener("abort", o));
        const { signal: c } = n;
        return c.unsubscribe = ()=>Je.asap(s), c;
    }
}, Dne = function*(e, t) {
    let r = e.byteLength;
    if (r < t) {
        yield e;
        return;
    }
    let n = 0, i1;
    for(; n < r;)i1 = n + t, yield e.slice(n, i1), n = i1;
}, jne = async function*(e, t) {
    for await (const r of Fne(e))yield* Dne(r, t);
}, Fne = async function*(e) {
    if (e[Symbol.asyncIterator]) {
        yield* e;
        return;
    }
    const t = e.getReader();
    try {
        for(;;){
            const { done: r, value: n } = await t.read();
            if (r) break;
            yield n;
        }
    } finally{
        await t.cancel();
    }
}, aO = (e, t, r, n)=>{
    const i1 = jne(e, t);
    let o = 0, a, s = (c)=>{
        a || (a = !0, n && n(c));
    };
    return new ReadableStream({
        async pull (c) {
            try {
                const { done: l, value: u } = await i1.next();
                if (l) {
                    s(), c.close();
                    return;
                }
                let f = u.byteLength;
                if (r) {
                    let h = o += f;
                    r(h);
                }
                c.enqueue(new Uint8Array(u));
            } catch (l) {
                throw s(l), l;
            }
        },
        cancel (c) {
            return s(c), i1.return();
        }
    }, {
        highWaterMark: 2
    });
}, ob = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", DM = ob && typeof ReadableStream == "function", zne = ob && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e)=>(t)=>e.encode(t))(new TextEncoder()) : async (e)=>new Uint8Array(await new Response(e).arrayBuffer())), jM = (e, ...t)=>{
    try {
        return !!e(...t);
    } catch  {
        return !1;
    }
}, Lne = DM && jM(()=>{
    let e = !1;
    const t = new Request(qi.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex () {
            return e = !0, "half";
        }
    }).headers.has("Content-Type");
    return e && !t;
}), sO = 64 * 1024, F8 = DM && jM(()=>Je.isReadableStream(new Response("").body)), Em = {
    stream: F8 && ((e)=>e.body)
};
ob && ((e)=>{
    [
        "text",
        "arrayBuffer",
        "blob",
        "formData",
        "stream"
    ].forEach((t)=>{
        !Em[t] && (Em[t] = Je.isFunction(e[t]) ? (r)=>r[t]() : (r, n)=>{
            throw new yr(`Response type '${t}' is not supported`, yr.ERR_NOT_SUPPORT, n);
        });
    });
})(new Response());
const Hne = async (e)=>{
    if (e == null) return 0;
    if (Je.isBlob(e)) return e.size;
    if (Je.isSpecCompliantForm(e)) return (await new Request(qi.origin, {
        method: "POST",
        body: e
    }).arrayBuffer()).byteLength;
    if (Je.isArrayBufferView(e) || Je.isArrayBuffer(e)) return e.byteLength;
    if (Je.isURLSearchParams(e) && (e = e + ""), Je.isString(e)) return (await zne(e)).byteLength;
}, Kne = async (e, t)=>Je.toFiniteNumber(e.getContentLength()) ?? Hne(t), qne = ob && (async (e)=>{
    let { url: t, method: r, data: n, signal: i1, cancelToken: o, timeout: a, onDownloadProgress: s, onUploadProgress: c, responseType: l, headers: u, withCredentials: f = "same-origin", fetchOptions: h } = UM(e);
    l = l ? (l + "").toLowerCase() : "text";
    let y = Une([
        i1,
        o && o.toAbortSignal()
    ], a), S;
    const k = y && y.unsubscribe && (()=>{
        y.unsubscribe();
    });
    let P;
    try {
        if (c && Lne && r !== "get" && r !== "head" && (P = await Kne(u, n)) !== 0) {
            let $ = new Request(t, {
                method: "POST",
                body: n,
                duplex: "half"
            }), ne;
            if (Je.isFormData(n) && (ne = $.headers.get("content-type")) && u.setContentType(ne), $.body) {
                const [ee, q] = nO(P, vm(iO(c)));
                n = aO($.body, sO, ee, q);
            }
        }
        Je.isString(f) || (f = f ? "include" : "omit");
        const M = "credentials" in Request.prototype;
        S = new Request(t, {
            ...h,
            signal: y,
            method: r.toUpperCase(),
            headers: u.normalize().toJSON(),
            body: n,
            duplex: "half",
            credentials: M ? f : void 0
        });
        let N = await fetch(S, h);
        const z = F8 && (l === "stream" || l === "response");
        if (F8 && (s || z && k)) {
            const $ = {};
            [
                "status",
                "statusText",
                "headers"
            ].forEach((U)=>{
                $[U] = N[U];
            });
            const ne = Je.toFiniteNumber(N.headers.get("content-length")), [ee, q] = s && nO(ne, vm(iO(s), !0)) || [];
            N = new Response(aO(N.body, sO, ee, ()=>{
                q && q(), k && k();
            }), $);
        }
        l = l || "text";
        let K = await Em[Je.findKey(Em, l) || "text"](N, e);
        return !z && k && k(), await new Promise(($, ne)=>{
            NM($, ne, {
                data: K,
                headers: Po.from(N.headers),
                status: N.status,
                statusText: N.statusText,
                config: e,
                request: S
            });
        });
    } catch (M) {
        throw k && k(), M && M.name === "TypeError" && /Load failed|fetch/i.test(M.message) ? Object.assign(new yr("Network Error", yr.ERR_NETWORK, e, S), {
            cause: M.cause || M
        }) : yr.from(M, M && M.code, e, S);
    }
}), z8 = {
    http: one,
    xhr: Rne,
    fetch: qne
};
Je.forEach(z8, (e, t)=>{
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            });
        } catch  {}
        Object.defineProperty(e, "adapterName", {
            value: t
        });
    }
});
const uO = (e)=>`- ${e}`, Vne = (e)=>Je.isFunction(e) || e === null || e === !1, FM = {
    getAdapter: (e)=>{
        e = Je.isArray(e) ? e : [
            e
        ];
        const { length: t } = e;
        let r, n;
        const i1 = {};
        for(let o = 0; o < t; o++){
            r = e[o];
            let a;
            if (n = r, !Vne(r) && (n = z8[(a = String(r)).toLowerCase()], n === void 0)) throw new yr(`Unknown adapter '${a}'`);
            if (n) break;
            i1[a || "#" + o] = n;
        }
        if (!n) {
            const o = Object.entries(i1).map(([s, c])=>`adapter ${s} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build"));
            let a = t ? o.length > 1 ? `since :
` + o.map(uO).join(`
`) : " " + uO(o[0]) : "as no adapter specified";
            throw new yr("There is no suitable adapter to dispatch the request " + a, "ERR_NOT_SUPPORT");
        }
        return n;
    },
    adapters: z8
};
function b3(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new zh(null, e);
}
function cO(e) {
    return b3(e), e.headers = Po.from(e.headers), e.data = m3.call(e, e.transformRequest), [
        "post",
        "put",
        "patch"
    ].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), FM.getAdapter(e.adapter || x1.adapter)(e).then(function(t) {
        return b3(e), t.data = m3.call(e, e.transformResponse, t), t.headers = Po.from(t.headers), t;
    }, function(t) {
        return MM(t) || (b3(e), t && t.response && (t.response.data = m3.call(e, e.transformResponse, t.response), t.response.headers = Po.from(t.response.headers))), Promise.reject(t);
    });
}
const zM = "1.10.0", ab = {};
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((e, t)=>{
    ab[e] = function(r) {
        return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
    };
});
const lO = {};
ab.transitional = function(e, t, r) {
    function n(i1, o) {
        return "[Axios v" + zM + "] Transitional option '" + i1 + "'" + o + (r ? ". " + r : "");
    }
    return (i1, o, a)=>{
        if (e === !1) throw new yr(n(o, " has been removed" + (t ? " in " + t : "")), yr.ERR_DEPRECATED);
        return t && !lO[o] && (lO[o] = !0, console.warn(n(o, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(i1, o, a) : !0;
    };
};
ab.spelling = function(e) {
    return (t, r)=>(console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function Wne(e, t, r) {
    if (typeof e != "object") throw new yr("options must be an object", yr.ERR_BAD_OPTION_VALUE);
    const n = Object.keys(e);
    let i1 = n.length;
    for(; i1-- > 0;){
        const o = n[i1], a = t[o];
        if (a) {
            const s = e[o], c = s === void 0 || a(s, o, e);
            if (c !== !0) throw new yr("option " + o + " must be " + c, yr.ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (r !== !0) throw new yr("Unknown option " + o, yr.ERR_BAD_OPTION);
    }
}
const Vy = {
    assertOptions: Wne,
    validators: ab
}, vs = Vy.validators;
let uf = class {
    constructor(e){
        this.defaults = e || {}, this.interceptors = {
            request: new tO(),
            response: new tO()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(e, t) {
        try {
            return await this._request(e, t);
        } catch (r) {
            if (r instanceof Error) {
                let n = {};
                Error.captureStackTrace ? Error.captureStackTrace(n) : n = new Error();
                const i1 = n.stack ? n.stack.replace(/^.+\n/, "") : "";
                try {
                    r.stack ? i1 && !String(r.stack).endsWith(i1.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + i1) : r.stack = i1;
                } catch  {}
            }
            throw r;
        }
    }
    _request(e, t) {
        typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = bf(this.defaults, t);
        const { transitional: r, paramsSerializer: n, headers: i1 } = t;
        r !== void 0 && Vy.assertOptions(r, {
            silentJSONParsing: vs.transitional(vs.boolean),
            forcedJSONParsing: vs.transitional(vs.boolean),
            clarifyTimeoutError: vs.transitional(vs.boolean)
        }, !1), n != null && (Je.isFunction(n) ? t.paramsSerializer = {
            serialize: n
        } : Vy.assertOptions(n, {
            encode: vs.function,
            serialize: vs.function
        }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Vy.assertOptions(t, {
            baseUrl: vs.spelling("baseURL"),
            withXsrfToken: vs.spelling("withXSRFToken")
        }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
        let o = i1 && Je.merge(i1.common, i1[t.method]);
        i1 && Je.forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (y)=>{
            delete i1[y];
        }), t.headers = Po.concat(o, i1);
        const a = [];
        let s = !0;
        this.interceptors.request.forEach(function(y) {
            typeof y.runWhen == "function" && y.runWhen(t) === !1 || (s = s && y.synchronous, a.unshift(y.fulfilled, y.rejected));
        });
        const c = [];
        this.interceptors.response.forEach(function(y) {
            c.push(y.fulfilled, y.rejected);
        });
        let l, u = 0, f;
        if (!s) {
            const y = [
                cO.bind(this),
                void 0
            ];
            for(y.unshift.apply(y, a), y.push.apply(y, c), f = y.length, l = Promise.resolve(t); u < f;)l = l.then(y[u++], y[u++]);
            return l;
        }
        f = a.length;
        let h = t;
        for(u = 0; u < f;){
            const y = a[u++], S = a[u++];
            try {
                h = y(h);
            } catch (k) {
                S.call(this, k);
                break;
            }
        }
        try {
            l = cO.call(this, h);
        } catch (y) {
            return Promise.reject(y);
        }
        for(u = 0, f = c.length; u < f;)l = l.then(c[u++], c[u++]);
        return l;
    }
    getUri(e) {
        e = bf(this.defaults, e);
        const t = RM(e.baseURL, e.url, e.allowAbsoluteUrls);
        return TM(t, e.params, e.paramsSerializer);
    }
};
Je.forEach([
    "delete",
    "get",
    "head",
    "options"
], function(e) {
    uf.prototype[e] = function(t, r) {
        return this.request(bf(r || {}, {
            method: e,
            url: t,
            data: (r || {}).data
        }));
    };
});
Je.forEach([
    "post",
    "put",
    "patch"
], function(e) {
    function t(r) {
        return function(n, i1, o) {
            return this.request(bf(o || {}, {
                method: e,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: n,
                data: i1
            }));
        };
    }
    uf.prototype[e] = t(), uf.prototype[e + "Form"] = t(!0);
});
let Gne = class LM {
    constructor(t){
        if (typeof t != "function") throw new TypeError("executor must be a function.");
        let r;
        this.promise = new Promise(function(i1) {
            r = i1;
        });
        const n = this;
        this.promise.then((i1)=>{
            if (!n._listeners) return;
            let o = n._listeners.length;
            for(; o-- > 0;)n._listeners[o](i1);
            n._listeners = null;
        }), this.promise.then = (i1)=>{
            let o;
            const a = new Promise((s)=>{
                n.subscribe(s), o = s;
            }).then(i1);
            return a.cancel = function() {
                n.unsubscribe(o);
            }, a;
        }, t(function(i1, o, a) {
            n.reason || (n.reason = new zh(i1, o, a), r(n.reason));
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(t) {
        if (this.reason) {
            t(this.reason);
            return;
        }
        this._listeners ? this._listeners.push(t) : this._listeners = [
            t
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(t) {
        if (!this._listeners) return;
        const r = this._listeners.indexOf(t);
        r !== -1 && this._listeners.splice(r, 1);
    }
    toAbortSignal() {
        const t = new AbortController(), r = (n)=>{
            t.abort(n);
        };
        return this.subscribe(r), t.signal.unsubscribe = ()=>this.unsubscribe(r), t.signal;
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let t;
        return {
            token: new LM(function(r) {
                t = r;
            }),
            cancel: t
        };
    }
};
function Qne(e) {
    return function(t) {
        return e.apply(null, t);
    };
}
function $ne(e) {
    return Je.isObject(e) && e.isAxiosError === !0;
}
const L8 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(L8).forEach(([e, t])=>{
    L8[t] = e;
});
function HM(e) {
    const t = new uf(e), r = bM(uf.prototype.request, t);
    return Je.extend(r, uf.prototype, t, {
        allOwnKeys: !0
    }), Je.extend(r, t, null, {
        allOwnKeys: !0
    }), r.create = function(n) {
        return HM(bf(e, n));
    }, r;
}
const un = HM(x1);
un.Axios = uf;
un.CanceledError = zh;
un.CancelToken = Gne;
un.isCancel = MM;
un.VERSION = zM;
un.toFormData = ib;
un.AxiosError = yr;
un.Cancel = un.CanceledError;
un.all = function(e) {
    return Promise.all(e);
};
un.spread = Qne;
un.isAxiosError = $ne;
un.mergeConfig = bf;
un.AxiosHeaders = Po;
un.formToJSON = (e)=>CM(Je.isHTMLForm(e) ? new FormData(e) : e);
un.getAdapter = FM.getAdapter;
un.HttpStatusCode = L8;
un.default = un;
const { Axios: F3e, AxiosError: z3e, CanceledError: L3e, isCancel: H3e, CancelToken: K3e, VERSION: q3e, all: V3e, Cancel: W3e, isAxiosError: G3e, spread: Q3e, toFormData: $3e, AxiosHeaders: Z3e, HttpStatusCode: X3e, formToJSON: Y3e, getAdapter: J3e, mergeConfig: e8e } = un, KM = "https://mainnet.sandshrew.io/v2", Zne = "https://signet.sandshrew.io/v2", Xne = "https://testnet.sandshrew.io/v2", Yne = "https://ladder-chain-sieve.sandshrew.io/v2", Kd = "lasereyes", Jne = "VIOi9IApvUkDFWBQ7I9oHsfUMWOIfDeO", qM = "bVG4GSXShooC9f67hq5YQWAJfZyRPrEN", eie = "https://xbt-mainnet.gomaestro-api.org/v0", tie = "https://xbt-testnet.gomaestro-api.org/v0", rie = "https://mempool.space", nie = "https://mempool.space/testnet", iie = "https://mempool.space/testnet4", oie = "https://mempool.space/signet", aie = "https://mempool.fractalbitcoin.io", sie = "https://mempool-testnet.fractalbitcoin.io", uie = "https://static.unisat.io/content", fO = "https://static-testnet.unisat.io/content", cie = "https://ordinals-testnet4.unisat.io/content", lie = "https://ordinals.fractalbitcoin.io/content", fie = "https://ordinals-testnet.fractalbitcoin.io/content", die = "https://static.unisat.io/preview", dO = "https://static-testnet.unisat.io/preview", hie = "https://ordinals-testnet4.unisat.io/preview", pie = "https://ordinals.fractalbitcoin.io/preview", gie = "https://ordinals-testnet.fractalbitcoin.io/preview", zi = (e)=>{
    switch(e){
        case Ki:
            return nie;
        case _o:
            return iie;
        case Xo:
            return oie;
        case Ku:
            return aie;
        case ko:
            return sie;
        default:
            return rie;
    }
}, Sm = (e, t)=>e === pt.TESTNET4 ? tie : eie, Cd = (e, t)=>{
    switch(e){
        case yM:
            return Yne;
        case Ki:
            return Xne;
        case Xo:
            return Zne;
        default:
            return KM;
    }
}, yie = (e)=>{
    switch(e){
        case Ki:
            return fO;
        case _o:
            return cie;
        case Xo:
            return fO;
        case Ku:
            return lie;
        case ko:
            return fie;
        default:
            return uie;
    }
}, mie = (e)=>{
    switch(e){
        case Ki:
            return dO;
        case _o:
            return hie;
        case Xo:
            return dO;
        case Ku:
            return pie;
        case ko:
            return gie;
        default:
            return die;
    }
};
w6(j2);
const Vr = (e)=>e === Ki || e === _o || e === Xo ? fW : ds, xm = (e)=>e.find(({ purpose: t })=>t === "ordinals"), _m = (e)=>e.find(({ purpose: t })=>t === "payment"), ph = async (e, t)=>{
    try {
        const r = await d5(e, t);
        return r ? r.reduce((n, i1)=>n + BigInt(i1.value), 0n) : 0n;
    } catch (r) {
        throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
    }
};
function f5(e, t, r) {
    const n = e * 57 + t * 41, i1 = r * 34;
    return 10 + n + i1;
}
async function d5(e, t) {
    if (e.startsWith("t")) {
        if (t === mn) return [];
        if (t === Ku) return [];
        if (t === ko) return [];
    }
    return console.log("address", e), console.log("network", t), e.startsWith("bcrt") && t === yM ? [] : await un.get(`${zi(t)}/api/address/${e}/utxo`).then((r)=>r.data);
}
async function sb(e, t, r, n, i1, o, a = 7) {
    const s = e === t, c = await d5(t, o);
    if (!c) throw new Error("No UTXOs found");
    const l = c.sort((S, k)=>k.value - S.value), u = new zr({
        network: Vr(o)
    }), f = f5(1, 0, 2), h = Math.floor(f * a) + n;
    let y = 0;
    for await (const S of l){
        const { txid: k, vout: P, value: M } = S, N = Ma(t, Vr(o));
        if (u.addInput({
            hash: k,
            index: P,
            witnessUtxo: {
                script: N,
                value: BigInt(M)
            }
        }), !s) {
            const z = O1(i1, o);
            u.updateInput(P, {
                redeemScript: z
            });
        }
        if (y += M, y >= h) break;
    }
    if (y < h) throw new Error("Insufficient funds");
    return u.addOutput({
        address: r,
        value: BigInt(n)
    }), y > h && u.addOutput({
        address: t,
        value: BigInt(y - h)
    }), {
        psbtBase64: u.toBase64(),
        psbtHex: u.toHex()
    };
}
function ub(e) {
    return e == null ? void 0 : e.reduce((t, r)=>t + r.value, 0);
}
async function cb(e, t) {
    return (await un.post(`${zi(t)}/api/tx`, e, {
        headers: {
            "Content-Type": "text/plain"
        }
    })).data;
}
const VM = (e)=>e === Ki || e === _o || e === Xo, lb = (e)=>e === mn || e === Ku || e === ko;
var Js = {}, gi = {};
Object.defineProperty(gi, "__esModule", {
    value: !0
});
gi.sha512_256 = gi.SHA512_256 = gi.sha512_224 = gi.SHA512_224 = gi.sha384 = gi.SHA384 = gi.sha512 = gi.SHA512 = void 0;
const fl = an;
gi.SHA512 = fl.SHA512;
gi.sha512 = fl.sha512;
gi.SHA384 = fl.SHA384;
gi.sha384 = fl.sha384;
gi.SHA512_224 = fl.SHA512_224;
gi.sha512_224 = fl.sha512_224;
gi.SHA512_256 = fl.SHA512_256;
gi.sha512_256 = fl.sha512_256;
var fb = {};
Object.defineProperty(fb, "__esModule", {
    value: !0
});
fb.pbkdf2 = wie;
fb.pbkdf2Async = Aie;
const bie = p1, Ja = Qr;
function WM(e, t, r, n) {
    (0, Ja.ahash)(e);
    const i1 = (0, Ja.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, n), { c: o, dkLen: a, asyncTick: s } = i1;
    if ((0, Ja.anumber)(o), (0, Ja.anumber)(a), (0, Ja.anumber)(s), o < 1) throw new Error("iterations (c) should be >= 1");
    const c = (0, Ja.kdfInputToBytes)(t), l = (0, Ja.kdfInputToBytes)(r), u = new Uint8Array(a), f = bie.hmac.create(e, c), h = f._cloneInto().update(l);
    return {
        c: o,
        dkLen: a,
        asyncTick: s,
        DK: u,
        PRF: f,
        PRFSalt: h
    };
}
function GM(e, t, r, n, i1) {
    return e.destroy(), t.destroy(), n && n.destroy(), (0, Ja.clean)(i1), r;
}
function wie(e, t, r, n) {
    const { c: i1, dkLen: o, DK: a, PRF: s, PRFSalt: c } = WM(e, t, r, n);
    let l;
    const u = new Uint8Array(4), f = (0, Ja.createView)(u), h = new Uint8Array(s.outputLen);
    for(let y = 1, S = 0; S < o; y++, S += s.outputLen){
        const k = a.subarray(S, S + s.outputLen);
        f.setInt32(0, y, !1), (l = c._cloneInto(l)).update(u).digestInto(h), k.set(h.subarray(0, k.length));
        for(let P = 1; P < i1; P++){
            s._cloneInto(l).update(h).digestInto(h);
            for(let M = 0; M < k.length; M++)k[M] ^= h[M];
        }
    }
    return GM(s, c, a, l, h);
}
async function Aie(e, t, r, n) {
    const { c: i1, dkLen: o, asyncTick: a, DK: s, PRF: c, PRFSalt: l } = WM(e, t, r, n);
    let u;
    const f = new Uint8Array(4), h = (0, Ja.createView)(f), y = new Uint8Array(c.outputLen);
    for(let S = 1, k = 0; k < o; S++, k += c.outputLen){
        const P = s.subarray(k, k + c.outputLen);
        h.setInt32(0, S, !1), (u = l._cloneInto(u)).update(f).digestInto(y), P.set(y.subarray(0, P.length)), await (0, Ja.asyncLoop)(i1 - 1, a, ()=>{
            c._cloneInto(u).update(y).digestInto(y);
            for(let M = 0; M < P.length; M++)P[M] ^= y[M];
        });
    }
    return GM(c, l, s, u, y);
}
var lo = {};
const vie = [
    "abdikace",
    "abeceda",
    "adresa",
    "agrese",
    "akce",
    "aktovka",
    "alej",
    "alkohol",
    "amputace",
    "ananas",
    "andulka",
    "anekdota",
    "anketa",
    "antika",
    "anulovat",
    "archa",
    "arogance",
    "asfalt",
    "asistent",
    "aspirace",
    "astma",
    "astronom",
    "atlas",
    "atletika",
    "atol",
    "autobus",
    "azyl",
    "babka",
    "bachor",
    "bacil",
    "baculka",
    "badatel",
    "bageta",
    "bagr",
    "bahno",
    "bakterie",
    "balada",
    "baletka",
    "balkon",
    "balonek",
    "balvan",
    "balza",
    "bambus",
    "bankomat",
    "barbar",
    "baret",
    "barman",
    "baroko",
    "barva",
    "baterka",
    "batoh",
    "bavlna",
    "bazalka",
    "bazilika",
    "bazuka",
    "bedna",
    "beran",
    "beseda",
    "bestie",
    "beton",
    "bezinka",
    "bezmoc",
    "beztak",
    "bicykl",
    "bidlo",
    "biftek",
    "bikiny",
    "bilance",
    "biograf",
    "biolog",
    "bitva",
    "bizon",
    "blahobyt",
    "blatouch",
    "blecha",
    "bledule",
    "blesk",
    "blikat",
    "blizna",
    "blokovat",
    "bloudit",
    "blud",
    "bobek",
    "bobr",
    "bodlina",
    "bodnout",
    "bohatost",
    "bojkot",
    "bojovat",
    "bokorys",
    "bolest",
    "borec",
    "borovice",
    "bota",
    "boubel",
    "bouchat",
    "bouda",
    "boule",
    "bourat",
    "boxer",
    "bradavka",
    "brambora",
    "branka",
    "bratr",
    "brepta",
    "briketa",
    "brko",
    "brloh",
    "bronz",
    "broskev",
    "brunetka",
    "brusinka",
    "brzda",
    "brzy",
    "bublina",
    "bubnovat",
    "buchta",
    "buditel",
    "budka",
    "budova",
    "bufet",
    "bujarost",
    "bukvice",
    "buldok",
    "bulva",
    "bunda",
    "bunkr",
    "burza",
    "butik",
    "buvol",
    "buzola",
    "bydlet",
    "bylina",
    "bytovka",
    "bzukot",
    "capart",
    "carevna",
    "cedr",
    "cedule",
    "cejch",
    "cejn",
    "cela",
    "celer",
    "celkem",
    "celnice",
    "cenina",
    "cennost",
    "cenovka",
    "centrum",
    "cenzor",
    "cestopis",
    "cetka",
    "chalupa",
    "chapadlo",
    "charita",
    "chata",
    "chechtat",
    "chemie",
    "chichot",
    "chirurg",
    "chlad",
    "chleba",
    "chlubit",
    "chmel",
    "chmura",
    "chobot",
    "chochol",
    "chodba",
    "cholera",
    "chomout",
    "chopit",
    "choroba",
    "chov",
    "chrapot",
    "chrlit",
    "chrt",
    "chrup",
    "chtivost",
    "chudina",
    "chutnat",
    "chvat",
    "chvilka",
    "chvost",
    "chyba",
    "chystat",
    "chytit",
    "cibule",
    "cigareta",
    "cihelna",
    "cihla",
    "cinkot",
    "cirkus",
    "cisterna",
    "citace",
    "citrus",
    "cizinec",
    "cizost",
    "clona",
    "cokoliv",
    "couvat",
    "ctitel",
    "ctnost",
    "cudnost",
    "cuketa",
    "cukr",
    "cupot",
    "cvaknout",
    "cval",
    "cvik",
    "cvrkot",
    "cyklista",
    "daleko",
    "dareba",
    "datel",
    "datum",
    "dcera",
    "debata",
    "dechovka",
    "decibel",
    "deficit",
    "deflace",
    "dekl",
    "dekret",
    "demokrat",
    "deprese",
    "derby",
    "deska",
    "detektiv",
    "dikobraz",
    "diktovat",
    "dioda",
    "diplom",
    "disk",
    "displej",
    "divadlo",
    "divoch",
    "dlaha",
    "dlouho",
    "dluhopis",
    "dnes",
    "dobro",
    "dobytek",
    "docent",
    "dochutit",
    "dodnes",
    "dohled",
    "dohoda",
    "dohra",
    "dojem",
    "dojnice",
    "doklad",
    "dokola",
    "doktor",
    "dokument",
    "dolar",
    "doleva",
    "dolina",
    "doma",
    "dominant",
    "domluvit",
    "domov",
    "donutit",
    "dopad",
    "dopis",
    "doplnit",
    "doposud",
    "doprovod",
    "dopustit",
    "dorazit",
    "dorost",
    "dort",
    "dosah",
    "doslov",
    "dostatek",
    "dosud",
    "dosyta",
    "dotaz",
    "dotek",
    "dotknout",
    "doufat",
    "doutnat",
    "dovozce",
    "dozadu",
    "doznat",
    "dozorce",
    "drahota",
    "drak",
    "dramatik",
    "dravec",
    "draze",
    "drdol",
    "drobnost",
    "drogerie",
    "drozd",
    "drsnost",
    "drtit",
    "drzost",
    "duben",
    "duchovno",
    "dudek",
    "duha",
    "duhovka",
    "dusit",
    "dusno",
    "dutost",
    "dvojice",
    "dvorec",
    "dynamit",
    "ekolog",
    "ekonomie",
    "elektron",
    "elipsa",
    "email",
    "emise",
    "emoce",
    "empatie",
    "epizoda",
    "epocha",
    "epopej",
    "epos",
    "esej",
    "esence",
    "eskorta",
    "eskymo",
    "etiketa",
    "euforie",
    "evoluce",
    "exekuce",
    "exkurze",
    "expedice",
    "exploze",
    "export",
    "extrakt",
    "facka",
    "fajfka",
    "fakulta",
    "fanatik",
    "fantazie",
    "farmacie",
    "favorit",
    "fazole",
    "federace",
    "fejeton",
    "fenka",
    "fialka",
    "figurant",
    "filozof",
    "filtr",
    "finance",
    "finta",
    "fixace",
    "fjord",
    "flanel",
    "flirt",
    "flotila",
    "fond",
    "fosfor",
    "fotbal",
    "fotka",
    "foton",
    "frakce",
    "freska",
    "fronta",
    "fukar",
    "funkce",
    "fyzika",
    "galeje",
    "garant",
    "genetika",
    "geolog",
    "gilotina",
    "glazura",
    "glejt",
    "golem",
    "golfista",
    "gotika",
    "graf",
    "gramofon",
    "granule",
    "grep",
    "gril",
    "grog",
    "groteska",
    "guma",
    "hadice",
    "hadr",
    "hala",
    "halenka",
    "hanba",
    "hanopis",
    "harfa",
    "harpuna",
    "havran",
    "hebkost",
    "hejkal",
    "hejno",
    "hejtman",
    "hektar",
    "helma",
    "hematom",
    "herec",
    "herna",
    "heslo",
    "hezky",
    "historik",
    "hladovka",
    "hlasivky",
    "hlava",
    "hledat",
    "hlen",
    "hlodavec",
    "hloh",
    "hloupost",
    "hltat",
    "hlubina",
    "hluchota",
    "hmat",
    "hmota",
    "hmyz",
    "hnis",
    "hnojivo",
    "hnout",
    "hoblina",
    "hoboj",
    "hoch",
    "hodiny",
    "hodlat",
    "hodnota",
    "hodovat",
    "hojnost",
    "hokej",
    "holinka",
    "holka",
    "holub",
    "homole",
    "honitba",
    "honorace",
    "horal",
    "horda",
    "horizont",
    "horko",
    "horlivec",
    "hormon",
    "hornina",
    "horoskop",
    "horstvo",
    "hospoda",
    "hostina",
    "hotovost",
    "houba",
    "houf",
    "houpat",
    "houska",
    "hovor",
    "hradba",
    "hranice",
    "hravost",
    "hrazda",
    "hrbolek",
    "hrdina",
    "hrdlo",
    "hrdost",
    "hrnek",
    "hrobka",
    "hromada",
    "hrot",
    "hrouda",
    "hrozen",
    "hrstka",
    "hrubost",
    "hryzat",
    "hubenost",
    "hubnout",
    "hudba",
    "hukot",
    "humr",
    "husita",
    "hustota",
    "hvozd",
    "hybnost",
    "hydrant",
    "hygiena",
    "hymna",
    "hysterik",
    "idylka",
    "ihned",
    "ikona",
    "iluze",
    "imunita",
    "infekce",
    "inflace",
    "inkaso",
    "inovace",
    "inspekce",
    "internet",
    "invalida",
    "investor",
    "inzerce",
    "ironie",
    "jablko",
    "jachta",
    "jahoda",
    "jakmile",
    "jakost",
    "jalovec",
    "jantar",
    "jarmark",
    "jaro",
    "jasan",
    "jasno",
    "jatka",
    "javor",
    "jazyk",
    "jedinec",
    "jedle",
    "jednatel",
    "jehlan",
    "jekot",
    "jelen",
    "jelito",
    "jemnost",
    "jenom",
    "jepice",
    "jeseter",
    "jevit",
    "jezdec",
    "jezero",
    "jinak",
    "jindy",
    "jinoch",
    "jiskra",
    "jistota",
    "jitrnice",
    "jizva",
    "jmenovat",
    "jogurt",
    "jurta",
    "kabaret",
    "kabel",
    "kabinet",
    "kachna",
    "kadet",
    "kadidlo",
    "kahan",
    "kajak",
    "kajuta",
    "kakao",
    "kaktus",
    "kalamita",
    "kalhoty",
    "kalibr",
    "kalnost",
    "kamera",
    "kamkoliv",
    "kamna",
    "kanibal",
    "kanoe",
    "kantor",
    "kapalina",
    "kapela",
    "kapitola",
    "kapka",
    "kaple",
    "kapota",
    "kapr",
    "kapusta",
    "kapybara",
    "karamel",
    "karotka",
    "karton",
    "kasa",
    "katalog",
    "katedra",
    "kauce",
    "kauza",
    "kavalec",
    "kazajka",
    "kazeta",
    "kazivost",
    "kdekoliv",
    "kdesi",
    "kedluben",
    "kemp",
    "keramika",
    "kino",
    "klacek",
    "kladivo",
    "klam",
    "klapot",
    "klasika",
    "klaun",
    "klec",
    "klenba",
    "klepat",
    "klesnout",
    "klid",
    "klima",
    "klisna",
    "klobouk",
    "klokan",
    "klopa",
    "kloub",
    "klubovna",
    "klusat",
    "kluzkost",
    "kmen",
    "kmitat",
    "kmotr",
    "kniha",
    "knot",
    "koalice",
    "koberec",
    "kobka",
    "kobliha",
    "kobyla",
    "kocour",
    "kohout",
    "kojenec",
    "kokos",
    "koktejl",
    "kolaps",
    "koleda",
    "kolize",
    "kolo",
    "komando",
    "kometa",
    "komik",
    "komnata",
    "komora",
    "kompas",
    "komunita",
    "konat",
    "koncept",
    "kondice",
    "konec",
    "konfese",
    "kongres",
    "konina",
    "konkurs",
    "kontakt",
    "konzerva",
    "kopanec",
    "kopie",
    "kopnout",
    "koprovka",
    "korbel",
    "korektor",
    "kormidlo",
    "koroptev",
    "korpus",
    "koruna",
    "koryto",
    "korzet",
    "kosatec",
    "kostka",
    "kotel",
    "kotleta",
    "kotoul",
    "koukat",
    "koupelna",
    "kousek",
    "kouzlo",
    "kovboj",
    "koza",
    "kozoroh",
    "krabice",
    "krach",
    "krajina",
    "kralovat",
    "krasopis",
    "kravata",
    "kredit",
    "krejcar",
    "kresba",
    "kreveta",
    "kriket",
    "kritik",
    "krize",
    "krkavec",
    "krmelec",
    "krmivo",
    "krocan",
    "krok",
    "kronika",
    "kropit",
    "kroupa",
    "krovka",
    "krtek",
    "kruhadlo",
    "krupice",
    "krutost",
    "krvinka",
    "krychle",
    "krypta",
    "krystal",
    "kryt",
    "kudlanka",
    "kufr",
    "kujnost",
    "kukla",
    "kulajda",
    "kulich",
    "kulka",
    "kulomet",
    "kultura",
    "kuna",
    "kupodivu",
    "kurt",
    "kurzor",
    "kutil",
    "kvalita",
    "kvasinka",
    "kvestor",
    "kynolog",
    "kyselina",
    "kytara",
    "kytice",
    "kytka",
    "kytovec",
    "kyvadlo",
    "labrador",
    "lachtan",
    "ladnost",
    "laik",
    "lakomec",
    "lamela",
    "lampa",
    "lanovka",
    "lasice",
    "laso",
    "lastura",
    "latinka",
    "lavina",
    "lebka",
    "leckdy",
    "leden",
    "lednice",
    "ledovka",
    "ledvina",
    "legenda",
    "legie",
    "legrace",
    "lehce",
    "lehkost",
    "lehnout",
    "lektvar",
    "lenochod",
    "lentilka",
    "lepenka",
    "lepidlo",
    "letadlo",
    "letec",
    "letmo",
    "letokruh",
    "levhart",
    "levitace",
    "levobok",
    "libra",
    "lichotka",
    "lidojed",
    "lidskost",
    "lihovina",
    "lijavec",
    "lilek",
    "limetka",
    "linie",
    "linka",
    "linoleum",
    "listopad",
    "litina",
    "litovat",
    "lobista",
    "lodivod",
    "logika",
    "logoped",
    "lokalita",
    "loket",
    "lomcovat",
    "lopata",
    "lopuch",
    "lord",
    "losos",
    "lotr",
    "loudal",
    "louh",
    "louka",
    "louskat",
    "lovec",
    "lstivost",
    "lucerna",
    "lucifer",
    "lump",
    "lusk",
    "lustrace",
    "lvice",
    "lyra",
    "lyrika",
    "lysina",
    "madam",
    "madlo",
    "magistr",
    "mahagon",
    "majetek",
    "majitel",
    "majorita",
    "makak",
    "makovice",
    "makrela",
    "malba",
    "malina",
    "malovat",
    "malvice",
    "maminka",
    "mandle",
    "manko",
    "marnost",
    "masakr",
    "maskot",
    "masopust",
    "matice",
    "matrika",
    "maturita",
    "mazanec",
    "mazivo",
    "mazlit",
    "mazurka",
    "mdloba",
    "mechanik",
    "meditace",
    "medovina",
    "melasa",
    "meloun",
    "mentolka",
    "metla",
    "metoda",
    "metr",
    "mezera",
    "migrace",
    "mihnout",
    "mihule",
    "mikina",
    "mikrofon",
    "milenec",
    "milimetr",
    "milost",
    "mimika",
    "mincovna",
    "minibar",
    "minomet",
    "minulost",
    "miska",
    "mistr",
    "mixovat",
    "mladost",
    "mlha",
    "mlhovina",
    "mlok",
    "mlsat",
    "mluvit",
    "mnich",
    "mnohem",
    "mobil",
    "mocnost",
    "modelka",
    "modlitba",
    "mohyla",
    "mokro",
    "molekula",
    "momentka",
    "monarcha",
    "monokl",
    "monstrum",
    "montovat",
    "monzun",
    "mosaz",
    "moskyt",
    "most",
    "motivace",
    "motorka",
    "motyka",
    "moucha",
    "moudrost",
    "mozaika",
    "mozek",
    "mozol",
    "mramor",
    "mravenec",
    "mrkev",
    "mrtvola",
    "mrzet",
    "mrzutost",
    "mstitel",
    "mudrc",
    "muflon",
    "mulat",
    "mumie",
    "munice",
    "muset",
    "mutace",
    "muzeum",
    "muzikant",
    "myslivec",
    "mzda",
    "nabourat",
    "nachytat",
    "nadace",
    "nadbytek",
    "nadhoz",
    "nadobro",
    "nadpis",
    "nahlas",
    "nahnat",
    "nahodile",
    "nahradit",
    "naivita",
    "najednou",
    "najisto",
    "najmout",
    "naklonit",
    "nakonec",
    "nakrmit",
    "nalevo",
    "namazat",
    "namluvit",
    "nanometr",
    "naoko",
    "naopak",
    "naostro",
    "napadat",
    "napevno",
    "naplnit",
    "napnout",
    "naposled",
    "naprosto",
    "narodit",
    "naruby",
    "narychlo",
    "nasadit",
    "nasekat",
    "naslepo",
    "nastat",
    "natolik",
    "navenek",
    "navrch",
    "navzdory",
    "nazvat",
    "nebe",
    "nechat",
    "necky",
    "nedaleko",
    "nedbat",
    "neduh",
    "negace",
    "nehet",
    "nehoda",
    "nejen",
    "nejprve",
    "neklid",
    "nelibost",
    "nemilost",
    "nemoc",
    "neochota",
    "neonka",
    "nepokoj",
    "nerost",
    "nerv",
    "nesmysl",
    "nesoulad",
    "netvor",
    "neuron",
    "nevina",
    "nezvykle",
    "nicota",
    "nijak",
    "nikam",
    "nikdy",
    "nikl",
    "nikterak",
    "nitro",
    "nocleh",
    "nohavice",
    "nominace",
    "nora",
    "norek",
    "nositel",
    "nosnost",
    "nouze",
    "noviny",
    "novota",
    "nozdra",
    "nuda",
    "nudle",
    "nuget",
    "nutit",
    "nutnost",
    "nutrie",
    "nymfa",
    "obal",
    "obarvit",
    "obava",
    "obdiv",
    "obec",
    "obehnat",
    "obejmout",
    "obezita",
    "obhajoba",
    "obilnice",
    "objasnit",
    "objekt",
    "obklopit",
    "oblast",
    "oblek",
    "obliba",
    "obloha",
    "obluda",
    "obnos",
    "obohatit",
    "obojek",
    "obout",
    "obrazec",
    "obrna",
    "obruba",
    "obrys",
    "obsah",
    "obsluha",
    "obstarat",
    "obuv",
    "obvaz",
    "obvinit",
    "obvod",
    "obvykle",
    "obyvatel",
    "obzor",
    "ocas",
    "ocel",
    "ocenit",
    "ochladit",
    "ochota",
    "ochrana",
    "ocitnout",
    "odboj",
    "odbyt",
    "odchod",
    "odcizit",
    "odebrat",
    "odeslat",
    "odevzdat",
    "odezva",
    "odhadce",
    "odhodit",
    "odjet",
    "odjinud",
    "odkaz",
    "odkoupit",
    "odliv",
    "odluka",
    "odmlka",
    "odolnost",
    "odpad",
    "odpis",
    "odplout",
    "odpor",
    "odpustit",
    "odpykat",
    "odrazka",
    "odsoudit",
    "odstup",
    "odsun",
    "odtok",
    "odtud",
    "odvaha",
    "odveta",
    "odvolat",
    "odvracet",
    "odznak",
    "ofina",
    "ofsajd",
    "ohlas",
    "ohnisko",
    "ohrada",
    "ohrozit",
    "ohryzek",
    "okap",
    "okenice",
    "oklika",
    "okno",
    "okouzlit",
    "okovy",
    "okrasa",
    "okres",
    "okrsek",
    "okruh",
    "okupant",
    "okurka",
    "okusit",
    "olejnina",
    "olizovat",
    "omak",
    "omeleta",
    "omezit",
    "omladina",
    "omlouvat",
    "omluva",
    "omyl",
    "onehdy",
    "opakovat",
    "opasek",
    "operace",
    "opice",
    "opilost",
    "opisovat",
    "opora",
    "opozice",
    "opravdu",
    "oproti",
    "orbital",
    "orchestr",
    "orgie",
    "orlice",
    "orloj",
    "ortel",
    "osada",
    "oschnout",
    "osika",
    "osivo",
    "oslava",
    "oslepit",
    "oslnit",
    "oslovit",
    "osnova",
    "osoba",
    "osolit",
    "ospalec",
    "osten",
    "ostraha",
    "ostuda",
    "ostych",
    "osvojit",
    "oteplit",
    "otisk",
    "otop",
    "otrhat",
    "otrlost",
    "otrok",
    "otruby",
    "otvor",
    "ovanout",
    "ovar",
    "oves",
    "ovlivnit",
    "ovoce",
    "oxid",
    "ozdoba",
    "pachatel",
    "pacient",
    "padouch",
    "pahorek",
    "pakt",
    "palanda",
    "palec",
    "palivo",
    "paluba",
    "pamflet",
    "pamlsek",
    "panenka",
    "panika",
    "panna",
    "panovat",
    "panstvo",
    "pantofle",
    "paprika",
    "parketa",
    "parodie",
    "parta",
    "paruka",
    "paryba",
    "paseka",
    "pasivita",
    "pastelka",
    "patent",
    "patrona",
    "pavouk",
    "pazneht",
    "pazourek",
    "pecka",
    "pedagog",
    "pejsek",
    "peklo",
    "peloton",
    "penalta",
    "pendrek",
    "penze",
    "periskop",
    "pero",
    "pestrost",
    "petarda",
    "petice",
    "petrolej",
    "pevnina",
    "pexeso",
    "pianista",
    "piha",
    "pijavice",
    "pikle",
    "piknik",
    "pilina",
    "pilnost",
    "pilulka",
    "pinzeta",
    "pipeta",
    "pisatel",
    "pistole",
    "pitevna",
    "pivnice",
    "pivovar",
    "placenta",
    "plakat",
    "plamen",
    "planeta",
    "plastika",
    "platit",
    "plavidlo",
    "plaz",
    "plech",
    "plemeno",
    "plenta",
    "ples",
    "pletivo",
    "plevel",
    "plivat",
    "plnit",
    "plno",
    "plocha",
    "plodina",
    "plomba",
    "plout",
    "pluk",
    "plyn",
    "pobavit",
    "pobyt",
    "pochod",
    "pocit",
    "poctivec",
    "podat",
    "podcenit",
    "podepsat",
    "podhled",
    "podivit",
    "podklad",
    "podmanit",
    "podnik",
    "podoba",
    "podpora",
    "podraz",
    "podstata",
    "podvod",
    "podzim",
    "poezie",
    "pohanka",
    "pohnutka",
    "pohovor",
    "pohroma",
    "pohyb",
    "pointa",
    "pojistka",
    "pojmout",
    "pokazit",
    "pokles",
    "pokoj",
    "pokrok",
    "pokuta",
    "pokyn",
    "poledne",
    "polibek",
    "polknout",
    "poloha",
    "polynom",
    "pomalu",
    "pominout",
    "pomlka",
    "pomoc",
    "pomsta",
    "pomyslet",
    "ponechat",
    "ponorka",
    "ponurost",
    "popadat",
    "popel",
    "popisek",
    "poplach",
    "poprosit",
    "popsat",
    "popud",
    "poradce",
    "porce",
    "porod",
    "porucha",
    "poryv",
    "posadit",
    "posed",
    "posila",
    "poskok",
    "poslanec",
    "posoudit",
    "pospolu",
    "postava",
    "posudek",
    "posyp",
    "potah",
    "potkan",
    "potlesk",
    "potomek",
    "potrava",
    "potupa",
    "potvora",
    "poukaz",
    "pouto",
    "pouzdro",
    "povaha",
    "povidla",
    "povlak",
    "povoz",
    "povrch",
    "povstat",
    "povyk",
    "povzdech",
    "pozdrav",
    "pozemek",
    "poznatek",
    "pozor",
    "pozvat",
    "pracovat",
    "prahory",
    "praktika",
    "prales",
    "praotec",
    "praporek",
    "prase",
    "pravda",
    "princip",
    "prkno",
    "probudit",
    "procento",
    "prodej",
    "profese",
    "prohra",
    "projekt",
    "prolomit",
    "promile",
    "pronikat",
    "propad",
    "prorok",
    "prosba",
    "proton",
    "proutek",
    "provaz",
    "prskavka",
    "prsten",
    "prudkost",
    "prut",
    "prvek",
    "prvohory",
    "psanec",
    "psovod",
    "pstruh",
    "ptactvo",
    "puberta",
    "puch",
    "pudl",
    "pukavec",
    "puklina",
    "pukrle",
    "pult",
    "pumpa",
    "punc",
    "pupen",
    "pusa",
    "pusinka",
    "pustina",
    "putovat",
    "putyka",
    "pyramida",
    "pysk",
    "pytel",
    "racek",
    "rachot",
    "radiace",
    "radnice",
    "radon",
    "raft",
    "ragby",
    "raketa",
    "rakovina",
    "rameno",
    "rampouch",
    "rande",
    "rarach",
    "rarita",
    "rasovna",
    "rastr",
    "ratolest",
    "razance",
    "razidlo",
    "reagovat",
    "reakce",
    "recept",
    "redaktor",
    "referent",
    "reflex",
    "rejnok",
    "reklama",
    "rekord",
    "rekrut",
    "rektor",
    "reputace",
    "revize",
    "revma",
    "revolver",
    "rezerva",
    "riskovat",
    "riziko",
    "robotika",
    "rodokmen",
    "rohovka",
    "rokle",
    "rokoko",
    "romaneto",
    "ropovod",
    "ropucha",
    "rorejs",
    "rosol",
    "rostlina",
    "rotmistr",
    "rotoped",
    "rotunda",
    "roubenka",
    "roucho",
    "roup",
    "roura",
    "rovina",
    "rovnice",
    "rozbor",
    "rozchod",
    "rozdat",
    "rozeznat",
    "rozhodce",
    "rozinka",
    "rozjezd",
    "rozkaz",
    "rozloha",
    "rozmar",
    "rozpad",
    "rozruch",
    "rozsah",
    "roztok",
    "rozum",
    "rozvod",
    "rubrika",
    "ruchadlo",
    "rukavice",
    "rukopis",
    "ryba",
    "rybolov",
    "rychlost",
    "rydlo",
    "rypadlo",
    "rytina",
    "ryzost",
    "sadista",
    "sahat",
    "sako",
    "samec",
    "samizdat",
    "samota",
    "sanitka",
    "sardinka",
    "sasanka",
    "satelit",
    "sazba",
    "sazenice",
    "sbor",
    "schovat",
    "sebranka",
    "secese",
    "sedadlo",
    "sediment",
    "sedlo",
    "sehnat",
    "sejmout",
    "sekera",
    "sekta",
    "sekunda",
    "sekvoje",
    "semeno",
    "seno",
    "servis",
    "sesadit",
    "seshora",
    "seskok",
    "seslat",
    "sestra",
    "sesuv",
    "sesypat",
    "setba",
    "setina",
    "setkat",
    "setnout",
    "setrvat",
    "sever",
    "seznam",
    "shoda",
    "shrnout",
    "sifon",
    "silnice",
    "sirka",
    "sirotek",
    "sirup",
    "situace",
    "skafandr",
    "skalisko",
    "skanzen",
    "skaut",
    "skeptik",
    "skica",
    "skladba",
    "sklenice",
    "sklo",
    "skluz",
    "skoba",
    "skokan",
    "skoro",
    "skripta",
    "skrz",
    "skupina",
    "skvost",
    "skvrna",
    "slabika",
    "sladidlo",
    "slanina",
    "slast",
    "slavnost",
    "sledovat",
    "slepec",
    "sleva",
    "slezina",
    "slib",
    "slina",
    "sliznice",
    "slon",
    "sloupek",
    "slovo",
    "sluch",
    "sluha",
    "slunce",
    "slupka",
    "slza",
    "smaragd",
    "smetana",
    "smilstvo",
    "smlouva",
    "smog",
    "smrad",
    "smrk",
    "smrtka",
    "smutek",
    "smysl",
    "snad",
    "snaha",
    "snob",
    "sobota",
    "socha",
    "sodovka",
    "sokol",
    "sopka",
    "sotva",
    "souboj",
    "soucit",
    "soudce",
    "souhlas",
    "soulad",
    "soumrak",
    "souprava",
    "soused",
    "soutok",
    "souviset",
    "spalovna",
    "spasitel",
    "spis",
    "splav",
    "spodek",
    "spojenec",
    "spolu",
    "sponzor",
    "spornost",
    "spousta",
    "sprcha",
    "spustit",
    "sranda",
    "sraz",
    "srdce",
    "srna",
    "srnec",
    "srovnat",
    "srpen",
    "srst",
    "srub",
    "stanice",
    "starosta",
    "statika",
    "stavba",
    "stehno",
    "stezka",
    "stodola",
    "stolek",
    "stopa",
    "storno",
    "stoupat",
    "strach",
    "stres",
    "strhnout",
    "strom",
    "struna",
    "studna",
    "stupnice",
    "stvol",
    "styk",
    "subjekt",
    "subtropy",
    "suchar",
    "sudost",
    "sukno",
    "sundat",
    "sunout",
    "surikata",
    "surovina",
    "svah",
    "svalstvo",
    "svetr",
    "svatba",
    "svazek",
    "svisle",
    "svitek",
    "svoboda",
    "svodidlo",
    "svorka",
    "svrab",
    "sykavka",
    "sykot",
    "synek",
    "synovec",
    "sypat",
    "sypkost",
    "syrovost",
    "sysel",
    "sytost",
    "tabletka",
    "tabule",
    "tahoun",
    "tajemno",
    "tajfun",
    "tajga",
    "tajit",
    "tajnost",
    "taktika",
    "tamhle",
    "tampon",
    "tancovat",
    "tanec",
    "tanker",
    "tapeta",
    "tavenina",
    "tazatel",
    "technika",
    "tehdy",
    "tekutina",
    "telefon",
    "temnota",
    "tendence",
    "tenista",
    "tenor",
    "teplota",
    "tepna",
    "teprve",
    "terapie",
    "termoska",
    "textil",
    "ticho",
    "tiskopis",
    "titulek",
    "tkadlec",
    "tkanina",
    "tlapka",
    "tleskat",
    "tlukot",
    "tlupa",
    "tmel",
    "toaleta",
    "topinka",
    "topol",
    "torzo",
    "touha",
    "toulec",
    "tradice",
    "traktor",
    "tramp",
    "trasa",
    "traverza",
    "trefit",
    "trest",
    "trezor",
    "trhavina",
    "trhlina",
    "trochu",
    "trojice",
    "troska",
    "trouba",
    "trpce",
    "trpitel",
    "trpkost",
    "trubec",
    "truchlit",
    "truhlice",
    "trus",
    "trvat",
    "tudy",
    "tuhnout",
    "tuhost",
    "tundra",
    "turista",
    "turnaj",
    "tuzemsko",
    "tvaroh",
    "tvorba",
    "tvrdost",
    "tvrz",
    "tygr",
    "tykev",
    "ubohost",
    "uboze",
    "ubrat",
    "ubrousek",
    "ubrus",
    "ubytovna",
    "ucho",
    "uctivost",
    "udivit",
    "uhradit",
    "ujednat",
    "ujistit",
    "ujmout",
    "ukazatel",
    "uklidnit",
    "uklonit",
    "ukotvit",
    "ukrojit",
    "ulice",
    "ulita",
    "ulovit",
    "umyvadlo",
    "unavit",
    "uniforma",
    "uniknout",
    "upadnout",
    "uplatnit",
    "uplynout",
    "upoutat",
    "upravit",
    "uran",
    "urazit",
    "usednout",
    "usilovat",
    "usmrtit",
    "usnadnit",
    "usnout",
    "usoudit",
    "ustlat",
    "ustrnout",
    "utahovat",
    "utkat",
    "utlumit",
    "utonout",
    "utopenec",
    "utrousit",
    "uvalit",
    "uvolnit",
    "uvozovka",
    "uzdravit",
    "uzel",
    "uzenina",
    "uzlina",
    "uznat",
    "vagon",
    "valcha",
    "valoun",
    "vana",
    "vandal",
    "vanilka",
    "varan",
    "varhany",
    "varovat",
    "vcelku",
    "vchod",
    "vdova",
    "vedro",
    "vegetace",
    "vejce",
    "velbloud",
    "veletrh",
    "velitel",
    "velmoc",
    "velryba",
    "venkov",
    "veranda",
    "verze",
    "veselka",
    "veskrze",
    "vesnice",
    "vespodu",
    "vesta",
    "veterina",
    "veverka",
    "vibrace",
    "vichr",
    "videohra",
    "vidina",
    "vidle",
    "vila",
    "vinice",
    "viset",
    "vitalita",
    "vize",
    "vizitka",
    "vjezd",
    "vklad",
    "vkus",
    "vlajka",
    "vlak",
    "vlasec",
    "vlevo",
    "vlhkost",
    "vliv",
    "vlnovka",
    "vloupat",
    "vnucovat",
    "vnuk",
    "voda",
    "vodivost",
    "vodoznak",
    "vodstvo",
    "vojensky",
    "vojna",
    "vojsko",
    "volant",
    "volba",
    "volit",
    "volno",
    "voskovka",
    "vozidlo",
    "vozovna",
    "vpravo",
    "vrabec",
    "vracet",
    "vrah",
    "vrata",
    "vrba",
    "vrcholek",
    "vrhat",
    "vrstva",
    "vrtule",
    "vsadit",
    "vstoupit",
    "vstup",
    "vtip",
    "vybavit",
    "vybrat",
    "vychovat",
    "vydat",
    "vydra",
    "vyfotit",
    "vyhledat",
    "vyhnout",
    "vyhodit",
    "vyhradit",
    "vyhubit",
    "vyjasnit",
    "vyjet",
    "vyjmout",
    "vyklopit",
    "vykonat",
    "vylekat",
    "vymazat",
    "vymezit",
    "vymizet",
    "vymyslet",
    "vynechat",
    "vynikat",
    "vynutit",
    "vypadat",
    "vyplatit",
    "vypravit",
    "vypustit",
    "vyrazit",
    "vyrovnat",
    "vyrvat",
    "vyslovit",
    "vysoko",
    "vystavit",
    "vysunout",
    "vysypat",
    "vytasit",
    "vytesat",
    "vytratit",
    "vyvinout",
    "vyvolat",
    "vyvrhel",
    "vyzdobit",
    "vyznat",
    "vzadu",
    "vzbudit",
    "vzchopit",
    "vzdor",
    "vzduch",
    "vzdychat",
    "vzestup",
    "vzhledem",
    "vzkaz",
    "vzlykat",
    "vznik",
    "vzorek",
    "vzpoura",
    "vztah",
    "vztek",
    "xylofon",
    "zabrat",
    "zabydlet",
    "zachovat",
    "zadarmo",
    "zadusit",
    "zafoukat",
    "zahltit",
    "zahodit",
    "zahrada",
    "zahynout",
    "zajatec",
    "zajet",
    "zajistit",
    "zaklepat",
    "zakoupit",
    "zalepit",
    "zamezit",
    "zamotat",
    "zamyslet",
    "zanechat",
    "zanikat",
    "zaplatit",
    "zapojit",
    "zapsat",
    "zarazit",
    "zastavit",
    "zasunout",
    "zatajit",
    "zatemnit",
    "zatknout",
    "zaujmout",
    "zavalit",
    "zavelet",
    "zavinit",
    "zavolat",
    "zavrtat",
    "zazvonit",
    "zbavit",
    "zbrusu",
    "zbudovat",
    "zbytek",
    "zdaleka",
    "zdarma",
    "zdatnost",
    "zdivo",
    "zdobit",
    "zdroj",
    "zdvih",
    "zdymadlo",
    "zelenina",
    "zeman",
    "zemina",
    "zeptat",
    "zezadu",
    "zezdola",
    "zhatit",
    "zhltnout",
    "zhluboka",
    "zhotovit",
    "zhruba",
    "zima",
    "zimnice",
    "zjemnit",
    "zklamat",
    "zkoumat",
    "zkratka",
    "zkumavka",
    "zlato",
    "zlehka",
    "zloba",
    "zlom",
    "zlost",
    "zlozvyk",
    "zmapovat",
    "zmar",
    "zmatek",
    "zmije",
    "zmizet",
    "zmocnit",
    "zmodrat",
    "zmrzlina",
    "zmutovat",
    "znak",
    "znalost",
    "znamenat",
    "znovu",
    "zobrazit",
    "zotavit",
    "zoubek",
    "zoufale",
    "zplodit",
    "zpomalit",
    "zprava",
    "zprostit",
    "zprudka",
    "zprvu",
    "zrada",
    "zranit",
    "zrcadlo",
    "zrnitost",
    "zrno",
    "zrovna",
    "zrychlit",
    "zrzavost",
    "zticha",
    "ztratit",
    "zubovina",
    "zubr",
    "zvednout",
    "zvenku",
    "zvesela",
    "zvon",
    "zvrat",
    "zvukovod",
    "zvyk"
], Eie = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], Sie = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], xie = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], _ie = [
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "academie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquerir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adequat",
    "adhesif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aerer",
    "aeronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agreable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algebre",
    "algue",
    "aliener",
    "aliment",
    "alleger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alveole",
    "amateur",
    "ambigu",
    "ambre",
    "amenager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "aneantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "aperitif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "arteriel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "banniere",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "belier",
    "belote",
    "benefice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "betail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "breche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "cafeine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "camera",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cedille",
    "ceinture",
    "celeste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cerebral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chequier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimere",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinema",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohesion",
    "coiffer",
    "coincer",
    "colere",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comedie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortege",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "creature",
    "crediter",
    "cremeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critere",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillere",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "debattre",
    "debiter",
    "deborder",
    "debrider",
    "debutant",
    "decaler",
    "decembre",
    "dechirer",
    "decider",
    "declarer",
    "decorer",
    "decrire",
    "decupler",
    "dedale",
    "deductif",
    "deesse",
    "defensif",
    "defiler",
    "defrayer",
    "degager",
    "degivrer",
    "deglutir",
    "degrafer",
    "dejeuner",
    "delice",
    "deloger",
    "demander",
    "demeurer",
    "demolir",
    "denicher",
    "denouer",
    "dentelle",
    "denuder",
    "depart",
    "depenser",
    "dephaser",
    "deplacer",
    "deposer",
    "deranger",
    "derober",
    "desastre",
    "descente",
    "desert",
    "designer",
    "desobeir",
    "dessiner",
    "destrier",
    "detacher",
    "detester",
    "detourer",
    "detresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "differer",
    "digerer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "eblouir",
    "ecarter",
    "echarpe",
    "echelle",
    "eclairer",
    "eclipse",
    "eclore",
    "ecluse",
    "ecole",
    "economie",
    "ecorce",
    "ecouter",
    "ecraser",
    "ecremer",
    "ecrivain",
    "ecrou",
    "ecume",
    "ecureuil",
    "edifier",
    "eduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "egaliser",
    "egarer",
    "ejecter",
    "elaborer",
    "elargir",
    "electron",
    "elegant",
    "elephant",
    "eleve",
    "eligible",
    "elitisme",
    "eloge",
    "elucider",
    "eluder",
    "emballer",
    "embellir",
    "embryon",
    "emeraude",
    "emission",
    "emmener",
    "emotion",
    "emouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "emulsion",
    "encadrer",
    "enchere",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "energie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "enigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "enumerer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "eolien",
    "epaissir",
    "epargne",
    "epatant",
    "epaule",
    "epicerie",
    "epidemie",
    "epier",
    "epilogue",
    "epine",
    "episode",
    "epitaphe",
    "epoque",
    "epreuve",
    "eprouver",
    "epuisant",
    "equerre",
    "equipe",
    "eriger",
    "erosion",
    "erreur",
    "eruption",
    "escalier",
    "espadon",
    "espece",
    "espiegle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "etagere",
    "etaler",
    "etanche",
    "etatique",
    "eteindre",
    "etendoir",
    "eternel",
    "ethanol",
    "ethique",
    "ethnie",
    "etirer",
    "etoffer",
    "etoile",
    "etonnant",
    "etourdir",
    "etrange",
    "etroit",
    "etude",
    "euphorie",
    "evaluer",
    "evasion",
    "eventail",
    "evidence",
    "eviter",
    "evolutif",
    "evoquer",
    "exact",
    "exagerer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "executer",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expedier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "febrile",
    "feconder",
    "federer",
    "felin",
    "femme",
    "femur",
    "fendoir",
    "feodal",
    "fermer",
    "feroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "fevrier",
    "fiasco",
    "ficeler",
    "fictif",
    "fidele",
    "figure",
    "filature",
    "filetage",
    "filiere",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fleau",
    "fleche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougere",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "fregate",
    "freiner",
    "frelon",
    "fremir",
    "frenesie",
    "frere",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "geant",
    "gelatine",
    "gelule",
    "gendarme",
    "general",
    "genie",
    "genou",
    "gentil",
    "geologie",
    "geometre",
    "geranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyere",
    "guepard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "helium",
    "hematome",
    "herbe",
    "herisson",
    "hermine",
    "heron",
    "hesiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogene",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiene",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "imperial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inedit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingerer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irreel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvenile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacerer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "legal",
    "leger",
    "legume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lezard",
    "liasse",
    "liberer",
    "libre",
    "licence",
    "licorne",
    "liege",
    "lievre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "lineaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisiere",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumiere",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "malefice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "materiel",
    "matiere",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "mechant",
    "meconnu",
    "medaille",
    "medecin",
    "mediter",
    "meduse",
    "meilleur",
    "melange",
    "melodie",
    "membre",
    "memoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "merite",
    "merle",
    "messager",
    "mesure",
    "metal",
    "meteore",
    "methode",
    "metier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "mineral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murene",
    "murmure",
    "muscle",
    "museum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystere",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nebuleux",
    "nectar",
    "nefaste",
    "negation",
    "negliger",
    "negocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numero",
    "nuptial",
    "nuque",
    "nutritif",
    "obeir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "ocean",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onereux",
    "onirique",
    "opale",
    "opaque",
    "operer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygene",
    "ozone",
    "paisible",
    "palace",
    "palmares",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pasteque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pelican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "penetrer",
    "penible",
    "pensif",
    "penurie",
    "pepite",
    "peplum",
    "perdrix",
    "perforer",
    "periode",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "petale",
    "petit",
    "petrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "piece",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poesie",
    "poete",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "ponderer",
    "poney",
    "portique",
    "position",
    "posseder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "precieux",
    "predire",
    "prefixe",
    "prelude",
    "prenom",
    "presence",
    "pretexte",
    "prevoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "probleme",
    "proceder",
    "prodige",
    "profond",
    "progres",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospere",
    "proteger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quietude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "reactif",
    "reagir",
    "realiser",
    "reanimer",
    "recevoir",
    "reciter",
    "reclamer",
    "recolter",
    "recruter",
    "reculer",
    "recycler",
    "rediger",
    "redouter",
    "refaire",
    "reflexe",
    "reformer",
    "refrain",
    "refuge",
    "regalien",
    "region",
    "reglage",
    "regulier",
    "reiterer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remede",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "reserve",
    "resineux",
    "resoudre",
    "respect",
    "rester",
    "resultat",
    "retablir",
    "retenir",
    "reticule",
    "retomber",
    "retracer",
    "reunion",
    "reussir",
    "revanche",
    "revivre",
    "revolte",
    "revulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "riviere",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scelerat",
    "scenario",
    "sceptre",
    "schema",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "seance",
    "secable",
    "secher",
    "secouer",
    "secreter",
    "sedatif",
    "seduire",
    "seigneur",
    "sejour",
    "selectif",
    "semaine",
    "sembler",
    "semence",
    "seminal",
    "senateur",
    "sensible",
    "sentence",
    "separer",
    "sequence",
    "serein",
    "sergent",
    "serieux",
    "serrure",
    "serum",
    "service",
    "sesame",
    "sevir",
    "sevrage",
    "sextuple",
    "sideral",
    "siecle",
    "sieger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincere",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "special",
    "sphere",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succes",
    "sucre",
    "suffixe",
    "suggerer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symetrie",
    "synapse",
    "syntaxe",
    "systeme",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "temoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tetine",
    "texte",
    "theme",
    "theorie",
    "therapie",
    "thorax",
    "tibia",
    "tiede",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolerant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trefle",
    "tremper",
    "tresor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "vegetal",
    "vehicule",
    "veinard",
    "veloce",
    "vendredi",
    "venerer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "verin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "veteran",
    "vetuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "video",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipere",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xenon",
    "yacht",
    "zebre",
    "zenith",
    "zeste",
    "zoologie"
], kie = [
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
], Oie = [
    "abaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "accion",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "acido",
    "aclarar",
    "acne",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aereo",
    "afectar",
    "aficion",
    "afinar",
    "afirmar",
    "agil",
    "agitar",
    "agonia",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "aguila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacran",
    "alambre",
    "alarma",
    "alba",
    "album",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodon",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almibar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ambar",
    "ambito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "anden",
    "anemia",
    "angulo",
    "anillo",
    "animo",
    "anis",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "anadir",
    "anejo",
    "ano",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "arana",
    "arar",
    "arbitro",
    "arbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "area",
    "arido",
    "aries",
    "armonia",
    "arnes",
    "aroma",
    "arpa",
    "arpon",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "aspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "atico",
    "atleta",
    "atomo",
    "atraer",
    "atroz",
    "atun",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avion",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafran",
    "azar",
    "azote",
    "azucar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahia",
    "baile",
    "bajar",
    "balanza",
    "balcon",
    "balde",
    "bambu",
    "banco",
    "banda",
    "bano",
    "barba",
    "barco",
    "barniz",
    "barro",
    "bascula",
    "baston",
    "basura",
    "batalla",
    "bateria",
    "batir",
    "batuta",
    "baul",
    "bazar",
    "bebe",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsai",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botin",
    "boveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufon",
    "buho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzon",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadaver",
    "cadena",
    "caer",
    "cafe",
    "caida",
    "caiman",
    "caja",
    "cajon",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cancer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "cana",
    "canon",
    "caoba",
    "caos",
    "capaz",
    "capitan",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbon",
    "carcel",
    "careta",
    "carga",
    "carino",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "celebre",
    "celoso",
    "celula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "cesped",
    "cetro",
    "chacal",
    "chaleco",
    "champu",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclon",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "cipres",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clinica",
    "cobre",
    "coccion",
    "cochino",
    "cocina",
    "coco",
    "codigo",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojin",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "comodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazon",
    "corbata",
    "corcho",
    "cordon",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "craneo",
    "crater",
    "crear",
    "crecer",
    "creido",
    "crema",
    "cria",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "cronica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupon",
    "cupula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "datil",
    "deber",
    "debil",
    "decada",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfin",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvio",
    "detalle",
    "detener",
    "deuda",
    "dia",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "dificil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseno",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragon",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueno",
    "dulce",
    "duo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ebano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edicion",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "elite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emocion",
    "empate",
    "empeno",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encia",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engano",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "ensenar",
    "entero",
    "entrar",
    "envase",
    "envio",
    "epoca",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espia",
    "esposa",
    "espuma",
    "esqui",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "etica",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "exito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fabrica",
    "fabula",
    "fachada",
    "facil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraon",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fertil",
    "fervor",
    "festin",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficcion",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "fluor",
    "fobia",
    "foca",
    "fogata",
    "fogon",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "fragil",
    "franja",
    "frase",
    "fraude",
    "freir",
    "freno",
    "fresa",
    "frio",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "funcion",
    "funda",
    "furgon",
    "furia",
    "fusil",
    "futbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galeria",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilan",
    "gemelo",
    "gemir",
    "gen",
    "genero",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "grafico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grua",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guia",
    "guino",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "habil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazana",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "heroe",
    "hervir",
    "hielo",
    "hierro",
    "higado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "humedo",
    "humilde",
    "humo",
    "hundir",
    "huracan",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "idolo",
    "iglesia",
    "iglu",
    "igual",
    "ilegal",
    "ilusion",
    "imagen",
    "iman",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "indice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interes",
    "intimo",
    "intuir",
    "inutil",
    "invierno",
    "ira",
    "iris",
    "ironia",
    "isla",
    "islote",
    "jabali",
    "jabon",
    "jamon",
    "jarabe",
    "jardin",
    "jarra",
    "jaula",
    "jazmin",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "jupiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladron",
    "lagarto",
    "lagrima",
    "laguna",
    "laico",
    "lamer",
    "lamina",
    "lampara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lapiz",
    "largo",
    "larva",
    "lastima",
    "lata",
    "latex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "leccion",
    "leche",
    "lector",
    "leer",
    "legion",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "lena",
    "leon",
    "leopardo",
    "lesion",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "lider",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "limite",
    "limon",
    "limpio",
    "lince",
    "lindo",
    "linea",
    "lingote",
    "lino",
    "linterna",
    "liquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "locion",
    "loco",
    "locura",
    "logica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maiz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mama",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniqui",
    "manjar",
    "mano",
    "manso",
    "manta",
    "manana",
    "mapa",
    "maquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "marmol",
    "marron",
    "martes",
    "marzo",
    "masa",
    "mascara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "maximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "medula",
    "mejilla",
    "mejor",
    "melena",
    "melon",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menu",
    "mercado",
    "merengue",
    "merito",
    "mes",
    "meson",
    "meta",
    "meter",
    "metodo",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millon",
    "mimo",
    "mina",
    "minero",
    "minimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "mocion",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "mono",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "movil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muneca",
    "mural",
    "muro",
    "musculo",
    "museo",
    "musgo",
    "musica",
    "muslo",
    "nacar",
    "nacion",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "nausea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "nectar",
    "negar",
    "negocio",
    "negro",
    "neon",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "ninez",
    "nino",
    "nitido",
    "nivel",
    "nobleza",
    "noche",
    "nomina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "nucleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "numero",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "oceano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oido",
    "oir",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opcion",
    "opera",
    "opinar",
    "oponer",
    "optar",
    "optica",
    "opuesto",
    "oracion",
    "orador",
    "oral",
    "orbita",
    "orca",
    "orden",
    "oreja",
    "organo",
    "orgia",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadia",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otono",
    "otro",
    "oveja",
    "ovulo",
    "oxido",
    "oxigeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "pagina",
    "pago",
    "pais",
    "pajaro",
    "palabra",
    "palco",
    "paleta",
    "palido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "panico",
    "pantera",
    "panuelo",
    "papa",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "parpado",
    "parque",
    "parrafo",
    "parte",
    "pasar",
    "paseo",
    "pasion",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peaton",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldano",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "penon",
    "peon",
    "peor",
    "pepino",
    "pequeno",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pesimo",
    "pestana",
    "petalo",
    "petroleo",
    "pez",
    "pezuna",
    "picar",
    "pichon",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "pina",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "piton",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesia",
    "poeta",
    "polen",
    "policia",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porcion",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "principe",
    "prision",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "proximo",
    "prueba",
    "publico",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmon",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "punal",
    "puno",
    "pupa",
    "pupila",
    "pure",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "quimica",
    "quince",
    "quitar",
    "rabano",
    "rabia",
    "rabo",
    "racion",
    "radical",
    "raiz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rapido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razon",
    "reaccion",
    "realidad",
    "rebano",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refran",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehen",
    "reino",
    "reir",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "reves",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rigido",
    "rigor",
    "rincon",
    "rinon",
    "rio",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubi",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sabado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmon",
    "salon",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sancion",
    "sandia",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sarten",
    "sastre",
    "satan",
    "sauna",
    "saxofon",
    "seccion",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "senal",
    "senor",
    "separar",
    "sepia",
    "sequia",
    "ser",
    "serie",
    "sermon",
    "servir",
    "sesenta",
    "sesion",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "silaba",
    "silbar",
    "silencio",
    "silla",
    "simbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "solido",
    "soltar",
    "solucion",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sosten",
    "sotano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueno",
    "suerte",
    "sufrir",
    "sujeto",
    "sultan",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureno",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabu",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talon",
    "tamano",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapon",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazon",
    "teatro",
    "techo",
    "tecla",
    "tecnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "telefono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoria",
    "terapia",
    "terco",
    "termino",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburon",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "timido",
    "timo",
    "tinta",
    "tio",
    "tipico",
    "tipo",
    "tira",
    "tiron",
    "titan",
    "titere",
    "titulo",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "torax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "toxico",
    "trabajo",
    "tractor",
    "traer",
    "trafico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trebol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tuberia",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "tunel",
    "tunica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "ulcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "una",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "util",
    "utopia",
    "uva",
    "vaca",
    "vacio",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "valido",
    "valle",
    "valor",
    "valvula",
    "vampiro",
    "vara",
    "variar",
    "varon",
    "vaso",
    "vecino",
    "vector",
    "vehiculo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "via",
    "viaje",
    "vibrar",
    "vicio",
    "victima",
    "vida",
    "video",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "vinedo",
    "violin",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "vispera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcan",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
], Iie = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
], Bie = [
    "abacate",
    "abaixo",
    "abalar",
    "abater",
    "abduzir",
    "abelha",
    "aberto",
    "abismo",
    "abotoar",
    "abranger",
    "abreviar",
    "abrigar",
    "abrupto",
    "absinto",
    "absoluto",
    "absurdo",
    "abutre",
    "acabado",
    "acalmar",
    "acampar",
    "acanhar",
    "acaso",
    "aceitar",
    "acelerar",
    "acenar",
    "acervo",
    "acessar",
    "acetona",
    "achatar",
    "acidez",
    "acima",
    "acionado",
    "acirrar",
    "aclamar",
    "aclive",
    "acolhida",
    "acomodar",
    "acoplar",
    "acordar",
    "acumular",
    "acusador",
    "adaptar",
    "adega",
    "adentro",
    "adepto",
    "adequar",
    "aderente",
    "adesivo",
    "adeus",
    "adiante",
    "aditivo",
    "adjetivo",
    "adjunto",
    "admirar",
    "adorar",
    "adquirir",
    "adubo",
    "adverso",
    "advogado",
    "aeronave",
    "afastar",
    "aferir",
    "afetivo",
    "afinador",
    "afivelar",
    "aflito",
    "afluente",
    "afrontar",
    "agachar",
    "agarrar",
    "agasalho",
    "agenciar",
    "agilizar",
    "agiota",
    "agitado",
    "agora",
    "agradar",
    "agreste",
    "agrupar",
    "aguardar",
    "agulha",
    "ajoelhar",
    "ajudar",
    "ajustar",
    "alameda",
    "alarme",
    "alastrar",
    "alavanca",
    "albergue",
    "albino",
    "alcatra",
    "aldeia",
    "alecrim",
    "alegria",
    "alertar",
    "alface",
    "alfinete",
    "algum",
    "alheio",
    "aliar",
    "alicate",
    "alienar",
    "alinhar",
    "aliviar",
    "almofada",
    "alocar",
    "alpiste",
    "alterar",
    "altitude",
    "alucinar",
    "alugar",
    "aluno",
    "alusivo",
    "alvo",
    "amaciar",
    "amador",
    "amarelo",
    "amassar",
    "ambas",
    "ambiente",
    "ameixa",
    "amenizar",
    "amido",
    "amistoso",
    "amizade",
    "amolador",
    "amontoar",
    "amoroso",
    "amostra",
    "amparar",
    "ampliar",
    "ampola",
    "anagrama",
    "analisar",
    "anarquia",
    "anatomia",
    "andaime",
    "anel",
    "anexo",
    "angular",
    "animar",
    "anjo",
    "anomalia",
    "anotado",
    "ansioso",
    "anterior",
    "anuidade",
    "anunciar",
    "anzol",
    "apagador",
    "apalpar",
    "apanhado",
    "apego",
    "apelido",
    "apertada",
    "apesar",
    "apetite",
    "apito",
    "aplauso",
    "aplicada",
    "apoio",
    "apontar",
    "aposta",
    "aprendiz",
    "aprovar",
    "aquecer",
    "arame",
    "aranha",
    "arara",
    "arcada",
    "ardente",
    "areia",
    "arejar",
    "arenito",
    "aresta",
    "argiloso",
    "argola",
    "arma",
    "arquivo",
    "arraial",
    "arrebate",
    "arriscar",
    "arroba",
    "arrumar",
    "arsenal",
    "arterial",
    "artigo",
    "arvoredo",
    "asfaltar",
    "asilado",
    "aspirar",
    "assador",
    "assinar",
    "assoalho",
    "assunto",
    "astral",
    "atacado",
    "atadura",
    "atalho",
    "atarefar",
    "atear",
    "atender",
    "aterro",
    "ateu",
    "atingir",
    "atirador",
    "ativo",
    "atoleiro",
    "atracar",
    "atrevido",
    "atriz",
    "atual",
    "atum",
    "auditor",
    "aumentar",
    "aura",
    "aurora",
    "autismo",
    "autoria",
    "autuar",
    "avaliar",
    "avante",
    "avaria",
    "avental",
    "avesso",
    "aviador",
    "avisar",
    "avulso",
    "axila",
    "azarar",
    "azedo",
    "azeite",
    "azulejo",
    "babar",
    "babosa",
    "bacalhau",
    "bacharel",
    "bacia",
    "bagagem",
    "baiano",
    "bailar",
    "baioneta",
    "bairro",
    "baixista",
    "bajular",
    "baleia",
    "baliza",
    "balsa",
    "banal",
    "bandeira",
    "banho",
    "banir",
    "banquete",
    "barato",
    "barbado",
    "baronesa",
    "barraca",
    "barulho",
    "baseado",
    "bastante",
    "batata",
    "batedor",
    "batida",
    "batom",
    "batucar",
    "baunilha",
    "beber",
    "beijo",
    "beirada",
    "beisebol",
    "beldade",
    "beleza",
    "belga",
    "beliscar",
    "bendito",
    "bengala",
    "benzer",
    "berimbau",
    "berlinda",
    "berro",
    "besouro",
    "bexiga",
    "bezerro",
    "bico",
    "bicudo",
    "bienal",
    "bifocal",
    "bifurcar",
    "bigorna",
    "bilhete",
    "bimestre",
    "bimotor",
    "biologia",
    "biombo",
    "biosfera",
    "bipolar",
    "birrento",
    "biscoito",
    "bisneto",
    "bispo",
    "bissexto",
    "bitola",
    "bizarro",
    "blindado",
    "bloco",
    "bloquear",
    "boato",
    "bobagem",
    "bocado",
    "bocejo",
    "bochecha",
    "boicotar",
    "bolada",
    "boletim",
    "bolha",
    "bolo",
    "bombeiro",
    "bonde",
    "boneco",
    "bonita",
    "borbulha",
    "borda",
    "boreal",
    "borracha",
    "bovino",
    "boxeador",
    "branco",
    "brasa",
    "braveza",
    "breu",
    "briga",
    "brilho",
    "brincar",
    "broa",
    "brochura",
    "bronzear",
    "broto",
    "bruxo",
    "bucha",
    "budismo",
    "bufar",
    "bule",
    "buraco",
    "busca",
    "busto",
    "buzina",
    "cabana",
    "cabelo",
    "cabide",
    "cabo",
    "cabrito",
    "cacau",
    "cacetada",
    "cachorro",
    "cacique",
    "cadastro",
    "cadeado",
    "cafezal",
    "caiaque",
    "caipira",
    "caixote",
    "cajado",
    "caju",
    "calafrio",
    "calcular",
    "caldeira",
    "calibrar",
    "calmante",
    "calota",
    "camada",
    "cambista",
    "camisa",
    "camomila",
    "campanha",
    "camuflar",
    "canavial",
    "cancelar",
    "caneta",
    "canguru",
    "canhoto",
    "canivete",
    "canoa",
    "cansado",
    "cantar",
    "canudo",
    "capacho",
    "capela",
    "capinar",
    "capotar",
    "capricho",
    "captador",
    "capuz",
    "caracol",
    "carbono",
    "cardeal",
    "careca",
    "carimbar",
    "carneiro",
    "carpete",
    "carreira",
    "cartaz",
    "carvalho",
    "casaco",
    "casca",
    "casebre",
    "castelo",
    "casulo",
    "catarata",
    "cativar",
    "caule",
    "causador",
    "cautelar",
    "cavalo",
    "caverna",
    "cebola",
    "cedilha",
    "cegonha",
    "celebrar",
    "celular",
    "cenoura",
    "censo",
    "centeio",
    "cercar",
    "cerrado",
    "certeiro",
    "cerveja",
    "cetim",
    "cevada",
    "chacota",
    "chaleira",
    "chamado",
    "chapada",
    "charme",
    "chatice",
    "chave",
    "chefe",
    "chegada",
    "cheiro",
    "cheque",
    "chicote",
    "chifre",
    "chinelo",
    "chocalho",
    "chover",
    "chumbo",
    "chutar",
    "chuva",
    "cicatriz",
    "ciclone",
    "cidade",
    "cidreira",
    "ciente",
    "cigana",
    "cimento",
    "cinto",
    "cinza",
    "ciranda",
    "circuito",
    "cirurgia",
    "citar",
    "clareza",
    "clero",
    "clicar",
    "clone",
    "clube",
    "coado",
    "coagir",
    "cobaia",
    "cobertor",
    "cobrar",
    "cocada",
    "coelho",
    "coentro",
    "coeso",
    "cogumelo",
    "coibir",
    "coifa",
    "coiote",
    "colar",
    "coleira",
    "colher",
    "colidir",
    "colmeia",
    "colono",
    "coluna",
    "comando",
    "combinar",
    "comentar",
    "comitiva",
    "comover",
    "complexo",
    "comum",
    "concha",
    "condor",
    "conectar",
    "confuso",
    "congelar",
    "conhecer",
    "conjugar",
    "consumir",
    "contrato",
    "convite",
    "cooperar",
    "copeiro",
    "copiador",
    "copo",
    "coquetel",
    "coragem",
    "cordial",
    "corneta",
    "coronha",
    "corporal",
    "correio",
    "cortejo",
    "coruja",
    "corvo",
    "cosseno",
    "costela",
    "cotonete",
    "couro",
    "couve",
    "covil",
    "cozinha",
    "cratera",
    "cravo",
    "creche",
    "credor",
    "creme",
    "crer",
    "crespo",
    "criada",
    "criminal",
    "crioulo",
    "crise",
    "criticar",
    "crosta",
    "crua",
    "cruzeiro",
    "cubano",
    "cueca",
    "cuidado",
    "cujo",
    "culatra",
    "culminar",
    "culpar",
    "cultura",
    "cumprir",
    "cunhado",
    "cupido",
    "curativo",
    "curral",
    "cursar",
    "curto",
    "cuspir",
    "custear",
    "cutelo",
    "damasco",
    "datar",
    "debater",
    "debitar",
    "deboche",
    "debulhar",
    "decalque",
    "decimal",
    "declive",
    "decote",
    "decretar",
    "dedal",
    "dedicado",
    "deduzir",
    "defesa",
    "defumar",
    "degelo",
    "degrau",
    "degustar",
    "deitado",
    "deixar",
    "delator",
    "delegado",
    "delinear",
    "delonga",
    "demanda",
    "demitir",
    "demolido",
    "dentista",
    "depenado",
    "depilar",
    "depois",
    "depressa",
    "depurar",
    "deriva",
    "derramar",
    "desafio",
    "desbotar",
    "descanso",
    "desenho",
    "desfiado",
    "desgaste",
    "desigual",
    "deslize",
    "desmamar",
    "desova",
    "despesa",
    "destaque",
    "desviar",
    "detalhar",
    "detentor",
    "detonar",
    "detrito",
    "deusa",
    "dever",
    "devido",
    "devotado",
    "dezena",
    "diagrama",
    "dialeto",
    "didata",
    "difuso",
    "digitar",
    "dilatado",
    "diluente",
    "diminuir",
    "dinastia",
    "dinheiro",
    "diocese",
    "direto",
    "discreta",
    "disfarce",
    "disparo",
    "disquete",
    "dissipar",
    "distante",
    "ditador",
    "diurno",
    "diverso",
    "divisor",
    "divulgar",
    "dizer",
    "dobrador",
    "dolorido",
    "domador",
    "dominado",
    "donativo",
    "donzela",
    "dormente",
    "dorsal",
    "dosagem",
    "dourado",
    "doutor",
    "drenagem",
    "drible",
    "drogaria",
    "duelar",
    "duende",
    "dueto",
    "duplo",
    "duquesa",
    "durante",
    "duvidoso",
    "eclodir",
    "ecoar",
    "ecologia",
    "edificar",
    "edital",
    "educado",
    "efeito",
    "efetivar",
    "ejetar",
    "elaborar",
    "eleger",
    "eleitor",
    "elenco",
    "elevador",
    "eliminar",
    "elogiar",
    "embargo",
    "embolado",
    "embrulho",
    "embutido",
    "emenda",
    "emergir",
    "emissor",
    "empatia",
    "empenho",
    "empinado",
    "empolgar",
    "emprego",
    "empurrar",
    "emulador",
    "encaixe",
    "encenado",
    "enchente",
    "encontro",
    "endeusar",
    "endossar",
    "enfaixar",
    "enfeite",
    "enfim",
    "engajado",
    "engenho",
    "englobar",
    "engomado",
    "engraxar",
    "enguia",
    "enjoar",
    "enlatar",
    "enquanto",
    "enraizar",
    "enrolado",
    "enrugar",
    "ensaio",
    "enseada",
    "ensino",
    "ensopado",
    "entanto",
    "enteado",
    "entidade",
    "entortar",
    "entrada",
    "entulho",
    "envergar",
    "enviado",
    "envolver",
    "enxame",
    "enxerto",
    "enxofre",
    "enxuto",
    "epiderme",
    "equipar",
    "ereto",
    "erguido",
    "errata",
    "erva",
    "ervilha",
    "esbanjar",
    "esbelto",
    "escama",
    "escola",
    "escrita",
    "escuta",
    "esfinge",
    "esfolar",
    "esfregar",
    "esfumado",
    "esgrima",
    "esmalte",
    "espanto",
    "espelho",
    "espiga",
    "esponja",
    "espreita",
    "espumar",
    "esquerda",
    "estaca",
    "esteira",
    "esticar",
    "estofado",
    "estrela",
    "estudo",
    "esvaziar",
    "etanol",
    "etiqueta",
    "euforia",
    "europeu",
    "evacuar",
    "evaporar",
    "evasivo",
    "eventual",
    "evidente",
    "evoluir",
    "exagero",
    "exalar",
    "examinar",
    "exato",
    "exausto",
    "excesso",
    "excitar",
    "exclamar",
    "executar",
    "exemplo",
    "exibir",
    "exigente",
    "exonerar",
    "expandir",
    "expelir",
    "expirar",
    "explanar",
    "exposto",
    "expresso",
    "expulsar",
    "externo",
    "extinto",
    "extrato",
    "fabricar",
    "fabuloso",
    "faceta",
    "facial",
    "fada",
    "fadiga",
    "faixa",
    "falar",
    "falta",
    "familiar",
    "fandango",
    "fanfarra",
    "fantoche",
    "fardado",
    "farelo",
    "farinha",
    "farofa",
    "farpa",
    "fartura",
    "fatia",
    "fator",
    "favorita",
    "faxina",
    "fazenda",
    "fechado",
    "feijoada",
    "feirante",
    "felino",
    "feminino",
    "fenda",
    "feno",
    "fera",
    "feriado",
    "ferrugem",
    "ferver",
    "festejar",
    "fetal",
    "feudal",
    "fiapo",
    "fibrose",
    "ficar",
    "ficheiro",
    "figurado",
    "fileira",
    "filho",
    "filme",
    "filtrar",
    "firmeza",
    "fisgada",
    "fissura",
    "fita",
    "fivela",
    "fixador",
    "fixo",
    "flacidez",
    "flamingo",
    "flanela",
    "flechada",
    "flora",
    "flutuar",
    "fluxo",
    "focal",
    "focinho",
    "fofocar",
    "fogo",
    "foguete",
    "foice",
    "folgado",
    "folheto",
    "forjar",
    "formiga",
    "forno",
    "forte",
    "fosco",
    "fossa",
    "fragata",
    "fralda",
    "frango",
    "frasco",
    "fraterno",
    "freira",
    "frente",
    "fretar",
    "frieza",
    "friso",
    "fritura",
    "fronha",
    "frustrar",
    "fruteira",
    "fugir",
    "fulano",
    "fuligem",
    "fundar",
    "fungo",
    "funil",
    "furador",
    "furioso",
    "futebol",
    "gabarito",
    "gabinete",
    "gado",
    "gaiato",
    "gaiola",
    "gaivota",
    "galega",
    "galho",
    "galinha",
    "galocha",
    "ganhar",
    "garagem",
    "garfo",
    "gargalo",
    "garimpo",
    "garoupa",
    "garrafa",
    "gasoduto",
    "gasto",
    "gata",
    "gatilho",
    "gaveta",
    "gazela",
    "gelado",
    "geleia",
    "gelo",
    "gemada",
    "gemer",
    "gemido",
    "generoso",
    "gengiva",
    "genial",
    "genoma",
    "genro",
    "geologia",
    "gerador",
    "germinar",
    "gesso",
    "gestor",
    "ginasta",
    "gincana",
    "gingado",
    "girafa",
    "girino",
    "glacial",
    "glicose",
    "global",
    "glorioso",
    "goela",
    "goiaba",
    "golfe",
    "golpear",
    "gordura",
    "gorjeta",
    "gorro",
    "gostoso",
    "goteira",
    "governar",
    "gracejo",
    "gradual",
    "grafite",
    "gralha",
    "grampo",
    "granada",
    "gratuito",
    "graveto",
    "graxa",
    "grego",
    "grelhar",
    "greve",
    "grilo",
    "grisalho",
    "gritaria",
    "grosso",
    "grotesco",
    "grudado",
    "grunhido",
    "gruta",
    "guache",
    "guarani",
    "guaxinim",
    "guerrear",
    "guiar",
    "guincho",
    "guisado",
    "gula",
    "guloso",
    "guru",
    "habitar",
    "harmonia",
    "haste",
    "haver",
    "hectare",
    "herdar",
    "heresia",
    "hesitar",
    "hiato",
    "hibernar",
    "hidratar",
    "hiena",
    "hino",
    "hipismo",
    "hipnose",
    "hipoteca",
    "hoje",
    "holofote",
    "homem",
    "honesto",
    "honrado",
    "hormonal",
    "hospedar",
    "humorado",
    "iate",
    "ideia",
    "idoso",
    "ignorado",
    "igreja",
    "iguana",
    "ileso",
    "ilha",
    "iludido",
    "iluminar",
    "ilustrar",
    "imagem",
    "imediato",
    "imenso",
    "imersivo",
    "iminente",
    "imitador",
    "imortal",
    "impacto",
    "impedir",
    "implante",
    "impor",
    "imprensa",
    "impune",
    "imunizar",
    "inalador",
    "inapto",
    "inativo",
    "incenso",
    "inchar",
    "incidir",
    "incluir",
    "incolor",
    "indeciso",
    "indireto",
    "indutor",
    "ineficaz",
    "inerente",
    "infantil",
    "infestar",
    "infinito",
    "inflamar",
    "informal",
    "infrator",
    "ingerir",
    "inibido",
    "inicial",
    "inimigo",
    "injetar",
    "inocente",
    "inodoro",
    "inovador",
    "inox",
    "inquieto",
    "inscrito",
    "inseto",
    "insistir",
    "inspetor",
    "instalar",
    "insulto",
    "intacto",
    "integral",
    "intimar",
    "intocado",
    "intriga",
    "invasor",
    "inverno",
    "invicto",
    "invocar",
    "iogurte",
    "iraniano",
    "ironizar",
    "irreal",
    "irritado",
    "isca",
    "isento",
    "isolado",
    "isqueiro",
    "italiano",
    "janeiro",
    "jangada",
    "janta",
    "jararaca",
    "jardim",
    "jarro",
    "jasmim",
    "jato",
    "javali",
    "jazida",
    "jejum",
    "joaninha",
    "joelhada",
    "jogador",
    "joia",
    "jornal",
    "jorrar",
    "jovem",
    "juba",
    "judeu",
    "judoca",
    "juiz",
    "julgador",
    "julho",
    "jurado",
    "jurista",
    "juro",
    "justa",
    "labareda",
    "laboral",
    "lacre",
    "lactante",
    "ladrilho",
    "lagarta",
    "lagoa",
    "laje",
    "lamber",
    "lamentar",
    "laminar",
    "lampejo",
    "lanche",
    "lapidar",
    "lapso",
    "laranja",
    "lareira",
    "largura",
    "lasanha",
    "lastro",
    "lateral",
    "latido",
    "lavanda",
    "lavoura",
    "lavrador",
    "laxante",
    "lazer",
    "lealdade",
    "lebre",
    "legado",
    "legendar",
    "legista",
    "leigo",
    "leiloar",
    "leitura",
    "lembrete",
    "leme",
    "lenhador",
    "lentilha",
    "leoa",
    "lesma",
    "leste",
    "letivo",
    "letreiro",
    "levar",
    "leveza",
    "levitar",
    "liberal",
    "libido",
    "liderar",
    "ligar",
    "ligeiro",
    "limitar",
    "limoeiro",
    "limpador",
    "linda",
    "linear",
    "linhagem",
    "liquidez",
    "listagem",
    "lisura",
    "litoral",
    "livro",
    "lixa",
    "lixeira",
    "locador",
    "locutor",
    "lojista",
    "lombo",
    "lona",
    "longe",
    "lontra",
    "lorde",
    "lotado",
    "loteria",
    "loucura",
    "lousa",
    "louvar",
    "luar",
    "lucidez",
    "lucro",
    "luneta",
    "lustre",
    "lutador",
    "luva",
    "macaco",
    "macete",
    "machado",
    "macio",
    "madeira",
    "madrinha",
    "magnata",
    "magreza",
    "maior",
    "mais",
    "malandro",
    "malha",
    "malote",
    "maluco",
    "mamilo",
    "mamoeiro",
    "mamute",
    "manada",
    "mancha",
    "mandato",
    "manequim",
    "manhoso",
    "manivela",
    "manobrar",
    "mansa",
    "manter",
    "manusear",
    "mapeado",
    "maquinar",
    "marcador",
    "maresia",
    "marfim",
    "margem",
    "marinho",
    "marmita",
    "maroto",
    "marquise",
    "marreco",
    "martelo",
    "marujo",
    "mascote",
    "masmorra",
    "massagem",
    "mastigar",
    "matagal",
    "materno",
    "matinal",
    "matutar",
    "maxilar",
    "medalha",
    "medida",
    "medusa",
    "megafone",
    "meiga",
    "melancia",
    "melhor",
    "membro",
    "memorial",
    "menino",
    "menos",
    "mensagem",
    "mental",
    "merecer",
    "mergulho",
    "mesada",
    "mesclar",
    "mesmo",
    "mesquita",
    "mestre",
    "metade",
    "meteoro",
    "metragem",
    "mexer",
    "mexicano",
    "micro",
    "migalha",
    "migrar",
    "milagre",
    "milenar",
    "milhar",
    "mimado",
    "minerar",
    "minhoca",
    "ministro",
    "minoria",
    "miolo",
    "mirante",
    "mirtilo",
    "misturar",
    "mocidade",
    "moderno",
    "modular",
    "moeda",
    "moer",
    "moinho",
    "moita",
    "moldura",
    "moleza",
    "molho",
    "molinete",
    "molusco",
    "montanha",
    "moqueca",
    "morango",
    "morcego",
    "mordomo",
    "morena",
    "mosaico",
    "mosquete",
    "mostarda",
    "motel",
    "motim",
    "moto",
    "motriz",
    "muda",
    "muito",
    "mulata",
    "mulher",
    "multar",
    "mundial",
    "munido",
    "muralha",
    "murcho",
    "muscular",
    "museu",
    "musical",
    "nacional",
    "nadador",
    "naja",
    "namoro",
    "narina",
    "narrado",
    "nascer",
    "nativa",
    "natureza",
    "navalha",
    "navegar",
    "navio",
    "neblina",
    "nebuloso",
    "negativa",
    "negociar",
    "negrito",
    "nervoso",
    "neta",
    "neural",
    "nevasca",
    "nevoeiro",
    "ninar",
    "ninho",
    "nitidez",
    "nivelar",
    "nobreza",
    "noite",
    "noiva",
    "nomear",
    "nominal",
    "nordeste",
    "nortear",
    "notar",
    "noticiar",
    "noturno",
    "novelo",
    "novilho",
    "novo",
    "nublado",
    "nudez",
    "numeral",
    "nupcial",
    "nutrir",
    "nuvem",
    "obcecado",
    "obedecer",
    "objetivo",
    "obrigado",
    "obscuro",
    "obstetra",
    "obter",
    "obturar",
    "ocidente",
    "ocioso",
    "ocorrer",
    "oculista",
    "ocupado",
    "ofegante",
    "ofensiva",
    "oferenda",
    "oficina",
    "ofuscado",
    "ogiva",
    "olaria",
    "oleoso",
    "olhar",
    "oliveira",
    "ombro",
    "omelete",
    "omisso",
    "omitir",
    "ondulado",
    "oneroso",
    "ontem",
    "opcional",
    "operador",
    "oponente",
    "oportuno",
    "oposto",
    "orar",
    "orbitar",
    "ordem",
    "ordinal",
    "orfanato",
    "orgasmo",
    "orgulho",
    "oriental",
    "origem",
    "oriundo",
    "orla",
    "ortodoxo",
    "orvalho",
    "oscilar",
    "ossada",
    "osso",
    "ostentar",
    "otimismo",
    "ousadia",
    "outono",
    "outubro",
    "ouvido",
    "ovelha",
    "ovular",
    "oxidar",
    "oxigenar",
    "pacato",
    "paciente",
    "pacote",
    "pactuar",
    "padaria",
    "padrinho",
    "pagar",
    "pagode",
    "painel",
    "pairar",
    "paisagem",
    "palavra",
    "palestra",
    "palheta",
    "palito",
    "palmada",
    "palpitar",
    "pancada",
    "panela",
    "panfleto",
    "panqueca",
    "pantanal",
    "papagaio",
    "papelada",
    "papiro",
    "parafina",
    "parcial",
    "pardal",
    "parede",
    "partida",
    "pasmo",
    "passado",
    "pastel",
    "patamar",
    "patente",
    "patinar",
    "patrono",
    "paulada",
    "pausar",
    "peculiar",
    "pedalar",
    "pedestre",
    "pediatra",
    "pedra",
    "pegada",
    "peitoral",
    "peixe",
    "pele",
    "pelicano",
    "penca",
    "pendurar",
    "peneira",
    "penhasco",
    "pensador",
    "pente",
    "perceber",
    "perfeito",
    "pergunta",
    "perito",
    "permitir",
    "perna",
    "perplexo",
    "persiana",
    "pertence",
    "peruca",
    "pescado",
    "pesquisa",
    "pessoa",
    "petiscar",
    "piada",
    "picado",
    "piedade",
    "pigmento",
    "pilastra",
    "pilhado",
    "pilotar",
    "pimenta",
    "pincel",
    "pinguim",
    "pinha",
    "pinote",
    "pintar",
    "pioneiro",
    "pipoca",
    "piquete",
    "piranha",
    "pires",
    "pirueta",
    "piscar",
    "pistola",
    "pitanga",
    "pivete",
    "planta",
    "plaqueta",
    "platina",
    "plebeu",
    "plumagem",
    "pluvial",
    "pneu",
    "poda",
    "poeira",
    "poetisa",
    "polegada",
    "policiar",
    "poluente",
    "polvilho",
    "pomar",
    "pomba",
    "ponderar",
    "pontaria",
    "populoso",
    "porta",
    "possuir",
    "postal",
    "pote",
    "poupar",
    "pouso",
    "povoar",
    "praia",
    "prancha",
    "prato",
    "praxe",
    "prece",
    "predador",
    "prefeito",
    "premiar",
    "prensar",
    "preparar",
    "presilha",
    "pretexto",
    "prevenir",
    "prezar",
    "primata",
    "princesa",
    "prisma",
    "privado",
    "processo",
    "produto",
    "profeta",
    "proibido",
    "projeto",
    "prometer",
    "propagar",
    "prosa",
    "protetor",
    "provador",
    "publicar",
    "pudim",
    "pular",
    "pulmonar",
    "pulseira",
    "punhal",
    "punir",
    "pupilo",
    "pureza",
    "puxador",
    "quadra",
    "quantia",
    "quarto",
    "quase",
    "quebrar",
    "queda",
    "queijo",
    "quente",
    "querido",
    "quimono",
    "quina",
    "quiosque",
    "rabanada",
    "rabisco",
    "rachar",
    "racionar",
    "radial",
    "raiar",
    "rainha",
    "raio",
    "raiva",
    "rajada",
    "ralado",
    "ramal",
    "ranger",
    "ranhura",
    "rapadura",
    "rapel",
    "rapidez",
    "raposa",
    "raquete",
    "raridade",
    "rasante",
    "rascunho",
    "rasgar",
    "raspador",
    "rasteira",
    "rasurar",
    "ratazana",
    "ratoeira",
    "realeza",
    "reanimar",
    "reaver",
    "rebaixar",
    "rebelde",
    "rebolar",
    "recado",
    "recente",
    "recheio",
    "recibo",
    "recordar",
    "recrutar",
    "recuar",
    "rede",
    "redimir",
    "redonda",
    "reduzida",
    "reenvio",
    "refinar",
    "refletir",
    "refogar",
    "refresco",
    "refugiar",
    "regalia",
    "regime",
    "regra",
    "reinado",
    "reitor",
    "rejeitar",
    "relativo",
    "remador",
    "remendo",
    "remorso",
    "renovado",
    "reparo",
    "repelir",
    "repleto",
    "repolho",
    "represa",
    "repudiar",
    "requerer",
    "resenha",
    "resfriar",
    "resgatar",
    "residir",
    "resolver",
    "respeito",
    "ressaca",
    "restante",
    "resumir",
    "retalho",
    "reter",
    "retirar",
    "retomada",
    "retratar",
    "revelar",
    "revisor",
    "revolta",
    "riacho",
    "rica",
    "rigidez",
    "rigoroso",
    "rimar",
    "ringue",
    "risada",
    "risco",
    "risonho",
    "robalo",
    "rochedo",
    "rodada",
    "rodeio",
    "rodovia",
    "roedor",
    "roleta",
    "romano",
    "roncar",
    "rosado",
    "roseira",
    "rosto",
    "rota",
    "roteiro",
    "rotina",
    "rotular",
    "rouco",
    "roupa",
    "roxo",
    "rubro",
    "rugido",
    "rugoso",
    "ruivo",
    "rumo",
    "rupestre",
    "russo",
    "sabor",
    "saciar",
    "sacola",
    "sacudir",
    "sadio",
    "safira",
    "saga",
    "sagrada",
    "saibro",
    "salada",
    "saleiro",
    "salgado",
    "saliva",
    "salpicar",
    "salsicha",
    "saltar",
    "salvador",
    "sambar",
    "samurai",
    "sanar",
    "sanfona",
    "sangue",
    "sanidade",
    "sapato",
    "sarda",
    "sargento",
    "sarjeta",
    "saturar",
    "saudade",
    "saxofone",
    "sazonal",
    "secar",
    "secular",
    "seda",
    "sedento",
    "sediado",
    "sedoso",
    "sedutor",
    "segmento",
    "segredo",
    "segundo",
    "seiva",
    "seleto",
    "selvagem",
    "semanal",
    "semente",
    "senador",
    "senhor",
    "sensual",
    "sentado",
    "separado",
    "sereia",
    "seringa",
    "serra",
    "servo",
    "setembro",
    "setor",
    "sigilo",
    "silhueta",
    "silicone",
    "simetria",
    "simpatia",
    "simular",
    "sinal",
    "sincero",
    "singular",
    "sinopse",
    "sintonia",
    "sirene",
    "siri",
    "situado",
    "soberano",
    "sobra",
    "socorro",
    "sogro",
    "soja",
    "solda",
    "soletrar",
    "solteiro",
    "sombrio",
    "sonata",
    "sondar",
    "sonegar",
    "sonhador",
    "sono",
    "soprano",
    "soquete",
    "sorrir",
    "sorteio",
    "sossego",
    "sotaque",
    "soterrar",
    "sovado",
    "sozinho",
    "suavizar",
    "subida",
    "submerso",
    "subsolo",
    "subtrair",
    "sucata",
    "sucesso",
    "suco",
    "sudeste",
    "sufixo",
    "sugador",
    "sugerir",
    "sujeito",
    "sulfato",
    "sumir",
    "suor",
    "superior",
    "suplicar",
    "suposto",
    "suprimir",
    "surdina",
    "surfista",
    "surpresa",
    "surreal",
    "surtir",
    "suspiro",
    "sustento",
    "tabela",
    "tablete",
    "tabuada",
    "tacho",
    "tagarela",
    "talher",
    "talo",
    "talvez",
    "tamanho",
    "tamborim",
    "tampa",
    "tangente",
    "tanto",
    "tapar",
    "tapioca",
    "tardio",
    "tarefa",
    "tarja",
    "tarraxa",
    "tatuagem",
    "taurino",
    "taxativo",
    "taxista",
    "teatral",
    "tecer",
    "tecido",
    "teclado",
    "tedioso",
    "teia",
    "teimar",
    "telefone",
    "telhado",
    "tempero",
    "tenente",
    "tensor",
    "tentar",
    "termal",
    "terno",
    "terreno",
    "tese",
    "tesoura",
    "testado",
    "teto",
    "textura",
    "texugo",
    "tiara",
    "tigela",
    "tijolo",
    "timbrar",
    "timidez",
    "tingido",
    "tinteiro",
    "tiragem",
    "titular",
    "toalha",
    "tocha",
    "tolerar",
    "tolice",
    "tomada",
    "tomilho",
    "tonel",
    "tontura",
    "topete",
    "tora",
    "torcido",
    "torneio",
    "torque",
    "torrada",
    "torto",
    "tostar",
    "touca",
    "toupeira",
    "toxina",
    "trabalho",
    "tracejar",
    "tradutor",
    "trafegar",
    "trajeto",
    "trama",
    "trancar",
    "trapo",
    "traseiro",
    "tratador",
    "travar",
    "treino",
    "tremer",
    "trepidar",
    "trevo",
    "triagem",
    "tribo",
    "triciclo",
    "tridente",
    "trilogia",
    "trindade",
    "triplo",
    "triturar",
    "triunfal",
    "trocar",
    "trombeta",
    "trova",
    "trunfo",
    "truque",
    "tubular",
    "tucano",
    "tudo",
    "tulipa",
    "tupi",
    "turbo",
    "turma",
    "turquesa",
    "tutelar",
    "tutorial",
    "uivar",
    "umbigo",
    "unha",
    "unidade",
    "uniforme",
    "urologia",
    "urso",
    "urtiga",
    "urubu",
    "usado",
    "usina",
    "usufruir",
    "vacina",
    "vadiar",
    "vagaroso",
    "vaidoso",
    "vala",
    "valente",
    "validade",
    "valores",
    "vantagem",
    "vaqueiro",
    "varanda",
    "vareta",
    "varrer",
    "vascular",
    "vasilha",
    "vassoura",
    "vazar",
    "vazio",
    "veado",
    "vedar",
    "vegetar",
    "veicular",
    "veleiro",
    "velhice",
    "veludo",
    "vencedor",
    "vendaval",
    "venerar",
    "ventre",
    "verbal",
    "verdade",
    "vereador",
    "vergonha",
    "vermelho",
    "verniz",
    "versar",
    "vertente",
    "vespa",
    "vestido",
    "vetorial",
    "viaduto",
    "viagem",
    "viajar",
    "viatura",
    "vibrador",
    "videira",
    "vidraria",
    "viela",
    "viga",
    "vigente",
    "vigiar",
    "vigorar",
    "vilarejo",
    "vinco",
    "vinheta",
    "vinil",
    "violeta",
    "virada",
    "virtude",
    "visitar",
    "visto",
    "vitral",
    "viveiro",
    "vizinho",
    "voador",
    "voar",
    "vogal",
    "volante",
    "voleibol",
    "voltagem",
    "volumoso",
    "vontade",
    "vulto",
    "vuvuzela",
    "xadrez",
    "xarope",
    "xeque",
    "xeretar",
    "xerife",
    "xingar",
    "zangado",
    "zarpar",
    "zebu",
    "zelador",
    "zombar",
    "zoologia",
    "zumbido"
], Tie = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
];
Object.defineProperty(lo, "__esModule", {
    value: !0
});
const Jo = {};
lo.wordlists = Jo;
let Cn;
var eu = lo._default = Cn;
try {
    eu = lo._default = Cn = vie, Jo.czech = Cn;
} catch  {}
try {
    eu = lo._default = Cn = Eie, Jo.chinese_simplified = Cn;
} catch  {}
try {
    eu = lo._default = Cn = Sie, Jo.chinese_traditional = Cn;
} catch  {}
try {
    eu = lo._default = Cn = xie, Jo.korean = Cn;
} catch  {}
try {
    eu = lo._default = Cn = _ie, Jo.french = Cn;
} catch  {}
try {
    eu = lo._default = Cn = kie, Jo.italian = Cn;
} catch  {}
try {
    eu = lo._default = Cn = Oie, Jo.spanish = Cn;
} catch  {}
try {
    eu = lo._default = Cn = Iie, Jo.japanese = Cn, Jo.JA = Cn;
} catch  {}
try {
    eu = lo._default = Cn = Bie, Jo.portuguese = Cn;
} catch  {}
try {
    eu = lo._default = Cn = Tie, Jo.english = Cn, Jo.EN = Cn;
} catch  {}
Object.defineProperty(Js, "__esModule", {
    value: !0
});
const Pie = Ba, QM = gi, $M = fb, Cie = Qr, km = lo;
let w0 = km._default;
const hO = "Invalid mnemonic", cf = "Invalid entropy", Mie = "Invalid mnemonic checksum", ZM = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function A0(e) {
    return (e || "").normalize("NFKD");
}
function XM(e, t, r) {
    for(; e.length < r;)e = t + e;
    return e;
}
function YM(e) {
    return parseInt(e, 2);
}
function JM(e) {
    return e.map((t)=>XM(t.toString(2), "0", 8)).join("");
}
function eN(e) {
    const t = e.length * 8 / 32, r = Pie.sha256(Uint8Array.from(e));
    return JM(Array.from(r)).slice(0, t);
}
function tN(e) {
    return "mnemonic" + (e || "");
}
function Nie(e, t) {
    const r = Uint8Array.from(Ke.from(A0(e), "utf8")), n = Uint8Array.from(Ke.from(tN(A0(t)), "utf8")), i1 = $M.pbkdf2(QM.sha512, r, n, {
        c: 2048,
        dkLen: 64
    });
    return Ke.from(i1);
}
Js.mnemonicToSeedSync = Nie;
function Rie(e, t) {
    const r = Uint8Array.from(Ke.from(A0(e), "utf8")), n = Uint8Array.from(Ke.from(tN(A0(t)), "utf8"));
    return $M.pbkdf2Async(QM.sha512, r, n, {
        c: 2048,
        dkLen: 64
    }).then((i1)=>Ke.from(i1));
}
var Uie = Js.mnemonicToSeed = Rie;
function rN(e, t) {
    if (t = t || w0, !t) throw new Error(ZM);
    const r = A0(e).split(" ");
    if (r.length % 3 !== 0) throw new Error(hO);
    const n = r.map((l)=>{
        const u = t.indexOf(l);
        if (u === -1) throw new Error(hO);
        return XM(u.toString(2), "0", 11);
    }).join(""), i1 = Math.floor(n.length / 33) * 32, o = n.slice(0, i1), a = n.slice(i1), s = o.match(/(.{1,8})/g).map(YM);
    if (s.length < 16) throw new Error(cf);
    if (s.length > 32) throw new Error(cf);
    if (s.length % 4 !== 0) throw new Error(cf);
    const c = Ke.from(s);
    if (eN(c) !== a) throw new Error(Mie);
    return c.toString("hex");
}
Js.mnemonicToEntropy = rN;
function nN(e, t) {
    if (Ke.isBuffer(e) || (e = Ke.from(e, "hex")), t = t || w0, !t) throw new Error(ZM);
    if (e.length < 16) throw new TypeError(cf);
    if (e.length > 32) throw new TypeError(cf);
    if (e.length % 4 !== 0) throw new TypeError(cf);
    const r = JM(Array.from(e)), n = eN(e), i1 = (r + n).match(/(.{1,11})/g).map((o)=>{
        const a = YM(o);
        return t[a];
    });
    return t[0] === "" ? i1.join("") : i1.join(" ");
}
var Die = Js.entropyToMnemonic = nN;
function jie(e, t, r) {
    if (e = e || 128, e % 32 !== 0) throw new TypeError(cf);
    return t = t || ((n)=>Ke.from(Cie.randomBytes(n))), nN(t(e / 8), r);
}
Js.generateMnemonic = jie;
function Fie(e, t) {
    try {
        rN(e, t);
    } catch  {
        return !1;
    }
    return !0;
}
Js.validateMnemonic = Fie;
function zie(e) {
    const t = km.wordlists[e];
    if (t) w0 = t;
    else throw new Error('Could not find wordlist for language "' + e + '"');
}
Js.setDefaultWordlist = zie;
function Lie() {
    if (!w0) throw new Error("No Default Wordlist set");
    return Object.keys(km.wordlists).filter((e)=>e === "JA" || e === "EN" ? !1 : km.wordlists[e].every((t, r)=>t === w0[r]))[0];
}
Js.getDefaultWordlist = Lie;
var Hie = lo;
Js.wordlists = Hie.wordlists;
let iN = class extends sT {
    constructor(e, t){
        super(), this.finished = !1, this.destroyed = !1, qW(e);
        const r = g6(t);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const n = this.blockLen, i1 = new Uint8Array(n);
        i1.set(r.length > n ? e.create().update(r).digest() : r);
        for(let o = 0; o < i1.length; o++)i1[o] ^= 54;
        this.iHash.update(i1), this.oHash = e.create();
        for(let o = 0; o < i1.length; o++)i1[o] ^= 106;
        this.oHash.update(i1), $c(i1);
    }
    update(e) {
        return lm(this), this.iHash.update(e), this;
    }
    digestInto(e) {
        lm(this), I2(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: t, iHash: r, finished: n, destroyed: i1, blockLen: o, outputLen: a } = this;
        return e = e, e.finished = n, e.destroyed = i1, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const oN = (e, t, r)=>new iN(e, t).update(r).digest();
oN.create = (e, t)=>new iN(e, t);
const Kie = bG;
function qie(e) {
    return hT(_i(e));
}
function pO(e, t) {
    return oN(Kie, e, t);
}
const vr = (e)=>MG(e);
function Vie(e) {
    if (Jn(e.isPoint(vr("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Jn(!e.isPoint(vr("030000000000000000000000000000000000000000000000000000000000000005"))), Jn(e.isPrivate(vr("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Jn(e.isPrivate(vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), Jn(!e.isPrivate(vr("0000000000000000000000000000000000000000000000000000000000000000"))), Jn(!e.isPrivate(vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), Jn(!e.isPrivate(vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), Jn(yu(e.pointFromScalar(vr("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), vr("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
        Jn(e.xOnlyPointAddTweak(vr("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
        let t = e.xOnlyPointAddTweak(vr("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), vr("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
        Jn(yu(t.xOnlyPubkey, vr("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(vr("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), vr("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    Jn(yu(e.pointAddScalar(vr("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), vr("0000000000000000000000000000000000000000000000000000000000000003")), vr("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), Jn(yu(e.privateAdd(vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), vr("0000000000000000000000000000000000000000000000000000000000000002")), vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (Jn(yu(e.privateNegate(vr("0000000000000000000000000000000000000000000000000000000000000001")), vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), Jn(yu(e.privateNegate(vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), vr("0000000000000000000000000000000000000000000000000000000000000003")) === 0), Jn(yu(e.privateNegate(vr("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), vr("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), Jn(yu(e.sign(vr("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), vr("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), vr("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), Jn(e.verify(vr("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), vr("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), vr("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && Jn(yu(e.signSchnorr(vr("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), vr("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), vr("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), vr("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && Jn(e.verifySchnorr(vr("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), vr("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), vr("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function Jn(e) {
    if (!e) throw new Error("ecc library invalid");
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function H8(e) {
    return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function aN(e, t) {
    return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((r)=>typeof r == "string") : t.every((r)=>Number.isSafeInteger(r)) : !1;
}
function Wie(e) {
    if (typeof e != "function") throw new Error("function expected");
    return !0;
}
function K8(e, t) {
    if (typeof t != "string") throw new Error(`${e}: string expected`);
    return !0;
}
function h5(e) {
    if (!Number.isSafeInteger(e)) throw new Error(`invalid integer: ${e}`);
}
function q8(e) {
    if (!Array.isArray(e)) throw new Error("array expected");
}
function sN(e, t) {
    if (!aN(!0, t)) throw new Error(`${e}: array of strings expected`);
}
function Gie(e, t) {
    if (!aN(!1, t)) throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function uN(...e) {
    const t = (o)=>o, r = (o, a)=>(s)=>o(a(s)), n = e.map((o)=>o.encode).reduceRight(r, t), i1 = e.map((o)=>o.decode).reduce(r, t);
    return {
        encode: n,
        decode: i1
    };
}
// @__NO_SIDE_EFFECTS__
function Qie(e) {
    const t = e.split(""), r = t.length;
    sN("alphabet", t);
    const n = new Map(t.map((i1, o)=>[
            i1,
            o
        ]));
    return {
        encode: (i1)=>(q8(i1), i1.map((o)=>{
                if (!Number.isSafeInteger(o) || o < 0 || o >= r) throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);
                return t[o];
            })),
        decode: (i1)=>(q8(i1), i1.map((o)=>{
                K8("alphabet.decode", o);
                const a = n.get(o);
                if (a === void 0) throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);
                return a;
            }))
    };
}
// @__NO_SIDE_EFFECTS__
function $ie(e = "") {
    return K8("join", e), {
        encode: (t)=>(sN("join.decode", t), t.join(e)),
        decode: (t)=>(K8("join.decode", t), t.split(e))
    };
}
function gO(e, t, r) {
    if (t < 2) throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
    if (q8(e), !e.length) return [];
    let n = 0;
    const i1 = [], o = Array.from(e, (s)=>{
        if (h5(s), s < 0 || s >= t) throw new Error(`invalid integer: ${s}`);
        return s;
    }), a = o.length;
    for(;;){
        let s = 0, c = !0;
        for(let l = n; l < a; l++){
            const u = o[l], f = t * s, h = f + u;
            if (!Number.isSafeInteger(h) || f / t !== s || h - u !== f) throw new Error("convertRadix: carry overflow");
            const y = h / r;
            s = h % r;
            const S = Math.floor(y);
            if (o[l] = S, !Number.isSafeInteger(S) || S * r + s !== h) throw new Error("convertRadix: carry overflow");
            if (c) S ? c = !1 : n = l;
            else continue;
        }
        if (i1.push(s), c) break;
    }
    for(let s = 0; s < e.length - 1 && e[s] === 0; s++)i1.push(0);
    return i1.reverse();
}
// @__NO_SIDE_EFFECTS__
function Zie(e) {
    h5(e);
    const t = 2 ** 8;
    return {
        encode: (r)=>{
            if (!H8(r)) throw new Error("radix.encode input should be Uint8Array");
            return gO(Array.from(r), t, e);
        },
        decode: (r)=>(Gie("radix.decode", r), Uint8Array.from(gO(r, e, t)))
    };
}
function Xie(e, t) {
    return h5(e), Wie(t), {
        encode (r) {
            if (!H8(r)) throw new Error("checksum.encode: input should be Uint8Array");
            const n = t(r).slice(0, e), i1 = new Uint8Array(r.length + e);
            return i1.set(r), i1.set(n, r.length), i1;
        },
        decode (r) {
            if (!H8(r)) throw new Error("checksum.decode: input should be Uint8Array");
            const n = r.slice(0, -e), i1 = r.slice(-e), o = t(n).slice(0, e);
            for(let a = 0; a < e; a++)if (o[a] !== i1[a]) throw new Error("Invalid checksum");
            return n;
        }
    };
}
const Yie = /* @__NO_SIDE_EFFECTS__ */ (e)=>/* @__PURE__ */ uN(/* @__PURE__ */ Zie(58), /* @__PURE__ */ Qie(e), /* @__PURE__ */ $ie("")), Jie = /* @__PURE__ */ Yie("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), eoe = (e)=>/* @__PURE__ */ uN(Xie(4, (t)=>e(e(t))), Jie), toe = eoe;
function roe(e) {
    return {
        lang: (e == null ? void 0 : e.lang) ?? void 0,
        message: e == null ? void 0 : e.message,
        abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
        abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
    };
}
function noe(e, t) {
    var r;
    return (r = void 0) == null ? void 0 : r.get(t);
}
function v0(e) {
    var t, r;
    const n = typeof e;
    return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function qu(e, t, r, n, i1) {
    const o = i1 && "input" in i1 ? i1.input : r.value, a = (i1 == null ? void 0 : i1.expected) ?? e.expects ?? null, s = (i1 == null ? void 0 : i1.received) ?? v0(o), c = {
        kind: e.kind,
        type: e.type,
        input: o,
        expected: a,
        received: s,
        message: `Invalid ${t}: ${a ? `Expected ${a} but r` : "R"}eceived ${s}`,
        // @ts-expect-error
        requirement: e.requirement,
        path: i1 == null ? void 0 : i1.path,
        issues: i1 == null ? void 0 : i1.issues,
        lang: n.lang,
        abortEarly: n.abortEarly,
        abortPipeEarly: n.abortPipeEarly
    }, l = e.kind === "schema", u = (i1 == null ? void 0 : i1.message) ?? // @ts-expect-error
    e.message ?? noe(e.reference, c.lang) ?? (l ? (c.lang, void 0) : null) ?? n.message ?? (c.lang, void 0);
    u && (c.message = typeof u == "function" ? u(c) : u), l && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [
        c
    ];
}
var ioe = class extends Error {
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(e){
        super(e[0].message), wt(this, "issues"), this.name = "ValiError", this.issues = e;
    }
};
function db(e) {
    return {
        kind: "validation",
        type: "integer",
        reference: db,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run (t, r) {
            return t.typed && !this.requirement(t.value) && qu(this, "integer", t, r), t;
        }
    };
}
function p5(e, t) {
    return {
        kind: "validation",
        type: "length",
        reference: p5,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value.length !== this.requirement && qu(this, "length", r, n, {
                received: `${r.value.length}`
            }), r;
        }
    };
}
function hb(e, t) {
    return {
        kind: "validation",
        type: "max_value",
        reference: hb,
        async: !1,
        expects: `<=${e instanceof Date ? e.toJSON() : v0(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value > this.requirement && qu(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : v0(r.value)
            }), r;
        }
    };
}
function pb(e, t) {
    return {
        kind: "validation",
        type: "min_value",
        reference: pb,
        async: !1,
        expects: `>=${e instanceof Date ? e.toJSON() : v0(e)}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && r.value < this.requirement && qu(this, "value", r, n, {
                received: r.value instanceof Date ? r.value.toJSON() : v0(r.value)
            }), r;
        }
    };
}
function cN(e, t) {
    return {
        kind: "validation",
        type: "regex",
        reference: cN,
        async: !1,
        expects: `${e}`,
        requirement: e,
        message: t,
        _run (r, n) {
            return r.typed && !this.requirement.test(r.value) && qu(this, "format", r, n), r;
        }
    };
}
function gb(e, t) {
    return {
        kind: "schema",
        type: "instance",
        reference: gb,
        expects: e.name,
        async: !1,
        class: e,
        message: t,
        _run (r, n) {
            return r.value instanceof this.class ? r.typed = !0 : qu(this, "type", r, n), r;
        }
    };
}
function yb(e) {
    return {
        kind: "schema",
        type: "number",
        reference: yb,
        expects: "number",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : qu(this, "type", t, r), t;
        }
    };
}
function V8(e, t) {
    return {
        kind: "schema",
        type: "object",
        reference: V8,
        expects: "Object",
        async: !1,
        entries: e,
        message: t,
        _run (r, n) {
            var i1;
            const o = r.value;
            if (o && typeof o == "object") {
                r.typed = !0, r.value = {};
                for(const a in this.entries){
                    const s = o[a], c = this.entries[a]._run({
                        typed: !1,
                        value: s
                    }, n);
                    if (c.issues) {
                        const l = {
                            type: "object",
                            origin: "value",
                            input: o,
                            key: a,
                            value: s
                        };
                        for (const u of c.issues)u.path ? u.path.unshift(l) : u.path = [
                            l
                        ], (i1 = r.issues) == null || i1.push(u);
                        if (r.issues || (r.issues = c.issues), n.abortEarly) {
                            r.typed = !1;
                            break;
                        }
                    }
                    c.typed || (r.typed = !1), (c.value !== void 0 || a in o) && (r.value[a] = c.value);
                }
            } else qu(this, "type", r, n);
            return r;
        }
    };
}
function lN(e) {
    return {
        kind: "schema",
        type: "string",
        reference: lN,
        expects: "string",
        async: !1,
        message: e,
        _run (t, r) {
            return typeof t.value == "string" ? t.typed = !0 : qu(this, "type", t, r), t;
        }
    };
}
function mu(e, t, r) {
    const n = e._run({
        typed: !1,
        value: t
    }, roe(r));
    if (n.issues) throw new ioe(n.issues);
    return n.value;
}
function Lh(...e) {
    return {
        ...e[0],
        pipe: e,
        _run (t, r) {
            for (const n of e)if (n.kind !== "metadata") {
                if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
                    t.typed = !1;
                    break;
                }
                (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
            }
            return t;
        }
    };
}
const W8 = Lh(yb(), db(), pb(0), hb(4294967295)), ooe = Lh(yb(), db(), pb(0), hb(2147483647)), aoe = Lh(yb(), db(), pb(0), hb(255)), w3 = Lh(gb(Uint8Array), p5(32)), soe = Lh(gb(Uint8Array), p5(33)), uoe = V8({
    wif: aoe,
    bip32: V8({
        public: W8,
        private: W8
    })
}), coe = Lh(lN(), cN(/^(m\/)?(\d+'?\/)*\d+'?$/));
function loe(e, t, r) {
    if (t.length !== 32) throw new TypeError("Invalid privateKey length");
    var n = new Uint8Array(34), i1 = new DataView(n.buffer);
    return i1.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function foe(e) {
    return ch.encode(loe(e.version, e.privateKey));
}
const yO = toe(_i), mO = {
    encode: (e)=>yO.encode(e),
    decode: (e)=>yO.decode(e)
};
function doe(e) {
    Vie(e);
    const t = {
        messagePrefix: `Bitcoin Signed Message:
`,
        bech32: "bc",
        bip32: {
            public: 76067358,
            private: 76066276
        },
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
    }, r = 2147483648;
    function n(h) {
        return h.length === 32 ? h : h.slice(1, 33);
    }
    class i1 {
        constructor(y, S){
            wt(this, "__D"), wt(this, "__Q"), wt(this, "lowR", !1), this.__D = y, this.__Q = S;
        }
        get publicKey() {
            return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, !0)), this.__Q;
        }
        get privateKey() {
            return this.__D;
        }
        sign(y, S) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (S === void 0 && (S = this.lowR), S === !1) return e.sign(y, this.privateKey);
            {
                let k = e.sign(y, this.privateKey);
                const P = new Uint8Array(32);
                let M = 0;
                for(; k[0] > 127;)M++, Bl(P, 0, M, "LE"), k = e.sign(y, this.privateKey, P);
                return k;
            }
        }
        signSchnorr(y) {
            if (!this.privateKey) throw new Error("Missing private key");
            if (!e.signSchnorr) throw new Error("signSchnorr not supported by ecc library");
            return e.signSchnorr(y, this.privateKey);
        }
        verify(y, S) {
            return e.verify(y, this.publicKey, S);
        }
        verifySchnorr(y, S) {
            if (!e.verifySchnorr) throw new Error("verifySchnorr not supported by ecc library");
            return e.verifySchnorr(y, this.publicKey.subarray(1, 33), S);
        }
    }
    class o extends i1 {
        constructor(y, S, k, P, M = 0, N = 0, z = 0){
            super(y, S), wt(this, "chainCode"), wt(this, "network"), wt(this, "__DEPTH"), wt(this, "__INDEX"), wt(this, "__PARENT_FINGERPRINT"), this.chainCode = k, this.network = P, this.__DEPTH = M, this.__INDEX = N, this.__PARENT_FINGERPRINT = z, mu(uoe, P);
        }
        get depth() {
            return this.__DEPTH;
        }
        get index() {
            return this.__INDEX;
        }
        get parentFingerprint() {
            return this.__PARENT_FINGERPRINT;
        }
        get identifier() {
            return qie(this.publicKey);
        }
        get fingerprint() {
            return this.identifier.slice(0, 4);
        }
        get compressed() {
            return !0;
        }
        // Private === not neutered
        // Public === neutered
        isNeutered() {
            return this.__D === void 0;
        }
        neutered() {
            return u(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
        }
        toBase58() {
            const y = this.network, S = this.isNeutered() ? y.bip32.public : y.bip32.private, k = new Uint8Array(78);
            return Bl(k, 0, S, "BE"), lS(k, 4, this.depth), Bl(k, 5, this.parentFingerprint, "BE"), Bl(k, 9, this.index, "BE"), k.set(this.chainCode, 13), this.isNeutered() ? k.set(this.publicKey, 45) : (lS(k, 45, 0), k.set(this.privateKey, 46)), mO.encode(k);
        }
        toWIF() {
            if (!this.privateKey) throw new TypeError("Missing private key");
            return foe({
                version: this.network.wif,
                privateKey: this.privateKey
            });
        }
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
        derive(y) {
            mu(W8, y);
            const S = y >= r, k = new Uint8Array(37);
            if (S) {
                if (this.isNeutered()) throw new TypeError("Missing private key for hardened child key");
                k[0] = 0, k.set(this.privateKey, 1), Bl(k, 33, y, "BE");
            } else k.set(this.publicKey, 0), Bl(k, 33, y, "BE");
            const P = pO(this.chainCode, k), M = P.slice(0, 32), N = P.slice(32);
            if (!e.isPrivate(M)) return this.derive(y + 1);
            let z;
            if (this.isNeutered()) {
                const K = e.pointAddScalar(this.publicKey, M, !0);
                if (K === null) return this.derive(y + 1);
                z = u(K, N, this.network, this.depth + 1, y, xd(this.fingerprint, 0, "BE"));
            } else {
                const K = e.privateAdd(this.privateKey, M);
                if (K == null) return this.derive(y + 1);
                z = c(K, N, this.network, this.depth + 1, y, xd(this.fingerprint, 0, "BE"));
            }
            return z;
        }
        deriveHardened(y) {
            if (typeof mu(ooe, y) == "number") return this.derive(y + r);
            throw new TypeError("Expected UInt31, got " + y);
        }
        derivePath(y) {
            mu(coe, y);
            let S = y.split("/");
            if (S[0] === "m") {
                if (this.parentFingerprint) throw new TypeError("Expected master, got child");
                S = S.slice(1);
            }
            return S.reduce((k, P)=>{
                let M;
                return P.slice(-1) === "'" ? (M = parseInt(P.slice(0, -1), 10), k.deriveHardened(M)) : (M = parseInt(P, 10), k.derive(M));
            }, this);
        }
        tweak(y) {
            return this.privateKey ? this.tweakFromPrivateKey(y) : this.tweakFromPublicKey(y);
        }
        tweakFromPublicKey(y) {
            const S = n(this.publicKey);
            if (!e.xOnlyPointAddTweak) throw new Error("xOnlyPointAddTweak not supported by ecc library");
            const k = e.xOnlyPointAddTweak(S, y);
            if (!k || k.xOnlyPubkey === null) throw new Error("Cannot tweak public key!");
            const P = Uint8Array.from([
                k.parity === 0 ? 2 : 3
            ]), M = CG([
                P,
                k.xOnlyPubkey
            ]);
            return new i1(void 0, M);
        }
        tweakFromPrivateKey(y) {
            const S = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, k = (()=>{
                if (S) {
                    if (e.privateNegate) return e.privateNegate(this.privateKey);
                    throw new Error("privateNegate not supported by ecc library");
                } else return this.privateKey;
            })(), P = e.privateAdd(k, y);
            if (!P) throw new Error("Invalid tweaked private key!");
            return new i1(P, void 0);
        }
    }
    function a(h, y) {
        const S = mO.decode(h);
        if (S.length !== 78) throw new TypeError("Invalid buffer length");
        y = y || t;
        const k = xd(S, 0, "BE");
        if (k !== y.bip32.private && k !== y.bip32.public) throw new TypeError("Invalid network version");
        const P = S[4], M = xd(S, 5, "BE");
        if (P === 0 && M !== 0) throw new TypeError("Invalid parent fingerprint");
        const N = xd(S, 9, "BE");
        if (P === 0 && N !== 0) throw new TypeError("Invalid index");
        const z = S.slice(13, 45);
        let K;
        if (k === y.bip32.private) {
            if (S[45] !== 0) throw new TypeError("Invalid private key");
            const $ = S.slice(46, 78);
            K = c($, z, y, P, N, M);
        } else {
            const $ = S.slice(45, 78);
            K = u($, z, y, P, N, M);
        }
        return K;
    }
    function s(h, y, S) {
        return c(h, y, S);
    }
    function c(h, y, S, k, P, M) {
        if (mu(w3, h), mu(w3, y), S = S || t, !e.isPrivate(h)) throw new TypeError("Private key not in range [1, n)");
        return new o(h, void 0, y, S, k, P, M);
    }
    function l(h, y, S) {
        return u(h, y, S);
    }
    function u(h, y, S, k, P, M) {
        if (mu(soe, h), mu(w3, y), S = S || t, !e.isPoint(h)) throw new TypeError("Point is not on the curve");
        return new o(void 0, h, y, S, k, P, M);
    }
    function f(h, y) {
        if (mu(gb(Uint8Array), h), h.length < 16) throw new TypeError("Seed should be at least 128 bits");
        if (h.length > 64) throw new TypeError("Seed should be at most 512 bits");
        y = y || t;
        const S = pO(PG("Bitcoin seed"), h), k = S.slice(0, 32), P = S.slice(32);
        return s(k, P, y);
    }
    return {
        fromSeed: f,
        fromBase58: a,
        fromPublicKey: l,
        fromPrivateKey: s
    };
}
const t8e = "text/html", r8e = "text/css", hoe = "text/plain", n8e = "text/javascript", i8e = "text/markdown", o8e = "application/json", a8e = "application/javascript", s8e = "application/xml", u8e = "application/pdf", c8e = "application/zip", l8e = "application/gzip", f8e = "application/xhtml+xml", d8e = "application/rss+xml", h8e = "application/atom+xml", p8e = "application/x-www-form-urlencoded", g8e = "application/octet-stream", y8e = "image/jpeg", m8e = "image/png", b8e = "image/gif", w8e = "image/svg+xml", A8e = "image/webp", v8e = "image/x-icon", E8e = "video/mp4", S8e = "video/webm", x8e = "video/ogg", _8e = "audio/mpeg", k8e = "audio/wav", O8e = "audio/ogg", I8e = "multipart/form-data", Md = "btc", bO = "brc20", wO = "runes", G8 = "alkanes", mb = "bip322", _1 = "ecdsa", k1 = "bip322-simple", fN = async (e = mn)=>await un.get(`${zi(e)}/api/v1/fees/recommended`, {
        headers: {
            "Content-Type": "application/json"
        }
    }).then((t)=>t.data), poe = doe(j2);
w6(j2);
async function goe(e) {
    const t = crypto.getRandomValues(new Uint8Array(32)), r = Die(Ke.from(t)), n = await Uie(r);
    return poe.fromSeed(n, Vr(e)).derivePath("m/44'/0'/0'/0/0").privateKey;
}
const bb = (e, t)=>{
    try {
        const r = Vr(t), n = IT(e);
        if (n.version === r.pubKeyHash) return RZ;
        if (n.version === r.scriptHash) {
            const i1 = Tn(n.hash);
            return i1 && i1.length === 2 && i1[0] === Zr.OP_0 ? UZ : d1;
        }
    } catch  {
        try {
            const r = v6(e);
            if (r.version === 0 && r.data.length === 20) return Fy;
            if (r.version === 0 && r.data.length === 32) return DZ;
            if (r.version === 1 && r.data.length === 32) return sf;
        } catch  {
            return "unknown";
        }
    }
    return "unknown";
}, yoe = (e, t)=>{
    const r = Vr(t);
    return Ma(e, r);
};
function dN(e, t) {
    const r = Vr(t);
    return Ma(e, r);
}
function O1(e, t) {
    var r;
    const n = c1({
        pubkey: Ke.from(e, "hex"),
        network: Vr(t)
    }), i1 = Ph({
        redeem: n,
        network: Vr(t)
    });
    return (r = i1 == null ? void 0 : i1.redeem) == null ? void 0 : r.output;
}
function Si(e, t, r) {
    var n;
    if (!e || typeof e != "object") return r;
    for (const i1 of t)if (e[i1] !== void 0) return ((n = e[i1]) == null ? void 0 : n.toString()) || r;
    return r;
}
function sy(e, t, r) {
    if (!e || typeof e != "object") return r;
    for (const n of t)if (e[n] !== void 0) {
        const i1 = Number(e[n]);
        return isNaN(i1) ? r : i1;
    }
    return r;
}
function qd(e, t = "unknown", r) {
    var n, i1;
    if (!e) return console.warn(`Invalid inscription data from source: ${t}`), {
        id: "",
        inscriptionId: "",
        content: "",
        number: 0,
        address: "",
        contentType: "unknown",
        output: "",
        location: "",
        preview: "",
        genesisTransaction: "",
        height: 0,
        outputValue: 0
    };
    const o = Si(e, [
        "id",
        "inscription_id",
        "inscriptionId"
    ], ""), a = sy(e, [
        "num",
        "number",
        "inscriptionNumber"
    ], 0), s = Si(e, [
        "address",
        "owner",
        "ownerAddress"
    ], ""), c = Si(e, [
        "content_type",
        "contentType",
        "mime",
        "mimeType"
    ], "unknown");
    let l = Si(e, [
        "utxo_txid",
        "txid",
        "transaction_id"
    ], ""), u = sy(e, [
        "vout",
        "utxo_vout"
    ], 0), f = Si(e, [
        "output"
    ], "");
    f || l && (f = `${l}:${u}`), f && (!l || !u) && (console.warn(`Invalid inscription location from source: ${t}`), l = f.split(":")[0], u = Number.parseInt(f.split(":")[1]));
    const h = sy(e, [
        "output_value",
        "value",
        "outputValue",
        "postage",
        "satoshis"
    ], 0), y = sy(e, [
        "height",
        "block_height"
    ], 0);
    let S = Si(e, [
        "genesis_tx_id",
        "genesisTx",
        "genesis_txid",
        "genesisTransaction"
    ], ((i1 = (n = e.inscription_id) == null ? void 0 : n.split("i")) == null ? void 0 : i1[0]) || e.txid || "");
    const k = e.utxo_sat_offset !== void 0 ? e.utxo_sat_offset : 0;
    if (!o) throw console.warn(`Invalid inscription data from source: ${t}`), new Error(`Invalid inscription data from source: ${t}`);
    if (!s) throw console.warn(`Invalid inscription address from source: ${t}`), new Error(`Invalid inscription address from source: ${t}`);
    if (!f) throw console.warn(`Invalid inscription output from source: ${t}`), new Error(`Invalid inscription output from source: ${t}`);
    if (!c) throw console.warn(`Invalid inscription content type from source: ${t}`), new Error(`Invalid inscription content type from source: ${t}`);
    return S || (S = o.split("i")[0]), {
        address: s,
        id: o,
        inscriptionId: o,
        number: a,
        outputValue: h,
        contentType: c,
        output: f,
        location: `${l}:${u}:${k}`,
        content: `${yie(r)}/${o}`,
        preview: `${mie(r)}/${o}`,
        genesisTransaction: S,
        height: y,
        offset: k
    };
}
function moe(e, t = "unknown") {
    const r = [];
    if (!e) return console.warn(`Invalid BRC20 balance data from source: ${t}`), r;
    if (e.data && typeof e.data == "object") return Object.entries(e.data).forEach(([n, i1])=>{
        const o = Si(i1, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), a = Si(i1, [
            "transferable",
            "transferableBalance"
        ], "na"), s = Si(i1, [
            "available",
            "availableBalance"
        ], "0");
        if (!o || !s) {
            console.warn(`Invalid BRC20 balance data from source: ${t}`);
            return;
        }
        const c = {
            ticker: n,
            overall: o,
            transferable: a ?? "na",
            available: s
        };
        r.push(c);
    }), r;
    if (Array.isArray(e)) return e.forEach((n)=>{
        const i1 = Si(n, [
            "ticker",
            "tick",
            "token"
        ], "");
        if (!i1) {
            console.warn(`Missing ticker in BRC20 balance from source: ${t}`);
            return;
        }
        const o = Si(n, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), a = Si(n, [
            "transferable",
            "transferableBalance"
        ], "0"), s = Si(n, [
            "available",
            "availableBalance"
        ], "0");
        if (!o || !s) {
            console.warn(`Invalid BRC20 balance data from source: ${t}`);
            return;
        }
        const c = {
            ticker: i1,
            overall: o,
            transferable: a ?? "na",
            available: s
        };
        r.push(c);
    }), r;
    if (typeof e == "object" && !Array.isArray(e)) {
        const n = Si(e, [
            "ticker",
            "tick",
            "token"
        ], "");
        if (!n) return console.warn(`Missing ticker in BRC20 balance from source: ${t}`), r;
        const i1 = Si(e, [
            "overall",
            "overallBalance",
            "total",
            "totalBalance"
        ], "0"), o = Si(e, [
            "transferable",
            "transferableBalance"
        ], "0"), a = Si(e, [
            "available",
            "availableBalance"
        ], "0");
        if (!i1 || !a) throw console.warn(`Invalid BRC20 balance data from source: ${t}`), new Error(`Invalid BRC20 balance data from source: ${t}`);
        const s = {
            ticker: n,
            overall: i1,
            transferable: o ?? "na",
            available: a
        };
        return r.push(s), r;
    }
    return console.warn(`Unrecognized BRC20 balance format from source: ${t}`), r;
}
class boe {
    constructor(t, r){
        wt(this, "apiUrl", ""), wt(this, "apiKey", ""), wt(this, "networks"), this.networks = {
            [_o]: {
                apiKey: qM,
                apiUrl: Sm(pt.TESTNET4)
            },
            ...r == null ? void 0 : r.networks
        }, this.setNetwork(t);
    }
    getName() {
        return uP;
    }
    setNetwork(t) {
        this.networks[t] ? (this.apiUrl = this.networks[t].apiUrl, this.apiKey = this.networks[t].apiKey) : (this.apiUrl = Sm(t), this.apiKey = this.networks.mainnet.apiKey);
    }
    async call(t, r, n) {
        const i1 = `${this.apiUrl}${r}`;
        try {
            const o = {
                headers: {
                    "Content-Type": "application/json",
                    "api-key": this.apiKey
                }
            }, a = t === "get" ? await un.get(i1, o) : await un.post(i1, n, o);
            if (!a || !a.data) throw new Error(`Invalid response from Maestro API: ${JSON.stringify(a)}`);
            return a.data;
        } catch (o) {
            throw console.error("MaestroDataSource.call error:", o), o;
        }
    }
    async getAddressBtcBalance(t) {
        return (await this.call("get", `/addresses/${t}/balance`)).data;
    }
    async getAddressBrc20Balances(t) {
        return await this.call("get", `/addresses/${t}/brc20`);
    }
    async getAddressInscriptions(t, r = 0, n = 10) {
        let i1, o = r, a = 100, s = null;
        for(; o > 0;){
            const f = Math.min(a, o), h = new URLSearchParams();
            h.append("count", f.toString()), i1 && h.append("cursor", i1);
            const y = `/addresses/${t}/inscriptions?${h.toString()}`;
            if (s = await this.call("get", y), !s.next_cursor && o > f) return {
                ...s,
                data: []
            };
            i1 = s.next_cursor, o -= f;
        }
        const c = new URLSearchParams();
        c.append("count", n.toString()), i1 && c.append("cursor", i1);
        const l = `/addresses/${t}/inscriptions?${c.toString()}`, u = await this.call("get", l);
        return {
            ...u,
            data: u.data.map((f)=>({
                    ...f,
                    address: t
                }))
        };
    }
    async getInscriptionInfo(t) {
        return await this.call("get", `/assets/inscriptions/${t}`);
    }
    async getBrc20ByTicker(t) {
        return this.call("get", `/assets/brc20/${t}`);
    }
    async getRuneById(t) {
        return this.call("get", `/assets/runes/${t}`);
    }
    async getRuneByName(t) {
        return this.call("get", `/assets/runes/${t}`);
    }
    async getTransactionInfo(t) {
        return this.call("get", `/rpc/transaction/${t}`);
    }
    async broadcastTransaction(t) {
        return await this.call("post", "/arpc/transaction/submit", t);
    }
    async getRawTransaction(t) {
        return this.call("get", `/raw-transactions/${t}`);
    }
    async getRecommendedFees() {
        const t = (await this.call("get", "/mempool/fee_rates")).data[0].sats_per_vb, r = t.median, n = t.min;
        return {
            fastFee: r,
            minFee: n
        };
    }
    async getOrdAddress(t) {
        return this.call("get", `/inscriptions/${t}`);
    }
}
class woe {
    constructor(t, r){
        wt(this, "apiUrl", ""), wt(this, "networks"), wt(this, "network"), this.networks = {
            [mn]: {
                apiUrl: zi("mainnet")
            },
            [Ki]: {
                apiUrl: zi("testnet")
            },
            [_o]: {
                apiUrl: zi("testnet4")
            },
            [Xo]: {
                apiUrl: zi("signet")
            },
            [Ku]: {
                apiUrl: zi("fractal-mainnet")
            },
            [ko]: {
                apiUrl: zi("fractal-testnet")
            },
            ...r == null ? void 0 : r.networks
        }, this.network = t, this.setNetwork(t);
    }
    getName() {
        return WZ;
    }
    setNetwork(t) {
        this.networks[t] ? this.apiUrl = this.networks[t].apiUrl : this.apiUrl = zi(t), this.network = t;
    }
    async call(t, r, n) {
        try {
            const i1 = `${this.apiUrl}${r}`, o = {
                headers: {
                    "Content-Type": t === "post" ? "text/plain" : "application/json"
                }
            };
            return (t === "get" ? await un.get(i1, o) : await un.post(i1, n, o)).data;
        } catch (i1) {
            throw console.error("MempoolSpaceDataSource.call error:", i1), i1;
        }
    }
    async getOutputValueByVOutIndex(t, r) {
        const n = Date.now();
        for(;;)try {
            const i1 = await this.getTransaction(t);
            if (i1 != null && i1.vout && i1.vout.length > 0) return Math.floor(i1.vout[r].value);
            if (Date.now() - n > 6e4) return null;
            await new Promise((o)=>setTimeout(o, 5e3));
        } catch (i1) {
            if (console.error("Error fetching transaction output value:", i1), Date.now() - n > 6e4) return null;
            await new Promise((o)=>setTimeout(o, 5e3));
        }
    }
    async waitForTransaction(t) {
        const r = Date.now();
        for(;;)try {
            if (await this.getTransaction(t)) return console.log("Transaction found in mempool:", t), !0;
            if (Date.now() - r > 6e4) return !1;
            await new Promise((n)=>setTimeout(n, 5e3));
        } catch  {
            if (Date.now() - r > 6e4) return !1;
            await new Promise((n)=>setTimeout(n, 5e3));
        }
    }
    async getAddressUtxos(t) {
        if (t.startsWith("bcrt")) return [];
        const r = await this.call("get", `/api/address/${t}/utxo`), n = Ma(t, Vr(this.network));
        return r.map((i1)=>({
                ...i1,
                scriptPk: Ke.from(n).toString("hex")
            }));
    }
    async getTransaction(t) {
        return await this.call("get", `/api/tx/${t}`);
    }
    async getRecommendedFees() {
        const t = await this.call("get", "/api/v1/fees/recommended"), r = t.fastestFee, n = t.minimumFee;
        return {
            fastFee: r,
            minFee: n
        };
    }
    async broadcastTransaction(t) {
        return await this.call("post", "/api/tx", t);
    }
}
async function* Aoe(e, t, r) {
    const n = /* @__PURE__ */ new Set();
    async function i1() {
        const [o, a] = await Promise.race(n);
        return n.delete(o), a;
    }
    for (const o of t){
        const a = (async ()=>await r(o, t))().then((s)=>[
                a,
                s
            ]);
        n.add(a), n.size >= e && (yield await i1());
    }
    for(; n.size;)yield await i1();
}
var voe = Aoe;
const Eoe = /* @__PURE__ */ gT(voe);
var g5 = {}, tu = {}, No = {}, Rf = {}, y5 = {};
(function(e) {
    var t = typeof Object.defineProperties == "function" ? Object.defineProperty : function(b, T, W) {
        b != Array.prototype && b != Object.prototype && (b[T] = W.value);
    }, r = Qe;
    function n(b, T) {
        if (T) {
            var W = r;
            b = b.split(".");
            for(var fe = 0; fe < b.length - 1; fe++){
                var Oe = b[fe];
                Oe in W || (W[Oe] = {}), W = W[Oe];
            }
            b = b[b.length - 1], fe = W[b], T = T(fe), T != fe && T != null && t(W, b, {
                configurable: !0,
                writable: !0,
                value: T
            });
        }
    }
    function i1(b) {
        var T = 0;
        return function() {
            return T < b.length ? {
                done: !1,
                value: b[T++]
            } : {
                done: !0
            };
        };
    }
    function o() {
        o = function() {}, r.Symbol || (r.Symbol = s);
    }
    function a(b, T) {
        this.a = b, t(this, "description", {
            configurable: !0,
            writable: !0,
            value: T
        });
    }
    a.prototype.toString = function() {
        return this.a;
    };
    var s = /* @__PURE__ */ function() {
        function b(W) {
            if (this instanceof b) throw new TypeError("Symbol is not a constructor");
            return new a("jscomp_symbol_" + (W || "") + "_" + T++, W);
        }
        var T = 0;
        return b;
    }();
    function c() {
        o();
        var b = r.Symbol.iterator;
        b || (b = r.Symbol.iterator = r.Symbol("Symbol.iterator")), typeof Array.prototype[b] != "function" && t(Array.prototype, b, {
            configurable: !0,
            writable: !0,
            value: function() {
                return l(i1(this));
            }
        }), c = function() {};
    }
    function l(b) {
        return c(), b = {
            next: b
        }, b[r.Symbol.iterator] = function() {
            return this;
        }, b;
    }
    function u(b, T) {
        c(), b instanceof String && (b += "");
        var W = 0, fe = {
            next: function() {
                if (W < b.length) {
                    var Oe = W++;
                    return {
                        value: T(Oe, b[Oe]),
                        done: !1
                    };
                }
                return fe.next = function() {
                    return {
                        done: !0,
                        value: void 0
                    };
                }, fe.next();
            }
        };
        return fe[Symbol.iterator] = function() {
            return fe;
        }, fe;
    }
    n("Array.prototype.entries", function(b) {
        return b || function() {
            return u(this, function(T, W) {
                return [
                    T,
                    W
                ];
            });
        };
    });
    var f = Qe || self;
    function h(b, T, W) {
        b = b.split("."), W = W || f, b[0] in W || typeof W.execScript > "u" || W.execScript("var " + b[0]);
        for(var fe; b.length && (fe = b.shift());)b.length || T === void 0 ? W[fe] && W[fe] !== Object.prototype[fe] ? W = W[fe] : W = W[fe] = {} : W[fe] = T;
    }
    function y(b) {
        var T = typeof b;
        if (T == "object") if (b) {
            if (b instanceof Array) return "array";
            if (b instanceof Object) return T;
            var W = Object.prototype.toString.call(b);
            if (W == "[object Window]") return "object";
            if (W == "[object Array]" || typeof b.length == "number" && typeof b.splice < "u" && typeof b.propertyIsEnumerable < "u" && !b.propertyIsEnumerable("splice")) return "array";
            if (W == "[object Function]" || typeof b.call < "u" && typeof b.propertyIsEnumerable < "u" && !b.propertyIsEnumerable("call")) return "function";
        } else return "null";
        else if (T == "function" && typeof b.call > "u") return "object";
        return T;
    }
    function S(b) {
        var T = typeof b;
        return T == "object" && b != null || T == "function";
    }
    function k(b, T, W) {
        h(b, T, W);
    }
    function P(b, T) {
        function W() {}
        W.prototype = T.prototype, b.prototype = new W(), b.prototype.constructor = b;
    }
    var M = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    function N(b, T) {
        for(var W, fe, Oe = 1; Oe < arguments.length; Oe++){
            fe = arguments[Oe];
            for(W in fe)b[W] = fe[W];
            for(var He = 0; He < M.length; He++)W = M[He], Object.prototype.hasOwnProperty.call(fe, W) && (b[W] = fe[W]);
        }
    }
    var z = Array.prototype.forEach ? function(b, T) {
        Array.prototype.forEach.call(b, T, void 0);
    } : function(b, T) {
        for(var W = b.length, fe = typeof b == "string" ? b.split("") : b, Oe = 0; Oe < W; Oe++)Oe in fe && T.call(void 0, fe[Oe], Oe, b);
    }, K = Array.prototype.map ? function(b, T) {
        return Array.prototype.map.call(b, T, void 0);
    } : function(b, T) {
        for(var W = b.length, fe = Array(W), Oe = typeof b == "string" ? b.split("") : b, He = 0; He < W; He++)He in Oe && (fe[He] = T.call(void 0, Oe[He], He, b));
        return fe;
    };
    function $(b, T, W) {
        return 2 >= arguments.length ? Array.prototype.slice.call(b, T) : Array.prototype.slice.call(b, T, W);
    }
    function ne(b, T, W, fe) {
        var Oe = "Assertion failed";
        if (W) {
            Oe += ": " + W;
            var He = fe;
        } else b && (Oe += ": " + b, He = T);
        throw Error(Oe, He || []);
    }
    function ee(b, T, W) {
        for(var fe = [], Oe = 2; Oe < arguments.length; ++Oe)fe[Oe - 2] = arguments[Oe];
        return b || ne("", null, T, fe), b;
    }
    function q(b, T, W) {
        for(var fe = [], Oe = 2; Oe < arguments.length; ++Oe)fe[Oe - 2] = arguments[Oe];
        typeof b != "string" && ne("Expected string but got %s: %s.", [
            y(b),
            b
        ], T, fe);
    }
    function U(b, T, W) {
        for(var fe = [], Oe = 2; Oe < arguments.length; ++Oe)fe[Oe - 2] = arguments[Oe];
        Array.isArray(b) || ne("Expected array but got %s: %s.", [
            y(b),
            b
        ], T, fe);
    }
    function Q(b, T) {
        for(var W = [], fe = 1; fe < arguments.length; ++fe)W[fe - 1] = arguments[fe];
        throw Error("Failure" + (b ? ": " + b : ""), W);
    }
    function v(b, T, W, fe) {
        for(var Oe = [], He = 3; He < arguments.length; ++He)Oe[He - 3] = arguments[He];
        b instanceof T || ne("Expected instanceof %s but got %s.", [
            B(T),
            B(b)
        ], W, Oe);
    }
    function B(b) {
        return b instanceof Function ? b.displayName || b.name || "unknown type name" : b instanceof Object ? b.constructor.displayName || b.constructor.name || Object.prototype.toString.call(b) : b === null ? "null" : typeof b;
    }
    function g(b, T) {
        if (this.c = b, this.b = T, this.a = {}, this.arrClean = !0, 0 < this.c.length) {
            for(b = 0; b < this.c.length; b++){
                T = this.c[b];
                var W = T[0];
                this.a[W.toString()] = new O(W, T[1]);
            }
            this.arrClean = !0;
        }
    }
    h("jspb.Map", g, void 0), g.prototype.g = function() {
        if (this.arrClean) {
            if (this.b) {
                var b = this.a, T;
                for(T in b)if (Object.prototype.hasOwnProperty.call(b, T)) {
                    var W = b[T].a;
                    W && W.g();
                }
            }
        } else {
            for(this.c.length = 0, b = _(this), b.sort(), T = 0; T < b.length; T++){
                var fe = this.a[b[T]];
                (W = fe.a) && W.g(), this.c.push([
                    fe.key,
                    fe.value
                ]);
            }
            this.arrClean = !0;
        }
        return this.c;
    }, g.prototype.toArray = g.prototype.g, g.prototype.Mc = function(b, T) {
        for(var W = this.g(), fe = [], Oe = 0; Oe < W.length; Oe++){
            var He = this.a[W[Oe][0].toString()];
            w(this, He);
            var ht = He.a;
            ht ? (ee(T), fe.push([
                He.key,
                T(b, ht)
            ])) : fe.push([
                He.key,
                He.value
            ]);
        }
        return fe;
    }, g.prototype.toObject = g.prototype.Mc, g.fromObject = function(b, T, W) {
        T = new g([], T);
        for(var fe = 0; fe < b.length; fe++){
            var Oe = b[fe][0], He = W(b[fe][1]);
            T.set(Oe, He);
        }
        return T;
    };
    function E(b) {
        this.a = 0, this.b = b;
    }
    E.prototype.next = function() {
        return this.a < this.b.length ? {
            done: !1,
            value: this.b[this.a++]
        } : {
            done: !0,
            value: void 0
        };
    }, typeof Symbol < "u" && (E.prototype[Symbol.iterator] = function() {
        return this;
    }), g.prototype.Jb = function() {
        return _(this).length;
    }, g.prototype.getLength = g.prototype.Jb, g.prototype.clear = function() {
        this.a = {}, this.arrClean = !1;
    }, g.prototype.clear = g.prototype.clear, g.prototype.Cb = function(b) {
        b = b.toString();
        var T = this.a.hasOwnProperty(b);
        return delete this.a[b], this.arrClean = !1, T;
    }, g.prototype.del = g.prototype.Cb, g.prototype.Eb = function() {
        var b = [], T = _(this);
        T.sort();
        for(var W = 0; W < T.length; W++){
            var fe = this.a[T[W]];
            b.push([
                fe.key,
                fe.value
            ]);
        }
        return b;
    }, g.prototype.getEntryList = g.prototype.Eb, g.prototype.entries = function() {
        var b = [], T = _(this);
        T.sort();
        for(var W = 0; W < T.length; W++){
            var fe = this.a[T[W]];
            b.push([
                fe.key,
                w(this, fe)
            ]);
        }
        return new E(b);
    }, g.prototype.entries = g.prototype.entries, g.prototype.keys = function() {
        var b = [], T = _(this);
        T.sort();
        for(var W = 0; W < T.length; W++)b.push(this.a[T[W]].key);
        return new E(b);
    }, g.prototype.keys = g.prototype.keys, g.prototype.values = function() {
        var b = [], T = _(this);
        T.sort();
        for(var W = 0; W < T.length; W++)b.push(w(this, this.a[T[W]]));
        return new E(b);
    }, g.prototype.values = g.prototype.values, g.prototype.forEach = function(b, T) {
        var W = _(this);
        W.sort();
        for(var fe = 0; fe < W.length; fe++){
            var Oe = this.a[W[fe]];
            b.call(T, w(this, Oe), Oe.key, this);
        }
    }, g.prototype.forEach = g.prototype.forEach, g.prototype.set = function(b, T) {
        var W = new O(b);
        return this.b ? (W.a = T, W.value = T.g()) : W.value = T, this.a[b.toString()] = W, this.arrClean = !1, this;
    }, g.prototype.set = g.prototype.set;
    function w(b, T) {
        return b.b ? (T.a || (T.a = new b.b(T.value)), T.a) : T.value;
    }
    g.prototype.get = function(b) {
        if (b = this.a[b.toString()]) return w(this, b);
    }, g.prototype.get = g.prototype.get, g.prototype.has = function(b) {
        return b.toString() in this.a;
    }, g.prototype.has = g.prototype.has, g.prototype.Jc = function(b, T, W, fe, Oe) {
        var He = _(this);
        He.sort();
        for(var ht = 0; ht < He.length; ht++){
            var Ht = this.a[He[ht]];
            T.Va(b), W.call(T, 1, Ht.key), this.b ? fe.call(T, 2, w(this, Ht), Oe) : fe.call(T, 2, Ht.value), T.Ya();
        }
    }, g.prototype.serializeBinary = g.prototype.Jc, g.deserializeBinary = function(b, T, W, fe, Oe, He, ht) {
        for(; T.oa() && !T.bb();){
            var Ht = T.c;
            Ht == 1 ? He = W.call(T) : Ht == 2 && (b.b ? (ee(Oe), ht || (ht = new b.b()), fe.call(T, ht, Oe)) : ht = fe.call(T));
        }
        ee(He != null), ee(ht != null), b.set(He, ht);
    };
    function _(b) {
        b = b.a;
        var T = [], W;
        for(W in b)Object.prototype.hasOwnProperty.call(b, W) && T.push(W);
        return T;
    }
    function O(b, T) {
        this.key = b, this.value = T, this.a = void 0;
    }
    function I(b) {
        if (8192 >= b.length) return String.fromCharCode.apply(null, b);
        for(var T = "", W = 0; W < b.length; W += 8192)T += String.fromCharCode.apply(null, $(b, W, W + 8192));
        return T;
    }
    var x = {
        "\0": "\\0",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\x0B",
        '"': '\\"',
        "\\": "\\\\",
        "<": "\\u003C"
    }, R = {
        "'": "\\'"
    }, j = {}, Y = null;
    function he(b, T) {
        T === void 0 && (T = 0), se(), T = j[T];
        for(var W = [], fe = 0; fe < b.length; fe += 3){
            var Oe = b[fe], He = fe + 1 < b.length, ht = He ? b[fe + 1] : 0, Ht = fe + 2 < b.length, An = Ht ? b[fe + 2] : 0, ja = Oe >> 2;
            Oe = (Oe & 3) << 4 | ht >> 4, ht = (ht & 15) << 2 | An >> 6, An &= 63, Ht || (An = 64, He || (ht = 64)), W.push(T[ja], T[Oe], T[ht] || "", T[An] || "");
        }
        return W.join("");
    }
    function ue(b) {
        var T = b.length, W = 3 * T / 4;
        W % 3 ? W = Math.floor(W) : "=.".indexOf(b[T - 1]) != -1 && (W = "=.".indexOf(b[T - 2]) != -1 ? W - 2 : W - 1);
        var fe = new Uint8Array(W), Oe = 0;
        return G(b, function(He) {
            fe[Oe++] = He;
        }), fe.subarray(0, Oe);
    }
    function G(b, T) {
        function W(An) {
            for(; fe < b.length;){
                var ja = b.charAt(fe++), $1 = Y[ja];
                if ($1 != null) return $1;
                if (!/^[\s\xa0]*$/.test(ja)) throw Error("Unknown base64 encoding at char: " + ja);
            }
            return An;
        }
        se();
        for(var fe = 0;;){
            var Oe = W(-1), He = W(0), ht = W(64), Ht = W(64);
            if (Ht === 64 && Oe === -1) break;
            T(Oe << 2 | He >> 4), ht != 64 && (T(He << 4 & 240 | ht >> 2), Ht != 64 && T(ht << 6 & 192 | Ht));
        }
    }
    function se() {
        if (!Y) {
            Y = {};
            for(var b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), T = [
                "+/=",
                "+/",
                "-_=",
                "-_.",
                "-_"
            ], W = 0; 5 > W; W++){
                var fe = b.concat(T[W].split(""));
                j[W] = fe;
                for(var Oe = 0; Oe < fe.length; Oe++){
                    var He = fe[Oe];
                    Y[He] === void 0 && (Y[He] = Oe);
                }
            }
        }
    }
    h("jspb.ConstBinaryMessage", function() {}, void 0), h("jspb.BinaryMessage", function() {}, void 0), h("jspb.BinaryConstants.FieldType", {
        yb: -1,
        ee: 1,
        FLOAT: 2,
        ke: 3,
        te: 4,
        je: 5,
        xb: 6,
        wb: 7,
        BOOL: 8,
        re: 9,
        ie: 10,
        le: 11,
        ce: 12,
        se: 13,
        ge: 14,
        me: 15,
        ne: 16,
        oe: 17,
        pe: 18,
        he: 30,
        ve: 31
    }, void 0), h("jspb.BinaryConstants.WireType", {
        yb: -1,
        ue: 0,
        xb: 1,
        de: 2,
        qe: 3,
        fe: 4,
        wb: 5
    }, void 0), h("jspb.BinaryConstants.FieldTypeToWireType", function(b) {
        switch(b){
            case 5:
            case 3:
            case 13:
            case 4:
            case 17:
            case 18:
            case 8:
            case 14:
            case 31:
                return 0;
            case 1:
            case 6:
            case 16:
            case 30:
                return 1;
            case 9:
            case 11:
            case 12:
                return 2;
            case 2:
            case 7:
            case 15:
                return 5;
            default:
                return -1;
        }
    }, void 0), h("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0), h("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0), h("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0), h("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0), h("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0), h("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0), h("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0), h("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0), h("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0), h("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0), h("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0), h("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0), h("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0), h("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0), h("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
    var Z = 0, ie = 0;
    h("jspb.utils.getSplit64Low", function() {
        return Z;
    }, void 0), h("jspb.utils.getSplit64High", function() {
        return ie;
    }, void 0);
    function pe(b) {
        var T = b >>> 0;
        b = Math.floor((b - T) / 4294967296) >>> 0, Z = T, ie = b;
    }
    h("jspb.utils.splitUint64", pe, void 0);
    function ve(b) {
        var T = 0 > b;
        b = Math.abs(b);
        var W = b >>> 0;
        b = Math.floor((b - W) / 4294967296), b >>>= 0, T && (b = ~b >>> 0, W = (~W >>> 0) + 1, 4294967295 < W && (W = 0, b++, 4294967295 < b && (b = 0))), Z = W, ie = b;
    }
    h("jspb.utils.splitInt64", ve, void 0);
    function Ie(b) {
        var T = 0 > b;
        b = 2 * Math.abs(b), pe(b), b = Z;
        var W = ie;
        T && (b == 0 ? W == 0 ? W = b = 4294967295 : (W--, b = 4294967295) : b--), Z = b, ie = W;
    }
    h("jspb.utils.splitZigzag64", Ie, void 0);
    function Me(b) {
        var T = 0 > b ? 1 : 0;
        if (b = T ? -b : b, b === 0) 0 < 1 / b ? Z = ie = 0 : (ie = 0, Z = 2147483648);
        else if (isNaN(b)) ie = 0, Z = 2147483647;
        else if (34028234663852886e22 < b) ie = 0, Z = (T << 31 | 2139095040) >>> 0;
        else if (11754943508222875e-54 > b) b = Math.round(b / Math.pow(2, -149)), ie = 0, Z = (T << 31 | b) >>> 0;
        else {
            var W = Math.floor(Math.log(b) / Math.LN2);
            b *= Math.pow(2, -W), b = Math.round(8388608 * b), 16777216 <= b && ++W, ie = 0, Z = (T << 31 | W + 127 << 23 | b & 8388607) >>> 0;
        }
    }
    h("jspb.utils.splitFloat32", Me, void 0);
    function Re(b) {
        var T = 0 > b ? 1 : 0;
        if (b = T ? -b : b, b === 0) ie = 0 < 1 / b ? 0 : 2147483648, Z = 0;
        else if (isNaN(b)) ie = 2147483647, Z = 4294967295;
        else if (17976931348623157e292 < b) ie = (T << 31 | 2146435072) >>> 0, Z = 0;
        else if (22250738585072014e-324 > b) b /= Math.pow(2, -1074), ie = (T << 31 | b / 4294967296) >>> 0, Z = b >>> 0;
        else {
            var W = b, fe = 0;
            if (2 <= W) for(; 2 <= W && 1023 > fe;)fe++, W /= 2;
            else for(; 1 > W && -1022 < fe;)W *= 2, fe--;
            b *= Math.pow(2, -fe), ie = (T << 31 | fe + 1023 << 20 | 1048576 * b & 1048575) >>> 0, Z = 4503599627370496 * b >>> 0;
        }
    }
    h("jspb.utils.splitFloat64", Re, void 0);
    function C(b) {
        var T = b.charCodeAt(4), W = b.charCodeAt(5), fe = b.charCodeAt(6), Oe = b.charCodeAt(7);
        Z = b.charCodeAt(0) + (b.charCodeAt(1) << 8) + (b.charCodeAt(2) << 16) + (b.charCodeAt(3) << 24) >>> 0, ie = T + (W << 8) + (fe << 16) + (Oe << 24) >>> 0;
    }
    h("jspb.utils.splitHash64", C, void 0);
    function J(b, T) {
        return 4294967296 * T + (b >>> 0);
    }
    h("jspb.utils.joinUint64", J, void 0);
    function me(b, T) {
        var W = T & 2147483648;
        return W && (b = ~b + 1 >>> 0, T = ~T >>> 0, b == 0 && (T = T + 1 >>> 0)), b = J(b, T), W ? -b : b;
    }
    h("jspb.utils.joinInt64", me, void 0);
    function je(b, T, W) {
        var fe = T >> 31;
        return W(b << 1 ^ fe, (T << 1 | b >>> 31) ^ fe);
    }
    h("jspb.utils.toZigzag64", je, void 0);
    function Ve(b, T) {
        return nt(b, T, me);
    }
    h("jspb.utils.joinZigzag64", Ve, void 0);
    function nt(b, T, W) {
        var fe = -(b & 1);
        return W((b >>> 1 | T << 31) ^ fe, T >>> 1 ^ fe);
    }
    h("jspb.utils.fromZigzag64", nt, void 0);
    function We(b) {
        var T = 2 * (b >> 31) + 1, W = b >>> 23 & 255;
        return b &= 8388607, W == 255 ? b ? NaN : 1 / 0 * T : W == 0 ? T * Math.pow(2, -149) * b : T * Math.pow(2, W - 150) * (b + Math.pow(2, 23));
    }
    h("jspb.utils.joinFloat32", We, void 0);
    function Ge(b, T) {
        var W = 2 * (T >> 31) + 1, fe = T >>> 20 & 2047;
        return b = 4294967296 * (T & 1048575) + b, fe == 2047 ? b ? NaN : 1 / 0 * W : fe == 0 ? W * Math.pow(2, -1074) * b : W * Math.pow(2, fe - 1075) * (b + 4503599627370496);
    }
    h("jspb.utils.joinFloat64", Ge, void 0);
    function p(b, T) {
        return String.fromCharCode(b >>> 0 & 255, b >>> 8 & 255, b >>> 16 & 255, b >>> 24 & 255, T >>> 0 & 255, T >>> 8 & 255, T >>> 16 & 255, T >>> 24 & 255);
    }
    h("jspb.utils.joinHash64", p, void 0), h("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
    function A(b, T) {
        function W(Oe, He) {
            return Oe = Oe ? String(Oe) : "", He ? "0000000".slice(Oe.length) + Oe : Oe;
        }
        if (2097151 >= T) return "" + J(b, T);
        var fe = (b >>> 24 | T << 8) >>> 0 & 16777215;
        return T = T >> 16 & 65535, b = (b & 16777215) + 6777216 * fe + 6710656 * T, fe += 8147497 * T, T *= 2, 1e7 <= b && (fe += Math.floor(b / 1e7), b %= 1e7), 1e7 <= fe && (T += Math.floor(fe / 1e7), fe %= 1e7), W(T, 0) + W(fe, T) + W(b, 1);
    }
    h("jspb.utils.joinUnsignedDecimalString", A, void 0);
    function V(b, T) {
        var W = T & 2147483648;
        return W && (b = ~b + 1 >>> 0, T = ~T + (b == 0 ? 1 : 0) >>> 0), b = A(b, T), W ? "-" + b : b;
    }
    h("jspb.utils.joinSignedDecimalString", V, void 0);
    function re(b, T) {
        C(b), b = Z;
        var W = ie;
        return T ? V(b, W) : A(b, W);
    }
    h("jspb.utils.hash64ToDecimalString", re, void 0), h("jspb.utils.hash64ArrayToDecimalStrings", function(b, T) {
        for(var W = Array(b.length), fe = 0; fe < b.length; fe++)W[fe] = re(b[fe], T);
        return W;
    }, void 0);
    function le(b) {
        function T(ht, Ht) {
            for(var An = 0; 8 > An && (ht !== 1 || 0 < Ht); An++)Ht = ht * Oe[An] + Ht, Oe[An] = Ht & 255, Ht >>>= 8;
        }
        function W() {
            for(var ht = 0; 8 > ht; ht++)Oe[ht] = ~Oe[ht] & 255;
        }
        ee(0 < b.length);
        var fe = !1;
        b[0] === "-" && (fe = !0, b = b.slice(1));
        for(var Oe = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ], He = 0; He < b.length; He++)T(10, b.charCodeAt(He) - 48);
        return fe && (W(), T(1, 1)), I(Oe);
    }
    h("jspb.utils.decimalStringToHash64", le, void 0), h("jspb.utils.splitDecimalString", function(b) {
        C(le(b));
    }, void 0);
    function L(b) {
        return String.fromCharCode(10 > b ? 48 + b : 87 + b);
    }
    function X(b) {
        return 97 <= b ? b - 97 + 10 : b - 48;
    }
    h("jspb.utils.hash64ToHexString", function(b) {
        var T = Array(18);
        T[0] = "0", T[1] = "x";
        for(var W = 0; 8 > W; W++){
            var fe = b.charCodeAt(7 - W);
            T[2 * W + 2] = L(fe >> 4), T[2 * W + 3] = L(fe & 15);
        }
        return T.join("");
    }, void 0), h("jspb.utils.hexStringToHash64", function(b) {
        b = b.toLowerCase(), ee(b.length == 18), ee(b[0] == "0"), ee(b[1] == "x");
        for(var T = "", W = 0; 8 > W; W++)T = String.fromCharCode(16 * X(b.charCodeAt(2 * W + 2)) + X(b.charCodeAt(2 * W + 3))) + T;
        return T;
    }, void 0), h("jspb.utils.hash64ToNumber", function(b, T) {
        C(b), b = Z;
        var W = ie;
        return T ? me(b, W) : J(b, W);
    }, void 0), h("jspb.utils.numberToHash64", function(b) {
        return ve(b), p(Z, ie);
    }, void 0), h("jspb.utils.countVarints", function(b, T, W) {
        for(var fe = 0, Oe = T; Oe < W; Oe++)fe += b[Oe] >> 7;
        return W - T - fe;
    }, void 0), h("jspb.utils.countVarintFields", function(b, T, W, fe) {
        var Oe = 0;
        if (fe *= 8, 128 > fe) for(; T < W && b[T++] == fe;)for(Oe++;;){
            var He = b[T++];
            if (!(He & 128)) break;
        }
        else for(; T < W;){
            for(He = fe; 128 < He;){
                if (b[T] != (He & 127 | 128)) return Oe;
                T++, He >>= 7;
            }
            if (b[T++] != He) break;
            for(Oe++; He = b[T++], (He & 128) != 0;);
        }
        return Oe;
    }, void 0);
    function ae(b, T, W, fe, Oe) {
        var He = 0;
        if (128 > fe) for(; T < W && b[T++] == fe;)He++, T += Oe;
        else for(; T < W;){
            for(var ht = fe; 128 < ht;){
                if (b[T++] != (ht & 127 | 128)) return He;
                ht >>= 7;
            }
            if (b[T++] != ht) break;
            He++, T += Oe;
        }
        return He;
    }
    h("jspb.utils.countFixed32Fields", function(b, T, W, fe) {
        return ae(b, T, W, 8 * fe + 5, 4);
    }, void 0), h("jspb.utils.countFixed64Fields", function(b, T, W, fe) {
        return ae(b, T, W, 8 * fe + 1, 8);
    }, void 0), h("jspb.utils.countDelimitedFields", function(b, T, W, fe) {
        var Oe = 0;
        for(fe = 8 * fe + 2; T < W;){
            for(var He = fe; 128 < He;){
                if (b[T++] != (He & 127 | 128)) return Oe;
                He >>= 7;
            }
            if (b[T++] != He) break;
            Oe++;
            for(var ht = 0, Ht = 1; He = b[T++], ht += (He & 127) * Ht, Ht *= 128, (He & 128) != 0;);
            T += ht;
        }
        return Oe;
    }, void 0), h("jspb.utils.debugBytesToTextFormat", function(b) {
        var T = '"';
        if (b) {
            b = D(b);
            for(var W = 0; W < b.length; W++)T += "\\x", 16 > b[W] && (T += "0"), T += b[W].toString(16);
        }
        return T + '"';
    }, void 0), h("jspb.utils.debugScalarToTextFormat", function(b) {
        if (typeof b == "string") {
            b = String(b);
            for(var T = [
                '"'
            ], W = 0; W < b.length; W++){
                var fe = b.charAt(W), Oe = fe.charCodeAt(0), He = W + 1, ht;
                (ht = x[fe]) || (31 < Oe && 127 > Oe || (Oe = fe, Oe in R ? fe = R[Oe] : Oe in x ? fe = R[Oe] = x[Oe] : (ht = Oe.charCodeAt(0), 31 < ht && 127 > ht ? fe = Oe : (256 > ht ? (fe = "\\x", (16 > ht || 256 < ht) && (fe += "0")) : (fe = "\\u", 4096 > ht && (fe += "0")), fe += ht.toString(16).toUpperCase()), fe = R[Oe] = fe)), ht = fe), T[He] = ht;
            }
            T.push('"'), b = T.join("");
        } else b = b.toString();
        return b;
    }, void 0), h("jspb.utils.stringToByteArray", function(b) {
        for(var T = new Uint8Array(b.length), W = 0; W < b.length; W++){
            var fe = b.charCodeAt(W);
            if (255 < fe) throw Error("Conversion error: string contains codepoint outside of byte range");
            T[W] = fe;
        }
        return T;
    }, void 0);
    function D(b) {
        return b.constructor === Uint8Array ? b : b.constructor === ArrayBuffer ? new Uint8Array(b) : b.constructor === Array ? new Uint8Array(b) : b.constructor === String ? ue(b) : b instanceof Uint8Array ? new Uint8Array(b.buffer, b.byteOffset, b.byteLength) : (Q("Type not convertible to Uint8Array."), new Uint8Array(0));
    }
    h("jspb.utils.byteSourceToUint8Array", D, void 0);
    function H(b, T, W) {
        this.b = null, this.a = this.c = this.h = 0, this.v = !1, b && this.H(b, T, W);
    }
    h("jspb.BinaryDecoder", H, void 0);
    var te = [];
    H.getInstanceCacheLength = function() {
        return te.length;
    };
    function ge(b, T, W) {
        if (te.length) {
            var fe = te.pop();
            return b && fe.H(b, T, W), fe;
        }
        return new H(b, T, W);
    }
    H.alloc = ge, H.prototype.Ca = function() {
        this.clear(), 100 > te.length && te.push(this);
    }, H.prototype.free = H.prototype.Ca, H.prototype.clone = function() {
        return ge(this.b, this.h, this.c - this.h);
    }, H.prototype.clone = H.prototype.clone, H.prototype.clear = function() {
        this.b = null, this.a = this.c = this.h = 0, this.v = !1;
    }, H.prototype.clear = H.prototype.clear, H.prototype.Y = function() {
        return this.b;
    }, H.prototype.getBuffer = H.prototype.Y, H.prototype.H = function(b, T, W) {
        this.b = D(b), this.h = T !== void 0 ? T : 0, this.c = W !== void 0 ? this.h + W : this.b.length, this.a = this.h;
    }, H.prototype.setBlock = H.prototype.H, H.prototype.Db = function() {
        return this.c;
    }, H.prototype.getEnd = H.prototype.Db, H.prototype.setEnd = function(b) {
        this.c = b;
    }, H.prototype.setEnd = H.prototype.setEnd, H.prototype.reset = function() {
        this.a = this.h;
    }, H.prototype.reset = H.prototype.reset, H.prototype.B = function() {
        return this.a;
    }, H.prototype.getCursor = H.prototype.B, H.prototype.Ma = function(b) {
        this.a = b;
    }, H.prototype.setCursor = H.prototype.Ma, H.prototype.advance = function(b) {
        this.a += b, ee(this.a <= this.c);
    }, H.prototype.advance = H.prototype.advance, H.prototype.ya = function() {
        return this.a == this.c;
    }, H.prototype.atEnd = H.prototype.ya, H.prototype.Qb = function() {
        return this.a > this.c;
    }, H.prototype.pastEnd = H.prototype.Qb, H.prototype.getError = function() {
        return this.v || 0 > this.a || this.a > this.c;
    }, H.prototype.getError = H.prototype.getError, H.prototype.w = function(b) {
        for(var T = 128, W = 0, fe = 0, Oe = 0; 4 > Oe && 128 <= T; Oe++)T = this.b[this.a++], W |= (T & 127) << 7 * Oe;
        if (128 <= T && (T = this.b[this.a++], W |= (T & 127) << 28, fe |= (T & 127) >> 4), 128 <= T) for(Oe = 0; 5 > Oe && 128 <= T; Oe++)T = this.b[this.a++], fe |= (T & 127) << 7 * Oe + 3;
        if (128 > T) return b(W >>> 0, fe >>> 0);
        Q("Failed to read varint, encoding is invalid."), this.v = !0;
    }, H.prototype.readSplitVarint64 = H.prototype.w, H.prototype.ea = function(b) {
        return this.w(function(T, W) {
            return nt(T, W, b);
        });
    }, H.prototype.readSplitZigzagVarint64 = H.prototype.ea, H.prototype.ta = function(b) {
        var T = this.b, W = this.a;
        this.a += 8;
        for(var fe = 0, Oe = 0, He = W + 7; He >= W; He--)fe = fe << 8 | T[He], Oe = Oe << 8 | T[He + 4];
        return b(fe, Oe);
    }, H.prototype.readSplitFixed64 = H.prototype.ta, H.prototype.kb = function() {
        for(; this.b[this.a] & 128;)this.a++;
        this.a++;
    }, H.prototype.skipVarint = H.prototype.kb, H.prototype.mb = function(b) {
        for(; 128 < b;)this.a--, b >>>= 7;
        this.a--;
    }, H.prototype.unskipVarint = H.prototype.mb, H.prototype.o = function() {
        var b = this.b, T = b[this.a], W = T & 127;
        return 128 > T ? (this.a += 1, ee(this.a <= this.c), W) : (T = b[this.a + 1], W |= (T & 127) << 7, 128 > T ? (this.a += 2, ee(this.a <= this.c), W) : (T = b[this.a + 2], W |= (T & 127) << 14, 128 > T ? (this.a += 3, ee(this.a <= this.c), W) : (T = b[this.a + 3], W |= (T & 127) << 21, 128 > T ? (this.a += 4, ee(this.a <= this.c), W) : (T = b[this.a + 4], W |= (T & 15) << 28, 128 > T ? (this.a += 5, ee(this.a <= this.c), W >>> 0) : (this.a += 5, 128 <= b[this.a++] && 128 <= b[this.a++] && 128 <= b[this.a++] && 128 <= b[this.a++] && 128 <= b[this.a++] && ee(!1), ee(this.a <= this.c), W)))));
    }, H.prototype.readUnsignedVarint32 = H.prototype.o, H.prototype.da = function() {
        return ~~this.o();
    }, H.prototype.readSignedVarint32 = H.prototype.da, H.prototype.O = function() {
        return this.o().toString();
    }, H.prototype.Ea = function() {
        return this.da().toString();
    }, H.prototype.readSignedVarint32String = H.prototype.Ea, H.prototype.Ia = function() {
        var b = this.o();
        return b >>> 1 ^ -(b & 1);
    }, H.prototype.readZigzagVarint32 = H.prototype.Ia, H.prototype.Ga = function() {
        return this.w(J);
    }, H.prototype.readUnsignedVarint64 = H.prototype.Ga, H.prototype.Ha = function() {
        return this.w(A);
    }, H.prototype.readUnsignedVarint64String = H.prototype.Ha, H.prototype.sa = function() {
        return this.w(me);
    }, H.prototype.readSignedVarint64 = H.prototype.sa, H.prototype.Fa = function() {
        return this.w(V);
    }, H.prototype.readSignedVarint64String = H.prototype.Fa, H.prototype.Ja = function() {
        return this.w(Ve);
    }, H.prototype.readZigzagVarint64 = H.prototype.Ja, H.prototype.fb = function() {
        return this.ea(p);
    }, H.prototype.readZigzagVarintHash64 = H.prototype.fb, H.prototype.Ka = function() {
        return this.ea(V);
    }, H.prototype.readZigzagVarint64String = H.prototype.Ka, H.prototype.Gc = function() {
        var b = this.b[this.a];
        return this.a += 1, ee(this.a <= this.c), b;
    }, H.prototype.readUint8 = H.prototype.Gc, H.prototype.Ec = function() {
        var b = this.b[this.a], T = this.b[this.a + 1];
        return this.a += 2, ee(this.a <= this.c), b << 0 | T << 8;
    }, H.prototype.readUint16 = H.prototype.Ec, H.prototype.m = function() {
        var b = this.b[this.a], T = this.b[this.a + 1], W = this.b[this.a + 2], fe = this.b[this.a + 3];
        return this.a += 4, ee(this.a <= this.c), (b << 0 | T << 8 | W << 16 | fe << 24) >>> 0;
    }, H.prototype.readUint32 = H.prototype.m, H.prototype.ga = function() {
        var b = this.m(), T = this.m();
        return J(b, T);
    }, H.prototype.readUint64 = H.prototype.ga, H.prototype.ha = function() {
        var b = this.m(), T = this.m();
        return A(b, T);
    }, H.prototype.readUint64String = H.prototype.ha, H.prototype.Xb = function() {
        var b = this.b[this.a];
        return this.a += 1, ee(this.a <= this.c), b << 24 >> 24;
    }, H.prototype.readInt8 = H.prototype.Xb, H.prototype.Vb = function() {
        var b = this.b[this.a], T = this.b[this.a + 1];
        return this.a += 2, ee(this.a <= this.c), (b << 0 | T << 8) << 16 >> 16;
    }, H.prototype.readInt16 = H.prototype.Vb, H.prototype.P = function() {
        var b = this.b[this.a], T = this.b[this.a + 1], W = this.b[this.a + 2], fe = this.b[this.a + 3];
        return this.a += 4, ee(this.a <= this.c), b << 0 | T << 8 | W << 16 | fe << 24;
    }, H.prototype.readInt32 = H.prototype.P, H.prototype.ba = function() {
        var b = this.m(), T = this.m();
        return me(b, T);
    }, H.prototype.readInt64 = H.prototype.ba, H.prototype.ca = function() {
        var b = this.m(), T = this.m();
        return V(b, T);
    }, H.prototype.readInt64String = H.prototype.ca, H.prototype.aa = function() {
        var b = this.m();
        return We(b);
    }, H.prototype.readFloat = H.prototype.aa, H.prototype.Z = function() {
        var b = this.m(), T = this.m();
        return Ge(b, T);
    }, H.prototype.readDouble = H.prototype.Z, H.prototype.pa = function() {
        return !!this.b[this.a++];
    }, H.prototype.readBool = H.prototype.pa, H.prototype.ra = function() {
        return this.da();
    }, H.prototype.readEnum = H.prototype.ra, H.prototype.fa = function(b) {
        var T = this.b, W = this.a;
        b = W + b;
        for(var fe = [], Oe = ""; W < b;){
            var He = T[W++];
            if (128 > He) fe.push(He);
            else {
                if (192 > He) continue;
                if (224 > He) {
                    var ht = T[W++];
                    fe.push((He & 31) << 6 | ht & 63);
                } else if (240 > He) {
                    ht = T[W++];
                    var Ht = T[W++];
                    fe.push((He & 15) << 12 | (ht & 63) << 6 | Ht & 63);
                } else if (248 > He) {
                    ht = T[W++], Ht = T[W++];
                    var An = T[W++];
                    He = (He & 7) << 18 | (ht & 63) << 12 | (Ht & 63) << 6 | An & 63, He -= 65536, fe.push((He >> 10 & 1023) + 55296, (He & 1023) + 56320);
                }
            }
            8192 <= fe.length && (Oe += String.fromCharCode.apply(null, fe), fe.length = 0);
        }
        return Oe += I(fe), this.a = W, Oe;
    }, H.prototype.readString = H.prototype.fa, H.prototype.Dc = function() {
        var b = this.o();
        return this.fa(b);
    }, H.prototype.readStringWithLength = H.prototype.Dc, H.prototype.qa = function(b) {
        if (0 > b || this.a + b > this.b.length) return this.v = !0, Q("Invalid byte length!"), new Uint8Array(0);
        var T = this.b.subarray(this.a, this.a + b);
        return this.a += b, ee(this.a <= this.c), T;
    }, H.prototype.readBytes = H.prototype.qa, H.prototype.ia = function() {
        return this.w(p);
    }, H.prototype.readVarintHash64 = H.prototype.ia, H.prototype.$ = function() {
        var b = this.b, T = this.a, W = b[T], fe = b[T + 1], Oe = b[T + 2], He = b[T + 3], ht = b[T + 4], Ht = b[T + 5], An = b[T + 6];
        return b = b[T + 7], this.a += 8, String.fromCharCode(W, fe, Oe, He, ht, Ht, An, b);
    }, H.prototype.readFixedHash64 = H.prototype.$;
    function ce(b, T, W) {
        this.a = ge(b, T, W), this.O = this.a.B(), this.b = this.c = -1, this.h = !1, this.v = null;
    }
    h("jspb.BinaryReader", ce, void 0);
    var Ue = [];
    ce.clearInstanceCache = function() {
        Ue = [];
    }, ce.getInstanceCacheLength = function() {
        return Ue.length;
    };
    function qe(b, T, W) {
        if (Ue.length) {
            var fe = Ue.pop();
            return b && fe.a.H(b, T, W), fe;
        }
        return new ce(b, T, W);
    }
    ce.alloc = qe, ce.prototype.zb = qe, ce.prototype.alloc = ce.prototype.zb, ce.prototype.Ca = function() {
        this.a.clear(), this.b = this.c = -1, this.h = !1, this.v = null, 100 > Ue.length && Ue.push(this);
    }, ce.prototype.free = ce.prototype.Ca, ce.prototype.Fb = function() {
        return this.O;
    }, ce.prototype.getFieldCursor = ce.prototype.Fb, ce.prototype.B = function() {
        return this.a.B();
    }, ce.prototype.getCursor = ce.prototype.B, ce.prototype.Y = function() {
        return this.a.Y();
    }, ce.prototype.getBuffer = ce.prototype.Y, ce.prototype.Hb = function() {
        return this.c;
    }, ce.prototype.getFieldNumber = ce.prototype.Hb, ce.prototype.Lb = function() {
        return this.b;
    }, ce.prototype.getWireType = ce.prototype.Lb, ce.prototype.Mb = function() {
        return this.b == 2;
    }, ce.prototype.isDelimited = ce.prototype.Mb, ce.prototype.bb = function() {
        return this.b == 4;
    }, ce.prototype.isEndGroup = ce.prototype.bb, ce.prototype.getError = function() {
        return this.h || this.a.getError();
    }, ce.prototype.getError = ce.prototype.getError, ce.prototype.H = function(b, T, W) {
        this.a.H(b, T, W), this.b = this.c = -1;
    }, ce.prototype.setBlock = ce.prototype.H, ce.prototype.reset = function() {
        this.a.reset(), this.b = this.c = -1;
    }, ce.prototype.reset = ce.prototype.reset, ce.prototype.advance = function(b) {
        this.a.advance(b);
    }, ce.prototype.advance = ce.prototype.advance, ce.prototype.oa = function() {
        if (this.a.ya()) return !1;
        if (this.getError()) return Q("Decoder hit an error"), !1;
        this.O = this.a.B();
        var b = this.a.o(), T = b >>> 3;
        return b &= 7, b != 0 && b != 5 && b != 1 && b != 2 && b != 3 && b != 4 ? (Q("Invalid wire type: %s (at position %s)", b, this.O), this.h = !0, !1) : (this.c = T, this.b = b, !0);
    }, ce.prototype.nextField = ce.prototype.oa, ce.prototype.Oa = function() {
        this.a.mb(this.c << 3 | this.b);
    }, ce.prototype.unskipHeader = ce.prototype.Oa, ce.prototype.Lc = function() {
        var b = this.c;
        for(this.Oa(); this.oa() && this.c == b;)this.C();
        this.a.ya() || this.Oa();
    }, ce.prototype.skipMatchingFields = ce.prototype.Lc, ce.prototype.lb = function() {
        this.b != 0 ? (Q("Invalid wire type for skipVarintField"), this.C()) : this.a.kb();
    }, ce.prototype.skipVarintField = ce.prototype.lb, ce.prototype.gb = function() {
        if (this.b != 2) Q("Invalid wire type for skipDelimitedField"), this.C();
        else {
            var b = this.a.o();
            this.a.advance(b);
        }
    }, ce.prototype.skipDelimitedField = ce.prototype.gb, ce.prototype.hb = function() {
        this.b != 5 ? (Q("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4);
    }, ce.prototype.skipFixed32Field = ce.prototype.hb, ce.prototype.ib = function() {
        this.b != 1 ? (Q("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8);
    }, ce.prototype.skipFixed64Field = ce.prototype.ib, ce.prototype.jb = function() {
        var b = this.c;
        do {
            if (!this.oa()) {
                Q("Unmatched start-group tag: stream EOF"), this.h = !0;
                break;
            }
            if (this.b == 4) {
                this.c != b && (Q("Unmatched end-group tag"), this.h = !0);
                break;
            }
            this.C();
        }while (!0)
    }, ce.prototype.skipGroup = ce.prototype.jb, ce.prototype.C = function() {
        switch(this.b){
            case 0:
                this.lb();
                break;
            case 1:
                this.ib();
                break;
            case 2:
                this.gb();
                break;
            case 5:
                this.hb();
                break;
            case 3:
                this.jb();
                break;
            default:
                Q("Invalid wire encoding for field.");
        }
    }, ce.prototype.skipField = ce.prototype.C, ce.prototype.Hc = function(b, T) {
        this.v === null && (this.v = {}), ee(!this.v[b]), this.v[b] = T;
    }, ce.prototype.registerReadCallback = ce.prototype.Hc, ce.prototype.Ic = function(b) {
        return ee(this.v !== null), b = this.v[b], ee(b), b(this);
    }, ce.prototype.runReadCallback = ce.prototype.Ic, ce.prototype.Yb = function(b, T) {
        ee(this.b == 2);
        var W = this.a.c, fe = this.a.o();
        fe = this.a.B() + fe, this.a.setEnd(fe), T(b, this), this.a.Ma(fe), this.a.setEnd(W);
    }, ce.prototype.readMessage = ce.prototype.Yb, ce.prototype.Ub = function(b, T, W) {
        ee(this.b == 3), ee(this.c == b), W(T, this), this.h || this.b == 4 || (Q("Group submessage did not end with an END_GROUP tag"), this.h = !0);
    }, ce.prototype.readGroup = ce.prototype.Ub, ce.prototype.Gb = function() {
        ee(this.b == 2);
        var b = this.a.o(), T = this.a.B(), W = T + b;
        return b = ge(this.a.Y(), T, b), this.a.Ma(W), b;
    }, ce.prototype.getFieldDecoder = ce.prototype.Gb, ce.prototype.P = function() {
        return ee(this.b == 0), this.a.da();
    }, ce.prototype.readInt32 = ce.prototype.P, ce.prototype.Wb = function() {
        return ee(this.b == 0), this.a.Ea();
    }, ce.prototype.readInt32String = ce.prototype.Wb, ce.prototype.ba = function() {
        return ee(this.b == 0), this.a.sa();
    }, ce.prototype.readInt64 = ce.prototype.ba, ce.prototype.ca = function() {
        return ee(this.b == 0), this.a.Fa();
    }, ce.prototype.readInt64String = ce.prototype.ca, ce.prototype.m = function() {
        return ee(this.b == 0), this.a.o();
    }, ce.prototype.readUint32 = ce.prototype.m, ce.prototype.Fc = function() {
        return ee(this.b == 0), this.a.O();
    }, ce.prototype.readUint32String = ce.prototype.Fc, ce.prototype.ga = function() {
        return ee(this.b == 0), this.a.Ga();
    }, ce.prototype.readUint64 = ce.prototype.ga, ce.prototype.ha = function() {
        return ee(this.b == 0), this.a.Ha();
    }, ce.prototype.readUint64String = ce.prototype.ha, ce.prototype.zc = function() {
        return ee(this.b == 0), this.a.Ia();
    }, ce.prototype.readSint32 = ce.prototype.zc, ce.prototype.Ac = function() {
        return ee(this.b == 0), this.a.Ja();
    }, ce.prototype.readSint64 = ce.prototype.Ac, ce.prototype.Bc = function() {
        return ee(this.b == 0), this.a.Ka();
    }, ce.prototype.readSint64String = ce.prototype.Bc, ce.prototype.Rb = function() {
        return ee(this.b == 5), this.a.m();
    }, ce.prototype.readFixed32 = ce.prototype.Rb, ce.prototype.Sb = function() {
        return ee(this.b == 1), this.a.ga();
    }, ce.prototype.readFixed64 = ce.prototype.Sb, ce.prototype.Tb = function() {
        return ee(this.b == 1), this.a.ha();
    }, ce.prototype.readFixed64String = ce.prototype.Tb, ce.prototype.vc = function() {
        return ee(this.b == 5), this.a.P();
    }, ce.prototype.readSfixed32 = ce.prototype.vc, ce.prototype.wc = function() {
        return ee(this.b == 5), this.a.P().toString();
    }, ce.prototype.readSfixed32String = ce.prototype.wc, ce.prototype.xc = function() {
        return ee(this.b == 1), this.a.ba();
    }, ce.prototype.readSfixed64 = ce.prototype.xc, ce.prototype.yc = function() {
        return ee(this.b == 1), this.a.ca();
    }, ce.prototype.readSfixed64String = ce.prototype.yc, ce.prototype.aa = function() {
        return ee(this.b == 5), this.a.aa();
    }, ce.prototype.readFloat = ce.prototype.aa, ce.prototype.Z = function() {
        return ee(this.b == 1), this.a.Z();
    }, ce.prototype.readDouble = ce.prototype.Z, ce.prototype.pa = function() {
        return ee(this.b == 0), !!this.a.o();
    }, ce.prototype.readBool = ce.prototype.pa, ce.prototype.ra = function() {
        return ee(this.b == 0), this.a.sa();
    }, ce.prototype.readEnum = ce.prototype.ra, ce.prototype.fa = function() {
        ee(this.b == 2);
        var b = this.a.o();
        return this.a.fa(b);
    }, ce.prototype.readString = ce.prototype.fa, ce.prototype.qa = function() {
        ee(this.b == 2);
        var b = this.a.o();
        return this.a.qa(b);
    }, ce.prototype.readBytes = ce.prototype.qa, ce.prototype.ia = function() {
        return ee(this.b == 0), this.a.ia();
    }, ce.prototype.readVarintHash64 = ce.prototype.ia, ce.prototype.Cc = function() {
        return ee(this.b == 0), this.a.fb();
    }, ce.prototype.readSintHash64 = ce.prototype.Cc, ce.prototype.w = function(b) {
        return ee(this.b == 0), this.a.w(b);
    }, ce.prototype.readSplitVarint64 = ce.prototype.w, ce.prototype.ea = function(b) {
        return ee(this.b == 0), this.a.w(function(T, W) {
            return nt(T, W, b);
        });
    }, ce.prototype.readSplitZigzagVarint64 = ce.prototype.ea, ce.prototype.$ = function() {
        return ee(this.b == 1), this.a.$();
    }, ce.prototype.readFixedHash64 = ce.prototype.$, ce.prototype.ta = function(b) {
        return ee(this.b == 1), this.a.ta(b);
    }, ce.prototype.readSplitFixed64 = ce.prototype.ta;
    function ot(b, T) {
        ee(b.b == 2);
        var W = b.a.o();
        W = b.a.B() + W;
        for(var fe = []; b.a.B() < W;)fe.push(T.call(b.a));
        return fe;
    }
    ce.prototype.gc = function() {
        return ot(this, this.a.da);
    }, ce.prototype.readPackedInt32 = ce.prototype.gc, ce.prototype.hc = function() {
        return ot(this, this.a.Ea);
    }, ce.prototype.readPackedInt32String = ce.prototype.hc, ce.prototype.ic = function() {
        return ot(this, this.a.sa);
    }, ce.prototype.readPackedInt64 = ce.prototype.ic, ce.prototype.jc = function() {
        return ot(this, this.a.Fa);
    }, ce.prototype.readPackedInt64String = ce.prototype.jc, ce.prototype.qc = function() {
        return ot(this, this.a.o);
    }, ce.prototype.readPackedUint32 = ce.prototype.qc, ce.prototype.rc = function() {
        return ot(this, this.a.O);
    }, ce.prototype.readPackedUint32String = ce.prototype.rc, ce.prototype.sc = function() {
        return ot(this, this.a.Ga);
    }, ce.prototype.readPackedUint64 = ce.prototype.sc, ce.prototype.tc = function() {
        return ot(this, this.a.Ha);
    }, ce.prototype.readPackedUint64String = ce.prototype.tc, ce.prototype.nc = function() {
        return ot(this, this.a.Ia);
    }, ce.prototype.readPackedSint32 = ce.prototype.nc, ce.prototype.oc = function() {
        return ot(this, this.a.Ja);
    }, ce.prototype.readPackedSint64 = ce.prototype.oc, ce.prototype.pc = function() {
        return ot(this, this.a.Ka);
    }, ce.prototype.readPackedSint64String = ce.prototype.pc, ce.prototype.bc = function() {
        return ot(this, this.a.m);
    }, ce.prototype.readPackedFixed32 = ce.prototype.bc, ce.prototype.cc = function() {
        return ot(this, this.a.ga);
    }, ce.prototype.readPackedFixed64 = ce.prototype.cc, ce.prototype.dc = function() {
        return ot(this, this.a.ha);
    }, ce.prototype.readPackedFixed64String = ce.prototype.dc, ce.prototype.kc = function() {
        return ot(this, this.a.P);
    }, ce.prototype.readPackedSfixed32 = ce.prototype.kc, ce.prototype.lc = function() {
        return ot(this, this.a.ba);
    }, ce.prototype.readPackedSfixed64 = ce.prototype.lc, ce.prototype.mc = function() {
        return ot(this, this.a.ca);
    }, ce.prototype.readPackedSfixed64String = ce.prototype.mc, ce.prototype.fc = function() {
        return ot(this, this.a.aa);
    }, ce.prototype.readPackedFloat = ce.prototype.fc, ce.prototype.$b = function() {
        return ot(this, this.a.Z);
    }, ce.prototype.readPackedDouble = ce.prototype.$b, ce.prototype.Zb = function() {
        return ot(this, this.a.pa);
    }, ce.prototype.readPackedBool = ce.prototype.Zb, ce.prototype.ac = function() {
        return ot(this, this.a.ra);
    }, ce.prototype.readPackedEnum = ce.prototype.ac, ce.prototype.uc = function() {
        return ot(this, this.a.ia);
    }, ce.prototype.readPackedVarintHash64 = ce.prototype.uc, ce.prototype.ec = function() {
        return ot(this, this.a.$);
    }, ce.prototype.readPackedFixedHash64 = ce.prototype.ec;
    function yt(b, T, W, fe, Oe) {
        this.ma = b, this.Ba = T, this.la = W, this.Na = fe, this.na = Oe;
    }
    h("jspb.ExtensionFieldInfo", yt, void 0);
    function Ut(b, T, W, fe, Oe, He) {
        this.Za = b, this.za = T, this.Aa = W, this.Wa = fe, this.Ab = Oe, this.Nb = He;
    }
    h("jspb.ExtensionFieldBinaryInfo", Ut, void 0), yt.prototype.F = function() {
        return !!this.la;
    }, yt.prototype.isMessageType = yt.prototype.F;
    function Xe() {}
    h("jspb.Message", Xe, void 0), Xe.GENERATE_TO_OBJECT = !0, Xe.GENERATE_FROM_OBJECT = !0;
    var _t = typeof Uint8Array == "function";
    Xe.prototype.Ib = function() {
        return this.b;
    }, Xe.prototype.getJsPbMessageId = Xe.prototype.Ib, Xe.initialize = function(b, T, W, fe, Oe, He) {
        b.f = null, T || (T = W ? [
            W
        ] : []), b.b = W ? String(W) : void 0, b.D = W === 0 ? -1 : 0, b.u = T;
        e: {
            if (W = b.u.length, T = -1, W && (T = W - 1, W = b.u[T], !(W === null || typeof W != "object" || Array.isArray(W) || _t && W instanceof Uint8Array))) {
                b.G = T - b.D, b.i = W;
                break e;
            }
            -1 < fe ? (b.G = Math.max(fe, T + 1 - b.D), b.i = null) : b.G = Number.MAX_VALUE;
        }
        if (b.a = {}, Oe) for(fe = 0; fe < Oe.length; fe++)T = Oe[fe], T < b.G ? (T += b.D, b.u[T] = b.u[T] || br) : (Lr(b), b.i[T] = b.i[T] || br);
        if (He && He.length) for(fe = 0; fe < He.length; fe++)lt(b, He[fe]);
    };
    var br = Object.freeze ? Object.freeze([]) : [];
    function Lr(b) {
        var T = b.G + b.D;
        b.u[T] || (b.i = b.u[T] = {});
    }
    function Wt(b, T, W) {
        for(var fe = [], Oe = 0; Oe < b.length; Oe++)fe[Oe] = T.call(b[Oe], W, b[Oe]);
        return fe;
    }
    Xe.toObjectList = Wt, Xe.toObjectExtension = function(b, T, W, fe, Oe) {
        for(var He in W){
            var ht = W[He], Ht = fe.call(b, ht);
            if (Ht != null) {
                for(var An in ht.Ba)if (ht.Ba.hasOwnProperty(An)) break;
                T[An] = ht.Na ? ht.na ? Wt(Ht, ht.Na, Oe) : ht.Na(Oe, Ht) : Ht;
            }
        }
    }, Xe.serializeBinaryExtensions = function(b, T, W, fe) {
        for(var Oe in W){
            var He = W[Oe], ht = He.Za;
            if (!He.Aa) throw Error("Message extension present that was generated without binary serialization support");
            var Ht = fe.call(b, ht);
            if (Ht != null) if (ht.F()) if (He.Wa) He.Aa.call(T, ht.ma, Ht, He.Wa);
            else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
            else He.Aa.call(T, ht.ma, Ht);
        }
    }, Xe.readBinaryExtension = function(b, T, W, fe, Oe) {
        var He = W[T.c];
        if (He) {
            if (W = He.Za, !He.za) throw Error("Deserializing extension whose generated code does not support binary format");
            if (W.F()) {
                var ht = new W.la();
                He.za.call(T, ht, He.Ab);
            } else ht = He.za.call(T);
            W.na && !He.Nb ? (T = fe.call(b, W)) ? T.push(ht) : Oe.call(b, W, [
                ht
            ]) : Oe.call(b, W, ht);
        } else T.C();
    };
    function Dt(b, T) {
        if (T < b.G) {
            T += b.D;
            var W = b.u[T];
            return W === br ? b.u[T] = [] : W;
        }
        if (b.i) return W = b.i[T], W === br ? b.i[T] = [] : W;
    }
    Xe.getField = Dt, Xe.getRepeatedField = function(b, T) {
        return Dt(b, T);
    };
    function Yt(b, T) {
        return b = Dt(b, T), b == null ? b : +b;
    }
    Xe.getOptionalFloatingPointField = Yt;
    function Lt(b, T) {
        return b = Dt(b, T), b == null ? b : !!b;
    }
    Xe.getBooleanField = Lt, Xe.getRepeatedFloatingPointField = function(b, T) {
        var W = Dt(b, T);
        if (b.a || (b.a = {}), !b.a[T]) {
            for(var fe = 0; fe < W.length; fe++)W[fe] = +W[fe];
            b.a[T] = !0;
        }
        return W;
    }, Xe.getRepeatedBooleanField = function(b, T) {
        var W = Dt(b, T);
        if (b.a || (b.a = {}), !b.a[T]) {
            for(var fe = 0; fe < W.length; fe++)W[fe] = !!W[fe];
            b.a[T] = !0;
        }
        return W;
    };
    function Dr(b) {
        return b == null || typeof b == "string" ? b : _t && b instanceof Uint8Array ? he(b) : (Q("Cannot coerce to b64 string: " + y(b)), null);
    }
    Xe.bytesAsB64 = Dr;
    function xe(b) {
        return b == null || b instanceof Uint8Array ? b : typeof b == "string" ? ue(b) : (Q("Cannot coerce to Uint8Array: " + y(b)), null);
    }
    Xe.bytesAsU8 = xe, Xe.bytesListAsB64 = function(b) {
        return ye(b), b.length && typeof b[0] != "string" ? K(b, Dr) : b;
    }, Xe.bytesListAsU8 = function(b) {
        return ye(b), !b.length || b[0] instanceof Uint8Array ? b : K(b, xe);
    };
    function ye(b) {
        if (b && 1 < b.length) {
            var T = y(b[0]);
            z(b, function(W) {
                y(W) != T && Q("Inconsistent type in JSPB repeated field array. Got " + y(W) + " expected " + T);
            });
        }
    }
    function ke(b, T, W) {
        return b = Dt(b, T), b ?? W;
    }
    Xe.getFieldWithDefault = ke, Xe.getBooleanFieldWithDefault = function(b, T, W) {
        return b = Lt(b, T), b ?? W;
    }, Xe.getFloatingPointFieldWithDefault = function(b, T, W) {
        return b = Yt(b, T), b ?? W;
    }, Xe.getFieldProto3 = ke, Xe.getMapField = function(b, T, W, fe) {
        if (b.f || (b.f = {}), T in b.f) return b.f[T];
        var Oe = Dt(b, T);
        if (!Oe) {
            if (W) return;
            Oe = [], Ce(b, T, Oe);
        }
        return b.f[T] = new g(Oe, fe);
    };
    function Ce(b, T, W) {
        return v(b, Xe), T < b.G ? b.u[T + b.D] = W : (Lr(b), b.i[T] = W), b;
    }
    Xe.setField = Ce, Xe.setProto3IntField = function(b, T, W) {
        return De(b, T, W, 0);
    }, Xe.setProto3FloatField = function(b, T, W) {
        return De(b, T, W, 0);
    }, Xe.setProto3BooleanField = function(b, T, W) {
        return De(b, T, W, !1);
    }, Xe.setProto3StringField = function(b, T, W) {
        return De(b, T, W, "");
    }, Xe.setProto3BytesField = function(b, T, W) {
        return De(b, T, W, "");
    }, Xe.setProto3EnumField = function(b, T, W) {
        return De(b, T, W, 0);
    }, Xe.setProto3StringIntField = function(b, T, W) {
        return De(b, T, W, "0");
    };
    function De(b, T, W, fe) {
        return v(b, Xe), W !== fe ? Ce(b, T, W) : T < b.G ? b.u[T + b.D] = null : (Lr(b), delete b.i[T]), b;
    }
    Xe.addToRepeatedField = function(b, T, W, fe) {
        return v(b, Xe), T = Dt(b, T), fe != null ? T.splice(fe, 0, W) : T.push(W), b;
    };
    function Ye(b, T, W, fe) {
        return v(b, Xe), (W = lt(b, W)) && W !== T && fe !== void 0 && (b.f && W in b.f && (b.f[W] = void 0), Ce(b, W, void 0)), Ce(b, T, fe);
    }
    Xe.setOneofField = Ye;
    function lt(b, T) {
        for(var W, fe, Oe = 0; Oe < T.length; Oe++){
            var He = T[Oe], ht = Dt(b, He);
            ht != null && (W = He, fe = ht, Ce(b, He, void 0));
        }
        return W ? (Ce(b, W, fe), W) : 0;
    }
    Xe.computeOneofCase = lt, Xe.getWrapperField = function(b, T, W, fe) {
        if (b.f || (b.f = {}), !b.f[W]) {
            var Oe = Dt(b, W);
            (fe || Oe) && (b.f[W] = new T(Oe));
        }
        return b.f[W];
    }, Xe.getRepeatedWrapperField = function(b, T, W) {
        return et(b, T, W), T = b.f[W], T == br && (T = b.f[W] = []), T;
    };
    function et(b, T, W) {
        if (b.f || (b.f = {}), !b.f[W]) {
            for(var fe = Dt(b, W), Oe = [], He = 0; He < fe.length; He++)Oe[He] = new T(fe[He]);
            b.f[W] = Oe;
        }
    }
    Xe.setWrapperField = function(b, T, W) {
        v(b, Xe), b.f || (b.f = {});
        var fe = W && W.g();
        return b.f[T] = W, Ce(b, T, fe);
    }, Xe.setOneofWrapperField = function(b, T, W, fe) {
        v(b, Xe), b.f || (b.f = {});
        var Oe = fe && fe.g();
        return b.f[T] = fe, Ye(b, T, W, Oe);
    }, Xe.setRepeatedWrapperField = function(b, T, W) {
        v(b, Xe), b.f || (b.f = {}), W = W || [];
        for(var fe = [], Oe = 0; Oe < W.length; Oe++)fe[Oe] = W[Oe].g();
        return b.f[T] = W, Ce(b, T, fe);
    }, Xe.addToRepeatedWrapperField = function(b, T, W, fe, Oe) {
        et(b, fe, T);
        var He = b.f[T];
        return He || (He = b.f[T] = []), W = W || new fe(), b = Dt(b, T), Oe != null ? (He.splice(Oe, 0, W), b.splice(Oe, 0, W.g())) : (He.push(W), b.push(W.g())), W;
    }, Xe.toMap = function(b, T, W, fe) {
        for(var Oe = {}, He = 0; He < b.length; He++)Oe[T.call(b[He])] = W ? W.call(b[He], fe, b[He]) : b[He];
        return Oe;
    };
    function vt(b) {
        if (b.f) for(var T in b.f){
            var W = b.f[T];
            if (Array.isArray(W)) for(var fe = 0; fe < W.length; fe++)W[fe] && W[fe].g();
            else W && W.g();
        }
    }
    Xe.prototype.g = function() {
        return vt(this), this.u;
    }, Xe.prototype.toArray = Xe.prototype.g, Xe.prototype.toString = function() {
        return vt(this), this.u.toString();
    }, Xe.prototype.getExtension = function(b) {
        if (this.i) {
            this.f || (this.f = {});
            var T = b.ma;
            if (b.na) {
                if (b.F()) return this.f[T] || (this.f[T] = K(this.i[T] || [], function(W) {
                    return new b.la(W);
                })), this.f[T];
            } else if (b.F()) return !this.f[T] && this.i[T] && (this.f[T] = new b.la(this.i[T])), this.f[T];
            return this.i[T];
        }
    }, Xe.prototype.getExtension = Xe.prototype.getExtension, Xe.prototype.Kc = function(b, T) {
        this.f || (this.f = {}), Lr(this);
        var W = b.ma;
        return b.na ? (T = T || [], b.F() ? (this.f[W] = T, this.i[W] = K(T, function(fe) {
            return fe.g();
        })) : this.i[W] = T) : b.F() ? (this.f[W] = T, this.i[W] = T && T.g()) : this.i[W] = T, this;
    }, Xe.prototype.setExtension = Xe.prototype.Kc, Xe.difference = function(b, T) {
        if (!(b instanceof T.constructor)) throw Error("Messages have different types.");
        var W = b.g();
        T = T.g();
        var fe = [], Oe = 0, He = W.length > T.length ? W.length : T.length;
        for(b.b && (fe[0] = b.b, Oe = 1); Oe < He; Oe++)dt(W[Oe], T[Oe]) || (fe[Oe] = T[Oe]);
        return new b.constructor(fe);
    }, Xe.equals = function(b, T) {
        return b == T || !(!b || !T) && b instanceof T.constructor && dt(b.g(), T.g());
    };
    function At(b, T) {
        b = b || {}, T = T || {};
        var W = {}, fe;
        for(fe in b)W[fe] = 0;
        for(fe in T)W[fe] = 0;
        for(fe in W)if (!dt(b[fe], T[fe])) return !1;
        return !0;
    }
    Xe.compareExtensions = At;
    function dt(b, T) {
        if (b == T) return !0;
        if (!S(b) || !S(T)) return typeof b == "number" && isNaN(b) || typeof T == "number" && isNaN(T) ? String(b) == String(T) : !1;
        if (b.constructor != T.constructor) return !1;
        if (_t && b.constructor === Uint8Array) {
            if (b.length != T.length) return !1;
            for(var W = 0; W < b.length; W++)if (b[W] != T[W]) return !1;
            return !0;
        }
        if (b.constructor === Array) {
            var fe = void 0, Oe = void 0, He = Math.max(b.length, T.length);
            for(W = 0; W < He; W++){
                var ht = b[W], Ht = T[W];
                if (ht && ht.constructor == Object && (ee(fe === void 0), ee(W === b.length - 1), fe = ht, ht = void 0), Ht && Ht.constructor == Object && (ee(Oe === void 0), ee(W === T.length - 1), Oe = Ht, Ht = void 0), !dt(ht, Ht)) return !1;
            }
            return fe || Oe ? (fe = fe || {}, Oe = Oe || {}, At(fe, Oe)) : !0;
        }
        if (b.constructor === Object) return At(b, T);
        throw Error("Invalid type in JSPB array");
    }
    Xe.compareFields = dt, Xe.prototype.Bb = function() {
        return Tt(this);
    }, Xe.prototype.cloneMessage = Xe.prototype.Bb, Xe.prototype.clone = function() {
        return Tt(this);
    }, Xe.prototype.clone = Xe.prototype.clone, Xe.clone = function(b) {
        return Tt(b);
    };
    function Tt(b) {
        return new b.constructor(Pt(b.g()));
    }
    Xe.copyInto = function(b, T) {
        v(b, Xe), v(T, Xe), ee(b.constructor == T.constructor, "Copy source and target message should have the same type."), b = Tt(b);
        for(var W = T.g(), fe = b.g(), Oe = W.length = 0; Oe < fe.length; Oe++)W[Oe] = fe[Oe];
        T.f = b.f, T.i = b.i;
    };
    function Pt(b) {
        if (Array.isArray(b)) {
            for(var T = Array(b.length), W = 0; W < b.length; W++){
                var fe = b[W];
                fe != null && (T[W] = typeof fe == "object" ? Pt(ee(fe)) : fe);
            }
            return T;
        }
        if (_t && b instanceof Uint8Array) return new Uint8Array(b);
        T = {};
        for(W in b)fe = b[W], fe != null && (T[W] = typeof fe == "object" ? Pt(ee(fe)) : fe);
        return T;
    }
    Xe.registerMessageType = function(b, T) {
        T.we = b;
    };
    var Rt = {
        dump: function(b) {
            return v(b, Xe, "jspb.Message instance expected"), ee(b.getExtension, "Only unobfuscated and unoptimized compilation modes supported."), Rt.X(b);
        }
    };
    h("jspb.debug.dump", Rt.dump, void 0), Rt.X = function(b) {
        var T = y(b);
        if (T == "number" || T == "string" || T == "boolean" || T == "null" || T == "undefined" || typeof Uint8Array < "u" && b instanceof Uint8Array) return b;
        if (T == "array") return U(b), K(b, Rt.X);
        if (b instanceof g) {
            var W = {};
            b = b.entries();
            for(var fe = b.next(); !fe.done; fe = b.next())W[fe.value[0]] = Rt.X(fe.value[1]);
            return W;
        }
        v(b, Xe, "Only messages expected: " + b), T = b.constructor;
        var Oe = {
            $name: T.name || T.displayName
        };
        for(Ht in T.prototype){
            var He = /^get([A-Z]\w*)/.exec(Ht);
            if (He && Ht != "getExtension" && Ht != "getJsPbMessageId") {
                var ht = "has" + He[1];
                (!b[ht] || b[ht]()) && (ht = b[Ht](), Oe[Rt.$a(He[1])] = Rt.X(ht));
            }
        }
        if (b.extensionObject_) return Oe.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", Oe;
        for(fe in T.extensions)if (/^\d+$/.test(fe)) {
            ht = T.extensions[fe];
            var Ht = b.getExtension(ht);
            He = void 0, ht = ht.Ba;
            var An = [], ja = 0;
            for(He in ht)An[ja++] = He;
            He = An[0], Ht != null && (W || (W = Oe.$extensions = {}), W[Rt.$a(He)] = Rt.X(Ht));
        }
        return Oe;
    }, Rt.$a = function(b) {
        return b.replace(/^[A-Z]/, function(T) {
            return T.toLowerCase();
        });
    };
    function rt() {
        this.a = [];
    }
    h("jspb.BinaryEncoder", rt, void 0), rt.prototype.length = function() {
        return this.a.length;
    }, rt.prototype.length = rt.prototype.length, rt.prototype.end = function() {
        var b = this.a;
        return this.a = [], b;
    }, rt.prototype.end = rt.prototype.end, rt.prototype.l = function(b, T) {
        for(ee(b == Math.floor(b)), ee(T == Math.floor(T)), ee(0 <= b && 4294967296 > b), ee(0 <= T && 4294967296 > T); 0 < T || 127 < b;)this.a.push(b & 127 | 128), b = (b >>> 7 | T << 25) >>> 0, T >>>= 7;
        this.a.push(b);
    }, rt.prototype.writeSplitVarint64 = rt.prototype.l, rt.prototype.A = function(b, T) {
        ee(b == Math.floor(b)), ee(T == Math.floor(T)), ee(0 <= b && 4294967296 > b), ee(0 <= T && 4294967296 > T), this.s(b), this.s(T);
    }, rt.prototype.writeSplitFixed64 = rt.prototype.A, rt.prototype.j = function(b) {
        for(ee(b == Math.floor(b)), ee(0 <= b && 4294967296 > b); 127 < b;)this.a.push(b & 127 | 128), b >>>= 7;
        this.a.push(b);
    }, rt.prototype.writeUnsignedVarint32 = rt.prototype.j, rt.prototype.M = function(b) {
        if (ee(b == Math.floor(b)), ee(-2147483648 <= b && 2147483648 > b), 0 <= b) this.j(b);
        else {
            for(var T = 0; 9 > T; T++)this.a.push(b & 127 | 128), b >>= 7;
            this.a.push(1);
        }
    }, rt.prototype.writeSignedVarint32 = rt.prototype.M, rt.prototype.va = function(b) {
        ee(b == Math.floor(b)), ee(0 <= b && 18446744073709552e3 > b), ve(b), this.l(Z, ie);
    }, rt.prototype.writeUnsignedVarint64 = rt.prototype.va, rt.prototype.ua = function(b) {
        ee(b == Math.floor(b)), ee(-9223372036854776e3 <= b && 9223372036854776e3 > b), ve(b), this.l(Z, ie);
    }, rt.prototype.writeSignedVarint64 = rt.prototype.ua, rt.prototype.wa = function(b) {
        ee(b == Math.floor(b)), ee(-2147483648 <= b && 2147483648 > b), this.j((b << 1 ^ b >> 31) >>> 0);
    }, rt.prototype.writeZigzagVarint32 = rt.prototype.wa, rt.prototype.xa = function(b) {
        ee(b == Math.floor(b)), ee(-9223372036854776e3 <= b && 9223372036854776e3 > b), Ie(b), this.l(Z, ie);
    }, rt.prototype.writeZigzagVarint64 = rt.prototype.xa, rt.prototype.Ta = function(b) {
        this.W(le(b));
    }, rt.prototype.writeZigzagVarint64String = rt.prototype.Ta, rt.prototype.W = function(b) {
        var T = this;
        C(b), je(Z, ie, function(W, fe) {
            T.l(W >>> 0, fe >>> 0);
        });
    }, rt.prototype.writeZigzagVarintHash64 = rt.prototype.W, rt.prototype.be = function(b) {
        ee(b == Math.floor(b)), ee(0 <= b && 256 > b), this.a.push(b >>> 0 & 255);
    }, rt.prototype.writeUint8 = rt.prototype.be, rt.prototype.ae = function(b) {
        ee(b == Math.floor(b)), ee(0 <= b && 65536 > b), this.a.push(b >>> 0 & 255), this.a.push(b >>> 8 & 255);
    }, rt.prototype.writeUint16 = rt.prototype.ae, rt.prototype.s = function(b) {
        ee(b == Math.floor(b)), ee(0 <= b && 4294967296 > b), this.a.push(b >>> 0 & 255), this.a.push(b >>> 8 & 255), this.a.push(b >>> 16 & 255), this.a.push(b >>> 24 & 255);
    }, rt.prototype.writeUint32 = rt.prototype.s, rt.prototype.V = function(b) {
        ee(b == Math.floor(b)), ee(0 <= b && 18446744073709552e3 > b), pe(b), this.s(Z), this.s(ie);
    }, rt.prototype.writeUint64 = rt.prototype.V, rt.prototype.Qc = function(b) {
        ee(b == Math.floor(b)), ee(-128 <= b && 128 > b), this.a.push(b >>> 0 & 255);
    }, rt.prototype.writeInt8 = rt.prototype.Qc, rt.prototype.Pc = function(b) {
        ee(b == Math.floor(b)), ee(-32768 <= b && 32768 > b), this.a.push(b >>> 0 & 255), this.a.push(b >>> 8 & 255);
    }, rt.prototype.writeInt16 = rt.prototype.Pc, rt.prototype.S = function(b) {
        ee(b == Math.floor(b)), ee(-2147483648 <= b && 2147483648 > b), this.a.push(b >>> 0 & 255), this.a.push(b >>> 8 & 255), this.a.push(b >>> 16 & 255), this.a.push(b >>> 24 & 255);
    }, rt.prototype.writeInt32 = rt.prototype.S, rt.prototype.T = function(b) {
        ee(b == Math.floor(b)), ee(-9223372036854776e3 <= b && 9223372036854776e3 > b), ve(b), this.A(Z, ie);
    }, rt.prototype.writeInt64 = rt.prototype.T, rt.prototype.ka = function(b) {
        ee(b == Math.floor(b)), ee(-9223372036854776e3 <= +b && 9223372036854776e3 > +b), C(le(b)), this.A(Z, ie);
    }, rt.prototype.writeInt64String = rt.prototype.ka, rt.prototype.L = function(b) {
        ee(b === 1 / 0 || b === -1 / 0 || isNaN(b) || -34028234663852886e22 <= b && 34028234663852886e22 >= b), Me(b), this.s(Z);
    }, rt.prototype.writeFloat = rt.prototype.L, rt.prototype.J = function(b) {
        ee(b === 1 / 0 || b === -1 / 0 || isNaN(b) || -17976931348623157e292 <= b && 17976931348623157e292 >= b), Re(b), this.s(Z), this.s(ie);
    }, rt.prototype.writeDouble = rt.prototype.J, rt.prototype.I = function(b) {
        ee(typeof b == "boolean" || typeof b == "number"), this.a.push(b ? 1 : 0);
    }, rt.prototype.writeBool = rt.prototype.I, rt.prototype.R = function(b) {
        ee(b == Math.floor(b)), ee(-2147483648 <= b && 2147483648 > b), this.M(b);
    }, rt.prototype.writeEnum = rt.prototype.R, rt.prototype.ja = function(b) {
        this.a.push.apply(this.a, b);
    }, rt.prototype.writeBytes = rt.prototype.ja, rt.prototype.N = function(b) {
        C(b), this.l(Z, ie);
    }, rt.prototype.writeVarintHash64 = rt.prototype.N, rt.prototype.K = function(b) {
        C(b), this.s(Z), this.s(ie);
    }, rt.prototype.writeFixedHash64 = rt.prototype.K, rt.prototype.U = function(b) {
        var T = this.a.length;
        q(b);
        for(var W = 0; W < b.length; W++){
            var fe = b.charCodeAt(W);
            if (128 > fe) this.a.push(fe);
            else if (2048 > fe) this.a.push(fe >> 6 | 192), this.a.push(fe & 63 | 128);
            else if (65536 > fe) if (55296 <= fe && 56319 >= fe && W + 1 < b.length) {
                var Oe = b.charCodeAt(W + 1);
                56320 <= Oe && 57343 >= Oe && (fe = 1024 * (fe - 55296) + Oe - 56320 + 65536, this.a.push(fe >> 18 | 240), this.a.push(fe >> 12 & 63 | 128), this.a.push(fe >> 6 & 63 | 128), this.a.push(fe & 63 | 128), W++);
            } else this.a.push(fe >> 12 | 224), this.a.push(fe >> 6 & 63 | 128), this.a.push(fe & 63 | 128);
        }
        return this.a.length - T;
    }, rt.prototype.writeString = rt.prototype.U;
    function Et(b, T) {
        this.lo = b, this.hi = T;
    }
    h("jspb.arith.UInt64", Et, void 0), Et.prototype.cmp = function(b) {
        return this.hi < b.hi || this.hi == b.hi && this.lo < b.lo ? -1 : this.hi == b.hi && this.lo == b.lo ? 0 : 1;
    }, Et.prototype.cmp = Et.prototype.cmp, Et.prototype.La = function() {
        return new Et((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
    }, Et.prototype.rightShift = Et.prototype.La, Et.prototype.Da = function() {
        return new Et(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
    }, Et.prototype.leftShift = Et.prototype.Da, Et.prototype.cb = function() {
        return !!(this.hi & 2147483648);
    }, Et.prototype.msb = Et.prototype.cb, Et.prototype.Ob = function() {
        return !!(this.lo & 1);
    }, Et.prototype.lsb = Et.prototype.Ob, Et.prototype.Ua = function() {
        return this.lo == 0 && this.hi == 0;
    }, Et.prototype.zero = Et.prototype.Ua, Et.prototype.add = function(b) {
        return new Et((this.lo + b.lo & 4294967295) >>> 0 >>> 0, ((this.hi + b.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + b.lo ? 1 : 0) >>> 0);
    }, Et.prototype.add = Et.prototype.add, Et.prototype.sub = function(b) {
        return new Et((this.lo - b.lo & 4294967295) >>> 0 >>> 0, ((this.hi - b.hi & 4294967295) >>> 0) - (0 > this.lo - b.lo ? 1 : 0) >>> 0);
    }, Et.prototype.sub = Et.prototype.sub;
    function Pe(b, T) {
        var W = b & 65535;
        b >>>= 16;
        var fe = T & 65535, Oe = T >>> 16;
        for(T = W * fe + 65536 * (W * Oe & 65535) + 65536 * (b * fe & 65535), W = b * Oe + (W * Oe >>> 16) + (b * fe >>> 16); 4294967296 <= T;)T -= 4294967296, W += 1;
        return new Et(T >>> 0, W >>> 0);
    }
    Et.mul32x32 = Pe, Et.prototype.eb = function(b) {
        var T = Pe(this.lo, b);
        return b = Pe(this.hi, b), b.hi = b.lo, b.lo = 0, T.add(b);
    }, Et.prototype.mul = Et.prototype.eb, Et.prototype.Xa = function(b) {
        if (b == 0) return [];
        var T = new Et(0, 0), W = new Et(this.lo, this.hi);
        b = new Et(b, 0);
        for(var fe = new Et(1, 0); !b.cb();)b = b.Da(), fe = fe.Da();
        for(; !fe.Ua();)0 >= b.cmp(W) && (T = T.add(fe), W = W.sub(b)), b = b.La(), fe = fe.La();
        return [
            T,
            W
        ];
    }, Et.prototype.div = Et.prototype.Xa, Et.prototype.toString = function() {
        for(var b = "", T = this; !T.Ua();){
            T = T.Xa(10);
            var W = T[0];
            b = T[1].lo + b, T = W;
        }
        return b == "" && (b = "0"), b;
    }, Et.prototype.toString = Et.prototype.toString;
    function mt(b) {
        for(var T = new Et(0, 0), W = new Et(0, 0), fe = 0; fe < b.length; fe++){
            if ("0" > b[fe] || "9" < b[fe]) return null;
            W.lo = parseInt(b[fe], 10), T = T.eb(10).add(W);
        }
        return T;
    }
    Et.fromString = mt, Et.prototype.clone = function() {
        return new Et(this.lo, this.hi);
    }, Et.prototype.clone = Et.prototype.clone;
    function ut(b, T) {
        this.lo = b, this.hi = T;
    }
    h("jspb.arith.Int64", ut, void 0), ut.prototype.add = function(b) {
        return new ut((this.lo + b.lo & 4294967295) >>> 0 >>> 0, ((this.hi + b.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + b.lo ? 1 : 0) >>> 0);
    }, ut.prototype.add = ut.prototype.add, ut.prototype.sub = function(b) {
        return new ut((this.lo - b.lo & 4294967295) >>> 0 >>> 0, ((this.hi - b.hi & 4294967295) >>> 0) - (0 > this.lo - b.lo ? 1 : 0) >>> 0);
    }, ut.prototype.sub = ut.prototype.sub, ut.prototype.clone = function() {
        return new ut(this.lo, this.hi);
    }, ut.prototype.clone = ut.prototype.clone, ut.prototype.toString = function() {
        var b = (this.hi & 2147483648) != 0, T = new Et(this.lo, this.hi);
        return b && (T = new Et(0, 0).sub(T)), (b ? "-" : "") + T.toString();
    }, ut.prototype.toString = ut.prototype.toString;
    function Jt(b) {
        var T = 0 < b.length && b[0] == "-";
        return T && (b = b.substring(1)), b = mt(b), b === null ? null : (T && (b = new Et(0, 0).sub(b)), new ut(b.lo, b.hi));
    }
    ut.fromString = Jt;
    function we() {
        this.c = [], this.b = 0, this.a = new rt(), this.h = [];
    }
    h("jspb.BinaryWriter", we, void 0);
    function Tr(b, T) {
        var W = b.a.end();
        b.c.push(W), b.c.push(T), b.b += W.length + T.length;
    }
    function ar(b, T) {
        return kt(b, T, 2), T = b.a.end(), b.c.push(T), b.b += T.length, T.push(b.b), T;
    }
    function sr(b, T) {
        var W = T.pop();
        for(W = b.b + b.a.length() - W, ee(0 <= W); 127 < W;)T.push(W & 127 | 128), W >>>= 7, b.b++;
        T.push(W), b.b++;
    }
    we.prototype.pb = function(b, T, W) {
        Tr(this, b.subarray(T, W));
    }, we.prototype.writeSerializedMessage = we.prototype.pb, we.prototype.Pb = function(b, T, W) {
        b != null && T != null && W != null && this.pb(b, T, W);
    }, we.prototype.maybeWriteSerializedMessage = we.prototype.Pb, we.prototype.reset = function() {
        this.c = [], this.a.end(), this.b = 0, this.h = [];
    }, we.prototype.reset = we.prototype.reset, we.prototype.ab = function() {
        ee(this.h.length == 0);
        for(var b = new Uint8Array(this.b + this.a.length()), T = this.c, W = T.length, fe = 0, Oe = 0; Oe < W; Oe++){
            var He = T[Oe];
            b.set(He, fe), fe += He.length;
        }
        return T = this.a.end(), b.set(T, fe), fe += T.length, ee(fe == b.length), this.c = [
            b
        ], b;
    }, we.prototype.getResultBuffer = we.prototype.ab, we.prototype.Kb = function(b) {
        return he(this.ab(), b);
    }, we.prototype.getResultBase64String = we.prototype.Kb, we.prototype.Va = function(b) {
        this.h.push(ar(this, b));
    }, we.prototype.beginSubMessage = we.prototype.Va, we.prototype.Ya = function() {
        ee(0 <= this.h.length), sr(this, this.h.pop());
    }, we.prototype.endSubMessage = we.prototype.Ya;
    function kt(b, T, W) {
        ee(1 <= T && T == Math.floor(T)), b.a.j(8 * T + W);
    }
    we.prototype.Nc = function(b, T, W) {
        switch(b){
            case 1:
                this.J(T, W);
                break;
            case 2:
                this.L(T, W);
                break;
            case 3:
                this.T(T, W);
                break;
            case 4:
                this.V(T, W);
                break;
            case 5:
                this.S(T, W);
                break;
            case 6:
                this.Qa(T, W);
                break;
            case 7:
                this.Pa(T, W);
                break;
            case 8:
                this.I(T, W);
                break;
            case 9:
                this.U(T, W);
                break;
            case 10:
                Q("Group field type not supported in writeAny()");
                break;
            case 11:
                Q("Message field type not supported in writeAny()");
                break;
            case 12:
                this.ja(T, W);
                break;
            case 13:
                this.s(T, W);
                break;
            case 14:
                this.R(T, W);
                break;
            case 15:
                this.Ra(T, W);
                break;
            case 16:
                this.Sa(T, W);
                break;
            case 17:
                this.rb(T, W);
                break;
            case 18:
                this.sb(T, W);
                break;
            case 30:
                this.K(T, W);
                break;
            case 31:
                this.N(T, W);
                break;
            default:
                Q("Invalid field type in writeAny()");
        }
    }, we.prototype.writeAny = we.prototype.Nc;
    function nn(b, T, W) {
        W != null && (kt(b, T, 0), b.a.j(W));
    }
    function bi(b, T, W) {
        W != null && (kt(b, T, 0), b.a.M(W));
    }
    we.prototype.S = function(b, T) {
        T != null && (ee(-2147483648 <= T && 2147483648 > T), bi(this, b, T));
    }, we.prototype.writeInt32 = we.prototype.S, we.prototype.ob = function(b, T) {
        T != null && (T = parseInt(T, 10), ee(-2147483648 <= T && 2147483648 > T), bi(this, b, T));
    }, we.prototype.writeInt32String = we.prototype.ob, we.prototype.T = function(b, T) {
        T != null && (ee(-9223372036854776e3 <= T && 9223372036854776e3 > T), T != null && (kt(this, b, 0), this.a.ua(T)));
    }, we.prototype.writeInt64 = we.prototype.T, we.prototype.ka = function(b, T) {
        T != null && (T = Jt(T), kt(this, b, 0), this.a.l(T.lo, T.hi));
    }, we.prototype.writeInt64String = we.prototype.ka, we.prototype.s = function(b, T) {
        T != null && (ee(0 <= T && 4294967296 > T), nn(this, b, T));
    }, we.prototype.writeUint32 = we.prototype.s, we.prototype.ub = function(b, T) {
        T != null && (T = parseInt(T, 10), ee(0 <= T && 4294967296 > T), nn(this, b, T));
    }, we.prototype.writeUint32String = we.prototype.ub, we.prototype.V = function(b, T) {
        T != null && (ee(0 <= T && 18446744073709552e3 > T), T != null && (kt(this, b, 0), this.a.va(T)));
    }, we.prototype.writeUint64 = we.prototype.V, we.prototype.vb = function(b, T) {
        T != null && (T = mt(T), kt(this, b, 0), this.a.l(T.lo, T.hi));
    }, we.prototype.writeUint64String = we.prototype.vb, we.prototype.rb = function(b, T) {
        T != null && (ee(-2147483648 <= T && 2147483648 > T), T != null && (kt(this, b, 0), this.a.wa(T)));
    }, we.prototype.writeSint32 = we.prototype.rb, we.prototype.sb = function(b, T) {
        T != null && (ee(-9223372036854776e3 <= T && 9223372036854776e3 > T), T != null && (kt(this, b, 0), this.a.xa(T)));
    }, we.prototype.writeSint64 = we.prototype.sb, we.prototype.$d = function(b, T) {
        T != null && T != null && (kt(this, b, 0), this.a.W(T));
    }, we.prototype.writeSintHash64 = we.prototype.$d, we.prototype.Zd = function(b, T) {
        T != null && T != null && (kt(this, b, 0), this.a.Ta(T));
    }, we.prototype.writeSint64String = we.prototype.Zd, we.prototype.Pa = function(b, T) {
        T != null && (ee(0 <= T && 4294967296 > T), kt(this, b, 5), this.a.s(T));
    }, we.prototype.writeFixed32 = we.prototype.Pa, we.prototype.Qa = function(b, T) {
        T != null && (ee(0 <= T && 18446744073709552e3 > T), kt(this, b, 1), this.a.V(T));
    }, we.prototype.writeFixed64 = we.prototype.Qa, we.prototype.nb = function(b, T) {
        T != null && (T = mt(T), kt(this, b, 1), this.a.A(T.lo, T.hi));
    }, we.prototype.writeFixed64String = we.prototype.nb, we.prototype.Ra = function(b, T) {
        T != null && (ee(-2147483648 <= T && 2147483648 > T), kt(this, b, 5), this.a.S(T));
    }, we.prototype.writeSfixed32 = we.prototype.Ra, we.prototype.Sa = function(b, T) {
        T != null && (ee(-9223372036854776e3 <= T && 9223372036854776e3 > T), kt(this, b, 1), this.a.T(T));
    }, we.prototype.writeSfixed64 = we.prototype.Sa, we.prototype.qb = function(b, T) {
        T != null && (T = Jt(T), kt(this, b, 1), this.a.A(T.lo, T.hi));
    }, we.prototype.writeSfixed64String = we.prototype.qb, we.prototype.L = function(b, T) {
        T != null && (kt(this, b, 5), this.a.L(T));
    }, we.prototype.writeFloat = we.prototype.L, we.prototype.J = function(b, T) {
        T != null && (kt(this, b, 1), this.a.J(T));
    }, we.prototype.writeDouble = we.prototype.J, we.prototype.I = function(b, T) {
        T != null && (ee(typeof T == "boolean" || typeof T == "number"), kt(this, b, 0), this.a.I(T));
    }, we.prototype.writeBool = we.prototype.I, we.prototype.R = function(b, T) {
        T != null && (ee(-2147483648 <= T && 2147483648 > T), kt(this, b, 0), this.a.M(T));
    }, we.prototype.writeEnum = we.prototype.R, we.prototype.U = function(b, T) {
        T != null && (b = ar(this, b), this.a.U(T), sr(this, b));
    }, we.prototype.writeString = we.prototype.U, we.prototype.ja = function(b, T) {
        T != null && (T = D(T), kt(this, b, 2), this.a.j(T.length), Tr(this, T));
    }, we.prototype.writeBytes = we.prototype.ja, we.prototype.Rc = function(b, T, W) {
        T != null && (b = ar(this, b), W(T, this), sr(this, b));
    }, we.prototype.writeMessage = we.prototype.Rc, we.prototype.Sc = function(b, T, W) {
        T != null && (kt(this, 1, 3), kt(this, 2, 0), this.a.M(b), b = ar(this, 3), W(T, this), sr(this, b), kt(this, 1, 4));
    }, we.prototype.writeMessageSet = we.prototype.Sc, we.prototype.Oc = function(b, T, W) {
        T != null && (kt(this, b, 3), W(T, this), kt(this, b, 4));
    }, we.prototype.writeGroup = we.prototype.Oc, we.prototype.K = function(b, T) {
        T != null && (ee(T.length == 8), kt(this, b, 1), this.a.K(T));
    }, we.prototype.writeFixedHash64 = we.prototype.K, we.prototype.N = function(b, T) {
        T != null && (ee(T.length == 8), kt(this, b, 0), this.a.N(T));
    }, we.prototype.writeVarintHash64 = we.prototype.N, we.prototype.A = function(b, T, W) {
        kt(this, b, 1), this.a.A(T, W);
    }, we.prototype.writeSplitFixed64 = we.prototype.A, we.prototype.l = function(b, T, W) {
        kt(this, b, 0), this.a.l(T, W);
    }, we.prototype.writeSplitVarint64 = we.prototype.l, we.prototype.tb = function(b, T, W) {
        kt(this, b, 0);
        var fe = this.a;
        je(T, W, function(Oe, He) {
            fe.l(Oe >>> 0, He >>> 0);
        });
    }, we.prototype.writeSplitZigzagVarint64 = we.prototype.tb, we.prototype.Ed = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)bi(this, b, T[W]);
    }, we.prototype.writeRepeatedInt32 = we.prototype.Ed, we.prototype.Fd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.ob(b, T[W]);
    }, we.prototype.writeRepeatedInt32String = we.prototype.Fd, we.prototype.Gd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++){
            var fe = T[W];
            fe != null && (kt(this, b, 0), this.a.ua(fe));
        }
    }, we.prototype.writeRepeatedInt64 = we.prototype.Gd, we.prototype.Qd = function(b, T, W, fe) {
        if (T != null) for(var Oe = 0; Oe < T.length; Oe++)this.A(b, W(T[Oe]), fe(T[Oe]));
    }, we.prototype.writeRepeatedSplitFixed64 = we.prototype.Qd, we.prototype.Rd = function(b, T, W, fe) {
        if (T != null) for(var Oe = 0; Oe < T.length; Oe++)this.l(b, W(T[Oe]), fe(T[Oe]));
    }, we.prototype.writeRepeatedSplitVarint64 = we.prototype.Rd, we.prototype.Sd = function(b, T, W, fe) {
        if (T != null) for(var Oe = 0; Oe < T.length; Oe++)this.tb(b, W(T[Oe]), fe(T[Oe]));
    }, we.prototype.writeRepeatedSplitZigzagVarint64 = we.prototype.Sd, we.prototype.Hd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.ka(b, T[W]);
    }, we.prototype.writeRepeatedInt64String = we.prototype.Hd, we.prototype.Ud = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)nn(this, b, T[W]);
    }, we.prototype.writeRepeatedUint32 = we.prototype.Ud, we.prototype.Vd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.ub(b, T[W]);
    }, we.prototype.writeRepeatedUint32String = we.prototype.Vd, we.prototype.Wd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++){
            var fe = T[W];
            fe != null && (kt(this, b, 0), this.a.va(fe));
        }
    }, we.prototype.writeRepeatedUint64 = we.prototype.Wd, we.prototype.Xd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.vb(b, T[W]);
    }, we.prototype.writeRepeatedUint64String = we.prototype.Xd, we.prototype.Md = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++){
            var fe = T[W];
            fe != null && (kt(this, b, 0), this.a.wa(fe));
        }
    }, we.prototype.writeRepeatedSint32 = we.prototype.Md, we.prototype.Nd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++){
            var fe = T[W];
            fe != null && (kt(this, b, 0), this.a.xa(fe));
        }
    }, we.prototype.writeRepeatedSint64 = we.prototype.Nd, we.prototype.Od = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++){
            var fe = T[W];
            fe != null && (kt(this, b, 0), this.a.Ta(fe));
        }
    }, we.prototype.writeRepeatedSint64String = we.prototype.Od, we.prototype.Pd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++){
            var fe = T[W];
            fe != null && (kt(this, b, 0), this.a.W(fe));
        }
    }, we.prototype.writeRepeatedSintHash64 = we.prototype.Pd, we.prototype.yd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.Pa(b, T[W]);
    }, we.prototype.writeRepeatedFixed32 = we.prototype.yd, we.prototype.zd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.Qa(b, T[W]);
    }, we.prototype.writeRepeatedFixed64 = we.prototype.zd, we.prototype.Ad = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.nb(b, T[W]);
    }, we.prototype.writeRepeatedFixed64String = we.prototype.Ad, we.prototype.Jd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.Ra(b, T[W]);
    }, we.prototype.writeRepeatedSfixed32 = we.prototype.Jd, we.prototype.Kd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.Sa(b, T[W]);
    }, we.prototype.writeRepeatedSfixed64 = we.prototype.Kd, we.prototype.Ld = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.qb(b, T[W]);
    }, we.prototype.writeRepeatedSfixed64String = we.prototype.Ld, we.prototype.Cd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.L(b, T[W]);
    }, we.prototype.writeRepeatedFloat = we.prototype.Cd, we.prototype.wd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.J(b, T[W]);
    }, we.prototype.writeRepeatedDouble = we.prototype.wd, we.prototype.ud = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.I(b, T[W]);
    }, we.prototype.writeRepeatedBool = we.prototype.ud, we.prototype.xd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.R(b, T[W]);
    }, we.prototype.writeRepeatedEnum = we.prototype.xd, we.prototype.Td = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.U(b, T[W]);
    }, we.prototype.writeRepeatedString = we.prototype.Td, we.prototype.vd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.ja(b, T[W]);
    }, we.prototype.writeRepeatedBytes = we.prototype.vd, we.prototype.Id = function(b, T, W) {
        if (T != null) for(var fe = 0; fe < T.length; fe++){
            var Oe = ar(this, b);
            W(T[fe], this), sr(this, Oe);
        }
    }, we.prototype.writeRepeatedMessage = we.prototype.Id, we.prototype.Dd = function(b, T, W) {
        if (T != null) for(var fe = 0; fe < T.length; fe++)kt(this, b, 3), W(T[fe], this), kt(this, b, 4);
    }, we.prototype.writeRepeatedGroup = we.prototype.Dd, we.prototype.Bd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.K(b, T[W]);
    }, we.prototype.writeRepeatedFixedHash64 = we.prototype.Bd, we.prototype.Yd = function(b, T) {
        if (T != null) for(var W = 0; W < T.length; W++)this.N(b, T[W]);
    }, we.prototype.writeRepeatedVarintHash64 = we.prototype.Yd, we.prototype.ad = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.M(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedInt32 = we.prototype.ad, we.prototype.bd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.M(parseInt(T[W], 10));
            sr(this, b);
        }
    }, we.prototype.writePackedInt32String = we.prototype.bd, we.prototype.cd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.ua(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedInt64 = we.prototype.cd, we.prototype.md = function(b, T, W, fe) {
        if (T != null) {
            b = ar(this, b);
            for(var Oe = 0; Oe < T.length; Oe++)this.a.A(W(T[Oe]), fe(T[Oe]));
            sr(this, b);
        }
    }, we.prototype.writePackedSplitFixed64 = we.prototype.md, we.prototype.nd = function(b, T, W, fe) {
        if (T != null) {
            b = ar(this, b);
            for(var Oe = 0; Oe < T.length; Oe++)this.a.l(W(T[Oe]), fe(T[Oe]));
            sr(this, b);
        }
    }, we.prototype.writePackedSplitVarint64 = we.prototype.nd, we.prototype.od = function(b, T, W, fe) {
        if (T != null) {
            b = ar(this, b);
            for(var Oe = this.a, He = 0; He < T.length; He++)je(W(T[He]), fe(T[He]), function(ht, Ht) {
                Oe.l(ht >>> 0, Ht >>> 0);
            });
            sr(this, b);
        }
    }, we.prototype.writePackedSplitZigzagVarint64 = we.prototype.od, we.prototype.dd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++){
                var fe = Jt(T[W]);
                this.a.l(fe.lo, fe.hi);
            }
            sr(this, b);
        }
    }, we.prototype.writePackedInt64String = we.prototype.dd, we.prototype.pd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.j(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedUint32 = we.prototype.pd, we.prototype.qd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.j(parseInt(T[W], 10));
            sr(this, b);
        }
    }, we.prototype.writePackedUint32String = we.prototype.qd, we.prototype.rd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.va(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedUint64 = we.prototype.rd, we.prototype.sd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++){
                var fe = mt(T[W]);
                this.a.l(fe.lo, fe.hi);
            }
            sr(this, b);
        }
    }, we.prototype.writePackedUint64String = we.prototype.sd, we.prototype.hd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.wa(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedSint32 = we.prototype.hd, we.prototype.jd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.xa(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedSint64 = we.prototype.jd, we.prototype.kd = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.W(le(T[W]));
            sr(this, b);
        }
    }, we.prototype.writePackedSint64String = we.prototype.kd, we.prototype.ld = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.W(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedSintHash64 = we.prototype.ld, we.prototype.Wc = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(4 * T.length), b = 0; b < T.length; b++)this.a.s(T[b]);
    }, we.prototype.writePackedFixed32 = we.prototype.Wc, we.prototype.Xc = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(8 * T.length), b = 0; b < T.length; b++)this.a.V(T[b]);
    }, we.prototype.writePackedFixed64 = we.prototype.Xc, we.prototype.Yc = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(8 * T.length), b = 0; b < T.length; b++){
            var W = mt(T[b]);
            this.a.A(W.lo, W.hi);
        }
    }, we.prototype.writePackedFixed64String = we.prototype.Yc, we.prototype.ed = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(4 * T.length), b = 0; b < T.length; b++)this.a.S(T[b]);
    }, we.prototype.writePackedSfixed32 = we.prototype.ed, we.prototype.fd = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(8 * T.length), b = 0; b < T.length; b++)this.a.T(T[b]);
    }, we.prototype.writePackedSfixed64 = we.prototype.fd, we.prototype.gd = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(8 * T.length), b = 0; b < T.length; b++)this.a.ka(T[b]);
    }, we.prototype.writePackedSfixed64String = we.prototype.gd, we.prototype.$c = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(4 * T.length), b = 0; b < T.length; b++)this.a.L(T[b]);
    }, we.prototype.writePackedFloat = we.prototype.$c, we.prototype.Uc = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(8 * T.length), b = 0; b < T.length; b++)this.a.J(T[b]);
    }, we.prototype.writePackedDouble = we.prototype.Uc, we.prototype.Tc = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(T.length), b = 0; b < T.length; b++)this.a.I(T[b]);
    }, we.prototype.writePackedBool = we.prototype.Tc, we.prototype.Vc = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.R(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedEnum = we.prototype.Vc, we.prototype.Zc = function(b, T) {
        if (T != null && T.length) for(kt(this, b, 2), this.a.j(8 * T.length), b = 0; b < T.length; b++)this.a.K(T[b]);
    }, we.prototype.writePackedFixedHash64 = we.prototype.Zc, we.prototype.td = function(b, T) {
        if (T != null && T.length) {
            b = ar(this, b);
            for(var W = 0; W < T.length; W++)this.a.N(T[W]);
            sr(this, b);
        }
    }, we.prototype.writePackedVarintHash64 = we.prototype.td, e.debug = Rt, e.Map = g, e.Message = Xe, e.BinaryReader = ce, e.BinaryWriter = we, e.ExtensionFieldInfo = yt, e.ExtensionFieldBinaryInfo = Ut, e.exportSymbol = k, e.inherits = P, e.object = {
        extend: N
    }, e.typeOf = y;
})(y5);
var Soe = Qe && Qe.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i1 = Object.getOwnPropertyDescriptor(t, r);
    (!i1 || ("get" in i1 ? !t.__esModule : i1.writable || i1.configurable)) && (i1 = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i1);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), xoe = Qe && Qe.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), _oe = Qe && Qe.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Soe(t, e, r);
    return xoe(t, e), t;
}, En = Qe && Qe.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
};
Object.defineProperty(Rf, "__esModule", {
    value: !0
});
Rf.protorune = void 0;
const Be = _oe(y5);
var AO;
(function(e) {
    var t, r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M, N, z, K, $, ne, ee, q;
    class U extends Be.Message {
        constructor(C){
            super(), t.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, t, "f")), !Array.isArray(C) && typeof C == "object" && ("height" in C && C.height != null && (this.height = C.height), "txindex" in C && C.txindex != null && (this.txindex = C.txindex));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(C) {
            Be.Message.setField(this, 1, C);
        }
        get txindex() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set txindex(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new U({});
            return C.height != null && (J.height = C.height), C.txindex != null && (J.txindex = C.txindex), J;
        }
        toObject() {
            const C = {};
            return this.height != null && (C.height = this.height), this.txindex != null && (C.txindex = this.txindex), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.height != 0 && J.writeUint32(1, this.height), this.txindex != 0 && J.writeUint32(2, this.txindex), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new U();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.height = J.readUint32();
                    break;
                case 2:
                    me.txindex = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return U.deserialize(C);
        }
    }
    t = /* @__PURE__ */ new WeakMap(), e.RuneId = U;
    class Q extends Be.Message {
        constructor(C){
            super(), r.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, r, "f")), !Array.isArray(C) && typeof C == "object" && ("height" in C && C.height != null && (this.height = C.height), "transaction" in C && C.transaction != null && (this.transaction = C.transaction));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(C) {
            Be.Message.setField(this, 1, C);
        }
        get transaction() {
            return Be.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set transaction(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new Q({});
            return C.height != null && (J.height = C.height), C.transaction != null && (J.transaction = C.transaction), J;
        }
        toObject() {
            const C = {};
            return this.height != null && (C.height = this.height), this.transaction != null && (C.transaction = this.transaction), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.height != 0 && J.writeUint64(1, this.height), this.transaction.length && J.writeBytes(2, this.transaction), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new Q();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.height = J.readUint64();
                    break;
                case 2:
                    me.transaction = J.readBytes();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return Q.deserialize(C);
        }
    }
    r = /* @__PURE__ */ new WeakMap(), e.TransactionRecord = Q;
    class v extends Be.Message {
        constructor(C){
            super(), n.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, n, "f")), !Array.isArray(C) && typeof C == "object" && ("height" in C && C.height != null && (this.height = C.height), "txindex" in C && C.txindex != null && (this.txindex = C.txindex));
        }
        get height() {
            return Be.Message.getWrapperField(this, se, 1);
        }
        set height(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_height() {
            return Be.Message.getField(this, 1) != null;
        }
        get txindex() {
            return Be.Message.getWrapperField(this, se, 2);
        }
        set txindex(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_txindex() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(C) {
            const J = new v({});
            return C.height != null && (J.height = se.fromObject(C.height)), C.txindex != null && (J.txindex = se.fromObject(C.txindex)), J;
        }
        toObject() {
            const C = {};
            return this.height != null && (C.height = this.height.toObject()), this.txindex != null && (C.txindex = this.txindex.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_height && J.writeMessage(1, this.height, ()=>this.height.serialize(J)), this.has_txindex && J.writeMessage(2, this.txindex, ()=>this.txindex.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new v();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.height, ()=>me.height = se.deserialize(J));
                    break;
                case 2:
                    J.readMessage(me.txindex, ()=>me.txindex = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return v.deserialize(C);
        }
    }
    n = /* @__PURE__ */ new WeakMap(), e.ProtoruneRuneId = v;
    class B extends Be.Message {
        constructor(C){
            super(), i1.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, i1, "f")), !Array.isArray(C) && typeof C == "object" && ("runeId" in C && C.runeId != null && (this.runeId = C.runeId), "name" in C && C.name != null && (this.name = C.name), "divisibility" in C && C.divisibility != null && (this.divisibility = C.divisibility), "spacers" in C && C.spacers != null && (this.spacers = C.spacers), "symbol" in C && C.symbol != null && (this.symbol = C.symbol), "runes_symbol" in C && C.runes_symbol != null && (this.runes_symbol = C.runes_symbol));
        }
        get runeId() {
            return Be.Message.getWrapperField(this, v, 1);
        }
        set runeId(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_runeId() {
            return Be.Message.getField(this, 1) != null;
        }
        get name() {
            return Be.Message.getFieldWithDefault(this, 2, "");
        }
        set name(C) {
            Be.Message.setField(this, 2, C);
        }
        get divisibility() {
            return Be.Message.getFieldWithDefault(this, 3, 0);
        }
        set divisibility(C) {
            Be.Message.setField(this, 3, C);
        }
        get spacers() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set spacers(C) {
            Be.Message.setField(this, 4, C);
        }
        get symbol() {
            return Be.Message.getFieldWithDefault(this, 5, "");
        }
        set symbol(C) {
            Be.Message.setField(this, 5, C);
        }
        get runes_symbol() {
            return Be.Message.getFieldWithDefault(this, 6, 0);
        }
        set runes_symbol(C) {
            Be.Message.setField(this, 6, C);
        }
        static fromObject(C) {
            const J = new B({});
            return C.runeId != null && (J.runeId = v.fromObject(C.runeId)), C.name != null && (J.name = C.name), C.divisibility != null && (J.divisibility = C.divisibility), C.spacers != null && (J.spacers = C.spacers), C.symbol != null && (J.symbol = C.symbol), C.runes_symbol != null && (J.runes_symbol = C.runes_symbol), J;
        }
        toObject() {
            const C = {};
            return this.runeId != null && (C.runeId = this.runeId.toObject()), this.name != null && (C.name = this.name), this.divisibility != null && (C.divisibility = this.divisibility), this.spacers != null && (C.spacers = this.spacers), this.symbol != null && (C.symbol = this.symbol), this.runes_symbol != null && (C.runes_symbol = this.runes_symbol), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_runeId && J.writeMessage(1, this.runeId, ()=>this.runeId.serialize(J)), this.name.length && J.writeString(2, this.name), this.divisibility != 0 && J.writeUint32(3, this.divisibility), this.spacers != 0 && J.writeUint32(4, this.spacers), this.symbol.length && J.writeString(5, this.symbol), this.runes_symbol != 0 && J.writeUint32(6, this.runes_symbol), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new B();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.runeId, ()=>me.runeId = v.deserialize(J));
                    break;
                case 2:
                    me.name = J.readString();
                    break;
                case 3:
                    me.divisibility = J.readUint32();
                    break;
                case 4:
                    me.spacers = J.readUint32();
                    break;
                case 5:
                    me.symbol = J.readString();
                    break;
                case 6:
                    me.runes_symbol = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return B.deserialize(C);
        }
    }
    i1 = /* @__PURE__ */ new WeakMap(), e.Rune = B;
    class g extends Be.Message {
        constructor(C){
            super(), o.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, o, "f")), !Array.isArray(C) && typeof C == "object" && ("rune" in C && C.rune != null && (this.rune = C.rune), "balance" in C && C.balance != null && (this.balance = C.balance));
        }
        get rune() {
            return Be.Message.getWrapperField(this, B, 1);
        }
        set rune(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_rune() {
            return Be.Message.getField(this, 1) != null;
        }
        get balance() {
            return Be.Message.getWrapperField(this, se, 2);
        }
        set balance(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_balance() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(C) {
            const J = new g({});
            return C.rune != null && (J.rune = B.fromObject(C.rune)), C.balance != null && (J.balance = se.fromObject(C.balance)), J;
        }
        toObject() {
            const C = {};
            return this.rune != null && (C.rune = this.rune.toObject()), this.balance != null && (C.balance = this.balance.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_rune && J.writeMessage(1, this.rune, ()=>this.rune.serialize(J)), this.has_balance && J.writeMessage(2, this.balance, ()=>this.balance.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new g();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.rune, ()=>me.rune = B.deserialize(J));
                    break;
                case 2:
                    J.readMessage(me.balance, ()=>me.balance = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return g.deserialize(C);
        }
    }
    o = /* @__PURE__ */ new WeakMap(), e.BalanceSheetItem = g;
    class E extends Be.Message {
        constructor(C){
            super(), a.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [
                1
            ], En(this, a, "f")), !Array.isArray(C) && typeof C == "object" && "entries" in C && C.entries != null && (this.entries = C.entries);
        }
        get entries() {
            return Be.Message.getRepeatedWrapperField(this, g, 1);
        }
        set entries(C) {
            Be.Message.setRepeatedWrapperField(this, 1, C);
        }
        static fromObject(C) {
            const J = new E({});
            return C.entries != null && (J.entries = C.entries.map((me)=>g.fromObject(me))), J;
        }
        toObject() {
            const C = {};
            return this.entries != null && (C.entries = this.entries.map((J)=>J.toObject())), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.entries.length && J.writeRepeatedMessage(1, this.entries, (me)=>me.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new E();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.entries, ()=>Be.Message.addToRepeatedWrapperField(me, 1, g.deserialize(J), g));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return E.deserialize(C);
        }
    }
    a = /* @__PURE__ */ new WeakMap(), e.BalanceSheet = E;
    class w extends Be.Message {
        constructor(C){
            super(), s.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, s, "f")), !Array.isArray(C) && typeof C == "object" && ("txid" in C && C.txid != null && (this.txid = C.txid), "vout" in C && C.vout != null && (this.vout = C.vout));
        }
        get txid() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(C) {
            Be.Message.setField(this, 1, C);
        }
        get vout() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new w({});
            return C.txid != null && (J.txid = C.txid), C.vout != null && (J.vout = C.vout), J;
        }
        toObject() {
            const C = {};
            return this.txid != null && (C.txid = this.txid), this.vout != null && (C.vout = this.vout), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.txid.length && J.writeBytes(1, this.txid), this.vout != 0 && J.writeUint32(2, this.vout), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new w();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.txid = J.readBytes();
                    break;
                case 2:
                    me.vout = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return w.deserialize(C);
        }
    }
    s = /* @__PURE__ */ new WeakMap(), e.Outpoint = w;
    class _ extends Be.Message {
        constructor(C){
            super(), c.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, c, "f")), !Array.isArray(C) && typeof C == "object" && ("txid" in C && C.txid != null && (this.txid = C.txid), "vout" in C && C.vout != null && (this.vout = C.vout), "protocol" in C && C.protocol != null && (this.protocol = C.protocol));
        }
        get txid() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(C) {
            Be.Message.setField(this, 1, C);
        }
        get vout() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(C) {
            Be.Message.setField(this, 2, C);
        }
        get protocol() {
            return Be.Message.getWrapperField(this, se, 3);
        }
        set protocol(C) {
            Be.Message.setWrapperField(this, 3, C);
        }
        get has_protocol() {
            return Be.Message.getField(this, 3) != null;
        }
        static fromObject(C) {
            const J = new _({});
            return C.txid != null && (J.txid = C.txid), C.vout != null && (J.vout = C.vout), C.protocol != null && (J.protocol = se.fromObject(C.protocol)), J;
        }
        toObject() {
            const C = {};
            return this.txid != null && (C.txid = this.txid), this.vout != null && (C.vout = this.vout), this.protocol != null && (C.protocol = this.protocol.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.txid.length && J.writeBytes(1, this.txid), this.vout != 0 && J.writeUint32(2, this.vout), this.has_protocol && J.writeMessage(3, this.protocol, ()=>this.protocol.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new _();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.txid = J.readBytes();
                    break;
                case 2:
                    me.vout = J.readUint32();
                    break;
                case 3:
                    J.readMessage(me.protocol, ()=>me.protocol = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return _.deserialize(C);
        }
    }
    c = /* @__PURE__ */ new WeakMap(), e.OutpointWithProtocol = _;
    class O extends Be.Message {
        constructor(C){
            super(), l.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, l, "f")), !Array.isArray(C) && typeof C == "object" && ("script" in C && C.script != null && (this.script = C.script), "value" in C && C.value != null && (this.value = C.value));
        }
        get script() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set script(C) {
            Be.Message.setField(this, 1, C);
        }
        get value() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set value(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new O({});
            return C.script != null && (J.script = C.script), C.value != null && (J.value = C.value), J;
        }
        toObject() {
            const C = {};
            return this.script != null && (C.script = this.script), this.value != null && (C.value = this.value), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.script.length && J.writeBytes(1, this.script), this.value != 0 && J.writeUint64(2, this.value), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new O();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.script = J.readBytes();
                    break;
                case 2:
                    me.value = J.readUint64();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return O.deserialize(C);
        }
    }
    l = /* @__PURE__ */ new WeakMap(), e.Output = O;
    class I extends Be.Message {
        constructor(C){
            super(), u.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, u, "f")), !Array.isArray(C) && typeof C == "object" && ("balances" in C && C.balances != null && (this.balances = C.balances), "outpoint" in C && C.outpoint != null && (this.outpoint = C.outpoint), "output" in C && C.output != null && (this.output = C.output), "height" in C && C.height != null && (this.height = C.height), "txindex" in C && C.txindex != null && (this.txindex = C.txindex));
        }
        get balances() {
            return Be.Message.getWrapperField(this, E, 1);
        }
        set balances(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_balances() {
            return Be.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return Be.Message.getWrapperField(this, w, 2);
        }
        set outpoint(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_outpoint() {
            return Be.Message.getField(this, 2) != null;
        }
        get output() {
            return Be.Message.getWrapperField(this, O, 3);
        }
        set output(C) {
            Be.Message.setWrapperField(this, 3, C);
        }
        get has_output() {
            return Be.Message.getField(this, 3) != null;
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set height(C) {
            Be.Message.setField(this, 4, C);
        }
        get txindex() {
            return Be.Message.getFieldWithDefault(this, 5, 0);
        }
        set txindex(C) {
            Be.Message.setField(this, 5, C);
        }
        static fromObject(C) {
            const J = new I({});
            return C.balances != null && (J.balances = E.fromObject(C.balances)), C.outpoint != null && (J.outpoint = w.fromObject(C.outpoint)), C.output != null && (J.output = O.fromObject(C.output)), C.height != null && (J.height = C.height), C.txindex != null && (J.txindex = C.txindex), J;
        }
        toObject() {
            const C = {};
            return this.balances != null && (C.balances = this.balances.toObject()), this.outpoint != null && (C.outpoint = this.outpoint.toObject()), this.output != null && (C.output = this.output.toObject()), this.height != null && (C.height = this.height), this.txindex != null && (C.txindex = this.txindex), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_balances && J.writeMessage(1, this.balances, ()=>this.balances.serialize(J)), this.has_outpoint && J.writeMessage(2, this.outpoint, ()=>this.outpoint.serialize(J)), this.has_output && J.writeMessage(3, this.output, ()=>this.output.serialize(J)), this.height != 0 && J.writeUint32(4, this.height), this.txindex != 0 && J.writeUint32(5, this.txindex), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new I();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.balances, ()=>me.balances = E.deserialize(J));
                    break;
                case 2:
                    J.readMessage(me.outpoint, ()=>me.outpoint = w.deserialize(J));
                    break;
                case 3:
                    J.readMessage(me.output, ()=>me.output = O.deserialize(J));
                    break;
                case 4:
                    me.height = J.readUint32();
                    break;
                case 5:
                    me.txindex = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return I.deserialize(C);
        }
    }
    u = /* @__PURE__ */ new WeakMap(), e.OutpointResponse = I;
    class x extends Be.Message {
        constructor(C){
            super(), f.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, f, "f")), !Array.isArray(C) && typeof C == "object" && ("start" in C && C.start != null && (this.start = C.start), "end" in C && C.end != null && (this.end = C.end));
        }
        get start() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set start(C) {
            Be.Message.setField(this, 1, C);
        }
        get end() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set end(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new x({});
            return C.start != null && (J.start = C.start), C.end != null && (J.end = C.end), J;
        }
        toObject() {
            const C = {};
            return this.start != null && (C.start = this.start), this.end != null && (C.end = this.end), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.start != 0 && J.writeUint32(1, this.start), this.end != 0 && J.writeUint32(2, this.end), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new x();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.start = J.readUint32();
                    break;
                case 2:
                    me.end = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return x.deserialize(C);
        }
    }
    f = /* @__PURE__ */ new WeakMap(), e.PaginationInput = x;
    class R extends Be.Message {
        constructor(C){
            super(), h.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, h, "f")), !Array.isArray(C) && typeof C == "object" && "wallet" in C && C.wallet != null && (this.wallet = C.wallet);
        }
        get wallet() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set wallet(C) {
            Be.Message.setField(this, 1, C);
        }
        static fromObject(C) {
            const J = new R({});
            return C.wallet != null && (J.wallet = C.wallet), J;
        }
        toObject() {
            const C = {};
            return this.wallet != null && (C.wallet = this.wallet), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.wallet.length && J.writeBytes(1, this.wallet), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new R();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.wallet = J.readBytes();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return R.deserialize(C);
        }
    }
    h = /* @__PURE__ */ new WeakMap(), e.WalletRequest = R;
    class j extends Be.Message {
        constructor(C){
            super(), y.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [
                1
            ], En(this, y, "f")), !Array.isArray(C) && typeof C == "object" && ("outpoints" in C && C.outpoints != null && (this.outpoints = C.outpoints), "balances" in C && C.balances != null && (this.balances = C.balances));
        }
        get outpoints() {
            return Be.Message.getRepeatedWrapperField(this, I, 1);
        }
        set outpoints(C) {
            Be.Message.setRepeatedWrapperField(this, 1, C);
        }
        get balances() {
            return Be.Message.getWrapperField(this, E, 2);
        }
        set balances(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_balances() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(C) {
            const J = new j({});
            return C.outpoints != null && (J.outpoints = C.outpoints.map((me)=>I.fromObject(me))), C.balances != null && (J.balances = E.fromObject(C.balances)), J;
        }
        toObject() {
            const C = {};
            return this.outpoints != null && (C.outpoints = this.outpoints.map((J)=>J.toObject())), this.balances != null && (C.balances = this.balances.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.outpoints.length && J.writeRepeatedMessage(1, this.outpoints, (me)=>me.serialize(J)), this.has_balances && J.writeMessage(2, this.balances, ()=>this.balances.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new j();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.outpoints, ()=>Be.Message.addToRepeatedWrapperField(me, 1, I.deserialize(J), I));
                    break;
                case 2:
                    J.readMessage(me.balances, ()=>me.balances = E.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return j.deserialize(C);
        }
    }
    y = /* @__PURE__ */ new WeakMap(), e.WalletResponse = j;
    class Y extends Be.Message {
        constructor(C){
            super(), S.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, S, "f")), !Array.isArray(C) && typeof C == "object" && ("wallet" in C && C.wallet != null && (this.wallet = C.wallet), "protocol_tag" in C && C.protocol_tag != null && (this.protocol_tag = C.protocol_tag));
        }
        get wallet() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set wallet(C) {
            Be.Message.setField(this, 1, C);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, se, 2);
        }
        set protocol_tag(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(C) {
            const J = new Y({});
            return C.wallet != null && (J.wallet = C.wallet), C.protocol_tag != null && (J.protocol_tag = se.fromObject(C.protocol_tag)), J;
        }
        toObject() {
            const C = {};
            return this.wallet != null && (C.wallet = this.wallet), this.protocol_tag != null && (C.protocol_tag = this.protocol_tag.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.wallet.length && J.writeBytes(1, this.wallet), this.has_protocol_tag && J.writeMessage(2, this.protocol_tag, ()=>this.protocol_tag.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new Y();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.wallet = J.readBytes();
                    break;
                case 2:
                    J.readMessage(me.protocol_tag, ()=>me.protocol_tag = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return Y.deserialize(C);
        }
    }
    S = /* @__PURE__ */ new WeakMap(), e.ProtorunesWalletRequest = Y;
    class he extends Be.Message {
        constructor(C){
            super(), k.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, k, "f")), !Array.isArray(C) && typeof C == "object" && "height" in C && C.height != null && (this.height = C.height);
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(C) {
            Be.Message.setField(this, 1, C);
        }
        static fromObject(C) {
            const J = new he({});
            return C.height != null && (J.height = C.height), J;
        }
        toObject() {
            const C = {};
            return this.height != null && (C.height = this.height), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.height != 0 && J.writeUint64(1, this.height), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new he();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.height = J.readUint64();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return he.deserialize(C);
        }
    }
    k = /* @__PURE__ */ new WeakMap(), e.RunesByHeightRequest = he;
    class ue extends Be.Message {
        constructor(C){
            super(), P.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [
                1
            ], En(this, P, "f")), !Array.isArray(C) && typeof C == "object" && "runes" in C && C.runes != null && (this.runes = C.runes);
        }
        get runes() {
            return Be.Message.getRepeatedWrapperField(this, B, 1);
        }
        set runes(C) {
            Be.Message.setRepeatedWrapperField(this, 1, C);
        }
        static fromObject(C) {
            const J = new ue({});
            return C.runes != null && (J.runes = C.runes.map((me)=>B.fromObject(me))), J;
        }
        toObject() {
            const C = {};
            return this.runes != null && (C.runes = this.runes.map((J)=>J.toObject())), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.runes.length && J.writeRepeatedMessage(1, this.runes, (me)=>me.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new ue();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.runes, ()=>Be.Message.addToRepeatedWrapperField(me, 1, B.deserialize(J), B));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return ue.deserialize(C);
        }
    }
    P = /* @__PURE__ */ new WeakMap(), e.RunesResponse = ue;
    class G extends Be.Message {
        constructor(C){
            super(), M.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, M, "f")), !Array.isArray(C) && typeof C == "object" && ("protocol_tag" in C && C.protocol_tag != null && (this.protocol_tag = C.protocol_tag), "pointer" in C && C.pointer != null && (this.pointer = C.pointer));
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, se, 1);
        }
        set protocol_tag(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 1) != null;
        }
        get pointer() {
            return Be.Message.getFieldWithDefault(this, 2, 0);
        }
        set pointer(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new G({});
            return C.protocol_tag != null && (J.protocol_tag = se.fromObject(C.protocol_tag)), C.pointer != null && (J.pointer = C.pointer), J;
        }
        toObject() {
            const C = {};
            return this.protocol_tag != null && (C.protocol_tag = this.protocol_tag.toObject()), this.pointer != null && (C.pointer = this.pointer), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_protocol_tag && J.writeMessage(1, this.protocol_tag, ()=>this.protocol_tag.serialize(J)), this.pointer != 0 && J.writeUint32(2, this.pointer), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new G();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.protocol_tag, ()=>me.protocol_tag = se.deserialize(J));
                    break;
                case 2:
                    me.pointer = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return G.deserialize(C);
        }
    }
    M = /* @__PURE__ */ new WeakMap(), e.ProtoBurn = G;
    class se extends Be.Message {
        constructor(C){
            super(), N.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, N, "f")), !Array.isArray(C) && typeof C == "object" && ("lo" in C && C.lo != null && (this.lo = C.lo), "hi" in C && C.hi != null && (this.hi = C.hi));
        }
        get lo() {
            return Be.Message.getFieldWithDefault(this, 1, "0");
        }
        set lo(C) {
            Be.Message.setField(this, 1, C);
        }
        get hi() {
            return Be.Message.getFieldWithDefault(this, 2, "0");
        }
        set hi(C) {
            Be.Message.setField(this, 2, C);
        }
        static fromObject(C) {
            const J = new se({});
            return C.lo != null && (J.lo = C.lo), C.hi != null && (J.hi = C.hi), J;
        }
        toObject() {
            const C = {};
            return this.lo != null && (C.lo = this.lo), this.hi != null && (C.hi = this.hi), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.lo != "0" && J.writeUint64String(1, this.lo), this.hi != "0" && J.writeUint64String(2, this.hi), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new se();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.lo = J.readUint64String();
                    break;
                case 2:
                    me.hi = J.readUint64String();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return se.deserialize(C);
        }
    }
    N = /* @__PURE__ */ new WeakMap(), e.uint128 = se;
    class Z extends Be.Message {
        constructor(C){
            super(), z.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, z, "f")), !Array.isArray(C) && typeof C == "object" && ("rune" in C && C.rune != null && (this.rune = C.rune), "amount" in C && C.amount != null && (this.amount = C.amount));
        }
        get rune() {
            return Be.Message.getWrapperField(this, v, 1);
        }
        set rune(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_rune() {
            return Be.Message.getField(this, 1) != null;
        }
        get amount() {
            return Be.Message.getWrapperField(this, se, 2);
        }
        set amount(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_amount() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(C) {
            const J = new Z({});
            return C.rune != null && (J.rune = v.fromObject(C.rune)), C.amount != null && (J.amount = se.fromObject(C.amount)), J;
        }
        toObject() {
            const C = {};
            return this.rune != null && (C.rune = this.rune.toObject()), this.amount != null && (C.amount = this.amount.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_rune && J.writeMessage(1, this.rune, ()=>this.rune.serialize(J)), this.has_amount && J.writeMessage(2, this.amount, ()=>this.amount.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new Z();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.rune, ()=>me.rune = v.deserialize(J));
                    break;
                case 2:
                    J.readMessage(me.amount, ()=>me.amount = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return Z.deserialize(C);
        }
    }
    z = /* @__PURE__ */ new WeakMap(), e.Clause = Z;
    class ie extends Be.Message {
        constructor(C){
            super(), K.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [
                1
            ], En(this, K, "f")), !Array.isArray(C) && typeof C == "object" && "clauses" in C && C.clauses != null && (this.clauses = C.clauses);
        }
        get clauses() {
            return Be.Message.getRepeatedWrapperField(this, Z, 1);
        }
        set clauses(C) {
            Be.Message.setRepeatedWrapperField(this, 1, C);
        }
        static fromObject(C) {
            const J = new ie({});
            return C.clauses != null && (J.clauses = C.clauses.map((me)=>Z.fromObject(me))), J;
        }
        toObject() {
            const C = {};
            return this.clauses != null && (C.clauses = this.clauses.map((J)=>J.toObject())), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.clauses.length && J.writeRepeatedMessage(1, this.clauses, (me)=>me.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new ie();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.clauses, ()=>Be.Message.addToRepeatedWrapperField(me, 1, Z.deserialize(J), Z));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return ie.deserialize(C);
        }
    }
    K = /* @__PURE__ */ new WeakMap(), e.Predicate = ie;
    class pe extends Be.Message {
        constructor(C){
            super(), $.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, $, "f")), !Array.isArray(C) && typeof C == "object" && ("calldata" in C && C.calldata != null && (this.calldata = C.calldata), "predicate" in C && C.predicate != null && (this.predicate = C.predicate), "pointer" in C && C.pointer != null && (this.pointer = C.pointer), "refund_pointer" in C && C.refund_pointer != null && (this.refund_pointer = C.refund_pointer));
        }
        get calldata() {
            return Be.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set calldata(C) {
            Be.Message.setField(this, 1, C);
        }
        get predicate() {
            return Be.Message.getWrapperField(this, ie, 2);
        }
        set predicate(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_predicate() {
            return Be.Message.getField(this, 2) != null;
        }
        get pointer() {
            return Be.Message.getFieldWithDefault(this, 3, 0);
        }
        set pointer(C) {
            Be.Message.setField(this, 3, C);
        }
        get refund_pointer() {
            return Be.Message.getFieldWithDefault(this, 4, 0);
        }
        set refund_pointer(C) {
            Be.Message.setField(this, 4, C);
        }
        static fromObject(C) {
            const J = new pe({});
            return C.calldata != null && (J.calldata = C.calldata), C.predicate != null && (J.predicate = ie.fromObject(C.predicate)), C.pointer != null && (J.pointer = C.pointer), C.refund_pointer != null && (J.refund_pointer = C.refund_pointer), J;
        }
        toObject() {
            const C = {};
            return this.calldata != null && (C.calldata = this.calldata), this.predicate != null && (C.predicate = this.predicate.toObject()), this.pointer != null && (C.pointer = this.pointer), this.refund_pointer != null && (C.refund_pointer = this.refund_pointer), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.calldata.length && J.writeBytes(1, this.calldata), this.has_predicate && J.writeMessage(2, this.predicate, ()=>this.predicate.serialize(J)), this.pointer != 0 && J.writeUint32(3, this.pointer), this.refund_pointer != 0 && J.writeUint32(4, this.refund_pointer), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new pe();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.calldata = J.readBytes();
                    break;
                case 2:
                    J.readMessage(me.predicate, ()=>me.predicate = ie.deserialize(J));
                    break;
                case 3:
                    me.pointer = J.readUint32();
                    break;
                case 4:
                    me.refund_pointer = J.readUint32();
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return pe.deserialize(C);
        }
    }
    $ = /* @__PURE__ */ new WeakMap(), e.ProtoMessage = pe;
    class ve extends Be.Message {
        constructor(C){
            super(), ne.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, ne, "f")), !Array.isArray(C) && typeof C == "object" && "protocol_tag" in C && C.protocol_tag != null && (this.protocol_tag = C.protocol_tag);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, se, 1);
        }
        set protocol_tag(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 1) != null;
        }
        static fromObject(C) {
            const J = new ve({});
            return C.protocol_tag != null && (J.protocol_tag = se.fromObject(C.protocol_tag)), J;
        }
        toObject() {
            const C = {};
            return this.protocol_tag != null && (C.protocol_tag = this.protocol_tag.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_protocol_tag && J.writeMessage(1, this.protocol_tag, ()=>this.protocol_tag.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new ve();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.protocol_tag, ()=>me.protocol_tag = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return ve.deserialize(C);
        }
    }
    ne = /* @__PURE__ */ new WeakMap(), e.RuntimeInput = ve;
    class Ie extends Be.Message {
        constructor(C){
            super(), ee.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, ee, "f")), !Array.isArray(C) && typeof C == "object" && "balances" in C && C.balances != null && (this.balances = C.balances);
        }
        get balances() {
            return Be.Message.getWrapperField(this, E, 1);
        }
        set balances(C) {
            Be.Message.setWrapperField(this, 1, C);
        }
        get has_balances() {
            return Be.Message.getField(this, 1) != null;
        }
        static fromObject(C) {
            const J = new Ie({});
            return C.balances != null && (J.balances = E.fromObject(C.balances)), J;
        }
        toObject() {
            const C = {};
            return this.balances != null && (C.balances = this.balances.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.has_balances && J.writeMessage(1, this.balances, ()=>this.balances.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new Ie();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    J.readMessage(me.balances, ()=>me.balances = E.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return Ie.deserialize(C);
        }
    }
    ee = /* @__PURE__ */ new WeakMap(), e.Runtime = Ie;
    class Me extends Be.Message {
        constructor(C){
            super(), q.set(this, []), Be.Message.initialize(this, Array.isArray(C) ? C : [], 0, -1, [], En(this, q, "f")), !Array.isArray(C) && typeof C == "object" && ("height" in C && C.height != null && (this.height = C.height), "protocol_tag" in C && C.protocol_tag != null && (this.protocol_tag = C.protocol_tag));
        }
        get height() {
            return Be.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(C) {
            Be.Message.setField(this, 1, C);
        }
        get protocol_tag() {
            return Be.Message.getWrapperField(this, se, 2);
        }
        set protocol_tag(C) {
            Be.Message.setWrapperField(this, 2, C);
        }
        get has_protocol_tag() {
            return Be.Message.getField(this, 2) != null;
        }
        static fromObject(C) {
            const J = new Me({});
            return C.height != null && (J.height = C.height), C.protocol_tag != null && (J.protocol_tag = se.fromObject(C.protocol_tag)), J;
        }
        toObject() {
            const C = {};
            return this.height != null && (C.height = this.height), this.protocol_tag != null && (C.protocol_tag = this.protocol_tag.toObject()), C;
        }
        serialize(C) {
            const J = C || new Be.BinaryWriter();
            if (this.height != 0 && J.writeUint64(1, this.height), this.has_protocol_tag && J.writeMessage(2, this.protocol_tag, ()=>this.protocol_tag.serialize(J)), !C) return J.getResultBuffer();
        }
        static deserialize(C) {
            const J = C instanceof Be.BinaryReader ? C : new Be.BinaryReader(C), me = new Me();
            for(; J.nextField() && !J.isEndGroup();)switch(J.getFieldNumber()){
                case 1:
                    me.height = J.readUint64();
                    break;
                case 2:
                    J.readMessage(me.protocol_tag, ()=>me.protocol_tag = se.deserialize(J));
                    break;
                default:
                    J.skipField();
            }
            return me;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(C) {
            return Me.deserialize(C);
        }
    }
    q = /* @__PURE__ */ new WeakMap(), e.ProtorunesByHeightRequest = Me;
})(AO || (Rf.protorune = AO = {}));
var I1 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.addHexPrefix = e.stripHexPrefix = void 0;
    const t = (n)=>n.slice(0, 2) == "0x" ? n.slice(2) : n;
    e.stripHexPrefix = t;
    const r = (n)=>"0x" + (0, e.stripHexPrefix)(n);
    e.addHexPrefix = r;
})(I1);
var rn = {}, wb = {};
Object.defineProperty(wb, "__esModule", {
    value: !0
});
wb.SeekBuffer = void 0;
let koe = class {
    constructor(e){
        this.buffer = e, this.seekIndex = 0;
    }
    readUInt8() {
        if (!this.isFinished()) return this.buffer.readUInt8(this.seekIndex++);
    }
    isFinished() {
        return this.seekIndex >= this.buffer.length;
    }
};
wb.SeekBuffer = koe;
var Hh = {}, Ooe = Qe && Qe.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i1 = Object.getOwnPropertyDescriptor(t, r);
    (!i1 || ("get" in i1 ? !t.__esModule : i1.writable || i1.configurable)) && (i1 = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i1);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), Ioe = Qe && Qe.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), Boe = Qe && Qe.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Ooe(t, e, r);
    return Ioe(t, e), t;
}, en = Qe && Qe.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
};
Object.defineProperty(Hh, "__esModule", {
    value: !0
});
Hh.alkanes = void 0;
const Se = Boe(y5);
var vO;
(function(e) {
    var t, r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M, N, z, K, $, ne, ee, q, U, Q, v;
    let B;
    (function(Ge) {
        Ge[Ge.NONE = 0] = "NONE", Ge[Ge.CALL = 1] = "CALL", Ge[Ge.DELEGATECALL = 2] = "DELEGATECALL", Ge[Ge.STATICCALL = 3] = "STATICCALL";
    })(B = e.AlkanesTraceCallType || (e.AlkanesTraceCallType = {}));
    let g;
    (function(Ge) {
        Ge[Ge.SUCCESS = 0] = "SUCCESS", Ge[Ge.FAILURE = 1] = "FAILURE";
    })(g = e.AlkanesTraceStatusFlag || (e.AlkanesTraceStatusFlag = {}));
    class E extends Se.Message {
        constructor(p){
            super(), t.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, t, "f")), !Array.isArray(p) && typeof p == "object" && ("lo" in p && p.lo != null && (this.lo = p.lo), "hi" in p && p.hi != null && (this.hi = p.hi));
        }
        get lo() {
            return Se.Message.getFieldWithDefault(this, 1, "0");
        }
        set lo(p) {
            Se.Message.setField(this, 1, p);
        }
        get hi() {
            return Se.Message.getFieldWithDefault(this, 2, "0");
        }
        set hi(p) {
            Se.Message.setField(this, 2, p);
        }
        static fromObject(p) {
            const A = new E({});
            return p.lo != null && (A.lo = p.lo), p.hi != null && (A.hi = p.hi), A;
        }
        toObject() {
            const p = {};
            return this.lo != null && (p.lo = this.lo), this.hi != null && (p.hi = this.hi), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.lo != "0" && A.writeUint64String(1, this.lo), this.hi != "0" && A.writeUint64String(2, this.hi), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new E();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.lo = A.readUint64String();
                    break;
                case 2:
                    V.hi = A.readUint64String();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return E.deserialize(p);
        }
    }
    t = /* @__PURE__ */ new WeakMap(), e.uint128 = E;
    class w extends Se.Message {
        constructor(p){
            super(), r.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, r, "f")), !Array.isArray(p) && typeof p == "object" && "id" in p && p.id != null && (this.id = p.id);
        }
        get id() {
            return Se.Message.getWrapperField(this, _, 1);
        }
        set id(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_id() {
            return Se.Message.getField(this, 1) != null;
        }
        static fromObject(p) {
            const A = new w({});
            return p.id != null && (A.id = _.fromObject(p.id)), A;
        }
        toObject() {
            const p = {};
            return this.id != null && (p.id = this.id.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_id && A.writeMessage(1, this.id, ()=>this.id.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new w();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.id, ()=>V.id = _.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return w.deserialize(p);
        }
    }
    r = /* @__PURE__ */ new WeakMap(), e.BytecodeRequest = w;
    class _ extends Se.Message {
        constructor(p){
            super(), n.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, n, "f")), !Array.isArray(p) && typeof p == "object" && ("block" in p && p.block != null && (this.block = p.block), "tx" in p && p.tx != null && (this.tx = p.tx));
        }
        get block() {
            return Se.Message.getWrapperField(this, E, 1);
        }
        set block(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_block() {
            return Se.Message.getField(this, 1) != null;
        }
        get tx() {
            return Se.Message.getWrapperField(this, E, 2);
        }
        set tx(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_tx() {
            return Se.Message.getField(this, 2) != null;
        }
        static fromObject(p) {
            const A = new _({});
            return p.block != null && (A.block = E.fromObject(p.block)), p.tx != null && (A.tx = E.fromObject(p.tx)), A;
        }
        toObject() {
            const p = {};
            return this.block != null && (p.block = this.block.toObject()), this.tx != null && (p.tx = this.tx.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_block && A.writeMessage(1, this.block, ()=>this.block.serialize(A)), this.has_tx && A.writeMessage(2, this.tx, ()=>this.tx.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new _();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.block, ()=>V.block = E.deserialize(A));
                    break;
                case 2:
                    A.readMessage(V.tx, ()=>V.tx = E.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return _.deserialize(p);
        }
    }
    n = /* @__PURE__ */ new WeakMap(), e.AlkaneId = _;
    class O extends Se.Message {
        constructor(p){
            super(), i1.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, i1, "f")), !Array.isArray(p) && typeof p == "object" && ("id" in p && p.id != null && (this.id = p.id), "value" in p && p.value != null && (this.value = p.value));
        }
        get id() {
            return Se.Message.getWrapperField(this, _, 1);
        }
        set id(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_id() {
            return Se.Message.getField(this, 1) != null;
        }
        get value() {
            return Se.Message.getWrapperField(this, E, 2);
        }
        set value(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_value() {
            return Se.Message.getField(this, 2) != null;
        }
        static fromObject(p) {
            const A = new O({});
            return p.id != null && (A.id = _.fromObject(p.id)), p.value != null && (A.value = E.fromObject(p.value)), A;
        }
        toObject() {
            const p = {};
            return this.id != null && (p.id = this.id.toObject()), this.value != null && (p.value = this.value.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_id && A.writeMessage(1, this.id, ()=>this.id.serialize(A)), this.has_value && A.writeMessage(2, this.value, ()=>this.value.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new O();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.id, ()=>V.id = _.deserialize(A));
                    break;
                case 2:
                    A.readMessage(V.value, ()=>V.value = E.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return O.deserialize(p);
        }
    }
    i1 = /* @__PURE__ */ new WeakMap(), e.AlkaneTransfer = O;
    class I extends Se.Message {
        constructor(p){
            super(), o.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                1
            ], en(this, o, "f")), !Array.isArray(p) && typeof p == "object" && ("alkanes" in p && p.alkanes != null && (this.alkanes = p.alkanes), "transaction" in p && p.transaction != null && (this.transaction = p.transaction), "block" in p && p.block != null && (this.block = p.block), "height" in p && p.height != null && (this.height = p.height), "txindex" in p && p.txindex != null && (this.txindex = p.txindex), "calldata" in p && p.calldata != null && (this.calldata = p.calldata), "vout" in p && p.vout != null && (this.vout = p.vout), "pointer" in p && p.pointer != null && (this.pointer = p.pointer), "refund_pointer" in p && p.refund_pointer != null && (this.refund_pointer = p.refund_pointer));
        }
        get alkanes() {
            return Se.Message.getRepeatedWrapperField(this, O, 1);
        }
        set alkanes(p) {
            Se.Message.setRepeatedWrapperField(this, 1, p);
        }
        get transaction() {
            return Se.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set transaction(p) {
            Se.Message.setField(this, 2, p);
        }
        get block() {
            return Se.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
        }
        set block(p) {
            Se.Message.setField(this, 3, p);
        }
        get height() {
            return Se.Message.getFieldWithDefault(this, 4, 0);
        }
        set height(p) {
            Se.Message.setField(this, 4, p);
        }
        get txindex() {
            return Se.Message.getFieldWithDefault(this, 6, 0);
        }
        set txindex(p) {
            Se.Message.setField(this, 6, p);
        }
        get calldata() {
            return Se.Message.getFieldWithDefault(this, 5, new Uint8Array(0));
        }
        set calldata(p) {
            Se.Message.setField(this, 5, p);
        }
        get vout() {
            return Se.Message.getFieldWithDefault(this, 7, 0);
        }
        set vout(p) {
            Se.Message.setField(this, 7, p);
        }
        get pointer() {
            return Se.Message.getFieldWithDefault(this, 8, 0);
        }
        set pointer(p) {
            Se.Message.setField(this, 8, p);
        }
        get refund_pointer() {
            return Se.Message.getFieldWithDefault(this, 9, 0);
        }
        set refund_pointer(p) {
            Se.Message.setField(this, 9, p);
        }
        static fromObject(p) {
            const A = new I({});
            return p.alkanes != null && (A.alkanes = p.alkanes.map((V)=>O.fromObject(V))), p.transaction != null && (A.transaction = p.transaction), p.block != null && (A.block = p.block), p.height != null && (A.height = p.height), p.txindex != null && (A.txindex = p.txindex), p.calldata != null && (A.calldata = p.calldata), p.vout != null && (A.vout = p.vout), p.pointer != null && (A.pointer = p.pointer), p.refund_pointer != null && (A.refund_pointer = p.refund_pointer), A;
        }
        toObject() {
            const p = {};
            return this.alkanes != null && (p.alkanes = this.alkanes.map((A)=>A.toObject())), this.transaction != null && (p.transaction = this.transaction), this.block != null && (p.block = this.block), this.height != null && (p.height = this.height), this.txindex != null && (p.txindex = this.txindex), this.calldata != null && (p.calldata = this.calldata), this.vout != null && (p.vout = this.vout), this.pointer != null && (p.pointer = this.pointer), this.refund_pointer != null && (p.refund_pointer = this.refund_pointer), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.alkanes.length && A.writeRepeatedMessage(1, this.alkanes, (V)=>V.serialize(A)), this.transaction.length && A.writeBytes(2, this.transaction), this.block.length && A.writeBytes(3, this.block), this.height != 0 && A.writeUint64(4, this.height), this.txindex != 0 && A.writeUint32(6, this.txindex), this.calldata.length && A.writeBytes(5, this.calldata), this.vout != 0 && A.writeUint32(7, this.vout), this.pointer != 0 && A.writeUint32(8, this.pointer), this.refund_pointer != 0 && A.writeUint32(9, this.refund_pointer), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new I();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.alkanes, ()=>Se.Message.addToRepeatedWrapperField(V, 1, O.deserialize(A), O));
                    break;
                case 2:
                    V.transaction = A.readBytes();
                    break;
                case 3:
                    V.block = A.readBytes();
                    break;
                case 4:
                    V.height = A.readUint64();
                    break;
                case 6:
                    V.txindex = A.readUint32();
                    break;
                case 5:
                    V.calldata = A.readBytes();
                    break;
                case 7:
                    V.vout = A.readUint32();
                    break;
                case 8:
                    V.pointer = A.readUint32();
                    break;
                case 9:
                    V.refund_pointer = A.readUint32();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return I.deserialize(p);
        }
    }
    o = /* @__PURE__ */ new WeakMap(), e.MessageContextParcel = I;
    class x extends Se.Message {
        constructor(p){
            super(), a.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, a, "f")), !Array.isArray(p) && typeof p == "object" && ("key" in p && p.key != null && (this.key = p.key), "value" in p && p.value != null && (this.value = p.value));
        }
        get key() {
            return Se.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set key(p) {
            Se.Message.setField(this, 1, p);
        }
        get value() {
            return Se.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
        }
        set value(p) {
            Se.Message.setField(this, 2, p);
        }
        static fromObject(p) {
            const A = new x({});
            return p.key != null && (A.key = p.key), p.value != null && (A.value = p.value), A;
        }
        toObject() {
            const p = {};
            return this.key != null && (p.key = this.key), this.value != null && (p.value = this.value), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.key.length && A.writeBytes(1, this.key), this.value.length && A.writeBytes(2, this.value), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new x();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.key = A.readBytes();
                    break;
                case 2:
                    V.value = A.readBytes();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return x.deserialize(p);
        }
    }
    a = /* @__PURE__ */ new WeakMap(), e.KeyValuePair = x;
    class R extends Se.Message {
        constructor(p){
            super(), s.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                1,
                2
            ], en(this, s, "f")), !Array.isArray(p) && typeof p == "object" && ("alkanes" in p && p.alkanes != null && (this.alkanes = p.alkanes), "storage" in p && p.storage != null && (this.storage = p.storage), "data" in p && p.data != null && (this.data = p.data));
        }
        get alkanes() {
            return Se.Message.getRepeatedWrapperField(this, O, 1);
        }
        set alkanes(p) {
            Se.Message.setRepeatedWrapperField(this, 1, p);
        }
        get storage() {
            return Se.Message.getRepeatedWrapperField(this, x, 2);
        }
        set storage(p) {
            Se.Message.setRepeatedWrapperField(this, 2, p);
        }
        get data() {
            return Se.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
        }
        set data(p) {
            Se.Message.setField(this, 3, p);
        }
        static fromObject(p) {
            const A = new R({});
            return p.alkanes != null && (A.alkanes = p.alkanes.map((V)=>O.fromObject(V))), p.storage != null && (A.storage = p.storage.map((V)=>x.fromObject(V))), p.data != null && (A.data = p.data), A;
        }
        toObject() {
            const p = {};
            return this.alkanes != null && (p.alkanes = this.alkanes.map((A)=>A.toObject())), this.storage != null && (p.storage = this.storage.map((A)=>A.toObject())), this.data != null && (p.data = this.data), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.alkanes.length && A.writeRepeatedMessage(1, this.alkanes, (V)=>V.serialize(A)), this.storage.length && A.writeRepeatedMessage(2, this.storage, (V)=>V.serialize(A)), this.data.length && A.writeBytes(3, this.data), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new R();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.alkanes, ()=>Se.Message.addToRepeatedWrapperField(V, 1, O.deserialize(A), O));
                    break;
                case 2:
                    A.readMessage(V.storage, ()=>Se.Message.addToRepeatedWrapperField(V, 2, x.deserialize(A), x));
                    break;
                case 3:
                    V.data = A.readBytes();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return R.deserialize(p);
        }
    }
    s = /* @__PURE__ */ new WeakMap(), e.ExtendedCallResponse = R;
    class j extends Se.Message {
        constructor(p){
            super(), c.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                3,
                5
            ], en(this, c, "f")), !Array.isArray(p) && typeof p == "object" && ("myself" in p && p.myself != null && (this.myself = p.myself), "caller" in p && p.caller != null && (this.caller = p.caller), "inputs" in p && p.inputs != null && (this.inputs = p.inputs), "vout" in p && p.vout != null && (this.vout = p.vout), "incoming_alkanes" in p && p.incoming_alkanes != null && (this.incoming_alkanes = p.incoming_alkanes));
        }
        get myself() {
            return Se.Message.getWrapperField(this, _, 1);
        }
        set myself(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_myself() {
            return Se.Message.getField(this, 1) != null;
        }
        get caller() {
            return Se.Message.getWrapperField(this, _, 2);
        }
        set caller(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_caller() {
            return Se.Message.getField(this, 2) != null;
        }
        get inputs() {
            return Se.Message.getRepeatedWrapperField(this, E, 3);
        }
        set inputs(p) {
            Se.Message.setRepeatedWrapperField(this, 3, p);
        }
        get vout() {
            return Se.Message.getFieldWithDefault(this, 4, 0);
        }
        set vout(p) {
            Se.Message.setField(this, 4, p);
        }
        get incoming_alkanes() {
            return Se.Message.getRepeatedWrapperField(this, O, 5);
        }
        set incoming_alkanes(p) {
            Se.Message.setRepeatedWrapperField(this, 5, p);
        }
        static fromObject(p) {
            const A = new j({});
            return p.myself != null && (A.myself = _.fromObject(p.myself)), p.caller != null && (A.caller = _.fromObject(p.caller)), p.inputs != null && (A.inputs = p.inputs.map((V)=>E.fromObject(V))), p.vout != null && (A.vout = p.vout), p.incoming_alkanes != null && (A.incoming_alkanes = p.incoming_alkanes.map((V)=>O.fromObject(V))), A;
        }
        toObject() {
            const p = {};
            return this.myself != null && (p.myself = this.myself.toObject()), this.caller != null && (p.caller = this.caller.toObject()), this.inputs != null && (p.inputs = this.inputs.map((A)=>A.toObject())), this.vout != null && (p.vout = this.vout), this.incoming_alkanes != null && (p.incoming_alkanes = this.incoming_alkanes.map((A)=>A.toObject())), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_myself && A.writeMessage(1, this.myself, ()=>this.myself.serialize(A)), this.has_caller && A.writeMessage(2, this.caller, ()=>this.caller.serialize(A)), this.inputs.length && A.writeRepeatedMessage(3, this.inputs, (V)=>V.serialize(A)), this.vout != 0 && A.writeUint32(4, this.vout), this.incoming_alkanes.length && A.writeRepeatedMessage(5, this.incoming_alkanes, (V)=>V.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new j();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.myself, ()=>V.myself = _.deserialize(A));
                    break;
                case 2:
                    A.readMessage(V.caller, ()=>V.caller = _.deserialize(A));
                    break;
                case 3:
                    A.readMessage(V.inputs, ()=>Se.Message.addToRepeatedWrapperField(V, 3, E.deserialize(A), E));
                    break;
                case 4:
                    V.vout = A.readUint32();
                    break;
                case 5:
                    A.readMessage(V.incoming_alkanes, ()=>Se.Message.addToRepeatedWrapperField(V, 5, O.deserialize(A), O));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return j.deserialize(p);
        }
    }
    c = /* @__PURE__ */ new WeakMap(), e.Context = j;
    class Y extends Se.Message {
        constructor(p){
            super(), l.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, l, "f")), !Array.isArray(p) && typeof p == "object" && ("inner" in p && p.inner != null && (this.inner = p.inner), "fuel" in p && p.fuel != null && (this.fuel = p.fuel));
        }
        get inner() {
            return Se.Message.getWrapperField(this, j, 1);
        }
        set inner(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_inner() {
            return Se.Message.getField(this, 1) != null;
        }
        get fuel() {
            return Se.Message.getFieldWithDefault(this, 2, 0);
        }
        set fuel(p) {
            Se.Message.setField(this, 2, p);
        }
        static fromObject(p) {
            const A = new Y({});
            return p.inner != null && (A.inner = j.fromObject(p.inner)), p.fuel != null && (A.fuel = p.fuel), A;
        }
        toObject() {
            const p = {};
            return this.inner != null && (p.inner = this.inner.toObject()), this.fuel != null && (p.fuel = this.fuel), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_inner && A.writeMessage(1, this.inner, ()=>this.inner.serialize(A)), this.fuel != 0 && A.writeUint64(2, this.fuel), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new Y();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.inner, ()=>V.inner = j.deserialize(A));
                    break;
                case 2:
                    V.fuel = A.readUint64();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return Y.deserialize(p);
        }
    }
    l = /* @__PURE__ */ new WeakMap(), e.TraceContext = Y;
    class he extends Se.Message {
        constructor(p){
            super(), u.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, u, "f")), !Array.isArray(p) && typeof p == "object" && ("call_type" in p && p.call_type != null && (this.call_type = p.call_type), "context" in p && p.context != null && (this.context = p.context));
        }
        get call_type() {
            return Se.Message.getFieldWithDefault(this, 1, B.NONE);
        }
        set call_type(p) {
            Se.Message.setField(this, 1, p);
        }
        get context() {
            return Se.Message.getWrapperField(this, Y, 2);
        }
        set context(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_context() {
            return Se.Message.getField(this, 2) != null;
        }
        static fromObject(p) {
            const A = new he({});
            return p.call_type != null && (A.call_type = p.call_type), p.context != null && (A.context = Y.fromObject(p.context)), A;
        }
        toObject() {
            const p = {};
            return this.call_type != null && (p.call_type = this.call_type), this.context != null && (p.context = this.context.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.call_type != B.NONE && A.writeEnum(1, this.call_type), this.has_context && A.writeMessage(2, this.context, ()=>this.context.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new he();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.call_type = A.readEnum();
                    break;
                case 2:
                    A.readMessage(V.context, ()=>V.context = Y.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return he.deserialize(p);
        }
    }
    u = /* @__PURE__ */ new WeakMap(), e.AlkanesEnterContext = he;
    class ue extends Se.Message {
        constructor(p){
            super(), f.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, f, "f")), !Array.isArray(p) && typeof p == "object" && ("status" in p && p.status != null && (this.status = p.status), "response" in p && p.response != null && (this.response = p.response));
        }
        get status() {
            return Se.Message.getFieldWithDefault(this, 1, g.SUCCESS);
        }
        set status(p) {
            Se.Message.setField(this, 1, p);
        }
        get response() {
            return Se.Message.getWrapperField(this, R, 2);
        }
        set response(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_response() {
            return Se.Message.getField(this, 2) != null;
        }
        static fromObject(p) {
            const A = new ue({});
            return p.status != null && (A.status = p.status), p.response != null && (A.response = R.fromObject(p.response)), A;
        }
        toObject() {
            const p = {};
            return this.status != null && (p.status = this.status), this.response != null && (p.response = this.response.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.status != g.SUCCESS && A.writeEnum(1, this.status), this.has_response && A.writeMessage(2, this.response, ()=>this.response.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new ue();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.status = A.readEnum();
                    break;
                case 2:
                    A.readMessage(V.response, ()=>V.response = R.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return ue.deserialize(p);
        }
    }
    f = /* @__PURE__ */ new WeakMap(), e.AlkanesExitContext = ue;
    class G extends Se.Message {
        constructor(p){
            super(), h.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, h, "f")), !Array.isArray(p) && typeof p == "object" && "new_alkane" in p && p.new_alkane != null && (this.new_alkane = p.new_alkane);
        }
        get new_alkane() {
            return Se.Message.getWrapperField(this, _, 1);
        }
        set new_alkane(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_new_alkane() {
            return Se.Message.getField(this, 1) != null;
        }
        static fromObject(p) {
            const A = new G({});
            return p.new_alkane != null && (A.new_alkane = _.fromObject(p.new_alkane)), A;
        }
        toObject() {
            const p = {};
            return this.new_alkane != null && (p.new_alkane = this.new_alkane.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_new_alkane && A.writeMessage(1, this.new_alkane, ()=>this.new_alkane.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new G();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.new_alkane, ()=>V.new_alkane = _.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return G.deserialize(p);
        }
    }
    h = /* @__PURE__ */ new WeakMap(), e.AlkanesCreate = G;
    class se extends Se.Message {
        constructor(p){
            super(), y.set(this, [
                [
                    1,
                    2,
                    3
                ]
            ]), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, y, "f")), !Array.isArray(p) && typeof p == "object" && ("enter_context" in p && p.enter_context != null && (this.enter_context = p.enter_context), "exit_context" in p && p.exit_context != null && (this.exit_context = p.exit_context), "create_alkane" in p && p.create_alkane != null && (this.create_alkane = p.create_alkane));
        }
        get enter_context() {
            return Se.Message.getWrapperField(this, he, 1);
        }
        set enter_context(p) {
            Se.Message.setOneofWrapperField(this, 1, en(this, y, "f")[0], p);
        }
        get has_enter_context() {
            return Se.Message.getField(this, 1) != null;
        }
        get exit_context() {
            return Se.Message.getWrapperField(this, ue, 2);
        }
        set exit_context(p) {
            Se.Message.setOneofWrapperField(this, 2, en(this, y, "f")[0], p);
        }
        get has_exit_context() {
            return Se.Message.getField(this, 2) != null;
        }
        get create_alkane() {
            return Se.Message.getWrapperField(this, G, 3);
        }
        set create_alkane(p) {
            Se.Message.setOneofWrapperField(this, 3, en(this, y, "f")[0], p);
        }
        get has_create_alkane() {
            return Se.Message.getField(this, 3) != null;
        }
        get event() {
            return ({
                0: "none",
                1: "enter_context",
                2: "exit_context",
                3: "create_alkane"
            })[Se.Message.computeOneofCase(this, [
                1,
                2,
                3
            ])];
        }
        static fromObject(p) {
            const A = new se({});
            return p.enter_context != null && (A.enter_context = he.fromObject(p.enter_context)), p.exit_context != null && (A.exit_context = ue.fromObject(p.exit_context)), p.create_alkane != null && (A.create_alkane = G.fromObject(p.create_alkane)), A;
        }
        toObject() {
            const p = {};
            return this.enter_context != null && (p.enter_context = this.enter_context.toObject()), this.exit_context != null && (p.exit_context = this.exit_context.toObject()), this.create_alkane != null && (p.create_alkane = this.create_alkane.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_enter_context && A.writeMessage(1, this.enter_context, ()=>this.enter_context.serialize(A)), this.has_exit_context && A.writeMessage(2, this.exit_context, ()=>this.exit_context.serialize(A)), this.has_create_alkane && A.writeMessage(3, this.create_alkane, ()=>this.create_alkane.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new se();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.enter_context, ()=>V.enter_context = he.deserialize(A));
                    break;
                case 2:
                    A.readMessage(V.exit_context, ()=>V.exit_context = ue.deserialize(A));
                    break;
                case 3:
                    A.readMessage(V.create_alkane, ()=>V.create_alkane = G.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return se.deserialize(p);
        }
    }
    y = /* @__PURE__ */ new WeakMap(), e.AlkanesTraceEvent = se;
    class Z extends Se.Message {
        constructor(p){
            super(), S.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, S, "f")), !Array.isArray(p) && typeof p == "object" && ("traces" in p && p.traces != null && (this.traces = p.traces), "outpoint" in p && p.outpoint != null && (this.outpoint = p.outpoint), "txindex" in p && p.txindex != null && (this.txindex = p.txindex));
        }
        get traces() {
            return Se.Message.getWrapperField(this, pe, 1);
        }
        set traces(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_traces() {
            return Se.Message.getField(this, 1) != null;
        }
        get outpoint() {
            return Se.Message.getWrapperField(this, J, 2);
        }
        set outpoint(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_outpoint() {
            return Se.Message.getField(this, 2) != null;
        }
        get txindex() {
            return Se.Message.getFieldWithDefault(this, 3, 0);
        }
        set txindex(p) {
            Se.Message.setField(this, 3, p);
        }
        static fromObject(p) {
            const A = new Z({});
            return p.traces != null && (A.traces = pe.fromObject(p.traces)), p.outpoint != null && (A.outpoint = J.fromObject(p.outpoint)), p.txindex != null && (A.txindex = p.txindex), A;
        }
        toObject() {
            const p = {};
            return this.traces != null && (p.traces = this.traces.toObject()), this.outpoint != null && (p.outpoint = this.outpoint.toObject()), this.txindex != null && (p.txindex = this.txindex), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_traces && A.writeMessage(1, this.traces, ()=>this.traces.serialize(A)), this.has_outpoint && A.writeMessage(2, this.outpoint, ()=>this.outpoint.serialize(A)), this.txindex != 0 && A.writeUint64(3, this.txindex), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new Z();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.traces, ()=>V.traces = pe.deserialize(A));
                    break;
                case 2:
                    A.readMessage(V.outpoint, ()=>V.outpoint = J.deserialize(A));
                    break;
                case 3:
                    V.txindex = A.readUint64();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return Z.deserialize(p);
        }
    }
    S = /* @__PURE__ */ new WeakMap(), e.AlkanesBlockEvent = Z;
    class ie extends Se.Message {
        constructor(p){
            super(), k.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                1
            ], en(this, k, "f")), !Array.isArray(p) && typeof p == "object" && "events" in p && p.events != null && (this.events = p.events);
        }
        get events() {
            return Se.Message.getRepeatedWrapperField(this, Z, 1);
        }
        set events(p) {
            Se.Message.setRepeatedWrapperField(this, 1, p);
        }
        static fromObject(p) {
            const A = new ie({});
            return p.events != null && (A.events = p.events.map((V)=>Z.fromObject(V))), A;
        }
        toObject() {
            const p = {};
            return this.events != null && (p.events = this.events.map((A)=>A.toObject())), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.events.length && A.writeRepeatedMessage(1, this.events, (V)=>V.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new ie();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.events, ()=>Se.Message.addToRepeatedWrapperField(V, 1, Z.deserialize(A), Z));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return ie.deserialize(p);
        }
    }
    k = /* @__PURE__ */ new WeakMap(), e.AlkanesBlockTraceEvent = ie;
    class pe extends Se.Message {
        constructor(p){
            super(), P.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                1
            ], en(this, P, "f")), !Array.isArray(p) && typeof p == "object" && "events" in p && p.events != null && (this.events = p.events);
        }
        get events() {
            return Se.Message.getRepeatedWrapperField(this, se, 1);
        }
        set events(p) {
            Se.Message.setRepeatedWrapperField(this, 1, p);
        }
        static fromObject(p) {
            const A = new pe({});
            return p.events != null && (A.events = p.events.map((V)=>se.fromObject(V))), A;
        }
        toObject() {
            const p = {};
            return this.events != null && (p.events = this.events.map((A)=>A.toObject())), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.events.length && A.writeRepeatedMessage(1, this.events, (V)=>V.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new pe();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.events, ()=>Se.Message.addToRepeatedWrapperField(V, 1, se.deserialize(A), se));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return pe.deserialize(p);
        }
    }
    P = /* @__PURE__ */ new WeakMap(), e.AlkanesTrace = pe;
    class ve extends Se.Message {
        constructor(p){
            super(), M.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, M, "f")), !Array.isArray(p) && typeof p == "object" && ("execution" in p && p.execution != null && (this.execution = p.execution), "gas_used" in p && p.gas_used != null && (this.gas_used = p.gas_used), "error" in p && p.error != null && (this.error = p.error));
        }
        get execution() {
            return Se.Message.getWrapperField(this, R, 1);
        }
        set execution(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_execution() {
            return Se.Message.getField(this, 1) != null;
        }
        get gas_used() {
            return Se.Message.getFieldWithDefault(this, 2, 0);
        }
        set gas_used(p) {
            Se.Message.setField(this, 2, p);
        }
        get error() {
            return Se.Message.getFieldWithDefault(this, 3, "");
        }
        set error(p) {
            Se.Message.setField(this, 3, p);
        }
        static fromObject(p) {
            const A = new ve({});
            return p.execution != null && (A.execution = R.fromObject(p.execution)), p.gas_used != null && (A.gas_used = p.gas_used), p.error != null && (A.error = p.error), A;
        }
        toObject() {
            const p = {};
            return this.execution != null && (p.execution = this.execution.toObject()), this.gas_used != null && (p.gas_used = this.gas_used), this.error != null && (p.error = this.error), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_execution && A.writeMessage(1, this.execution, ()=>this.execution.serialize(A)), this.gas_used != 0 && A.writeUint64(2, this.gas_used), this.error.length && A.writeString(3, this.error), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new ve();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.execution, ()=>V.execution = R.deserialize(A));
                    break;
                case 2:
                    V.gas_used = A.readUint64();
                    break;
                case 3:
                    V.error = A.readString();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return ve.deserialize(p);
        }
    }
    M = /* @__PURE__ */ new WeakMap(), e.SimulateResponse = ve;
    class Ie extends Se.Message {
        constructor(p){
            super(), N.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, N, "f")), !Array.isArray(p) && typeof p == "object" && "id" in p && p.id != null && (this.id = p.id);
        }
        get id() {
            return Se.Message.getWrapperField(this, _, 1);
        }
        set id(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_id() {
            return Se.Message.getField(this, 1) != null;
        }
        static fromObject(p) {
            const A = new Ie({});
            return p.id != null && (A.id = _.fromObject(p.id)), A;
        }
        toObject() {
            const p = {};
            return this.id != null && (p.id = this.id.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_id && A.writeMessage(1, this.id, ()=>this.id.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new Ie();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.id, ()=>V.id = _.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return Ie.deserialize(p);
        }
    }
    N = /* @__PURE__ */ new WeakMap(), e.AlkaneInventoryRequest = Ie;
    class Me extends Se.Message {
        constructor(p){
            super(), z.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                1
            ], en(this, z, "f")), !Array.isArray(p) && typeof p == "object" && "alkanes" in p && p.alkanes != null && (this.alkanes = p.alkanes);
        }
        get alkanes() {
            return Se.Message.getRepeatedWrapperField(this, O, 1);
        }
        set alkanes(p) {
            Se.Message.setRepeatedWrapperField(this, 1, p);
        }
        static fromObject(p) {
            const A = new Me({});
            return p.alkanes != null && (A.alkanes = p.alkanes.map((V)=>O.fromObject(V))), A;
        }
        toObject() {
            const p = {};
            return this.alkanes != null && (p.alkanes = this.alkanes.map((A)=>A.toObject())), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.alkanes.length && A.writeRepeatedMessage(1, this.alkanes, (V)=>V.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new Me();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.alkanes, ()=>Se.Message.addToRepeatedWrapperField(V, 1, O.deserialize(A), O));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return Me.deserialize(p);
        }
    }
    z = /* @__PURE__ */ new WeakMap(), e.AlkaneInventoryResponse = Me;
    class Re extends Se.Message {
        constructor(p){
            super(), K.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, K, "f")), !Array.isArray(p) && typeof p == "object" && "id" in p && p.id != null && (this.id = p.id);
        }
        get id() {
            return Se.Message.getWrapperField(this, _, 1);
        }
        set id(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_id() {
            return Se.Message.getField(this, 1) != null;
        }
        static fromObject(p) {
            const A = new Re({});
            return p.id != null && (A.id = _.fromObject(p.id)), A;
        }
        toObject() {
            const p = {};
            return this.id != null && (p.id = this.id.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_id && A.writeMessage(1, this.id, ()=>this.id.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new Re();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.id, ()=>V.id = _.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return Re.deserialize(p);
        }
    }
    K = /* @__PURE__ */ new WeakMap(), e.AlkaneIdToOutpointRequest = Re;
    class C extends Se.Message {
        constructor(p){
            super(), $.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, $, "f")), !Array.isArray(p) && typeof p == "object" && ("txid" in p && p.txid != null && (this.txid = p.txid), "vout" in p && p.vout != null && (this.vout = p.vout));
        }
        get txid() {
            return Se.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(p) {
            Se.Message.setField(this, 1, p);
        }
        get vout() {
            return Se.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(p) {
            Se.Message.setField(this, 2, p);
        }
        static fromObject(p) {
            const A = new C({});
            return p.txid != null && (A.txid = p.txid), p.vout != null && (A.vout = p.vout), A;
        }
        toObject() {
            const p = {};
            return this.txid != null && (p.txid = this.txid), this.vout != null && (p.vout = this.vout), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.txid.length && A.writeBytes(1, this.txid), this.vout != 0 && A.writeUint32(2, this.vout), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new C();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.txid = A.readBytes();
                    break;
                case 2:
                    V.vout = A.readUint32();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return C.deserialize(p);
        }
    }
    $ = /* @__PURE__ */ new WeakMap(), e.AlkaneIdToOutpointResponse = C;
    class J extends Se.Message {
        constructor(p){
            super(), ne.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, ne, "f")), !Array.isArray(p) && typeof p == "object" && ("txid" in p && p.txid != null && (this.txid = p.txid), "vout" in p && p.vout != null && (this.vout = p.vout));
        }
        get txid() {
            return Se.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set txid(p) {
            Se.Message.setField(this, 1, p);
        }
        get vout() {
            return Se.Message.getFieldWithDefault(this, 2, 0);
        }
        set vout(p) {
            Se.Message.setField(this, 2, p);
        }
        static fromObject(p) {
            const A = new J({});
            return p.txid != null && (A.txid = p.txid), p.vout != null && (A.vout = p.vout), A;
        }
        toObject() {
            const p = {};
            return this.txid != null && (p.txid = this.txid), this.vout != null && (p.vout = this.vout), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.txid.length && A.writeBytes(1, this.txid), this.vout != 0 && A.writeUint32(2, this.vout), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new J();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.txid = A.readBytes();
                    break;
                case 2:
                    V.vout = A.readUint32();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return J.deserialize(p);
        }
    }
    ne = /* @__PURE__ */ new WeakMap(), e.Outpoint = J;
    class me extends Se.Message {
        constructor(p){
            super(), ee.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, ee, "f")), !Array.isArray(p) && typeof p == "object" && ("outpoint" in p && p.outpoint != null && (this.outpoint = p.outpoint), "trace" in p && p.trace != null && (this.trace = p.trace));
        }
        get outpoint() {
            return Se.Message.getWrapperField(this, J, 1);
        }
        set outpoint(p) {
            Se.Message.setWrapperField(this, 1, p);
        }
        get has_outpoint() {
            return Se.Message.getField(this, 1) != null;
        }
        get trace() {
            return Se.Message.getWrapperField(this, pe, 2);
        }
        set trace(p) {
            Se.Message.setWrapperField(this, 2, p);
        }
        get has_trace() {
            return Se.Message.getField(this, 2) != null;
        }
        static fromObject(p) {
            const A = new me({});
            return p.outpoint != null && (A.outpoint = J.fromObject(p.outpoint)), p.trace != null && (A.trace = pe.fromObject(p.trace)), A;
        }
        toObject() {
            const p = {};
            return this.outpoint != null && (p.outpoint = this.outpoint.toObject()), this.trace != null && (p.trace = this.trace.toObject()), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.has_outpoint && A.writeMessage(1, this.outpoint, ()=>this.outpoint.serialize(A)), this.has_trace && A.writeMessage(2, this.trace, ()=>this.trace.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new me();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.outpoint, ()=>V.outpoint = J.deserialize(A));
                    break;
                case 2:
                    A.readMessage(V.trace, ()=>V.trace = pe.deserialize(A));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return me.deserialize(p);
        }
    }
    ee = /* @__PURE__ */ new WeakMap(), e.Trace = me;
    class je extends Se.Message {
        constructor(p){
            super(), q.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, q, "f")), !Array.isArray(p) && typeof p == "object" && "block" in p && p.block != null && (this.block = p.block);
        }
        get block() {
            return Se.Message.getFieldWithDefault(this, 1, 0);
        }
        set block(p) {
            Se.Message.setField(this, 1, p);
        }
        static fromObject(p) {
            const A = new je({});
            return p.block != null && (A.block = p.block), A;
        }
        toObject() {
            const p = {};
            return this.block != null && (p.block = this.block), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.block != 0 && A.writeUint64(1, this.block), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new je();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.block = A.readUint64();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return je.deserialize(p);
        }
    }
    q = /* @__PURE__ */ new WeakMap(), e.TraceBlockRequest = je;
    class Ve extends Se.Message {
        constructor(p){
            super(), U.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, U, "f")), !Array.isArray(p) && typeof p == "object" && "height" in p && p.height != null && (this.height = p.height);
        }
        get height() {
            return Se.Message.getFieldWithDefault(this, 1, 0);
        }
        set height(p) {
            Se.Message.setField(this, 1, p);
        }
        static fromObject(p) {
            const A = new Ve({});
            return p.height != null && (A.height = p.height), A;
        }
        toObject() {
            const p = {};
            return this.height != null && (p.height = this.height), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.height != 0 && A.writeUint32(1, this.height), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new Ve();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.height = A.readUint32();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return Ve.deserialize(p);
        }
    }
    U = /* @__PURE__ */ new WeakMap(), e.BlockRequest = Ve;
    class nt extends Se.Message {
        constructor(p){
            super(), Q.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [], en(this, Q, "f")), !Array.isArray(p) && typeof p == "object" && ("block" in p && p.block != null && (this.block = p.block), "height" in p && p.height != null && (this.height = p.height));
        }
        get block() {
            return Se.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
        }
        set block(p) {
            Se.Message.setField(this, 1, p);
        }
        get height() {
            return Se.Message.getFieldWithDefault(this, 2, 0);
        }
        set height(p) {
            Se.Message.setField(this, 2, p);
        }
        static fromObject(p) {
            const A = new nt({});
            return p.block != null && (A.block = p.block), p.height != null && (A.height = p.height), A;
        }
        toObject() {
            const p = {};
            return this.block != null && (p.block = this.block), this.height != null && (p.height = this.height), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.block.length && A.writeBytes(1, this.block), this.height != 0 && A.writeUint32(2, this.height), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new nt();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    V.block = A.readBytes();
                    break;
                case 2:
                    V.height = A.readUint32();
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return nt.deserialize(p);
        }
    }
    Q = /* @__PURE__ */ new WeakMap(), e.BlockResponse = nt;
    class We extends Se.Message {
        constructor(p){
            super(), v.set(this, []), Se.Message.initialize(this, Array.isArray(p) ? p : [], 0, -1, [
                1
            ], en(this, v, "f")), !Array.isArray(p) && typeof p == "object" && "traces" in p && p.traces != null && (this.traces = p.traces);
        }
        get traces() {
            return Se.Message.getRepeatedWrapperField(this, me, 1);
        }
        set traces(p) {
            Se.Message.setRepeatedWrapperField(this, 1, p);
        }
        static fromObject(p) {
            const A = new We({});
            return p.traces != null && (A.traces = p.traces.map((V)=>me.fromObject(V))), A;
        }
        toObject() {
            const p = {};
            return this.traces != null && (p.traces = this.traces.map((A)=>A.toObject())), p;
        }
        serialize(p) {
            const A = p || new Se.BinaryWriter();
            if (this.traces.length && A.writeRepeatedMessage(1, this.traces, (V)=>V.serialize(A)), !p) return A.getResultBuffer();
        }
        static deserialize(p) {
            const A = p instanceof Se.BinaryReader ? p : new Se.BinaryReader(p), V = new We();
            for(; A.nextField() && !A.isEndGroup();)switch(A.getFieldNumber()){
                case 1:
                    A.readMessage(V.traces, ()=>Se.Message.addToRepeatedWrapperField(V, 1, me.deserialize(A), me));
                    break;
                default:
                    A.skipField();
            }
            return V;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(p) {
            return We.deserialize(p);
        }
    }
    v = /* @__PURE__ */ new WeakMap(), e.TraceBlockResponse = We;
})(vO || (Hh.alkanes = vO = {}));
Object.defineProperty(rn, "__esModule", {
    value: !0
});
rn.fromBuffer = rn.toBuffer = void 0;
rn.toProtobufAlkaneTransfer = Poe;
rn.unpack = Coe;
rn.leftPad15 = hN;
rn.leftPadByte = m5;
rn.rightPadByte = Moe;
rn.leftPad16 = b5;
rn.leftPad8 = $8;
rn.toUint128 = Wy;
rn.fromUint128 = Noe;
rn.toHexString = Z8;
rn.u128ToBuffer = pN;
rn.encodeVarInt = gN;
rn.encipher = Roe;
rn.decipher = yN;
rn.decodeVarInt = mN;
rn.tryDecodeVarInt = bN;
rn.pack = joe;
rn.decipherPacked = Foe;
const Toe = wb, Q8 = Hh;
function Poe(e) {
    return new Q8.alkanes.AlkaneTransfer({
        id: new Q8.alkanes.AlkaneId({
            block: Wy(e.id.block),
            tx: Wy(e.id.tx)
        }),
        value: Wy(e.value)
    });
}
function Coe(e) {
    return Array.from(e).reduce((t, r, n)=>(n % 15 === 0 && t.push([]), t[t.length - 1].push(r), t), []).map((t)=>BigInt("0x" + Ke.from(t.reverse()).toString("hex")));
}
function hN(e) {
    if (e.length > 30) throw Error("varint in encoding cannot exceed 15 bytes");
    return "0".repeat(30 - e.length) + e;
}
function m5(e) {
    return e.length % 2 ? "0" + e : e;
}
function Moe(e) {
    return e.length % 2 ? e + "0" : e;
}
function b5(e) {
    if (e.length > 16) throw Error("varint in encoding cannot exceed 15 bytes");
    return "0".repeat(32 - e.length) + e;
}
function $8(e) {
    return "0".repeat(16 - e.length) + e;
}
function Wy(e) {
    let t = b5(e.toString(16));
    return new Q8.alkanes.uint128({
        hi: BigInt("0x" + t.substr(0, 16)).toString(10),
        lo: BigInt("0x" + t.substr(16, 32)).toString(10)
    });
}
function Noe(e) {
    return pN(e);
}
function Z8(e) {
    return BigInt(e).toString(16);
}
function pN(e) {
    return BigInt("0x" + Ke.from($8(Z8(e.hi)) + $8(Z8(e.lo)), "hex").toString("hex"));
}
function gN(e) {
    const t = [];
    for(; e >> 7n > 0n;)t.push(Number(e & 0xffn) | 128), e = BigInt(e >> 7n);
    return t.push(Number(e & 0xffn)), Ke.from(t);
}
function Roe(e) {
    return Ke.concat(e.map((t)=>gN(t)));
}
const Uoe = (e)=>Ke.from(Array.from(Ke.from(b5(e.toString(16)), "hex")).reverse());
rn.toBuffer = Uoe;
const Doe = (e)=>BigInt("0x" + Ke.from(Array.from(e).reverse()).toString("hex"));
rn.fromBuffer = Doe;
function yN(e) {
    let t = new Toe.SeekBuffer(e), r = null;
    const n = [];
    for(; (r = mN(t)) !== BigInt(-1);)n.push(r);
    return n;
}
function mN(e) {
    try {
        return bN(e);
    } catch  {
        return BigInt(-1);
    }
}
function bN(e) {
    let t = BigInt(0);
    for(let r = 0; r <= 18; r++){
        const n = e.readUInt8();
        if (n === void 0) throw new Error("Unterminated");
        const i1 = BigInt(n) & 127n;
        if (r === 18 && (i1 & 124n) !== 0n) throw new Error("Overflow");
        if (t = BigInt(t | i1 << BigInt(7 * r)), !(n & 128)) return t;
    }
    throw new Error("Overlong");
}
function joe(e) {
    return Ke.concat(e.map((t)=>Ke.from(hN(Ke.from(Array.from(Ke.from(m5(t.toString(16)), "hex")).reverse()).toString("hex")), "hex")));
}
function Foe(e) {
    return yN(Ke.concat(e.map((t)=>Ke.from(Array.from(Ke.from(m5(t.toString(16)), "hex")).reverse()))));
}
Object.defineProperty(No, "__esModule", {
    value: !0
});
No.encodeOutpointInput = Woe;
No.decodeRunes = wN;
No.decodeOutpointViewBase = AN;
No.decodeOutpointView = Goe;
No.decodeRunesResponse = Qoe;
No.encodeBlockHeightInput = $oe;
No.encodeProtorunesByHeightInput = Zoe;
No.encodeAlkanesIdToOutpointInput = Xoe;
No.decodeAlkanesIdToOutpointResponse = Yoe;
const zoe = Rf, w5 = I1, Vd = rn, { OutpointResponse: Loe, Outpoint: Hoe, BalanceSheet: B8e, RunesResponse: Koe, ProtorunesByHeightRequest: qoe, RunesByHeightRequest: Voe } = zoe.protorune, X8 = Hh;
function Woe(e, t) {
    const r = {
        txid: Ke.from(e, "hex"),
        vout: t
    };
    return "0x" + Ke.from(new Hoe(r).serializeBinary()).toString("hex");
}
function wN(e) {
    return e ? e.entries.map((t)=>{
        const r = t.balance, n = t.rune, i1 = "", o = n.spacers.toString(2);
        let a = n.name, s = a;
        const c = n.symbol;
        let l = 0;
        return o.split("").reverse().map((u, f)=>{
            u == "1" && (s = `${s.slice(0, f + 1 + l)}${i1}${s.slice(f + 1 + l)}`, l++);
        }), {
            rune: {
                id: {
                    block: (0, Vd.fromUint128)(n.runeId.height),
                    tx: (0, Vd.fromUint128)(n.runeId.txindex)
                },
                name: a,
                spacedName: s,
                divisibility: n.divisibility,
                spacers: n.spacers,
                symbol: c
            },
            balance: (0, Vd.fromUint128)(r)
        };
    }) : [];
}
function AN(e) {
    return {
        runes: wN(e.balances),
        outpoint: {
            txid: Ke.from(e.outpoint.txid).toString("hex"),
            vout: e.outpoint.vout
        },
        output: e.output ? {
            value: e.output.value,
            script: Ke.from(e.output.script).toString("hex")
        } : {
            value: "",
            script: ""
        },
        height: e.height,
        txindex: e.txindex
    };
}
function Goe(e) {
    const t = Uint8Array.from(Ke.from((0, w5.stripHexPrefix)(e), "hex")), r = Loe.deserializeBinary(t);
    return AN(r);
}
function Qoe(e) {
    if (!e || e === "0x") return {
        runes: []
    };
    const t = Ke.from((0, w5.stripHexPrefix)(e), "hex");
    return t.length === 0 ? {
        runes: []
    } : {
        runes: Koe.deserializeBinary(t).runes.map((r)=>{
            var n, i1;
            return {
                runeId: `${((n = r.runeId) == null ? void 0 : n.height) || 0}:${((i1 = r.runeId) == null ? void 0 : i1.txindex) || 0}`,
                name: Ke.from(r.name).toString("utf8"),
                divisibility: r.divisibility,
                spacers: r.spacers,
                symbol: r.symbol
            };
        })
    };
}
function $oe(e) {
    const t = {
        height: e
    };
    return "0x" + Ke.from(new Voe(t).serializeBinary()).toString("hex");
}
function Zoe(e, t) {
    const r = {
        height: e,
        protocol_tag: (0, Vd.toUint128)(t)
    };
    return "0x" + Ke.from(new qoe(r).serializeBinary()).toString("hex");
}
function Xoe(e, t) {
    const r = new X8.alkanes.AlkaneId({
        block: (0, Vd.toUint128)(e),
        tx: (0, Vd.toUint128)(t)
    });
    return "0x" + Ke.from(new X8.alkanes.AlkaneIdToOutpointRequest({
        id: r
    }).serializeBinary()).toString("hex");
}
function Yoe(e) {
    if (!e || e === "0x") return {
        outpoint: {}
    };
    const t = Ke.from((0, w5.stripHexPrefix)(e), "hex");
    if (t.length === 0) return {
        outpoint: {}
    };
    const r = X8.alkanes.AlkaneIdToOutpointResponse.deserializeBinary(t);
    return {
        outpoint: {
            txid: Ke.from(r.txid).toString("hex"),
            vout: r.vout
        }
    };
}
Object.defineProperty(tu, "__esModule", {
    value: !0
});
tu.encodeProtorunesWalletInput = uae;
tu.encodeTransactionId = cae;
tu.encodeWalletInput = lae;
tu.decodeTransactionResult = fae;
tu.decodeWalletOutput = dae;
tu.encodeRuntimeInput = hae;
tu.decodeRuntimeOutput = pae;
const vN = No, Joe = Rf, eae = No, E0 = I1, tae = rn, { ProtorunesWalletRequest: rae, TransactionRecord: nae, WalletRequest: iae, WalletResponse: oae, RuntimeInput: aae, Runtime: sae, Outpoint: T8e } = Joe.protorune;
function EN(e) {
    return (0, tae.toUint128)(e);
}
function uae(e, t) {
    const r = {
        wallet: Uint8Array.from(Ke.from(e, "utf-8")),
        protocol_tag: EN(t)
    };
    return "0x" + Ke.from(new rae(r).serializeBinary()).toString("hex");
}
function cae(e) {
    return Ke.from((0, E0.stripHexPrefix)(e), "hex");
}
function lae(e) {
    const t = {
        wallet: Uint8Array.from(Ke.from(e, "utf-8"))
    };
    return "0x" + Ke.from(new iae(t).serializeBinary()).toString("hex");
}
function fae(e) {
    const { transaction: t, height: r } = nae.deserializeBinary(Uint8Array.from(Ke.from((0, E0.stripHexPrefix)(e), "hex")));
    return {
        transaction: (0, E0.addHexPrefix)(Ke.from(t).toString("hex")),
        height: Number(r)
    };
}
function dae(e) {
    const t = oae.deserializeBinary(Uint8Array.from(Ke.from((0, E0.stripHexPrefix)(e), "hex")));
    return {
        outpoints: t.outpoints.map((r)=>(0, eae.decodeOutpointViewBase)(r)),
        balanceSheet: (0, vN.decodeRunes)(t.balances)
    };
}
function hae(e) {
    const t = {
        protocolTag: EN(e)
    };
    return "0x" + Ke.from(new aae(t).serializeBinary()).toString("hex");
}
function pae(e) {
    const t = sae.deserializeBinary(Uint8Array.from(Ke.from((0, E0.stripHexPrefix)(e), "hex")));
    return {
        balances: (0, vN.decodeRunes)(t.balances)
    };
}
var Rn = {};
Object.defineProperty(Rn, "__esModule", {
    value: !0
});
Rn.formatKey = xN;
Rn.toAlkaneTransfer = Ab;
Rn.toBytecodeRequest = _N;
Rn.encodeBlockRequest = yae;
Rn.encodeGetBytecodeRequest = mae;
Rn.fromCallType = kN;
Rn.toAlkaneId = S0;
Rn.toStorageSlot = A5;
Rn.toContext = ON;
Rn.toResponse = IN;
Rn.toEvent = v5;
Rn.encodeTraceRequest = bae;
Rn.encodeTraceBlockRequest = wae;
Rn.decodeBlockResponse = Aae;
Rn.decodeTraceBlockResponse = vae;
Rn.decodeTraceResponse = Eae;
Rn.encodeSimulateRequest = Sae;
Rn.decodeSimulateResponse = xae;
Rn.outpointResponseToObject = BN;
Rn.decodeOutpointResponse = _ae;
Rn.decodeMetaResponse = kae;
const as = rn, Ws = Hh, Jc = I1, SN = Rf, { SimulateResponse: P8e, MessageContextParcel: C8e, AlkanesTrace: M8e } = Ws.alkanes, gae = 47;
function xN(e) {
    return Array.from(e).reduce((t, r)=>r === gae ? (t.push([]), t) : (t[t.length - 1].push(r), t), [
        []
    ]).map((t)=>{
        const r = Ke.from(t).toString("utf8");
        return /^\w+$/.test(r) ? r : Ke.from(t).toString("hex");
    }).join("/");
}
function Ab(e) {
    return {
        id: S0(e.id),
        value: (0, as.fromUint128)(e.value)
    };
}
function _N({ block: e, tx: t }) {
    return new Ws.alkanes.BytecodeRequest({
        id: new Ws.alkanes.AlkaneId({
            block: (0, as.toUint128)(e),
            tx: (0, as.toUint128)(t)
        })
    });
}
function yae({ height: e }) {
    return new Ws.alkanes.BlockRequest({
        height: e
    });
}
function mae(e) {
    const t = _N(e);
    return (0, Jc.addHexPrefix)(Ke.from(t.serializeBinary()).toString("hex"));
}
function kN(e) {
    switch(e){
        case 1:
            return "call";
        case 2:
            return "delegatecall";
        case 3:
            return "staticcall";
        default:
            return "unknowncall";
    }
}
function S0(e) {
    return {
        block: typeof e.block == "bigint" ? e.block : (0, as.fromUint128)(e.block),
        tx: typeof e.tx == "bigint" ? e.tx : (0, as.fromUint128)(e.tx)
    };
}
function A5(e) {
    return {
        key: xN(e.key),
        value: "0x" + Ke.from(e.value).toString("hex")
    };
}
function ON(e) {
    return {
        myself: S0(e.myself),
        caller: S0(e.caller),
        inputs: e.inputs.map((t)=>(0, as.fromUint128)(t)),
        incomingAlkanes: e.incoming_alkanes.map((t)=>Ab(t)),
        vout: e.vout
    };
}
function IN(e) {
    return {
        alkanes: e.alkanes.map((t)=>Ab(t)),
        data: "0x" + Ke.from(e.data).toString("hex"),
        storage: e.storage.map((t)=>A5(t))
    };
}
function v5(e) {
    let t = Object.keys(e)[0];
    switch(t){
        case "create_alkane":
            return {
                event: "create",
                data: S0(e[t].new_alkane)
            };
        case "enter_context":
            return {
                event: "invoke",
                data: {
                    type: kN(e[t].call_type),
                    context: ON(e[t].context.inner),
                    fuel: e[t].context.fuel
                }
            };
        case "exit_context":
            return {
                event: "return",
                data: {
                    status: e[t].status == 0 ? "success" : "revert",
                    response: IN(e[t].response)
                }
            };
    }
}
function bae({ txid: e, vout: t }) {
    const r = {
        txid: Ke.from((0, Jc.stripHexPrefix)(e), "hex"),
        vout: t
    };
    return "0x" + Ke.from(new SN.protorune.Outpoint(r).serializeBinary()).toString("hex");
}
function wae({ block: e }) {
    const t = {
        block: Number(e)
    };
    return "0x" + Ke.from(new Ws.alkanes.TraceBlockRequest(t).serializeBinary()).toString("hex");
}
function Aae(e) {
    return (0, Jc.addHexPrefix)(Ke.from(Ws.alkanes.BlockResponse.deserializeBinary(Ke.from((0, Jc.stripHexPrefix)(e), "hex")).block).toString("hex"));
}
function vae(e) {
    return Ws.alkanes.TraceBlockResponse.deserializeBinary(Ke.from((0, Jc.stripHexPrefix)(e), "hex")).traces.map(({ outpoint: t, trace: r })=>({
            outpoint: {
                txid: Ke.from(t.txid).toString("hex"),
                vout: t.vout
            },
            trace: r.events.map((n)=>v5(n))
        }));
}
function Eae(e) {
    return Ws.alkanes.AlkanesTrace.deserializeBinary(Ke.from((0, Jc.stripHexPrefix)(e), "hex")).toObject().events.map((t)=>v5(t));
}
function Sae({ alkanes: e, transaction: t, height: r, block: n, inputs: i1, target: o, txindex: a, vout: s, pointer: c, refundPointer: l }) {
    const u = {
        alkanes: e.map((f)=>(0, as.toProtobufAlkaneTransfer)(f)),
        transaction: Uint8Array.from(Ke.from(t, "hex")),
        height: Number(r),
        txindex: a,
        calldata: (0, as.encipher)([
            o.block,
            o.tx,
            ...i1
        ]),
        block: Uint8Array.from(Ke.from(n, "hex")),
        vout: s,
        pointer: c,
        refund_pointer: l
    };
    return "0x" + Ke.from(new Ws.alkanes.MessageContextParcel(u).serializeBinary()).toString("hex");
}
class Om {
    constructor(){}
}
Om.SUCCESS = 0;
Om.REVERT = 1;
function xae(e) {
    const t = Ws.alkanes.SimulateResponse.deserializeBinary(Ke.from((0, Jc.stripHexPrefix)(e), "hex"));
    return t.error || !t.execution ? {
        status: Om.REVERT,
        gasUsed: 0,
        execution: {
            alkanes: [],
            storage: [],
            data: "0x",
            error: t.error
        }
    } : {
        status: Om.SUCCESS,
        gasUsed: t.gas_used,
        execution: {
            alkanes: t.execution.alkanes.map(Ab),
            storage: t.execution.storage.map(A5),
            error: null,
            data: "0x" + Ke.from(t.execution.data).toString("hex")
        }
    };
}
function BN(e) {
    return e.map((t)=>({
            token: {
                id: {
                    block: (0, as.fromUint128)(t.rune.runeId.height),
                    tx: (0, as.fromUint128)(t.rune.runeId.txindex)
                },
                name: t.rune.name,
                symbol: t.rune.symbol
            },
            value: (0, as.fromUint128)(t.balance)
        }));
}
function _ae(e) {
    return BN(((SN.protorune.OutpointResponse.deserializeBinary(Ke.from(e.substr(2), "hex")).toObject() || {}).balances || {}).entries || []);
}
function kae(e) {
    if (!e || e === "0x") return null;
    const t = Ke.from((0, Jc.stripHexPrefix)(e), "hex");
    try {
        return JSON.parse(t.toString("utf8"));
    } catch (r) {
        return console.error("Failed to parse meta response as JSON:", r), null;
    }
}
var vb = {}, Kh = {}, Im = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */ Im.exports;
(function(e, t) {
    (function(r) {
        var n = t && !t.nodeType && t, i1 = e && !e.nodeType && e, o = typeof Qe == "object" && Qe;
        (o.global === o || o.window === o || o.self === o) && (r = o);
        var a, s = 2147483647, c = 36, l = 1, u = 26, f = 38, h = 700, y = 72, S = 128, k = "-", P = /^xn--/, M = /[^\x20-\x7E]/, N = /[\x2E\u3002\uFF0E\uFF61]/g, z = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, K = c - l, $ = Math.floor, ne = String.fromCharCode, ee;
        function q(R) {
            throw new RangeError(z[R]);
        }
        function U(R, j) {
            for(var Y = R.length, he = []; Y--;)he[Y] = j(R[Y]);
            return he;
        }
        function Q(R, j) {
            var Y = R.split("@"), he = "";
            Y.length > 1 && (he = Y[0] + "@", R = Y[1]), R = R.replace(N, ".");
            var ue = R.split("."), G = U(ue, j).join(".");
            return he + G;
        }
        function v(R) {
            for(var j = [], Y = 0, he = R.length, ue, G; Y < he;)ue = R.charCodeAt(Y++), ue >= 55296 && ue <= 56319 && Y < he ? (G = R.charCodeAt(Y++), (G & 64512) == 56320 ? j.push(((ue & 1023) << 10) + (G & 1023) + 65536) : (j.push(ue), Y--)) : j.push(ue);
            return j;
        }
        function B(R) {
            return U(R, function(j) {
                var Y = "";
                return j > 65535 && (j -= 65536, Y += ne(j >>> 10 & 1023 | 55296), j = 56320 | j & 1023), Y += ne(j), Y;
            }).join("");
        }
        function g(R) {
            return R - 48 < 10 ? R - 22 : R - 65 < 26 ? R - 65 : R - 97 < 26 ? R - 97 : c;
        }
        function E(R, j) {
            return R + 22 + 75 * (R < 26) - ((j != 0) << 5);
        }
        function w(R, j, Y) {
            var he = 0;
            for(R = Y ? $(R / h) : R >> 1, R += $(R / j); R > K * u >> 1; he += c)R = $(R / K);
            return $(he + (K + 1) * R / (R + f));
        }
        function _(R) {
            var j = [], Y = R.length, he, ue = 0, G = S, se = y, Z, ie, pe, ve, Ie, Me, Re, C, J;
            for(Z = R.lastIndexOf(k), Z < 0 && (Z = 0), ie = 0; ie < Z; ++ie)R.charCodeAt(ie) >= 128 && q("not-basic"), j.push(R.charCodeAt(ie));
            for(pe = Z > 0 ? Z + 1 : 0; pe < Y;){
                for(ve = ue, Ie = 1, Me = c; pe >= Y && q("invalid-input"), Re = g(R.charCodeAt(pe++)), (Re >= c || Re > $((s - ue) / Ie)) && q("overflow"), ue += Re * Ie, C = Me <= se ? l : Me >= se + u ? u : Me - se, !(Re < C); Me += c)J = c - C, Ie > $(s / J) && q("overflow"), Ie *= J;
                he = j.length + 1, se = w(ue - ve, he, ve == 0), $(ue / he) > s - G && q("overflow"), G += $(ue / he), ue %= he, j.splice(ue++, 0, G);
            }
            return B(j);
        }
        function O(R) {
            var j, Y, he, ue, G, se, Z, ie, pe, ve, Ie, Me = [], Re, C, J, me;
            for(R = v(R), Re = R.length, j = S, Y = 0, G = y, se = 0; se < Re; ++se)Ie = R[se], Ie < 128 && Me.push(ne(Ie));
            for(he = ue = Me.length, ue && Me.push(k); he < Re;){
                for(Z = s, se = 0; se < Re; ++se)Ie = R[se], Ie >= j && Ie < Z && (Z = Ie);
                for(C = he + 1, Z - j > $((s - Y) / C) && q("overflow"), Y += (Z - j) * C, j = Z, se = 0; se < Re; ++se)if (Ie = R[se], Ie < j && ++Y > s && q("overflow"), Ie == j) {
                    for(ie = Y, pe = c; ve = pe <= G ? l : pe >= G + u ? u : pe - G, !(ie < ve); pe += c)me = ie - ve, J = c - ve, Me.push(ne(E(ve + me % J, 0))), ie = $(me / J);
                    Me.push(ne(E(ie, 0))), G = w(Y, C, he == ue), Y = 0, ++he;
                }
                ++Y, ++j;
            }
            return Me.join("");
        }
        function I(R) {
            return Q(R, function(j) {
                return P.test(j) ? _(j.slice(4).toLowerCase()) : j;
            });
        }
        function x(R) {
            return Q(R, function(j) {
                return M.test(j) ? "xn--" + O(j) : j;
            });
        }
        if (a = {
            /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */ version: "1.4.1",
            /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */ ucs2: {
                decode: v,
                encode: B
            },
            decode: _,
            encode: O,
            toASCII: x,
            toUnicode: I
        }, n && i1) if (e.exports == n) i1.exports = a;
        else for(ee in a)a.hasOwnProperty(ee) && (n[ee] = a[ee]);
        else r.punycode = a;
    })(Qe);
})(Im, Im.exports);
var Oae = Im.exports, qh = TypeError, E5 = typeof Map == "function" && Map.prototype, A3 = Object.getOwnPropertyDescriptor && E5 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Bm = E5 && A3 && typeof A3.get == "function" ? A3.get : null, EO = E5 && Map.prototype.forEach, S5 = typeof Set == "function" && Set.prototype, v3 = Object.getOwnPropertyDescriptor && S5 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Tm = S5 && v3 && typeof v3.get == "function" ? v3.get : null, SO = S5 && Set.prototype.forEach, Iae = typeof WeakMap == "function" && WeakMap.prototype, $p = Iae ? WeakMap.prototype.has : null, Bae = typeof WeakSet == "function" && WeakSet.prototype, Zp = Bae ? WeakSet.prototype.has : null, Tae = typeof WeakRef == "function" && WeakRef.prototype, xO = Tae ? WeakRef.prototype.deref : null, Pae = Boolean.prototype.valueOf, Cae = Object.prototype.toString, Mae = Function.prototype.toString, Nae = String.prototype.match, x5 = String.prototype.slice, qc = String.prototype.replace, Rae = String.prototype.toUpperCase, _O = String.prototype.toLowerCase, TN = RegExp.prototype.test, kO = Array.prototype.concat, zs = Array.prototype.join, Uae = Array.prototype.slice, OO = Math.floor, Y8 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, E3 = Object.getOwnPropertySymbols, J8 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, gh = typeof Symbol == "function" && typeof Symbol.iterator == "object", Xp = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === gh || !0) ? Symbol.toStringTag : null, PN = Object.prototype.propertyIsEnumerable, IO = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
    return e.__proto__;
} : null);
function BO(e, t) {
    if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || TN.call(/e/, t)) return t;
    var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof e == "number") {
        var n = e < 0 ? -OO(-e) : OO(e);
        if (n !== e) {
            var i1 = String(n), o = x5.call(t, i1.length + 1);
            return qc.call(i1, r, "$&_") + "." + qc.call(qc.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
    }
    return qc.call(t, r, "$&_");
}
var e4 = cl, TO = e4.custom, PO = NN(TO) ? TO : null, CN = {
    __proto__: null,
    double: '"',
    single: "'"
}, Dae = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
}, Eb = function e(t, r, n, i1) {
    var o = r || {};
    if (xu(o, "quoteStyle") && !xu(CN, o.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (xu(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var a = xu(o, "customInspect") ? o.customInspect : !0;
    if (typeof a != "boolean" && a !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (xu(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (xu(o, "numericSeparator") && typeof o.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var s = o.numericSeparator;
    if (typeof t > "u") return "undefined";
    if (t === null) return "null";
    if (typeof t == "boolean") return t ? "true" : "false";
    if (typeof t == "string") return UN(t, o);
    if (typeof t == "number") {
        if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
        var c = String(t);
        return s ? BO(t, c) : c;
    }
    if (typeof t == "bigint") {
        var l = String(t) + "n";
        return s ? BO(t, l) : l;
    }
    var u = typeof o.depth > "u" ? 5 : o.depth;
    if (typeof n > "u" && (n = 0), n >= u && u > 0 && typeof t == "object") return t4(t) ? "[Array]" : "[Object]";
    var f = tse(o, n);
    if (typeof i1 > "u") i1 = [];
    else if (RN(i1, t) >= 0) return "[Circular]";
    function h(g, E, w) {
        if (E && (i1 = Uae.call(i1), i1.push(E)), w) {
            var _ = {
                depth: o.depth
            };
            return xu(o, "quoteStyle") && (_.quoteStyle = o.quoteStyle), e(g, _, n + 1, i1);
        }
        return e(g, o, n + 1, i1);
    }
    if (typeof t == "function" && !CO(t)) {
        var y = Wae(t), S = uy(t, h);
        return "[Function" + (y ? ": " + y : " (anonymous)") + "]" + (S.length > 0 ? " { " + zs.call(S, ", ") + " }" : "");
    }
    if (NN(t)) {
        var k = gh ? qc.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : J8.call(t);
        return typeof t == "object" && !gh ? xp(k) : k;
    }
    if (Yae(t)) {
        for(var P = "<" + _O.call(String(t.nodeName)), M = t.attributes || [], N = 0; N < M.length; N++)P += " " + M[N].name + "=" + MN(jae(M[N].value), "double", o);
        return P += ">", t.childNodes && t.childNodes.length && (P += "..."), P += "</" + _O.call(String(t.nodeName)) + ">", P;
    }
    if (t4(t)) {
        if (t.length === 0) return "[]";
        var z = uy(t, h);
        return f && !ese(z) ? "[" + r4(z, f) + "]" : "[ " + zs.call(z, ", ") + " ]";
    }
    if (zae(t)) {
        var K = uy(t, h);
        return !("cause" in Error.prototype) && "cause" in t && !PN.call(t, "cause") ? "{ [" + String(t) + "] " + zs.call(kO.call("[cause]: " + h(t.cause), K), ", ") + " }" : K.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + zs.call(K, ", ") + " }";
    }
    if (typeof t == "object" && a) {
        if (PO && typeof t[PO] == "function" && e4) return e4(t, {
            depth: u - n
        });
        if (a !== "symbol" && typeof t.inspect == "function") return t.inspect();
    }
    if (Gae(t)) {
        var $ = [];
        return EO && EO.call(t, function(g, E) {
            $.push(h(E, t, !0) + " => " + h(g, t));
        }), MO("Map", Bm.call(t), $, f);
    }
    if (Zae(t)) {
        var ne = [];
        return SO && SO.call(t, function(g) {
            ne.push(h(g, t));
        }), MO("Set", Tm.call(t), ne, f);
    }
    if (Qae(t)) return S3("WeakMap");
    if (Xae(t)) return S3("WeakSet");
    if ($ae(t)) return S3("WeakRef");
    if (Hae(t)) return xp(h(Number(t)));
    if (qae(t)) return xp(h(Y8.call(t)));
    if (Kae(t)) return xp(Pae.call(t));
    if (Lae(t)) return xp(h(String(t)));
    if (typeof window < "u" && t === window) return "{ [object Window] }";
    if (typeof globalThis < "u" && t === globalThis || typeof Qe < "u" && t === Qe) return "{ [object globalThis] }";
    if (!Fae(t) && !CO(t)) {
        var ee = uy(t, h), q = IO ? IO(t) === Object.prototype : t instanceof Object || t.constructor === Object, U = t instanceof Object ? "" : "null prototype", Q = !q && Xp && Object(t) === t && Xp in t ? x5.call(dl(t), 8, -1) : U ? "Object" : "", v = q || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", B = v + (Q || U ? "[" + zs.call(kO.call([], Q || [], U || []), ": ") + "] " : "");
        return ee.length === 0 ? B + "{}" : f ? B + "{" + r4(ee, f) + "}" : B + "{ " + zs.call(ee, ", ") + " }";
    }
    return String(t);
};
function MN(e, t, r) {
    var n = r.quoteStyle || t, i1 = CN[n];
    return i1 + e + i1;
}
function jae(e) {
    return qc.call(String(e), /"/g, "&quot;");
}
function Uf(e) {
    return !Xp || !(typeof e == "object" && (Xp in e || typeof e[Xp] < "u"));
}
function t4(e) {
    return dl(e) === "[object Array]" && Uf(e);
}
function Fae(e) {
    return dl(e) === "[object Date]" && Uf(e);
}
function CO(e) {
    return dl(e) === "[object RegExp]" && Uf(e);
}
function zae(e) {
    return dl(e) === "[object Error]" && Uf(e);
}
function Lae(e) {
    return dl(e) === "[object String]" && Uf(e);
}
function Hae(e) {
    return dl(e) === "[object Number]" && Uf(e);
}
function Kae(e) {
    return dl(e) === "[object Boolean]" && Uf(e);
}
function NN(e) {
    if (gh) return e && typeof e == "object" && e instanceof Symbol;
    if (typeof e == "symbol") return !0;
    if (!e || typeof e != "object" || !J8) return !1;
    try {
        return J8.call(e), !0;
    } catch  {}
    return !1;
}
function qae(e) {
    if (!e || typeof e != "object" || !Y8) return !1;
    try {
        return Y8.call(e), !0;
    } catch  {}
    return !1;
}
var Vae = Object.prototype.hasOwnProperty || function(e) {
    return e in this;
};
function xu(e, t) {
    return Vae.call(e, t);
}
function dl(e) {
    return Cae.call(e);
}
function Wae(e) {
    if (e.name) return e.name;
    var t = Nae.call(Mae.call(e), /^function\s*([\w$]+)/);
    return t ? t[1] : null;
}
function RN(e, t) {
    if (e.indexOf) return e.indexOf(t);
    for(var r = 0, n = e.length; r < n; r++)if (e[r] === t) return r;
    return -1;
}
function Gae(e) {
    if (!Bm || !e || typeof e != "object") return !1;
    try {
        Bm.call(e);
        try {
            Tm.call(e);
        } catch  {
            return !0;
        }
        return e instanceof Map;
    } catch  {}
    return !1;
}
function Qae(e) {
    if (!$p || !e || typeof e != "object") return !1;
    try {
        $p.call(e, $p);
        try {
            Zp.call(e, Zp);
        } catch  {
            return !0;
        }
        return e instanceof WeakMap;
    } catch  {}
    return !1;
}
function $ae(e) {
    if (!xO || !e || typeof e != "object") return !1;
    try {
        return xO.call(e), !0;
    } catch  {}
    return !1;
}
function Zae(e) {
    if (!Tm || !e || typeof e != "object") return !1;
    try {
        Tm.call(e);
        try {
            Bm.call(e);
        } catch  {
            return !0;
        }
        return e instanceof Set;
    } catch  {}
    return !1;
}
function Xae(e) {
    if (!Zp || !e || typeof e != "object") return !1;
    try {
        Zp.call(e, Zp);
        try {
            $p.call(e, $p);
        } catch  {
            return !0;
        }
        return e instanceof WeakSet;
    } catch  {}
    return !1;
}
function Yae(e) {
    return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function UN(e, t) {
    if (e.length > t.maxStringLength) {
        var r = e.length - t.maxStringLength, n = "... " + r + " more character" + (r > 1 ? "s" : "");
        return UN(x5.call(e, 0, t.maxStringLength), t) + n;
    }
    var i1 = Dae[t.quoteStyle || "single"];
    i1.lastIndex = 0;
    var o = qc.call(qc.call(e, i1, "\\$1"), /[\x00-\x1f]/g, Jae);
    return MN(o, "single", t);
}
function Jae(e) {
    var t = e.charCodeAt(0), r = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + Rae.call(t.toString(16));
}
function xp(e) {
    return "Object(" + e + ")";
}
function S3(e) {
    return e + " { ? }";
}
function MO(e, t, r, n) {
    var i1 = n ? r4(r, n) : zs.call(r, ", ");
    return e + " (" + t + ") {" + i1 + "}";
}
function ese(e) {
    for(var t = 0; t < e.length; t++)if (RN(e[t], `
`) >= 0) return !1;
    return !0;
}
function tse(e, t) {
    var r;
    if (e.indent === "	") r = "	";
    else if (typeof e.indent == "number" && e.indent > 0) r = zs.call(Array(e.indent + 1), " ");
    else return null;
    return {
        base: r,
        prev: zs.call(Array(t + 1), r)
    };
}
function r4(e, t) {
    if (e.length === 0) return "";
    var r = `
` + t.prev + t.base;
    return r + zs.call(e, "," + r) + `
` + t.prev;
}
function uy(e, t) {
    var r = t4(e), n = [];
    if (r) {
        n.length = e.length;
        for(var i1 = 0; i1 < e.length; i1++)n[i1] = xu(e, i1) ? t(e[i1], e) : "";
    }
    var o = typeof E3 == "function" ? E3(e) : [], a;
    if (gh) {
        a = {};
        for(var s = 0; s < o.length; s++)a["$" + o[s]] = o[s];
    }
    for(var c in e)xu(e, c) && (r && String(Number(c)) === c && c < e.length || gh && a["$" + c] instanceof Symbol || (TN.call(/[^\w$]/, c) ? n.push(t(c, e) + ": " + t(e[c], e)) : n.push(c + ": " + t(e[c], e))));
    if (typeof E3 == "function") for(var l = 0; l < o.length; l++)PN.call(e, o[l]) && n.push("[" + t(o[l]) + "]: " + t(e[o[l]], e));
    return n;
}
var rse = Eb, nse = qh, Sb = function(e, t, r) {
    for(var n = e, i1; (i1 = n.next) != null; n = i1)if (i1.key === t) return n.next = i1.next, r || (i1.next = /** @type {NonNullable<typeof list.next>} */ e.next, e.next = i1), i1;
}, ise = function(e, t) {
    if (e) {
        var r = Sb(e, t);
        return r && r.value;
    }
}, ose = function(e, t, r) {
    var n = Sb(e, t);
    n ? n.value = r : e.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: t,
        next: e.next,
        value: r
    };
}, ase = function(e, t) {
    return e ? !!Sb(e, t) : !1;
}, sse = function(e, t) {
    if (e) return Sb(e, t, !0);
}, use = function() {
    var e, t = {
        assert: function(r) {
            if (!t.has(r)) throw new nse("Side channel does not contain " + rse(r));
        },
        delete: function(r) {
            var n = e && e.next, i1 = sse(e, r);
            return i1 && n && n === i1 && (e = void 0), !!i1;
        },
        get: function(r) {
            return ise(e, r);
        },
        has: function(r) {
            return ase(e, r);
        },
        set: function(r, n) {
            e || (e = {
                next: void 0
            }), ose(/** @type {NonNullable<typeof $o>} */ e, r, n);
        }
    };
    return t;
}, DN = Object, cse = Error, lse = EvalError, fse = RangeError, dse = ReferenceError, hse = SyntaxError, pse = URIError, gse = Math.abs, yse = Math.floor, mse = Math.max, bse = Math.min, wse = Math.pow, Ase = Math.round, vse = Number.isNaN || function(e) {
    return e !== e;
}, Ese = vse, Sse = function(e) {
    return Ese(e) || e === 0 ? e : e < 0 ? -1 : 1;
}, xse = Object.getOwnPropertyDescriptor, Gy = xse;
if (Gy) try {
    Gy([], "length");
} catch  {
    Gy = null;
}
var jN = Gy, Qy = Object.defineProperty || !1;
if (Qy) try {
    Qy({}, "a", {
        value: 1
    });
} catch  {
    Qy = !1;
}
var _se = Qy, NO, RO;
function kse() {
    return RO || (RO = 1, NO = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {}, t = Symbol("test"), r = Object(t);
        if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
        var n = 42;
        e[t] = n;
        for(var i1 in e)return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var o = Object.getOwnPropertySymbols(e);
        if (o.length !== 1 || o[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var a = /** @type {PropertyDescriptor} */ Object.getOwnPropertyDescriptor(e, t);
            if (a.value !== n || a.enumerable !== !0) return !1;
        }
        return !0;
    }), NO;
}
var x3, UO;
function Ose() {
    if (UO) return x3;
    UO = 1;
    var e = typeof Symbol < "u" && Symbol, t = kse();
    return x3 = function() {
        return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
    }, x3;
}
var DO, jO;
function FN() {
    return jO || (jO = 1, DO = typeof Reflect < "u" && Reflect.getPrototypeOf || null), DO;
}
var _3, FO;
function zN() {
    if (FO) return _3;
    FO = 1;
    var e = DN;
    return _3 = e.getPrototypeOf || null, _3;
}
var Ise = "Function.prototype.bind called on incompatible ", Bse = Object.prototype.toString, Tse = Math.max, Pse = "[object Function]", zO = function(e, t) {
    for(var r = [], n = 0; n < e.length; n += 1)r[n] = e[n];
    for(var i1 = 0; i1 < t.length; i1 += 1)r[i1 + e.length] = t[i1];
    return r;
}, Cse = function(e, t) {
    for(var r = [], n = t, i1 = 0; n < e.length; n += 1, i1 += 1)r[i1] = e[n];
    return r;
}, Mse = function(e, t) {
    for(var r = "", n = 0; n < e.length; n += 1)r += e[n], n + 1 < e.length && (r += t);
    return r;
}, Nse = function(e) {
    var t = this;
    if (typeof t != "function" || Bse.apply(t) !== Pse) throw new TypeError(Ise + t);
    for(var r = Cse(arguments, 1), n, i1 = function() {
        if (this instanceof n) {
            var l = t.apply(this, zO(r, arguments));
            return Object(l) === l ? l : this;
        }
        return t.apply(e, zO(r, arguments));
    }, o = Tse(0, t.length - r.length), a = [], s = 0; s < o; s++)a[s] = "$" + s;
    if (n = Function("binder", "return function (" + Mse(a, ",") + "){ return binder.apply(this,arguments); }")(i1), t.prototype) {
        var c = function() {};
        c.prototype = t.prototype, n.prototype = new c(), c.prototype = null;
    }
    return n;
}, Rse = Nse, xb = Function.prototype.bind || Rse, _5 = Function.prototype.call, LO, HO;
function LN() {
    return HO || (HO = 1, LO = Function.prototype.apply), LO;
}
var Use = typeof Reflect < "u" && Reflect && Reflect.apply, Dse = xb, jse = LN(), Fse = _5, zse = Use, Lse = zse || Dse.call(Fse, jse), Hse = xb, Kse = qh, qse = _5, Vse = Lse, HN = function(e) {
    if (e.length < 1 || typeof e[0] != "function") throw new Kse("a function is required");
    return Vse(Hse, qse, e);
}, k3, KO;
function Wse() {
    if (KO) return k3;
    KO = 1;
    var e = HN, t = jN, r;
    try {
        r = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
    } catch (a) {
        if (!a || typeof a != "object" || !("code" in a) || a.code !== "ERR_PROTO_ACCESS") throw a;
    }
    var n = !!r && t && t(Object.prototype, /** @type {keyof typeof Object.prototype} */ "__proto__"), i1 = Object, o = i1.getPrototypeOf;
    return k3 = n && typeof n.get == "function" ? e([
        n.get
    ]) : typeof o == "function" ? /** @type {import('./get')} */ function(a) {
        return o(a == null ? a : i1(a));
    } : !1, k3;
}
var O3, qO;
function Gse() {
    if (qO) return O3;
    qO = 1;
    var e = FN(), t = zN(), r = Wse();
    return O3 = e ? function(n) {
        return e(n);
    } : t ? function(n) {
        if (!n || typeof n != "object" && typeof n != "function") throw new TypeError("getProto: not an object");
        return t(n);
    } : r ? function(n) {
        return r(n);
    } : null, O3;
}
var I3, VO;
function Qse() {
    if (VO) return I3;
    VO = 1;
    var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = xb;
    return I3 = r.call(e, t), I3;
}
var Fr, $se = DN, Zse = cse, Xse = lse, Yse = fse, Jse = dse, yh = hse, Wd = qh, eue = pse, tue = gse, rue = yse, nue = mse, iue = bse, oue = wse, aue = Ase, sue = Sse, KN = Function, B3 = function(e) {
    try {
        return KN('"use strict"; return (' + e + ").constructor;")();
    } catch  {}
}, x0 = jN, uue = _se, T3 = function() {
    throw new Wd();
}, cue = x0 ? function() {
    try {
        return arguments.callee, T3;
    } catch  {
        try {
            return x0(arguments, "callee").get;
        } catch  {
            return T3;
        }
    }
}() : T3, pd = Ose()(), hi = Gse(), lue = zN(), fue = FN(), qN = LN(), B1 = _5, _d = {}, due = typeof Uint8Array > "u" || !hi ? Fr : hi(Uint8Array), lf = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Fr : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Fr : ArrayBuffer,
    "%ArrayIteratorPrototype%": pd && hi ? hi([][Symbol.iterator]()) : Fr,
    "%AsyncFromSyncIteratorPrototype%": Fr,
    "%AsyncFunction%": _d,
    "%AsyncGenerator%": _d,
    "%AsyncGeneratorFunction%": _d,
    "%AsyncIteratorPrototype%": _d,
    "%Atomics%": typeof Atomics > "u" ? Fr : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Fr : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Fr : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Fr : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Fr : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Zse,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": Xse,
    "%Float16Array%": typeof Float16Array > "u" ? Fr : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? Fr : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Fr : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Fr : FinalizationRegistry,
    "%Function%": KN,
    "%GeneratorFunction%": _d,
    "%Int8Array%": typeof Int8Array > "u" ? Fr : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Fr : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Fr : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": pd && hi ? hi(hi([][Symbol.iterator]())) : Fr,
    "%JSON%": typeof JSON == "object" ? JSON : Fr,
    "%Map%": typeof Map > "u" ? Fr : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !pd || !hi ? Fr : hi(/* @__PURE__ */ new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $se,
    "%Object.getOwnPropertyDescriptor%": x0,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Fr : Promise,
    "%Proxy%": typeof Proxy > "u" ? Fr : Proxy,
    "%RangeError%": Yse,
    "%ReferenceError%": Jse,
    "%Reflect%": typeof Reflect > "u" ? Fr : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Fr : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !pd || !hi ? Fr : hi(/* @__PURE__ */ new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Fr : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": pd && hi ? hi(""[Symbol.iterator]()) : Fr,
    "%Symbol%": pd ? Symbol : Fr,
    "%SyntaxError%": yh,
    "%ThrowTypeError%": cue,
    "%TypedArray%": due,
    "%TypeError%": Wd,
    "%Uint8Array%": typeof Uint8Array > "u" ? Fr : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Fr : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Fr : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Fr : Uint32Array,
    "%URIError%": eue,
    "%WeakMap%": typeof WeakMap > "u" ? Fr : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Fr : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Fr : WeakSet,
    "%Function.prototype.call%": B1,
    "%Function.prototype.apply%": qN,
    "%Object.defineProperty%": uue,
    "%Object.getPrototypeOf%": lue,
    "%Math.abs%": tue,
    "%Math.floor%": rue,
    "%Math.max%": nue,
    "%Math.min%": iue,
    "%Math.pow%": oue,
    "%Math.round%": aue,
    "%Math.sign%": sue,
    "%Reflect.getPrototypeOf%": fue
};
if (hi) try {
    null.error;
} catch (e) {
    var hue = hi(hi(e));
    lf["%Error.prototype%"] = hue;
}
var pue = function e(t) {
    var r;
    if (t === "%AsyncFunction%") r = B3("async function () {}");
    else if (t === "%GeneratorFunction%") r = B3("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") r = B3("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var n = e("%AsyncGeneratorFunction%");
        n && (r = n.prototype);
    } else if (t === "%AsyncIteratorPrototype%") {
        var i1 = e("%AsyncGenerator%");
        i1 && hi && (r = hi(i1.prototype));
    }
    return lf[t] = r, r;
}, WO = {
    __proto__: null,
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
}, T1 = xb, Pm = Qse(), gue = T1.call(B1, Array.prototype.concat), yue = T1.call(qN, Array.prototype.splice), GO = T1.call(B1, String.prototype.replace), Cm = T1.call(B1, String.prototype.slice), mue = T1.call(B1, RegExp.prototype.exec), bue = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, wue = /\\(\\)?/g, Aue = function(e) {
    var t = Cm(e, 0, 1), r = Cm(e, -1);
    if (t === "%" && r !== "%") throw new yh("invalid intrinsic syntax, expected closing `%`");
    if (r === "%" && t !== "%") throw new yh("invalid intrinsic syntax, expected opening `%`");
    var n = [];
    return GO(e, bue, function(i1, o, a, s) {
        n[n.length] = a ? GO(s, wue, "$1") : o || i1;
    }), n;
}, vue = function(e, t) {
    var r = e, n;
    if (Pm(WO, r) && (n = WO[r], r = "%" + n[0] + "%"), Pm(lf, r)) {
        var i1 = lf[r];
        if (i1 === _d && (i1 = pue(r)), typeof i1 > "u" && !t) throw new Wd("intrinsic " + e + " exists, but is not available. Please file an issue!");
        return {
            alias: n,
            name: r,
            value: i1
        };
    }
    throw new yh("intrinsic " + e + " does not exist!");
}, k5 = function(e, t) {
    if (typeof e != "string" || e.length === 0) throw new Wd("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof t != "boolean") throw new Wd('"allowMissing" argument must be a boolean');
    if (mue(/^%?[^%]*%?$/, e) === null) throw new yh("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var r = Aue(e), n = r.length > 0 ? r[0] : "", i1 = vue("%" + n + "%", t), o = i1.name, a = i1.value, s = !1, c = i1.alias;
    c && (n = c[0], yue(r, gue([
        0,
        1
    ], c)));
    for(var l = 1, u = !0; l < r.length; l += 1){
        var f = r[l], h = Cm(f, 0, 1), y = Cm(f, -1);
        if ((h === '"' || h === "'" || h === "`" || y === '"' || y === "'" || y === "`") && h !== y) throw new yh("property names with quotes must have matching quotes");
        if ((f === "constructor" || !u) && (s = !0), n += "." + f, o = "%" + n + "%", Pm(lf, o)) a = lf[o];
        else if (a != null) {
            if (!(f in a)) {
                if (!t) throw new Wd("base intrinsic for " + e + " exists, but the property is not available.");
                return;
            }
            if (x0 && l + 1 >= r.length) {
                var S = x0(a, f);
                u = !!S, u && "get" in S && !("originalValue" in S.get) ? a = S.get : a = a[f];
            } else u = Pm(a, f), a = a[f];
            u && !s && (lf[o] = a);
        }
    }
    return a;
}, VN = k5, WN = HN, Eue = WN([
    VN("%String.prototype.indexOf%")
]), GN = function(e, t) {
    var r = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ VN(e, !!t);
    return typeof r == "function" && Eue(e, ".prototype.") > -1 ? WN(/** @type {const} */ [
        r
    ]) : r;
}, Sue = k5, P1 = GN, xue = Eb, _ue = qh, QO = Sue("%Map%", !0), kue = P1("Map.prototype.get", !0), Oue = P1("Map.prototype.set", !0), Iue = P1("Map.prototype.has", !0), Bue = P1("Map.prototype.delete", !0), Tue = P1("Map.prototype.size", !0), QN = !!QO && /** @type {Exclude<import('.'), false>} */ function() {
    var e, t = {
        assert: function(r) {
            if (!t.has(r)) throw new _ue("Side channel does not contain " + xue(r));
        },
        delete: function(r) {
            if (e) {
                var n = Bue(e, r);
                return Tue(e) === 0 && (e = void 0), n;
            }
            return !1;
        },
        get: function(r) {
            if (e) return kue(e, r);
        },
        has: function(r) {
            return e ? Iue(e, r) : !1;
        },
        set: function(r, n) {
            e || (e = new QO()), Oue(e, r, n);
        }
    };
    return t;
}, Pue = k5, _b = GN, Cue = Eb, cy = QN, Mue = qh, gd = Pue("%WeakMap%", !0), Nue = _b("WeakMap.prototype.get", !0), Rue = _b("WeakMap.prototype.set", !0), Uue = _b("WeakMap.prototype.has", !0), Due = _b("WeakMap.prototype.delete", !0), jue = gd ? /** @type {Exclude<import('.'), false>} */ function() {
    var e, t, r = {
        assert: function(n) {
            if (!r.has(n)) throw new Mue("Side channel does not contain " + Cue(n));
        },
        delete: function(n) {
            if (gd && n && (typeof n == "object" || typeof n == "function")) {
                if (e) return Due(e, n);
            } else if (cy && t) return t.delete(n);
            return !1;
        },
        get: function(n) {
            return gd && n && (typeof n == "object" || typeof n == "function") && e ? Nue(e, n) : t && t.get(n);
        },
        has: function(n) {
            return gd && n && (typeof n == "object" || typeof n == "function") && e ? Uue(e, n) : !!t && t.has(n);
        },
        set: function(n, i1) {
            gd && n && (typeof n == "object" || typeof n == "function") ? (e || (e = new gd()), Rue(e, n, i1)) : cy && (t || (t = cy()), t.set(n, i1));
        }
    };
    return r;
} : cy, Fue = qh, zue = Eb, Lue = use, Hue = QN, Kue = jue, que = Kue || Hue || Lue, Vue = function() {
    var e, t = {
        assert: function(r) {
            if (!t.has(r)) throw new Fue("Side channel does not contain " + zue(r));
        },
        delete: function(r) {
            return !!e && e.delete(r);
        },
        get: function(r) {
            return e && e.get(r);
        },
        has: function(r) {
            return !!e && e.has(r);
        },
        set: function(r, n) {
            e || (e = que()), e.set(r, n);
        }
    };
    return t;
}, Wue = String.prototype.replace, Gue = /%20/g, P3 = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}, O5 = {
    default: P3.RFC3986,
    formatters: {
        RFC1738: function(e) {
            return Wue.call(e, Gue, "+");
        },
        RFC3986: function(e) {
            return String(e);
        }
    },
    RFC1738: P3.RFC1738,
    RFC3986: P3.RFC3986
}, Que = O5, C3 = Object.prototype.hasOwnProperty, Ml = Array.isArray, Es = function() {
    for(var e = [], t = 0; t < 256; ++t)e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e;
}(), $ue = function(e) {
    for(; e.length > 1;){
        var t = e.pop(), r = t.obj[t.prop];
        if (Ml(r)) {
            for(var n = [], i1 = 0; i1 < r.length; ++i1)typeof r[i1] < "u" && n.push(r[i1]);
            t.obj[t.prop] = n;
        }
    }
}, $N = function(e, t) {
    for(var r = t && t.plainObjects ? {
        __proto__: null
    } : {}, n = 0; n < e.length; ++n)typeof e[n] < "u" && (r[n] = e[n]);
    return r;
}, Zue = function e(t, r, n) {
    if (!r) return t;
    if (typeof r != "object" && typeof r != "function") {
        if (Ml(t)) t.push(r);
        else if (t && typeof t == "object") (n && (n.plainObjects || n.allowPrototypes) || !C3.call(Object.prototype, r)) && (t[r] = !0);
        else return [
            t,
            r
        ];
        return t;
    }
    if (!t || typeof t != "object") return [
        t
    ].concat(r);
    var i1 = t;
    return Ml(t) && !Ml(r) && (i1 = $N(t, n)), Ml(t) && Ml(r) ? (r.forEach(function(o, a) {
        if (C3.call(t, a)) {
            var s = t[a];
            s && typeof s == "object" && o && typeof o == "object" ? t[a] = e(s, o, n) : t.push(o);
        } else t[a] = o;
    }), t) : Object.keys(r).reduce(function(o, a) {
        var s = r[a];
        return C3.call(o, a) ? o[a] = e(o[a], s, n) : o[a] = s, o;
    }, i1);
}, Xue = function(e, t) {
    return Object.keys(t).reduce(function(r, n) {
        return r[n] = t[n], r;
    }, e);
}, Yue = function(e, t, r) {
    var n = e.replace(/\+/g, " ");
    if (r === "iso-8859-1") return n.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(n);
    } catch  {
        return n;
    }
}, M3 = 1024, Jue = function(e, t, r, n, i1) {
    if (e.length === 0) return e;
    var o = e;
    if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), r === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(h) {
        return "%26%23" + parseInt(h.slice(2), 16) + "%3B";
    });
    for(var a = "", s = 0; s < o.length; s += M3){
        for(var c = o.length >= M3 ? o.slice(s, s + M3) : o, l = [], u = 0; u < c.length; ++u){
            var f = c.charCodeAt(u);
            if (f === 45 || f === 46 || f === 95 || f === 126 || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || i1 === Que.RFC1738 && (f === 40 || f === 41)) {
                l[l.length] = c.charAt(u);
                continue;
            }
            if (f < 128) {
                l[l.length] = Es[f];
                continue;
            }
            if (f < 2048) {
                l[l.length] = Es[192 | f >> 6] + Es[128 | f & 63];
                continue;
            }
            if (f < 55296 || f >= 57344) {
                l[l.length] = Es[224 | f >> 12] + Es[128 | f >> 6 & 63] + Es[128 | f & 63];
                continue;
            }
            u += 1, f = 65536 + ((f & 1023) << 10 | c.charCodeAt(u) & 1023), l[l.length] = Es[240 | f >> 18] + Es[128 | f >> 12 & 63] + Es[128 | f >> 6 & 63] + Es[128 | f & 63];
        }
        a += l.join("");
    }
    return a;
}, ece = function(e) {
    for(var t = [
        {
            obj: {
                o: e
            },
            prop: "o"
        }
    ], r = [], n = 0; n < t.length; ++n)for(var i1 = t[n], o = i1.obj[i1.prop], a = Object.keys(o), s = 0; s < a.length; ++s){
        var c = a[s], l = o[c];
        typeof l == "object" && l !== null && r.indexOf(l) === -1 && (t.push({
            obj: o,
            prop: c
        }), r.push(l));
    }
    return $ue(t), e;
}, tce = function(e) {
    return Object.prototype.toString.call(e) === "[object RegExp]";
}, rce = function(e) {
    return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}, nce = function(e, t) {
    return [].concat(e, t);
}, ice = function(e, t) {
    if (Ml(e)) {
        for(var r = [], n = 0; n < e.length; n += 1)r.push(t(e[n]));
        return r;
    }
    return t(e);
}, ZN = {
    arrayToObject: $N,
    assign: Xue,
    combine: nce,
    compact: ece,
    decode: Yue,
    encode: Jue,
    isBuffer: rce,
    isRegExp: tce,
    maybeMap: ice,
    merge: Zue
}, XN = Vue, $y = ZN, Yp = O5, oce = Object.prototype.hasOwnProperty, YN = {
    brackets: function(e) {
        return e + "[]";
    },
    comma: "comma",
    indices: function(e, t) {
        return e + "[" + t + "]";
    },
    repeat: function(e) {
        return e;
    }
}, Us = Array.isArray, ace = Array.prototype.push, JN = function(e, t) {
    ace.apply(e, Us(t) ? t : [
        t
    ]);
}, sce = Date.prototype.toISOString, $O = Yp.default, ni = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    commaRoundTrip: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: $y.encode,
    encodeValuesOnly: !1,
    filter: void 0,
    format: $O,
    formatter: Yp.formatters[$O],
    // deprecated
    indices: !1,
    serializeDate: function(e) {
        return sce.call(e);
    },
    skipNulls: !1,
    strictNullHandling: !1
}, uce = function(e) {
    return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
}, N3 = {}, cce = function e(t, r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M, N) {
    for(var z = t, K = N, $ = 0, ne = !1; (K = K.get(N3)) !== void 0 && !ne;){
        var ee = K.get(t);
        if ($ += 1, typeof ee < "u") {
            if (ee === $) throw new RangeError("Cyclic object value");
            ne = !0;
        }
        typeof K.get(N3) > "u" && ($ = 0);
    }
    if (typeof u == "function" ? z = u(r, z) : z instanceof Date ? z = y(z) : n === "comma" && Us(z) && (z = $y.maybeMap(z, function(R) {
        return R instanceof Date ? y(R) : R;
    })), z === null) {
        if (a) return l && !P ? l(r, ni.encoder, M, "key", S) : r;
        z = "";
    }
    if (uce(z) || $y.isBuffer(z)) {
        if (l) {
            var q = P ? r : l(r, ni.encoder, M, "key", S);
            return [
                k(q) + "=" + k(l(z, ni.encoder, M, "value", S))
            ];
        }
        return [
            k(r) + "=" + k(String(z))
        ];
    }
    var U = [];
    if (typeof z > "u") return U;
    var Q;
    if (n === "comma" && Us(z)) P && l && (z = $y.maybeMap(z, l)), Q = [
        {
            value: z.length > 0 ? z.join(",") || null : void 0
        }
    ];
    else if (Us(u)) Q = u;
    else {
        var v = Object.keys(z);
        Q = f ? v.sort(f) : v;
    }
    var B = c ? String(r).replace(/\./g, "%2E") : String(r), g = i1 && Us(z) && z.length === 1 ? B + "[]" : B;
    if (o && Us(z) && z.length === 0) return g + "[]";
    for(var E = 0; E < Q.length; ++E){
        var w = Q[E], _ = typeof w == "object" && w && typeof w.value < "u" ? w.value : z[w];
        if (!(s && _ === null)) {
            var O = h && c ? String(w).replace(/\./g, "%2E") : String(w), I = Us(z) ? typeof n == "function" ? n(g, O) : g : g + (h ? "." + O : "[" + O + "]");
            N.set(t, $);
            var x = XN();
            x.set(N3, N), JN(U, e(_, I, n, i1, o, a, s, c, n === "comma" && P && Us(z) ? null : l, u, f, h, y, S, k, P, M, x));
        }
    }
    return U;
}, lce = function(e) {
    if (!e) return ni;
    if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
    var t = e.charset || ni.charset;
    if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var r = Yp.default;
    if (typeof e.format < "u") {
        if (!oce.call(Yp.formatters, e.format)) throw new TypeError("Unknown format option provided.");
        r = e.format;
    }
    var n = Yp.formatters[r], i1 = ni.filter;
    (typeof e.filter == "function" || Us(e.filter)) && (i1 = e.filter);
    var o;
    if (e.arrayFormat in YN ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = ni.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var a = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : ni.allowDots : !!e.allowDots;
    return {
        addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : ni.addQueryPrefix,
        allowDots: a,
        allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : ni.allowEmptyArrays,
        arrayFormat: o,
        charset: t,
        charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : ni.charsetSentinel,
        commaRoundTrip: !!e.commaRoundTrip,
        delimiter: typeof e.delimiter > "u" ? ni.delimiter : e.delimiter,
        encode: typeof e.encode == "boolean" ? e.encode : ni.encode,
        encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : ni.encodeDotInKeys,
        encoder: typeof e.encoder == "function" ? e.encoder : ni.encoder,
        encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : ni.encodeValuesOnly,
        filter: i1,
        format: r,
        formatter: n,
        serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : ni.serializeDate,
        skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : ni.skipNulls,
        sort: typeof e.sort == "function" ? e.sort : null,
        strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : ni.strictNullHandling
    };
}, fce = function(e, t) {
    var r = e, n = lce(t), i1, o;
    typeof n.filter == "function" ? (o = n.filter, r = o("", r)) : Us(n.filter) && (o = n.filter, i1 = o);
    var a = [];
    if (typeof r != "object" || r === null) return "";
    var s = YN[n.arrayFormat], c = s === "comma" && n.commaRoundTrip;
    i1 || (i1 = Object.keys(r)), n.sort && i1.sort(n.sort);
    for(var l = XN(), u = 0; u < i1.length; ++u){
        var f = i1[u], h = r[f];
        n.skipNulls && h === null || JN(a, cce(h, f, s, c, n.allowEmptyArrays, n.strictNullHandling, n.skipNulls, n.encodeDotInKeys, n.encode ? n.encoder : null, n.filter, n.sort, n.allowDots, n.serializeDate, n.format, n.formatter, n.encodeValuesOnly, n.charset, l));
    }
    var y = a.join(n.delimiter), S = n.addQueryPrefix === !0 ? "?" : "";
    return n.charsetSentinel && (n.charset === "iso-8859-1" ? S += "utf8=%26%2310003%3B&" : S += "utf8=%E2%9C%93&"), y.length > 0 ? S + y : "";
}, wf = ZN, n4 = Object.prototype.hasOwnProperty, ZO = Array.isArray, jn = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: wf.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1,
    throwOnLimitExceeded: !1
}, dce = function(e) {
    return e.replace(/&#(\d+);/g, function(t, r) {
        return String.fromCharCode(parseInt(r, 10));
    });
}, eR = function(e, t, r) {
    if (e && typeof e == "string" && t.comma && e.indexOf(",") > -1) return e.split(",");
    if (t.throwOnLimitExceeded && r >= t.arrayLimit) throw new RangeError("Array limit exceeded. Only " + t.arrayLimit + " element" + (t.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return e;
}, hce = "utf8=%26%2310003%3B", pce = "utf8=%E2%9C%93", gce = function(e, t) {
    var r = {
        __proto__: null
    }, n = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
    n = n.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var i1 = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit, o = n.split(t.delimiter, t.throwOnLimitExceeded ? i1 + 1 : i1);
    if (t.throwOnLimitExceeded && o.length > i1) throw new RangeError("Parameter limit exceeded. Only " + i1 + " parameter" + (i1 === 1 ? "" : "s") + " allowed.");
    var a = -1, s, c = t.charset;
    if (t.charsetSentinel) for(s = 0; s < o.length; ++s)o[s].indexOf("utf8=") === 0 && (o[s] === pce ? c = "utf-8" : o[s] === hce && (c = "iso-8859-1"), a = s, s = o.length);
    for(s = 0; s < o.length; ++s)if (s !== a) {
        var l = o[s], u = l.indexOf("]="), f = u === -1 ? l.indexOf("=") : u + 1, h, y;
        f === -1 ? (h = t.decoder(l, jn.decoder, c, "key"), y = t.strictNullHandling ? null : "") : (h = t.decoder(l.slice(0, f), jn.decoder, c, "key"), y = wf.maybeMap(eR(l.slice(f + 1), t, ZO(r[h]) ? r[h].length : 0), function(k) {
            return t.decoder(k, jn.decoder, c, "value");
        })), y && t.interpretNumericEntities && c === "iso-8859-1" && (y = dce(String(y))), l.indexOf("[]=") > -1 && (y = ZO(y) ? [
            y
        ] : y);
        var S = n4.call(r, h);
        S && t.duplicates === "combine" ? r[h] = wf.combine(r[h], y) : (!S || t.duplicates === "last") && (r[h] = y);
    }
    return r;
}, yce = function(e, t, r, n) {
    var i1 = 0;
    if (e.length > 0 && e[e.length - 1] === "[]") {
        var o = e.slice(0, -1).join("");
        i1 = Array.isArray(t) && t[o] ? t[o].length : 0;
    }
    for(var a = n ? t : eR(t, r, i1), s = e.length - 1; s >= 0; --s){
        var c, l = e[s];
        if (l === "[]" && r.parseArrays) c = r.allowEmptyArrays && (a === "" || r.strictNullHandling && a === null) ? [] : wf.combine([], a);
        else {
            c = r.plainObjects ? {
                __proto__: null
            } : {};
            var u = l.charAt(0) === "[" && l.charAt(l.length - 1) === "]" ? l.slice(1, -1) : l, f = r.decodeDotInKeys ? u.replace(/%2E/g, ".") : u, h = parseInt(f, 10);
            !r.parseArrays && f === "" ? c = {
                0: a
            } : !isNaN(h) && l !== f && String(h) === f && h >= 0 && r.parseArrays && h <= r.arrayLimit ? (c = [], c[h] = a) : f !== "__proto__" && (c[f] = a);
        }
        a = c;
    }
    return a;
}, mce = function(e, t, r, n) {
    if (e) {
        var i1 = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, o = /(\[[^[\]]*])/, a = /(\[[^[\]]*])/g, s = r.depth > 0 && o.exec(i1), c = s ? i1.slice(0, s.index) : i1, l = [];
        if (c) {
            if (!r.plainObjects && n4.call(Object.prototype, c) && !r.allowPrototypes) return;
            l.push(c);
        }
        for(var u = 0; r.depth > 0 && (s = a.exec(i1)) !== null && u < r.depth;){
            if (u += 1, !r.plainObjects && n4.call(Object.prototype, s[1].slice(1, -1)) && !r.allowPrototypes) return;
            l.push(s[1]);
        }
        if (s) {
            if (r.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
            l.push("[" + i1.slice(s.index) + "]");
        }
        return yce(l, t, r, n);
    }
}, bce = function(e) {
    if (!e) return jn;
    if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
    if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof e.throwOnLimitExceeded < "u" && typeof e.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var t = typeof e.charset > "u" ? jn.charset : e.charset, r = typeof e.duplicates > "u" ? jn.duplicates : e.duplicates;
    if (r !== "combine" && r !== "first" && r !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
    var n = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : jn.allowDots : !!e.allowDots;
    return {
        allowDots: n,
        allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : jn.allowEmptyArrays,
        allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : jn.allowPrototypes,
        allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : jn.allowSparse,
        arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : jn.arrayLimit,
        charset: t,
        charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : jn.charsetSentinel,
        comma: typeof e.comma == "boolean" ? e.comma : jn.comma,
        decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : jn.decodeDotInKeys,
        decoder: typeof e.decoder == "function" ? e.decoder : jn.decoder,
        delimiter: typeof e.delimiter == "string" || wf.isRegExp(e.delimiter) ? e.delimiter : jn.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : jn.depth,
        duplicates: r,
        ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : jn.interpretNumericEntities,
        parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : jn.parameterLimit,
        parseArrays: e.parseArrays !== !1,
        plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : jn.plainObjects,
        strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : jn.strictDepth,
        strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : jn.strictNullHandling,
        throwOnLimitExceeded: typeof e.throwOnLimitExceeded == "boolean" ? e.throwOnLimitExceeded : !1
    };
}, wce = function(e, t) {
    var r = bce(t);
    if (e === "" || e === null || typeof e > "u") return r.plainObjects ? {
        __proto__: null
    } : {};
    for(var n = typeof e == "string" ? gce(e, r) : e, i1 = r.plainObjects ? {
        __proto__: null
    } : {}, o = Object.keys(n), a = 0; a < o.length; ++a){
        var s = o[a], c = mce(s, n[s], r, typeof e == "string");
        i1 = wf.merge(i1, c, r);
    }
    return r.allowSparse === !0 ? i1 : wf.compact(i1);
}, Ace = fce, vce = wce, Ece = O5, Sce = {
    formats: Ece,
    parse: vce,
    stringify: Ace
}, xce = Oae;
function Pa() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var _ce = /^([a-z0-9.+-]+:)/i, kce = /:[0-9]*$/, Oce = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, Ice = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
], Bce = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
].concat(Ice), i4 = [
    "'"
].concat(Bce), XO = [
    "%",
    "/",
    "?",
    ";",
    "#"
].concat(i4), YO = [
    "/",
    "?",
    "#"
], Tce = 255, JO = /^[+a-z0-9A-Z_-]{0,63}$/, Pce = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Cce = {
    javascript: !0,
    "javascript:": !0
}, o4 = {
    javascript: !0,
    "javascript:": !0
}, Gd = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}, a4 = Sce;
function C1(e, t, r) {
    if (e && typeof e == "object" && e instanceof Pa) return e;
    var n = new Pa();
    return n.parse(e, t, r), n;
}
Pa.prototype.parse = function(e, t, r) {
    if (typeof e != "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var n = e.indexOf("?"), i1 = n !== -1 && n < e.indexOf("#") ? "?" : "#", o = e.split(i1), a = /\\/g;
    o[0] = o[0].replace(a, "/"), e = o.join(i1);
    var s = e;
    if (s = s.trim(), !r && e.split("#").length === 1) {
        var c = Oce.exec(s);
        if (c) return this.path = s, this.href = s, this.pathname = c[1], c[2] ? (this.search = c[2], t ? this.query = a4.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
    }
    var l = _ce.exec(s);
    if (l) {
        l = l[0];
        var u = l.toLowerCase();
        this.protocol = u, s = s.substr(l.length);
    }
    if (r || l || s.match(/^\/\/[^@/]+@[^@/]+/)) {
        var f = s.substr(0, 2) === "//";
        f && !(l && o4[l]) && (s = s.substr(2), this.slashes = !0);
    }
    if (!o4[l] && (f || l && !Gd[l])) {
        for(var h = -1, y = 0; y < YO.length; y++){
            var S = s.indexOf(YO[y]);
            S !== -1 && (h === -1 || S < h) && (h = S);
        }
        var k, P;
        h === -1 ? P = s.lastIndexOf("@") : P = s.lastIndexOf("@", h), P !== -1 && (k = s.slice(0, P), s = s.slice(P + 1), this.auth = decodeURIComponent(k)), h = -1;
        for(var y = 0; y < XO.length; y++){
            var S = s.indexOf(XO[y]);
            S !== -1 && (h === -1 || S < h) && (h = S);
        }
        h === -1 && (h = s.length), this.host = s.slice(0, h), s = s.slice(h), this.parseHost(), this.hostname = this.hostname || "";
        var M = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!M) for(var N = this.hostname.split(/\./), y = 0, z = N.length; y < z; y++){
            var K = N[y];
            if (K && !K.match(JO)) {
                for(var $ = "", ne = 0, ee = K.length; ne < ee; ne++)K.charCodeAt(ne) > 127 ? $ += "x" : $ += K[ne];
                if (!$.match(JO)) {
                    var q = N.slice(0, y), U = N.slice(y + 1), Q = K.match(Pce);
                    Q && (q.push(Q[1]), U.unshift(Q[2])), U.length && (s = "/" + U.join(".") + s), this.hostname = q.join(".");
                    break;
                }
            }
        }
        this.hostname.length > Tce ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), M || (this.hostname = xce.toASCII(this.hostname));
        var v = this.port ? ":" + this.port : "", B = this.hostname || "";
        this.host = B + v, this.href += this.host, M && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s[0] !== "/" && (s = "/" + s));
    }
    if (!Cce[u]) for(var y = 0, z = i4.length; y < z; y++){
        var g = i4[y];
        if (s.indexOf(g) !== -1) {
            var E = encodeURIComponent(g);
            E === g && (E = escape(g)), s = s.split(g).join(E);
        }
    }
    var w = s.indexOf("#");
    w !== -1 && (this.hash = s.substr(w), s = s.slice(0, w));
    var _ = s.indexOf("?");
    if (_ !== -1 ? (this.search = s.substr(_), this.query = s.substr(_ + 1), t && (this.query = a4.parse(this.query)), s = s.slice(0, _)) : t && (this.search = "", this.query = {}), s && (this.pathname = s), Gd[u] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var v = this.pathname || "", O = this.search || "";
        this.path = v + O;
    }
    return this.href = this.format(), this;
};
function Mce(e) {
    return typeof e == "string" && (e = C1(e)), e instanceof Pa ? e.format() : Pa.prototype.format.call(e);
}
Pa.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i1 = !1, o = "";
    this.host ? i1 = e + this.host : this.hostname && (i1 = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i1 += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (o = a4.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1
    }));
    var a = this.search || o && "?" + o || "";
    return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Gd[t]) && i1 !== !1 ? (i1 = "//" + (i1 || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i1 || (i1 = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a && a.charAt(0) !== "?" && (a = "?" + a), r = r.replace(/[?#]/g, function(s) {
        return encodeURIComponent(s);
    }), a = a.replace("#", "%23"), t + i1 + r + a + n;
};
function Nce(e, t) {
    return C1(e, !1, !0).resolve(t);
}
Pa.prototype.resolve = function(e) {
    return this.resolveObject(C1(e, !1, !0)).format();
};
function Rce(e, t) {
    return e ? C1(e, !1, !0).resolveObject(t) : t;
}
Pa.prototype.resolveObject = function(e) {
    if (typeof e == "string") {
        var t = new Pa();
        t.parse(e, !1, !0), e = t;
    }
    for(var r = new Pa(), n = Object.keys(this), i1 = 0; i1 < n.length; i1++){
        var o = n[i1];
        r[o] = this[o];
    }
    if (r.hash = e.hash, e.href === "") return r.href = r.format(), r;
    if (e.slashes && !e.protocol) {
        for(var a = Object.keys(e), s = 0; s < a.length; s++){
            var c = a[s];
            c !== "protocol" && (r[c] = e[c]);
        }
        return Gd[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
    }
    if (e.protocol && e.protocol !== r.protocol) {
        if (!Gd[e.protocol]) {
            for(var l = Object.keys(e), u = 0; u < l.length; u++){
                var f = l[u];
                r[f] = e[f];
            }
            return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !o4[e.protocol]) {
            for(var z = (e.pathname || "").split("/"); z.length && !(e.host = z.shift()););
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), z[0] !== "" && z.unshift(""), z.length < 2 && z.unshift(""), r.pathname = z.join("/");
        } else r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
            var h = r.pathname || "", y = r.search || "";
            r.path = h + y;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    }
    var S = r.pathname && r.pathname.charAt(0) === "/", k = e.host || e.pathname && e.pathname.charAt(0) === "/", P = k || S || r.host && e.pathname, M = P, N = r.pathname && r.pathname.split("/") || [], z = e.pathname && e.pathname.split("/") || [], K = r.protocol && !Gd[r.protocol];
    if (K && (r.hostname = "", r.port = null, r.host && (N[0] === "" ? N[0] = r.host : N.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (z[0] === "" ? z[0] = e.host : z.unshift(e.host)), e.host = null), P = P && (z[0] === "" || N[0] === "")), k) r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, N = z;
    else if (z.length) N || (N = []), N.pop(), N = N.concat(z), r.search = e.search, r.query = e.query;
    else if (e.search != null) {
        if (K) {
            r.host = N.shift(), r.hostname = r.host;
            var $ = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            $ && (r.auth = $.shift(), r.hostname = $.shift(), r.host = r.hostname);
        }
        return r.search = e.search, r.query = e.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
    }
    if (!N.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
    for(var ne = N.slice(-1)[0], ee = (r.host || e.host || N.length > 1) && (ne === "." || ne === "..") || ne === "", q = 0, U = N.length; U >= 0; U--)ne = N[U], ne === "." ? N.splice(U, 1) : ne === ".." ? (N.splice(U, 1), q++) : q && (N.splice(U, 1), q--);
    if (!P && !M) for(; q--; q)N.unshift("..");
    P && N[0] !== "" && (!N[0] || N[0].charAt(0) !== "/") && N.unshift(""), ee && N.join("/").substr(-1) !== "/" && N.push("");
    var Q = N[0] === "" || N[0] && N[0].charAt(0) === "/";
    if (K) {
        r.hostname = Q ? "" : N.length ? N.shift() : "", r.host = r.hostname;
        var $ = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
        $ && (r.auth = $.shift(), r.hostname = $.shift(), r.host = r.hostname);
    }
    return P = P || r.host && N.length, P && !Q && N.unshift(""), N.length > 0 ? r.pathname = N.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
Pa.prototype.parseHost = function() {
    var e = this.host, t = kce.exec(e);
    t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
Kh.parse = C1;
Kh.resolve = Nce;
Kh.resolveObject = Rce;
Kh.format = Mce;
Kh.Url = Pa;
var Uce = Qe && Qe.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i1 = Object.getOwnPropertyDescriptor(t, r);
    (!i1 || ("get" in i1 ? !t.__esModule : i1.writable || i1.configurable)) && (i1 = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i1);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), Dce = Qe && Qe.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), jce = Qe && Qe.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Uce(t, e, r);
    return Dce(t, e), t;
}, Fce = Qe && Qe.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    };
};
Object.defineProperty(vb, "__esModule", {
    value: !0
});
vb.BaseRpc = void 0;
const eI = jce(tu), ly = Fce(Kh), tI = No, rI = (e)=>e.substr(0, 2) === "0x" ? e : "0x" + e;
let nI = 0;
class zce {
    constructor({ baseUrl: t, memshrewUrl: r, headers: n, blockTag: i1 }){
        this.baseUrl = t || "http://localhost:8080", this.memshrewUrl = r || t, this.blockTag = i1 || "latest", this.headers = n || {};
    }
    async _preview({ method: t, input: r }) {
        const n = await (await fetch(ly.default.format({
            ...ly.default.parse(this.memshrewUrl || this.baseUrl),
            pathname: "/"
        }), {})).json();
        if (n.error) {
            const a = new Error(n.error.message);
            throw a.code = n.error.code, a;
        }
        if (n.length === 0) throw Error("no mempool block built by memshrew");
        const i1 = n.result[0], o = await (await fetch(ly.default.format({
            ...ly.default.parse(this.baseUrl),
            pathname: "/"
        }), {
            method: "POST",
            body: JSON.stringify({
                id: nI++,
                jsonrpc: "2.0",
                method: "metashrew_preview",
                params: [
                    i1,
                    t,
                    r,
                    "latest"
                ]
            }),
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        })).json();
        return rI(o.result);
    }
    async _call({ method: t, input: r }, n = "latest") {
        if (n === "pending") return await this._preview({
            method: t,
            input: r
        });
        const i1 = await (await fetch(this.baseUrl, {
            method: "POST",
            body: JSON.stringify({
                id: nI++,
                jsonrpc: "2.0",
                method: "metashrew_view",
                params: [
                    t,
                    r,
                    n || this.blockTag
                ]
            }),
            headers: Object.assign({}, {
                "Content-Type": "application/json",
                Accept: "application/json"
            }, this.headers)
        })).json();
        return rI(i1.result);
    }
    async runesbyaddress({ address: t }, r = "latest") {
        const n = eI.encodeWalletInput(t), i1 = await this._call({
            method: "runesbyaddress",
            input: n
        }, r);
        return eI.decodeWalletOutput(i1);
    }
    async runesbyheight({ height: t }, r = "latest") {
        const n = (0, tI.encodeBlockHeightInput)(t), i1 = await this._call({
            method: "runesbyheight",
            input: n
        }, r);
        return (0, tI.decodeRunesResponse)(i1);
    }
}
vb.BaseRpc = zce;
var Oo = {}, wn = {}, ui = {}, I5 = {}, Ti = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.isNone = e.isSome = e.None = e.Some = e.OptionType = void 0, e.OptionType = {
        Some: Symbol(":some"),
        None: Symbol(":none")
    };
    class t {
        constructor(s){
            this.val = s;
        }
        get type() {
            return e.OptionType.Some;
        }
        isSome() {
            return !0;
        }
        isNone() {
            return !1;
        }
        match(s) {
            return s.some(this.val);
        }
        map(s) {
            return n(s(this.val));
        }
        inspect(s) {
            return s(this.val), this;
        }
        andThen(s) {
            return s(this.val);
        }
        or(s) {
            return this;
        }
        orElse(s) {
            return this;
        }
        and(s) {
            return s;
        }
        unwrapOr(s) {
            return this.val;
        }
        unwrap() {
            return this.val;
        }
    }
    class r {
        get type() {
            return e.OptionType.None;
        }
        isSome() {
            return !1;
        }
        isNone() {
            return !0;
        }
        match({ none: s }) {
            return typeof s == "function" ? s() : s;
        }
        map(s) {
            return new r();
        }
        inspect(s) {
            return this;
        }
        andThen(s) {
            return new r();
        }
        or(s) {
            return s;
        }
        orElse(s) {
            return s();
        }
        and(s) {
            return new r();
        }
        unwrapOr(s) {
            return s;
        }
        unwrap() {
            throw new ReferenceError("Trying to unwrap None.");
        }
    }
    function n(a) {
        return new t(a);
    }
    e.Some = n, e.None = new r();
    function i1(a) {
        return a.isSome();
    }
    e.isSome = i1;
    function o(a) {
        return a.isNone();
    }
    e.isNone = o;
})(Ti);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u8 = e.U8_MAX_BIGINT = void 0;
    const t = Ti;
    e.U8_MAX_BIGINT = 0xffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U8_MAX_BIGINT;
    }
    e.u8 = r, function(n) {
        n.MAX = n(e.U8_MAX_BIGINT);
        function i1(a, s) {
            const c = a + s;
            return c > n.MAX ? t.None : (0, t.Some)(n(c));
        }
        n.checkedAdd = i1;
        function o(a, s) {
            const c = a - s;
            return c < 0n ? t.None : (0, t.Some)(n(c));
        }
        n.checkedSub = o;
    }(r || (e.u8 = r = {}));
})(I5);
var B5 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u32 = e.U32_MAX_BIGINT = void 0;
    const t = Ti;
    e.U32_MAX_BIGINT = 0xffffffffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U32_MAX_BIGINT;
    }
    e.u32 = r, function(n) {
        n.MAX = n(e.U32_MAX_BIGINT);
        function i1(a, s) {
            const c = a + s;
            return c > n.MAX ? t.None : (0, t.Some)(n(c));
        }
        n.checkedAdd = i1;
        function o(a, s) {
            const c = a - s;
            return c < 0n ? t.None : (0, t.Some)(n(c));
        }
        n.checkedSub = o;
    }(r || (e.u32 = r = {}));
})(B5);
var T5 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u64 = e.U64_MAX_BIGINT = void 0;
    const t = Ti;
    e.U64_MAX_BIGINT = 0xffffffffffffffffn;
    function r(n) {
        return (typeof n == "bigint" ? n : BigInt(n)) & e.U64_MAX_BIGINT;
    }
    e.u64 = r, function(n) {
        n.MAX = n(e.U64_MAX_BIGINT);
        function i1(a, s) {
            const c = a + s;
            return c > n.MAX ? t.None : (0, t.Some)(n(c));
        }
        n.checkedAdd = i1;
        function o(a, s) {
            const c = a - s;
            return c < 0n ? t.None : (0, t.Some)(n(c));
        }
        n.checkedSub = o;
    }(r || (e.u64 = r = {}));
})(T5);
var Jp = {}, M1 = {};
Object.defineProperty(M1, "__esModule", {
    value: !0
});
M1.SeekBuffer = void 0;
class Lce {
    constructor(t){
        this.buffer = t, this.seekIndex = 0;
    }
    readUInt8() {
        if (!this.isFinished()) return this.buffer.readUInt8(this.seekIndex++);
    }
    isFinished() {
        return this.seekIndex >= this.buffer.length;
    }
}
M1.SeekBuffer = Lce;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getAllU128 = e.u128 = e.U128_MAX_BIGINT = void 0;
    const t = Ti, r = M1, n = T5, i1 = B5, o = I5;
    e.U128_MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
    function a(c) {
        return (typeof c == "bigint" ? c : BigInt(c)) & e.U128_MAX_BIGINT;
    }
    e.u128 = a, function(c) {
        c.MAX = c(e.U128_MAX_BIGINT);
        function l(ee, q) {
            const U = ee + q;
            return U > c.MAX ? t.None : (0, t.Some)(c(U));
        }
        c.checkedAdd = l;
        function u(ee, q) {
            const U = c.checkedAdd(ee, q);
            if (U.isNone()) throw new Error("checked add overflow");
            return U.unwrap();
        }
        c.checkedAddThrow = u;
        function f(ee, q) {
            const U = ee - q;
            return U < 0n ? t.None : (0, t.Some)(c(U));
        }
        c.checkedSub = f;
        function h(ee, q) {
            const U = c.checkedSub(ee, q);
            if (U.isNone()) throw new Error("checked sub overflow");
            return U.unwrap();
        }
        c.checkedSubThrow = h;
        function y(ee, q) {
            const U = ee * q;
            return U > c.MAX ? t.None : (0, t.Some)(c(U));
        }
        c.checkedMultiply = y;
        function S(ee, q) {
            const U = ee + q;
            return U > c.MAX ? c.MAX : c(U);
        }
        c.saturatingAdd = S;
        function k(ee, q) {
            const U = ee * q;
            return U > c.MAX ? c.MAX : c(U);
        }
        c.saturatingMultiply = k;
        function P(ee, q) {
            return c(ee < q ? 0 : ee - q);
        }
        c.saturatingSub = P;
        function M(ee) {
            try {
                return (0, t.Some)(N(ee));
            } catch  {
                return t.None;
            }
        }
        c.decodeVarInt = M;
        function N(ee) {
            let q = c(0);
            for(let U = 0; U <= 18; U++){
                const Q = ee.readUInt8();
                if (Q === void 0) throw new Error("Unterminated");
                const v = c(Q) & 127n;
                if (U === 18 && (v & 124n) !== 0n) throw new Error("Overflow");
                if (q = c(q | v << c(7 * U)), !(Q & 128)) return q;
            }
            throw new Error("Overlong");
        }
        c.tryDecodeVarInt = N;
        function z(ee) {
            const q = [];
            for(; ee >> 7n > 0n;)q.push(Number(ee & 0xffn) | 128), ee = c(ee >> 7n);
            return q.push(Number(ee & 0xffn)), Ke.from(q);
        }
        c.encodeVarInt = z;
        function K(ee) {
            return ee > n.u64.MAX ? t.None : (0, t.Some)((0, n.u64)(ee));
        }
        c.tryIntoU64 = K;
        function $(ee) {
            return ee > i1.u32.MAX ? t.None : (0, t.Some)((0, i1.u32)(ee));
        }
        c.tryIntoU32 = $;
        function ne(ee) {
            return ee > o.u8.MAX ? t.None : (0, t.Some)((0, o.u8)(ee));
        }
        c.tryIntoU8 = ne;
    }(a || (e.u128 = a = {}));
    function* s(c) {
        const l = new r.SeekBuffer(c);
        for(; !l.isFinished();){
            const u = a.tryDecodeVarInt(l);
            if (u === void 0) return;
            yield u;
        }
    }
    e.getAllU128 = s;
})(Jp);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.u128 = e.u64 = e.u32 = e.u8 = void 0;
    var t = I5;
    Object.defineProperty(e, "u8", {
        enumerable: !0,
        get: function() {
            return t.u8;
        }
    });
    var r = B5;
    Object.defineProperty(e, "u32", {
        enumerable: !0,
        get: function() {
            return r.u32;
        }
    });
    var n = T5;
    Object.defineProperty(e, "u64", {
        enumerable: !0,
        get: function() {
            return n.u64;
        }
    });
    var i1 = Jp;
    Object.defineProperty(e, "u128", {
        enumerable: !0,
        get: function() {
            return i1.u128;
        }
    });
})(ui);
var Du = {};
Object.defineProperty(Du, "__esModule", {
    value: !0
});
Du.script = Du.opcodes = void 0;
var e0;
(function(e) {
    function t(i1) {
        return i1 < _a.OP_PUSHDATA1 ? 1 : i1 <= 255 ? 2 : i1 <= 65535 ? 3 : 5;
    }
    e.encodingLength = t;
    function r(i1, o, a) {
        const s = t(o);
        return s === 1 ? i1.writeUInt8(o, a) : s === 2 ? (i1.writeUInt8(_a.OP_PUSHDATA1, a), i1.writeUInt8(o, a + 1)) : s === 3 ? (i1.writeUInt8(_a.OP_PUSHDATA2, a), i1.writeUInt16LE(o, a + 1)) : (i1.writeUInt8(_a.OP_PUSHDATA4, a), i1.writeUInt32LE(o, a + 1)), s;
    }
    e.encode = r;
    function n(i1, o) {
        const a = i1.readUInt8(o);
        let s, c;
        if (a < _a.OP_PUSHDATA1) s = a, c = 1;
        else if (a === _a.OP_PUSHDATA1) {
            if (o + 2 > i1.length) return null;
            s = i1.readUInt8(o + 1), c = 2;
        } else if (a === _a.OP_PUSHDATA2) {
            if (o + 3 > i1.length) return null;
            s = i1.readUInt16LE(o + 1), c = 3;
        } else {
            if (o + 5 > i1.length) return null;
            if (a !== _a.OP_PUSHDATA4) throw new Error("Unexpected opcode");
            s = i1.readUInt32LE(o + 1), c = 5;
        }
        return {
            opcode: a,
            number: s,
            size: c
        };
    }
    e.decode = n;
})(e0 || (e0 = {}));
const _a = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
};
Du.opcodes = _a;
_a.OP_RESERVED;
function iI(e) {
    return Ke.isBuffer(e);
}
var oI;
(function(e) {
    function t(n) {
        const i1 = n.reduce((s, c)=>iI(c) ? s + e0.encodingLength(c.length) + c.length : s + 1, 0), o = Ke.allocUnsafe(i1);
        let a = 0;
        if (n.forEach((s)=>{
            iI(s) ? (a += e0.encode(o, s.length, a), s.copy(o, a), a += s.length) : (o.writeUInt8(s, a), a += 1);
        }), a !== o.length) throw new Error("Could not decode chunks");
        return o;
    }
    e.compile = t;
    function* r(n) {
        let i1 = 0;
        for(; i1 < n.length;){
            const o = n[i1];
            if (o >= _a.OP_0 && o <= _a.OP_PUSHDATA4) {
                const a = e0.decode(n, i1);
                if (a === null || (i1 += a.size, i1 + a.number > n.length)) return !1;
                const s = n.slice(i1, i1 + a.number);
                i1 += a.number, yield s;
            } else yield o, i1 += 1;
        }
        return !0;
    }
    e.decompile = r;
})(oI || (Du.script = oI = {}));
Object.defineProperty(wn, "__esModule", {
    value: !0
});
wn.TAPROOT_SCRIPT_PUBKEY_TYPE = wn.COMMIT_CONFIRMATIONS = wn.TAPROOT_ANNEX_PREFIX = wn.MAGIC_NUMBER = wn.OP_RETURN = wn.MAX_SCRIPT_ELEMENT_SIZE = wn.SUBSIDY_HALVING_INTERVAL = wn.RESERVED = wn.MAX_DIVISIBILITY = void 0;
const tR = ui, rR = Du;
wn.MAX_DIVISIBILITY = (0, tR.u8)(38);
wn.RESERVED = (0, tR.u128)(6402364363415443603228541259936211926n);
wn.SUBSIDY_HALVING_INTERVAL = 21e4;
wn.MAX_SCRIPT_ELEMENT_SIZE = 520;
wn.OP_RETURN = rR.opcodes.OP_RETURN;
wn.MAGIC_NUMBER = rR.opcodes.OP_13;
wn.TAPROOT_ANNEX_PREFIX = 80;
wn.COMMIT_CONFIRMATIONS = 6;
wn.TAPROOT_SCRIPT_PUBKEY_TYPE = "witness_v1_taproot";
var Vh = {};
Object.defineProperty(Vh, "__esModule", {
    value: !0
});
var nR = Vh.ProtoruneRuneId = void 0;
const Ss = Ti, xs = ui;
class t0 {
    constructor(t, r){
        this.block = t, this.tx = r;
    }
    static new(t, r) {
        const n = new t0(t, r);
        return n.block === (0, xs.u128)(0) && n.tx > (0, xs.u128)(0) ? Ss.None : (0, Ss.Some)(n);
    }
    static sort(t) {
        return [
            ...t
        ].sort((r, n)=>Number(r.block - n.block || r.tx - n.tx));
    }
    delta(t) {
        const r = xs.u128.checkedSub(t.block, this.block);
        if (r.isNone()) return Ss.None;
        const n = r.unwrap();
        let i1;
        if (n === 0n) {
            const o = xs.u128.checkedSub(t.tx, this.tx);
            if (o.isNone()) return Ss.None;
            i1 = o.unwrap();
        } else i1 = t.tx;
        return (0, Ss.Some)([
            (0, xs.u128)(n),
            (0, xs.u128)(i1)
        ]);
    }
    next(t, r) {
        const n = (0, Ss.Some)(t), i1 = (0, Ss.Some)(r);
        if (n.isNone() || i1.isNone()) return Ss.None;
        const o = n.unwrap(), a = i1.unwrap(), s = xs.u128.checkedAdd(this.block, o);
        if (s.isNone()) return Ss.None;
        let c;
        if (o === 0n) {
            const l = xs.u128.checkedAdd(this.tx, a);
            if (l.isNone()) return Ss.None;
            c = l.unwrap();
        } else c = a;
        return t0.new(s.unwrap(), c);
    }
    toString() {
        return `${this.block}:${this.tx}`;
    }
    static fromString(t) {
        const r = t.split(":");
        if (r.length !== 2) throw new Error(`invalid rune ID: ${t}`);
        const [n, i1] = r;
        if (!/^\d+$/.test(n) || !/^\d+$/.test(i1)) throw new Error(`invalid rune ID: ${t}`);
        return new t0((0, xs.u128)(BigInt(n)), (0, xs.u128)(BigInt(i1)));
    }
}
nR = Vh.ProtoruneRuneId = t0;
var Wh = {};
Object.defineProperty(Wh, "__esModule", {
    value: !0
});
Wh.Etching = void 0;
const aI = Ti, _p = ui;
class Hce {
    constructor(t, r, n, i1, o, a, s){
        this.divisibility = t, this.rune = r, this.spacers = n, this.terms = o, this.premine = a, this.turbo = s, this.symbol = i1.andThen((c)=>{
            const l = c.codePointAt(0);
            return l !== void 0 ? (0, aI.Some)(String.fromCodePoint(l)) : aI.None;
        });
    }
    get supply() {
        const t = this.premine.unwrapOr((0, _p.u128)(0)), r = this.terms.andThen((i1)=>i1.cap).unwrapOr((0, _p.u128)(0)), n = this.terms.andThen((i1)=>i1.amount).unwrapOr((0, _p.u128)(0));
        return _p.u128.checkedMultiply(r, n).andThen((i1)=>_p.u128.checkedAdd(t, i1));
    }
}
Wh.Etching = Hce;
var Df = {};
Object.defineProperty(Df, "__esModule", {
    value: !0
});
Df.Tag = void 0;
const fy = Ti, yd = ui;
var Mm;
(function(e) {
    e[e.BODY = 0] = "BODY", e[e.FLAGS = 2] = "FLAGS", e[e.RUNE = 4] = "RUNE", e[e.PREMINE = 6] = "PREMINE", e[e.CAP = 8] = "CAP", e[e.AMOUNT = 10] = "AMOUNT", e[e.HEIGHT_START = 12] = "HEIGHT_START", e[e.HEIGHT_END = 14] = "HEIGHT_END", e[e.OFFSET_START = 16] = "OFFSET_START", e[e.OFFSET_END = 18] = "OFFSET_END", e[e.MINT = 20] = "MINT", e[e.POINTER = 22] = "POINTER", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.DIVISIBILITY = 1] = "DIVISIBILITY", e[e.SPACERS = 3] = "SPACERS", e[e.SYMBOL = 5] = "SYMBOL", e[e.NOP = 127] = "NOP";
})(Mm || (Df.Tag = Mm = {}));
(function(e) {
    function t(i1, o, a, s) {
        const c = o.get((0, yd.u128)(i1));
        if (c === void 0) return fy.None;
        const l = [];
        for (const f of [
            ...Array(a).keys()
        ]){
            if (c[f] === void 0) return fy.None;
            l[f] = c[f];
        }
        const u = s(l);
        return u.isNone() ? fy.None : (c.splice(0, a), c.length === 0 && o.delete((0, yd.u128)(i1)), (0, fy.Some)(u.unwrap()));
    }
    e.take = t;
    function r(i1, o) {
        return Ke.concat(o.map((a)=>[
                yd.u128.encodeVarInt((0, yd.u128)(i1)),
                yd.u128.encodeVarInt(a)
            ]).flat());
    }
    e.encode = r;
    function n(i1, o) {
        return o.map((a)=>e.encode(i1, [
                (0, yd.u128)(a)
            ])).unwrapOr(Ke.alloc(0));
    }
    e.encodeOptionInt = n;
})(Mm || (Df.Tag = Mm = {}));
var Gh = {};
Object.defineProperty(Gh, "__esModule", {
    value: !0
});
Gh.Tag = void 0;
const md = ui, dy = Ti;
var Nm;
(function(e) {
    e[e.BODY = 0] = "BODY", e[e.PROTOCOL = 16383] = "PROTOCOL", e[e.MESSAGE = 81] = "MESSAGE", e[e.BURN = 83] = "BURN", e[e.SPLIT = 85] = "SPLIT", e[e.POINTER = 91] = "POINTER", e[e.REFUND = 93] = "REFUND", e[e.FROM = 95] = "FROM", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.NOP = 127] = "NOP";
})(Nm || (Gh.Tag = Nm = {}));
(function(e) {
    function t(i1, o, a, s) {
        const c = o.get((0, md.u128)(i1));
        if (c === void 0) return dy.None;
        const l = [];
        for (const f of [
            ...Array(a).keys()
        ]){
            if (c[f] === void 0) return dy.None;
            l[f] = c[f];
        }
        const u = s(l);
        return u.isNone() ? dy.None : (c.splice(0, a), c.length === 0 && o.delete((0, md.u128)(i1)), (0, dy.Some)(u.unwrap()));
    }
    e.take = t;
    function r(i1, o) {
        return Ke.concat(o.map((a)=>[
                md.u128.encodeVarInt((0, md.u128)(i1)),
                md.u128.encodeVarInt(a)
            ]).flat());
    }
    e.encode = r;
    function n(i1, o) {
        return o.map((a)=>e.encode(i1, [
                (0, md.u128)(a)
            ])).unwrapOr(Ke.alloc(0));
    }
    e.encodeOptionInt = n;
})(Nm || (Gh.Tag = Nm = {}));
var Qh = {};
Object.defineProperty(Qh, "__esModule", {
    value: !0
});
Qh.Flag = void 0;
const R3 = ui;
var Rm;
(function(e) {
    e[e.ETCHING = 0] = "ETCHING", e[e.TERMS = 1] = "TERMS", e[e.TURBO = 2] = "TURBO", e[e.CENOTAPH = 127] = "CENOTAPH";
})(Rm || (Qh.Flag = Rm = {}));
(function(e) {
    function t(i1) {
        return (0, R3.u128)(1n << BigInt(i1));
    }
    e.mask = t;
    function r(i1, o) {
        const a = e.mask(o), s = (i1 & a) !== 0n;
        return {
            set: s,
            flags: s ? (0, R3.u128)(i1 - a) : i1
        };
    }
    e.take = r;
    function n(i1, o) {
        return (0, R3.u128)(i1 | e.mask(o));
    }
    e.set = n;
})(Rm || (Qh.Flag = Rm = {}));
var $h = {}, Zh = {}, jf = {};
Object.defineProperty(jf, "__esModule", {
    value: !0
});
jf.Network = void 0;
const hy = wn;
var Um;
(function(e) {
    e[e.MAINNET = 0] = "MAINNET", e[e.SIGNET = 1] = "SIGNET", e[e.TESTNET = 2] = "TESTNET", e[e.REGTEST = 3] = "REGTEST";
})(Um || (jf.Network = Um = {}));
(function(e) {
    function t(r) {
        switch(r){
            case e.MAINNET:
                return hy.SUBSIDY_HALVING_INTERVAL * 4;
            case e.REGTEST:
                return hy.SUBSIDY_HALVING_INTERVAL * 0;
            case e.SIGNET:
                return hy.SUBSIDY_HALVING_INTERVAL * 0;
            case e.TESTNET:
                return hy.SUBSIDY_HALVING_INTERVAL * 12;
        }
    }
    e.getFirstRuneHeight = t;
})(Um || (jf.Network = Um = {}));
Object.defineProperty(Zh, "__esModule", {
    value: !0
});
Zh.Rune = void 0;
const Kce = jf, py = wn, Kt = ui;
class $a {
    constructor(t){
        this.value = t;
    }
    static getMinimumAtHeight(t, r) {
        let n = Kt.u128.saturatingAdd(r, (0, Kt.u128)(1));
        const i1 = (0, Kt.u128)(py.SUBSIDY_HALVING_INTERVAL / 12);
        let o = (0, Kt.u128)(Kce.Network.getFirstRuneHeight(t)), a = Kt.u128.saturatingAdd(o, (0, Kt.u128)(py.SUBSIDY_HALVING_INTERVAL));
        if (n < o) return new $a($a.STEPS[12]);
        if (n >= a) return new $a((0, Kt.u128)(0));
        let s = Kt.u128.saturatingSub(n, o), c = Kt.u128.saturatingSub((0, Kt.u128)(12n), (0, Kt.u128)(s / i1)), l = Number(c & (0, Kt.u128)(Kt.u32.MAX)), u = $a.STEPS[l], f = $a.STEPS[l - 1], h = (0, Kt.u128)(s % i1);
        return new $a((0, Kt.u128)(u - (u - f) * h / i1));
    }
    get reserved() {
        return this.value >= py.RESERVED;
    }
    get commitment() {
        const t = Ke.alloc(16);
        t.writeBigUInt64LE(0xffffffffffffffffn & this.value, 0), t.writeBigUInt64LE(this.value >> 64n, 8);
        let r = t.length;
        for(; r > 0 && t.at(r - 1) === 0;)r--;
        return t.subarray(0, r);
    }
    static getReserved(t, r) {
        return new $a(Kt.u128.checkedAdd(py.RESERVED, (0, Kt.u128)(t << 32n | r)).unwrap());
    }
    toString() {
        let t = this.value;
        if (t === Kt.u128.MAX) return "BCGDENLQRQWDSLRUGSNLBTMFIJAV";
        t = (0, Kt.u128)(t + 1n);
        let r = "";
        for(; t > 0;)r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Number((t - 1n) % 26n)] + r, t = (0, Kt.u128)((t - 1n) / 26n);
        return r;
    }
    static fromString(t) {
        let r = (0, Kt.u128)(0);
        for (const n of [
            ...Array(t.length).keys()
        ]){
            const i1 = t[n];
            if (n > 0 && (r = (0, Kt.u128)(r + 1n)), r = Kt.u128.checkedMultiply(r, (0, Kt.u128)(26)).unwrap(), "A" <= i1 && i1 <= "Z") r = Kt.u128.checkedAdd(r, (0, Kt.u128)(i1.charCodeAt(0) - 65)).unwrap();
            else throw new Error(`invalid character in rune name: ${i1}`);
        }
        return new $a(r);
    }
}
Zh.Rune = $a;
$a.STEPS = [
    (0, Kt.u128)(0n),
    (0, Kt.u128)(26n),
    (0, Kt.u128)(702n),
    (0, Kt.u128)(18278n),
    (0, Kt.u128)(475254n),
    (0, Kt.u128)(12356630n),
    (0, Kt.u128)(321272406n),
    (0, Kt.u128)(8353082582n),
    (0, Kt.u128)(217180147158n),
    (0, Kt.u128)(5646683826134n),
    (0, Kt.u128)(146813779479510n),
    (0, Kt.u128)(3817158266467286n),
    (0, Kt.u128)(99246114928149462n),
    (0, Kt.u128)(2580398988131886038n),
    (0, Kt.u128)(67090373691429037014n),
    (0, Kt.u128)(1744349715977154962390n),
    (0, Kt.u128)(45353092615406029022166n),
    (0, Kt.u128)(1179180408000556754576342n),
    (0, Kt.u128)(30658690608014475618984918n),
    (0, Kt.u128)(797125955808376366093607894n),
    (0, Kt.u128)(20725274851017785518433805270n),
    (0, Kt.u128)(538857146126462423479278937046n),
    (0, Kt.u128)(14010285799288023010461252363222n),
    (0, Kt.u128)(364267430781488598271992561443798n),
    (0, Kt.u128)(9470953200318703555071806597538774n),
    (0, Kt.u128)(246244783208286292431866971536008150n),
    (0, Kt.u128)(6402364363415443603228541259936211926n),
    (0, Kt.u128)(166461473448801533683942072758341510102n)
];
Object.defineProperty($h, "__esModule", {
    value: !0
});
$h.SpacedRune = void 0;
const qce = Zh;
class P5 {
    constructor(t, r){
        this.rune = t, this.spacers = r;
    }
    static fromString(t) {
        let r = "", n = 0;
        for (const i1 of t)if ("A" <= i1 && i1 <= "Z") r += i1;
        else if (i1 === "." || i1 === "") {
            if (r.length === 0) throw new Error("leading spacer");
            const o = 1 << r.length - 1;
            if (n & o) throw new Error("double spacer");
            n |= o;
        } else throw new Error("invalid character");
        if (n >= 1 << r.length - 1) throw new Error("trailing spacer");
        return new P5(qce.Rune.fromString(r), n);
    }
    toString() {
        const t = this.rune.toString();
        let r = 0, n = "";
        for (const i1 of t)n += i1, r < t.length - 1 && this.spacers & 1 << r && (n += ""), r++;
        return n;
    }
}
$h.SpacedRune = P5;
Object.defineProperty(Oo, "__esModule", {
    value: !0
});
Oo.RunestoneProtostoneUpgrade = Oo.MAX_U128_BYTES_COMPAT_W_RUNES = Oo.MAX_LEB128_BYTES_IN_U128 = Oo.MAX_SPACERS = void 0;
Oo.isValidPayload = $ce;
Oo.encodeOptionInt = qo;
Oo.encodeRunestoneProtostone = Xce;
const Nd = wn, s4 = Vh, Vce = Wh, Di = Df, Wce = Gh, yn = ui, Wr = Ti, bd = Qh, Gce = Du, Qce = $h, U3 = rn;
Oo.MAX_SPACERS = 134217727;
function $ce(e) {
    return Ke.isBuffer(e);
}
function qo(e, t, r) {
    r.isSome() && (e.push(t), e.push(r.unwrap()));
}
Oo.MAX_LEB128_BYTES_IN_U128 = 18;
Oo.MAX_U128_BYTES_COMPAT_W_RUNES = 15;
class iR {
    constructor(t, r, n, i1, o){
        this.mint = t, this.pointer = r, this.edicts = n, this.etching = i1, this.protostones = o;
    }
    // removed decipher function -- can add it back if needed
    encipher() {
        const t = [];
        if (this.etching.isSome()) {
            const i1 = this.etching.unwrap();
            let o = (0, yn.u128)(0);
            if (o = bd.Flag.set(o, bd.Flag.ETCHING), i1.terms.isSome() && (o = bd.Flag.set(o, bd.Flag.TERMS)), i1.turbo && (o = bd.Flag.set(o, bd.Flag.TURBO)), t.push(Di.Tag.FLAGS), t.push(o), qo(t, Di.Tag.RUNE, i1.rune.map((a)=>a.value)), qo(t, Di.Tag.DIVISIBILITY, i1.divisibility.map(yn.u128)), qo(t, Di.Tag.SYMBOL, i1.spacers.map(yn.u128)), qo(t, Di.Tag.SYMBOL, i1.symbol.map((a)=>(0, yn.u128)(a.codePointAt(0)))), qo(t, Di.Tag.PREMINE, i1.premine), i1.terms.isSome()) {
                const a = i1.terms.unwrap();
                qo(t, Di.Tag.AMOUNT, a.amount), qo(t, Di.Tag.CAP, a.cap), qo(t, Di.Tag.HEIGHT_START, a.height[0]), qo(t, Di.Tag.HEIGHT_END, a.height[1]), qo(t, Di.Tag.OFFSET_START, a.offset[0]), qo(t, Di.Tag.OFFSET_END, a.offset[1]);
            }
        }
        if (this.mint.isSome()) {
            const i1 = this.mint.unwrap();
            t.push(Di.Tag.MINT), t.push((0, yn.u128)(i1.block)), t.push(Di.Tag.MINT), t.push((0, yn.u128)(i1.tx));
        }
        if (qo(t, Di.Tag.POINTER, this.pointer.map(yn.u128)), this.protostones.length) {
            let i1 = [];
            this.protostones.forEach((o)=>{
                o.encipher_payloads().forEach((a)=>i1.push(a));
            }), (0, U3.unpack)((0, U3.encipher)(i1)).forEach((o)=>{
                t.push((0, yn.u128)(Wce.Tag.PROTOCOL)), t.push((0, yn.u128)(o));
            });
        }
        if (this.edicts.length) {
            t.push((0, yn.u128)(Di.Tag.BODY));
            const i1 = [
                ...this.edicts
            ].sort((a, s)=>Number(a.id.block - s.id.block || a.id.tx - s.id.tx));
            let o = new s4.ProtoruneRuneId((0, yn.u128)(0), (0, yn.u128)(0));
            for (const a of i1){
                const [s, c] = o.delta(a.id).unwrap();
                t.push(s), t.push(c), t.push(a.amount), t.push((0, yn.u128)(a.output)), o = a.id;
            }
        }
        const r = [];
        r.push(Nd.OP_RETURN), r.push(Nd.MAGIC_NUMBER);
        const n = (0, U3.encipher)(t);
        for(let i1 = 0; i1 < n.length; i1 += Nd.MAX_SCRIPT_ELEMENT_SIZE)r.push(n.subarray(i1, i1 + Nd.MAX_SCRIPT_ELEMENT_SIZE));
        return Gce.script.compile(r);
    }
}
Oo.RunestoneProtostoneUpgrade = iR;
const Zce = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > yn.u8.MAX) throw Error("u8 overflow");
    return (0, yn.u8)(t);
}, sI = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > yn.u32.MAX) throw Error("u32 overflow");
    return (0, yn.u32)(t);
}, gy = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > yn.u64.MAX) throw Error("u64 overflow");
    return (0, yn.u64)(t);
}, yy = (e)=>{
    const t = BigInt(e);
    if (t < 0n || t > yn.u128.MAX) throw Error("u128 overflow");
    return (0, yn.u128)(t);
};
function Xce(e) {
    const t = e.mint ? (0, Wr.Some)(new s4.ProtoruneRuneId((0, yn.u128)(e.mint.block), (0, yn.u128)(e.mint.tx))) : Wr.None, r = e.pointer !== void 0 ? (0, Wr.Some)(e.pointer).map(sI) : Wr.None, n = (e.edicts ?? []).map((s)=>({
            id: new s4.ProtoruneRuneId((0, yn.u128)(s.id.block), (0, yn.u128)(s.id.tx)),
            amount: yy(s.amount),
            output: s.output
        })), i1 = e.protostones ?? [];
    let o = Wr.None, a;
    if (e.etching) {
        const s = e.etching, c = s.runeName ? Qce.SpacedRune.fromString(s.runeName) : void 0, l = (c == null ? void 0 : c.rune) !== void 0 ? (0, Wr.Some)(c.rune) : Wr.None;
        if (s.symbol && !(s.symbol.length === 1 || s.symbol.length === 2 && s.symbol.codePointAt(0) >= 65536)) throw Error("Symbol must be one code point");
        const u = s.divisibility !== void 0 ? (0, Wr.Some)(s.divisibility).map(Zce) : Wr.None, f = s.premine !== void 0 ? (0, Wr.Some)(s.premine).map(yy) : Wr.None, h = (c == null ? void 0 : c.spacers) !== void 0 && c.spacers !== 0 ? (0, Wr.Some)(sI(c.spacers)) : Wr.None, y = s.symbol ? (0, Wr.Some)(s.symbol) : Wr.None;
        if (u.isSome() && u.unwrap() > Nd.MAX_DIVISIBILITY) throw Error(`Divisibility is greater than protocol max ${Nd.MAX_DIVISIBILITY}`);
        let S = Wr.None;
        if (s.terms) {
            const P = s.terms, M = P.amount !== void 0 ? (0, Wr.Some)(P.amount).map(yy) : Wr.None, N = P.cap !== void 0 ? (0, Wr.Some)(P.cap).map(yy) : Wr.None, z = P.height ? [
                P.height.start !== void 0 ? (0, Wr.Some)(P.height.start).map(gy) : Wr.None,
                P.height.end !== void 0 ? (0, Wr.Some)(P.height.end).map(gy) : Wr.None
            ] : [
                Wr.None,
                Wr.None
            ], K = P.offset ? [
                P.offset.start !== void 0 ? (0, Wr.Some)(P.offset.start).map(gy) : Wr.None,
                P.offset.end !== void 0 ? (0, Wr.Some)(P.offset.end).map(gy) : Wr.None
            ] : [
                Wr.None,
                Wr.None
            ];
            if (M.isSome() && N.isSome() && M.unwrap() * N.unwrap() > yn.u128.MAX) throw Error("Terms overflow with amount times cap");
            S = (0, Wr.Some)({
                amount: M,
                cap: N,
                height: z,
                offset: K
            });
        }
        const k = s.turbo ?? !1;
        o = (0, Wr.Some)(new Vce.Etching(u, l, h, y, S, f, k)), a = l.isSome() ? l.unwrap().commitment : void 0;
    }
    return {
        encodedRunestone: new iR(t, r, n, o, i1).encipher(),
        etchingCommitment: a
    };
}
var N1 = {};
Object.defineProperty(N1, "__esModule", {
    value: !0
});
N1.ProtoStone = void 0;
const Dn = ui, wd = Gh, D3 = Ti, Yce = Vh, Jce = rn;
class r0 {
    constructor({ burn: t, message: r, protocolTag: n, edicts: i1 }){
        this.protocolTag = (0, Dn.u128)(n), this.edicts = i1, t && (this.burn = {
            pointer: (0, D3.Some)((0, Dn.u32)(t.pointer)),
            from: t.from
        }), r && (this.message = {
            calldata: r.calldata,
            pointer: (0, D3.Some)((0, Dn.u32)(r.pointer)),
            refundPointer: (0, D3.Some)((0, Dn.u32)(r.refundPointer))
        });
    }
    // Enciphering a protostone doesn't make sense, removed this functionality
    // encipher() {
    //   const stack: (Buffer | number)[] = [];
    //   let payloads: Buffer[] = [];
    //   stack.push(OP_RETURN);
    //   if (this.burn) {
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.POINTER, this.burn.pointer.map(u128)),
    //     );
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.BURN, Some<u128>(this.protocolTag)),
    //     );
    //     stack.push(opcodes.OP_14);
    //   } else if (this.message) {
    //     payloads.push(u128.encodeVarInt(this.protocolTag));
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.POINTER, this.message.pointer.map(u128)),
    //     );
    //     payloads.push(
    //       Tag.encodeOptionInt(Tag.REFUND, this.message.refundPointer.map(u128)),
    //     );
    //     payloads.push(Tag.encode(Tag.MESSAGE, this.message.calldata));
    //     stack.push(opcodes.OP_16);
    //   } else if (this.split) {
    //     payloads.push(Tag.encode(Tag.SPLIT, this.split.order.map(u128)));
    //     stack.push(opcodes.OP_16);
    //   } else if (this.chunk) {
    //     payloads.push(this.chunk);
    //     stack.push(opcodes.OP_15);
    //   }
    //   const payload = Buffer.concat(payloads);
    //   for (let i = 0; i < payload.length; i += MAX_SCRIPT_ELEMENT_SIZE) {
    //     stack.push(payload.subarray(i, i + MAX_SCRIPT_ELEMENT_SIZE));
    //   }
    //   return script.compile(stack);
    // }
    encipher_payloads() {
        let t = [];
        if (this.burn ? (t.push((0, Dn.u128)(wd.Tag.POINTER)), t.push(this.burn.pointer.map(Dn.u128).unwrap()), this.burn.from && (t.push((0, Dn.u128)(wd.Tag.FROM)), t.push(this.burn.from.map(Dn.u128)[0]))) : this.message && (this.message.pointer.isSome() && (t.push((0, Dn.u128)(wd.Tag.POINTER)), t.push((0, Dn.u128)(this.message.pointer.map(Dn.u128).unwrap()))), this.message.refundPointer.isSome() && (t.push((0, Dn.u128)(wd.Tag.REFUND)), t.push((0, Dn.u128)(this.message.refundPointer.map(Dn.u128).unwrap()))), this.message.calldata.length && (0, Jce.unpack)(this.message.calldata).forEach((n)=>{
            t.push((0, Dn.u128)(wd.Tag.MESSAGE)), t.push((0, Dn.u128)(n));
        })), this.edicts && this.edicts.length) {
            t.push((0, Dn.u128)(wd.Tag.BODY));
            const n = [
                ...this.edicts
            ].sort((o, a)=>Number(o.id.block - a.id.block || o.id.tx - a.id.tx));
            let i1 = new Yce.ProtoruneRuneId((0, Dn.u128)(0), (0, Dn.u128)(0));
            for (const o of n){
                const [a, s] = i1.delta(o.id).unwrap();
                t.push(a), t.push(s), t.push(o.amount), t.push((0, Dn.u128)(o.output)), i1 = o.id;
            }
        }
        const r = t.length;
        return t.unshift((0, Dn.u128)(r)), t.unshift((0, Dn.u128)(this.protocolTag)), t;
    }
    static burn({ protocolTag: t, edicts: r, ...n }) {
        return new r0({
            burn: n,
            protocolTag: t,
            edicts: r
        });
    }
    static message({ protocolTag: t, edicts: r, ...n }) {
        return new r0({
            message: n,
            protocolTag: t,
            edicts: r
        });
    }
    static edicts({ protocolTag: t, edicts: r }) {
        return new r0({
            edicts: r,
            protocolTag: t
        });
    }
}
N1.ProtoStone = r0;
var ele = Qe && Qe.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i1 = Object.getOwnPropertyDescriptor(t, r);
    (!i1 || ("get" in i1 ? !t.__esModule : i1.writable || i1.configurable)) && (i1 = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i1);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), tle = Qe && Qe.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), oR = Qe && Qe.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && ele(t, e, r);
    return tle(t, e), t;
};
Object.defineProperty(g5, "__esModule", {
    value: !0
});
var aR = g5.AlkanesRpc = void 0;
const _s = oR(tu), Ho = oR(Rn), Ad = No, rle = vb, uI = Rf, nle = Oo, my = ui, ile = Vh, ole = N1, ale = rn;
let sle = class extends rle.BaseRpc {
    async getbytecode({ block: e, tx: t }, r = "latest") {
        return await this._call({
            method: "getbytecode",
            input: Ho.encodeGetBytecodeRequest({
                block: e,
                tx: t
            })
        }, r);
    }
    async getblock(e, t = "latest") {
        return Ho.decodeBlockResponse(await this._call({
            method: "getblock",
            input: Ho.encodeBlockRequest({
                height: e
            })
        }, t));
    }
    async protorunesbyaddress({ address: e, protocolTag: t }, r = "latest") {
        const n = _s.encodeProtorunesWalletInput(e, t), i1 = await this._call({
            method: "protorunesbyaddress",
            input: n
        }, r);
        return console.log(i1), _s.decodeWalletOutput(i1);
    }
    async transactionbyid({ txid: e }, t = "latest") {
        const r = _s.encodeTransactionId(e), n = await this._call({
            method: "transactionbyid",
            input: r
        }, t);
        return _s.decodeTransactionResult(n);
    }
    async spendablesbyaddress({ address: e, protocolTag: t }, r = "latest") {
        const n = _s.encodeProtorunesWalletInput(e, t), i1 = await this._call({
            method: "spendablesbyaddress",
            input: n
        }, r);
        return _s.decodeWalletOutput(i1);
    }
    async runesbyaddress({ address: e }, t = "latest") {
        const r = _s.encodeWalletInput(e), n = await this._call({
            method: "runesbyaddress",
            input: r
        }, t);
        return _s.decodeWalletOutput(n);
    }
    async runesbyheight({ height: e }, t = "latest") {
        const r = (0, Ad.encodeBlockHeightInput)(e), n = await this._call({
            method: "runesbyheight",
            input: r
        }, t);
        return (0, Ad.decodeRunesResponse)(n);
    }
    async protorunesbyheight({ height: e, protocolTag: t }, r = "latest") {
        const n = (0, Ad.encodeProtorunesByHeightInput)(e, t), i1 = await this._call({
            method: "protorunesbyheight",
            input: n
        }, r);
        return (0, Ad.decodeRunesResponse)(i1);
    }
    async protorunesbyoutpoint({ txid: e, vout: t, protocolTag: r }, n = "latest") {
        const i1 = "0x" + Ke.from(new uI.protorune.OutpointWithProtocol({
            protocol: (0, ale.toUint128)(r),
            txid: Ke.from(e, "hex"),
            vout: t
        }).serializeBinary()).toString("hex");
        return Ho.decodeOutpointResponse(await this._call({
            method: "protorunesbyoutpoint",
            input: i1
        }, n));
    }
    async runesbyoutpoint({ txid: e, vout: t }, r = "latest") {
        const n = "0x" + Ke.from(new uI.protorune.Outpoint({
            txid: Ke.from(e, "hex"),
            vout: t
        }).serializeBinary()).toString("hex");
        return Ho.decodeOutpointResponse(await this._call({
            method: "protorunesbyoutpoint",
            input: n
        }, r));
    }
    async alkanesidtooutpoint({ block: e, tx: t }, r = "latest") {
        const n = (0, Ad.encodeAlkanesIdToOutpointInput)(e, t), i1 = await this._call({
            method: "alkanes_id_to_outpoint",
            input: n
        }, r);
        return (0, Ad.decodeAlkanesIdToOutpointResponse)(i1);
    }
    async traceblock({ block: e }, t = "latest") {
        const r = Ho.encodeTraceBlockRequest({
            block: e
        }), n = await this._call({
            method: "traceblock",
            input: r
        }, t);
        return Ho.decodeTraceBlockResponse(n);
    }
    async trace({ txid: e, vout: t }, r = "latest") {
        const n = Ho.encodeTraceRequest({
            txid: e,
            vout: t
        }), i1 = await this._call({
            method: "trace",
            input: n
        }, r);
        return Ho.decodeTraceResponse(i1);
    }
    async simulate({ alkanes: e, transaction: t, height: r, block: n, txindex: i1, target: o, inputs: a, vout: s, pointer: c, refundPointer: l }, u = "latest") {
        const f = Ho.encodeSimulateRequest({
            alkanes: e,
            transaction: t,
            height: r,
            txindex: i1,
            target: o,
            block: n,
            inputs: a,
            vout: s,
            pointer: c,
            refundPointer: l
        }), h = await this._call({
            method: "simulate",
            input: f
        }, u);
        return Ho.decodeSimulateResponse(h);
    }
    async meta({ alkanes: e, transaction: t, height: r, block: n, txindex: i1, target: o, inputs: a, vout: s, pointer: c, refundPointer: l }, u = "latest") {
        const f = Ho.encodeSimulateRequest({
            alkanes: e,
            transaction: t,
            height: r,
            txindex: i1,
            target: o,
            block: n,
            inputs: a,
            vout: s,
            pointer: c,
            refundPointer: l
        }), h = await this._call({
            method: "meta",
            input: f
        }, u);
        return Ho.decodeMetaResponse(h);
    }
    async runtime({ protocolTag: e }, t = "latest") {
        const r = _s.encodeRuntimeInput(e), n = await this._call({
            method: "protorunesbyaddress",
            input: r
        }, t);
        return _s.decodeRuntimeOutput(n);
    }
    async pack({ runes: e, cellpack: t, pointer: r, refundPointer: n, edicts: i1 }) {
        const o = new ole.ProtoStone({
            message: {
                calldata: t,
                pointer: r,
                refundPointer: n
            },
            protocolTag: BigInt(1),
            edicts: i1
        });
        return (0, nle.encodeRunestoneProtostone)({
            edicts: e.map((a)=>({
                    id: new ile.ProtoruneRuneId((0, my.u128)(a.id.block), (0, my.u128)(a.id.tx)),
                    output: (0, my.u32)(2),
                    amount: (0, my.u128)(a.value)
                })),
            pointer: 3,
            protostones: [
                o
            ]
        }).encodedRunestone;
    }
};
aR = g5.AlkanesRpc = sle;
class ule {
    constructor(){
        wt(this, "override"), this.override = null;
    }
    set(t) {
        this.override = t;
    }
    exists() {
        return this.override !== null;
    }
    get() {
        return this.override;
    }
}
const cI = new ule(), cle = (e)=>e.substr(0, 2) === "0x" ? e.substr(2) : e;
let lle = 0;
function u4(e) {
    switch(typeof e){
        case "bigint":
            return "0x" + e.toString(16);
        case "object":
            return e === null ? null : Ke.isBuffer(e) ? "0x" + e.toString("hex") : Array.isArray(e) ? e.map((t)=>u4(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
                    t,
                    u4(r)
                ]));
        default:
            return e;
    }
}
function c4(e) {
    switch(typeof e){
        case "string":
            return e !== "0x" && !isNaN(e) ? BigInt(e) : e.substr(0, 2) === "0x" || /^[0-9a-f]+$/.test(e) ? Ke.from(cle(e), "hex") : e;
        case "object":
            return e === null ? null : Array.isArray(e) ? e.map((t)=>c4(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
                    t,
                    c4(r)
                ]));
        default:
            return e;
    }
}
const j3 = [
    "99",
    "100",
    "101",
    "102",
    "103",
    "104",
    "1000"
], vd = [
    "name",
    "symbol",
    "totalSupply",
    "cap",
    "minted",
    "mintAmount",
    "data"
];
class lI {
    constructor(t){
        wt(this, "alkanesUrl"), this.alkanesUrl = t;
    }
    async _metashrewCall(t, r = []) {
        const n = new aR({
            baseUrl: cI.get()
        });
        return u4(await n[t.split("_")[1]](c4(r[0] || {})));
    }
    async _call(t, r = []) {
        if (cI.get() !== null && t.match("alkanes_")) return await this._metashrewCall(t, r);
        const n = {
            jsonrpc: "2.0",
            method: t,
            params: r,
            id: lle++
        }, i1 = {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(n),
            cache: "no-cache"
        };
        try {
            const o = await (await fetch(this.alkanesUrl, i1)).json();
            if (o.error) throw new Error(o.error.message);
            return o.result;
        } catch (o) {
            throw o instanceof Error && o.name === "AbortError" ? (console.error("Request Timeout:", o), new Error("Request timed out")) : (console.error("Request Error:", o), o);
        }
    }
    async metashrewHeight() {
        return await this._call("metashrew_height", []);
    }
    async getAlkanesByHeight({ height: t, protocolTag: r = "1" }) {
        return await this._call("alkanes_protorunesbyheight", [
            {
                height: t,
                protocolTag: r
            }
        ]);
    }
    async getAlkanesByAddress({ address: t, protocolTag: r = "1" }) {
        try {
            return (await this._call("alkanes_protorunesbyaddress", [
                {
                    address: t,
                    protocolTag: r
                }
            ])).outpoints.filter((n)=>n.runes.length > 0).map((n)=>({
                    ...n,
                    outpoint: {
                        vout: n.outpoint.vout,
                        txid: Ke.from(n.outpoint.txid, "hex").reverse().toString("hex")
                    },
                    runes: n.runes.map((i1)=>({
                            ...i1,
                            balance: parseInt(i1.balance, 16).toString(),
                            rune: {
                                ...i1.rune,
                                id: {
                                    block: parseInt(i1.rune.id.block, 16).toString(),
                                    tx: parseInt(i1.rune.id.tx, 16).toString()
                                }
                            }
                        }))
                }));
        } catch (n) {
            throw console.error("Error in getAlkanesByAddress:", n), n;
        }
    }
    async trace(t) {
        return t.txid = Ke.from(t.txid, "hex").reverse().toString("hex"), await await this._call("alkanes_trace", [
            t
        ]);
    }
    parsePoolInfo(t) {
        function r(i1) {
            if (i1.startsWith("0x") && (i1 = i1.slice(2)), i1.length % 32 !== 0) throw new Error("Invalid hex length. Expected multiples of 128-bit (32 hex chars).");
            const o = (a)=>{
                var s, c;
                const l = (c = (s = a.match(/.{2}/g)) == null ? void 0 : s.reverse()) == null ? void 0 : c.join("");
                if (!l) throw new Error("Failed to process hex segment.");
                return BigInt("0x" + l);
            };
            return (i1.match(/.{32}/g) || []).map(o).map((a)=>a.toString());
        }
        const n = r(t);
        return {
            tokenA: {
                block: n[0],
                tx: n[1]
            },
            tokenB: {
                block: n[2],
                tx: n[3]
            },
            reserveA: n[4],
            reserveB: n[5]
        };
    }
    async simulate(t, r) {
        var n;
        const i1 = await this._call("alkanes_simulate", [
            {
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "20000",
                txindex: 0,
                inputs: [],
                pointer: 0,
                refundPointer: 0,
                vout: 0,
                ...t
            }
        ]);
        if (r) {
            const o = Number((n = t.inputs) == null ? void 0 : n[0]);
            i1.parsed = r(i1, o);
        } else i1.parsed = this.parseSimulateReturn(i1.execution.data);
        return i1;
    }
    async simulatePoolInfo(t) {
        const r = await this._call("alkanes_simulate", [
            t
        ]), n = this.parsePoolInfo(r.execution.data);
        return r.parsed = n, r;
    }
    async getAlkanesByOutpoint({ txid: t, vout: r, protocolTag: n = "1", height: i1 = "latest" }) {
        return (await this._call("alkanes_protorunesbyoutpoint", [
            {
                txid: Ke.from(t, "hex").reverse().toString("hex"),
                vout: r,
                protocolTag: n
            },
            i1
        ])).map((o)=>({
                ...o,
                token: {
                    ...o.token,
                    id: {
                        block: parseInt(o.token.id.block, 16).toString(),
                        tx: parseInt(o.token.id.tx, 16).toString()
                    }
                },
                value: parseInt(o.value, 16).toString()
            }));
    }
    async getAlkaneById({ block: t, tx: r }) {
        var n, i1;
        const o = {
            id: {
                block: t,
                tx: r
            },
            data: "",
            name: "",
            mintActive: !1,
            percentageMinted: 0,
            symbol: "",
            totalSupply: 0,
            cap: 0,
            minted: 0,
            mintAmount: 0
        };
        for(let a = 0; a < j3.length; a++)try {
            const s = await this.simulate({
                target: {
                    block: t,
                    tx: r
                },
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "20000",
                txindex: 0,
                inputs: [
                    j3[a]
                ],
                pointer: 0,
                refundPointer: 0,
                vout: 0
            });
            s.status === 0 && (o[vd[a]] = Number(((n = s.parsed) == null ? void 0 : n.le) || 0), (vd[a] === "name" || vd[a] === "symbol" || vd[a] === "data") && (o[vd[a]] = ((i1 = s.parsed) == null ? void 0 : i1.string) || ""), o.mintActive = Number(o.minted) < Number(o.cap), o.percentageMinted = Math.floor(o.minted / o.cap * 100));
        } catch (s) {
            console.log(s);
        }
        return o;
    }
    async getAlkanes({ limit: t, offset: r = 0 }) {
        if (t > 1e3) throw new Error("Max limit reached. Request fewer than 1000 alkanes per call");
        const n = Array.from({
            length: t
        }, (a, s)=>s + r), i1 = async (a)=>{
            const s = {
                id: {
                    block: "2",
                    tx: a.toString()
                }
            };
            let c = !1;
            const l = j3.filter((u)=>u !== void 0);
            try {
                if ((await Promise.all(l.map(async (u, f)=>{
                    if (!u) return null;
                    try {
                        const h = await this.simulate({
                            target: {
                                block: "2",
                                tx: a.toString()
                            },
                            alkanes: [],
                            transaction: "0x",
                            block: "0x",
                            height: "20000",
                            txindex: 0,
                            inputs: [
                                u
                            ],
                            pointer: 0,
                            refundPointer: 0,
                            vout: 0
                        });
                        if ((h == null ? void 0 : h.status) === 0) return {
                            opcode: u,
                            result: h,
                            opcodeIndex: f,
                            opcodeHRV: vd[f]
                        };
                    } catch  {
                        return null;
                    }
                }))).filter((u)=>u != null && u.opcodeHRV !== void 0).forEach(({ result: u, opcodeHRV: f })=>{
                    var h, y;
                    f && ([
                        "name",
                        "symbol",
                        "data"
                    ].includes(f) ? s[f] = ((h = u.parsed) == null ? void 0 : h.string) || "" : s[f] = Number(((y = u.parsed) == null ? void 0 : y.le) || 0), c = !0);
                }), c) return s.mintActive = Number(s.minted || 0) < Number(s.cap || 0), s.percentageMinted = Math.floor((s.minted || 0) / (s.cap || 1) * 100), s;
            } catch (u) {
                return console.log(`Error processing alkane at index ${a}:`, u), null;
            }
            return null;
        }, o = [];
        for await (const a of Eoe(10, n, i1))a !== null && o.push(a);
        return o;
    }
    async meta(t) {
        return await this._call("alkanes_meta", [
            {
                alkanes: [],
                transaction: "0x",
                block: "0x",
                height: "0x",
                txindex: 0,
                inputs: [],
                pointer: 0,
                refundPointer: 0,
                vout: 0,
                ...t
            }
        ]);
    }
    parseSimulateReturn(t) {
        if (t === "0x") return;
        const r = (o)=>o.startsWith("0x") ? o.slice(2) : o, n = (o)=>"0x" + r(o);
        let i1;
        try {
            if (i1 = Ke.from(r(t), "hex").toString("utf8"), /[\uFFFD]/.test(i1)) throw new Error("Invalid UTF-8 string");
        } catch  {
            i1 = n(t);
        }
        return {
            string: i1,
            bytes: n(t),
            le: BigInt(n(Ke.from(Array.from(Ke.from(r(t), "hex")).reverse()).toString("hex"))).toString(),
            be: BigInt(n(t)).toString()
        };
    }
}
function fle({ block: e, tx: t }) {
    return `${e}:${t}`;
}
class dle {
    constructor(t, r){
        wt(this, "apiUrl", ""), wt(this, "apiKey", ""), wt(this, "networks"), wt(this, "alkanesRpc"), wt(this, "network"), this.networks = {
            mainnet: {
                apiUrl: Cd("mainnet"),
                apiKey: (r == null ? void 0 : r.apiKey) || Kd
            },
            signet: {
                apiUrl: Cd("signet"),
                apiKey: (r == null ? void 0 : r.apiKey) || Kd
            },
            oylnet: {
                apiUrl: Cd("oylnet"),
                apiKey: (r == null ? void 0 : r.apiKey) || "regtest"
            },
            ...r == null ? void 0 : r.networks
        }, this.setNetwork(t), this.alkanesRpc = new lI(`${this.apiUrl}/${this.apiKey}`), this.network = t;
    }
    getName() {
        return GZ;
    }
    setNetwork(t) {
        if (this.networks[t]) this.apiUrl = this.networks[t].apiUrl, this.apiKey = this.networks[t].apiKey;
        else {
            const r = t === pt.TESTNET || t === pt.TESTNET4 || t === pt.SIGNET || t === pt.FRACTAL_TESTNET ? pt.SIGNET : pt.MAINNET;
            this.networks[r] ? (this.apiUrl = this.networks[r].apiUrl, this.apiKey = this.networks[r].apiKey) : (this.apiUrl = Cd(t), this.apiKey = Kd);
        }
        this.alkanesRpc = new lI(`${this.apiUrl}/${this.apiKey}`), this.network = t;
    }
    async call(t, r) {
        console.log("SandshrewDataSource.call", t, r), console.log("SandshrewDataSource.apiUrl", this.apiUrl), console.log("SandshrewDataSource.apiKey", this.apiKey);
        try {
            const n = `${this.apiUrl}/${this.apiKey}`;
            return (await un.post(n, {
                jsonrpc: "2.0",
                id: t,
                method: t,
                params: r
            }, {
                headers: {
                    "Content-Type": "application/json"
                }
            })).data;
        } catch (n) {
            throw console.error("SandshrewDataSource.callRPC error:", n), n;
        }
    }
    async multicall(t) {
        return (await this.call("sandshrew_multicall", t)).result;
    }
    async getAlkanesByAddress(t) {
        return await this.alkanesRpc.getAlkanesByAddress({
            address: t
        });
    }
    async getAddressBtcBalance(t) {
        const r = (await this.call("esplora_address", [
            t
        ])).result;
        return (BigInt(r.chain_stats.funded_txo_sum) - BigInt(r.chain_stats.spent_txo_sum)).toString();
    }
    async getAddressUtxos(t) {
        const r = await this.call("esplora_address::utxo", [
            t
        ]), n = Ma(t, Vr(this.network));
        return r.result.map((i1)=>({
                ...i1,
                scriptPk: Ke.from(n).toString("hex")
            }));
    }
    async getOutputValueByVOutIndex(t, r) {
        var n;
        return ((n = (await this.call("esplora_tx", [
            t
        ])).result.vout[r]) == null ? void 0 : n.value) ?? null;
    }
    async getAddressAlkanesBalances(t) {
        const r = await this.getAlkanesByAddress(t), n = {};
        for (const i1 of r)for (const o of i1.runes){
            const a = fle(o.rune.id);
            n[a] ? n[a].balance += BigInt(o.balance) : n[a] = {
                id: a,
                balance: BigInt(o.balance),
                name: o.rune.name,
                symbol: o.rune.symbol
            };
        }
        return Object.values(n);
    }
    async getTransaction(t) {
        return (await this.call("esplora_tx", [
            t
        ])).result;
    }
    async getRuneById(t) {
        return (await this.call("ord_rune", [
            t
        ])).result;
    }
    async getRuneByName(t) {
        return (await this.call("ord_rune", [
            t
        ])).result;
    }
    async broadcastTransaction(t) {
        return await this.call("broadcast_tx", [
            t
        ]);
    }
    async getOrdAddress(t) {
        return (await this.call("ord_address", [
            t
        ])).result;
    }
    async getTxInfo(t) {
        return (await this.call("esplora_tx", [
            t
        ])).result;
    }
    async batchOrdOutput({ outpoints: t, rune_name: r }) {
        const n = [];
        for(let i1 = 0; i1 < t.length; i1 += 1e3){
            const o = t.slice(i1, i1 + 1e3), a = o.map((l)=>[
                    "ord_output",
                    [
                        l
                    ]
                ]), { result: s } = await this.call("sandshrew_multicall", a);
            for(let l = 0; l < s.length; l++)s[l].result.output = o[l];
            const c = s.filter((l)=>Object.keys(l.result.runes).includes(r));
            n.push(...c);
        }
        return n;
    }
    async batchOrdInscriptionInfo(t) {
        const r = [];
        for(let n = 0; n < t.length; n += 1e3){
            const i1 = t.slice(n, n + 1e3).map((a)=>[
                    "ord_inscription",
                    [
                        a
                    ]
                ]), { result: o } = await this.call("sandshrew_multicall", i1);
            for(let a = 0; a < o.length; a++)r.push(o[a].result);
        }
        return r;
    }
    async getAddressRunesBalances(t) {
        try {
            const r = (await this.getOrdAddress(t)).runes_balances;
            if (!r) throw new Error("No runes data found");
            return r.map((n)=>({
                    name: n[0],
                    balance: n[1],
                    symbol: n[2]
                }));
        } catch (r) {
            throw console.error("Error fetching ord address:", r), r;
        }
    }
    async getInscriptionInfo(t) {
        const r = (await this.call("ord_inscription", [
            t
        ])).result;
        return {
            data: {
                inscription_id: r.id || t,
                inscription_number: r.number || 0,
                created_at: r.timestamp || 0,
                content_type: r.effective_content_type || "",
                content_body_preview: "",
                content_length: r.content_length || 0,
                collection_symbol: null
            },
            last_updated: {
                block_hash: "",
                block_height: r.height || 0
            }
        };
    }
    async getRecommendedFees() {
        const t = (await this.call("esplora_fee-estimates", [])).result, r = t[1] || 0, n = Math.min(...Object.values(t));
        return {
            fastFee: Math.round(r),
            minFee: Math.round(n)
        };
    }
    async getBalances(t) {
        if (Array.isArray(t)) {
            const r = t.map((n)=>[
                    "sandshrew_balances",
                    [
                        {
                            address: n
                        }
                    ]
                ]);
            return (await this.multicall(r)).map((n)=>n.result);
        }
        return [
            (await this.call("sandshrew_balances", [
                {
                    address: t
                }
            ])).result
        ];
    }
    async getRuneOutpoints({ address: t, runeId: r }) {
        const n = await this.getOrdAddress(t), { entry: i1 } = await this.getRuneById(r), o = i1.spaced_rune, a = await this.batchOrdOutput({
            outpoints: n.outputs,
            rune_name: o
        });
        return await this.mapRuneBalances({
            ordOutputs: a
        });
    }
    async mapRuneBalances({ ordOutputs: t }) {
        var r;
        const n = [];
        for(let i1 = 0; i1 < t.length; i1++){
            const o = t[i1], { result: a } = o;
            if (!((r = a.output) != null && r.split(":"))) throw new Error("No output found");
            const { output: s, address: c, runes: l } = a, u = {
                output: s,
                wallet_addr: c,
                script: "",
                balances: [],
                decimals: [],
                rune_ids: [],
                value: a.value
            };
            if (u.script = Ke.from(dN(c, mn)).toString("hex"), typeof l == "object" && !Array.isArray(l)) for(const f in l)u.balances.push(l[f].amount), u.decimals.push(l[f].divisibility), u.rune_ids.push((await this.getRuneByName(f)).id);
            n.push(u);
        }
        return n;
    }
}
const yo = "Method not available on any data source", sR = class kd {
    constructor(t){
        wt(this, "dataSources", /* @__PURE__ */ new Map()), wt(this, "network"), wt(this, "customNetworks", /* @__PURE__ */ new Map());
        var r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M, N, z;
        const K = (t == null ? void 0 : t.network) || pt.MAINNET;
        this.network = K, this.customNetworks = new Map(Object.entries((t == null ? void 0 : t.customNetworks) || {})), this.dataSources.set("mempool", new woe(K, {
            networks: {
                mainnet: {
                    apiUrl: ((n = (r = t == null ? void 0 : t.dataSources) == null ? void 0 : r.mempool) == null ? void 0 : n.url) || zi(pt.MAINNET)
                },
                testnet: {
                    apiUrl: zi(pt.TESTNET)
                },
                testnet4: {
                    apiUrl: zi(pt.TESTNET4)
                },
                signet: {
                    apiUrl: zi(pt.SIGNET)
                },
                "fractal-mainnet": {
                    apiUrl: zi(pt.FRACTAL_MAINNET)
                },
                "fractal-testnet": {
                    apiUrl: zi(pt.FRACTAL_TESTNET)
                },
                ...(o = (i1 = t == null ? void 0 : t.dataSources) == null ? void 0 : i1.mempool) == null ? void 0 : o.networks
            }
        })), this.dataSources.set("sandshrew", new dle(K, {
            apiKey: (s = (a = t == null ? void 0 : t.dataSources) == null ? void 0 : a.sandshrew) == null ? void 0 : s.apiKey,
            networks: {
                mainnet: {
                    apiKey: ((l = (c = t == null ? void 0 : t.dataSources) == null ? void 0 : c.sandshrew) == null ? void 0 : l.apiKey) || Kd,
                    apiUrl: Cd(pt.MAINNET)
                },
                testnet: {
                    apiKey: ((f = (u = t == null ? void 0 : t.dataSources) == null ? void 0 : u.sandshrew) == null ? void 0 : f.apiKey) || Kd,
                    apiUrl: Cd(pt.TESTNET)
                },
                ...(y = (h = t == null ? void 0 : t.dataSources) == null ? void 0 : h.sandshrew) == null ? void 0 : y.networks
            }
        })), this.dataSources.set("maestro", new boe(K, {
            networks: {
                mainnet: {
                    apiKey: ((k = (S = t == null ? void 0 : t.dataSources) == null ? void 0 : S.maestro) == null ? void 0 : k.apiKey) || Jne,
                    apiUrl: Sm(pt.MAINNET)
                },
                testnet4: {
                    apiKey: ((M = (P = t == null ? void 0 : t.dataSources) == null ? void 0 : P.maestro) == null ? void 0 : M.testnetApiKey) || qM,
                    apiUrl: Sm(pt.TESTNET4)
                },
                ...(z = (N = t == null ? void 0 : t.dataSources) == null ? void 0 : N.maestro) == null ? void 0 : z.networks
            }
        }));
    }
    static init(t) {
        kd.instance || (kd.instance = new kd(t));
    }
    static getInstance() {
        if (!kd.instance) throw new Error("DataSourceManager has not been initialized");
        return kd.instance;
    }
    updateNetwork(t) {
        var r, n;
        this.network = t;
        const i1 = (r = this.customNetworks.get(t)) == null ? void 0 : r.baseNetwork;
        for (const o of this.dataSources.values())(n = o.setNetwork) == null || n.call(o, t, i1);
    }
    registerDataSource(t, r) {
        var n, i1, o;
        this.dataSources.set(t, r), (o = (n = this.dataSources.get(t)) == null ? void 0 : n.setNetwork) == null || o.call(n, this.network, (i1 = this.customNetworks.get(this.network)) == null ? void 0 : i1.baseNetwork);
    }
    getSource(t) {
        return this.dataSources.get(t);
    }
    async getAddressAlkanesBalances(t) {
        const r = this.findAvailableSource("getAddressAlkanesBalances");
        if (!r || !r.getAddressAlkanesBalances) throw new Error(yo);
        return await r.getAddressAlkanesBalances(t);
    }
    async getAlkanesByAddress(t) {
        const r = this.findAvailableSource("getAlkanesByAddress");
        if (!r || !r.getAlkanesByAddress) throw new Error(yo);
        return await r.getAlkanesByAddress(t);
    }
    async getAddressBtcBalance(t) {
        const r = this.findAvailableSource("getAddressBtcBalance");
        if (!r || !r.getAddressBtcBalance) throw new Error(yo);
        const n = await this.withFallback("sandshrew", async (i1)=>{
            var o;
            return await ((o = i1.getAddressBtcBalance) == null ? void 0 : o.call(i1, t));
        });
        if (n === void 0) throw new Error("Unable to get balance from any data source");
        return n;
    }
    async getAddressBrc20Balances(t) {
        const r = this.findAvailableSource("getAddressBrc20Balances");
        if (!r || !r.getAddressBrc20Balances) throw new Error(yo);
        const n = await r.getAddressBrc20Balances(t);
        return moe(n);
    }
    async getAddressInscriptions(t, r, n) {
        const i1 = this.findAvailableSource("getAddressInscriptions");
        if (!i1 || !i1.getAddressInscriptions) throw new Error(yo);
        if (!i1.getInscriptionInfo) throw new Error(yo);
        const o = pt.MAINNET, a = await i1.getAddressInscriptions(t, r, n), s = i1.getName();
        return s === uP && a.data ? (await Promise.all(a.data.map(async (c)=>{
            try {
                if (!i1.getInscriptionInfo) throw new Error(yo);
                const l = await i1.getInscriptionInfo(c.inscription_id);
                return {
                    ...c,
                    ...l.data
                };
            } catch (l) {
                return console.error(`Failed to fetch details for inscription ${c.inscription_id}:`, l), c;
            }
        }))).map((c)=>qd(c, s, o)) : a.inscriptions ? a.inscriptions.map((c)=>qd(c, s, o)) : Array.isArray(a) ? a.map((c)=>qd(c, s, o)) : (console.warn("Unable to normalize inscriptions from data source", s), []);
    }
    async getInscriptionInfo(t) {
        const r = this.findAvailableSource("getInscriptionInfo");
        if (!r || !r.getInscriptionInfo) throw new Error(yo);
        return await r.getInscriptionInfo(t);
    }
    async getRecommendedFees() {
        const t = this.findAvailableSource("getRecommendedFees");
        if (!t || !t.getRecommendedFees) throw new Error(yo);
        console.log("getting recommended fees");
        const r = await this.withFallback("sandshrew", async (n)=>{
            var i1;
            return await ((i1 = n.getRecommendedFees) == null ? void 0 : i1.call(n));
        });
        if (r === void 0) throw new Error("Unable to get recommended fees from any data source");
        return {
            fastFee: r.fastFee,
            minFee: r.minFee
        };
    }
    async getAddressUtxos(t) {
        const r = this.findAvailableSource("getAddressUtxos");
        if (!r || !r.getAddressUtxos) throw new Error(yo);
        const n = await this.withFallback("sandshrew", async (i1)=>{
            var o;
            return await ((o = i1.getAddressUtxos) == null ? void 0 : o.call(i1, t));
        });
        if (n === void 0) throw new Error("Unable to get utxos from any data source");
        return n;
    }
    async getOutputValueByVOutIndex(t, r) {
        const n = this.findAvailableSource("getOutputValueByVOutIndex");
        if (!n || !n.getOutputValueByVOutIndex) throw new Error(yo);
        const i1 = await this.withFallback("sandshrew", async (o)=>{
            var a;
            return await ((a = o.getOutputValueByVOutIndex) == null ? void 0 : a.call(o, t, r));
        });
        if (i1 === void 0) throw new Error("Unable to get output value from any data source");
        return i1;
    }
    async waitForTransaction(t) {
        const r = this.findAvailableSource("waitForTransaction");
        if (!r || !r.waitForTransaction) throw new Error(yo);
        return !!await r.waitForTransaction(t);
    }
    async getAddressRunesBalances(t) {
        const r = this.findAvailableSource("getAddressRunesBalances");
        if (!r || !r.getAddressRunesBalances) throw new Error(yo);
        return await r.getAddressRunesBalances(t);
    }
    async broadcastTransaction(t) {
        const r = this.findAvailableSource("broadcastTransaction");
        if (!r || !r.broadcastTransaction) throw new Error(yo);
        return await r.broadcastTransaction(t);
    }
    async withFallback(t, r) {
        const n = [
            t,
            ...Array.from(this.dataSources.keys()).filter((i1)=>i1 !== t)
        ];
        for (const i1 of n)try {
            const o = this.getSource(i1);
            if (!o) continue;
            return await r(o);
        } catch (o) {
            console.warn(`Fallback: ${i1} failed`, o);
        }
        throw new Error("All data sources failed");
    }
    findAvailableSource(t) {
        const r = this.customNetworks.get(this.network);
        if (r) {
            const n = this.getSource(r.preferredDataSource);
            if (n && typeof n[t] == "function") return n;
        }
        for (const n of this.dataSources.values())if (typeof n[t] == "function") return n;
    }
    async getFormattedUTXOs(t) {
        const r = this.getSource("sandshrew");
        if (!r || !r.getBalances) throw new Error("Sandshrew data source with getBalances method is required");
        const n = await r.getBalances(t), i1 = [], o = Array.isArray(t) ? [
            ...new Set(t)
        ] : [
            t
        ];
        for(let a = 0; a < n.length; a++){
            const s = n[a], c = o[a], l = s.metashrewHeight, u = Ke.from(yoe(c, this.network)).toString("hex");
            for (const f of s.spendable){
                const [h, y] = f.outpoint.split(":");
                i1.push({
                    txHash: h,
                    txOutputIndex: parseInt(y),
                    btcValue: f.value,
                    scriptPubKey: u,
                    address: c,
                    hasRunes: !1,
                    runes: [],
                    hasAlkanes: !1,
                    // No alkanes info in sandshrew_balances
                    alkanes: [],
                    hasInscriptions: !1,
                    inscriptions: [],
                    confirmations: f.height ? l - f.height : void 0
                });
            }
            for (const f of s.assets){
                const [h, y] = f.outpoint.split(":"), S = (f.inscriptions || []).map((M)=>({
                        inscriptionId: M
                    })), k = [];
                if (f.ord_runes) for (const [M, N] of Object.entries(f.ord_runes))k.push({
                    runeId: M,
                    // Using name as ID
                    amount: N.amount
                });
                const P = [];
                if (f.runes) for (const M of f.runes)P.push({
                    id: parseInt(M.rune.id.block, 16) + ":" + parseInt(M.rune.id.tx, 16),
                    amount: parseInt(M.balance, 16),
                    // Convert hex to number
                    name: M.rune.name,
                    symbol: M.rune.symbol
                });
                i1.push({
                    txHash: h,
                    txOutputIndex: parseInt(y),
                    btcValue: f.value,
                    scriptPubKey: u,
                    address: c,
                    hasRunes: k.length > 0,
                    runes: k,
                    hasAlkanes: P.length > 0,
                    alkanes: P,
                    hasInscriptions: S.length > 0,
                    inscriptions: S,
                    confirmations: f.height ? l - f.height : void 0
                });
            }
        }
        return i1.sort((a, s)=>a.btcValue - s.btcValue), i1;
    }
};
wt(sR, "instance");
let ff = sR;
const hle = (e)=>/^(?:[A-Za-z0-9+/]{4})*?(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e), ple = (e)=>/^[a-fA-F0-9]+$/.test(e), Ol = (e)=>{
    const t = [];
    let r = e;
    do {
        let n = r & BigInt(127);
        r >>= BigInt(7), r !== BigInt(0) && (n |= BigInt(128)), t.push(Number(n));
    }while (r !== BigInt(0))
    return {
        varint: Ke.from(t)
    };
};
function Af(e) {
    return Object.fromEntries(Object.entries(e).filter(([t, r])=>r !== void 0));
}
const gle = (e)=>{
    let t = 0n;
    const r = [];
    for (const n of e)n.inscriptions.length <= 0 && n.runes.length <= 0 && n.alkanes.length <= 0 && n.btcValue !== 546 && n.btcValue !== 330 && (r.push(n), t += BigInt(n.btcValue));
    return {
        utxos: r,
        totalAmount: t
    };
};
var Bu = {}, uR = {}, C5 = {};
(function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0, e.assertNumber = t;
    // @__NO_SIDE_EFFECTS__
    function t(B) {
        if (!Number.isSafeInteger(B)) throw new Error(`Wrong integer: ${B}`);
    }
    function r(B) {
        return B instanceof Uint8Array || B != null && typeof B == "object" && B.constructor.name === "Uint8Array";
    }
    // @__NO_SIDE_EFFECTS__
    function n(...B) {
        const g = (O)=>O, E = (O, I)=>(x)=>O(I(x)), w = B.map((O)=>O.encode).reduceRight(E, g), _ = B.map((O)=>O.decode).reduce(E, g);
        return {
            encode: w,
            decode: _
        };
    }
    // @__NO_SIDE_EFFECTS__
    function i1(B) {
        return {
            encode: (g)=>{
                if (!Array.isArray(g) || g.length && typeof g[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
                return g.map((E)=>{
                    if (E < 0 || E >= B.length) throw new Error(`Digit index outside alphabet: ${E} (alphabet: ${B.length})`);
                    return B[E];
                });
            },
            decode: (g)=>{
                if (!Array.isArray(g) || g.length && typeof g[0] != "string") throw new Error("alphabet.decode input should be array of strings");
                return g.map((E)=>{
                    if (typeof E != "string") throw new Error(`alphabet.decode: not string element=${E}`);
                    const w = B.indexOf(E);
                    if (w === -1) throw new Error(`Unknown letter: "${E}". Allowed: ${B}`);
                    return w;
                });
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function o(B = "") {
        if (typeof B != "string") throw new Error("join separator should be string");
        return {
            encode: (g)=>{
                if (!Array.isArray(g) || g.length && typeof g[0] != "string") throw new Error("join.encode input should be array of strings");
                for (let E of g)if (typeof E != "string") throw new Error(`join.encode: non-string input=${E}`);
                return g.join(B);
            },
            decode: (g)=>{
                if (typeof g != "string") throw new Error("join.decode input should be string");
                return g.split(B);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function a(B, g = "=") {
        if (typeof g != "string") throw new Error("padding chr should be string");
        return {
            encode (E) {
                if (!Array.isArray(E) || E.length && typeof E[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let w of E)if (typeof w != "string") throw new Error(`padding.encode: non-string input=${w}`);
                for(; E.length * B % 8;)E.push(g);
                return E;
            },
            decode (E) {
                if (!Array.isArray(E) || E.length && typeof E[0] != "string") throw new Error("padding.encode input should be array of strings");
                for (let _ of E)if (typeof _ != "string") throw new Error(`padding.decode: non-string input=${_}`);
                let w = E.length;
                if (w * B % 8) throw new Error("Invalid padding: string should have whole number of bytes");
                for(; w > 0 && E[w - 1] === g; w--)if (!((w - 1) * B % 8)) throw new Error("Invalid padding: string has too much padding");
                return E.slice(0, w);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function s(B) {
        if (typeof B != "function") throw new Error("normalize fn should be function");
        return {
            encode: (g)=>g,
            decode: (g)=>B(g)
        };
    }
    // @__NO_SIDE_EFFECTS__
    function c(B, g, E) {
        if (g < 2) throw new Error(`convertRadix: wrong from=${g}, base cannot be less than 2`);
        if (E < 2) throw new Error(`convertRadix: wrong to=${E}, base cannot be less than 2`);
        if (!Array.isArray(B)) throw new Error("convertRadix: data should be array");
        if (!B.length) return [];
        let w = 0;
        const _ = [], O = Array.from(B);
        for(O.forEach((I)=>{
            if (I < 0 || I >= g) throw new Error(`Wrong integer: ${I}`);
        });;){
            let I = 0, x = !0;
            for(let R = w; R < O.length; R++){
                const j = O[R], Y = g * I + j;
                if (!Number.isSafeInteger(Y) || g * I / g !== I || Y - j !== g * I) throw new Error("convertRadix: carry overflow");
                I = Y % E;
                const he = Math.floor(Y / E);
                if (O[R] = he, !Number.isSafeInteger(he) || he * E + I !== Y) throw new Error("convertRadix: carry overflow");
                if (x) he ? x = !1 : w = R;
                else continue;
            }
            if (_.push(I), x) break;
        }
        for(let I = 0; I < B.length - 1 && B[I] === 0; I++)_.push(0);
        return _.reverse();
    }
    const l = /* @__NO_SIDE_EFFECTS__ */ (B, g)=>g ? /* @__PURE__ */ l(g, B % g) : B, u = /* @__NO_SIDE_EFFECTS__ */ (B, g)=>B + (g - /* @__PURE__ */ l(B, g));
    // @__NO_SIDE_EFFECTS__
    function f(B, g, E, w) {
        if (!Array.isArray(B)) throw new Error("convertRadix2: data should be array");
        if (g <= 0 || g > 32) throw new Error(`convertRadix2: wrong from=${g}`);
        if (E <= 0 || E > 32) throw new Error(`convertRadix2: wrong to=${E}`);
        if (/* @__PURE__ */ u(g, E) > 32) throw new Error(`convertRadix2: carry overflow from=${g} to=${E} carryBits=${/* @__PURE__ */ u(g, E)}`);
        let _ = 0, O = 0;
        const I = 2 ** E - 1, x = [];
        for (const R of B){
            if (R >= 2 ** g) throw new Error(`convertRadix2: invalid data word=${R} from=${g}`);
            if (_ = _ << g | R, O + g > 32) throw new Error(`convertRadix2: carry overflow pos=${O} from=${g}`);
            for(O += g; O >= E; O -= E)x.push((_ >> O - E & I) >>> 0);
            _ &= 2 ** O - 1;
        }
        if (_ = _ << E - O & I, !w && O >= g) throw new Error("Excess padding");
        if (!w && _) throw new Error(`Non-zero padding: ${_}`);
        return w && O > 0 && x.push(_ >>> 0), x;
    }
    // @__NO_SIDE_EFFECTS__
    function h(B) {
        return {
            encode: (g)=>{
                if (!r(g)) throw new Error("radix.encode input should be Uint8Array");
                return /* @__PURE__ */ c(Array.from(g), 2 ** 8, B);
            },
            decode: (g)=>{
                if (!Array.isArray(g) || g.length && typeof g[0] != "number") throw new Error("radix.decode input should be array of numbers");
                return Uint8Array.from(/* @__PURE__ */ c(g, B, 2 ** 8));
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function y(B, g = !1) {
        if (B <= 0 || B > 32) throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ u(8, B) > 32 || /* @__PURE__ */ u(B, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (E)=>{
                if (!r(E)) throw new Error("radix2.encode input should be Uint8Array");
                return /* @__PURE__ */ f(Array.from(E), 8, B, !g);
            },
            decode: (E)=>{
                if (!Array.isArray(E) || E.length && typeof E[0] != "number") throw new Error("radix2.decode input should be array of numbers");
                return Uint8Array.from(/* @__PURE__ */ f(E, B, 8, g));
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function S(B) {
        if (typeof B != "function") throw new Error("unsafeWrapper fn should be function");
        return function(...g) {
            try {
                return B.apply(null, g);
            } catch  {}
        };
    }
    // @__NO_SIDE_EFFECTS__
    function k(B, g) {
        if (typeof g != "function") throw new Error("checksum fn should be function");
        return {
            encode (E) {
                if (!r(E)) throw new Error("checksum.encode: input should be Uint8Array");
                const w = g(E).slice(0, B), _ = new Uint8Array(E.length + B);
                return _.set(E), _.set(w, E.length), _;
            },
            decode (E) {
                if (!r(E)) throw new Error("checksum.decode: input should be Uint8Array");
                const w = E.slice(0, -B), _ = g(w).slice(0, B), O = E.slice(-B);
                for(let I = 0; I < B; I++)if (_[I] !== O[I]) throw new Error("Invalid checksum");
                return w;
            }
        };
    }
    e.utils = {
        alphabet: i1,
        chain: n,
        checksum: k,
        convertRadix: c,
        convertRadix2: f,
        radix: h,
        radix2: y,
        join: o,
        padding: a
    }, e.base16 = /* @__PURE__ */ n(/* @__PURE__ */ y(4), /* @__PURE__ */ i1("0123456789ABCDEF"), /* @__PURE__ */ o("")), e.base32 = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ a(5), /* @__PURE__ */ o("")), e.base32nopad = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ o("")), e.base32hex = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i1("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ a(5), /* @__PURE__ */ o("")), e.base32hexnopad = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i1("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ o("")), e.base32crockford = /* @__PURE__ */ n(/* @__PURE__ */ y(5), /* @__PURE__ */ i1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ o(""), /* @__PURE__ */ s((B)=>B.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ a(6), /* @__PURE__ */ o("")), e.base64nopad = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ o("")), e.base64url = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ a(6), /* @__PURE__ */ o("")), e.base64urlnopad = /* @__PURE__ */ n(/* @__PURE__ */ y(6), /* @__PURE__ */ i1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ o(""));
    const P = (B)=>/* @__PURE__ */ n(/* @__PURE__ */ h(58), /* @__PURE__ */ i1(B), /* @__PURE__ */ o(""));
    e.base58 = P("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = P("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = P("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const M = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    e.base58xmr = {
        encode (B) {
            let g = "";
            for(let E = 0; E < B.length; E += 8){
                const w = B.subarray(E, E + 8);
                g += e.base58.encode(w).padStart(M[w.length], "1");
            }
            return g;
        },
        decode (B) {
            let g = [];
            for(let E = 0; E < B.length; E += 11){
                const w = B.slice(E, E + 11), _ = M.indexOf(w.length), O = e.base58.decode(w);
                for(let I = 0; I < O.length - _; I++)if (O[I] !== 0) throw new Error("base58xmr: wrong padding");
                g = g.concat(Array.from(O.slice(O.length - _)));
            }
            return Uint8Array.from(g);
        }
    };
    const N = (B)=>/* @__PURE__ */ n(/* @__PURE__ */ k(4, (g)=>B(B(g))), e.base58);
    e.createBase58check = N, e.base58check = e.createBase58check;
    const z = /* @__PURE__ */ n(/* @__PURE__ */ i1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ o("")), K = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    // @__NO_SIDE_EFFECTS__
    function $(B) {
        const g = B >> 25;
        let E = (B & 33554431) << 5;
        for(let w = 0; w < K.length; w++)(g >> w & 1) === 1 && (E ^= K[w]);
        return E;
    }
    // @__NO_SIDE_EFFECTS__
    function ne(B, g, E = 1) {
        const w = B.length;
        let _ = 1;
        for(let O = 0; O < w; O++){
            const I = B.charCodeAt(O);
            if (I < 33 || I > 126) throw new Error(`Invalid prefix (${B})`);
            _ = /* @__PURE__ */ $(_) ^ I >> 5;
        }
        _ = /* @__PURE__ */ $(_);
        for(let O = 0; O < w; O++)_ = /* @__PURE__ */ $(_) ^ B.charCodeAt(O) & 31;
        for (let O of g)_ = /* @__PURE__ */ $(_) ^ O;
        for(let O = 0; O < 6; O++)_ = /* @__PURE__ */ $(_);
        return _ ^= E, z.encode(/* @__PURE__ */ f([
            _ % 2 ** 30
        ], 30, 5, !1));
    }
    // @__NO_SIDE_EFFECTS__
    function ee(B) {
        const g = B === "bech32" ? 1 : 734539939, E = /* @__PURE__ */ y(5), w = E.decode, _ = E.encode, O = /* @__PURE__ */ S(w);
        function I(he, ue, G = 90) {
            if (typeof he != "string") throw new Error(`bech32.encode prefix should be string, not ${typeof he}`);
            if (ue instanceof Uint8Array && (ue = Array.from(ue)), !Array.isArray(ue) || ue.length && typeof ue[0] != "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof ue}`);
            if (he.length === 0) throw new TypeError(`Invalid prefix length ${he.length}`);
            const se = he.length + 7 + ue.length;
            if (G !== !1 && se > G) throw new TypeError(`Length ${se} exceeds limit ${G}`);
            const Z = he.toLowerCase(), ie = /* @__PURE__ */ ne(Z, ue, g);
            return `${Z}1${z.encode(ue)}${ie}`;
        }
        function x(he, ue = 90) {
            if (typeof he != "string") throw new Error(`bech32.decode input should be string, not ${typeof he}`);
            if (he.length < 8 || ue !== !1 && he.length > ue) throw new TypeError(`Wrong string length: ${he.length} (${he}). Expected (8..${ue})`);
            const G = he.toLowerCase();
            if (he !== G && he !== he.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const se = G.lastIndexOf("1");
            if (se === 0 || se === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const Z = G.slice(0, se), ie = G.slice(se + 1);
            if (ie.length < 6) throw new Error("Data must be at least 6 characters long");
            const pe = z.decode(ie).slice(0, -6), ve = /* @__PURE__ */ ne(Z, pe, g);
            if (!ie.endsWith(ve)) throw new Error(`Invalid checksum in ${he}: expected "${ve}"`);
            return {
                prefix: Z,
                words: pe
            };
        }
        const R = /* @__PURE__ */ S(x);
        function j(he) {
            const { prefix: ue, words: G } = x(he, !1);
            return {
                prefix: ue,
                words: G,
                bytes: w(G)
            };
        }
        function Y(he, ue) {
            return I(he, _(ue));
        }
        return {
            encode: I,
            decode: x,
            encodeFromBytes: Y,
            decodeToBytes: j,
            decodeUnsafe: R,
            fromWords: w,
            fromWordsUnsafe: O,
            toWords: _
        };
    }
    e.bech32 = /* @__PURE__ */ ee("bech32"), e.bech32m = /* @__PURE__ */ ee("bech32m"), e.utf8 = {
        encode: (B)=>new TextDecoder().decode(B),
        decode: (B)=>new TextEncoder().encode(B)
    }, e.hex = /* @__PURE__ */ n(/* @__PURE__ */ y(4), /* @__PURE__ */ i1("0123456789abcdef"), /* @__PURE__ */ o(""), /* @__PURE__ */ s((B)=>{
        if (typeof B != "string" || B.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof B} with length ${B.length}`);
        return B.toLowerCase();
    }));
    const q = {
        utf8: e.utf8,
        hex: e.hex,
        base16: e.base16,
        base32: e.base32,
        base64: e.base64,
        base64url: e.base64url,
        base58: e.base58,
        base58xmr: e.base58xmr
    }, U = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", Q = (B, g)=>{
        if (typeof B != "string" || !q.hasOwnProperty(B)) throw new TypeError(U);
        if (!r(g)) throw new TypeError("bytesToString() expects Uint8Array");
        return q[B].encode(g);
    };
    e.bytesToString = Q, e.str = e.bytesToString;
    const v = (B, g)=>{
        if (!q.hasOwnProperty(B)) throw new TypeError(U);
        if (typeof g != "string") throw new TypeError("stringToBytes() expects string");
        return q[B].decode(g);
    };
    e.stringToBytes = v, e.bytes = e.stringToBytes;
})(C5);
var M5 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.constant = e.magicBytes = e.magic = e.optional = e.flagged = e.flag = e.lazy = e.apply = e.hex = e.cstring = e.string = e.prefix = e.bytes = e.bool = e.F64LE = e.F64BE = e.F32LE = e.F32BE = e.I8 = e.U8 = e.I16BE = e.I16LE = e.U16BE = e.U16LE = e.I32BE = e.I32LE = e.U32BE = e.U32LE = e.int = e.I64BE = e.I64LE = e.U64BE = e.U64LE = e.I128BE = e.I128LE = e.U128BE = e.U128LE = e.I256BE = e.I256LE = e.U256BE = e.U256LE = e.bigint = e.bits = e.coders = e.isCoder = e.wrap = e.validate = e.utils = e.NULL = e.EMPTY = void 0, e._TEST = e.pointer = e.padRight = e.padLeft = e.ZeroPad = e.bitset = e.mappedTag = e.tag = e.map = e.array = e.tuple = e.struct = void 0;
    const t = C5;
    e.EMPTY = new Uint8Array(), e.NULL = new Uint8Array([
        0
    ]);
    function r(p, A) {
        if (p.length !== A.length) return !1;
        for(let V = 0; V < p.length; V++)if (p[V] !== A[V]) return !1;
        return !0;
    }
    function n(p) {
        return p instanceof Uint8Array || p != null && typeof p == "object" && p.constructor.name === "Uint8Array";
    }
    function i1(...p) {
        let A = 0;
        for(let re = 0; re < p.length; re++){
            const le = p[re];
            if (!n(le)) throw new Error("Uint8Array expected");
            A += le.length;
        }
        const V = new Uint8Array(A);
        for(let re = 0, le = 0; re < p.length; re++){
            const L = p[re];
            V.set(L, le), le += L.length;
        }
        return V;
    }
    const o = (p)=>new DataView(p.buffer, p.byteOffset, p.byteLength);
    function a(p) {
        return Object.prototype.toString.call(p) === "[object Object]";
    }
    function s(p) {
        return Number.isSafeInteger(p);
    }
    e.utils = {
        equalBytes: r,
        isBytes: n,
        isCoder: z,
        checkBounds: S,
        concatBytes: i1,
        createView: o,
        isPlainObject: a
    };
    const c = (p)=>{
        if (p !== null && typeof p != "string" && !z(p) && !n(p) && !s(p)) throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${p} (${typeof p})`);
        return {
            encodeStream (A, V) {
                if (p === null) return;
                if (z(p)) return p.encodeStream(A, V);
                let re;
                if (typeof p == "number" ? re = p : typeof p == "string" && (re = u.resolve(A.stack, p)), typeof re == "bigint" && (re = Number(re)), re === void 0 || re !== V) throw A.err(`Wrong length: ${re} len=${p} exp=${V} (${typeof V})`);
            },
            decodeStream (A) {
                let V;
                if (z(p) ? V = Number(p.decodeStream(A)) : typeof p == "number" ? V = p : typeof p == "string" && (V = u.resolve(A.stack, p)), typeof V == "bigint" && (V = Number(V)), typeof V != "number") throw A.err(`Wrong length: ${V}`);
                return V;
            }
        };
    }, l = {
        BITS: 32,
        FULL_MASK: -1 >>> 0,
        // 1<<32 will overflow
        len: (p)=>Math.ceil(p / 32),
        create: (p)=>new Uint32Array(l.len(p)),
        clean: (p)=>p.fill(0),
        debug: (p)=>Array.from(p).map((A)=>(A >>> 0).toString(2).padStart(32, "0")),
        checkLen: (p, A)=>{
            if (l.len(A) !== p.length) throw new Error(`wrong length=${p.length}. Expected: ${l.len(A)}`);
        },
        chunkLen: (p, A, V)=>{
            if (A < 0) throw new Error(`wrong pos=${A}`);
            if (A + V > p) throw new Error(`wrong range=${A}/${V} of ${p}`);
        },
        set: (p, A, V, re = !0)=>!re && p[A] & V ? !1 : (p[A] |= V, !0),
        pos: (p, A)=>({
                chunk: Math.floor((p + A) / 32),
                mask: 1 << 32 - (p + A) % 32 - 1
            }),
        indices: (p, A, V = !1)=>{
            l.checkLen(p, A);
            const { FULL_MASK: re, BITS: le } = l, L = le - A % le, X = L ? re >>> L << L : re, ae = [];
            for(let D = 0; D < p.length; D++){
                let H = p[D];
                if (V && (H = ~H), D === p.length - 1 && (H &= X), H !== 0) for(let te = 0; te < le; te++){
                    const ge = 1 << le - te - 1;
                    H & ge && ae.push(D * le + te);
                }
            }
            return ae;
        },
        range: (p)=>{
            const A = [];
            let V;
            for (const re of p)V === void 0 || re !== V.pos + V.length ? A.push(V = {
                pos: re,
                length: 1
            }) : V.length += 1;
            return A;
        },
        rangeDebug: (p, A, V = !1)=>`[${l.range(l.indices(p, A, V)).map((re)=>`(${re.pos}/${re.length})`).join(", ")}]`,
        setRange: (p, A, V, re, le = !0)=>{
            l.chunkLen(A, V, re);
            const { FULL_MASK: L, BITS: X } = l, ae = V % X ? Math.floor(V / X) : void 0, D = V + re, H = D % X ? Math.floor(D / X) : void 0;
            if (ae !== void 0 && ae === H) return l.set(p, ae, L >>> X - re << X - re - V, le);
            if (ae !== void 0 && !l.set(p, ae, L >>> V % X, le)) return !1;
            const te = ae !== void 0 ? ae + 1 : V / X, ge = H !== void 0 ? H : D / X;
            for(let ce = te; ce < ge; ce++)if (!l.set(p, ce, L, le)) return !1;
            return !(H !== void 0 && ae !== H && !l.set(p, H, L << X - D % X, le));
        }
    }, u = {
        /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */ pushObj: (p, A, V)=>{
            const re = {
                obj: A
            };
            p.push(re), V((le, L)=>{
                re.field = le, L(), re.field = void 0;
            }), p.pop();
        },
        path: (p)=>{
            const A = [];
            for (const V of p)V.field !== void 0 && A.push(V.field);
            return A.join("/");
        },
        err (p, A, V) {
            const re = new Error(`${p}(${u.path(A)}): ${typeof V == "string" ? V : V.message}`);
            return V instanceof Error && V.stack && (re.stack = V.stack), re;
        },
        resolve: (p, A)=>{
            const V = A.split("/"), re = p.map((X)=>X.obj);
            let le = 0;
            for(; le < V.length && V[le] === ".."; le++)re.pop();
            let L = re.pop();
            for(; le < V.length; le++){
                if (!L || L[V[le]] === void 0) return;
                L = L[V[le]];
            }
            return L;
        }
    };
    class f {
        constructor(A, V = {}, re = [], le = void 0, L = 0){
            this.data = A, this.opts = V, this.stack = re, this.parent = le, this.parentOffset = L, this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.view = o(A);
        }
        /**
     * Internal method for pointers.
     */ _enablePointers() {
            if (this.parent) return this.parent._enablePointers();
            this.bs || (this.bs = l.create(this.data.length), l.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
        }
        markBytesBS(A, V) {
            return this.parent ? this.parent.markBytesBS(this.parentOffset + A, V) : !V || !this.bs ? !0 : l.setRange(this.bs, this.data.length, A, V, !1);
        }
        markBytes(A) {
            const V = this.pos;
            this.pos += A;
            const re = this.markBytesBS(V, A);
            if (!this.opts.allowMultipleReads && !re) throw this.err(`multiple read pos=${this.pos} len=${A}`);
            return re;
        }
        pushObj(A, V) {
            return u.pushObj(this.stack, A, V);
        }
        readView(A, V) {
            if (!Number.isFinite(A)) throw this.err(`readView: wrong length=${A}`);
            if (this.pos + A > this.data.length) throw this.err("readView: Unexpected end of buffer");
            const re = V(this.view, this.pos);
            return this.markBytes(A), re;
        }
        // read bytes by absolute offset
        absBytes(A) {
            if (A > this.data.length) throw new Error("Unexpected end of buffer");
            return this.data.subarray(A);
        }
        finish() {
            if (!this.opts.allowUnreadBytes) {
                if (this.bitPos) throw this.err(`${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
                if (this.bs && !this.parent) {
                    const A = l.indices(this.bs, this.data.length, !0);
                    if (A.length) {
                        const V = l.range(A).map(({ pos: re, length: le })=>`(${re}/${le})[${t.hex.encode(this.data.subarray(re, re + le))}]`).join(", ");
                        throw this.err(`unread byte ranges: ${V} (total=${this.data.length})`);
                    } else return;
                }
                if (!this.isEnd()) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
            }
        }
        // User methods
        err(A) {
            return u.err("Reader", this.stack, A);
        }
        offsetReader(A) {
            if (A > this.data.length) throw this.err("offsetReader: Unexpected end of buffer");
            return new f(this.absBytes(A), this.opts, this.stack, this, A);
        }
        bytes(A, V = !1) {
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(A)) throw this.err(`readBytes: wrong length=${A}`);
            if (this.pos + A > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const re = this.data.subarray(this.pos, this.pos + A);
            return V || this.markBytes(A), re;
        }
        byte(A = !1) {
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            if (this.pos + 1 > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const V = this.data[this.pos];
            return A || this.markBytes(1), V;
        }
        get leftBytes() {
            return this.data.length - this.pos;
        }
        get totalBytes() {
            return this.data.length;
        }
        isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
        }
        // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
        bits(A) {
            if (A > 32) throw this.err("BitReader: cannot read more than 32 bits in single call");
            let V = 0;
            for(; A;){
                this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
                const re = Math.min(A, this.bitPos);
                this.bitPos -= re, V = V << re | this.bitBuf >> this.bitPos & 2 ** re - 1, this.bitBuf &= 2 ** this.bitPos - 1, A -= re;
            }
            return V >>> 0;
        }
        find(A, V = this.pos) {
            if (!n(A)) throw this.err(`find: needle is not bytes! ${A}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!A.length) throw this.err("find: needle is empty");
            for(let re = V; (re = this.data.indexOf(A[0], re)) !== -1; re++){
                if (re === -1 || this.data.length - re < A.length) return;
                if (r(A, this.data.subarray(re, re + A.length))) return re;
            }
        }
    }
    class h {
        constructor(A = []){
            this.stack = A, this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = !1, this.view = o(this.viewBuf);
        }
        pushObj(A, V) {
            return u.pushObj(this.stack, A, V);
        }
        writeView(A, V) {
            if (this.finished) throw this.err("buffer: finished");
            if (!s(A) || A > 8) throw new Error(`wrong writeView length=${A}`);
            V(this.view), this.bytes(this.viewBuf.slice(0, A)), this.viewBuf.fill(0);
        }
        // User methods
        err(A) {
            if (this.finished) throw this.err("buffer: finished");
            return u.err("Reader", this.stack, A);
        }
        bytes(A) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(A), this.pos += A.length;
        }
        byte(A) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([
                A
            ])), this.pos++;
        }
        finish(A = !0) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("buffer: ends with non-empty bit buffer");
            const V = this.buffers.concat(this.ptrs.map((L)=>L.buffer)), re = V.map((L)=>L.length).reduce((L, X)=>L + X, 0), le = new Uint8Array(re);
            for(let L = 0, X = 0; L < V.length; L++){
                const ae = V[L];
                le.set(ae, X), X += ae.length;
            }
            for(let L = this.pos, X = 0; X < this.ptrs.length; X++){
                const ae = this.ptrs[X];
                le.set(ae.ptr.encode(L), ae.pos), L += ae.buffer.length;
            }
            if (A) {
                this.buffers = [];
                for (const L of this.ptrs)L.buffer.fill(0);
                this.ptrs = [], this.finished = !0, this.bitBuf = 0;
            }
            return le;
        }
        bits(A, V) {
            if (V > 32) throw this.err("writeBits: cannot write more than 32 bits in single call");
            if (A >= 2 ** V) throw this.err(`writeBits: value (${A}) >= 2**bits (${V})`);
            for(; V;){
                const re = Math.min(V, 8 - this.bitPos);
                this.bitBuf = this.bitBuf << re | A >> V - re, this.bitPos += re, V -= re, A &= 2 ** V - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([
                    this.bitBuf
                ])), this.pos++);
            }
        }
    }
    const y = (p)=>Uint8Array.from(p).reverse();
    function S(p, A, V) {
        if (V) {
            const re = 2n ** (A - 1n);
            if (p < -re || p >= re) throw new Error(`value out of signed bounds. Expected ${-re} <= ${p} < ${re}`);
        } else if (0n > p || p >= 2n ** A) throw new Error(`value out of unsigned bounds. Expected 0 <= ${p} < ${2n ** A}`);
    }
    function k(p) {
        return {
            // NOTE: we cannot export validate here, since it is likely mistake.
            encodeStream: p.encodeStream,
            decodeStream: p.decodeStream,
            size: p.size,
            encode: (A)=>{
                const V = new h();
                return p.encodeStream(V, A), V.finish();
            },
            decode: (A, V = {})=>{
                const re = new f(A, V), le = p.decodeStream(re);
                return re.finish(), le;
            }
        };
    }
    function P(p, A) {
        if (!z(p)) throw new Error(`validate: invalid inner value ${p}`);
        if (typeof A != "function") throw new Error("validate: fn should be function");
        return k({
            size: p.size,
            encodeStream: (V, re)=>{
                let le;
                try {
                    le = A(re);
                } catch (L) {
                    throw V.err(L);
                }
                p.encodeStream(V, le);
            },
            decodeStream: (V)=>{
                const re = p.decodeStream(V);
                try {
                    return A(re);
                } catch (le) {
                    throw V.err(le);
                }
            }
        });
    }
    e.validate = P;
    const M = (p)=>{
        const A = k(p);
        return p.validate ? P(A, p.validate) : A;
    };
    e.wrap = M;
    const N = (p)=>a(p) && typeof p.decode == "function" && typeof p.encode == "function";
    function z(p) {
        return a(p) && N(p) && typeof p.encodeStream == "function" && typeof p.decodeStream == "function" && (p.size === void 0 || s(p.size));
    }
    e.isCoder = z;
    function K() {
        return {
            encode: (p)=>{
                if (!Array.isArray(p)) throw new Error("array expected");
                const A = {};
                for (const V of p){
                    if (!Array.isArray(V) || V.length !== 2) throw new Error("array of two elements expected");
                    const re = V[0], le = V[1];
                    if (A[re] !== void 0) throw new Error(`key(${re}) appears twice in struct`);
                    A[re] = le;
                }
                return A;
            },
            decode: (p)=>{
                if (!a(p)) throw new Error(`expected plain object, got ${p}`);
                return Object.entries(p);
            }
        };
    }
    const $ = {
        encode: (p)=>{
            if (typeof p != "bigint") throw new Error(`expected bigint, got ${typeof p}`);
            if (p > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`element bigger than MAX_SAFE_INTEGER=${p}`);
            return Number(p);
        },
        decode: (p)=>{
            if (!s(p)) throw new Error("element is not a safe integer");
            return BigInt(p);
        }
    };
    function ne(p) {
        if (!a(p)) throw new Error("plain object expected");
        return {
            encode: (A)=>{
                if (!s(A) || !(A in p)) throw new Error(`wrong value ${A}`);
                return p[A];
            },
            decode: (A)=>{
                if (typeof A != "string") throw new Error(`wrong value ${typeof A}`);
                return p[A];
            }
        };
    }
    function ee(p, A = !1) {
        if (!s(p)) throw new Error(`decimal/precision: wrong value ${p}`);
        if (typeof A != "boolean") throw new Error(`decimal/round: expected boolean, got ${typeof A}`);
        const V = 10n ** BigInt(p);
        return {
            encode: (re)=>{
                if (typeof re != "bigint") throw new Error(`expected bigint, got ${typeof re}`);
                let le = (re < 0n ? -re : re).toString(10), L = le.length - p;
                L < 0 && (le = le.padStart(le.length - L, "0"), L = 0);
                let X = le.length - 1;
                for(; X >= L && le[X] === "0"; X--);
                let ae = le.slice(0, L), D = le.slice(L, X + 1);
                return ae || (ae = "0"), re < 0n && (ae = "-" + ae), D ? `${ae}.${D}` : ae;
            },
            decode: (re)=>{
                if (typeof re != "string") throw new Error(`expected string, got ${typeof re}`);
                if (re === "-0") throw new Error("negative zero is not allowed");
                let le = !1;
                if (re.startsWith("-") && (le = !0, re = re.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(re)) throw new Error(`wrong string value=${re}`);
                let L = re.indexOf(".");
                L = L === -1 ? re.length : L;
                const X = re.slice(0, L), ae = re.slice(L + 1).replace(/0+$/, ""), D = BigInt(X) * V;
                if (!A && ae.length > p) throw new Error(`fractional part cannot be represented with this precision (num=${re}, prec=${p})`);
                const H = Math.min(ae.length, p), te = BigInt(ae.slice(0, H)) * 10n ** BigInt(p - H), ge = D + te;
                return le ? -ge : ge;
            }
        };
    }
    function q(p) {
        if (!Array.isArray(p)) throw new Error(`expected array, got ${typeof p}`);
        for (const A of p)if (!N(A)) throw new Error(`wrong base coder ${A}`);
        return {
            encode: (A)=>{
                for (const V of p){
                    const re = V.encode(A);
                    if (re !== void 0) return re;
                }
                throw new Error(`match/encode: cannot find match in ${A}`);
            },
            decode: (A)=>{
                for (const V of p){
                    const re = V.decode(A);
                    if (re !== void 0) return re;
                }
                throw new Error(`match/decode: cannot find match in ${A}`);
            }
        };
    }
    const U = (p)=>{
        if (!N(p)) throw new Error("BaseCoder expected");
        return {
            encode: p.decode,
            decode: p.encode
        };
    };
    e.coders = {
        dict: K,
        numberBigint: $,
        tsEnum: ne,
        decimal: ee,
        match: q,
        reverse: U
    };
    const Q = (p)=>{
        if (!s(p)) throw new Error(`bits: wrong length ${p} (${typeof p})`);
        return (0, e.wrap)({
            encodeStream: (A, V)=>A.bits(V, p),
            decodeStream: (A)=>A.bits(p),
            validate: (A)=>{
                if (!s(A)) throw new Error(`bits: wrong value ${A}`);
                return A;
            }
        });
    };
    e.bits = Q;
    const v = (p, A = !1, V = !1, re = !0)=>{
        if (!s(p)) throw new Error(`bigint/size: wrong value ${p}`);
        if (typeof A != "boolean") throw new Error(`bigint/le: expected boolean, got ${typeof A}`);
        if (typeof V != "boolean") throw new Error(`bigint/signed: expected boolean, got ${typeof V}`);
        if (typeof re != "boolean") throw new Error(`bigint/sized: expected boolean, got ${typeof re}`);
        const le = BigInt(p), L = 2n ** (8n * le - 1n);
        return (0, e.wrap)({
            size: re ? p : void 0,
            encodeStream: (X, ae)=>{
                V && ae < 0 && (ae = ae | L);
                const D = [];
                for(let te = 0; te < p; te++)D.push(Number(ae & 255n)), ae >>= 8n;
                let H = new Uint8Array(D).reverse();
                if (!re) {
                    let te = 0;
                    for(te = 0; te < H.length && H[te] === 0; te++);
                    H = H.subarray(te);
                }
                X.bytes(A ? H.reverse() : H);
            },
            decodeStream: (X)=>{
                const ae = X.bytes(re ? p : Math.min(p, X.leftBytes)), D = A ? ae : y(ae);
                let H = 0n;
                for(let te = 0; te < D.length; te++)H |= BigInt(D[te]) << 8n * BigInt(te);
                return V && H & L && (H = (H ^ L) - L), H;
            },
            validate: (X)=>{
                if (typeof X != "bigint") throw new Error(`bigint: invalid value: ${X}`);
                return S(X, 8n * le, !!V), X;
            }
        });
    };
    e.bigint = v, e.U256LE = (0, e.bigint)(32, !0), e.U256BE = (0, e.bigint)(32, !1), e.I256LE = (0, e.bigint)(32, !0, !0), e.I256BE = (0, e.bigint)(32, !1, !0), e.U128LE = (0, e.bigint)(16, !0), e.U128BE = (0, e.bigint)(16, !1), e.I128LE = (0, e.bigint)(16, !0, !0), e.I128BE = (0, e.bigint)(16, !1, !0), e.U64LE = (0, e.bigint)(8, !0), e.U64BE = (0, e.bigint)(8, !1), e.I64LE = (0, e.bigint)(8, !0, !0), e.I64BE = (0, e.bigint)(8, !1, !0);
    const B = (p, A = !1, V = !1, re = !0)=>{
        if (!s(p)) throw new Error(`int/size: wrong value ${p}`);
        if (typeof A != "boolean") throw new Error(`int/le: expected boolean, got ${typeof A}`);
        if (typeof V != "boolean") throw new Error(`int/signed: expected boolean, got ${typeof V}`);
        if (typeof re != "boolean") throw new Error(`int/sized: expected boolean, got ${typeof re}`);
        if (p > 6) throw new Error("int supports size up to 6 bytes (48 bits): use bigints instead");
        return j((0, e.bigint)(p, A, V, re), e.coders.numberBigint);
    };
    e.int = B;
    const g = (p, A)=>(0, e.wrap)({
            size: p,
            encodeStream: (V, re)=>V.writeView(p, (le)=>A.write(le, re)),
            decodeStream: (V)=>V.readView(p, A.read),
            validate: (V)=>{
                if (typeof V != "number") throw new Error(`viewCoder: expected number, got ${typeof V}`);
                return A.validate && A.validate(V), V;
            }
        }), E = (p, A, V)=>{
        const re = p * 8, le = 2 ** (re - 1), L = (D)=>{
            if (!s(D)) throw new Error(`sintView: value is not safe integer: ${D}`);
            if (D < -le || D >= le) throw new Error(`sintView: value out of bounds. Expected ${-le} <= ${D} < ${le}`);
        }, X = 2 ** re, ae = (D)=>{
            if (!s(D)) throw new Error(`uintView: value is not safe integer: ${D}`);
            if (0 > D || D >= X) throw new Error(`uintView: value out of bounds. Expected 0 <= ${D} < ${X}`);
        };
        return g(p, {
            write: V.write,
            read: V.read,
            validate: A ? L : ae
        });
    };
    e.U32LE = E(4, !1, {
        read: (p, A)=>p.getUint32(A, !0),
        write: (p, A)=>p.setUint32(0, A, !0)
    }), e.U32BE = E(4, !1, {
        read: (p, A)=>p.getUint32(A, !1),
        write: (p, A)=>p.setUint32(0, A, !1)
    }), e.I32LE = E(4, !0, {
        read: (p, A)=>p.getInt32(A, !0),
        write: (p, A)=>p.setInt32(0, A, !0)
    }), e.I32BE = E(4, !0, {
        read: (p, A)=>p.getInt32(A, !1),
        write: (p, A)=>p.setInt32(0, A, !1)
    }), e.U16LE = E(2, !1, {
        read: (p, A)=>p.getUint16(A, !0),
        write: (p, A)=>p.setUint16(0, A, !0)
    }), e.U16BE = E(2, !1, {
        read: (p, A)=>p.getUint16(A, !1),
        write: (p, A)=>p.setUint16(0, A, !1)
    }), e.I16LE = E(2, !0, {
        read: (p, A)=>p.getInt16(A, !0),
        write: (p, A)=>p.setInt16(0, A, !0)
    }), e.I16BE = E(2, !0, {
        read: (p, A)=>p.getInt16(A, !1),
        write: (p, A)=>p.setInt16(0, A, !1)
    }), e.U8 = E(1, !1, {
        read: (p, A)=>p.getUint8(A),
        write: (p, A)=>p.setUint8(0, A)
    }), e.I8 = E(1, !0, {
        read: (p, A)=>p.getInt8(A),
        write: (p, A)=>p.setInt8(0, A)
    });
    const w = (p)=>g(4, {
            read: (A, V)=>A.getFloat32(V, p),
            write: (A, V)=>A.setFloat32(0, V, p),
            validate: (A)=>{
                if (Math.fround(A) !== A && !Number.isNaN(A)) throw new Error(`f32: wrong value=${A}`);
            }
        }), _ = (p)=>g(8, {
            read: (A, V)=>A.getFloat64(V, p),
            write: (A, V)=>A.setFloat64(0, V, p)
        });
    e.F32BE = w(!1), e.F32LE = w(!0), e.F64BE = _(!1), e.F64LE = _(!0), e.bool = (0, e.wrap)({
        size: 1,
        encodeStream: (p, A)=>p.byte(A ? 1 : 0),
        decodeStream: (p)=>{
            const A = p.byte();
            if (A !== 0 && A !== 1) throw p.err(`bool: invalid value ${A}`);
            return A === 1;
        },
        validate: (p)=>{
            if (typeof p != "boolean") throw new Error(`bool: invalid value ${p}`);
            return p;
        }
    });
    const O = (p, A = !1)=>{
        if (typeof A != "boolean") throw new Error(`bytes/le: expected boolean, got ${typeof A}`);
        const V = c(p), re = n(p);
        return (0, e.wrap)({
            size: typeof p == "number" ? p : void 0,
            encodeStream: (le, L)=>{
                re || V.encodeStream(le, L.length), le.bytes(A ? y(L) : L), re && le.bytes(p);
            },
            decodeStream: (le)=>{
                let L;
                if (re) {
                    const X = le.find(p);
                    if (!X) throw le.err("bytes: cannot find terminator");
                    L = le.bytes(X - le.pos), le.bytes(p.length);
                } else L = le.bytes(p === null ? le.leftBytes : V.decodeStream(le));
                return A ? y(L) : L;
            },
            validate: (le)=>{
                if (!n(le)) throw new Error(`bytes: invalid value ${le}`);
                return le;
            }
        });
    };
    e.bytes = O;
    function I(p, A) {
        if (!z(A)) throw new Error(`prefix: invalid inner value ${A}`);
        return j((0, e.bytes)(p), U(A));
    }
    e.prefix = I;
    const x = (p, A = !1)=>P(j((0, e.bytes)(p, A), t.utf8), (V)=>{
            if (typeof V != "string") throw new Error(`expected string, got ${typeof V}`);
            return V;
        });
    e.string = x, e.cstring = (0, e.string)(e.NULL);
    const R = (p, A = {
        isLE: !1,
        with0x: !1
    })=>{
        let V = j((0, e.bytes)(p, A.isLE), t.hex);
        if (typeof A.with0x != "boolean") throw new Error(`hex/with0x: expected boolean, got ${typeof A.with0x}`);
        return A.with0x && (V = j(V, {
            encode: (re)=>`0x${re}`,
            decode: (re)=>{
                if (!re.startsWith("0x")) throw new Error("hex(with0x=true).encode input should start with 0x");
                return re.slice(2);
            }
        })), V;
    };
    e.hex = R;
    function j(p, A) {
        if (!z(p)) throw new Error(`apply: invalid inner value ${p}`);
        if (!N(A)) throw new Error(`apply: invalid base value ${p}`);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (V, re)=>{
                let le;
                try {
                    le = A.decode(re);
                } catch (L) {
                    throw V.err("" + L);
                }
                return p.encodeStream(V, le);
            },
            decodeStream: (V)=>{
                const re = p.decodeStream(V);
                try {
                    return A.encode(re);
                } catch (le) {
                    throw V.err("" + le);
                }
            }
        });
    }
    e.apply = j;
    function Y(p) {
        if (typeof p != "function") throw new Error(`lazy: expected function, got ${typeof p}`);
        return (0, e.wrap)({
            encodeStream: (A, V)=>p().encodeStream(A, V),
            decodeStream: (A)=>p().decodeStream(A)
        });
    }
    e.lazy = Y;
    const he = (p, A = !1)=>{
        if (!n(p)) throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof p}`);
        if (typeof A != "boolean") throw new Error(`flag/xor: expected boolean, got ${typeof A}`);
        return (0, e.wrap)({
            size: p.length,
            encodeStream: (V, re)=>{
                !!re !== A && V.bytes(p);
            },
            decodeStream: (V)=>{
                let re = V.leftBytes >= p.length;
                return re && (re = r(V.bytes(p.length, !0), p), re && V.bytes(p.length)), re !== A;
            },
            validate: (V)=>{
                if (V !== void 0 && typeof V != "boolean") throw new Error(`flag: expected boolean value or undefined, got ${typeof V}`);
                return V;
            }
        });
    };
    e.flag = he;
    function ue(p, A, V) {
        if (!z(A)) throw new Error(`flagged: invalid inner value ${A}`);
        if (typeof p != "string" && !z(A)) throw new Error(`flagged: wrong path=${p}`);
        return (0, e.wrap)({
            encodeStream: (re, le)=>{
                typeof p == "string" ? u.resolve(re.stack, p) ? A.encodeStream(re, le) : V && A.encodeStream(re, V) : (p.encodeStream(re, !!le), le ? A.encodeStream(re, le) : V && A.encodeStream(re, V));
            },
            decodeStream: (re)=>{
                let le = !1;
                if (typeof p == "string" ? le = !!u.resolve(re.stack, p) : le = p.decodeStream(re), le) return A.decodeStream(re);
                V && A.decodeStream(re);
            }
        });
    }
    e.flagged = ue;
    function G(p, A, V) {
        if (!z(p) || !z(A)) throw new Error(`optional: invalid flag or inner value flag=${p} inner=${A}`);
        return (0, e.wrap)({
            size: V !== void 0 && p.size && A.size ? p.size + A.size : void 0,
            encodeStream: (re, le)=>{
                p.encodeStream(re, !!le), le ? A.encodeStream(re, le) : V !== void 0 && A.encodeStream(re, V);
            },
            decodeStream: (re)=>{
                if (p.decodeStream(re)) return A.decodeStream(re);
                V !== void 0 && A.decodeStream(re);
            }
        });
    }
    e.optional = G;
    function se(p, A, V = !0) {
        if (!z(p)) throw new Error(`magic: invalid inner value ${p}`);
        if (typeof V != "boolean") throw new Error(`magic: expected boolean, got ${typeof V}`);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (re, le)=>p.encodeStream(re, A),
            decodeStream: (re)=>{
                const le = p.decodeStream(re);
                if (V && typeof le != "object" && le !== A || n(A) && !r(A, le)) throw re.err(`magic: invalid value: ${le} !== ${A}`);
            },
            validate: (re)=>{
                if (re !== void 0) throw new Error(`magic: wrong value=${typeof re}`);
                return re;
            }
        });
    }
    e.magic = se;
    const Z = (p)=>{
        const A = typeof p == "string" ? t.utf8.decode(p) : p;
        return se((0, e.bytes)(A.length), A);
    };
    e.magicBytes = Z;
    function ie(p) {
        return (0, e.wrap)({
            encodeStream: (A, V)=>{
                if (V !== p) throw new Error(`constant: invalid value ${V} (exp: ${p})`);
            },
            decodeStream: (A)=>p
        });
    }
    e.constant = ie;
    function pe(p) {
        let A = 0;
        for (const V of p){
            if (V.size === void 0) return;
            if (!s(V.size)) throw new Error(`sizeof: wrong element size=${A}`);
            A += V.size;
        }
        return A;
    }
    function ve(p) {
        if (!a(p)) throw new Error(`struct: expected plain object, got ${p}`);
        for(const A in p)if (!z(p[A])) throw new Error(`struct: field ${A} is not CoderType`);
        return (0, e.wrap)({
            size: pe(Object.values(p)),
            encodeStream: (A, V)=>{
                A.pushObj(V, (re)=>{
                    for(const le in p)re(le, ()=>p[le].encodeStream(A, V[le]));
                });
            },
            decodeStream: (A)=>{
                const V = {};
                return A.pushObj(V, (re)=>{
                    for(const le in p)re(le, ()=>V[le] = p[le].decodeStream(A));
                }), V;
            },
            validate: (A)=>{
                if (typeof A != "object" || A === null) throw new Error(`struct: invalid value ${A}`);
                return A;
            }
        });
    }
    e.struct = ve;
    function Ie(p) {
        if (!Array.isArray(p)) throw new Error(`Packed.Tuple: got ${typeof p} instead of array`);
        for(let A = 0; A < p.length; A++)if (!z(p[A])) throw new Error(`tuple: field ${A} is not CoderType`);
        return (0, e.wrap)({
            size: pe(p),
            encodeStream: (A, V)=>{
                if (!Array.isArray(V)) throw A.err(`tuple: invalid value ${V}`);
                A.pushObj(V, (re)=>{
                    for(let le = 0; le < p.length; le++)re(`${le}`, ()=>p[le].encodeStream(A, V[le]));
                });
            },
            decodeStream: (A)=>{
                const V = [];
                return A.pushObj(V, (re)=>{
                    for(let le = 0; le < p.length; le++)re(`${le}`, ()=>V.push(p[le].decodeStream(A)));
                }), V;
            },
            validate: (A)=>{
                if (!Array.isArray(A)) throw new Error(`tuple: invalid value ${A}`);
                if (A.length !== p.length) throw new Error(`tuple: wrong length=${A.length}, expected ${p.length}`);
                return A;
            }
        });
    }
    e.tuple = Ie;
    function Me(p, A) {
        if (!z(A)) throw new Error(`array: invalid inner value ${A}`);
        const V = c(typeof p == "string" ? `../${p}` : p);
        return (0, e.wrap)({
            size: typeof p == "number" && A.size ? p * A.size : void 0,
            encodeStream: (re, le)=>{
                const L = re;
                L.pushObj(le, (X)=>{
                    n(p) || V.encodeStream(re, le.length);
                    for(let ae = 0; ae < le.length; ae++)X(`${ae}`, ()=>{
                        const D = le[ae], H = re.pos;
                        if (A.encodeStream(re, D), n(p)) {
                            if (p.length > L.pos - H) return;
                            const te = L.finish(!1).subarray(H, L.pos);
                            if (r(te.subarray(0, p.length), p)) throw L.err(`array: inner element encoding same as separator. elm=${D} data=${te}`);
                        }
                    });
                }), n(p) && re.bytes(p);
            },
            decodeStream: (re)=>{
                const le = [];
                return re.pushObj(le, (L)=>{
                    if (p === null) for(let X = 0; !re.isEnd() && (L(`${X}`, ()=>le.push(A.decodeStream(re))), !(A.size && re.leftBytes < A.size)); X++);
                    else if (n(p)) for(let X = 0;; X++){
                        if (r(re.bytes(p.length, !0), p)) {
                            re.bytes(p.length);
                            break;
                        }
                        L(`${X}`, ()=>le.push(A.decodeStream(re)));
                    }
                    else {
                        let X;
                        L("arrayLen", ()=>X = V.decodeStream(re));
                        for(let ae = 0; ae < X; ae++)L(`${ae}`, ()=>le.push(A.decodeStream(re)));
                    }
                }), le;
            },
            validate: (re)=>{
                if (!Array.isArray(re)) throw new Error(`array: invalid value ${re}`);
                return re;
            }
        });
    }
    e.array = Me;
    function Re(p, A) {
        if (!z(p)) throw new Error(`map: invalid inner value ${p}`);
        if (!a(A)) throw new Error("map: variants should be plain object");
        const V = /* @__PURE__ */ new Map();
        for(const re in A)V.set(A[re], re);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (re, le)=>p.encodeStream(re, A[le]),
            decodeStream: (re)=>{
                const le = p.decodeStream(re), L = V.get(le);
                if (L === void 0) throw re.err(`Enum: unknown value: ${le} ${Array.from(V.keys())}`);
                return L;
            },
            validate: (re)=>{
                if (typeof re != "string") throw new Error(`map: invalid value ${re}`);
                if (!(re in A)) throw new Error(`Map: unknown variant: ${re}`);
                return re;
            }
        });
    }
    e.map = Re;
    function C(p, A) {
        if (!z(p)) throw new Error(`tag: invalid tag value ${p}`);
        if (!a(A)) throw new Error("tag: variants should be plain object");
        for(const V in A)if (!z(A[V])) throw new Error(`tag: variant ${V} is not CoderType`);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (V, re)=>{
                const { TAG: le, data: L } = re, X = A[le];
                p.encodeStream(V, le), X.encodeStream(V, L);
            },
            decodeStream: (V)=>{
                const re = p.decodeStream(V), le = A[re];
                if (!le) throw V.err(`Tag: invalid tag ${re}`);
                return {
                    TAG: re,
                    data: le.decodeStream(V)
                };
            },
            validate: (V)=>{
                const { TAG: re } = V;
                if (!A[re]) throw new Error(`Tag: invalid tag ${re.toString()}`);
                return V;
            }
        });
    }
    e.tag = C;
    function J(p, A) {
        if (!z(p)) throw new Error(`mappedTag: invalid tag value ${C}`);
        if (!a(A)) throw new Error("mappedTag: variants should be plain object");
        const V = {}, re = {};
        for(const le in A){
            const L = A[le];
            V[le] = L[0], re[le] = L[1];
        }
        return C(Re(p, V), re);
    }
    e.mappedTag = J;
    function me(p, A = !1) {
        if (typeof A != "boolean") throw new Error(`bitset/pad: expected boolean, got ${typeof A}`);
        if (!Array.isArray(p)) throw new Error("bitset/names: expected array");
        for (const V of p)if (typeof V != "string") throw new Error("bitset/names: expected array of strings");
        return (0, e.wrap)({
            encodeStream: (V, re)=>{
                for(let le = 0; le < p.length; le++)V.bits(+re[p[le]], 1);
                A && p.length % 8 && V.bits(0, 8 - p.length % 8);
            },
            decodeStream: (V)=>{
                const re = {};
                for(let le = 0; le < p.length; le++)re[p[le]] = !!V.bits(1);
                return A && p.length % 8 && V.bits(8 - p.length % 8), re;
            },
            validate: (V)=>{
                if (!a(V)) throw new Error(`bitset: invalid value ${V}`);
                for (const re of Object.values(V))if (typeof re != "boolean") throw new Error("expected boolean");
                return V;
            }
        });
    }
    e.bitset = me;
    const je = (p)=>0;
    e.ZeroPad = je;
    function Ve(p, A) {
        return A % p === 0 ? 0 : p - A % p;
    }
    function nt(p, A, V) {
        if (!s(p) || p <= 0) throw new Error(`padLeft: wrong blockSize=${p}`);
        if (!z(A)) throw new Error(`padLeft: invalid inner value ${A}`);
        if (V !== void 0 && typeof V != "function") throw new Error(`padLeft: wrong padFn=${typeof V}`);
        const re = V || e.ZeroPad;
        if (!A.size) throw new Error("padLeft cannot have dynamic size");
        return (0, e.wrap)({
            size: A.size + Ve(p, A.size),
            encodeStream: (le, L)=>{
                const X = Ve(p, A.size);
                for(let ae = 0; ae < X; ae++)le.byte(re(ae));
                A.encodeStream(le, L);
            },
            decodeStream: (le)=>(le.bytes(Ve(p, A.size)), A.decodeStream(le))
        });
    }
    e.padLeft = nt;
    function We(p, A, V) {
        if (!z(A)) throw new Error(`padRight: invalid inner value ${A}`);
        if (!s(p) || p <= 0) throw new Error(`padLeft: wrong blockSize=${p}`);
        if (V !== void 0 && typeof V != "function") throw new Error(`padRight: wrong padFn=${typeof V}`);
        const re = V || e.ZeroPad;
        return (0, e.wrap)({
            size: A.size ? A.size + Ve(p, A.size) : void 0,
            encodeStream: (le, L)=>{
                const X = le, ae = X.pos;
                A.encodeStream(le, L);
                const D = Ve(p, X.pos - ae);
                for(let H = 0; H < D; H++)le.byte(re(H));
            },
            decodeStream: (le)=>{
                const L = le.pos, X = A.decodeStream(le);
                return le.bytes(Ve(p, le.pos - L)), X;
            }
        });
    }
    e.padRight = We;
    function Ge(p, A, V = !1) {
        if (!z(p)) throw new Error(`pointer: invalid ptr value ${p}`);
        if (!z(A)) throw new Error(`pointer: invalid inner value ${A}`);
        if (typeof V != "boolean") throw new Error(`pointer/sized: expected boolean, got ${typeof V}`);
        if (!p.size) throw new Error("unsized pointer");
        return (0, e.wrap)({
            size: V ? p.size : void 0,
            encodeStream: (re, le)=>{
                const L = re, X = L.pos;
                p.encodeStream(re, 0), L.ptrs.push({
                    pos: X,
                    ptr: p,
                    buffer: A.encode(le)
                });
            },
            decodeStream: (re)=>{
                const le = p.decodeStream(re);
                return re._enablePointers(), A.decodeStream(re.offsetReader(le));
            }
        });
    }
    e.pointer = Ge, e._TEST = {
        _bitset: l,
        _Reader: f,
        _Writer: h,
        Path: u
    };
})(M5);
var N5 = {}, Gs = {}, vo = {};
Object.defineProperty(vo, "__esModule", {
    value: !0
});
vo.ripemd160 = vo.RIPEMD160 = vo.md5 = vo.MD5 = vo.sha1 = vo.SHA1 = void 0;
const df = Hi, ki = Qr, Od = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
]), lc = /* @__PURE__ */ new Uint32Array(80);
class cR extends df.HashMD {
    constructor(){
        super(64, 20, 8, !1), this.A = Od[0] | 0, this.B = Od[1] | 0, this.C = Od[2] | 0, this.D = Od[3] | 0, this.E = Od[4] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i1, E: o } = this;
        return [
            t,
            r,
            n,
            i1,
            o
        ];
    }
    set(t, r, n, i1, o) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i1 | 0, this.E = o | 0;
    }
    process(t, r) {
        for(let c = 0; c < 16; c++, r += 4)lc[c] = t.getUint32(r, !1);
        for(let c = 16; c < 80; c++)lc[c] = (0, ki.rotl)(lc[c - 3] ^ lc[c - 8] ^ lc[c - 14] ^ lc[c - 16], 1);
        let { A: n, B: i1, C: o, D: a, E: s } = this;
        for(let c = 0; c < 80; c++){
            let l, u;
            c < 20 ? (l = (0, df.Chi)(i1, o, a), u = 1518500249) : c < 40 ? (l = i1 ^ o ^ a, u = 1859775393) : c < 60 ? (l = (0, df.Maj)(i1, o, a), u = 2400959708) : (l = i1 ^ o ^ a, u = 3395469782);
            const f = (0, ki.rotl)(n, 5) + l + s + u + lc[c] | 0;
            s = a, a = o, o = (0, ki.rotl)(i1, 30), i1 = n, n = f;
        }
        n = n + this.A | 0, i1 = i1 + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, s = s + this.E | 0, this.set(n, i1, o, a, s);
    }
    roundClean() {
        (0, ki.clean)(lc);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0), (0, ki.clean)(this.buffer);
    }
}
vo.SHA1 = cR;
vo.sha1 = (0, ki.createHasher)(()=>new cR());
const yle = /* @__PURE__ */ Math.pow(2, 32), mle = /* @__PURE__ */ Array.from({
    length: 64
}, (e, t)=>Math.floor(yle * Math.abs(Math.sin(t + 1)))), by = /* @__PURE__ */ Od.slice(0, 4), F3 = /* @__PURE__ */ new Uint32Array(16);
class lR extends df.HashMD {
    constructor(){
        super(64, 16, 8, !0), this.A = by[0] | 0, this.B = by[1] | 0, this.C = by[2] | 0, this.D = by[3] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i1 } = this;
        return [
            t,
            r,
            n,
            i1
        ];
    }
    set(t, r, n, i1) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i1 | 0;
    }
    process(t, r) {
        for(let s = 0; s < 16; s++, r += 4)F3[s] = t.getUint32(r, !0);
        let { A: n, B: i1, C: o, D: a } = this;
        for(let s = 0; s < 64; s++){
            let c, l, u;
            s < 16 ? (c = (0, df.Chi)(i1, o, a), l = s, u = [
                7,
                12,
                17,
                22
            ]) : s < 32 ? (c = (0, df.Chi)(a, i1, o), l = (5 * s + 1) % 16, u = [
                5,
                9,
                14,
                20
            ]) : s < 48 ? (c = i1 ^ o ^ a, l = (3 * s + 5) % 16, u = [
                4,
                11,
                16,
                23
            ]) : (c = o ^ (i1 | ~a), l = 7 * s % 16, u = [
                6,
                10,
                15,
                21
            ]), c = c + n + mle[s] + F3[l], n = a, a = o, o = i1, i1 = i1 + (0, ki.rotl)(c, u[s % 4]);
        }
        n = n + this.A | 0, i1 = i1 + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, this.set(n, i1, o, a);
    }
    roundClean() {
        (0, ki.clean)(F3);
    }
    destroy() {
        this.set(0, 0, 0, 0), (0, ki.clean)(this.buffer);
    }
}
vo.MD5 = lR;
vo.md5 = (0, ki.createHasher)(()=>new lR());
const ble = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), fR = Uint8Array.from(new Array(16).fill(0).map((e, t)=>t)), wle = fR.map((e)=>(9 * e + 5) % 16), dR = /* @__PURE__ */ (()=>{
    const e = [
        [
            fR
        ],
        [
            wle
        ]
    ];
    for(let t = 0; t < 4; t++)for (let r of e)r.push(r[t].map((n)=>ble[n]));
    return e;
})(), hR = dR[0], pR = dR[1], gR = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>Uint8Array.from(e)), Ale = /* @__PURE__ */ hR.map((e, t)=>e.map((r)=>gR[t][r])), vle = /* @__PURE__ */ pR.map((e, t)=>e.map((r)=>gR[t][r])), Ele = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), Sle = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]);
function fI(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const wy = /* @__PURE__ */ new Uint32Array(16);
let yR = class extends df.HashMD {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: e, h1: t, h2: r, h3: n, h4: i1 } = this;
        return [
            e,
            t,
            r,
            n,
            i1
        ];
    }
    set(e, t, r, n, i1) {
        this.h0 = e | 0, this.h1 = t | 0, this.h2 = r | 0, this.h3 = n | 0, this.h4 = i1 | 0;
    }
    process(e, t) {
        for(let h = 0; h < 16; h++, t += 4)wy[h] = e.getUint32(t, !0);
        let r = this.h0 | 0, n = r, i1 = this.h1 | 0, o = i1, a = this.h2 | 0, s = a, c = this.h3 | 0, l = c, u = this.h4 | 0, f = u;
        for(let h = 0; h < 5; h++){
            const y = 4 - h, S = Ele[h], k = Sle[h], P = hR[h], M = pR[h], N = Ale[h], z = vle[h];
            for(let K = 0; K < 16; K++){
                const $ = (0, ki.rotl)(r + fI(h, i1, a, c) + wy[P[K]] + S, N[K]) + u | 0;
                r = u, u = c, c = (0, ki.rotl)(a, 10) | 0, a = i1, i1 = $;
            }
            for(let K = 0; K < 16; K++){
                const $ = (0, ki.rotl)(n + fI(y, o, s, l) + wy[M[K]] + k, z[K]) + f | 0;
                n = f, f = l, l = (0, ki.rotl)(s, 10) | 0, s = o, o = $;
            }
        }
        this.set(this.h1 + a + l | 0, this.h2 + c + f | 0, this.h3 + u + n | 0, this.h4 + r + o | 0, this.h0 + i1 + s | 0);
    }
    roundClean() {
        (0, ki.clean)(wy);
    }
    destroy() {
        this.destroyed = !0, (0, ki.clean)(this.buffer), this.set(0, 0, 0, 0, 0);
    }
};
vo.RIPEMD160 = yR;
vo.ripemd160 = (0, ki.createHasher)(()=>new yR());
var Ff = {}, Xh = {};
(function(e) {
    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0;
    function t(ue) {
        return ue instanceof Uint8Array || ArrayBuffer.isView(ue) && ue.constructor.name === "Uint8Array";
    }
    function r(ue, ...G) {
        if (!t(ue)) throw new Error("Uint8Array expected");
        if (G.length > 0 && !G.includes(ue.length)) throw new Error("Uint8Array expected of length " + G + ", got length=" + ue.length);
    }
    function n(ue, G) {
        return Array.isArray(G) ? G.length === 0 ? !0 : ue ? G.every((se)=>typeof se == "string") : G.every((se)=>Number.isSafeInteger(se)) : !1;
    }
    function i1(ue) {
        if (typeof ue != "function") throw new Error("function expected");
        return !0;
    }
    function o(ue, G) {
        if (typeof G != "string") throw new Error(`${ue}: string expected`);
        return !0;
    }
    function a(ue) {
        if (!Number.isSafeInteger(ue)) throw new Error(`invalid integer: ${ue}`);
    }
    function s(ue) {
        if (!Array.isArray(ue)) throw new Error("array expected");
    }
    function c(ue, G) {
        if (!n(!0, G)) throw new Error(`${ue}: array of strings expected`);
    }
    function l(ue, G) {
        if (!n(!1, G)) throw new Error(`${ue}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function u(...ue) {
        const G = (pe)=>pe, se = (pe, ve)=>(Ie)=>pe(ve(Ie)), Z = ue.map((pe)=>pe.encode).reduceRight(se, G), ie = ue.map((pe)=>pe.decode).reduce(se, G);
        return {
            encode: Z,
            decode: ie
        };
    }
    // @__NO_SIDE_EFFECTS__
    function f(ue) {
        const G = typeof ue == "string" ? ue.split("") : ue, se = G.length;
        c("alphabet", G);
        const Z = new Map(G.map((ie, pe)=>[
                ie,
                pe
            ]));
        return {
            encode: (ie)=>(s(ie), ie.map((pe)=>{
                    if (!Number.isSafeInteger(pe) || pe < 0 || pe >= se) throw new Error(`alphabet.encode: digit index outside alphabet "${pe}". Allowed: ${ue}`);
                    return G[pe];
                })),
            decode: (ie)=>(s(ie), ie.map((pe)=>{
                    o("alphabet.decode", pe);
                    const ve = Z.get(pe);
                    if (ve === void 0) throw new Error(`Unknown letter: "${pe}". Allowed: ${ue}`);
                    return ve;
                }))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function h(ue = "") {
        return o("join", ue), {
            encode: (G)=>(c("join.decode", G), G.join(ue)),
            decode: (G)=>(o("join.decode", G), G.split(ue))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function y(ue, G = "=") {
        return a(ue), o("padding", G), {
            encode (se) {
                for(c("padding.encode", se); se.length * ue % 8;)se.push(G);
                return se;
            },
            decode (se) {
                c("padding.decode", se);
                let Z = se.length;
                if (Z * ue % 8) throw new Error("padding: invalid, string should have whole number of bytes");
                for(; Z > 0 && se[Z - 1] === G; Z--)if ((Z - 1) * ue % 8 === 0) throw new Error("padding: invalid, string has too much padding");
                return se.slice(0, Z);
            }
        };
    }
    // @__NO_SIDE_EFFECTS__
    function S(ue) {
        return i1(ue), {
            encode: (G)=>G,
            decode: (G)=>ue(G)
        };
    }
    function k(ue, G, se) {
        if (G < 2) throw new Error(`convertRadix: invalid from=${G}, base cannot be less than 2`);
        if (se < 2) throw new Error(`convertRadix: invalid to=${se}, base cannot be less than 2`);
        if (s(ue), !ue.length) return [];
        let Z = 0;
        const ie = [], pe = Array.from(ue, (Ie)=>{
            if (a(Ie), Ie < 0 || Ie >= G) throw new Error(`invalid integer: ${Ie}`);
            return Ie;
        }), ve = pe.length;
        for(;;){
            let Ie = 0, Me = !0;
            for(let Re = Z; Re < ve; Re++){
                const C = pe[Re], J = G * Ie, me = J + C;
                if (!Number.isSafeInteger(me) || J / G !== Ie || me - C !== J) throw new Error("convertRadix: carry overflow");
                const je = me / se;
                Ie = me % se;
                const Ve = Math.floor(je);
                if (pe[Re] = Ve, !Number.isSafeInteger(Ve) || Ve * se + Ie !== me) throw new Error("convertRadix: carry overflow");
                if (Me) Ve ? Me = !1 : Z = Re;
                else continue;
            }
            if (ie.push(Ie), Me) break;
        }
        for(let Ie = 0; Ie < ue.length - 1 && ue[Ie] === 0; Ie++)ie.push(0);
        return ie.reverse();
    }
    const P = (ue, G)=>G === 0 ? ue : P(G, ue % G), M = /* @__NO_SIDE_EFFECTS__ */ (ue, G)=>ue + (G - P(ue, G)), N = /* @__PURE__ */ (()=>{
        let ue = [];
        for(let G = 0; G < 40; G++)ue.push(2 ** G);
        return ue;
    })();
    function z(ue, G, se, Z) {
        if (s(ue), G <= 0 || G > 32) throw new Error(`convertRadix2: wrong from=${G}`);
        if (se <= 0 || se > 32) throw new Error(`convertRadix2: wrong to=${se}`);
        if (/* @__PURE__ */ M(G, se) > 32) throw new Error(`convertRadix2: carry overflow from=${G} to=${se} carryBits=${/* @__PURE__ */ M(G, se)}`);
        let ie = 0, pe = 0;
        const ve = N[G], Ie = N[se] - 1, Me = [];
        for (const Re of ue){
            if (a(Re), Re >= ve) throw new Error(`convertRadix2: invalid data word=${Re} from=${G}`);
            if (ie = ie << G | Re, pe + G > 32) throw new Error(`convertRadix2: carry overflow pos=${pe} from=${G}`);
            for(pe += G; pe >= se; pe -= se)Me.push((ie >> pe - se & Ie) >>> 0);
            const C = N[pe];
            if (C === void 0) throw new Error("invalid carry");
            ie &= C - 1;
        }
        if (ie = ie << se - pe & Ie, !Z && pe >= G) throw new Error("Excess padding");
        if (!Z && ie > 0) throw new Error(`Non-zero padding: ${ie}`);
        return Z && pe > 0 && Me.push(ie >>> 0), Me;
    }
    // @__NO_SIDE_EFFECTS__
    function K(ue) {
        a(ue);
        const G = 2 ** 8;
        return {
            encode: (se)=>{
                if (!t(se)) throw new Error("radix.encode input should be Uint8Array");
                return k(Array.from(se), G, ue);
            },
            decode: (se)=>(l("radix.decode", se), Uint8Array.from(k(se, ue, G)))
        };
    }
    // @__NO_SIDE_EFFECTS__
    function $(ue, G = !1) {
        if (a(ue), ue <= 0 || ue > 32) throw new Error("radix2: bits should be in (0..32]");
        if (/* @__PURE__ */ M(8, ue) > 32 || /* @__PURE__ */ M(ue, 8) > 32) throw new Error("radix2: carry overflow");
        return {
            encode: (se)=>{
                if (!t(se)) throw new Error("radix2.encode input should be Uint8Array");
                return z(Array.from(se), 8, ue, !G);
            },
            decode: (se)=>(l("radix2.decode", se), Uint8Array.from(z(se, ue, 8, G)))
        };
    }
    function ne(ue) {
        return i1(ue), function(...G) {
            try {
                return ue.apply(null, G);
            } catch  {}
        };
    }
    function ee(ue, G) {
        return a(ue), i1(G), {
            encode (se) {
                if (!t(se)) throw new Error("checksum.encode: input should be Uint8Array");
                const Z = G(se).slice(0, ue), ie = new Uint8Array(se.length + ue);
                return ie.set(se), ie.set(Z, se.length), ie;
            },
            decode (se) {
                if (!t(se)) throw new Error("checksum.decode: input should be Uint8Array");
                const Z = se.slice(0, -ue), ie = se.slice(-ue), pe = G(Z).slice(0, ue);
                for(let ve = 0; ve < ue; ve++)if (pe[ve] !== ie[ve]) throw new Error("Invalid checksum");
                return Z;
            }
        };
    }
    e.utils = {
        alphabet: f,
        chain: u,
        checksum: ee,
        convertRadix: k,
        convertRadix2: z,
        radix: K,
        radix2: $,
        join: h,
        padding: y
    }, e.base16 = /* @__PURE__ */ u(/* @__PURE__ */ $(4), /* @__PURE__ */ f("0123456789ABCDEF"), /* @__PURE__ */ h("")), e.base32 = /* @__PURE__ */ u(/* @__PURE__ */ $(5), /* @__PURE__ */ f("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ y(5), /* @__PURE__ */ h("")), e.base32nopad = /* @__PURE__ */ u(/* @__PURE__ */ $(5), /* @__PURE__ */ f("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ h("")), e.base32hex = /* @__PURE__ */ u(/* @__PURE__ */ $(5), /* @__PURE__ */ f("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ y(5), /* @__PURE__ */ h("")), e.base32hexnopad = /* @__PURE__ */ u(/* @__PURE__ */ $(5), /* @__PURE__ */ f("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ h("")), e.base32crockford = /* @__PURE__ */ u(/* @__PURE__ */ $(5), /* @__PURE__ */ f("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ h(""), /* @__PURE__ */ S((ue)=>ue.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    const q = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function", U = (ue, G)=>{
        o("base64", ue);
        const se = G ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/, Z = G ? "base64url" : "base64";
        if (ue.length > 0 && !se.test(ue)) throw new Error("invalid base64");
        return Uint8Array.fromBase64(ue, {
            alphabet: Z,
            lastChunkHandling: "strict"
        });
    };
    e.base64 = q ? {
        encode (ue) {
            return r(ue), ue.toBase64();
        },
        decode (ue) {
            return U(ue, !1);
        }
    } : /* @__PURE__ */ u(/* @__PURE__ */ $(6), /* @__PURE__ */ f("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ y(6), /* @__PURE__ */ h("")), e.base64nopad = /* @__PURE__ */ u(/* @__PURE__ */ $(6), /* @__PURE__ */ f("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ h("")), e.base64url = q ? {
        encode (ue) {
            return r(ue), ue.toBase64({
                alphabet: "base64url"
            });
        },
        decode (ue) {
            return U(ue, !0);
        }
    } : /* @__PURE__ */ u(/* @__PURE__ */ $(6), /* @__PURE__ */ f("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ y(6), /* @__PURE__ */ h("")), e.base64urlnopad = /* @__PURE__ */ u(/* @__PURE__ */ $(6), /* @__PURE__ */ f("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ h(""));
    const Q = /* @__NO_SIDE_EFFECTS__ */ (ue)=>/* @__PURE__ */ u(/* @__PURE__ */ K(58), /* @__PURE__ */ f(ue), /* @__PURE__ */ h(""));
    e.base58 = /* @__PURE__ */ Q("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = /* @__PURE__ */ Q("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = /* @__PURE__ */ Q("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    const v = [
        0,
        2,
        3,
        5,
        6,
        7,
        9,
        10,
        11
    ];
    e.base58xmr = {
        encode (ue) {
            let G = "";
            for(let se = 0; se < ue.length; se += 8){
                const Z = ue.subarray(se, se + 8);
                G += e.base58.encode(Z).padStart(v[Z.length], "1");
            }
            return G;
        },
        decode (ue) {
            let G = [];
            for(let se = 0; se < ue.length; se += 11){
                const Z = ue.slice(se, se + 11), ie = v.indexOf(Z.length), pe = e.base58.decode(Z);
                for(let ve = 0; ve < pe.length - ie; ve++)if (pe[ve] !== 0) throw new Error("base58xmr: wrong padding");
                G = G.concat(Array.from(pe.slice(pe.length - ie)));
            }
            return Uint8Array.from(G);
        }
    };
    const B = (ue)=>/* @__PURE__ */ u(ee(4, (G)=>ue(ue(G))), e.base58);
    e.createBase58check = B, e.base58check = e.createBase58check;
    const g = /* @__PURE__ */ u(/* @__PURE__ */ f("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ h("")), E = [
        996825010,
        642813549,
        513874426,
        1027748829,
        705979059
    ];
    function w(ue) {
        const G = ue >> 25;
        let se = (ue & 33554431) << 5;
        for(let Z = 0; Z < E.length; Z++)(G >> Z & 1) === 1 && (se ^= E[Z]);
        return se;
    }
    function _(ue, G, se = 1) {
        const Z = ue.length;
        let ie = 1;
        for(let pe = 0; pe < Z; pe++){
            const ve = ue.charCodeAt(pe);
            if (ve < 33 || ve > 126) throw new Error(`Invalid prefix (${ue})`);
            ie = w(ie) ^ ve >> 5;
        }
        ie = w(ie);
        for(let pe = 0; pe < Z; pe++)ie = w(ie) ^ ue.charCodeAt(pe) & 31;
        for (let pe of G)ie = w(ie) ^ pe;
        for(let pe = 0; pe < 6; pe++)ie = w(ie);
        return ie ^= se, g.encode(z([
            ie % N[30]
        ], 30, 5, !1));
    }
    // @__NO_SIDE_EFFECTS__
    function O(ue) {
        const G = ue === "bech32" ? 1 : 734539939, se = /* @__PURE__ */ $(5), Z = se.decode, ie = se.encode, pe = ne(Z);
        function ve(J, me, je = 90) {
            o("bech32.encode prefix", J), t(me) && (me = Array.from(me)), l("bech32.encode", me);
            const Ve = J.length;
            if (Ve === 0) throw new TypeError(`Invalid prefix length ${Ve}`);
            const nt = Ve + 7 + me.length;
            if (je !== !1 && nt > je) throw new TypeError(`Length ${nt} exceeds limit ${je}`);
            const We = J.toLowerCase(), Ge = _(We, me, G);
            return `${We}1${g.encode(me)}${Ge}`;
        }
        function Ie(J, me = 90) {
            o("bech32.decode input", J);
            const je = J.length;
            if (je < 8 || me !== !1 && je > me) throw new TypeError(`invalid string length: ${je} (${J}). Expected (8..${me})`);
            const Ve = J.toLowerCase();
            if (J !== Ve && J !== J.toUpperCase()) throw new Error("String must be lowercase or uppercase");
            const nt = Ve.lastIndexOf("1");
            if (nt === 0 || nt === -1) throw new Error('Letter "1" must be present between prefix and data only');
            const We = Ve.slice(0, nt), Ge = Ve.slice(nt + 1);
            if (Ge.length < 6) throw new Error("Data must be at least 6 characters long");
            const p = g.decode(Ge).slice(0, -6), A = _(We, p, G);
            if (!Ge.endsWith(A)) throw new Error(`Invalid checksum in ${J}: expected "${A}"`);
            return {
                prefix: We,
                words: p
            };
        }
        const Me = ne(Ie);
        function Re(J) {
            const { prefix: me, words: je } = Ie(J, !1);
            return {
                prefix: me,
                words: je,
                bytes: Z(je)
            };
        }
        function C(J, me) {
            return ve(J, ie(me));
        }
        return {
            encode: ve,
            decode: Ie,
            encodeFromBytes: C,
            decodeToBytes: Re,
            decodeUnsafe: Me,
            fromWords: Z,
            fromWordsUnsafe: pe,
            toWords: ie
        };
    }
    e.bech32 = /* @__PURE__ */ O("bech32"), e.bech32m = /* @__PURE__ */ O("bech32m"), e.utf8 = {
        encode: (ue)=>new TextDecoder().decode(ue),
        decode: (ue)=>new TextEncoder().encode(ue)
    };
    const I = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", x = {
        encode (ue) {
            return r(ue), ue.toHex();
        },
        decode (ue) {
            return o("hex", ue), Uint8Array.fromHex(ue);
        }
    };
    e.hex = I ? x : /* @__PURE__ */ u(/* @__PURE__ */ $(4), /* @__PURE__ */ f("0123456789abcdef"), /* @__PURE__ */ h(""), /* @__PURE__ */ S((ue)=>{
        if (typeof ue != "string" || ue.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof ue} with length ${ue.length}`);
        return ue.toLowerCase();
    }));
    const R = {
        utf8: e.utf8,
        hex: e.hex,
        base16: e.base16,
        base32: e.base32,
        base64: e.base64,
        base64url: e.base64url,
        base58: e.base58,
        base58xmr: e.base58xmr
    }, j = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", Y = (ue, G)=>{
        if (typeof ue != "string" || !R.hasOwnProperty(ue)) throw new TypeError(j);
        if (!t(G)) throw new TypeError("bytesToString() expects Uint8Array");
        return R[ue].encode(G);
    };
    e.bytesToString = Y, e.str = e.bytesToString;
    const he = (ue, G)=>{
        if (!R.hasOwnProperty(ue)) throw new TypeError(j);
        if (typeof G != "string") throw new TypeError("stringToBytes() expects string");
        return R[ue].decode(G);
    };
    e.stringToBytes = he, e.bytes = e.stringToBytes;
})(Xh);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._TEST = e.ZeroPad = e.magicBytes = e.flag = e.cstring = e.string = e.hex = e.bytes = e.bool = e.F64LE = e.F64BE = e.F32LE = e.F32BE = e.I8 = e.U8 = e.I16BE = e.I16LE = e.U16BE = e.U16LE = e.I32BE = e.I32LE = e.U32BE = e.U32LE = e.int = e.I64BE = e.I64LE = e.U64BE = e.U64LE = e.I128BE = e.I128LE = e.U128BE = e.U128LE = e.I256BE = e.I256LE = e.U256BE = e.U256LE = e.bigint = e.bits = e.coders = e.wrap = e.utils = e.NULL = e.EMPTY = void 0, e.validate = P, e.isCoder = z, e.prefix = I, e.apply = j, e.lazy = Y, e.flagged = ue, e.optional = G, e.magic = se, e.constant = ie, e.struct = ve, e.tuple = Ie, e.array = Me, e.map = Re, e.tag = C, e.mappedTag = J, e.bitset = me, e.padLeft = nt, e.padRight = We, e.pointer = Ge;
    const t = Xh;
    e.EMPTY = new Uint8Array(), e.NULL = new Uint8Array([
        0
    ]);
    function r(p, A) {
        if (p.length !== A.length) return !1;
        for(let V = 0; V < p.length; V++)if (p[V] !== A[V]) return !1;
        return !0;
    }
    function n(p) {
        return p instanceof Uint8Array || ArrayBuffer.isView(p) && p.constructor.name === "Uint8Array";
    }
    function i1(...p) {
        let A = 0;
        for(let re = 0; re < p.length; re++){
            const le = p[re];
            if (!n(le)) throw new Error("Uint8Array expected");
            A += le.length;
        }
        const V = new Uint8Array(A);
        for(let re = 0, le = 0; re < p.length; re++){
            const L = p[re];
            V.set(L, le), le += L.length;
        }
        return V;
    }
    const o = (p)=>new DataView(p.buffer, p.byteOffset, p.byteLength);
    function a(p) {
        return Object.prototype.toString.call(p) === "[object Object]";
    }
    function s(p) {
        return Number.isSafeInteger(p);
    }
    e.utils = {
        equalBytes: r,
        isBytes: n,
        isCoder: z,
        checkBounds: S,
        concatBytes: i1,
        createView: o,
        isPlainObject: a
    };
    const c = (p)=>{
        if (p !== null && typeof p != "string" && !z(p) && !n(p) && !s(p)) throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${p} (${typeof p})`);
        return {
            encodeStream (A, V) {
                if (p === null) return;
                if (z(p)) return p.encodeStream(A, V);
                let re;
                if (typeof p == "number" ? re = p : typeof p == "string" && (re = u.resolve(A.stack, p)), typeof re == "bigint" && (re = Number(re)), re === void 0 || re !== V) throw A.err(`Wrong length: ${re} len=${p} exp=${V} (${typeof V})`);
            },
            decodeStream (A) {
                let V;
                if (z(p) ? V = Number(p.decodeStream(A)) : typeof p == "number" ? V = p : typeof p == "string" && (V = u.resolve(A.stack, p)), typeof V == "bigint" && (V = Number(V)), typeof V != "number") throw A.err(`Wrong length: ${V}`);
                return V;
            }
        };
    }, l = {
        BITS: 32,
        FULL_MASK: -1 >>> 0,
        // 1<<32 will overflow
        len: (p)=>Math.ceil(p / 32),
        create: (p)=>new Uint32Array(l.len(p)),
        clean: (p)=>p.fill(0),
        debug: (p)=>Array.from(p).map((A)=>(A >>> 0).toString(2).padStart(32, "0")),
        checkLen: (p, A)=>{
            if (l.len(A) !== p.length) throw new Error(`wrong length=${p.length}. Expected: ${l.len(A)}`);
        },
        chunkLen: (p, A, V)=>{
            if (A < 0) throw new Error(`wrong pos=${A}`);
            if (A + V > p) throw new Error(`wrong range=${A}/${V} of ${p}`);
        },
        set: (p, A, V, re = !0)=>!re && p[A] & V ? !1 : (p[A] |= V, !0),
        pos: (p, A)=>({
                chunk: Math.floor((p + A) / 32),
                mask: 1 << 32 - (p + A) % 32 - 1
            }),
        indices: (p, A, V = !1)=>{
            l.checkLen(p, A);
            const { FULL_MASK: re, BITS: le } = l, L = le - A % le, X = L ? re >>> L << L : re, ae = [];
            for(let D = 0; D < p.length; D++){
                let H = p[D];
                if (V && (H = ~H), D === p.length - 1 && (H &= X), H !== 0) for(let te = 0; te < le; te++){
                    const ge = 1 << le - te - 1;
                    H & ge && ae.push(D * le + te);
                }
            }
            return ae;
        },
        range: (p)=>{
            const A = [];
            let V;
            for (const re of p)V === void 0 || re !== V.pos + V.length ? A.push(V = {
                pos: re,
                length: 1
            }) : V.length += 1;
            return A;
        },
        rangeDebug: (p, A, V = !1)=>`[${l.range(l.indices(p, A, V)).map((re)=>`(${re.pos}/${re.length})`).join(", ")}]`,
        setRange: (p, A, V, re, le = !0)=>{
            l.chunkLen(A, V, re);
            const { FULL_MASK: L, BITS: X } = l, ae = V % X ? Math.floor(V / X) : void 0, D = V + re, H = D % X ? Math.floor(D / X) : void 0;
            if (ae !== void 0 && ae === H) return l.set(p, ae, L >>> X - re << X - re - V, le);
            if (ae !== void 0 && !l.set(p, ae, L >>> V % X, le)) return !1;
            const te = ae !== void 0 ? ae + 1 : V / X, ge = H !== void 0 ? H : D / X;
            for(let ce = te; ce < ge; ce++)if (!l.set(p, ce, L, le)) return !1;
            return !(H !== void 0 && ae !== H && !l.set(p, H, L << X - D % X, le));
        }
    }, u = {
        /**
     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)
     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).
     * Also, this makes impossible:
     * - pushing field when stack is empty
     * - pushing field inside of field (real bug)
     * NOTE: we don't want to do '.pop' on error!
     */ pushObj: (p, A, V)=>{
            const re = {
                obj: A
            };
            p.push(re), V((le, L)=>{
                re.field = le, L(), re.field = void 0;
            }), p.pop();
        },
        path: (p)=>{
            const A = [];
            for (const V of p)V.field !== void 0 && A.push(V.field);
            return A.join("/");
        },
        err: (p, A, V)=>{
            const re = new Error(`${p}(${u.path(A)}): ${typeof V == "string" ? V : V.message}`);
            return V instanceof Error && V.stack && (re.stack = V.stack), re;
        },
        resolve: (p, A)=>{
            const V = A.split("/"), re = p.map((X)=>X.obj);
            let le = 0;
            for(; le < V.length && V[le] === ".."; le++)re.pop();
            let L = re.pop();
            for(; le < V.length; le++){
                if (!L || L[V[le]] === void 0) return;
                L = L[V[le]];
            }
            return L;
        }
    };
    class f {
        constructor(A, V = {}, re = [], le = void 0, L = 0){
            this.pos = 0, this.bitBuf = 0, this.bitPos = 0, this.data = A, this.opts = V, this.stack = re, this.parent = le, this.parentOffset = L, this.view = o(A);
        }
        /** Internal method for pointers. */ _enablePointers() {
            if (this.parent) return this.parent._enablePointers();
            this.bs || (this.bs = l.create(this.data.length), l.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads));
        }
        markBytesBS(A, V) {
            return this.parent ? this.parent.markBytesBS(this.parentOffset + A, V) : !V || !this.bs ? !0 : l.setRange(this.bs, this.data.length, A, V, !1);
        }
        markBytes(A) {
            const V = this.pos;
            this.pos += A;
            const re = this.markBytesBS(V, A);
            if (!this.opts.allowMultipleReads && !re) throw this.err(`multiple read pos=${this.pos} len=${A}`);
            return re;
        }
        pushObj(A, V) {
            return u.pushObj(this.stack, A, V);
        }
        readView(A, V) {
            if (!Number.isFinite(A)) throw this.err(`readView: wrong length=${A}`);
            if (this.pos + A > this.data.length) throw this.err("readView: Unexpected end of buffer");
            const re = V(this.view, this.pos);
            return this.markBytes(A), re;
        }
        // read bytes by absolute offset
        absBytes(A) {
            if (A > this.data.length) throw new Error("Unexpected end of buffer");
            return this.data.subarray(A);
        }
        finish() {
            if (!this.opts.allowUnreadBytes) {
                if (this.bitPos) throw this.err(`${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
                if (this.bs && !this.parent) {
                    const A = l.indices(this.bs, this.data.length, !0);
                    if (A.length) {
                        const V = l.range(A).map(({ pos: re, length: le })=>`(${re}/${le})[${t.hex.encode(this.data.subarray(re, re + le))}]`).join(", ");
                        throw this.err(`unread byte ranges: ${V} (total=${this.data.length})`);
                    } else return;
                }
                if (!this.isEnd()) throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${t.hex.encode(this.data.slice(this.pos))}`);
            }
        }
        // User methods
        err(A) {
            return u.err("Reader", this.stack, A);
        }
        offsetReader(A) {
            if (A > this.data.length) throw this.err("offsetReader: Unexpected end of buffer");
            return new f(this.absBytes(A), this.opts, this.stack, this, A);
        }
        bytes(A, V = !1) {
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(A)) throw this.err(`readBytes: wrong length=${A}`);
            if (this.pos + A > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const re = this.data.subarray(this.pos, this.pos + A);
            return V || this.markBytes(A), re;
        }
        byte(A = !1) {
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            if (this.pos + 1 > this.data.length) throw this.err("readBytes: Unexpected end of buffer");
            const V = this.data[this.pos];
            return A || this.markBytes(1), V;
        }
        get leftBytes() {
            return this.data.length - this.pos;
        }
        get totalBytes() {
            return this.data.length;
        }
        isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
        }
        // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1
        bits(A) {
            if (A > 32) throw this.err("BitReader: cannot read more than 32 bits in single call");
            let V = 0;
            for(; A;){
                this.bitPos || (this.bitBuf = this.byte(), this.bitPos = 8);
                const re = Math.min(A, this.bitPos);
                this.bitPos -= re, V = V << re | this.bitBuf >> this.bitPos & 2 ** re - 1, this.bitBuf &= 2 ** this.bitPos - 1, A -= re;
            }
            return V >>> 0;
        }
        find(A, V = this.pos) {
            if (!n(A)) throw this.err(`find: needle is not bytes! ${A}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!A.length) throw this.err("find: needle is empty");
            for(let re = V; (re = this.data.indexOf(A[0], re)) !== -1; re++){
                if (re === -1 || this.data.length - re < A.length) return;
                if (r(A, this.data.subarray(re, re + A.length))) return re;
            }
        }
    }
    class h {
        constructor(A = []){
            this.pos = 0, this.buffers = [], this.ptrs = [], this.bitBuf = 0, this.bitPos = 0, this.viewBuf = new Uint8Array(8), this.finished = !1, this.stack = A, this.view = o(this.viewBuf);
        }
        pushObj(A, V) {
            return u.pushObj(this.stack, A, V);
        }
        writeView(A, V) {
            if (this.finished) throw this.err("buffer: finished");
            if (!s(A) || A > 8) throw new Error(`wrong writeView length=${A}`);
            V(this.view), this.bytes(this.viewBuf.slice(0, A)), this.viewBuf.fill(0);
        }
        // User methods
        err(A) {
            if (this.finished) throw this.err("buffer: finished");
            return u.err("Reader", this.stack, A);
        }
        bytes(A) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(A), this.pos += A.length;
        }
        byte(A) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([
                A
            ])), this.pos++;
        }
        finish(A = !0) {
            if (this.finished) throw this.err("buffer: finished");
            if (this.bitPos) throw this.err("buffer: ends with non-empty bit buffer");
            const V = this.buffers.concat(this.ptrs.map((L)=>L.buffer)), re = V.map((L)=>L.length).reduce((L, X)=>L + X, 0), le = new Uint8Array(re);
            for(let L = 0, X = 0; L < V.length; L++){
                const ae = V[L];
                le.set(ae, X), X += ae.length;
            }
            for(let L = this.pos, X = 0; X < this.ptrs.length; X++){
                const ae = this.ptrs[X];
                le.set(ae.ptr.encode(L), ae.pos), L += ae.buffer.length;
            }
            if (A) {
                this.buffers = [];
                for (const L of this.ptrs)L.buffer.fill(0);
                this.ptrs = [], this.finished = !0, this.bitBuf = 0;
            }
            return le;
        }
        bits(A, V) {
            if (V > 32) throw this.err("writeBits: cannot write more than 32 bits in single call");
            if (A >= 2 ** V) throw this.err(`writeBits: value (${A}) >= 2**bits (${V})`);
            for(; V;){
                const re = Math.min(V, 8 - this.bitPos);
                this.bitBuf = this.bitBuf << re | A >> V - re, this.bitPos += re, V -= re, A &= 2 ** V - 1, this.bitPos === 8 && (this.bitPos = 0, this.buffers.push(new Uint8Array([
                    this.bitBuf
                ])), this.pos++);
            }
        }
    }
    const y = (p)=>Uint8Array.from(p).reverse();
    function S(p, A, V) {
        if (V) {
            const re = 2n ** (A - 1n);
            if (p < -re || p >= re) throw new Error(`value out of signed bounds. Expected ${-re} <= ${p} < ${re}`);
        } else if (0n > p || p >= 2n ** A) throw new Error(`value out of unsigned bounds. Expected 0 <= ${p} < ${2n ** A}`);
    }
    function k(p) {
        return {
            // NOTE: we cannot export validate here, since it is likely mistake.
            encodeStream: p.encodeStream,
            decodeStream: p.decodeStream,
            size: p.size,
            encode: (A)=>{
                const V = new h();
                return p.encodeStream(V, A), V.finish();
            },
            decode: (A, V = {})=>{
                const re = new f(A, V), le = p.decodeStream(re);
                return re.finish(), le;
            }
        };
    }
    function P(p, A) {
        if (!z(p)) throw new Error(`validate: invalid inner value ${p}`);
        if (typeof A != "function") throw new Error("validate: fn should be function");
        return k({
            size: p.size,
            encodeStream: (V, re)=>{
                let le;
                try {
                    le = A(re);
                } catch (L) {
                    throw V.err(L);
                }
                p.encodeStream(V, le);
            },
            decodeStream: (V)=>{
                const re = p.decodeStream(V);
                try {
                    return A(re);
                } catch (le) {
                    throw V.err(le);
                }
            }
        });
    }
    const M = (p)=>{
        const A = k(p);
        return p.validate ? P(A, p.validate) : A;
    };
    e.wrap = M;
    const N = (p)=>a(p) && typeof p.decode == "function" && typeof p.encode == "function";
    function z(p) {
        return a(p) && N(p) && typeof p.encodeStream == "function" && typeof p.decodeStream == "function" && (p.size === void 0 || s(p.size));
    }
    function K() {
        return {
            encode: (p)=>{
                if (!Array.isArray(p)) throw new Error("array expected");
                const A = {};
                for (const V of p){
                    if (!Array.isArray(V) || V.length !== 2) throw new Error("array of two elements expected");
                    const re = V[0], le = V[1];
                    if (A[re] !== void 0) throw new Error(`key(${re}) appears twice in struct`);
                    A[re] = le;
                }
                return A;
            },
            decode: (p)=>{
                if (!a(p)) throw new Error(`expected plain object, got ${p}`);
                return Object.entries(p);
            }
        };
    }
    const $ = {
        encode: (p)=>{
            if (typeof p != "bigint") throw new Error(`expected bigint, got ${typeof p}`);
            if (p > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(`element bigger than MAX_SAFE_INTEGER=${p}`);
            return Number(p);
        },
        decode: (p)=>{
            if (!s(p)) throw new Error("element is not a safe integer");
            return BigInt(p);
        }
    };
    function ne(p) {
        if (!a(p)) throw new Error("plain object expected");
        return {
            encode: (A)=>{
                if (!s(A) || !(A in p)) throw new Error(`wrong value ${A}`);
                return p[A];
            },
            decode: (A)=>{
                if (typeof A != "string") throw new Error(`wrong value ${typeof A}`);
                return p[A];
            }
        };
    }
    function ee(p, A = !1) {
        if (!s(p)) throw new Error(`decimal/precision: wrong value ${p}`);
        if (typeof A != "boolean") throw new Error(`decimal/round: expected boolean, got ${typeof A}`);
        const V = 10n ** BigInt(p);
        return {
            encode: (re)=>{
                if (typeof re != "bigint") throw new Error(`expected bigint, got ${typeof re}`);
                let le = (re < 0n ? -re : re).toString(10), L = le.length - p;
                L < 0 && (le = le.padStart(le.length - L, "0"), L = 0);
                let X = le.length - 1;
                for(; X >= L && le[X] === "0"; X--);
                let ae = le.slice(0, L), D = le.slice(L, X + 1);
                return ae || (ae = "0"), re < 0n && (ae = "-" + ae), D ? `${ae}.${D}` : ae;
            },
            decode: (re)=>{
                if (typeof re != "string") throw new Error(`expected string, got ${typeof re}`);
                if (re === "-0") throw new Error("negative zero is not allowed");
                let le = !1;
                if (re.startsWith("-") && (le = !0, re = re.slice(1)), !/^(0|[1-9]\d*)(\.\d+)?$/.test(re)) throw new Error(`wrong string value=${re}`);
                let L = re.indexOf(".");
                L = L === -1 ? re.length : L;
                const X = re.slice(0, L), ae = re.slice(L + 1).replace(/0+$/, ""), D = BigInt(X) * V;
                if (!A && ae.length > p) throw new Error(`fractional part cannot be represented with this precision (num=${re}, prec=${p})`);
                const H = Math.min(ae.length, p), te = BigInt(ae.slice(0, H)) * 10n ** BigInt(p - H), ge = D + te;
                return le ? -ge : ge;
            }
        };
    }
    function q(p) {
        if (!Array.isArray(p)) throw new Error(`expected array, got ${typeof p}`);
        for (const A of p)if (!N(A)) throw new Error(`wrong base coder ${A}`);
        return {
            encode: (A)=>{
                for (const V of p){
                    const re = V.encode(A);
                    if (re !== void 0) return re;
                }
                throw new Error(`match/encode: cannot find match in ${A}`);
            },
            decode: (A)=>{
                for (const V of p){
                    const re = V.decode(A);
                    if (re !== void 0) return re;
                }
                throw new Error(`match/decode: cannot find match in ${A}`);
            }
        };
    }
    const U = (p)=>{
        if (!N(p)) throw new Error("BaseCoder expected");
        return {
            encode: p.decode,
            decode: p.encode
        };
    };
    e.coders = {
        dict: K,
        numberBigint: $,
        tsEnum: ne,
        decimal: ee,
        match: q,
        reverse: U
    };
    const Q = (p)=>{
        if (!s(p)) throw new Error(`bits: wrong length ${p} (${typeof p})`);
        return (0, e.wrap)({
            encodeStream: (A, V)=>A.bits(V, p),
            decodeStream: (A)=>A.bits(p),
            validate: (A)=>{
                if (!s(A)) throw new Error(`bits: wrong value ${A}`);
                return A;
            }
        });
    };
    e.bits = Q;
    const v = (p, A = !1, V = !1, re = !0)=>{
        if (!s(p)) throw new Error(`bigint/size: wrong value ${p}`);
        if (typeof A != "boolean") throw new Error(`bigint/le: expected boolean, got ${typeof A}`);
        if (typeof V != "boolean") throw new Error(`bigint/signed: expected boolean, got ${typeof V}`);
        if (typeof re != "boolean") throw new Error(`bigint/sized: expected boolean, got ${typeof re}`);
        const le = BigInt(p), L = 2n ** (8n * le - 1n);
        return (0, e.wrap)({
            size: re ? p : void 0,
            encodeStream: (X, ae)=>{
                V && ae < 0 && (ae = ae | L);
                const D = [];
                for(let te = 0; te < p; te++)D.push(Number(ae & 255n)), ae >>= 8n;
                let H = new Uint8Array(D).reverse();
                if (!re) {
                    let te = 0;
                    for(te = 0; te < H.length && H[te] === 0; te++);
                    H = H.subarray(te);
                }
                X.bytes(A ? H.reverse() : H);
            },
            decodeStream: (X)=>{
                const ae = X.bytes(re ? p : Math.min(p, X.leftBytes)), D = A ? ae : y(ae);
                let H = 0n;
                for(let te = 0; te < D.length; te++)H |= BigInt(D[te]) << 8n * BigInt(te);
                return V && H & L && (H = (H ^ L) - L), H;
            },
            validate: (X)=>{
                if (typeof X != "bigint") throw new Error(`bigint: invalid value: ${X}`);
                return S(X, 8n * le, !!V), X;
            }
        });
    };
    e.bigint = v, e.U256LE = (0, e.bigint)(32, !0), e.U256BE = (0, e.bigint)(32, !1), e.I256LE = (0, e.bigint)(32, !0, !0), e.I256BE = (0, e.bigint)(32, !1, !0), e.U128LE = (0, e.bigint)(16, !0), e.U128BE = (0, e.bigint)(16, !1), e.I128LE = (0, e.bigint)(16, !0, !0), e.I128BE = (0, e.bigint)(16, !1, !0), e.U64LE = (0, e.bigint)(8, !0), e.U64BE = (0, e.bigint)(8, !1), e.I64LE = (0, e.bigint)(8, !0, !0), e.I64BE = (0, e.bigint)(8, !1, !0);
    const B = (p, A = !1, V = !1, re = !0)=>{
        if (!s(p)) throw new Error(`int/size: wrong value ${p}`);
        if (typeof A != "boolean") throw new Error(`int/le: expected boolean, got ${typeof A}`);
        if (typeof V != "boolean") throw new Error(`int/signed: expected boolean, got ${typeof V}`);
        if (typeof re != "boolean") throw new Error(`int/sized: expected boolean, got ${typeof re}`);
        if (p > 6) throw new Error("int supports size up to 6 bytes (48 bits): use bigints instead");
        return j((0, e.bigint)(p, A, V, re), e.coders.numberBigint);
    };
    e.int = B;
    const g = (p, A)=>(0, e.wrap)({
            size: p,
            encodeStream: (V, re)=>V.writeView(p, (le)=>A.write(le, re)),
            decodeStream: (V)=>V.readView(p, A.read),
            validate: (V)=>{
                if (typeof V != "number") throw new Error(`viewCoder: expected number, got ${typeof V}`);
                return A.validate && A.validate(V), V;
            }
        }), E = (p, A, V)=>{
        const re = p * 8, le = 2 ** (re - 1), L = (D)=>{
            if (!s(D)) throw new Error(`sintView: value is not safe integer: ${D}`);
            if (D < -le || D >= le) throw new Error(`sintView: value out of bounds. Expected ${-le} <= ${D} < ${le}`);
        }, X = 2 ** re, ae = (D)=>{
            if (!s(D)) throw new Error(`uintView: value is not safe integer: ${D}`);
            if (0 > D || D >= X) throw new Error(`uintView: value out of bounds. Expected 0 <= ${D} < ${X}`);
        };
        return g(p, {
            write: V.write,
            read: V.read,
            validate: A ? L : ae
        });
    };
    e.U32LE = E(4, !1, {
        read: (p, A)=>p.getUint32(A, !0),
        write: (p, A)=>p.setUint32(0, A, !0)
    }), e.U32BE = E(4, !1, {
        read: (p, A)=>p.getUint32(A, !1),
        write: (p, A)=>p.setUint32(0, A, !1)
    }), e.I32LE = E(4, !0, {
        read: (p, A)=>p.getInt32(A, !0),
        write: (p, A)=>p.setInt32(0, A, !0)
    }), e.I32BE = E(4, !0, {
        read: (p, A)=>p.getInt32(A, !1),
        write: (p, A)=>p.setInt32(0, A, !1)
    }), e.U16LE = E(2, !1, {
        read: (p, A)=>p.getUint16(A, !0),
        write: (p, A)=>p.setUint16(0, A, !0)
    }), e.U16BE = E(2, !1, {
        read: (p, A)=>p.getUint16(A, !1),
        write: (p, A)=>p.setUint16(0, A, !1)
    }), e.I16LE = E(2, !0, {
        read: (p, A)=>p.getInt16(A, !0),
        write: (p, A)=>p.setInt16(0, A, !0)
    }), e.I16BE = E(2, !0, {
        read: (p, A)=>p.getInt16(A, !1),
        write: (p, A)=>p.setInt16(0, A, !1)
    }), e.U8 = E(1, !1, {
        read: (p, A)=>p.getUint8(A),
        write: (p, A)=>p.setUint8(0, A)
    }), e.I8 = E(1, !0, {
        read: (p, A)=>p.getInt8(A),
        write: (p, A)=>p.setInt8(0, A)
    });
    const w = (p)=>g(4, {
            read: (A, V)=>A.getFloat32(V, p),
            write: (A, V)=>A.setFloat32(0, V, p),
            validate: (A)=>{
                if (Math.fround(A) !== A && !Number.isNaN(A)) throw new Error(`f32: wrong value=${A}`);
            }
        }), _ = (p)=>g(8, {
            read: (A, V)=>A.getFloat64(V, p),
            write: (A, V)=>A.setFloat64(0, V, p)
        });
    e.F32BE = w(!1), e.F32LE = w(!0), e.F64BE = _(!1), e.F64LE = _(!0), e.bool = (0, e.wrap)({
        size: 1,
        encodeStream: (p, A)=>p.byte(A ? 1 : 0),
        decodeStream: (p)=>{
            const A = p.byte();
            if (A !== 0 && A !== 1) throw p.err(`bool: invalid value ${A}`);
            return A === 1;
        },
        validate: (p)=>{
            if (typeof p != "boolean") throw new Error(`bool: invalid value ${p}`);
            return p;
        }
    });
    const O = (p, A = !1)=>{
        if (typeof A != "boolean") throw new Error(`bytes/le: expected boolean, got ${typeof A}`);
        const V = c(p), re = n(p);
        return (0, e.wrap)({
            size: typeof p == "number" ? p : void 0,
            encodeStream: (le, L)=>{
                re || V.encodeStream(le, L.length), le.bytes(A ? y(L) : L), re && le.bytes(p);
            },
            decodeStream: (le)=>{
                let L;
                if (re) {
                    const X = le.find(p);
                    if (!X) throw le.err("bytes: cannot find terminator");
                    L = le.bytes(X - le.pos), le.bytes(p.length);
                } else L = le.bytes(p === null ? le.leftBytes : V.decodeStream(le));
                return A ? y(L) : L;
            },
            validate: (le)=>{
                if (!n(le)) throw new Error(`bytes: invalid value ${le}`);
                return le;
            }
        });
    };
    e.bytes = O;
    function I(p, A) {
        if (!z(A)) throw new Error(`prefix: invalid inner value ${A}`);
        return j(O(p), U(A));
    }
    const x = (p, A = !1)=>P(j(O(p, A), t.utf8), (V)=>{
            if (typeof V != "string") throw new Error(`expected string, got ${typeof V}`);
            return V;
        });
    e.string = x, e.cstring = (0, e.string)(e.NULL);
    const R = (p, A = {
        isLE: !1,
        with0x: !1
    })=>{
        let V = j(O(p, A.isLE), t.hex);
        const re = A.with0x;
        if (typeof re != "boolean") throw new Error(`hex/with0x: expected boolean, got ${typeof re}`);
        return re && (V = j(V, {
            encode: (le)=>`0x${le}`,
            decode: (le)=>{
                if (!le.startsWith("0x")) throw new Error("hex(with0x=true).encode input should start with 0x");
                return le.slice(2);
            }
        })), V;
    };
    e.hex = R;
    function j(p, A) {
        if (!z(p)) throw new Error(`apply: invalid inner value ${p}`);
        if (!N(A)) throw new Error(`apply: invalid base value ${p}`);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (V, re)=>{
                let le;
                try {
                    le = A.decode(re);
                } catch (L) {
                    throw V.err("" + L);
                }
                return p.encodeStream(V, le);
            },
            decodeStream: (V)=>{
                const re = p.decodeStream(V);
                try {
                    return A.encode(re);
                } catch (le) {
                    throw V.err("" + le);
                }
            }
        });
    }
    function Y(p) {
        if (typeof p != "function") throw new Error(`lazy: expected function, got ${typeof p}`);
        return (0, e.wrap)({
            encodeStream: (A, V)=>p().encodeStream(A, V),
            decodeStream: (A)=>p().decodeStream(A)
        });
    }
    const he = (p, A = !1)=>{
        if (!n(p)) throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof p}`);
        if (typeof A != "boolean") throw new Error(`flag/xor: expected boolean, got ${typeof A}`);
        return (0, e.wrap)({
            size: p.length,
            encodeStream: (V, re)=>{
                !!re !== A && V.bytes(p);
            },
            decodeStream: (V)=>{
                let re = V.leftBytes >= p.length;
                return re && (re = r(V.bytes(p.length, !0), p), re && V.bytes(p.length)), re !== A;
            },
            validate: (V)=>{
                if (V !== void 0 && typeof V != "boolean") throw new Error(`flag: expected boolean value or undefined, got ${typeof V}`);
                return V;
            }
        });
    };
    e.flag = he;
    function ue(p, A, V) {
        if (!z(A)) throw new Error(`flagged: invalid inner value ${A}`);
        if (typeof p != "string" && !z(A)) throw new Error(`flagged: wrong path=${p}`);
        return (0, e.wrap)({
            encodeStream: (re, le)=>{
                typeof p == "string" ? u.resolve(re.stack, p) ? A.encodeStream(re, le) : V && A.encodeStream(re, V) : (p.encodeStream(re, !!le), le ? A.encodeStream(re, le) : V && A.encodeStream(re, V));
            },
            decodeStream: (re)=>{
                let le = !1;
                if (typeof p == "string" ? le = !!u.resolve(re.stack, p) : le = p.decodeStream(re), le) return A.decodeStream(re);
                V && A.decodeStream(re);
            }
        });
    }
    function G(p, A, V) {
        if (!z(p) || !z(A)) throw new Error(`optional: invalid flag or inner value flag=${p} inner=${A}`);
        return (0, e.wrap)({
            size: V !== void 0 && p.size && A.size ? p.size + A.size : void 0,
            encodeStream: (re, le)=>{
                p.encodeStream(re, !!le), le ? A.encodeStream(re, le) : V !== void 0 && A.encodeStream(re, V);
            },
            decodeStream: (re)=>{
                if (p.decodeStream(re)) return A.decodeStream(re);
                V !== void 0 && A.decodeStream(re);
            }
        });
    }
    function se(p, A, V = !0) {
        if (!z(p)) throw new Error(`magic: invalid inner value ${p}`);
        if (typeof V != "boolean") throw new Error(`magic: expected boolean, got ${typeof V}`);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (re, le)=>p.encodeStream(re, A),
            decodeStream: (re)=>{
                const le = p.decodeStream(re);
                if (V && typeof le != "object" && le !== A || n(A) && !r(A, le)) throw re.err(`magic: invalid value: ${le} !== ${A}`);
            },
            validate: (re)=>{
                if (re !== void 0) throw new Error(`magic: wrong value=${typeof re}`);
                return re;
            }
        });
    }
    const Z = (p)=>{
        const A = typeof p == "string" ? t.utf8.decode(p) : p;
        return se(O(A.length), A);
    };
    e.magicBytes = Z;
    function ie(p) {
        return (0, e.wrap)({
            encodeStream: (A, V)=>{
                if (V !== p) throw new Error(`constant: invalid value ${V} (exp: ${p})`);
            },
            decodeStream: (A)=>p
        });
    }
    function pe(p) {
        let A = 0;
        for (const V of p){
            if (V.size === void 0) return;
            if (!s(V.size)) throw new Error(`sizeof: wrong element size=${A}`);
            A += V.size;
        }
        return A;
    }
    function ve(p) {
        if (!a(p)) throw new Error(`struct: expected plain object, got ${p}`);
        for(const A in p)if (!z(p[A])) throw new Error(`struct: field ${A} is not CoderType`);
        return (0, e.wrap)({
            size: pe(Object.values(p)),
            encodeStream: (A, V)=>{
                A.pushObj(V, (re)=>{
                    for(const le in p)re(le, ()=>p[le].encodeStream(A, V[le]));
                });
            },
            decodeStream: (A)=>{
                const V = {};
                return A.pushObj(V, (re)=>{
                    for(const le in p)re(le, ()=>V[le] = p[le].decodeStream(A));
                }), V;
            },
            validate: (A)=>{
                if (typeof A != "object" || A === null) throw new Error(`struct: invalid value ${A}`);
                return A;
            }
        });
    }
    function Ie(p) {
        if (!Array.isArray(p)) throw new Error(`Packed.Tuple: got ${typeof p} instead of array`);
        for(let A = 0; A < p.length; A++)if (!z(p[A])) throw new Error(`tuple: field ${A} is not CoderType`);
        return (0, e.wrap)({
            size: pe(p),
            encodeStream: (A, V)=>{
                if (!Array.isArray(V)) throw A.err(`tuple: invalid value ${V}`);
                A.pushObj(V, (re)=>{
                    for(let le = 0; le < p.length; le++)re(`${le}`, ()=>p[le].encodeStream(A, V[le]));
                });
            },
            decodeStream: (A)=>{
                const V = [];
                return A.pushObj(V, (re)=>{
                    for(let le = 0; le < p.length; le++)re(`${le}`, ()=>V.push(p[le].decodeStream(A)));
                }), V;
            },
            validate: (A)=>{
                if (!Array.isArray(A)) throw new Error(`tuple: invalid value ${A}`);
                if (A.length !== p.length) throw new Error(`tuple: wrong length=${A.length}, expected ${p.length}`);
                return A;
            }
        });
    }
    function Me(p, A) {
        if (!z(A)) throw new Error(`array: invalid inner value ${A}`);
        const V = c(typeof p == "string" ? `../${p}` : p);
        return (0, e.wrap)({
            size: typeof p == "number" && A.size ? p * A.size : void 0,
            encodeStream: (re, le)=>{
                const L = re;
                L.pushObj(le, (X)=>{
                    n(p) || V.encodeStream(re, le.length);
                    for(let ae = 0; ae < le.length; ae++)X(`${ae}`, ()=>{
                        const D = le[ae], H = re.pos;
                        if (A.encodeStream(re, D), n(p)) {
                            if (p.length > L.pos - H) return;
                            const te = L.finish(!1).subarray(H, L.pos);
                            if (r(te.subarray(0, p.length), p)) throw L.err(`array: inner element encoding same as separator. elm=${D} data=${te}`);
                        }
                    });
                }), n(p) && re.bytes(p);
            },
            decodeStream: (re)=>{
                const le = [];
                return re.pushObj(le, (L)=>{
                    if (p === null) for(let X = 0; !re.isEnd() && (L(`${X}`, ()=>le.push(A.decodeStream(re))), !(A.size && re.leftBytes < A.size)); X++);
                    else if (n(p)) for(let X = 0;; X++){
                        if (r(re.bytes(p.length, !0), p)) {
                            re.bytes(p.length);
                            break;
                        }
                        L(`${X}`, ()=>le.push(A.decodeStream(re)));
                    }
                    else {
                        let X;
                        L("arrayLen", ()=>X = V.decodeStream(re));
                        for(let ae = 0; ae < X; ae++)L(`${ae}`, ()=>le.push(A.decodeStream(re)));
                    }
                }), le;
            },
            validate: (re)=>{
                if (!Array.isArray(re)) throw new Error(`array: invalid value ${re}`);
                return re;
            }
        });
    }
    function Re(p, A) {
        if (!z(p)) throw new Error(`map: invalid inner value ${p}`);
        if (!a(A)) throw new Error("map: variants should be plain object");
        const V = /* @__PURE__ */ new Map();
        for(const re in A)V.set(A[re], re);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (re, le)=>p.encodeStream(re, A[le]),
            decodeStream: (re)=>{
                const le = p.decodeStream(re), L = V.get(le);
                if (L === void 0) throw re.err(`Enum: unknown value: ${le} ${Array.from(V.keys())}`);
                return L;
            },
            validate: (re)=>{
                if (typeof re != "string") throw new Error(`map: invalid value ${re}`);
                if (!(re in A)) throw new Error(`Map: unknown variant: ${re}`);
                return re;
            }
        });
    }
    function C(p, A) {
        if (!z(p)) throw new Error(`tag: invalid tag value ${p}`);
        if (!a(A)) throw new Error("tag: variants should be plain object");
        for(const V in A)if (!z(A[V])) throw new Error(`tag: variant ${V} is not CoderType`);
        return (0, e.wrap)({
            size: p.size,
            encodeStream: (V, re)=>{
                const { TAG: le, data: L } = re, X = A[le];
                p.encodeStream(V, le), X.encodeStream(V, L);
            },
            decodeStream: (V)=>{
                const re = p.decodeStream(V), le = A[re];
                if (!le) throw V.err(`Tag: invalid tag ${re}`);
                return {
                    TAG: re,
                    data: le.decodeStream(V)
                };
            },
            validate: (V)=>{
                const { TAG: re } = V;
                if (!A[re]) throw new Error(`Tag: invalid tag ${re.toString()}`);
                return V;
            }
        });
    }
    function J(p, A) {
        if (!z(p)) throw new Error(`mappedTag: invalid tag value ${C}`);
        if (!a(A)) throw new Error("mappedTag: variants should be plain object");
        const V = {}, re = {};
        for(const le in A){
            const L = A[le];
            V[le] = L[0], re[le] = L[1];
        }
        return C(Re(p, V), re);
    }
    function me(p, A = !1) {
        if (typeof A != "boolean") throw new Error(`bitset/pad: expected boolean, got ${typeof A}`);
        if (!Array.isArray(p)) throw new Error("bitset/names: expected array");
        for (const V of p)if (typeof V != "string") throw new Error("bitset/names: expected array of strings");
        return (0, e.wrap)({
            encodeStream: (V, re)=>{
                for(let le = 0; le < p.length; le++)V.bits(+re[p[le]], 1);
                A && p.length % 8 && V.bits(0, 8 - p.length % 8);
            },
            decodeStream: (V)=>{
                const re = {};
                for(let le = 0; le < p.length; le++)re[p[le]] = !!V.bits(1);
                return A && p.length % 8 && V.bits(8 - p.length % 8), re;
            },
            validate: (V)=>{
                if (!a(V)) throw new Error(`bitset: invalid value ${V}`);
                for (const re of Object.values(V))if (typeof re != "boolean") throw new Error("expected boolean");
                return V;
            }
        });
    }
    const je = (p)=>0;
    e.ZeroPad = je;
    function Ve(p, A) {
        return A % p === 0 ? 0 : p - A % p;
    }
    function nt(p, A, V) {
        if (!s(p) || p <= 0) throw new Error(`padLeft: wrong blockSize=${p}`);
        if (!z(A)) throw new Error(`padLeft: invalid inner value ${A}`);
        if (V !== void 0 && typeof V != "function") throw new Error(`padLeft: wrong padFn=${typeof V}`);
        const re = V || e.ZeroPad;
        if (!A.size) throw new Error("padLeft cannot have dynamic size");
        return (0, e.wrap)({
            size: A.size + Ve(p, A.size),
            encodeStream: (le, L)=>{
                const X = Ve(p, A.size);
                for(let ae = 0; ae < X; ae++)le.byte(re(ae));
                A.encodeStream(le, L);
            },
            decodeStream: (le)=>(le.bytes(Ve(p, A.size)), A.decodeStream(le))
        });
    }
    function We(p, A, V) {
        if (!z(A)) throw new Error(`padRight: invalid inner value ${A}`);
        if (!s(p) || p <= 0) throw new Error(`padLeft: wrong blockSize=${p}`);
        if (V !== void 0 && typeof V != "function") throw new Error(`padRight: wrong padFn=${typeof V}`);
        const re = V || e.ZeroPad;
        return (0, e.wrap)({
            size: A.size ? A.size + Ve(p, A.size) : void 0,
            encodeStream: (le, L)=>{
                const X = le, ae = X.pos;
                A.encodeStream(le, L);
                const D = Ve(p, X.pos - ae);
                for(let H = 0; H < D; H++)le.byte(re(H));
            },
            decodeStream: (le)=>{
                const L = le.pos, X = A.decodeStream(le);
                return le.bytes(Ve(p, le.pos - L)), X;
            }
        });
    }
    function Ge(p, A, V = !1) {
        if (!z(p)) throw new Error(`pointer: invalid ptr value ${p}`);
        if (!z(A)) throw new Error(`pointer: invalid inner value ${A}`);
        if (typeof V != "boolean") throw new Error(`pointer/sized: expected boolean, got ${typeof V}`);
        if (!p.size) throw new Error("unsized pointer");
        return (0, e.wrap)({
            size: V ? p.size : void 0,
            encodeStream: (re, le)=>{
                const L = re, X = L.pos;
                p.encodeStream(re, 0), L.ptrs.push({
                    pos: X,
                    ptr: p,
                    buffer: A.encode(le)
                });
            },
            decodeStream: (re)=>{
                const le = p.decodeStream(re);
                return re._enablePointers(), A.decodeStream(re.offsetReader(le));
            }
        });
    }
    e._TEST = {
        _bitset: l,
        _Reader: f,
        _Writer: h,
        Path: u
    };
})(Ff);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.TEST_NETWORK = e.NETWORK = e.TAPROOT_UNSPENDABLE_KEY = e.PubT = e.tagSchnorr = e.signSchnorr = e.pubECDSA = e.pubSchnorr = e.randomPrivateKeyBytes = e.sha256x2 = e.hash160 = e.sha256 = e.isBytes = e.equalBytes = e.concatBytes = void 0, e.signECDSA = y, e.validatePubkey = k, e.tapTweak = P, e.taprootTweakPrivKey = M, e.taprootTweakPubkey = N, e.compareBytes = z;
    const t = I6, r = vo, n = an;
    Object.defineProperty(e, "sha256", {
        enumerable: !0,
        get: function() {
            return n.sha256;
        }
    });
    const i1 = Ff, o = t.secp256k1.ProjectivePoint, a = t.secp256k1.CURVE.n, s = i1.utils.isBytes;
    e.isBytes = s;
    const c = i1.utils.concatBytes;
    e.concatBytes = c;
    const l = i1.utils.equalBytes;
    e.equalBytes = l;
    const u = (K)=>(0, r.ripemd160)((0, n.sha256)(K));
    e.hash160 = u;
    const f = (...K)=>(0, n.sha256)((0, n.sha256)(c(...K)));
    e.sha256x2 = f, e.randomPrivateKeyBytes = t.schnorr.utils.randomPrivateKey, e.pubSchnorr = t.schnorr.getPublicKey, e.pubECDSA = t.secp256k1.getPublicKey;
    const h = (K)=>K.r < a / 2n;
    function y(K, $, ne = !1) {
        let ee = t.secp256k1.sign(K, $);
        if (ne && !h(ee)) {
            const q = new Uint8Array(32);
            let U = 0;
            for(; !h(ee);)if (q.set(i1.U32LE.encode(U++)), ee = t.secp256k1.sign(K, $, {
                extraEntropy: q
            }), U > 4294967295) throw new Error("lowR counter overflow: report the error");
        }
        return ee.toDERRawBytes();
    }
    e.signSchnorr = t.schnorr.sign, e.tagSchnorr = t.schnorr.utils.taggedHash;
    var S;
    (function(K) {
        K[K.ecdsa = 0] = "ecdsa", K[K.schnorr = 1] = "schnorr";
    })(S || (e.PubT = S = {}));
    function k(K, $) {
        const ne = K.length;
        if ($ === S.ecdsa) {
            if (ne === 32) throw new Error("Expected non-Schnorr key");
            return o.fromHex(K), K;
        } else if ($ === S.schnorr) {
            if (ne !== 32) throw new Error("Expected 32-byte Schnorr key");
            return t.schnorr.utils.lift_x(t.schnorr.utils.bytesToNumberBE(K)), K;
        } else throw new Error("Unknown key type");
    }
    function P(K, $) {
        const ne = t.schnorr.utils, ee = ne.taggedHash("TapTweak", K, $), q = ne.bytesToNumberBE(ee);
        if (q >= a) throw new Error("tweak higher than curve order");
        return q;
    }
    function M(K, $ = Uint8Array.of()) {
        const ne = t.schnorr.utils, ee = ne.bytesToNumberBE(K), q = o.fromPrivateKey(ee), U = q.hasEvenY() ? ee : ne.mod(-ee, a), Q = ne.pointToBytes(q), v = P(Q, $);
        return ne.numberToBytesBE(ne.mod(U + v, a), 32);
    }
    function N(K, $) {
        const ne = t.schnorr.utils, ee = P(K, $), q = ne.lift_x(ne.bytesToNumberBE(K)).add(o.fromPrivateKey(ee)), U = q.hasEvenY() ? 0 : 1;
        return [
            ne.pointToBytes(q),
            U
        ];
    }
    e.TAPROOT_UNSPENDABLE_KEY = (0, n.sha256)(o.BASE.toRawBytes(!1)), e.NETWORK = {
        bech32: "bc",
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
    }, e.TEST_NETWORK = {
        bech32: "tb",
        pubKeyHash: 111,
        scriptHash: 196,
        wif: 239
    };
    function z(K, $) {
        if (!s(K) || !s($)) throw new Error(`cmp: wrong type a=${typeof K} b=${typeof $}`);
        const ne = Math.min(K.length, $.length);
        for(let ee = 0; ee < ne; ee++)if (K[ee] != $[ee]) return Math.sign(K[ee] - $[ee]);
        return Math.sign(K.length - $.length);
    }
})(Gs);
var _0 = {}, R1 = {}, Yh = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RawOldTx = e.RawTx = e.RawOutput = e.RawInput = e.BTCArray = e.RawWitness = e.VarBytes = e.CompactSizeLen = e.CompactSize = e.Script = e.OP = e.MAX_SCRIPT_BYTE_LENGTH = void 0, e.ScriptNum = i1, e.OpToNum = o;
    const t = Ff, r = Gs;
    e.MAX_SCRIPT_BYTE_LENGTH = 520;
    var n;
    (function(u) {
        u[u.OP_0 = 0] = "OP_0", u[u.PUSHDATA1 = 76] = "PUSHDATA1", u[u.PUSHDATA2 = 77] = "PUSHDATA2", u[u.PUSHDATA4 = 78] = "PUSHDATA4", u[u["1NEGATE"] = 79] = "1NEGATE", u[u.RESERVED = 80] = "RESERVED", u[u.OP_1 = 81] = "OP_1", u[u.OP_2 = 82] = "OP_2", u[u.OP_3 = 83] = "OP_3", u[u.OP_4 = 84] = "OP_4", u[u.OP_5 = 85] = "OP_5", u[u.OP_6 = 86] = "OP_6", u[u.OP_7 = 87] = "OP_7", u[u.OP_8 = 88] = "OP_8", u[u.OP_9 = 89] = "OP_9", u[u.OP_10 = 90] = "OP_10", u[u.OP_11 = 91] = "OP_11", u[u.OP_12 = 92] = "OP_12", u[u.OP_13 = 93] = "OP_13", u[u.OP_14 = 94] = "OP_14", u[u.OP_15 = 95] = "OP_15", u[u.OP_16 = 96] = "OP_16", u[u.NOP = 97] = "NOP", u[u.VER = 98] = "VER", u[u.IF = 99] = "IF", u[u.NOTIF = 100] = "NOTIF", u[u.VERIF = 101] = "VERIF", u[u.VERNOTIF = 102] = "VERNOTIF", u[u.ELSE = 103] = "ELSE", u[u.ENDIF = 104] = "ENDIF", u[u.VERIFY = 105] = "VERIFY", u[u.RETURN = 106] = "RETURN", u[u.TOALTSTACK = 107] = "TOALTSTACK", u[u.FROMALTSTACK = 108] = "FROMALTSTACK", u[u["2DROP"] = 109] = "2DROP", u[u["2DUP"] = 110] = "2DUP", u[u["3DUP"] = 111] = "3DUP", u[u["2OVER"] = 112] = "2OVER", u[u["2ROT"] = 113] = "2ROT", u[u["2SWAP"] = 114] = "2SWAP", u[u.IFDUP = 115] = "IFDUP", u[u.DEPTH = 116] = "DEPTH", u[u.DROP = 117] = "DROP", u[u.DUP = 118] = "DUP", u[u.NIP = 119] = "NIP", u[u.OVER = 120] = "OVER", u[u.PICK = 121] = "PICK", u[u.ROLL = 122] = "ROLL", u[u.ROT = 123] = "ROT", u[u.SWAP = 124] = "SWAP", u[u.TUCK = 125] = "TUCK", u[u.CAT = 126] = "CAT", u[u.SUBSTR = 127] = "SUBSTR", u[u.LEFT = 128] = "LEFT", u[u.RIGHT = 129] = "RIGHT", u[u.SIZE = 130] = "SIZE", u[u.INVERT = 131] = "INVERT", u[u.AND = 132] = "AND", u[u.OR = 133] = "OR", u[u.XOR = 134] = "XOR", u[u.EQUAL = 135] = "EQUAL", u[u.EQUALVERIFY = 136] = "EQUALVERIFY", u[u.RESERVED1 = 137] = "RESERVED1", u[u.RESERVED2 = 138] = "RESERVED2", u[u["1ADD"] = 139] = "1ADD", u[u["1SUB"] = 140] = "1SUB", u[u["2MUL"] = 141] = "2MUL", u[u["2DIV"] = 142] = "2DIV", u[u.NEGATE = 143] = "NEGATE", u[u.ABS = 144] = "ABS", u[u.NOT = 145] = "NOT", u[u["0NOTEQUAL"] = 146] = "0NOTEQUAL", u[u.ADD = 147] = "ADD", u[u.SUB = 148] = "SUB", u[u.MUL = 149] = "MUL", u[u.DIV = 150] = "DIV", u[u.MOD = 151] = "MOD", u[u.LSHIFT = 152] = "LSHIFT", u[u.RSHIFT = 153] = "RSHIFT", u[u.BOOLAND = 154] = "BOOLAND", u[u.BOOLOR = 155] = "BOOLOR", u[u.NUMEQUAL = 156] = "NUMEQUAL", u[u.NUMEQUALVERIFY = 157] = "NUMEQUALVERIFY", u[u.NUMNOTEQUAL = 158] = "NUMNOTEQUAL", u[u.LESSTHAN = 159] = "LESSTHAN", u[u.GREATERTHAN = 160] = "GREATERTHAN", u[u.LESSTHANOREQUAL = 161] = "LESSTHANOREQUAL", u[u.GREATERTHANOREQUAL = 162] = "GREATERTHANOREQUAL", u[u.MIN = 163] = "MIN", u[u.MAX = 164] = "MAX", u[u.WITHIN = 165] = "WITHIN", u[u.RIPEMD160 = 166] = "RIPEMD160", u[u.SHA1 = 167] = "SHA1", u[u.SHA256 = 168] = "SHA256", u[u.HASH160 = 169] = "HASH160", u[u.HASH256 = 170] = "HASH256", u[u.CODESEPARATOR = 171] = "CODESEPARATOR", u[u.CHECKSIG = 172] = "CHECKSIG", u[u.CHECKSIGVERIFY = 173] = "CHECKSIGVERIFY", u[u.CHECKMULTISIG = 174] = "CHECKMULTISIG", u[u.CHECKMULTISIGVERIFY = 175] = "CHECKMULTISIGVERIFY", u[u.NOP1 = 176] = "NOP1", u[u.CHECKLOCKTIMEVERIFY = 177] = "CHECKLOCKTIMEVERIFY", u[u.CHECKSEQUENCEVERIFY = 178] = "CHECKSEQUENCEVERIFY", u[u.NOP4 = 179] = "NOP4", u[u.NOP5 = 180] = "NOP5", u[u.NOP6 = 181] = "NOP6", u[u.NOP7 = 182] = "NOP7", u[u.NOP8 = 183] = "NOP8", u[u.NOP9 = 184] = "NOP9", u[u.NOP10 = 185] = "NOP10", u[u.CHECKSIGADD = 186] = "CHECKSIGADD", u[u.INVALID = 255] = "INVALID";
    })(n || (e.OP = n = {}));
    function i1(u = 6, f = !1) {
        return t.wrap({
            encodeStream: (h, y)=>{
                if (y === 0n) return;
                const S = y < 0, k = BigInt(y), P = [];
                for(let M = S ? -k : k; M; M >>= 8n)P.push(Number(M & 0xffn));
                P[P.length - 1] >= 128 ? P.push(S ? 128 : 0) : S && (P[P.length - 1] |= 128), h.bytes(new Uint8Array(P));
            },
            decodeStream: (h)=>{
                const y = h.leftBytes;
                if (y > u) throw new Error(`ScriptNum: number (${y}) bigger than limit=${u}`);
                if (y === 0) return 0n;
                if (f) {
                    const P = h.bytes(y, !0);
                    if (!(P[P.length - 1] & 127) && (y <= 1 || !(P[P.length - 2] & 128))) throw new Error("Non-minimally encoded ScriptNum");
                }
                let S = 0, k = 0n;
                for(let P = 0; P < y; ++P)S = h.byte(), k |= BigInt(S) << 8n * BigInt(P);
                return S >= 128 && (k &= 2n ** BigInt(y * 8) - 1n >> 1n, k = -k), k;
            }
        });
    }
    function o(u, f = 4, h = !0) {
        if (typeof u == "number") return u;
        if ((0, r.isBytes)(u)) try {
            const y = i1(f, h).decode(u);
            return y > Number.MAX_SAFE_INTEGER ? void 0 : Number(y);
        } catch  {
            return;
        }
    }
    e.Script = t.wrap({
        encodeStream: (u, f)=>{
            for (let h of f){
                if (typeof h == "string") {
                    if (n[h] === void 0) throw new Error(`Unknown opcode=${h}`);
                    u.byte(n[h]);
                    continue;
                } else if (typeof h == "number") {
                    if (h === 0) {
                        u.byte(0);
                        continue;
                    } else if (1 <= h && h <= 16) {
                        u.byte(n.OP_1 - 1 + h);
                        continue;
                    }
                }
                if (typeof h == "number" && (h = i1().encode(BigInt(h))), !(0, r.isBytes)(h)) throw new Error(`Wrong Script OP=${h} (${typeof h})`);
                const y = h.length;
                y < n.PUSHDATA1 ? u.byte(y) : y <= 255 ? (u.byte(n.PUSHDATA1), u.byte(y)) : y <= 65535 ? (u.byte(n.PUSHDATA2), u.bytes(t.U16LE.encode(y))) : (u.byte(n.PUSHDATA4), u.bytes(t.U32LE.encode(y))), u.bytes(h);
            }
        },
        decodeStream: (u)=>{
            const f = [];
            for(; !u.isEnd();){
                const h = u.byte();
                if (n.OP_0 < h && h <= n.PUSHDATA4) {
                    let y;
                    if (h < n.PUSHDATA1) y = h;
                    else if (h === n.PUSHDATA1) y = t.U8.decodeStream(u);
                    else if (h === n.PUSHDATA2) y = t.U16LE.decodeStream(u);
                    else if (h === n.PUSHDATA4) y = t.U32LE.decodeStream(u);
                    else throw new Error("Should be not possible");
                    f.push(u.bytes(y));
                } else if (h === 0) f.push(0);
                else if (n.OP_1 <= h && h <= n.OP_16) f.push(h - (n.OP_1 - 1));
                else {
                    const y = n[h];
                    if (y === void 0) throw new Error(`Unknown opcode=${h.toString(16)}`);
                    f.push(y);
                }
            }
            return f;
        }
    });
    const a = {
        253: [
            253,
            2,
            253n,
            65535n
        ],
        254: [
            254,
            4,
            65536n,
            4294967295n
        ],
        255: [
            255,
            8,
            4294967296n,
            18446744073709551615n
        ]
    };
    e.CompactSize = t.wrap({
        encodeStream: (u, f)=>{
            if (typeof f == "number" && (f = BigInt(f)), 0n <= f && f <= 252n) return u.byte(Number(f));
            for (const [h, y, S, k] of Object.values(a))if (!(S > f || f > k)) {
                u.byte(h);
                for(let P = 0; P < y; P++)u.byte(Number(f >> 8n * BigInt(P) & 0xffn));
                return;
            }
            throw u.err(`VarInt too big: ${f}`);
        },
        decodeStream: (u)=>{
            const f = u.byte();
            if (f <= 252) return BigInt(f);
            const [h, y, S] = a[f];
            let k = 0n;
            for(let P = 0; P < y; P++)k |= BigInt(u.byte()) << 8n * BigInt(P);
            if (k < S) throw u.err(`Wrong CompactSize(${8 * y})`);
            return k;
        }
    }), e.CompactSizeLen = t.apply(e.CompactSize, t.coders.numberBigint), e.VarBytes = t.bytes(e.CompactSize), e.RawWitness = t.array(e.CompactSizeLen, e.VarBytes);
    const s = (u)=>t.array(e.CompactSize, u);
    e.BTCArray = s, e.RawInput = t.struct({
        txid: t.bytes(32, !0),
        // hash(prev_tx),
        index: t.U32LE,
        // output number of previous tx
        finalScriptSig: e.VarBytes,
        // btc merges input and output script, executes it. If ok = tx passes
        sequence: t.U32LE
    }), e.RawOutput = t.struct({
        amount: t.U64LE,
        script: e.VarBytes
    });
    const c = t.struct({
        version: t.I32LE,
        segwitFlag: t.flag(new Uint8Array([
            0,
            1
        ])),
        inputs: (0, e.BTCArray)(e.RawInput),
        outputs: (0, e.BTCArray)(e.RawOutput),
        witnesses: t.flagged("segwitFlag", t.array("inputs/length", e.RawWitness)),
        // < 500000000	Block number at which this transaction is unlocked
        // >= 500000000	UNIX timestamp at which this transaction is unlocked
        // Handled as part of PSBTv2
        lockTime: t.U32LE
    });
    function l(u) {
        if (u.segwitFlag && u.witnesses && !u.witnesses.length) throw new Error("Segwit flag with empty witnesses array");
        return u;
    }
    e.RawTx = t.validate(c, l), e.RawOldTx = t.struct({
        version: t.I32LE,
        inputs: (0, e.BTCArray)(e.RawInput),
        outputs: (0, e.BTCArray)(e.RawOutput),
        lockTime: t.U32LE
    });
})(Yh);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RawPSBTV2 = e.RawPSBTV0 = e._DebugPSBT = e._RawPSBTV2 = e._RawPSBTV0 = e.PSBTOutputCoder = e.PSBTInputCoder = e.PSBTOutputUnsignedKeys = e.PSBTOutput = e.PSBTInputUnsignedKeys = e.PSBTInputFinalKeys = e.PSBTInput = e.PSBTGlobal = e.TaprootControlBlock = void 0, e.cleanPSBTFields = ne, e.mergeKeyMap = q;
    const t = Xh, r = Ff, n = Yh, i1 = Gs, o = r.validate(r.bytes(null), (U)=>(0, i1.validatePubkey)(U, i1.PubT.ecdsa)), a = r.validate(r.bytes(32), (U)=>(0, i1.validatePubkey)(U, i1.PubT.schnorr)), s = r.validate(r.bytes(null), (U)=>{
        if (U.length !== 64 && U.length !== 65) throw new Error("Schnorr signature should be 64 or 65 bytes long");
        return U;
    }), c = r.struct({
        fingerprint: r.U32BE,
        path: r.array(null, r.U32LE)
    }), l = r.struct({
        hashes: r.array(n.CompactSizeLen, r.bytes(32)),
        der: c
    }), u = r.bytes(78), f = r.struct({
        pubKey: a,
        leafHash: r.bytes(32)
    }), h = r.struct({
        version: r.U8,
        // With parity :(
        internalKey: r.bytes(32),
        merklePath: r.array(null, r.bytes(32))
    });
    e.TaprootControlBlock = r.validate(h, (U)=>{
        if (U.merklePath.length > 128) throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");
        return U;
    });
    const y = r.array(null, r.struct({
        depth: r.U8,
        version: r.U8,
        script: n.VarBytes
    })), S = r.bytes(null), k = r.bytes(20), P = r.bytes(32);
    e.PSBTGlobal = {
        unsignedTx: [
            0,
            !1,
            n.RawOldTx,
            [
                0
            ],
            [
                0
            ],
            !1
        ],
        xpub: [
            1,
            u,
            c,
            [],
            [
                0,
                2
            ],
            !1
        ],
        txVersion: [
            2,
            !1,
            r.U32LE,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        fallbackLocktime: [
            3,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        inputCount: [
            4,
            !1,
            n.CompactSizeLen,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        outputCount: [
            5,
            !1,
            n.CompactSizeLen,
            [
                2
            ],
            [
                2
            ],
            !1
        ],
        txModifiable: [
            6,
            !1,
            r.U8,
            [],
            [
                2
            ],
            !1
        ],
        // TODO: bitfield
        version: [
            251,
            !1,
            r.U32LE,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            S,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTInput = {
        nonWitnessUtxo: [
            0,
            !1,
            n.RawTx,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessUtxo: [
            1,
            !1,
            n.RawOutput,
            [],
            [
                0,
                2
            ],
            !1
        ],
        partialSig: [
            2,
            o,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        sighashType: [
            3,
            !1,
            r.U32LE,
            [],
            [
                0,
                2
            ],
            !1
        ],
        redeemScript: [
            4,
            !1,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessScript: [
            5,
            !1,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        bip32Derivation: [
            6,
            o,
            c,
            [],
            [
                0,
                2
            ],
            !1
        ],
        finalScriptSig: [
            7,
            !1,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        finalScriptWitness: [
            8,
            !1,
            n.RawWitness,
            [],
            [
                0,
                2
            ],
            !1
        ],
        porCommitment: [
            9,
            !1,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        ripemd160: [
            10,
            k,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        sha256: [
            11,
            P,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        hash160: [
            12,
            k,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        hash256: [
            13,
            P,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        txid: [
            14,
            !1,
            P,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        index: [
            15,
            !1,
            r.U32LE,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        sequence: [
            16,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !0
        ],
        requiredTimeLocktime: [
            17,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        requiredHeightLocktime: [
            18,
            !1,
            r.U32LE,
            [],
            [
                2
            ],
            !1
        ],
        tapKeySig: [
            19,
            !1,
            s,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapScriptSig: [
            20,
            f,
            s,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapLeafScript: [
            21,
            e.TaprootControlBlock,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapBip32Derivation: [
            22,
            P,
            l,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapInternalKey: [
            23,
            !1,
            a,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapMerkleRoot: [
            24,
            !1,
            P,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            S,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTInputFinalKeys = [
        "txid",
        "sequence",
        "index",
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknown"
    ], e.PSBTInputUnsignedKeys = [
        "partialSig",
        "finalScriptSig",
        "finalScriptWitness",
        "tapKeySig",
        "tapScriptSig"
    ], e.PSBTOutput = {
        redeemScript: [
            0,
            !1,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        witnessScript: [
            1,
            !1,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ],
        bip32Derivation: [
            2,
            o,
            c,
            [],
            [
                0,
                2
            ],
            !1
        ],
        amount: [
            3,
            !1,
            r.I64LE,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        script: [
            4,
            !1,
            S,
            [
                2
            ],
            [
                2
            ],
            !0
        ],
        tapInternalKey: [
            5,
            !1,
            a,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapTree: [
            6,
            !1,
            y,
            [],
            [
                0,
                2
            ],
            !1
        ],
        tapBip32Derivation: [
            7,
            a,
            l,
            [],
            [
                0,
                2
            ],
            !1
        ],
        proprietary: [
            252,
            S,
            S,
            [],
            [
                0,
                2
            ],
            !1
        ]
    }, e.PSBTOutputUnsignedKeys = [];
    const M = r.array(r.NULL, r.struct({
        //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)
        key: r.prefix(n.CompactSizeLen, r.struct({
            type: n.CompactSizeLen,
            key: r.bytes(null)
        })),
        //  <value> := <valuelen> <valuedata>
        value: r.bytes(n.CompactSizeLen)
    }));
    function N(U) {
        const [Q, v, B, g, E, w] = U;
        return {
            type: Q,
            kc: v,
            vc: B,
            reqInc: g,
            allowInc: E,
            silentIgnore: w
        };
    }
    r.struct({
        type: n.CompactSizeLen,
        key: r.bytes(null)
    });
    function z(U) {
        const Q = {};
        for(const v in U){
            const [B, g, E] = U[v];
            Q[B] = [
                v,
                g,
                E
            ];
        }
        return r.wrap({
            encodeStream: (v, B)=>{
                let g = [];
                for(const E in U){
                    const w = B[E];
                    if (w === void 0) continue;
                    const [_, O, I] = U[E];
                    if (!O) g.push({
                        key: {
                            type: _,
                            key: r.EMPTY
                        },
                        value: I.encode(w)
                    });
                    else {
                        const x = w.map(([R, j])=>[
                                O.encode(R),
                                I.encode(j)
                            ]);
                        x.sort((R, j)=>(0, i1.compareBytes)(R[0], j[0]));
                        for (const [R, j] of x)g.push({
                            key: {
                                key: R,
                                type: _
                            },
                            value: j
                        });
                    }
                }
                if (B.unknown) {
                    B.unknown.sort((E, w)=>(0, i1.compareBytes)(E[0].key, w[0].key));
                    for (const [E, w] of B.unknown)g.push({
                        key: E,
                        value: w
                    });
                }
                M.encodeStream(v, g);
            },
            decodeStream: (v)=>{
                const B = M.decodeStream(v), g = {}, E = {};
                for (const w of B){
                    let _ = "unknown", O = w.key.key, I = w.value;
                    if (Q[w.key.type]) {
                        const [x, R, j] = Q[w.key.type];
                        if (_ = x, !R && O.length) throw new Error(`PSBT: Non-empty key for ${_} (key=${t.hex.encode(O)} value=${t.hex.encode(I)}`);
                        if (O = R ? R.decode(O) : void 0, I = j.decode(I), !R) {
                            if (g[_]) throw new Error(`PSBT: Same keys: ${_} (key=${O} value=${I})`);
                            g[_] = I, E[_] = !0;
                            continue;
                        }
                    } else O = {
                        type: w.key.type,
                        key: w.key.key
                    };
                    if (E[_]) throw new Error(`PSBT: Key type with empty key and no key=${_} val=${I}`);
                    g[_] || (g[_] = []), g[_].push([
                        O,
                        I
                    ]);
                }
                return g;
            }
        });
    }
    e.PSBTInputCoder = r.validate(z(e.PSBTInput), (U)=>{
        if (U.finalScriptWitness && !U.finalScriptWitness.length) throw new Error("validateInput: empty finalScriptWitness");
        if (U.partialSig && !U.partialSig.length) throw new Error("Empty partialSig");
        if (U.partialSig) for (const [Q] of U.partialSig)(0, i1.validatePubkey)(Q, i1.PubT.ecdsa);
        if (U.bip32Derivation) for (const [Q] of U.bip32Derivation)(0, i1.validatePubkey)(Q, i1.PubT.ecdsa);
        if (U.requiredTimeLocktime !== void 0 && U.requiredTimeLocktime < 5e8) throw new Error(`validateInput: wrong timeLocktime=${U.requiredTimeLocktime}`);
        if (U.requiredHeightLocktime !== void 0 && (U.requiredHeightLocktime <= 0 || U.requiredHeightLocktime >= 5e8)) throw new Error(`validateInput: wrong heighLocktime=${U.requiredHeightLocktime}`);
        if (U.tapLeafScript) for (const [Q, v] of U.tapLeafScript){
            if ((Q.version & 254) !== v[v.length - 1]) throw new Error("validateInput: tapLeafScript version mimatch");
            if (v[v.length - 1] & 1) throw new Error("validateInput: tapLeafScript version has parity bit!");
        }
        return U;
    }), e.PSBTOutputCoder = r.validate(z(e.PSBTOutput), (U)=>{
        if (U.bip32Derivation) for (const [Q] of U.bip32Derivation)(0, i1.validatePubkey)(Q, i1.PubT.ecdsa);
        return U;
    });
    const K = r.validate(z(e.PSBTGlobal), (U)=>{
        if ((U.version || 0) === 0) {
            if (!U.unsignedTx) throw new Error("PSBTv0: missing unsignedTx");
            for (const Q of U.unsignedTx.inputs)if (Q.finalScriptSig && Q.finalScriptSig.length) throw new Error("PSBTv0: input scriptSig found in unsignedTx");
        }
        return U;
    });
    e._RawPSBTV0 = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        global: K,
        inputs: r.array("global/unsignedTx/inputs/length", e.PSBTInputCoder),
        outputs: r.array(null, e.PSBTOutputCoder)
    }), e._RawPSBTV2 = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        global: K,
        inputs: r.array("global/inputCount", e.PSBTInputCoder),
        outputs: r.array("global/outputCount", e.PSBTOutputCoder)
    }), e._DebugPSBT = r.struct({
        magic: r.magic(r.string(new Uint8Array([
            255
        ])), "psbt"),
        items: r.array(null, r.apply(r.array(r.NULL, r.tuple([
            r.hex(n.CompactSizeLen),
            r.bytes(n.CompactSize)
        ])), r.coders.dict()))
    });
    function $(U, Q, v) {
        for(const B in v){
            if (B === "unknown" || !Q[B]) continue;
            const { allowInc: g } = N(Q[B]);
            if (!g.includes(U)) throw new Error(`PSBTv${U}: field ${B} is not allowed`);
        }
        for(const B in Q){
            const { reqInc: g } = N(Q[B]);
            if (g.includes(U) && v[B] === void 0) throw new Error(`PSBTv${U}: missing required field ${B}`);
        }
    }
    function ne(U, Q, v) {
        const B = {};
        for(const g in v){
            const E = g;
            if (E !== "unknown") {
                if (!Q[E]) continue;
                const { allowInc: w, silentIgnore: _ } = N(Q[E]);
                if (!w.includes(U)) {
                    if (_) continue;
                    throw new Error(`Failed to serialize in PSBTv${U}: ${E} but versions allows inclusion=${w}`);
                }
            }
            B[E] = v[E];
        }
        return B;
    }
    function ee(U) {
        const Q = U && U.global && U.global.version || 0;
        $(Q, e.PSBTGlobal, U.global);
        for (const w of U.inputs)$(Q, e.PSBTInput, w);
        for (const w of U.outputs)$(Q, e.PSBTOutput, w);
        const v = Q ? U.global.inputCount : U.global.unsignedTx.inputs.length;
        if (U.inputs.length < v) throw new Error("Not enough inputs");
        const B = U.inputs.slice(v);
        if (B.length > 1 || B.length && Object.keys(B[0]).length) throw new Error(`Unexpected inputs left in tx=${B}`);
        const g = Q ? U.global.outputCount : U.global.unsignedTx.outputs.length;
        if (U.outputs.length < g) throw new Error("Not outputs inputs");
        const E = U.outputs.slice(g);
        if (E.length > 1 || E.length && Object.keys(E[0]).length) throw new Error(`Unexpected outputs left in tx=${E}`);
        return U;
    }
    function q(U, Q, v, B, g) {
        const E = {
            ...v,
            ...Q
        };
        for(const w in U){
            const _ = w, [O, I, x] = U[_], R = B && !B.includes(w);
            if (Q[w] === void 0 && w in Q) {
                if (R) throw new Error(`Cannot remove signed field=${w}`);
                delete E[w];
            } else if (I) {
                const j = v && v[w] ? v[w] : [];
                let Y = Q[_];
                if (Y) {
                    if (!Array.isArray(Y)) throw new Error(`keyMap(${w}): KV pairs should be [k, v][]`);
                    Y = Y.map((G)=>{
                        if (G.length !== 2) throw new Error(`keyMap(${w}): KV pairs should be [k, v][]`);
                        return [
                            typeof G[0] == "string" ? I.decode(t.hex.decode(G[0])) : G[0],
                            typeof G[1] == "string" ? x.decode(t.hex.decode(G[1])) : G[1]
                        ];
                    });
                    const he = {}, ue = (G, se, Z)=>{
                        if (he[G] === void 0) {
                            he[G] = [
                                se,
                                Z
                            ];
                            return;
                        }
                        const ie = t.hex.encode(x.encode(he[G][1])), pe = t.hex.encode(x.encode(Z));
                        if (ie !== pe) throw new Error(`keyMap(${_}): same key=${G} oldVal=${ie} newVal=${pe}`);
                    };
                    for (const [G, se] of j){
                        const Z = t.hex.encode(I.encode(G));
                        ue(Z, G, se);
                    }
                    for (const [G, se] of Y){
                        const Z = t.hex.encode(I.encode(G));
                        if (se === void 0) {
                            if (R) throw new Error(`Cannot remove signed field=${_}/${G}`);
                            delete he[Z];
                        } else ue(Z, G, se);
                    }
                    E[_] = Object.values(he);
                }
            } else if (typeof E[w] == "string") E[w] = x.decode(t.hex.decode(E[w]));
            else if (R && w in Q && v && v[w] !== void 0 && !(0, i1.equalBytes)(x.encode(Q[w]), x.encode(v[w]))) throw new Error(`Cannot change signed field=${w}`);
        }
        for(const w in E)if (!U[w]) {
            if (g && w === "unknown") continue;
            delete E[w];
        }
        return E;
    }
    e.RawPSBTV0 = r.validate(e._RawPSBTV0, ee), e.RawPSBTV2 = r.validate(e._RawPSBTV2, ee);
})(R1);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._sortPubkeys = e.p2tr_pk = e.p2tr_ns = e.tapLeafHash = e.TAP_LEAF_VERSION = e.p2ms = e.p2wpkh = e.p2wsh = e.p2sh = e.p2pkh = e.p2pk = e.OutScript = void 0, e.checkScript = h, e.taprootListToTree = $, e.p2tr = Q, e.combinations = v, e.p2tr_ms = E, e.getAddress = w, e.multisig = O, e.sortedMultisig = I, e.WIF = he, e.Address = ue;
    const t = Xh, r = Ff, n = R1, i1 = Yh, o = Gs, a = Gs, s = {
        encode (G) {
            if (!(G.length !== 2 || G[0] !== 1 || !o.isBytes(G[1]) || t.hex.encode(G[1]) !== "4e73")) return {
                type: "p2a",
                script: i1.Script.encode(G)
            };
        },
        decode: (G)=>{
            if (G.type === "p2a") return [
                1,
                t.hex.decode("4e73")
            ];
        }
    };
    function c(G, se) {
        try {
            return o.validatePubkey(G, se), !0;
        } catch  {
            return !1;
        }
    }
    const l = [
        s,
        {
            encode (G) {
                if (!(G.length !== 2 || !o.isBytes(G[0]) || !c(G[0], o.PubT.ecdsa) || G[1] !== "CHECKSIG")) return {
                    type: "pk",
                    pubkey: G[0]
                };
            },
            decode: (G)=>G.type === "pk" ? [
                    G.pubkey,
                    "CHECKSIG"
                ] : void 0
        },
        {
            encode (G) {
                if (!(G.length !== 5 || G[0] !== "DUP" || G[1] !== "HASH160" || !o.isBytes(G[2])) && !(G[3] !== "EQUALVERIFY" || G[4] !== "CHECKSIG")) return {
                    type: "pkh",
                    hash: G[2]
                };
            },
            decode: (G)=>G.type === "pkh" ? [
                    "DUP",
                    "HASH160",
                    G.hash,
                    "EQUALVERIFY",
                    "CHECKSIG"
                ] : void 0
        },
        {
            encode (G) {
                if (!(G.length !== 3 || G[0] !== "HASH160" || !o.isBytes(G[1]) || G[2] !== "EQUAL")) return {
                    type: "sh",
                    hash: G[1]
                };
            },
            decode: (G)=>G.type === "sh" ? [
                    "HASH160",
                    G.hash,
                    "EQUAL"
                ] : void 0
        },
        {
            encode (G) {
                if (!(G.length !== 2 || G[0] !== 0 || !o.isBytes(G[1])) && G[1].length === 32) return {
                    type: "wsh",
                    hash: G[1]
                };
            },
            decode: (G)=>G.type === "wsh" ? [
                    0,
                    G.hash
                ] : void 0
        },
        {
            encode (G) {
                if (!(G.length !== 2 || G[0] !== 0 || !o.isBytes(G[1])) && G[1].length === 20) return {
                    type: "wpkh",
                    hash: G[1]
                };
            },
            decode: (G)=>G.type === "wpkh" ? [
                    0,
                    G.hash
                ] : void 0
        },
        {
            encode (G) {
                const se = G.length - 1;
                if (G[se] !== "CHECKMULTISIG") return;
                const Z = G[0], ie = G[se - 1];
                if (typeof Z != "number" || typeof ie != "number") return;
                const pe = G.slice(1, -2);
                if (ie === pe.length) {
                    for (const ve of pe)if (!o.isBytes(ve)) return;
                    return {
                        type: "ms",
                        m: Z,
                        pubkeys: pe
                    };
                }
            },
            // checkmultisig(n, ..pubkeys, m)
            decode: (G)=>G.type === "ms" ? [
                    G.m,
                    ...G.pubkeys,
                    G.pubkeys.length,
                    "CHECKMULTISIG"
                ] : void 0
        },
        {
            encode (G) {
                if (!(G.length !== 2 || G[0] !== 1 || !o.isBytes(G[1]))) return {
                    type: "tr",
                    pubkey: G[1]
                };
            },
            decode: (G)=>G.type === "tr" ? [
                    1,
                    G.pubkey
                ] : void 0
        },
        {
            encode (G) {
                const se = G.length - 1;
                if (G[se] !== "CHECKSIG") return;
                const Z = [];
                for(let ie = 0; ie < se; ie++){
                    const pe = G[ie];
                    if (ie & 1) {
                        if (pe !== "CHECKSIGVERIFY" || ie === se - 1) return;
                        continue;
                    }
                    if (!o.isBytes(pe)) return;
                    Z.push(pe);
                }
                return {
                    type: "tr_ns",
                    pubkeys: Z
                };
            },
            decode: (G)=>{
                if (G.type !== "tr_ns") return;
                const se = [];
                for(let Z = 0; Z < G.pubkeys.length - 1; Z++)se.push(G.pubkeys[Z], "CHECKSIGVERIFY");
                return se.push(G.pubkeys[G.pubkeys.length - 1], "CHECKSIG"), se;
            }
        },
        {
            encode (G) {
                const se = G.length - 1;
                if (G[se] !== "NUMEQUAL" || G[1] !== "CHECKSIG") return;
                const Z = [], ie = (0, i1.OpToNum)(G[se - 1]);
                if (typeof ie == "number") {
                    for(let pe = 0; pe < se - 1; pe++){
                        const ve = G[pe];
                        if (pe & 1) {
                            if (ve !== (pe === 1 ? "CHECKSIG" : "CHECKSIGADD")) throw new Error("OutScript.encode/tr_ms: wrong element");
                            continue;
                        }
                        if (!o.isBytes(ve)) throw new Error("OutScript.encode/tr_ms: wrong key element");
                        Z.push(ve);
                    }
                    return {
                        type: "tr_ms",
                        pubkeys: Z,
                        m: ie
                    };
                }
            },
            decode: (G)=>{
                if (G.type !== "tr_ms") return;
                const se = [
                    G.pubkeys[0],
                    "CHECKSIG"
                ];
                for(let Z = 1; Z < G.pubkeys.length; Z++)se.push(G.pubkeys[Z], "CHECKSIGADD");
                return se.push(G.m, "NUMEQUAL"), se;
            }
        },
        {
            encode (G) {
                return {
                    type: "unknown",
                    script: i1.Script.encode(G)
                };
            },
            decode: (G)=>G.type === "unknown" ? i1.Script.decode(G.script) : void 0
        }
    ], u = r.apply(i1.Script, r.coders.match(l));
    e.OutScript = r.validate(u, (G)=>{
        if (G.type === "pk" && !c(G.pubkey, o.PubT.ecdsa)) throw new Error("OutScript/pk: wrong key");
        if ((G.type === "pkh" || G.type === "sh" || G.type === "wpkh") && (!o.isBytes(G.hash) || G.hash.length !== 20)) throw new Error(`OutScript/${G.type}: wrong hash`);
        if (G.type === "wsh" && (!o.isBytes(G.hash) || G.hash.length !== 32)) throw new Error("OutScript/wsh: wrong hash");
        if (G.type === "tr" && (!o.isBytes(G.pubkey) || !c(G.pubkey, o.PubT.schnorr))) throw new Error("OutScript/tr: wrong taproot public key");
        if ((G.type === "ms" || G.type === "tr_ns" || G.type === "tr_ms") && !Array.isArray(G.pubkeys)) throw new Error("OutScript/multisig: wrong pubkeys array");
        if (G.type === "ms") {
            const se = G.pubkeys.length;
            for (const Z of G.pubkeys)if (!c(Z, o.PubT.ecdsa)) throw new Error("OutScript/multisig: wrong pubkey");
            if (G.m <= 0 || se > 16 || G.m > se) throw new Error("OutScript/multisig: invalid params");
        }
        if (G.type === "tr_ns" || G.type === "tr_ms") {
            for (const se of G.pubkeys)if (!c(se, o.PubT.schnorr)) throw new Error(`OutScript/${G.type}: wrong pubkey`);
        }
        if (G.type === "tr_ms") {
            const se = G.pubkeys.length;
            if (G.m <= 0 || se > 999 || G.m > se) throw new Error("OutScript/tr_ms: invalid params");
        }
        return G;
    });
    function f(G, se) {
        if (!o.equalBytes(G.hash, o.sha256(se))) throw new Error("checkScript: wsh wrong witnessScript hash");
        const Z = e.OutScript.decode(se);
        if (Z.type === "tr" || Z.type === "tr_ns" || Z.type === "tr_ms") throw new Error(`checkScript: P2${Z.type} cannot be wrapped in P2SH`);
        if (Z.type === "wpkh" || Z.type === "sh") throw new Error(`checkScript: P2${Z.type} cannot be wrapped in P2WSH`);
    }
    function h(G, se, Z) {
        if (G) {
            const ie = e.OutScript.decode(G);
            if (ie.type === "tr_ns" || ie.type === "tr_ms" || ie.type === "ms" || ie.type == "pk") throw new Error(`checkScript: non-wrapped ${ie.type}`);
            if (ie.type === "sh" && se) {
                if (!o.equalBytes(ie.hash, o.hash160(se))) throw new Error("checkScript: sh wrong redeemScript hash");
                const pe = e.OutScript.decode(se);
                if (pe.type === "tr" || pe.type === "tr_ns" || pe.type === "tr_ms") throw new Error(`checkScript: P2${pe.type} cannot be wrapped in P2SH`);
                if (pe.type === "sh") throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
            }
            ie.type === "wsh" && Z && f(ie, Z);
        }
        if (se) {
            const ie = e.OutScript.decode(se);
            ie.type === "wsh" && Z && f(ie, Z);
        }
    }
    function y(G) {
        const se = {};
        for (const Z of G){
            const ie = t.hex.encode(Z);
            if (se[ie]) throw new Error(`Multisig: non-uniq pubkey: ${G.map(t.hex.encode)}`);
            se[ie] = !0;
        }
    }
    const S = (G, se = a.NETWORK)=>{
        if (!c(G, o.PubT.ecdsa)) throw new Error("P2PK: invalid publicKey");
        return {
            type: "pk",
            script: e.OutScript.encode({
                type: "pk",
                pubkey: G
            })
        };
    };
    e.p2pk = S;
    const k = (G, se = a.NETWORK)=>{
        if (!c(G, o.PubT.ecdsa)) throw new Error("P2PKH: invalid publicKey");
        const Z = o.hash160(G);
        return {
            type: "pkh",
            script: e.OutScript.encode({
                type: "pkh",
                hash: Z
            }),
            address: ue(se).encode({
                type: "pkh",
                hash: Z
            }),
            hash: Z
        };
    };
    e.p2pkh = k;
    const P = (G, se = a.NETWORK)=>{
        const Z = G.script;
        if (!o.isBytes(Z)) throw new Error(`Wrong script: ${typeof G.script}, expected Uint8Array`);
        const ie = o.hash160(Z), pe = e.OutScript.encode({
            type: "sh",
            hash: ie
        });
        return h(pe, Z, G.witnessScript), G.witnessScript ? {
            type: "sh",
            redeemScript: Z,
            script: e.OutScript.encode({
                type: "sh",
                hash: ie
            }),
            address: ue(se).encode({
                type: "sh",
                hash: ie
            }),
            hash: ie,
            witnessScript: G.witnessScript
        } : {
            type: "sh",
            redeemScript: Z,
            script: e.OutScript.encode({
                type: "sh",
                hash: ie
            }),
            address: ue(se).encode({
                type: "sh",
                hash: ie
            }),
            hash: ie
        };
    };
    e.p2sh = P;
    const M = (G, se = a.NETWORK)=>{
        const Z = G.script;
        if (!o.isBytes(Z)) throw new Error(`Wrong script: ${typeof Z}, expected Uint8Array`);
        const ie = o.sha256(Z), pe = e.OutScript.encode({
            type: "wsh",
            hash: ie
        });
        return h(pe, void 0, Z), {
            type: "wsh",
            witnessScript: Z,
            script: e.OutScript.encode({
                type: "wsh",
                hash: ie
            }),
            address: ue(se).encode({
                type: "wsh",
                hash: ie
            }),
            hash: ie
        };
    };
    e.p2wsh = M;
    const N = (G, se = a.NETWORK)=>{
        if (!c(G, o.PubT.ecdsa)) throw new Error("P2WPKH: invalid publicKey");
        if (G.length === 65) throw new Error("P2WPKH: uncompressed public key");
        const Z = o.hash160(G);
        return {
            type: "wpkh",
            script: e.OutScript.encode({
                type: "wpkh",
                hash: Z
            }),
            address: ue(se).encode({
                type: "wpkh",
                hash: Z
            }),
            hash: Z
        };
    };
    e.p2wpkh = N;
    const z = (G, se, Z = !1)=>(Z || y(se), {
            type: "ms",
            script: e.OutScript.encode({
                type: "ms",
                pubkeys: se,
                m: G
            })
        });
    e.p2ms = z;
    function K(G, se, Z = !1, ie) {
        const pe = e.OutScript.decode(G);
        if (pe.type === "unknown") {
            if (ie) {
                const Ie = r.apply(i1.Script, r.coders.match(ie)).decode(G);
                if (Ie !== void 0) {
                    if (typeof Ie.type != "string" || !Ie.type.startsWith("tr_")) throw new Error(`P2TR: invalid custom type=${Ie.type}`);
                    return;
                }
            }
            if (Z) return;
        }
        if (![
            "tr_ns",
            "tr_ms"
        ].includes(pe.type)) throw new Error(`P2TR: invalid leaf script=${pe.type}`);
        const ve = pe;
        if (!Z && ve.pubkeys) for (const Ie of ve.pubkeys){
            if (o.equalBytes(Ie, o.TAPROOT_UNSPENDABLE_KEY)) throw new Error("Unspendable taproot key in leaf script");
            if (o.equalBytes(Ie, se)) throw new Error("Using P2TR with leaf script with same key as internal key is not supported");
        }
    }
    function $(G) {
        const se = Array.from(G);
        for(; se.length >= 2;){
            se.sort((Ie, Me)=>(Me.weight || 1) - (Ie.weight || 1));
            const ie = se.pop(), pe = se.pop(), ve = ((pe == null ? void 0 : pe.weight) || 1) + ((ie == null ? void 0 : ie.weight) || 1);
            se.push({
                weight: ve,
                // Unwrap children array
                // TODO: Very hard to remove any here
                childs: [
                    (pe == null ? void 0 : pe.childs) || pe,
                    (ie == null ? void 0 : ie.childs) || ie
                ]
            });
        }
        const Z = se[0];
        return (Z == null ? void 0 : Z.childs) || Z;
    }
    function ne(G, se = []) {
        if (!G) throw new Error("taprootAddPath: empty tree");
        if (G.type === "leaf") return {
            ...G,
            path: se
        };
        if (G.type !== "branch") throw new Error(`taprootAddPath: wrong type=${G}`);
        return {
            ...G,
            path: se,
            // Left element has right hash in path and otherwise
            left: ne(G.left, [
                G.right.hash,
                ...se
            ]),
            right: ne(G.right, [
                G.left.hash,
                ...se
            ])
        };
    }
    function ee(G) {
        if (!G) throw new Error("taprootAddPath: empty tree");
        if (G.type === "leaf") return [
            G
        ];
        if (G.type !== "branch") throw new Error(`taprootWalkTree: wrong type=${G}`);
        return [
            ...ee(G.left),
            ...ee(G.right)
        ];
    }
    function q(G, se, Z = !1, ie) {
        if (!G) throw new Error("taprootHashTree: empty tree");
        if (Array.isArray(G) && G.length === 1 && (G = G[0]), !Array.isArray(G)) {
            const { leafVersion: Re, script: C } = G;
            if (G.tapLeafScript || G.tapMerkleRoot && !o.equalBytes(G.tapMerkleRoot, r.EMPTY)) throw new Error("P2TR: tapRoot leafScript cannot have tree");
            const J = typeof C == "string" ? t.hex.decode(C) : C;
            if (!o.isBytes(J)) throw new Error(`checkScript: wrong script type=${J}`);
            return K(J, se, Z, ie), {
                type: "leaf",
                version: Re,
                script: J,
                hash: (0, e.tapLeafHash)(J, Re)
            };
        }
        if (G.length !== 2 && (G = $(G)), G.length !== 2) throw new Error("hashTree: non binary tree!");
        const pe = q(G[0], se, Z, ie), ve = q(G[1], se, Z, ie);
        let [Ie, Me] = [
            pe.hash,
            ve.hash
        ];
        return o.compareBytes(Me, Ie) === -1 && ([Ie, Me] = [
            Me,
            Ie
        ]), {
            type: "branch",
            left: pe,
            right: ve,
            hash: o.tagSchnorr("TapBranch", Ie, Me)
        };
    }
    e.TAP_LEAF_VERSION = 192;
    const U = (G, se = e.TAP_LEAF_VERSION)=>o.tagSchnorr("TapLeaf", new Uint8Array([
            se
        ]), i1.VarBytes.encode(G));
    e.tapLeafHash = U;
    function Q(G, se, Z = a.NETWORK, ie = !1, pe) {
        if (!G && !se) throw new Error("p2tr: should have pubKey or scriptTree (or both)");
        const ve = typeof G == "string" ? t.hex.decode(G) : G || o.TAPROOT_UNSPENDABLE_KEY;
        if (!c(ve, o.PubT.schnorr)) throw new Error("p2tr: non-schnorr pubkey");
        if (se) {
            let Ie = ne(q(se, ve, ie, pe));
            const Me = Ie.hash, [Re, C] = o.taprootTweakPubkey(ve, Me), J = ee(Ie).map((me)=>({
                    ...me,
                    controlBlock: n.TaprootControlBlock.encode({
                        version: (me.version || e.TAP_LEAF_VERSION) + C,
                        internalKey: ve,
                        merklePath: me.path
                    })
                }));
            return {
                type: "tr",
                script: e.OutScript.encode({
                    type: "tr",
                    pubkey: Re
                }),
                address: ue(Z).encode({
                    type: "tr",
                    pubkey: Re
                }),
                // For tests
                tweakedPubkey: Re,
                // PSBT stuff
                tapInternalKey: ve,
                leaves: J,
                tapLeafScript: J.map((me)=>[
                        n.TaprootControlBlock.decode(me.controlBlock),
                        o.concatBytes(me.script, new Uint8Array([
                            me.version || e.TAP_LEAF_VERSION
                        ]))
                    ]),
                tapMerkleRoot: Me
            };
        } else {
            const Ie = o.taprootTweakPubkey(ve, r.EMPTY)[0];
            return {
                type: "tr",
                script: e.OutScript.encode({
                    type: "tr",
                    pubkey: Ie
                }),
                address: ue(Z).encode({
                    type: "tr",
                    pubkey: Ie
                }),
                // For tests
                tweakedPubkey: Ie,
                // PSBT stuff
                tapInternalKey: ve
            };
        }
    }
    function v(G, se) {
        const Z = [];
        if (!Array.isArray(se)) throw new Error("combinations: lst arg should be array");
        const ie = se.length;
        if (G > ie) throw new Error("combinations: m > lst.length, no combinations possible");
        const pe = Array.from({
            length: G
        }, (Ie, Me)=>Me), ve = pe.length - 1;
        e: for(;;){
            Z.push(pe.map((Me)=>se[Me])), pe[ve] += 1;
            let Ie = ve;
            for(; Ie >= 0 && pe[Ie] > ie - G + Ie; Ie--){
                if (pe[Ie] = 0, Ie === 0) break e;
                pe[Ie - 1] += 1;
            }
            for(Ie += 1; Ie < pe.length; Ie++)pe[Ie] = pe[Ie - 1] + 1;
        }
        return Z;
    }
    const B = (G, se, Z = !1)=>(Z || y(se), v(G, se).map((ie)=>({
                type: "tr_ns",
                script: e.OutScript.encode({
                    type: "tr_ns",
                    pubkeys: ie
                })
            })));
    e.p2tr_ns = B;
    const g = (G)=>(0, e.p2tr_ns)(1, [
            G
        ], void 0)[0];
    e.p2tr_pk = g;
    function E(G, se, Z = !1) {
        return Z || y(se), {
            type: "tr_ms",
            script: e.OutScript.encode({
                type: "tr_ms",
                pubkeys: se,
                m: G
            })
        };
    }
    function w(G, se, Z = a.NETWORK) {
        if (G === "tr") return Q(o.pubSchnorr(se), void 0, Z).address;
        const ie = o.pubECDSA(se);
        if (G === "pkh") return (0, e.p2pkh)(ie, Z).address;
        if (G === "wpkh") return (0, e.p2wpkh)(ie, Z).address;
        throw new Error(`getAddress: unknown type=${G}`);
    }
    const _ = (G)=>Array.from(G).sort(o.compareBytes);
    e._sortPubkeys = _;
    function O(G, se, Z = !1, ie = !1, pe = a.NETWORK) {
        const ve = (0, e.p2ms)(G, Z ? (0, e._sortPubkeys)(se) : se);
        return ie ? (0, e.p2wsh)(ve, pe) : (0, e.p2sh)(ve, pe);
    }
    function I(G, se, Z = !1, ie = a.NETWORK) {
        return O(G, se, !0, Z, ie);
    }
    const x = (0, t.createBase58check)(o.sha256);
    function R(G, se) {
        if (se.length < 2 || se.length > 40) throw new Error("Witness: invalid length");
        if (G > 16) throw new Error("Witness: invalid version");
        if (G === 0 && !(se.length === 20 || se.length === 32)) throw new Error("Witness: invalid length for version");
    }
    function j(G, se, Z = a.NETWORK) {
        R(G, se);
        const ie = G === 0 ? t.bech32 : t.bech32m;
        return ie.encode(Z.bech32, [
            G
        ].concat(ie.toWords(se)));
    }
    function Y(G, se) {
        return x.encode(o.concatBytes(Uint8Array.from(se), G));
    }
    function he(G = a.NETWORK) {
        return {
            encode (se) {
                const Z = o.concatBytes(se, new Uint8Array([
                    1
                ]));
                return Y(Z.subarray(0, 33), [
                    G.wif
                ]);
            },
            decode (se) {
                let Z = x.decode(se);
                if (Z[0] !== G.wif) throw new Error("Wrong WIF prefix");
                if (Z = Z.subarray(1), Z.length !== 33) throw new Error("Wrong WIF length");
                if (Z[32] !== 1) throw new Error("Wrong WIF postfix");
                return Z.subarray(0, -1);
            }
        };
    }
    function ue(G = a.NETWORK) {
        return {
            encode (se) {
                const { type: Z } = se;
                if (Z === "wpkh" || Z === "wsh") return j(0, se.hash, G);
                if (Z === "tr") return j(1, se.pubkey, G);
                if (Z === "pkh") return Y(se.hash, [
                    G.pubKeyHash
                ]);
                if (Z === "sh") return Y(se.hash, [
                    G.scriptHash
                ]);
                throw new Error(`Unknown address type=${Z}`);
            },
            decode (se) {
                if (se.length < 14 || se.length > 74) throw new Error("Invalid address length");
                if (G.bech32 && se.toLowerCase().startsWith(`${G.bech32}1`)) {
                    let ie;
                    try {
                        if (ie = t.bech32.decode(se), ie.words[0] !== 0) throw new Error(`bech32: wrong version=${ie.words[0]}`);
                    } catch  {
                        if (ie = t.bech32m.decode(se), ie.words[0] === 0) throw new Error(`bech32m: wrong version=${ie.words[0]}`);
                    }
                    if (ie.prefix !== G.bech32) throw new Error(`wrong bech32 prefix=${ie.prefix}`);
                    const [pe, ...ve] = ie.words, Ie = t.bech32.fromWords(ve);
                    if (R(pe, Ie), pe === 0 && Ie.length === 32) return {
                        type: "wsh",
                        hash: Ie
                    };
                    if (pe === 0 && Ie.length === 20) return {
                        type: "wpkh",
                        hash: Ie
                    };
                    if (pe === 1 && Ie.length === 32) return {
                        type: "tr",
                        pubkey: Ie
                    };
                    throw new Error("Unknown witness program");
                }
                const Z = x.decode(se);
                if (Z.length !== 21) throw new Error("Invalid base58 address");
                if (Z[0] === G.pubKeyHash) return {
                    type: "pkh",
                    hash: Z.slice(1)
                };
                if (Z[0] === G.scriptHash) return {
                    type: "sh",
                    hash: Z.slice(1)
                };
                throw new Error(`Invalid address prefix=${Z[0]}`);
            }
        };
    }
})(_0);
var Dm = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Transaction = e.SigHash = e.SignatureHash = e.def = e.Decimal = e.DEFAULT_SEQUENCE = e.DEFAULT_LOCKTIME = e.DEFAULT_VERSION = e.PRECISION = e.toVsize = void 0, e.cloneDeep = h, e.inputBeforeSign = M, e.getPrevOut = q, e.normalizeInput = U, e.getInputType = Q, e.PSBTCombine = B, e.bip32Path = E;
    const t = Xh, r = Ff, n = _0, i1 = R1, o = Yh, a = Gs, s = Gs, c = new Uint8Array(32), l = {
        amount: 0xffffffffffffffffn,
        script: r.EMPTY
    }, u = (w)=>Math.ceil(w / 4);
    e.toVsize = u, e.PRECISION = 8, e.DEFAULT_VERSION = 2, e.DEFAULT_LOCKTIME = 0, e.DEFAULT_SEQUENCE = 4294967295, e.Decimal = r.coders.decimal(e.PRECISION);
    const f = (w, _)=>w === void 0 ? _ : w;
    e.def = f;
    function h(w) {
        if (Array.isArray(w)) return w.map((_)=>h(_));
        if ((0, s.isBytes)(w)) return Uint8Array.from(w);
        if ([
            "number",
            "bigint",
            "boolean",
            "string",
            "undefined"
        ].includes(typeof w) || w === null) return w;
        if (typeof w == "object") return Object.fromEntries(Object.entries(w).map(([_, O])=>[
                _,
                h(O)
            ]));
        throw new Error(`cloneDeep: unknown type=${w} (${typeof w})`);
    }
    var y;
    (function(w) {
        w[w.DEFAULT = 0] = "DEFAULT", w[w.ALL = 1] = "ALL", w[w.NONE = 2] = "NONE", w[w.SINGLE = 3] = "SINGLE", w[w.ANYONECANPAY = 128] = "ANYONECANPAY";
    })(y || (e.SignatureHash = y = {}));
    var S;
    (function(w) {
        w[w.DEFAULT = 0] = "DEFAULT", w[w.ALL = 1] = "ALL", w[w.NONE = 2] = "NONE", w[w.SINGLE = 3] = "SINGLE", w[w.DEFAULT_ANYONECANPAY = 128] = "DEFAULT_ANYONECANPAY", w[w.ALL_ANYONECANPAY = 129] = "ALL_ANYONECANPAY", w[w.NONE_ANYONECANPAY = 130] = "NONE_ANYONECANPAY", w[w.SINGLE_ANYONECANPAY = 131] = "SINGLE_ANYONECANPAY";
    })(S || (e.SigHash = S = {}));
    function k(w, _, O, I = r.EMPTY) {
        return (0, s.equalBytes)(O, _) && (w = a.taprootTweakPrivKey(w, I), _ = a.pubSchnorr(w)), {
            privKey: w,
            pubKey: _
        };
    }
    function P(w) {
        if (w.script === void 0 || w.amount === void 0) throw new Error("Transaction/output: script and amount required");
        return {
            script: w.script,
            amount: w.amount
        };
    }
    function M(w) {
        if (w.txid === void 0 || w.index === void 0) throw new Error("Transaction/input: txid and index required");
        return {
            txid: w.txid,
            index: w.index,
            sequence: (0, e.def)(w.sequence, e.DEFAULT_SEQUENCE),
            finalScriptSig: (0, e.def)(w.finalScriptSig, r.EMPTY)
        };
    }
    function N(w) {
        for(const _ in w){
            const O = _;
            i1.PSBTInputFinalKeys.includes(O) || delete w[O];
        }
    }
    const z = r.struct({
        txid: r.bytes(32, !0),
        index: r.U32LE
    });
    function K(w) {
        if (typeof w != "number" || typeof S[w] != "string") throw new Error(`Invalid SigHash=${w}`);
        return w;
    }
    function $(w) {
        const _ = w & 31;
        return {
            isAny: !!(w & y.ANYONECANPAY),
            isNone: _ === y.NONE,
            isSingle: _ === y.SINGLE
        };
    }
    function ne(w) {
        if (w !== void 0 && ({}).toString.call(w) !== "[object Object]") throw new Error(`Wrong object type for transaction options: ${w}`);
        const _ = {
            ...w,
            // Defaults
            version: (0, e.def)(w.version, e.DEFAULT_VERSION),
            lockTime: (0, e.def)(w.lockTime, 0),
            PSBTVersion: (0, e.def)(w.PSBTVersion, 0)
        };
        if (typeof _.allowUnknowInput < "u" && (w.allowUnknownInputs = _.allowUnknowInput), typeof _.allowUnknowOutput < "u" && (w.allowUnknownOutputs = _.allowUnknowOutput), typeof _.lockTime != "number") throw new Error("Transaction lock time should be number");
        if (r.U32LE.encode(_.lockTime), _.PSBTVersion !== 0 && _.PSBTVersion !== 2) throw new Error(`Unknown PSBT version ${_.PSBTVersion}`);
        for (const O of [
            "allowUnknownVersion",
            "allowUnknownOutputs",
            "allowUnknownInputs",
            "disableScriptCheck",
            "bip174jsCompat",
            "allowLegacyWitnessUtxo",
            "lowR"
        ]){
            const I = _[O];
            if (I !== void 0 && typeof I != "boolean") throw new Error(`Transation options wrong type: ${O}=${I} (${typeof I})`);
        }
        if (_.allowUnknownVersion ? typeof _.version == "number" : ![
            -1,
            0,
            1,
            2,
            3
        ].includes(_.version)) throw new Error(`Unknown version: ${_.version}`);
        if (_.customScripts !== void 0) {
            const O = _.customScripts;
            if (!Array.isArray(O)) throw new Error(`wrong custom scripts type (expected array): customScripts=${O} (${typeof O})`);
            for (const I of O){
                if (typeof I.encode != "function" || typeof I.decode != "function") throw new Error(`wrong script=${I} (${typeof I})`);
                if (I.finalizeTaproot !== void 0 && typeof I.finalizeTaproot != "function") throw new Error(`wrong script=${I} (${typeof I})`);
            }
        }
        return Object.freeze(_);
    }
    function ee(w) {
        if (w.nonWitnessUtxo && w.index !== void 0) {
            const _ = w.nonWitnessUtxo.outputs.length - 1;
            if (w.index > _) throw new Error(`validateInput: index(${w.index}) not in nonWitnessUtxo`);
            const O = w.nonWitnessUtxo.outputs[w.index];
            if (w.witnessUtxo && (!(0, s.equalBytes)(w.witnessUtxo.script, O.script) || w.witnessUtxo.amount !== O.amount)) throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo");
            if (w.txid) {
                if (w.nonWitnessUtxo.outputs.length - 1 < w.index) throw new Error("nonWitnessUtxo: incorect output index");
                const I = v.fromRaw(o.RawTx.encode(w.nonWitnessUtxo), {
                    allowUnknownOutputs: !0,
                    disableScriptCheck: !0,
                    allowUnknownInputs: !0
                }), x = t.hex.encode(w.txid);
                if (I.isFinal && I.id !== x) throw new Error(`nonWitnessUtxo: wrong txid, exp=${x} got=${I.id}`);
            }
        }
        return w;
    }
    function q(w) {
        if (w.nonWitnessUtxo) {
            if (w.index === void 0) throw new Error("Unknown input index");
            return w.nonWitnessUtxo.outputs[w.index];
        } else {
            if (w.witnessUtxo) return w.witnessUtxo;
            throw new Error("Cannot find previous output info");
        }
    }
    function U(w, _, O, I = !1, x = !1) {
        let { nonWitnessUtxo: R, txid: j } = w;
        typeof R == "string" && (R = t.hex.decode(R)), (0, s.isBytes)(R) && (R = o.RawTx.decode(R)), !("nonWitnessUtxo" in w) && R === void 0 && (R = _ == null ? void 0 : _.nonWitnessUtxo), typeof j == "string" && (j = t.hex.decode(j)), j === void 0 && (j = _ == null ? void 0 : _.txid);
        let Y = {
            ..._,
            ...w,
            nonWitnessUtxo: R,
            txid: j
        };
        !("nonWitnessUtxo" in w) && Y.nonWitnessUtxo === void 0 && delete Y.nonWitnessUtxo, Y.sequence === void 0 && (Y.sequence = e.DEFAULT_SEQUENCE), Y.tapMerkleRoot === null && delete Y.tapMerkleRoot, Y = i1.mergeKeyMap(i1.PSBTInput, Y, _, O, x), i1.PSBTInputCoder.encode(Y);
        let he;
        return Y.nonWitnessUtxo && Y.index !== void 0 ? he = Y.nonWitnessUtxo.outputs[Y.index] : Y.witnessUtxo && (he = Y.witnessUtxo), he && !I && (0, n.checkScript)(he && he.script, Y.redeemScript, Y.witnessScript), Y;
    }
    function Q(w, _ = !1) {
        let O = "legacy", I = y.ALL;
        const x = q(w), R = n.OutScript.decode(x.script);
        let j = R.type, Y = R;
        const he = [
            R
        ];
        if (R.type === "tr") return I = y.DEFAULT, {
            txType: "taproot",
            type: "tr",
            last: R,
            lastScript: x.script,
            defaultSighash: I,
            sighash: w.sighashType || I
        };
        {
            if ((R.type === "wpkh" || R.type === "wsh") && (O = "segwit"), R.type === "sh") {
                if (!w.redeemScript) throw new Error("inputType: sh without redeemScript");
                let Z = n.OutScript.decode(w.redeemScript);
                (Z.type === "wpkh" || Z.type === "wsh") && (O = "segwit"), he.push(Z), Y = Z, j += `-${Z.type}`;
            }
            if (Y.type === "wsh") {
                if (!w.witnessScript) throw new Error("inputType: wsh without witnessScript");
                let Z = n.OutScript.decode(w.witnessScript);
                Z.type === "wsh" && (O = "segwit"), he.push(Z), Y = Z, j += `-${Z.type}`;
            }
            const ue = he[he.length - 1];
            if (ue.type === "sh" || ue.type === "wsh") throw new Error("inputType: sh/wsh cannot be terminal type");
            const G = n.OutScript.encode(ue), se = {
                type: j,
                txType: O,
                last: ue,
                lastScript: G,
                defaultSighash: I,
                sighash: w.sighashType || I
            };
            if (O === "legacy" && !_ && !w.nonWitnessUtxo) throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");
            return se;
        }
    }
    class v {
        constructor(_ = {}){
            this.global = {}, this.inputs = [], this.outputs = [];
            const O = this.opts = ne(_);
            O.lockTime !== e.DEFAULT_LOCKTIME && (this.global.fallbackLocktime = O.lockTime), this.global.txVersion = O.version;
        }
        // Import
        static fromRaw(_, O = {}) {
            const I = o.RawTx.decode(_), x = new v({
                ...O,
                version: I.version,
                lockTime: I.lockTime
            });
            for (const R of I.outputs)x.addOutput(R);
            if (x.outputs = I.outputs, x.inputs = I.inputs, I.witnesses) for(let R = 0; R < I.witnesses.length; R++)x.inputs[R].finalScriptWitness = I.witnesses[R];
            return x;
        }
        // PSBT
        static fromPSBT(_, O = {}) {
            let I;
            try {
                I = i1.RawPSBTV0.decode(_);
            } catch (se) {
                try {
                    I = i1.RawPSBTV2.decode(_);
                } catch  {
                    throw se;
                }
            }
            const x = I.global.version || 0;
            if (x !== 0 && x !== 2) throw new Error(`Wrong PSBT version=${x}`);
            const R = I.global.unsignedTx, j = x === 0 ? R == null ? void 0 : R.version : I.global.txVersion, Y = x === 0 ? R == null ? void 0 : R.lockTime : I.global.fallbackLocktime, he = new v({
                ...O,
                version: j,
                lockTime: Y,
                PSBTVersion: x
            }), ue = x === 0 ? R == null ? void 0 : R.inputs.length : I.global.inputCount;
            he.inputs = I.inputs.slice(0, ue).map((se, Z)=>{
                var ie;
                return ee({
                    finalScriptSig: r.EMPTY,
                    ...(ie = I.global.unsignedTx) == null ? void 0 : ie.inputs[Z],
                    ...se
                });
            });
            const G = x === 0 ? R == null ? void 0 : R.outputs.length : I.global.outputCount;
            return he.outputs = I.outputs.slice(0, G).map((se, Z)=>{
                var ie;
                return {
                    ...se,
                    ...(ie = I.global.unsignedTx) == null ? void 0 : ie.outputs[Z]
                };
            }), he.global = {
                ...I.global,
                txVersion: j
            }, Y !== e.DEFAULT_LOCKTIME && (he.global.fallbackLocktime = Y), he;
        }
        toPSBT(_ = this.opts.PSBTVersion) {
            if (_ !== 0 && _ !== 2) throw new Error(`Wrong PSBT version=${_}`);
            const O = this.inputs.map((R)=>ee(i1.cleanPSBTFields(_, i1.PSBTInput, R)));
            for (const R of O)R.partialSig && !R.partialSig.length && delete R.partialSig, R.finalScriptSig && !R.finalScriptSig.length && delete R.finalScriptSig, R.finalScriptWitness && !R.finalScriptWitness.length && delete R.finalScriptWitness;
            const I = this.outputs.map((R)=>i1.cleanPSBTFields(_, i1.PSBTOutput, R)), x = {
                ...this.global
            };
            return _ === 0 ? (x.unsignedTx = o.RawOldTx.decode(o.RawOldTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(M).map((R)=>({
                        ...R,
                        finalScriptSig: r.EMPTY
                    })),
                outputs: this.outputs.map(P)
            })), delete x.fallbackLocktime, delete x.txVersion) : (x.version = _, x.txVersion = this.version, x.inputCount = this.inputs.length, x.outputCount = this.outputs.length, x.fallbackLocktime && x.fallbackLocktime === e.DEFAULT_LOCKTIME && delete x.fallbackLocktime), this.opts.bip174jsCompat && (O.length || O.push({}), I.length || I.push({})), (_ === 0 ? i1.RawPSBTV0 : i1.RawPSBTV2).encode({
                global: x,
                inputs: O,
                outputs: I
            });
        }
        // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)
        get lockTime() {
            let _ = e.DEFAULT_LOCKTIME, O = 0, I = e.DEFAULT_LOCKTIME, x = 0;
            for (const R of this.inputs)R.requiredHeightLocktime && (_ = Math.max(_, R.requiredHeightLocktime), O++), R.requiredTimeLocktime && (I = Math.max(I, R.requiredTimeLocktime), x++);
            return O && O >= x ? _ : I !== e.DEFAULT_LOCKTIME ? I : this.global.fallbackLocktime || e.DEFAULT_LOCKTIME;
        }
        get version() {
            if (this.global.txVersion === void 0) throw new Error("No global.txVersion");
            return this.global.txVersion;
        }
        inputStatus(_) {
            this.checkInputIdx(_);
            const O = this.inputs[_];
            return O.finalScriptSig && O.finalScriptSig.length || O.finalScriptWitness && O.finalScriptWitness.length ? "finalized" : O.tapKeySig || O.tapScriptSig && O.tapScriptSig.length || O.partialSig && O.partialSig.length ? "signed" : "unsigned";
        }
        // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range
        // We will lose some vectors -> smaller test coverage of preimages (very important!)
        inputSighash(_) {
            this.checkInputIdx(_);
            const O = this.inputs[_].sighashType, I = O === void 0 ? y.DEFAULT : O, x = I === y.DEFAULT ? y.ALL : I & 3;
            return {
                sigInputs: I & y.ANYONECANPAY,
                sigOutputs: x
            };
        }
        // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.
        // Some cache will be nice, but there chance to have bugs with cache invalidation
        signStatus() {
            let _ = !0, O = !0, I = [], x = [];
            for(let R = 0; R < this.inputs.length; R++){
                if (this.inputStatus(R) === "unsigned") continue;
                const { sigInputs: j, sigOutputs: Y } = this.inputSighash(R);
                if (j === y.ANYONECANPAY ? I.push(R) : _ = !1, Y === y.ALL) O = !1;
                else if (Y === y.SINGLE) x.push(R);
                else if (Y !== y.NONE) throw new Error(`Wrong signature hash output type: ${Y}`);
            }
            return {
                addInput: _,
                addOutput: O,
                inputs: I,
                outputs: x
            };
        }
        get isFinal() {
            for(let _ = 0; _ < this.inputs.length; _++)if (this.inputStatus(_) !== "finalized") return !1;
            return !0;
        }
        // Info utils
        get hasWitnesses() {
            let _ = !1;
            for (const O of this.inputs)O.finalScriptWitness && O.finalScriptWitness.length && (_ = !0);
            return _;
        }
        // https://en.bitcoin.it/wiki/Weight_units
        get weight() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            let _ = 32;
            const O = this.outputs.map(P);
            _ += 4 * o.CompactSizeLen.encode(this.outputs.length).length;
            for (const I of O)_ += 32 + 4 * o.VarBytes.encode(I.script).length;
            this.hasWitnesses && (_ += 2), _ += 4 * o.CompactSizeLen.encode(this.inputs.length).length;
            for (const I of this.inputs)_ += 160 + 4 * o.VarBytes.encode(I.finalScriptSig || r.EMPTY).length, this.hasWitnesses && I.finalScriptWitness && (_ += o.RawWitness.encode(I.finalScriptWitness).length);
            return _;
        }
        get vsize() {
            return (0, e.toVsize)(this.weight);
        }
        toBytes(_ = !1, O = !1) {
            return o.RawTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(M).map((I)=>({
                        ...I,
                        finalScriptSig: _ && I.finalScriptSig || r.EMPTY
                    })),
                outputs: this.outputs.map(P),
                witnesses: this.inputs.map((I)=>I.finalScriptWitness || []),
                segwitFlag: O && this.hasWitnesses
            });
        }
        get unsignedTx() {
            return this.toBytes(!1, !1);
        }
        get hex() {
            return t.hex.encode(this.toBytes(!0, this.hasWitnesses));
        }
        get hash() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return t.hex.encode(a.sha256x2(this.toBytes(!0)));
        }
        get id() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return t.hex.encode(a.sha256x2(this.toBytes(!0)).reverse());
        }
        // Input stuff
        checkInputIdx(_) {
            if (!Number.isSafeInteger(_) || 0 > _ || _ >= this.inputs.length) throw new Error(`Wrong input index=${_}`);
        }
        getInput(_) {
            return this.checkInputIdx(_), h(this.inputs[_]);
        }
        get inputsLength() {
            return this.inputs.length;
        }
        // Modification
        addInput(_, O = !1) {
            if (!O && !this.signStatus().addInput) throw new Error("Tx has signed inputs, cannot add new one");
            return this.inputs.push(U(_, void 0, void 0, this.opts.disableScriptCheck)), this.inputs.length - 1;
        }
        updateInput(_, O, I = !1) {
            this.checkInputIdx(_);
            let x;
            if (!I) {
                const R = this.signStatus();
                (!R.addInput || R.inputs.includes(_)) && (x = i1.PSBTInputUnsignedKeys);
            }
            this.inputs[_] = U(O, this.inputs[_], x, this.opts.disableScriptCheck, this.opts.allowUnknown);
        }
        // Output stuff
        checkOutputIdx(_) {
            if (!Number.isSafeInteger(_) || 0 > _ || _ >= this.outputs.length) throw new Error(`Wrong output index=${_}`);
        }
        getOutput(_) {
            return this.checkOutputIdx(_), h(this.outputs[_]);
        }
        getOutputAddress(_, O = s.NETWORK) {
            const I = this.getOutput(_);
            if (I.script) return (0, n.Address)(O).encode(n.OutScript.decode(I.script));
        }
        get outputsLength() {
            return this.outputs.length;
        }
        normalizeOutput(_, O, I) {
            let { amount: x, script: R } = _;
            if (x === void 0 && (x = O == null ? void 0 : O.amount), typeof x != "bigint") throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${x} of type ${typeof x}`);
            typeof R == "string" && (R = t.hex.decode(R)), R === void 0 && (R = O == null ? void 0 : O.script);
            let j = {
                ...O,
                ..._,
                amount: x,
                script: R
            };
            if (j.amount === void 0 && delete j.amount, j = i1.mergeKeyMap(i1.PSBTOutput, j, O, I, this.opts.allowUnknown), i1.PSBTOutputCoder.encode(j), j.script && !this.opts.allowUnknownOutputs && n.OutScript.decode(j.script).type === "unknown") throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
            return this.opts.disableScriptCheck || (0, n.checkScript)(j.script, j.redeemScript, j.witnessScript), j;
        }
        addOutput(_, O = !1) {
            if (!O && !this.signStatus().addOutput) throw new Error("Tx has signed outputs, cannot add new one");
            return this.outputs.push(this.normalizeOutput(_)), this.outputs.length - 1;
        }
        updateOutput(_, O, I = !1) {
            this.checkOutputIdx(_);
            let x;
            if (!I) {
                const R = this.signStatus();
                (!R.addOutput || R.outputs.includes(_)) && (x = i1.PSBTOutputUnsignedKeys);
            }
            this.outputs[_] = this.normalizeOutput(O, this.outputs[_], x);
        }
        addOutputAddress(_, O, I = s.NETWORK) {
            return this.addOutput({
                script: n.OutScript.encode((0, n.Address)(I).decode(_)),
                amount: O
            });
        }
        // Utils
        get fee() {
            let _ = 0n;
            for (const I of this.inputs){
                const x = q(I);
                if (!x) throw new Error("Empty input amount");
                _ += x.amount;
            }
            const O = this.outputs.map(P);
            for (const I of O)_ -= I.amount;
            return _;
        }
        // Signing
        // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624
        // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,
        // but we are trying to be less complicated for audit purpose for now.
        preimageLegacy(_, O, I) {
            const { isAny: x, isNone: R, isSingle: j } = $(I);
            if (_ < 0 || !Number.isSafeInteger(_)) throw new Error(`Invalid input idx=${_}`);
            if (j && _ >= this.outputs.length || _ >= this.inputs.length) return r.U256BE.encode(1n);
            O = o.Script.encode(o.Script.decode(O).filter((G)=>G !== "CODESEPARATOR"));
            let Y = this.inputs.map(M).map((G, se)=>({
                    ...G,
                    finalScriptSig: se === _ ? O : r.EMPTY
                }));
            x ? Y = [
                Y[_]
            ] : (R || j) && (Y = Y.map((G, se)=>({
                    ...G,
                    sequence: se === _ ? G.sequence : 0
                })));
            let he = this.outputs.map(P);
            R ? he = [] : j && (he = he.slice(0, _).fill(l).concat([
                he[_]
            ]));
            const ue = o.RawTx.encode({
                lockTime: this.lockTime,
                version: this.version,
                segwitFlag: !1,
                inputs: Y,
                outputs: he
            });
            return a.sha256x2(ue, r.I32LE.encode(I));
        }
        preimageWitnessV0(_, O, I, x) {
            const { isAny: R, isNone: j, isSingle: Y } = $(I);
            let he = c, ue = c, G = c;
            const se = this.inputs.map(M), Z = this.outputs.map(P);
            R || (he = a.sha256x2(...se.map(z.encode))), !R && !Y && !j && (ue = a.sha256x2(...se.map((pe)=>r.U32LE.encode(pe.sequence)))), !Y && !j ? G = a.sha256x2(...Z.map(o.RawOutput.encode)) : Y && _ < Z.length && (G = a.sha256x2(o.RawOutput.encode(Z[_])));
            const ie = se[_];
            return a.sha256x2(r.I32LE.encode(this.version), he, ue, r.bytes(32, !0).encode(ie.txid), r.U32LE.encode(ie.index), o.VarBytes.encode(O), r.U64LE.encode(x), r.U32LE.encode(ie.sequence), G, r.U32LE.encode(this.lockTime), r.U32LE.encode(I));
        }
        preimageWitnessV1(_, O, I, x, R = -1, j, Y = 192, he) {
            if (!Array.isArray(x) || this.inputs.length !== x.length) throw new Error(`Invalid amounts array=${x}`);
            if (!Array.isArray(O) || this.inputs.length !== O.length) throw new Error(`Invalid prevOutScript array=${O}`);
            const ue = [
                r.U8.encode(0),
                r.U8.encode(I),
                // U8 sigHash
                r.I32LE.encode(this.version),
                r.U32LE.encode(this.lockTime)
            ], G = I === y.DEFAULT ? y.ALL : I & 3, se = I & y.ANYONECANPAY, Z = this.inputs.map(M), ie = this.outputs.map(P);
            se !== y.ANYONECANPAY && ue.push(...[
                Z.map(z.encode),
                x.map(r.U64LE.encode),
                O.map(o.VarBytes.encode),
                Z.map((ve)=>r.U32LE.encode(ve.sequence))
            ].map((ve)=>a.sha256((0, s.concatBytes)(...ve)))), G === y.ALL && ue.push(a.sha256((0, s.concatBytes)(...ie.map(o.RawOutput.encode))));
            const pe = (he ? 1 : 0) | (j ? 2 : 0);
            if (ue.push(new Uint8Array([
                pe
            ])), se === y.ANYONECANPAY) {
                const ve = Z[_];
                ue.push(z.encode(ve), r.U64LE.encode(x[_]), o.VarBytes.encode(O[_]), r.U32LE.encode(ve.sequence));
            } else ue.push(r.U32LE.encode(_));
            return pe & 1 && ue.push(a.sha256(o.VarBytes.encode(he || r.EMPTY))), G === y.SINGLE && ue.push(_ < ie.length ? a.sha256(o.RawOutput.encode(ie[_])) : c), j && ue.push((0, n.tapLeafHash)(j, Y), r.U8.encode(0), r.I32LE.encode(R)), a.tagSchnorr("TapSighash", ...ue);
        }
        // Signer can be privateKey OR instance of bip32 HD stuff
        signIdx(_, O, I, x) {
            this.checkInputIdx(O);
            const R = this.inputs[O], j = Q(R, this.opts.allowLegacyWitnessUtxo);
            if (!(0, s.isBytes)(_)) {
                if (!R.bip32Derivation || !R.bip32Derivation.length) throw new Error("bip32Derivation: empty");
                const G = R.bip32Derivation.filter((Z)=>Z[1].fingerprint == _.fingerprint).map(([Z, { path: ie }])=>{
                    let pe = _;
                    for (const ve of ie)pe = pe.deriveChild(ve);
                    if (!(0, s.equalBytes)(pe.publicKey, Z)) throw new Error("bip32Derivation: wrong pubKey");
                    if (!pe.privateKey) throw new Error("bip32Derivation: no privateKey");
                    return pe;
                });
                if (!G.length) throw new Error(`bip32Derivation: no items with fingerprint=${_.fingerprint}`);
                let se = !1;
                for (const Z of G)this.signIdx(Z.privateKey, O) && (se = !0);
                return se;
            }
            I ? I.forEach(K) : I = [
                j.defaultSighash
            ];
            const Y = j.sighash;
            if (!I.includes(Y)) throw new Error(`Input with not allowed sigHash=${Y}. Allowed: ${I.join(", ")}`);
            const { sigOutputs: he } = this.inputSighash(O);
            if (he === y.SINGLE && O >= this.outputs.length) throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${O}`);
            const ue = q(R);
            if (j.txType === "taproot") {
                const G = this.inputs.map(q), se = G.map((Ie)=>Ie.script), Z = G.map((Ie)=>Ie.amount);
                let ie = !1, pe = a.pubSchnorr(_), ve = R.tapMerkleRoot || r.EMPTY;
                if (R.tapInternalKey) {
                    const { pubKey: Ie, privKey: Me } = k(_, pe, R.tapInternalKey, ve), [Re, C] = a.taprootTweakPubkey(R.tapInternalKey, ve);
                    if ((0, s.equalBytes)(Re, Ie)) {
                        const J = this.preimageWitnessV1(O, se, Y, Z), me = (0, s.concatBytes)(a.signSchnorr(J, Me, x), Y !== y.DEFAULT ? new Uint8Array([
                            Y
                        ]) : r.EMPTY);
                        this.updateInput(O, {
                            tapKeySig: me
                        }, !0), ie = !0;
                    }
                }
                if (R.tapLeafScript) {
                    R.tapScriptSig = R.tapScriptSig || [];
                    for (const [Ie, Me] of R.tapLeafScript){
                        const Re = Me.subarray(0, -1), C = o.Script.decode(Re), J = Me[Me.length - 1], me = (0, n.tapLeafHash)(Re, J);
                        if (C.findIndex((nt)=>(0, s.isBytes)(nt) && (0, s.equalBytes)(nt, pe)) === -1) continue;
                        const je = this.preimageWitnessV1(O, se, Y, Z, void 0, Re, J), Ve = (0, s.concatBytes)(a.signSchnorr(je, _, x), Y !== y.DEFAULT ? new Uint8Array([
                            Y
                        ]) : r.EMPTY);
                        this.updateInput(O, {
                            tapScriptSig: [
                                [
                                    {
                                        pubKey: pe,
                                        leafHash: me
                                    },
                                    Ve
                                ]
                            ]
                        }, !0), ie = !0;
                    }
                }
                if (!ie) throw new Error("No taproot scripts signed");
                return !0;
            } else {
                const G = a.pubECDSA(_);
                let se = !1;
                const Z = a.hash160(G);
                for (const ve of o.Script.decode(j.lastScript))(0, s.isBytes)(ve) && ((0, s.equalBytes)(ve, G) || (0, s.equalBytes)(ve, Z)) && (se = !0);
                if (!se) throw new Error(`Input script doesn't have pubKey: ${j.lastScript}`);
                let ie;
                if (j.txType === "legacy") ie = this.preimageLegacy(O, j.lastScript, Y);
                else if (j.txType === "segwit") {
                    let ve = j.lastScript;
                    j.last.type === "wpkh" && (ve = n.OutScript.encode({
                        type: "pkh",
                        hash: j.last.hash
                    })), ie = this.preimageWitnessV0(O, ve, Y, ue.amount);
                } else throw new Error(`Transaction/sign: unknown tx type: ${j.txType}`);
                const pe = a.signECDSA(ie, _, this.opts.lowR);
                this.updateInput(O, {
                    partialSig: [
                        [
                            G,
                            (0, s.concatBytes)(pe, new Uint8Array([
                                Y
                            ]))
                        ]
                    ]
                }, !0);
            }
            return !0;
        }
        // This is bad API. Will work if user creates and signs tx, but if
        // there is some complex workflow with exchanging PSBT and signing them,
        // then it is better to validate which output user signs. How could a better API look like?
        // Example: user adds input, sends to another party, then signs received input (mixer etc),
        // another user can add different input for same key and user will sign it.
        // Even worse: another user can add bip32 derivation, and spend money from different address.
        // Better api: signIdx
        sign(_, O, I) {
            let x = 0;
            for(let R = 0; R < this.inputs.length; R++)try {
                this.signIdx(_, R, O, I) && x++;
            } catch  {}
            if (!x) throw new Error("No inputs signed");
            return x;
        }
        finalizeIdx(_) {
            if (this.checkInputIdx(_), this.fee < 0n) throw new Error("Outputs spends more than inputs amount");
            const O = this.inputs[_], I = Q(O, this.opts.allowLegacyWitnessUtxo);
            if (I.txType === "taproot") {
                if (O.tapKeySig) O.finalScriptWitness = [
                    O.tapKeySig
                ];
                else if (O.tapLeafScript && O.tapScriptSig) {
                    const he = O.tapLeafScript.sort((ue, G)=>i1.TaprootControlBlock.encode(ue[0]).length - i1.TaprootControlBlock.encode(G[0]).length);
                    for (const [ue, G] of he){
                        const se = G.slice(0, -1), Z = G[G.length - 1], ie = n.OutScript.decode(se), pe = (0, n.tapLeafHash)(se, Z), ve = O.tapScriptSig.filter((Me)=>(0, s.equalBytes)(Me[0].leafHash, pe));
                        let Ie = [];
                        if (ie.type === "tr_ms") {
                            const Me = ie.m, Re = ie.pubkeys;
                            let C = 0;
                            for (const J of Re){
                                const me = ve.findIndex((je)=>(0, s.equalBytes)(je[0].pubKey, J));
                                if (C === Me || me === -1) {
                                    Ie.push(r.EMPTY);
                                    continue;
                                }
                                Ie.push(ve[me][1]), C++;
                            }
                            if (C !== Me) continue;
                        } else if (ie.type === "tr_ns") {
                            for (const Me of ie.pubkeys){
                                const Re = ve.findIndex((C)=>(0, s.equalBytes)(C[0].pubKey, Me));
                                Re !== -1 && Ie.push(ve[Re][1]);
                            }
                            if (Ie.length !== ie.pubkeys.length) continue;
                        } else if (ie.type === "unknown" && this.opts.allowUnknownInputs) {
                            const Me = o.Script.decode(se);
                            if (Ie = ve.map(([{ pubKey: Re }, C])=>{
                                const J = Me.findIndex((me)=>(0, s.isBytes)(me) && (0, s.equalBytes)(me, Re));
                                if (J === -1) throw new Error("finalize/taproot: cannot find position of pubkey in script");
                                return {
                                    signature: C,
                                    pos: J
                                };
                            }).sort((Re, C)=>Re.pos - C.pos).map((Re)=>Re.signature), !Ie.length) continue;
                        } else {
                            const Me = this.opts.customScripts;
                            if (Me) for (const Re of Me){
                                if (!Re.finalizeTaproot) continue;
                                const C = o.Script.decode(se), J = Re.encode(C);
                                if (J === void 0) continue;
                                const me = Re.finalizeTaproot(se, J, ve);
                                if (me) {
                                    O.finalScriptWitness = me.concat(i1.TaprootControlBlock.encode(ue)), O.finalScriptSig = r.EMPTY, N(O);
                                    return;
                                }
                            }
                            throw new Error("Finalize: Unknown tapLeafScript");
                        }
                        O.finalScriptWitness = Ie.reverse().concat([
                            se,
                            i1.TaprootControlBlock.encode(ue)
                        ]);
                        break;
                    }
                    if (!O.finalScriptWitness) throw new Error("finalize/taproot: empty witness");
                } else throw new Error("finalize/taproot: unknown input");
                O.finalScriptSig = r.EMPTY, N(O);
                return;
            }
            if (!O.partialSig || !O.partialSig.length) throw new Error("Not enough partial sign");
            let x = r.EMPTY, R = [];
            if (I.last.type === "ms") {
                const he = I.last.m, ue = I.last.pubkeys;
                let G = [];
                for (const se of ue){
                    const Z = O.partialSig.find((ie)=>(0, s.equalBytes)(se, ie[0]));
                    Z && G.push(Z[1]);
                }
                if (G = G.slice(0, he), G.length !== he) throw new Error(`Multisig: wrong signatures count, m=${he} n=${ue.length} signatures=${G.length}`);
                x = o.Script.encode([
                    0,
                    ...G
                ]);
            } else if (I.last.type === "pk") x = o.Script.encode([
                O.partialSig[0][1]
            ]);
            else if (I.last.type === "pkh") x = o.Script.encode([
                O.partialSig[0][1],
                O.partialSig[0][0]
            ]);
            else if (I.last.type === "wpkh") x = r.EMPTY, R = [
                O.partialSig[0][1],
                O.partialSig[0][0]
            ];
            else if (I.last.type === "unknown" && !this.opts.allowUnknownInputs) throw new Error("Unknown inputs not allowed");
            let j, Y;
            if (I.type.includes("wsh-") && (x.length && I.lastScript.length && (R = o.Script.decode(x).map((he)=>{
                if (he === 0) return r.EMPTY;
                if ((0, s.isBytes)(he)) return he;
                throw new Error(`Wrong witness op=${he}`);
            })), R = R.concat(I.lastScript)), I.txType === "segwit" && (Y = R), I.type.startsWith("sh-wsh-") ? j = o.Script.encode([
                o.Script.encode([
                    0,
                    a.sha256(I.lastScript)
                ])
            ]) : I.type.startsWith("sh-") ? j = o.Script.encode([
                ...o.Script.decode(x),
                I.lastScript
            ]) : I.type.startsWith("wsh-") || I.txType !== "segwit" && (j = x), !j && !Y) throw new Error("Unknown error finalizing input");
            j && (O.finalScriptSig = j), Y && (O.finalScriptWitness = Y), N(O);
        }
        finalize() {
            for(let _ = 0; _ < this.inputs.length; _++)this.finalizeIdx(_);
        }
        extract() {
            if (!this.isFinal) throw new Error("Transaction has unfinalized inputs");
            if (!this.outputs.length) throw new Error("Transaction has no outputs");
            if (this.fee < 0n) throw new Error("Outputs spends more than inputs amount");
            return this.toBytes(!0, !0);
        }
        combine(_) {
            for (const x of [
                "PSBTVersion",
                "version",
                "lockTime"
            ])if (this.opts[x] !== _.opts[x]) throw new Error(`Transaction/combine: different ${x} this=${this.opts[x]} other=${_.opts[x]}`);
            for (const x of [
                "inputs",
                "outputs"
            ])if (this[x].length !== _[x].length) throw new Error(`Transaction/combine: different ${x} length this=${this[x].length} other=${_[x].length}`);
            const O = this.global.unsignedTx ? o.RawOldTx.encode(this.global.unsignedTx) : r.EMPTY, I = _.global.unsignedTx ? o.RawOldTx.encode(_.global.unsignedTx) : r.EMPTY;
            if (!(0, s.equalBytes)(O, I)) throw new Error("Transaction/combine: different unsigned tx");
            this.global = i1.mergeKeyMap(i1.PSBTGlobal, this.global, _.global, void 0, this.opts.allowUnknown);
            for(let x = 0; x < this.inputs.length; x++)this.updateInput(x, _.inputs[x], !0);
            for(let x = 0; x < this.outputs.length; x++)this.updateOutput(x, _.outputs[x], !0);
            return this;
        }
        clone() {
            return v.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
        }
    }
    e.Transaction = v;
    function B(w) {
        if (!w || !Array.isArray(w) || !w.length) throw new Error("PSBTCombine: wrong PSBT list");
        const _ = v.fromPSBT(w[0]);
        for(let O = 1; O < w.length; O++)_.combine(v.fromPSBT(w[O]));
        return _.toPSBT();
    }
    const g = 2147483648;
    function E(w) {
        const _ = [];
        if (!/^[mM]'?/.test(w)) throw new Error('Path must start with "m" or "M"');
        if (/^[mM]'?$/.test(w)) return _;
        const O = w.replace(/^[mM]'?\//, "").split("/");
        for (const I of O){
            const x = /^(\d+)('?)$/.exec(I);
            if (!x || x.length !== 3) throw new Error(`Invalid child index: ${I}`);
            let R = +x[1];
            if (!Number.isSafeInteger(R) || R >= g) throw new Error("Invalid index");
            x[2] === "'" && (R += g), _.push(R);
        }
        return _;
    }
})(Dm);
var l4 = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._Estimator = e._cmpBig = void 0, e.selectUTXO = S;
    const t = Xh, r = Ff, n = _0, i1 = R1, o = Yh, a = Dm, s = Gs, c = (k)=>i1.TaprootControlBlock.encode(k);
    function l(k, P, M) {
        if (!k || !k.length) throw new Error("no leafs");
        const N = ()=>new Uint8Array(P), z = k.sort((K, $)=>c(K[0]).length - c($[0]).length);
        for (const [K, $] of z){
            const ne = $.slice(0, -1), ee = $[$.length - 1], q = n.OutScript.decode(ne);
            let U = [];
            if (q.type === "tr_ms") {
                const Q = q.m, v = q.pubkeys.length - Q;
                for(let B = 0; B < Q; B++)U.push(N());
                for(let B = 0; B < v; B++)U.push(r.EMPTY);
            } else if (q.type === "tr_ns") for (const Q of q.pubkeys)U.push(N());
            else {
                if (!M) throw new Error("Finalize: Unknown tapLeafScript");
                const Q = (0, n.tapLeafHash)(ne, ee);
                for (const v of M){
                    if (!v.finalizeTaproot) continue;
                    const B = o.Script.decode(ne), g = v.encode(B);
                    if (g === void 0) continue;
                    const E = B.filter((_)=>{
                        if (!(0, s.isBytes)(_)) return !1;
                        try {
                            return (0, s.validatePubkey)(_, s.PubT.schnorr), !0;
                        } catch  {
                            return !1;
                        }
                    }), w = v.finalizeTaproot(ne, g, E.map((_)=>[
                            {
                                pubKey: _,
                                leafHash: Q
                            },
                            N()
                        ]));
                    if (w) return w.concat(c(K));
                }
            }
            return U.reverse().concat([
                ne,
                c(K)
            ]);
        }
        throw new Error("there was no witness");
    }
    function u(k, P, M) {
        let N = r.EMPTY, z;
        if (k.txType === "taproot") {
            const ne = k.sighash !== a.SignatureHash.DEFAULT ? 65 : 64;
            if (P.tapInternalKey && !(0, s.equalBytes)(P.tapInternalKey, s.TAPROOT_UNSPENDABLE_KEY)) z = [
                new Uint8Array(ne)
            ];
            else if (P.tapLeafScript) z = l(P.tapLeafScript, ne, M.customScripts);
            else throw new Error("estimateInput/taproot: unknown input");
        } else {
            const ne = ()=>new Uint8Array(72), ee = ()=>new Uint8Array(33);
            let q = r.EMPTY, U = [];
            const Q = k.last.type;
            if (Q === "ms") {
                const v = k.last.m, B = [
                    0
                ];
                for(let g = 0; g < v; g++)B.push(ne());
                q = o.Script.encode(B);
            } else if (Q === "pk") q = o.Script.encode([
                ne()
            ]);
            else if (Q === "pkh") q = o.Script.encode([
                ne(),
                ee()
            ]);
            else if (Q === "wpkh") q = r.EMPTY, U = [
                ne(),
                ee()
            ];
            else if (Q === "unknown" && !M.allowUnknownInputs) throw new Error("Unknown inputs are not allowed");
            k.type.includes("wsh-") && (q.length && k.lastScript.length && (U = o.Script.decode(q).map((v)=>{
                if (v === 0) return r.EMPTY;
                if ((0, s.isBytes)(v)) return v;
                throw new Error(`Wrong witness op=${v}`);
            })), U = U.concat(k.lastScript)), k.txType === "segwit" && (z = U), k.type.startsWith("sh-wsh-") ? N = o.Script.encode([
                o.Script.encode([
                    0,
                    new Uint8Array(s.sha256.outputLen)
                ])
            ]) : k.type.startsWith("sh-") ? N = o.Script.encode([
                ...o.Script.decode(q),
                k.lastScript
            ]) : k.type.startsWith("wsh-") || k.txType !== "segwit" && (N = q);
        }
        let K = 160 + 4 * o.VarBytes.encode(N).length, $ = !1;
        return z && (K += o.RawWitness.encode(z).length, $ = !0), {
            weight: K,
            hasWitnesses: $
        };
    }
    const f = (k, P)=>{
        const M = k - P;
        return M < 0n ? -1 : M > 0n ? 1 : 0;
    };
    e._cmpBig = f;
    function h(k, P = {}, M = s.NETWORK) {
        let N;
        if ("script" in k && (0, s.isBytes)(k.script) && (N = k.script), "address" in k) {
            if (typeof k.address != "string") throw new Error(`Estimator: wrong output address=${k.address}`);
            N = n.OutScript.encode((0, n.Address)(M).decode(k.address));
        }
        if (!N) throw new Error("Estimator: wrong output script");
        if (typeof k.amount != "bigint") throw new Error(`Estimator: wrong output amount=${k.amount}, should be of type bigint but got ${typeof k.amount}.`);
        if (N && !P.allowUnknownOutputs && n.OutScript.decode(N).type === "unknown") throw new Error("Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure");
        return P.disableScriptCheck || (0, n.checkScript)(N), N;
    }
    class y {
        constructor(P, M, N){
            if (this.requiredIndices = [], this.outputs = M, this.opts = N, typeof N.feePerByte != "bigint") throw new Error(`Estimator: wrong feePerByte=${N.feePerByte}, should be of type bigint but got ${typeof N.feePerByte}.`);
            const z = N.dust === void 0 ? BigInt(182) : N.dust;
            if (typeof z != "bigint") throw new Error(`Estimator: wrong dust=${N.dust}, should be of type bigint but got ${typeof N.dust}.`);
            const K = N.dustRelayFeeRate === void 0 ? 3n : N.dustRelayFeeRate;
            if (typeof K != "bigint") throw new Error(`Estimator: wrong dustRelayFeeRate=${N.dustRelayFeeRate}, should be of type bigint but got ${typeof N.dustRelayFeeRate}.`);
            if (this.dust = z * K, N.requiredInputs !== void 0 && !Array.isArray(N.requiredInputs)) throw new Error(`Estimator: wrong required inputs=${N.requiredInputs}`);
            const $ = N.network || s.NETWORK;
            let ne = 0n, ee = 32;
            for (const v of M){
                const B = h(v, N, N.network);
                ee += 32 + 4 * o.VarBytes.encode(B).length, ne += v.amount;
            }
            if (typeof N.changeAddress != "string") throw new Error(`Estimator: wrong change address=${N.changeAddress}`);
            let q = ee + 32 + 4 * o.VarBytes.encode(n.OutScript.encode((0, n.Address)($).decode(N.changeAddress))).length;
            ee += 4 * o.CompactSizeLen.encode(M.length).length, q += 4 * o.CompactSizeLen.encode(M.length + 1).length, this.baseWeight = ee, this.changeWeight = q, this.amount = ne;
            const U = Array.from(P);
            if (N.requiredInputs) for(let v = 0; v < N.requiredInputs.length; v++)this.requiredIndices.push(U.push(N.requiredInputs[v]) - 1);
            const Q = /* @__PURE__ */ new Set();
            this.normalizedInputs = U.map((v)=>{
                const B = (0, a.normalizeInput)(v, void 0, void 0, N.disableScriptCheck, N.allowUnknown);
                (0, a.inputBeforeSign)(B);
                const g = `${t.hex.encode(B.txid)}:${B.index}`;
                if (!N.allowSameUtxo && Q.has(g)) throw new Error(`Estimator: same input passed multiple times: ${g}`);
                Q.add(g);
                const E = (0, a.getInputType)(B, N.allowLegacyWitnessUtxo), w = (0, a.getPrevOut)(B), _ = u(E, B, this.opts), O = w.amount - N.feePerByte * BigInt((0, a.toVsize)(_.weight));
                return {
                    inputType: E,
                    normalized: B,
                    amount: w.amount,
                    value: O,
                    estimate: _
                };
            });
        }
        checkInputIdx(P) {
            if (!Number.isSafeInteger(P) || 0 > P || P >= this.normalizedInputs.length) throw new Error(`Wrong input index=${P}`);
            return P;
        }
        sortIndices(P) {
            return P.slice().sort((M, N)=>{
                const z = this.normalizedInputs[this.checkInputIdx(M)], K = this.normalizedInputs[this.checkInputIdx(N)], $ = (0, s.compareBytes)(z.normalized.txid, K.normalized.txid);
                return $ !== 0 ? $ : z.normalized.index - K.normalized.index;
            });
        }
        sortOutputs(P) {
            const M = P.map((N)=>h(N, this.opts, this.opts.network));
            return P.map((N, z)=>z).sort((N, z)=>{
                const K = P[N].amount, $ = P[z].amount, ne = (0, e._cmpBig)(K, $);
                return ne !== 0 ? ne : (0, s.compareBytes)(M[N], M[z]);
            });
        }
        getSatoshi(P) {
            return this.opts.feePerByte * BigInt((0, a.toVsize)(P));
        }
        // Sort by value instead of amount
        get biggest() {
            return this.normalizedInputs.map((P, M)=>M).sort((P, M)=>(0, e._cmpBig)(this.normalizedInputs[M].value, this.normalizedInputs[P].value));
        }
        get smallest() {
            return this.biggest.reverse();
        }
        // These assume that UTXO array has historical order.
        // Otherwise, we have no way to know which tx is oldest
        // Explorers usually give UTXO in this order.
        get oldest() {
            return this.normalizedInputs.map((P, M)=>M);
        }
        get newest() {
            return this.oldest.reverse();
        }
        // exact - like blackjack from coinselect.
        // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.
        // If not, it will accumulate largest utxo until value is close to targetValue+dust.
        accumulate(P, M = !1, N = !0, z = !1) {
            let K = this.opts.alwaysChange ? this.changeWeight : this.baseWeight, $ = !1, ne = 0, ee = 0n;
            const q = this.amount, U = /* @__PURE__ */ new Set();
            let Q;
            for (const v of this.requiredIndices){
                if (this.checkInputIdx(v), U.has(v)) throw new Error("required input encountered multiple times");
                const { estimate: B, amount: g } = this.normalizedInputs[v];
                let E = K + B.weight;
                !$ && B.hasWitnesses && (E += 2);
                const w = E + 4 * o.CompactSizeLen.encode(ne).length;
                if (Q = this.getSatoshi(w), K = E, B.hasWitnesses && ($ = !0), ne++, ee += g, U.add(v), !z && q + Q <= ee && ne >= this.requiredIndices.length) return {
                    indices: Array.from(U),
                    fee: Q,
                    weight: w,
                    total: ee
                };
            }
            for (const v of P){
                if (this.checkInputIdx(v), U.has(v)) continue;
                const { estimate: B, amount: g, value: E } = this.normalizedInputs[v];
                let w = K + B.weight;
                !$ && B.hasWitnesses && (w += 2);
                const _ = w + 4 * o.CompactSizeLen.encode(ne).length;
                if (Q = this.getSatoshi(_), !(M && g + ee > q + Q + this.dust) && !(N && E <= 0n) && (K = w, B.hasWitnesses && ($ = !0), ne++, ee += g, U.add(v), !z && q + Q <= ee)) return {
                    indices: Array.from(U),
                    fee: Q,
                    weight: _,
                    total: ee
                };
            }
            if (z) {
                const v = K + 4 * o.CompactSizeLen.encode(ne).length;
                return {
                    indices: Array.from(U),
                    fee: Q,
                    weight: v,
                    total: ee
                };
            }
        }
        // Works like coinselect default method
        default() {
            const { biggest: P } = this;
            return this.accumulate(P, !0, !1) || this.accumulate(P);
        }
        select(P) {
            if (P === "all") return this.accumulate(this.normalizedInputs.map((N, z)=>z), !1, !0, !0);
            if (P === "default") return this.default();
            const M = {
                Oldest: ()=>this.oldest,
                Newest: ()=>this.newest,
                Smallest: ()=>this.smallest,
                Biggest: ()=>this.biggest
            };
            if (P.startsWith("exact")) {
                const [N, z] = P.slice(5).split("/");
                if (!M[N]) throw new Error(`Estimator.select: wrong strategy=${P}`);
                P = z;
                const K = this.accumulate(M[N](), !0, !0);
                if (K) return K;
            }
            if (P.startsWith("accum")) {
                const N = P.slice(5);
                if (!M[N]) throw new Error(`Estimator.select: wrong strategy=${P}`);
                return this.accumulate(M[N]());
            }
            throw new Error(`Estimator.select: wrong strategy=${P}`);
        }
        result(P) {
            const M = this.select(P);
            if (!M) return;
            const { indices: N, weight: z, total: K } = M;
            let $ = this.opts.alwaysChange;
            const ne = this.opts.alwaysChange ? z : z + (this.changeWeight - this.baseWeight), ee = this.getSatoshi(ne);
            let q = M.fee;
            const U = K - this.amount - ee;
            U > this.dust && ($ = !0);
            let Q = N, v = Array.from(this.outputs);
            if ($) {
                if (q = ee, U < 0n) throw new Error(`Estimator.result: negative change=${U}`);
                v.push({
                    address: this.opts.changeAddress,
                    amount: U
                });
            }
            this.opts.bip69 && (Q = this.sortIndices(Q), v = this.sortOutputs(v).map((E)=>v[E]));
            const B = {
                inputs: Q.map((E)=>this.normalizedInputs[E].normalized),
                outputs: v,
                fee: q,
                weight: this.opts.alwaysChange ? M.weight : ne,
                change: !!$
            };
            let g;
            if (this.opts.createTx) {
                const { inputs: E, outputs: w } = B;
                g = new a.Transaction(this.opts);
                for (const _ of E)g.addInput(_);
                for (const _ of w)g.addOutput({
                    ..._,
                    script: h(_, this.opts, this.opts.network)
                });
            }
            return Object.assign(B, {
                tx: g
            });
        }
    }
    e._Estimator = y;
    function S(k, P, M, N) {
        const z = {
            createTx: !0,
            bip69: !0,
            ...N
        };
        return new y(k, P, z).result(M);
    }
})(l4);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e._Estimator = e._cmpBig = e.SigHash = e.PSBTCombine = e.DEFAULT_SEQUENCE = e.Decimal = e.bip32Path = e.TaprootControlBlock = e._DebugPSBT = e.WIF = e.taprootListToTree = e.sortedMultisig = e.OutScript = e.getAddress = e.combinations = e.Address = e._sortPubkeys = e.utils = e.selectUTXO = e.TEST_NETWORK = e.TAPROOT_UNSPENDABLE_KEY = e.NETWORK = e.Transaction = e.getInputType = e.ScriptNum = e.Script = e.RawWitness = e.RawTx = e.OP = e.MAX_SCRIPT_BYTE_LENGTH = e.CompactSize = e.p2wsh = e.p2wpkh = e.p2tr_pk = e.p2tr_ns = e.p2tr_ms = e.p2tr = e.p2sh = e.p2pkh = e.p2pk = e.p2ms = e.multisig = void 0;
    /*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const t = Gs;
    var r = _0;
    Object.defineProperty(e, "multisig", {
        enumerable: !0,
        get: function() {
            return r.multisig;
        }
    }), Object.defineProperty(e, "p2ms", {
        enumerable: !0,
        get: function() {
            return r.p2ms;
        }
    }), Object.defineProperty(e, "p2pk", {
        enumerable: !0,
        get: function() {
            return r.p2pk;
        }
    }), Object.defineProperty(e, "p2pkh", {
        enumerable: !0,
        get: function() {
            return r.p2pkh;
        }
    }), Object.defineProperty(e, "p2sh", {
        enumerable: !0,
        get: function() {
            return r.p2sh;
        }
    }), Object.defineProperty(e, "p2tr", {
        enumerable: !0,
        get: function() {
            return r.p2tr;
        }
    }), Object.defineProperty(e, "p2tr_ms", {
        enumerable: !0,
        get: function() {
            return r.p2tr_ms;
        }
    }), Object.defineProperty(e, "p2tr_ns", {
        enumerable: !0,
        get: function() {
            return r.p2tr_ns;
        }
    }), Object.defineProperty(e, "p2tr_pk", {
        enumerable: !0,
        get: function() {
            return r.p2tr_pk;
        }
    }), Object.defineProperty(e, "p2wpkh", {
        enumerable: !0,
        get: function() {
            return r.p2wpkh;
        }
    }), Object.defineProperty(e, "p2wsh", {
        enumerable: !0,
        get: function() {
            return r.p2wsh;
        }
    });
    var n = Yh;
    Object.defineProperty(e, "CompactSize", {
        enumerable: !0,
        get: function() {
            return n.CompactSize;
        }
    }), Object.defineProperty(e, "MAX_SCRIPT_BYTE_LENGTH", {
        enumerable: !0,
        get: function() {
            return n.MAX_SCRIPT_BYTE_LENGTH;
        }
    }), Object.defineProperty(e, "OP", {
        enumerable: !0,
        get: function() {
            return n.OP;
        }
    }), Object.defineProperty(e, "RawTx", {
        enumerable: !0,
        get: function() {
            return n.RawTx;
        }
    }), Object.defineProperty(e, "RawWitness", {
        enumerable: !0,
        get: function() {
            return n.RawWitness;
        }
    }), Object.defineProperty(e, "Script", {
        enumerable: !0,
        get: function() {
            return n.Script;
        }
    }), Object.defineProperty(e, "ScriptNum", {
        enumerable: !0,
        get: function() {
            return n.ScriptNum;
        }
    });
    var i1 = Dm;
    Object.defineProperty(e, "getInputType", {
        enumerable: !0,
        get: function() {
            return i1.getInputType;
        }
    }), Object.defineProperty(e, "Transaction", {
        enumerable: !0,
        get: function() {
            return i1.Transaction;
        }
    });
    var o = Gs;
    Object.defineProperty(e, "NETWORK", {
        enumerable: !0,
        get: function() {
            return o.NETWORK;
        }
    }), Object.defineProperty(e, "TAPROOT_UNSPENDABLE_KEY", {
        enumerable: !0,
        get: function() {
            return o.TAPROOT_UNSPENDABLE_KEY;
        }
    }), Object.defineProperty(e, "TEST_NETWORK", {
        enumerable: !0,
        get: function() {
            return o.TEST_NETWORK;
        }
    });
    var a = l4;
    Object.defineProperty(e, "selectUTXO", {
        enumerable: !0,
        get: function() {
            return a.selectUTXO;
        }
    }), e.utils = {
        isBytes: t.isBytes,
        concatBytes: t.concatBytes,
        compareBytes: t.compareBytes,
        pubSchnorr: t.pubSchnorr,
        randomPrivateKeyBytes: t.randomPrivateKeyBytes,
        taprootTweakPubkey: t.taprootTweakPubkey
    };
    var s = _0;
    Object.defineProperty(e, "_sortPubkeys", {
        enumerable: !0,
        get: function() {
            return s._sortPubkeys;
        }
    }), Object.defineProperty(e, "Address", {
        enumerable: !0,
        get: function() {
            return s.Address;
        }
    }), Object.defineProperty(e, "combinations", {
        enumerable: !0,
        get: function() {
            return s.combinations;
        }
    }), Object.defineProperty(e, "getAddress", {
        enumerable: !0,
        get: function() {
            return s.getAddress;
        }
    }), Object.defineProperty(e, "OutScript", {
        enumerable: !0,
        get: function() {
            return s.OutScript;
        }
    }), Object.defineProperty(e, "sortedMultisig", {
        enumerable: !0,
        get: function() {
            return s.sortedMultisig;
        }
    }), Object.defineProperty(e, "taprootListToTree", {
        enumerable: !0,
        get: function() {
            return s.taprootListToTree;
        }
    }), Object.defineProperty(e, "WIF", {
        enumerable: !0,
        get: function() {
            return s.WIF;
        }
    });
    var c = R1;
    Object.defineProperty(e, "_DebugPSBT", {
        enumerable: !0,
        get: function() {
            return c._DebugPSBT;
        }
    }), Object.defineProperty(e, "TaprootControlBlock", {
        enumerable: !0,
        get: function() {
            return c.TaprootControlBlock;
        }
    });
    var l = Dm;
    Object.defineProperty(e, "bip32Path", {
        enumerable: !0,
        get: function() {
            return l.bip32Path;
        }
    }), Object.defineProperty(e, "Decimal", {
        enumerable: !0,
        get: function() {
            return l.Decimal;
        }
    }), Object.defineProperty(e, "DEFAULT_SEQUENCE", {
        enumerable: !0,
        get: function() {
            return l.DEFAULT_SEQUENCE;
        }
    }), Object.defineProperty(e, "PSBTCombine", {
        enumerable: !0,
        get: function() {
            return l.PSBTCombine;
        }
    }), Object.defineProperty(e, "SigHash", {
        enumerable: !0,
        get: function() {
            return l.SigHash;
        }
    });
    var u = l4;
    Object.defineProperty(e, "_cmpBig", {
        enumerable: !0,
        get: function() {
            return u._cmpBig;
        }
    }), Object.defineProperty(e, "_Estimator", {
        enumerable: !0,
        get: function() {
            return u._Estimator;
        }
    });
})(N5);
var kb = {}, xle = Qe && Qe.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i1 = Object.getOwnPropertyDescriptor(t, r);
    (!i1 || ("get" in i1 ? !t.__esModule : i1.writable || i1.configurable)) && (i1 = {
        enumerable: !0,
        get: function() {
            return t[r];
        }
    }), Object.defineProperty(e, n, i1);
} : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
}), _le = Qe && Qe.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    });
} : function(e, t) {
    e.default = t;
}), kle = Qe && Qe.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for(var r in e)r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && xle(t, e, r);
    return _le(t, e), t;
};
Object.defineProperty(kb, "__esModule", {
    value: !0
});
kb.CBOR = void 0;
const Or = kle(M5), Ay = N5, R5 = (e)=>e === 0 && 1 / e < 0, dI = Or.wrap({
    encodeStream (e, t) {
        if (t === 1 / 0) return e.bytes(new Uint8Array([
            124,
            0
        ]));
        if (t === -1 / 0) return e.bytes(new Uint8Array([
            252,
            0
        ]));
        if (Number.isNaN(t)) return e.bytes(new Uint8Array([
            126,
            0
        ]));
        if (R5(t)) return e.bytes(new Uint8Array([
            128,
            0
        ]));
        throw e.err("f16: not implemented");
    },
    decodeStream: (e)=>{
        const t = Or.U16BE.decodeStream(e), r = (t & 31744) >> 10, n = t & 1023;
        let i1;
        return r === 0 ? i1 = 6103515625e-14 * (n / 1024) : r !== 31 ? i1 = Math.pow(2, r - 15) * (1 + n / 1024) : i1 = n ? NaN : 1 / 0, t & 32768 ? -i1 : i1;
    }
}), xi = Or.bits(5), Ole = Or.apply(Or.U64BE, Or.coders.numberBigint), Cu = {
    24: [
        2 ** 8 - 1,
        Or.U8,
        Or.U8
    ],
    25: [
        2 ** 16 - 1,
        Or.U16BE,
        Or.U16BE
    ],
    26: [
        2 ** 32 - 1,
        Or.U32BE,
        Or.U32BE
    ],
    27: [
        2n ** 64n - 1n,
        Or.U64BE,
        Ole
    ]
}, jm = Or.wrap({
    encodeStream (e, t) {
        if (t < 24) return xi.encodeStream(e, typeof t == "bigint" ? Number(t) : t);
        for(const r in Cu){
            const [n, i1, o] = Cu[r];
            if (!(t > n)) return xi.encodeStream(e, Number(r)), i1.encodeStream(e, t);
        }
        throw e.err(`cbor/uint: wrong value=${t}`);
    },
    decodeStream (e) {
        const t = xi.decodeStream(e);
        if (t < 24) return t;
        const r = Cu[t][1];
        if (!r) throw e.err(`cbor/uint wrong additional information=${t}`);
        return r.decodeStream(e);
    }
}), Ile = Or.wrap({
    encodeStream: (e, t)=>jm.encodeStream(e, typeof t == "bigint" ? -(t + 1n) : -(t + 1)),
    decodeStream (e) {
        const t = jm.decodeStream(e);
        return typeof t == "bigint" ? -1n - t : -1 - t;
    }
}), hI = (e)=>Or.wrap({
        encodeStream (t, r) {
            if (r.length < 24) {
                xi.encodeStream(t, r.length), Or.array(r.length, e).encodeStream(t, r);
                return;
            }
            for(const n in Cu){
                const [i1, o, a] = Cu[n];
                if (r.length < i1) {
                    xi.encodeStream(t, Number(n)), Or.array(a, e).encodeStream(t, r);
                    return;
                }
            }
            throw t.err(`cbor/lengthArray: wrong value=${r}`);
        },
        decodeStream (t) {
            const r = xi.decodeStream(t);
            if (r < 24) return Or.array(r, e).decodeStream(t);
            if (r === 31) return Or.array(new Uint8Array([
                255
            ]), e).decodeStream(t);
            const n = Cu[r][2];
            if (!n) throw t.err(`cbor/lengthArray wrong length=${r}`);
            return Or.array(n, e).decodeStream(t);
        }
    }), pI = (e, t)=>Or.wrap({
        encodeStream (r, n) {
            if (Array.isArray(n)) throw new Error("cbor/length: encoding indefinite-length strings not supported");
            const i1 = e(null).encode(n);
            if (i1.length < 24) {
                xi.encodeStream(r, i1.length), r.bytes(i1);
                return;
            }
            for(const o in Cu){
                const [a, s, c] = Cu[o];
                if (i1.length < a) {
                    xi.encodeStream(r, Number(o)), c.encodeStream(r, i1.length), r.bytes(i1);
                    return;
                }
            }
            throw r.err(`cbor/lengthArray: wrong value=${n}`);
        },
        decodeStream (r) {
            const n = xi.decodeStream(r);
            if (n < 24) return e(n).decodeStream(r);
            if (n === 31) return Or.array(new Uint8Array([
                255
            ]), t).decodeStream(r);
            const i1 = Cu[n][2];
            if (!i1) throw r.err(`cbor/length wrong length=${n}`);
            return e(i1).decodeStream(r);
        }
    }), Ble = Or.wrap({
    encodeStream (e, t) {
        if (t === !1) return xi.encodeStream(e, 20);
        if (t === !0) return xi.encodeStream(e, 21);
        if (t === null) return xi.encodeStream(e, 22);
        if (t === void 0) return xi.encodeStream(e, 23);
        if (typeof t != "number") throw e.err(`cbor/simple: wrong value type=${typeof t}`);
        return R5(t) || Number.isNaN(t) || t === 1 / 0 || t === -1 / 0 ? (xi.encodeStream(e, 25), dI.encodeStream(e, t)) : Math.fround(t) === t ? (xi.encodeStream(e, 26), Or.F32BE.encodeStream(e, t)) : (xi.encodeStream(e, 27), Or.F64BE.encodeStream(e, t));
    },
    decodeStream (e) {
        const t = xi.decodeStream(e);
        if (t === 20) return !1;
        if (t === 21) return !0;
        if (t === 22) return null;
        if (t !== 23) {
            if (t === 25) return dI.decodeStream(e);
            if (t === 26) return Or.F32BE.decodeStream(e);
            if (t === 27) return Or.F64BE.decodeStream(e);
            throw e.err("cbor/simple: unassigned");
        }
    }
}), Pl = Or.mappedTag(Or.bits(3), {
    uint: [
        0,
        jm
    ],
    // An unsigned integer in the range 0..264-1 inclusive.
    negint: [
        1,
        Ile
    ],
    // A negative integer in the range -264..-1 inclusive
    bytes: [
        2,
        Or.lazy(()=>pI(Or.bytes, Pl))
    ],
    // A byte string.
    string: [
        3,
        Or.lazy(()=>pI(Or.string, Pl))
    ],
    // A text string (utf8)
    array: [
        4,
        hI(Or.lazy(()=>Pl))
    ],
    // An array of data items
    map: [
        5,
        Or.lazy(()=>hI(Or.tuple([
                Pl,
                Pl
            ])))
    ],
    // A map of pairs of data items
    tag: [
        6,
        Or.tuple([
            jm,
            Or.lazy(()=>Pl)
        ])
    ],
    // A tagged data item ("tag") whose tag number
    simple: [
        7,
        Ble
    ]
});
kb.CBOR = Or.apply(Pl, {
    encode (e) {
        let t = e.data;
        if (e.TAG === "bytes") {
            if (Ay.utils.isBytes(t)) return t;
            const r = [];
            if (!Array.isArray(t)) throw new Error(`CBOR: wrong indefinite-length bytestring=${t}`);
            for (const n of t){
                if (n.TAG !== "bytes" || !Ay.utils.isBytes(n.data)) throw new Error(`CBOR: wrong indefinite-length bytestring=${n}`);
                r.push(n.data);
            }
            return Ay.utils.concatBytes(...r);
        }
        if (e.TAG === "string") {
            if (typeof t == "string") return t;
            if (!Array.isArray(t)) throw new Error(`CBOR: wrong indefinite-length string=${t}`);
            let r = "";
            for (const n of t){
                if (n.TAG !== "string" || typeof n.data != "string") throw new Error(`CBOR: wrong indefinite-length string=${n}`);
                r += n.data;
            }
            return r;
        }
        if (e.TAG === "array" && Array.isArray(t) && (t = t.map((r)=>this.encode(r))), e.TAG === "map" && typeof t == "object" && t !== null) return Object.fromEntries(e.data.map(([r, n])=>[
                this.encode(r),
                this.encode(n)
            ]));
        if (e.TAG === "tag") throw new Error("not implemented");
        return t;
    },
    decode (e) {
        if (typeof e == "bigint") return e < 0n ? {
            TAG: "negint",
            data: e
        } : {
            TAG: "uint",
            data: e
        };
        if (typeof e == "string") return {
            TAG: "string",
            data: e
        };
        if (Ay.utils.isBytes(e)) return {
            TAG: "bytes",
            data: e
        };
        if (Array.isArray(e)) return {
            TAG: "array",
            data: e.map((t)=>this.decode(t))
        };
        if (typeof e == "number" && Number.isSafeInteger(e) && !R5(e)) return e < 0 ? {
            TAG: "negint",
            data: e
        } : {
            TAG: "uint",
            data: e
        };
        if (typeof e == "boolean" || typeof e == "number" || e === null || e === void 0) return {
            TAG: "simple",
            data: e
        };
        if (typeof e == "object") return {
            TAG: "map",
            data: Object.entries(e).map((t)=>t.map((r)=>this.decode(r)))
        };
        throw new Error("unknown type");
    }
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(z, K, $, ne) {
        ne === void 0 && (ne = $);
        var ee = Object.getOwnPropertyDescriptor(K, $);
        (!ee || ("get" in ee ? !K.__esModule : ee.writable || ee.configurable)) && (ee = {
            enumerable: !0,
            get: function() {
                return K[$];
            }
        }), Object.defineProperty(z, ne, ee);
    } : function(z, K, $, ne) {
        ne === void 0 && (ne = $), z[ne] = K[$];
    }), r = Qe && Qe.__setModuleDefault || (Object.create ? function(z, K) {
        Object.defineProperty(z, "default", {
            enumerable: !0,
            value: K
        });
    } : function(z, K) {
        z.default = K;
    }), n = Qe && Qe.__importStar || function(z) {
        if (z && z.__esModule) return z;
        var K = {};
        if (z != null) for(var $ in z)$ !== "default" && Object.prototype.hasOwnProperty.call(z, $) && t(K, z, $);
        return r(K, z), K;
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.__test__ = e.OutOrdinalReveal = e.InscriptionId = void 0, e.parseInscriptions = P, e.parseWitness = M, e.p2tr_ord_reveal = N;
    const i1 = C5, o = n(M5), a = N5, s = kb, c = /* @__PURE__ */ i1.utf8.decode("BIN");
    function l(z) {
        const K = [];
        for(let $ = 0; $ < z.length; $ += a.MAX_SCRIPT_BYTE_LENGTH)K.push(z.subarray($, $ + a.MAX_SCRIPT_BYTE_LENGTH));
        return K;
    }
    const u = /* @__PURE__ */ o.tuple([
        o.bytes(32, !0),
        o.apply(o.bigint(4, !0, !1, !1), o.coders.numberBigint)
    ]);
    e.InscriptionId = {
        encode (z) {
            const [K, $] = z.split("i", 2);
            if (`${+$}` !== $) throw new Error(`InscriptionId wrong index: ${$}`);
            return u.encode([
                i1.hex.decode(K),
                +$
            ]);
        },
        decode (z) {
            const [K, $] = u.decode(z);
            return `${i1.hex.encode(K)}i${$}`;
        }
    };
    const f = {
        // Would be simpler to have body tag here,
        // but body chunks don't have body tag near them
        contentType: 1,
        pointer: 2,
        parent: 3,
        metadata: 5,
        metaprotocol: 7,
        contentEncoding: 9,
        delegate: 11,
        rune: 13,
        note: 15
    }, h = /* @__PURE__ */ o.map(o.U8, f), y = {
        pointer: o.bigint(8, !0, !1, !1),
        // U64
        contentType: o.string(null),
        parent: e.InscriptionId,
        metadata: s.CBOR,
        metaprotocol: o.string(null),
        contentEncoding: o.string(null),
        delegate: e.InscriptionId,
        rune: o.bigint(16, !0, !1, !1),
        // U128
        note: o.string(null)
    }, S = {
        encode (z) {
            const K = {}, $ = [];
            for (const { tag: ee, data: q } of z)try {
                const U = h.decode(ee);
                K[U] || (K[U] = []), K[U].push(q);
            } catch  {
                $.push([
                    ee,
                    q
                ]);
            }
            const ne = {};
            $.length && (ne.unknown = $);
            for(const ee in K){
                if (ee === "parent" && K[ee].length > 1) {
                    ne[ee] = K[ee].map((q)=>y.parent.decode(q));
                    continue;
                }
                ne[ee] = y[ee].decode(a.utils.concatBytes(...K[ee]));
            }
            return ne;
        },
        decode (z) {
            const K = [];
            for(const $ in z){
                if ($ === "unknown") continue;
                const ne = h.encode($);
                if ($ === "parent" && Array.isArray(z.parent)) {
                    for (const q of z.parent)K.push({
                        tag: ne,
                        data: y.parent.encode(q)
                    });
                    continue;
                }
                const ee = y[$].encode(z[$]);
                for (const q of l(ee))K.push({
                    tag: ne,
                    data: q
                });
            }
            if (z.unknown) {
                if (!Array.isArray(z.unknown)) throw new Error("ordinals/TagCoder: unknown should be array");
                for (const [$, ne] of z.unknown)K.push({
                    tag: $,
                    data: ne
                });
            }
            return K;
        }
    }, k = (z, K = 0)=>{
        if (!Number.isSafeInteger(K)) throw new Error(`parseInscription: wrong pos=${typeof K}`);
        const $ = [];
        let ne = !1;
        e: for(; K < z.length; K++){
            if (z[K] !== 0) continue;
            if (z[K + 1] !== "IF") {
                z[K + 1] === 0 && (ne = !0);
                continue e;
            }
            if (!a.utils.isBytes(z[K + 2]) || !o.utils.equalBytes(z[K + 2], c)) {
                z[K + 2] === 0 && (ne = !0);
                continue e;
            }
            let ee = !1;
            const q = [];
            for(let U = K + 3; U < z.length; U++){
                const Q = z[U];
                if (Q === "ENDIF") {
                    $.push({
                        start: K + 3,
                        end: U,
                        pushnum: ee,
                        payload: q,
                        stutter: ne
                    }), K = U;
                    break;
                }
                if (Q === "1NEGATE") {
                    ee = !0, q.push(new Uint8Array([
                        129
                    ]));
                    continue;
                }
                if (typeof Q == "number" && 1 <= Q && Q <= 16) {
                    ee = !0, q.push(new Uint8Array([
                        Q
                    ]));
                    continue;
                }
                if (a.utils.isBytes(Q) || Q === 0) {
                    q.push(Q);
                    continue;
                }
                ne = !1;
                break;
            }
        }
        return $;
    };
    function P(z, K = !1) {
        if (K && (!a.utils.isBytes(z[0]) || z[0].length !== 32) || K && z[1] !== "CHECKSIG") return;
        const $ = k(z), ne = [];
        let ee = 5;
        for (const q of $){
            if (K && (q.stutter || q.pushnum) || K && q.start !== ee) return;
            const { payload: U } = q;
            let Q = 0;
            const v = [];
            for(; Q < U.length && U[Q] !== 0; Q += 2){
                const g = U[Q], E = U[Q + 1];
                if (!a.utils.isBytes(g)) throw new Error("parseInscription: non-bytes tag");
                if (!a.utils.isBytes(E)) throw new Error("parseInscription: non-bytes tag data");
                v.push({
                    tag: g,
                    data: E
                });
            }
            for(; U[Q] === 0 && Q < U.length;)Q++;
            const B = [];
            for(; Q < U.length && a.utils.isBytes(U[Q]); Q++)B.push(U[Q]);
            ne.push({
                tags: S.encode(v),
                body: a.utils.concatBytes(...B),
                cursed: q.pushnum || q.stutter
            }), ee = q.end + 4;
        }
        if (ee - 3 === z.length) return ne;
    }
    function M(z) {
        if (z.length !== 3) throw new Error("Wrong witness");
        return P(a.Script.decode(z[1]));
    }
    e.OutOrdinalReveal = {
        encode (z) {
            const K = {
                type: "tr_ord_reveal"
            };
            try {
                K.inscriptions = P(z, !0), K.pubkey = z[0];
            } catch  {
                return;
            }
            return K;
        },
        decode: (z)=>{
            if (z.type !== "tr_ord_reveal") return;
            const K = [
                z.pubkey,
                "CHECKSIG"
            ];
            for (const { tags: $, body: ne } of z.inscriptions){
                K.push(0, "IF", c);
                const ee = S.decode($);
                for (const q of ee)K.push(q.tag, q.data);
                K.push(0);
                for (const q of l(ne))K.push(q);
                K.push("ENDIF");
            }
            return K;
        },
        finalizeTaproot: (z, K, $)=>{
            if ($.length !== 1) throw new Error("tr_ord_reveal/finalize: wrong signatures array");
            const [{ pubKey: ne }, ee] = $[0];
            if (o.utils.equalBytes(ne, K.pubkey)) return [
                ee,
                z
            ];
        }
    };
    function N(z, K) {
        return {
            type: "tr_ord_reveal",
            script: o.apply(a.Script, o.coders.match([
                e.OutOrdinalReveal
            ])).encode({
                type: "tr_ord_reveal",
                pubkey: z,
                inscriptions: K
            })
        };
    }
    e.__test__ = {
        TagCoders: y,
        TagCoder: S,
        parseEnvelopes: k
    };
})(uR);
var mR = {}, U1 = {};
Object.defineProperty(U1, "__esModule", {
    value: !0
});
U1.AbstractProvider = void 0;
class Tle {
}
U1.AbstractProvider = Tle;
var D1 = {};
Object.defineProperty(D1, "__esModule", {
    value: !0
});
D1.AbstractSigner = void 0;
class Ple {
}
D1.AbstractSigner = Ple;
var Ob = {};
Object.defineProperty(Ob, "__esModule", {
    value: !0
});
Ob.Signer = void 0;
const Cle = D1;
let Mle = class extends Cle.AbstractSigner {
    static from(e) {
        return new this(e, null);
    }
    connect(e) {
        return new this.constructor(this._target, e);
    }
    constructor(e, t){
        super(), this._target = e, this._provider = t;
    }
    get provider() {
        return this._provider;
    }
    async signPsbt(...e) {
        return await this._target.signPsbt(...e);
    }
    async signMessage(...e) {
        return await this._target.signMessage(...e);
    }
};
Ob.Signer = Mle;
var Ib = {}, Fm = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ Fm.exports;
(function(e, t) {
    (function() {
        var r, n = "4.17.21", i1 = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", s = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", l = 500, u = "__lodash_placeholder__", f = 1, h = 2, y = 4, S = 1, k = 2, P = 1, M = 2, N = 4, z = 8, K = 16, $ = 32, ne = 64, ee = 128, q = 256, U = 512, Q = 30, v = "...", B = 800, g = 16, E = 1, w = 2, _ = 3, O = 1 / 0, I = 9007199254740991, x = 17976931348623157e292, R = NaN, j = 4294967295, Y = j - 1, he = j >>> 1, ue = [
            [
                "ary",
                ee
            ],
            [
                "bind",
                P
            ],
            [
                "bindKey",
                M
            ],
            [
                "curry",
                z
            ],
            [
                "curryRight",
                K
            ],
            [
                "flip",
                U
            ],
            [
                "partial",
                $
            ],
            [
                "partialRight",
                ne
            ],
            [
                "rearg",
                q
            ]
        ], G = "[object Arguments]", se = "[object Array]", Z = "[object AsyncFunction]", ie = "[object Boolean]", pe = "[object Date]", ve = "[object DOMException]", Ie = "[object Error]", Me = "[object Function]", Re = "[object GeneratorFunction]", C = "[object Map]", J = "[object Number]", me = "[object Null]", je = "[object Object]", Ve = "[object Promise]", nt = "[object Proxy]", We = "[object RegExp]", Ge = "[object Set]", p = "[object String]", A = "[object Symbol]", V = "[object Undefined]", re = "[object WeakMap]", le = "[object WeakSet]", L = "[object ArrayBuffer]", X = "[object DataView]", ae = "[object Float32Array]", D = "[object Float64Array]", H = "[object Int8Array]", te = "[object Int16Array]", ge = "[object Int32Array]", ce = "[object Uint8Array]", Ue = "[object Uint8ClampedArray]", qe = "[object Uint16Array]", ot = "[object Uint32Array]", yt = /\b__p \+= '';/g, Ut = /\b(__p \+=) '' \+/g, Xe = /(__e\(.*?\)|\b__t\)) \+\n'';/g, _t = /&(?:amp|lt|gt|quot|#39);/g, br = /[&<>"']/g, Lr = RegExp(_t.source), Wt = RegExp(br.source), Dt = /<%-([\s\S]+?)%>/g, Yt = /<%([\s\S]+?)%>/g, Lt = /<%=([\s\S]+?)%>/g, Dr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, xe = /^\w*$/, ye = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ke = /[\\^$.*+?()[\]{}|]/g, Ce = RegExp(ke.source), De = /^\s+/, Ye = /\s/, lt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, et = /\{\n\/\* \[wrapped with (.+)\] \*/, vt = /,? & /, At = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, dt = /[()=,{}\[\]\/\s]/, Tt = /\\(\\)?/g, Pt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Rt = /\w*$/, rt = /^[-+]0x[0-9a-f]+$/i, Et = /^0b[01]+$/i, Pe = /^\[object .+?Constructor\]$/, mt = /^0o[0-7]+$/i, ut = /^(?:0|[1-9]\d*)$/, Jt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, we = /($^)/, Tr = /['\n\r\u2028\u2029\\]/g, ar = "\\ud800-\\udfff", sr = "\\u0300-\\u036f", kt = "\\ufe20-\\ufe2f", nn = "\\u20d0-\\u20ff", bi = sr + kt + nn, b = "\\u2700-\\u27bf", T = "a-z\\xdf-\\xf6\\xf8-\\xff", W = "\\xac\\xb1\\xd7\\xf7", fe = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Oe = "\\u2000-\\u206f", He = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ht = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ht = "\\ufe0e\\ufe0f", An = W + fe + Oe + He, ja = "[']", $1 = "[" + ar + "]", k7 = "[" + An + "]", Z1 = "[" + bi + "]", O7 = "\\d+", sF = "[" + b + "]", I7 = "[" + T + "]", B7 = "[^" + ar + An + O7 + b + T + ht + "]", Xb = "\\ud83c[\\udffb-\\udfff]", uF = "(?:" + Z1 + "|" + Xb + ")", T7 = "[^" + ar + "]", Yb = "(?:\\ud83c[\\udde6-\\uddff]){2}", Jb = "[\\ud800-\\udbff][\\udc00-\\udfff]", Vf = "[" + ht + "]", P7 = "\\u200d", C7 = "(?:" + I7 + "|" + B7 + ")", cF = "(?:" + Vf + "|" + B7 + ")", M7 = "(?:" + ja + "(?:d|ll|m|re|s|t|ve))?", N7 = "(?:" + ja + "(?:D|LL|M|RE|S|T|VE))?", R7 = uF + "?", U7 = "[" + Ht + "]?", lF = "(?:" + P7 + "(?:" + [
            T7,
            Yb,
            Jb
        ].join("|") + ")" + U7 + R7 + ")*", fF = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", dF = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", D7 = U7 + R7 + lF, hF = "(?:" + [
            sF,
            Yb,
            Jb
        ].join("|") + ")" + D7, pF = "(?:" + [
            T7 + Z1 + "?",
            Z1,
            Yb,
            Jb,
            $1
        ].join("|") + ")", gF = RegExp(ja, "g"), yF = RegExp(Z1, "g"), ew = RegExp(Xb + "(?=" + Xb + ")|" + pF + D7, "g"), mF = RegExp([
            Vf + "?" + I7 + "+" + M7 + "(?=" + [
                k7,
                Vf,
                "$"
            ].join("|") + ")",
            cF + "+" + N7 + "(?=" + [
                k7,
                Vf + C7,
                "$"
            ].join("|") + ")",
            Vf + "?" + C7 + "+" + M7,
            Vf + "+" + N7,
            dF,
            fF,
            O7,
            hF
        ].join("|"), "g"), bF = RegExp("[" + P7 + ar + bi + Ht + "]"), wF = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, AF = [
            "Array",
            "Buffer",
            "DataView",
            "Date",
            "Error",
            "Float32Array",
            "Float64Array",
            "Function",
            "Int8Array",
            "Int16Array",
            "Int32Array",
            "Map",
            "Math",
            "Object",
            "Promise",
            "RegExp",
            "Set",
            "String",
            "Symbol",
            "TypeError",
            "Uint8Array",
            "Uint8ClampedArray",
            "Uint16Array",
            "Uint32Array",
            "WeakMap",
            "_",
            "clearTimeout",
            "isFinite",
            "parseInt",
            "setTimeout"
        ], vF = -1, bn = {};
        bn[ae] = bn[D] = bn[H] = bn[te] = bn[ge] = bn[ce] = bn[Ue] = bn[qe] = bn[ot] = !0, bn[G] = bn[se] = bn[L] = bn[ie] = bn[X] = bn[pe] = bn[Ie] = bn[Me] = bn[C] = bn[J] = bn[je] = bn[We] = bn[Ge] = bn[p] = bn[re] = !1;
        var gn = {};
        gn[G] = gn[se] = gn[L] = gn[X] = gn[ie] = gn[pe] = gn[ae] = gn[D] = gn[H] = gn[te] = gn[ge] = gn[C] = gn[J] = gn[je] = gn[We] = gn[Ge] = gn[p] = gn[A] = gn[ce] = gn[Ue] = gn[qe] = gn[ot] = !0, gn[Ie] = gn[Me] = gn[re] = !1;
        var EF = {
            // Latin-1 Supplement block.
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "C",
            : "c",
            : "D",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "N",
            : "n",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "Y",
            : "y",
            : "y",
            : "Ae",
            : "ae",
            : "Th",
            : "th",
            : "ss",
            // Latin Extended-A block.
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "C",
            : "C",
            : "C",
            : "C",
            : "c",
            : "c",
            : "c",
            : "c",
            : "D",
            : "D",
            : "d",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "G",
            : "G",
            : "G",
            : "G",
            : "g",
            : "g",
            : "g",
            : "g",
            : "H",
            : "H",
            : "h",
            : "h",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "J",
            : "j",
            : "K",
            : "k",
            : "k",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "N",
            : "N",
            : "N",
            : "N",
            : "n",
            : "n",
            : "n",
            : "n",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "R",
            : "R",
            : "R",
            : "r",
            : "r",
            : "r",
            : "S",
            : "S",
            : "S",
            : "S",
            : "s",
            : "s",
            : "s",
            : "s",
            : "T",
            : "T",
            : "T",
            : "t",
            : "t",
            : "t",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "W",
            : "w",
            : "Y",
            : "y",
            : "Y",
            : "Z",
            : "Z",
            : "Z",
            : "z",
            : "z",
            : "z",
            : "IJ",
            : "ij",
            : "Oe",
            : "oe",
            : "'n",
            : "s"
        }, SF = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, xF = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        }, _F = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        }, kF = parseFloat, OF = parseInt, j7 = typeof Qe == "object" && Qe && Qe.Object === Object && Qe, IF = typeof self == "object" && self && self.Object === Object && self, wi = j7 || IF || Function("return this")(), tw = t && !t.nodeType && t, gl = tw && !0 && e && !e.nodeType && e, F7 = gl && gl.exports === tw, rw = F7 && j7.process, na = function() {
            try {
                var ze = gl && gl.require && gl.require("util").types;
                return ze || rw && rw.binding && rw.binding("util");
            } catch  {}
        }(), z7 = na && na.isArrayBuffer, L7 = na && na.isDate, H7 = na && na.isMap, K7 = na && na.isRegExp, q7 = na && na.isSet, V7 = na && na.isTypedArray;
        function Ro(ze, tt, Ze) {
            switch(Ze.length){
                case 0:
                    return ze.call(tt);
                case 1:
                    return ze.call(tt, Ze[0]);
                case 2:
                    return ze.call(tt, Ze[0], Ze[1]);
                case 3:
                    return ze.call(tt, Ze[0], Ze[1], Ze[2]);
            }
            return ze.apply(tt, Ze);
        }
        function BF(ze, tt, Ze, Ct) {
            for(var lr = -1, Xr = ze == null ? 0 : ze.length; ++lr < Xr;){
                var Xn = ze[lr];
                tt(Ct, Xn, Ze(Xn), ze);
            }
            return Ct;
        }
        function ia(ze, tt) {
            for(var Ze = -1, Ct = ze == null ? 0 : ze.length; ++Ze < Ct && tt(ze[Ze], Ze, ze) !== !1;);
            return ze;
        }
        function TF(ze, tt) {
            for(var Ze = ze == null ? 0 : ze.length; Ze-- && tt(ze[Ze], Ze, ze) !== !1;);
            return ze;
        }
        function W7(ze, tt) {
            for(var Ze = -1, Ct = ze == null ? 0 : ze.length; ++Ze < Ct;)if (!tt(ze[Ze], Ze, ze)) return !1;
            return !0;
        }
        function Wu(ze, tt) {
            for(var Ze = -1, Ct = ze == null ? 0 : ze.length, lr = 0, Xr = []; ++Ze < Ct;){
                var Xn = ze[Ze];
                tt(Xn, Ze, ze) && (Xr[lr++] = Xn);
            }
            return Xr;
        }
        function X1(ze, tt) {
            var Ze = ze == null ? 0 : ze.length;
            return !!Ze && Wf(ze, tt, 0) > -1;
        }
        function nw(ze, tt, Ze) {
            for(var Ct = -1, lr = ze == null ? 0 : ze.length; ++Ct < lr;)if (Ze(tt, ze[Ct])) return !0;
            return !1;
        }
        function vn(ze, tt) {
            for(var Ze = -1, Ct = ze == null ? 0 : ze.length, lr = Array(Ct); ++Ze < Ct;)lr[Ze] = tt(ze[Ze], Ze, ze);
            return lr;
        }
        function Gu(ze, tt) {
            for(var Ze = -1, Ct = tt.length, lr = ze.length; ++Ze < Ct;)ze[lr + Ze] = tt[Ze];
            return ze;
        }
        function iw(ze, tt, Ze, Ct) {
            var lr = -1, Xr = ze == null ? 0 : ze.length;
            for(Ct && Xr && (Ze = ze[++lr]); ++lr < Xr;)Ze = tt(Ze, ze[lr], lr, ze);
            return Ze;
        }
        function PF(ze, tt, Ze, Ct) {
            var lr = ze == null ? 0 : ze.length;
            for(Ct && lr && (Ze = ze[--lr]); lr--;)Ze = tt(Ze, ze[lr], lr, ze);
            return Ze;
        }
        function ow(ze, tt) {
            for(var Ze = -1, Ct = ze == null ? 0 : ze.length; ++Ze < Ct;)if (tt(ze[Ze], Ze, ze)) return !0;
            return !1;
        }
        var CF = aw("length");
        function MF(ze) {
            return ze.split("");
        }
        function NF(ze) {
            return ze.match(At) || [];
        }
        function G7(ze, tt, Ze) {
            var Ct;
            return Ze(ze, function(lr, Xr, Xn) {
                if (tt(lr, Xr, Xn)) return Ct = Xr, !1;
            }), Ct;
        }
        function Y1(ze, tt, Ze, Ct) {
            for(var lr = ze.length, Xr = Ze + (Ct ? 1 : -1); Ct ? Xr-- : ++Xr < lr;)if (tt(ze[Xr], Xr, ze)) return Xr;
            return -1;
        }
        function Wf(ze, tt, Ze) {
            return tt === tt ? WF(ze, tt, Ze) : Y1(ze, Q7, Ze);
        }
        function RF(ze, tt, Ze, Ct) {
            for(var lr = Ze - 1, Xr = ze.length; ++lr < Xr;)if (Ct(ze[lr], tt)) return lr;
            return -1;
        }
        function Q7(ze) {
            return ze !== ze;
        }
        function $7(ze, tt) {
            var Ze = ze == null ? 0 : ze.length;
            return Ze ? uw(ze, tt) / Ze : R;
        }
        function aw(ze) {
            return function(tt) {
                return tt == null ? r : tt[ze];
            };
        }
        function sw(ze) {
            return function(tt) {
                return ze == null ? r : ze[tt];
            };
        }
        function Z7(ze, tt, Ze, Ct, lr) {
            return lr(ze, function(Xr, Xn, hn) {
                Ze = Ct ? (Ct = !1, Xr) : tt(Ze, Xr, Xn, hn);
            }), Ze;
        }
        function UF(ze, tt) {
            var Ze = ze.length;
            for(ze.sort(tt); Ze--;)ze[Ze] = ze[Ze].value;
            return ze;
        }
        function uw(ze, tt) {
            for(var Ze, Ct = -1, lr = ze.length; ++Ct < lr;){
                var Xr = tt(ze[Ct]);
                Xr !== r && (Ze = Ze === r ? Xr : Ze + Xr);
            }
            return Ze;
        }
        function cw(ze, tt) {
            for(var Ze = -1, Ct = Array(ze); ++Ze < ze;)Ct[Ze] = tt(Ze);
            return Ct;
        }
        function DF(ze, tt) {
            return vn(tt, function(Ze) {
                return [
                    Ze,
                    ze[Ze]
                ];
            });
        }
        function X7(ze) {
            return ze && ze.slice(0, t9(ze) + 1).replace(De, "");
        }
        function Uo(ze) {
            return function(tt) {
                return ze(tt);
            };
        }
        function lw(ze, tt) {
            return vn(tt, function(Ze) {
                return ze[Ze];
            });
        }
        function ip(ze, tt) {
            return ze.has(tt);
        }
        function Y7(ze, tt) {
            for(var Ze = -1, Ct = ze.length; ++Ze < Ct && Wf(tt, ze[Ze], 0) > -1;);
            return Ze;
        }
        function J7(ze, tt) {
            for(var Ze = ze.length; Ze-- && Wf(tt, ze[Ze], 0) > -1;);
            return Ze;
        }
        function jF(ze, tt) {
            for(var Ze = ze.length, Ct = 0; Ze--;)ze[Ze] === tt && ++Ct;
            return Ct;
        }
        var FF = sw(EF), zF = sw(SF);
        function LF(ze) {
            return "\\" + _F[ze];
        }
        function HF(ze, tt) {
            return ze == null ? r : ze[tt];
        }
        function Gf(ze) {
            return bF.test(ze);
        }
        function KF(ze) {
            return wF.test(ze);
        }
        function qF(ze) {
            for(var tt, Ze = []; !(tt = ze.next()).done;)Ze.push(tt.value);
            return Ze;
        }
        function fw(ze) {
            var tt = -1, Ze = Array(ze.size);
            return ze.forEach(function(Ct, lr) {
                Ze[++tt] = [
                    lr,
                    Ct
                ];
            }), Ze;
        }
        function e9(ze, tt) {
            return function(Ze) {
                return ze(tt(Ze));
            };
        }
        function Qu(ze, tt) {
            for(var Ze = -1, Ct = ze.length, lr = 0, Xr = []; ++Ze < Ct;){
                var Xn = ze[Ze];
                (Xn === tt || Xn === u) && (ze[Ze] = u, Xr[lr++] = Ze);
            }
            return Xr;
        }
        function J1(ze) {
            var tt = -1, Ze = Array(ze.size);
            return ze.forEach(function(Ct) {
                Ze[++tt] = Ct;
            }), Ze;
        }
        function VF(ze) {
            var tt = -1, Ze = Array(ze.size);
            return ze.forEach(function(Ct) {
                Ze[++tt] = [
                    Ct,
                    Ct
                ];
            }), Ze;
        }
        function WF(ze, tt, Ze) {
            for(var Ct = Ze - 1, lr = ze.length; ++Ct < lr;)if (ze[Ct] === tt) return Ct;
            return -1;
        }
        function GF(ze, tt, Ze) {
            for(var Ct = Ze + 1; Ct--;)if (ze[Ct] === tt) return Ct;
            return Ct;
        }
        function Qf(ze) {
            return Gf(ze) ? $F(ze) : CF(ze);
        }
        function Fa(ze) {
            return Gf(ze) ? ZF(ze) : MF(ze);
        }
        function t9(ze) {
            for(var tt = ze.length; tt-- && Ye.test(ze.charAt(tt)););
            return tt;
        }
        var QF = sw(xF);
        function $F(ze) {
            for(var tt = ew.lastIndex = 0; ew.test(ze);)++tt;
            return tt;
        }
        function ZF(ze) {
            return ze.match(ew) || [];
        }
        function XF(ze) {
            return ze.match(mF) || [];
        }
        var YF = function ze(tt) {
            tt = tt == null ? wi : $f.defaults(wi.Object(), tt, $f.pick(wi, AF));
            var Ze = tt.Array, Ct = tt.Date, lr = tt.Error, Xr = tt.Function, Xn = tt.Math, hn = tt.Object, dw = tt.RegExp, JF = tt.String, oa = tt.TypeError, eg = Ze.prototype, ez = Xr.prototype, Zf = hn.prototype, tg = tt["__core-js_shared__"], rg = ez.toString, on = Zf.hasOwnProperty, tz = 0, r9 = function() {
                var d = /[^.]+$/.exec(tg && tg.keys && tg.keys.IE_PROTO || "");
                return d ? "Symbol(src)_1." + d : "";
            }(), ng = Zf.toString, rz = rg.call(hn), nz = wi._, iz = dw("^" + rg.call(on).replace(ke, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ig = F7 ? tt.Buffer : r, $u = tt.Symbol, og = tt.Uint8Array, n9 = ig ? ig.allocUnsafe : r, ag = e9(hn.getPrototypeOf, hn), i9 = hn.create, o9 = Zf.propertyIsEnumerable, sg = eg.splice, a9 = $u ? $u.isConcatSpreadable : r, op = $u ? $u.iterator : r, yl = $u ? $u.toStringTag : r, ug = function() {
                try {
                    var d = vl(hn, "defineProperty");
                    return d({}, "", {}), d;
                } catch  {}
            }(), oz = tt.clearTimeout !== wi.clearTimeout && tt.clearTimeout, az = Ct && Ct.now !== wi.Date.now && Ct.now, sz = tt.setTimeout !== wi.setTimeout && tt.setTimeout, cg = Xn.ceil, lg = Xn.floor, hw = hn.getOwnPropertySymbols, uz = ig ? ig.isBuffer : r, s9 = tt.isFinite, cz = eg.join, lz = e9(hn.keys, hn), Yn = Xn.max, Pi = Xn.min, fz = Ct.now, dz = tt.parseInt, u9 = Xn.random, hz = eg.reverse, pw = vl(tt, "DataView"), ap = vl(tt, "Map"), gw = vl(tt, "Promise"), Xf = vl(tt, "Set"), sp = vl(tt, "WeakMap"), up = vl(hn, "create"), fg = sp && new sp(), Yf = {}, pz = El(pw), gz = El(ap), yz = El(gw), mz = El(Xf), bz = El(sp), dg = $u ? $u.prototype : r, cp = dg ? dg.valueOf : r, c9 = dg ? dg.toString : r;
            function be(d) {
                if (Un(d) && !hr(d) && !(d instanceof jr)) {
                    if (d instanceof aa) return d;
                    if (on.call(d, "__wrapped__")) return lE(d);
                }
                return new aa(d);
            }
            var Jf = /* @__PURE__ */ function() {
                function d() {}
                return function(m) {
                    if (!_n(m)) return {};
                    if (i9) return i9(m);
                    d.prototype = m;
                    var F = new d();
                    return d.prototype = r, F;
                };
            }();
            function hg() {}
            function aa(d, m) {
                this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!m, this.__index__ = 0, this.__values__ = r;
            }
            be.templateSettings = {
                /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ escape: Dt,
                /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ evaluate: Yt,
                /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */ interpolate: Lt,
                /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */ variable: "",
                /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */ imports: {
                    /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */ _: be
                }
            }, be.prototype = hg.prototype, be.prototype.constructor = be, aa.prototype = Jf(hg.prototype), aa.prototype.constructor = aa;
            function jr(d) {
                this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = j, this.__views__ = [];
            }
            function wz() {
                var d = new jr(this.__wrapped__);
                return d.__actions__ = fo(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = fo(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = fo(this.__views__), d;
            }
            function Az() {
                if (this.__filtered__) {
                    var d = new jr(this);
                    d.__dir__ = -1, d.__filtered__ = !0;
                } else d = this.clone(), d.__dir__ *= -1;
                return d;
            }
            function vz() {
                var d = this.__wrapped__.value(), m = this.__dir__, F = hr(d), oe = m < 0, de = F ? d.length : 0, Ae = ML(0, de, this.__views__), Te = Ae.start, Ne = Ae.end, Le = Ne - Te, at = oe ? Ne : Te - 1, ct = this.__iteratees__, ft = ct.length, St = 0, jt = Pi(Le, this.__takeCount__);
                if (!F || !oe && de == Le && jt == Le) return M9(d, this.__actions__);
                var Qt = [];
                e: for(; Le-- && St < jt;){
                    at += m;
                    for(var xr = -1, $t = d[at]; ++xr < ft;){
                        var Rr = ct[xr], Hr = Rr.iteratee, Fo = Rr.type, Xi = Hr($t);
                        if (Fo == w) $t = Xi;
                        else if (!Xi) {
                            if (Fo == E) continue e;
                            break e;
                        }
                    }
                    Qt[St++] = $t;
                }
                return Qt;
            }
            jr.prototype = Jf(hg.prototype), jr.prototype.constructor = jr;
            function ml(d) {
                var m = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++m < F;){
                    var oe = d[m];
                    this.set(oe[0], oe[1]);
                }
            }
            function Ez() {
                this.__data__ = up ? up(null) : {}, this.size = 0;
            }
            function Sz(d) {
                var m = this.has(d) && delete this.__data__[d];
                return this.size -= m ? 1 : 0, m;
            }
            function xz(d) {
                var m = this.__data__;
                if (up) {
                    var F = m[d];
                    return F === c ? r : F;
                }
                return on.call(m, d) ? m[d] : r;
            }
            function _z(d) {
                var m = this.__data__;
                return up ? m[d] !== r : on.call(m, d);
            }
            function kz(d, m) {
                var F = this.__data__;
                return this.size += this.has(d) ? 0 : 1, F[d] = up && m === r ? c : m, this;
            }
            ml.prototype.clear = Ez, ml.prototype.delete = Sz, ml.prototype.get = xz, ml.prototype.has = _z, ml.prototype.set = kz;
            function ou(d) {
                var m = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++m < F;){
                    var oe = d[m];
                    this.set(oe[0], oe[1]);
                }
            }
            function Oz() {
                this.__data__ = [], this.size = 0;
            }
            function Iz(d) {
                var m = this.__data__, F = pg(m, d);
                if (F < 0) return !1;
                var oe = m.length - 1;
                return F == oe ? m.pop() : sg.call(m, F, 1), --this.size, !0;
            }
            function Bz(d) {
                var m = this.__data__, F = pg(m, d);
                return F < 0 ? r : m[F][1];
            }
            function Tz(d) {
                return pg(this.__data__, d) > -1;
            }
            function Pz(d, m) {
                var F = this.__data__, oe = pg(F, d);
                return oe < 0 ? (++this.size, F.push([
                    d,
                    m
                ])) : F[oe][1] = m, this;
            }
            ou.prototype.clear = Oz, ou.prototype.delete = Iz, ou.prototype.get = Bz, ou.prototype.has = Tz, ou.prototype.set = Pz;
            function au(d) {
                var m = -1, F = d == null ? 0 : d.length;
                for(this.clear(); ++m < F;){
                    var oe = d[m];
                    this.set(oe[0], oe[1]);
                }
            }
            function Cz() {
                this.size = 0, this.__data__ = {
                    hash: new ml(),
                    map: new (ap || ou)(),
                    string: new ml()
                };
            }
            function Mz(d) {
                var m = kg(this, d).delete(d);
                return this.size -= m ? 1 : 0, m;
            }
            function Nz(d) {
                return kg(this, d).get(d);
            }
            function Rz(d) {
                return kg(this, d).has(d);
            }
            function Uz(d, m) {
                var F = kg(this, d), oe = F.size;
                return F.set(d, m), this.size += F.size == oe ? 0 : 1, this;
            }
            au.prototype.clear = Cz, au.prototype.delete = Mz, au.prototype.get = Nz, au.prototype.has = Rz, au.prototype.set = Uz;
            function bl(d) {
                var m = -1, F = d == null ? 0 : d.length;
                for(this.__data__ = new au(); ++m < F;)this.add(d[m]);
            }
            function Dz(d) {
                return this.__data__.set(d, c), this;
            }
            function jz(d) {
                return this.__data__.has(d);
            }
            bl.prototype.add = bl.prototype.push = Dz, bl.prototype.has = jz;
            function za(d) {
                var m = this.__data__ = new ou(d);
                this.size = m.size;
            }
            function Fz() {
                this.__data__ = new ou(), this.size = 0;
            }
            function zz(d) {
                var m = this.__data__, F = m.delete(d);
                return this.size = m.size, F;
            }
            function Lz(d) {
                return this.__data__.get(d);
            }
            function Hz(d) {
                return this.__data__.has(d);
            }
            function Kz(d, m) {
                var F = this.__data__;
                if (F instanceof ou) {
                    var oe = F.__data__;
                    if (!ap || oe.length < i1 - 1) return oe.push([
                        d,
                        m
                    ]), this.size = ++F.size, this;
                    F = this.__data__ = new au(oe);
                }
                return F.set(d, m), this.size = F.size, this;
            }
            za.prototype.clear = Fz, za.prototype.delete = zz, za.prototype.get = Lz, za.prototype.has = Hz, za.prototype.set = Kz;
            function l9(d, m) {
                var F = hr(d), oe = !F && Sl(d), de = !F && !oe && ec(d), Ae = !F && !oe && !de && nd(d), Te = F || oe || de || Ae, Ne = Te ? cw(d.length, JF) : [], Le = Ne.length;
                for(var at in d)(m || on.call(d, at)) && !(Te && // Safari 9 has enumerable `arguments.length` in strict mode.
                (at == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                de && (at == "offset" || at == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                Ae && (at == "buffer" || at == "byteLength" || at == "byteOffset") || // Skip index properties.
                lu(at, Le))) && Ne.push(at);
                return Ne;
            }
            function f9(d) {
                var m = d.length;
                return m ? d[kw(0, m - 1)] : r;
            }
            function qz(d, m) {
                return Og(fo(d), wl(m, 0, d.length));
            }
            function Vz(d) {
                return Og(fo(d));
            }
            function yw(d, m, F) {
                (F !== r && !La(d[m], F) || F === r && !(m in d)) && su(d, m, F);
            }
            function lp(d, m, F) {
                var oe = d[m];
                (!(on.call(d, m) && La(oe, F)) || F === r && !(m in d)) && su(d, m, F);
            }
            function pg(d, m) {
                for(var F = d.length; F--;)if (La(d[F][0], m)) return F;
                return -1;
            }
            function Wz(d, m, F, oe) {
                return Zu(d, function(de, Ae, Te) {
                    m(oe, de, F(de), Te);
                }), oe;
            }
            function d9(d, m) {
                return d && ys(m, li(m), d);
            }
            function Gz(d, m) {
                return d && ys(m, po(m), d);
            }
            function su(d, m, F) {
                m == "__proto__" && ug ? ug(d, m, {
                    configurable: !0,
                    enumerable: !0,
                    value: F,
                    writable: !0
                }) : d[m] = F;
            }
            function mw(d, m) {
                for(var F = -1, oe = m.length, de = Ze(oe), Ae = d == null; ++F < oe;)de[F] = Ae ? r : Xw(d, m[F]);
                return de;
            }
            function wl(d, m, F) {
                return d === d && (F !== r && (d = d <= F ? d : F), m !== r && (d = d >= m ? d : m)), d;
            }
            function sa(d, m, F, oe, de, Ae) {
                var Te, Ne = m & f, Le = m & h, at = m & y;
                if (F && (Te = de ? F(d, oe, de, Ae) : F(d)), Te !== r) return Te;
                if (!_n(d)) return d;
                var ct = hr(d);
                if (ct) {
                    if (Te = RL(d), !Ne) return fo(d, Te);
                } else {
                    var ft = Ci(d), St = ft == Me || ft == Re;
                    if (ec(d)) return U9(d, Ne);
                    if (ft == je || ft == G || St && !de) {
                        if (Te = Le || St ? {} : tE(d), !Ne) return Le ? xL(d, Gz(Te, d)) : SL(d, d9(Te, d));
                    } else {
                        if (!gn[ft]) return de ? d : {};
                        Te = UL(d, ft, Ne);
                    }
                }
                Ae || (Ae = new za());
                var jt = Ae.get(d);
                if (jt) return jt;
                Ae.set(d, Te), TE(d) ? d.forEach(function($t) {
                    Te.add(sa($t, m, F, $t, d, Ae));
                }) : IE(d) && d.forEach(function($t, Rr) {
                    Te.set(Rr, sa($t, m, F, Rr, d, Ae));
                });
                var Qt = at ? Le ? Dw : Uw : Le ? po : li, xr = ct ? r : Qt(d);
                return ia(xr || d, function($t, Rr) {
                    xr && (Rr = $t, $t = d[Rr]), lp(Te, Rr, sa($t, m, F, Rr, d, Ae));
                }), Te;
            }
            function Qz(d) {
                var m = li(d);
                return function(F) {
                    return h9(F, d, m);
                };
            }
            function h9(d, m, F) {
                var oe = F.length;
                if (d == null) return !oe;
                for(d = hn(d); oe--;){
                    var de = F[oe], Ae = m[de], Te = d[de];
                    if (Te === r && !(de in d) || !Ae(Te)) return !1;
                }
                return !0;
            }
            function p9(d, m, F) {
                if (typeof d != "function") throw new oa(a);
                return mp(function() {
                    d.apply(r, F);
                }, m);
            }
            function fp(d, m, F, oe) {
                var de = -1, Ae = X1, Te = !0, Ne = d.length, Le = [], at = m.length;
                if (!Ne) return Le;
                F && (m = vn(m, Uo(F))), oe ? (Ae = nw, Te = !1) : m.length >= i1 && (Ae = ip, Te = !1, m = new bl(m));
                e: for(; ++de < Ne;){
                    var ct = d[de], ft = F == null ? ct : F(ct);
                    if (ct = oe || ct !== 0 ? ct : 0, Te && ft === ft) {
                        for(var St = at; St--;)if (m[St] === ft) continue e;
                        Le.push(ct);
                    } else Ae(m, ft, oe) || Le.push(ct);
                }
                return Le;
            }
            var Zu = L9(gs), g9 = L9(ww, !0);
            function $z(d, m) {
                var F = !0;
                return Zu(d, function(oe, de, Ae) {
                    return F = !!m(oe, de, Ae), F;
                }), F;
            }
            function gg(d, m, F) {
                for(var oe = -1, de = d.length; ++oe < de;){
                    var Ae = d[oe], Te = m(Ae);
                    if (Te != null && (Ne === r ? Te === Te && !jo(Te) : F(Te, Ne))) var Ne = Te, Le = Ae;
                }
                return Le;
            }
            function Zz(d, m, F, oe) {
                var de = d.length;
                for(F = wr(F), F < 0 && (F = -F > de ? 0 : de + F), oe = oe === r || oe > de ? de : wr(oe), oe < 0 && (oe += de), oe = F > oe ? 0 : CE(oe); F < oe;)d[F++] = m;
                return d;
            }
            function y9(d, m) {
                var F = [];
                return Zu(d, function(oe, de, Ae) {
                    m(oe, de, Ae) && F.push(oe);
                }), F;
            }
            function Ai(d, m, F, oe, de) {
                var Ae = -1, Te = d.length;
                for(F || (F = jL), de || (de = []); ++Ae < Te;){
                    var Ne = d[Ae];
                    m > 0 && F(Ne) ? m > 1 ? Ai(Ne, m - 1, F, oe, de) : Gu(de, Ne) : oe || (de[de.length] = Ne);
                }
                return de;
            }
            var bw = H9(), m9 = H9(!0);
            function gs(d, m) {
                return d && bw(d, m, li);
            }
            function ww(d, m) {
                return d && m9(d, m, li);
            }
            function yg(d, m) {
                return Wu(m, function(F) {
                    return fu(d[F]);
                });
            }
            function Al(d, m) {
                m = Yu(m, d);
                for(var F = 0, oe = m.length; d != null && F < oe;)d = d[ms(m[F++])];
                return F && F == oe ? d : r;
            }
            function b9(d, m, F) {
                var oe = m(d);
                return hr(d) ? oe : Gu(oe, F(d));
            }
            function $i(d) {
                return d == null ? d === r ? V : me : yl && yl in hn(d) ? CL(d) : VL(d);
            }
            function Aw(d, m) {
                return d > m;
            }
            function Xz(d, m) {
                return d != null && on.call(d, m);
            }
            function Yz(d, m) {
                return d != null && m in hn(d);
            }
            function Jz(d, m, F) {
                return d >= Pi(m, F) && d < Yn(m, F);
            }
            function vw(d, m, F) {
                for(var oe = F ? nw : X1, de = d[0].length, Ae = d.length, Te = Ae, Ne = Ze(Ae), Le = 1 / 0, at = []; Te--;){
                    var ct = d[Te];
                    Te && m && (ct = vn(ct, Uo(m))), Le = Pi(ct.length, Le), Ne[Te] = !F && (m || de >= 120 && ct.length >= 120) ? new bl(Te && ct) : r;
                }
                ct = d[0];
                var ft = -1, St = Ne[0];
                e: for(; ++ft < de && at.length < Le;){
                    var jt = ct[ft], Qt = m ? m(jt) : jt;
                    if (jt = F || jt !== 0 ? jt : 0, !(St ? ip(St, Qt) : oe(at, Qt, F))) {
                        for(Te = Ae; --Te;){
                            var xr = Ne[Te];
                            if (!(xr ? ip(xr, Qt) : oe(d[Te], Qt, F))) continue e;
                        }
                        St && St.push(Qt), at.push(jt);
                    }
                }
                return at;
            }
            function eL(d, m, F, oe) {
                return gs(d, function(de, Ae, Te) {
                    m(oe, F(de), Ae, Te);
                }), oe;
            }
            function dp(d, m, F) {
                m = Yu(m, d), d = oE(d, m);
                var oe = d == null ? d : d[ms(ca(m))];
                return oe == null ? r : Ro(oe, d, F);
            }
            function w9(d) {
                return Un(d) && $i(d) == G;
            }
            function tL(d) {
                return Un(d) && $i(d) == L;
            }
            function rL(d) {
                return Un(d) && $i(d) == pe;
            }
            function hp(d, m, F, oe, de) {
                return d === m ? !0 : d == null || m == null || !Un(d) && !Un(m) ? d !== d && m !== m : nL(d, m, F, oe, hp, de);
            }
            function nL(d, m, F, oe, de, Ae) {
                var Te = hr(d), Ne = hr(m), Le = Te ? se : Ci(d), at = Ne ? se : Ci(m);
                Le = Le == G ? je : Le, at = at == G ? je : at;
                var ct = Le == je, ft = at == je, St = Le == at;
                if (St && ec(d)) {
                    if (!ec(m)) return !1;
                    Te = !0, ct = !1;
                }
                if (St && !ct) return Ae || (Ae = new za()), Te || nd(d) ? Y9(d, m, F, oe, de, Ae) : TL(d, m, Le, F, oe, de, Ae);
                if (!(F & S)) {
                    var jt = ct && on.call(d, "__wrapped__"), Qt = ft && on.call(m, "__wrapped__");
                    if (jt || Qt) {
                        var xr = jt ? d.value() : d, $t = Qt ? m.value() : m;
                        return Ae || (Ae = new za()), de(xr, $t, F, oe, Ae);
                    }
                }
                return St ? (Ae || (Ae = new za()), PL(d, m, F, oe, de, Ae)) : !1;
            }
            function iL(d) {
                return Un(d) && Ci(d) == C;
            }
            function Ew(d, m, F, oe) {
                var de = F.length, Ae = de, Te = !oe;
                if (d == null) return !Ae;
                for(d = hn(d); de--;){
                    var Ne = F[de];
                    if (Te && Ne[2] ? Ne[1] !== d[Ne[0]] : !(Ne[0] in d)) return !1;
                }
                for(; ++de < Ae;){
                    Ne = F[de];
                    var Le = Ne[0], at = d[Le], ct = Ne[1];
                    if (Te && Ne[2]) {
                        if (at === r && !(Le in d)) return !1;
                    } else {
                        var ft = new za();
                        if (oe) var St = oe(at, ct, Le, d, m, ft);
                        if (!(St === r ? hp(ct, at, S | k, oe, ft) : St)) return !1;
                    }
                }
                return !0;
            }
            function A9(d) {
                if (!_n(d) || zL(d)) return !1;
                var m = fu(d) ? iz : Pe;
                return m.test(El(d));
            }
            function oL(d) {
                return Un(d) && $i(d) == We;
            }
            function aL(d) {
                return Un(d) && Ci(d) == Ge;
            }
            function sL(d) {
                return Un(d) && Mg(d.length) && !!bn[$i(d)];
            }
            function v9(d) {
                return typeof d == "function" ? d : d == null ? go : typeof d == "object" ? hr(d) ? x9(d[0], d[1]) : S9(d) : KE(d);
            }
            function Sw(d) {
                if (!yp(d)) return lz(d);
                var m = [];
                for(var F in hn(d))on.call(d, F) && F != "constructor" && m.push(F);
                return m;
            }
            function uL(d) {
                if (!_n(d)) return qL(d);
                var m = yp(d), F = [];
                for(var oe in d)oe == "constructor" && (m || !on.call(d, oe)) || F.push(oe);
                return F;
            }
            function xw(d, m) {
                return d < m;
            }
            function E9(d, m) {
                var F = -1, oe = ho(d) ? Ze(d.length) : [];
                return Zu(d, function(de, Ae, Te) {
                    oe[++F] = m(de, Ae, Te);
                }), oe;
            }
            function S9(d) {
                var m = Fw(d);
                return m.length == 1 && m[0][2] ? nE(m[0][0], m[0][1]) : function(F) {
                    return F === d || Ew(F, d, m);
                };
            }
            function x9(d, m) {
                return Lw(d) && rE(m) ? nE(ms(d), m) : function(F) {
                    var oe = Xw(F, d);
                    return oe === r && oe === m ? Yw(F, d) : hp(m, oe, S | k);
                };
            }
            function mg(d, m, F, oe, de) {
                d !== m && bw(m, function(Ae, Te) {
                    if (de || (de = new za()), _n(Ae)) cL(d, m, Te, F, mg, oe, de);
                    else {
                        var Ne = oe ? oe(Kw(d, Te), Ae, Te + "", d, m, de) : r;
                        Ne === r && (Ne = Ae), yw(d, Te, Ne);
                    }
                }, po);
            }
            function cL(d, m, F, oe, de, Ae, Te) {
                var Ne = Kw(d, F), Le = Kw(m, F), at = Te.get(Le);
                if (at) {
                    yw(d, F, at);
                    return;
                }
                var ct = Ae ? Ae(Ne, Le, F + "", d, m, Te) : r, ft = ct === r;
                if (ft) {
                    var St = hr(Le), jt = !St && ec(Le), Qt = !St && !jt && nd(Le);
                    ct = Le, St || jt || Qt ? hr(Ne) ? ct = Ne : zn(Ne) ? ct = fo(Ne) : jt ? (ft = !1, ct = U9(Le, !0)) : Qt ? (ft = !1, ct = D9(Le, !0)) : ct = [] : bp(Le) || Sl(Le) ? (ct = Ne, Sl(Ne) ? ct = ME(Ne) : (!_n(Ne) || fu(Ne)) && (ct = tE(Le))) : ft = !1;
                }
                ft && (Te.set(Le, ct), de(ct, Le, oe, Ae, Te), Te.delete(Le)), yw(d, F, ct);
            }
            function _9(d, m) {
                var F = d.length;
                if (F) return m += m < 0 ? F : 0, lu(m, F) ? d[m] : r;
            }
            function k9(d, m, F) {
                m.length ? m = vn(m, function(Ae) {
                    return hr(Ae) ? function(Te) {
                        return Al(Te, Ae.length === 1 ? Ae[0] : Ae);
                    } : Ae;
                }) : m = [
                    go
                ];
                var oe = -1;
                m = vn(m, Uo(Gt()));
                var de = E9(d, function(Ae, Te, Ne) {
                    var Le = vn(m, function(at) {
                        return at(Ae);
                    });
                    return {
                        criteria: Le,
                        index: ++oe,
                        value: Ae
                    };
                });
                return UF(de, function(Ae, Te) {
                    return EL(Ae, Te, F);
                });
            }
            function lL(d, m) {
                return O9(d, m, function(F, oe) {
                    return Yw(d, oe);
                });
            }
            function O9(d, m, F) {
                for(var oe = -1, de = m.length, Ae = {}; ++oe < de;){
                    var Te = m[oe], Ne = Al(d, Te);
                    F(Ne, Te) && pp(Ae, Yu(Te, d), Ne);
                }
                return Ae;
            }
            function fL(d) {
                return function(m) {
                    return Al(m, d);
                };
            }
            function _w(d, m, F, oe) {
                var de = oe ? RF : Wf, Ae = -1, Te = m.length, Ne = d;
                for(d === m && (m = fo(m)), F && (Ne = vn(d, Uo(F))); ++Ae < Te;)for(var Le = 0, at = m[Ae], ct = F ? F(at) : at; (Le = de(Ne, ct, Le, oe)) > -1;)Ne !== d && sg.call(Ne, Le, 1), sg.call(d, Le, 1);
                return d;
            }
            function I9(d, m) {
                for(var F = d ? m.length : 0, oe = F - 1; F--;){
                    var de = m[F];
                    if (F == oe || de !== Ae) {
                        var Ae = de;
                        lu(de) ? sg.call(d, de, 1) : Bw(d, de);
                    }
                }
                return d;
            }
            function kw(d, m) {
                return d + lg(u9() * (m - d + 1));
            }
            function dL(d, m, F, oe) {
                for(var de = -1, Ae = Yn(cg((m - d) / (F || 1)), 0), Te = Ze(Ae); Ae--;)Te[oe ? Ae : ++de] = d, d += F;
                return Te;
            }
            function Ow(d, m) {
                var F = "";
                if (!d || m < 1 || m > I) return F;
                do m % 2 && (F += d), m = lg(m / 2), m && (d += d);
                while (m)
                return F;
            }
            function Pr(d, m) {
                return qw(iE(d, m, go), d + "");
            }
            function hL(d) {
                return f9(id(d));
            }
            function pL(d, m) {
                var F = id(d);
                return Og(F, wl(m, 0, F.length));
            }
            function pp(d, m, F, oe) {
                if (!_n(d)) return d;
                m = Yu(m, d);
                for(var de = -1, Ae = m.length, Te = Ae - 1, Ne = d; Ne != null && ++de < Ae;){
                    var Le = ms(m[de]), at = F;
                    if (Le === "__proto__" || Le === "constructor" || Le === "prototype") return d;
                    if (de != Te) {
                        var ct = Ne[Le];
                        at = oe ? oe(ct, Le, Ne) : r, at === r && (at = _n(ct) ? ct : lu(m[de + 1]) ? [] : {});
                    }
                    lp(Ne, Le, at), Ne = Ne[Le];
                }
                return d;
            }
            var B9 = fg ? function(d, m) {
                return fg.set(d, m), d;
            } : go, gL = ug ? function(d, m) {
                return ug(d, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: eA(m),
                    writable: !0
                });
            } : go;
            function yL(d) {
                return Og(id(d));
            }
            function ua(d, m, F) {
                var oe = -1, de = d.length;
                m < 0 && (m = -m > de ? 0 : de + m), F = F > de ? de : F, F < 0 && (F += de), de = m > F ? 0 : F - m >>> 0, m >>>= 0;
                for(var Ae = Ze(de); ++oe < de;)Ae[oe] = d[oe + m];
                return Ae;
            }
            function mL(d, m) {
                var F;
                return Zu(d, function(oe, de, Ae) {
                    return F = m(oe, de, Ae), !F;
                }), !!F;
            }
            function bg(d, m, F) {
                var oe = 0, de = d == null ? oe : d.length;
                if (typeof m == "number" && m === m && de <= he) {
                    for(; oe < de;){
                        var Ae = oe + de >>> 1, Te = d[Ae];
                        Te !== null && !jo(Te) && (F ? Te <= m : Te < m) ? oe = Ae + 1 : de = Ae;
                    }
                    return de;
                }
                return Iw(d, m, go, F);
            }
            function Iw(d, m, F, oe) {
                var de = 0, Ae = d == null ? 0 : d.length;
                if (Ae === 0) return 0;
                m = F(m);
                for(var Te = m !== m, Ne = m === null, Le = jo(m), at = m === r; de < Ae;){
                    var ct = lg((de + Ae) / 2), ft = F(d[ct]), St = ft !== r, jt = ft === null, Qt = ft === ft, xr = jo(ft);
                    if (Te) var $t = oe || Qt;
                    else at ? $t = Qt && (oe || St) : Ne ? $t = Qt && St && (oe || !jt) : Le ? $t = Qt && St && !jt && (oe || !xr) : jt || xr ? $t = !1 : $t = oe ? ft <= m : ft < m;
                    $t ? de = ct + 1 : Ae = ct;
                }
                return Pi(Ae, Y);
            }
            function T9(d, m) {
                for(var F = -1, oe = d.length, de = 0, Ae = []; ++F < oe;){
                    var Te = d[F], Ne = m ? m(Te) : Te;
                    if (!F || !La(Ne, Le)) {
                        var Le = Ne;
                        Ae[de++] = Te === 0 ? 0 : Te;
                    }
                }
                return Ae;
            }
            function P9(d) {
                return typeof d == "number" ? d : jo(d) ? R : +d;
            }
            function Do(d) {
                if (typeof d == "string") return d;
                if (hr(d)) return vn(d, Do) + "";
                if (jo(d)) return c9 ? c9.call(d) : "";
                var m = d + "";
                return m == "0" && 1 / d == -O ? "-0" : m;
            }
            function Xu(d, m, F) {
                var oe = -1, de = X1, Ae = d.length, Te = !0, Ne = [], Le = Ne;
                if (F) Te = !1, de = nw;
                else if (Ae >= i1) {
                    var at = m ? null : IL(d);
                    if (at) return J1(at);
                    Te = !1, de = ip, Le = new bl();
                } else Le = m ? [] : Ne;
                e: for(; ++oe < Ae;){
                    var ct = d[oe], ft = m ? m(ct) : ct;
                    if (ct = F || ct !== 0 ? ct : 0, Te && ft === ft) {
                        for(var St = Le.length; St--;)if (Le[St] === ft) continue e;
                        m && Le.push(ft), Ne.push(ct);
                    } else de(Le, ft, F) || (Le !== Ne && Le.push(ft), Ne.push(ct));
                }
                return Ne;
            }
            function Bw(d, m) {
                return m = Yu(m, d), d = oE(d, m), d == null || delete d[ms(ca(m))];
            }
            function C9(d, m, F, oe) {
                return pp(d, m, F(Al(d, m)), oe);
            }
            function wg(d, m, F, oe) {
                for(var de = d.length, Ae = oe ? de : -1; (oe ? Ae-- : ++Ae < de) && m(d[Ae], Ae, d););
                return F ? ua(d, oe ? 0 : Ae, oe ? Ae + 1 : de) : ua(d, oe ? Ae + 1 : 0, oe ? de : Ae);
            }
            function M9(d, m) {
                var F = d;
                return F instanceof jr && (F = F.value()), iw(m, function(oe, de) {
                    return de.func.apply(de.thisArg, Gu([
                        oe
                    ], de.args));
                }, F);
            }
            function Tw(d, m, F) {
                var oe = d.length;
                if (oe < 2) return oe ? Xu(d[0]) : [];
                for(var de = -1, Ae = Ze(oe); ++de < oe;)for(var Te = d[de], Ne = -1; ++Ne < oe;)Ne != de && (Ae[de] = fp(Ae[de] || Te, d[Ne], m, F));
                return Xu(Ai(Ae, 1), m, F);
            }
            function N9(d, m, F) {
                for(var oe = -1, de = d.length, Ae = m.length, Te = {}; ++oe < de;){
                    var Ne = oe < Ae ? m[oe] : r;
                    F(Te, d[oe], Ne);
                }
                return Te;
            }
            function Pw(d) {
                return zn(d) ? d : [];
            }
            function Cw(d) {
                return typeof d == "function" ? d : go;
            }
            function Yu(d, m) {
                return hr(d) ? d : Lw(d, m) ? [
                    d
                ] : cE(Jr(d));
            }
            var bL = Pr;
            function Ju(d, m, F) {
                var oe = d.length;
                return F = F === r ? oe : F, !m && F >= oe ? d : ua(d, m, F);
            }
            var R9 = oz || function(d) {
                return wi.clearTimeout(d);
            };
            function U9(d, m) {
                if (m) return d.slice();
                var F = d.length, oe = n9 ? n9(F) : new d.constructor(F);
                return d.copy(oe), oe;
            }
            function Mw(d) {
                var m = new d.constructor(d.byteLength);
                return new og(m).set(new og(d)), m;
            }
            function wL(d, m) {
                var F = m ? Mw(d.buffer) : d.buffer;
                return new d.constructor(F, d.byteOffset, d.byteLength);
            }
            function AL(d) {
                var m = new d.constructor(d.source, Rt.exec(d));
                return m.lastIndex = d.lastIndex, m;
            }
            function vL(d) {
                return cp ? hn(cp.call(d)) : {};
            }
            function D9(d, m) {
                var F = m ? Mw(d.buffer) : d.buffer;
                return new d.constructor(F, d.byteOffset, d.length);
            }
            function j9(d, m) {
                if (d !== m) {
                    var F = d !== r, oe = d === null, de = d === d, Ae = jo(d), Te = m !== r, Ne = m === null, Le = m === m, at = jo(m);
                    if (!Ne && !at && !Ae && d > m || Ae && Te && Le && !Ne && !at || oe && Te && Le || !F && Le || !de) return 1;
                    if (!oe && !Ae && !at && d < m || at && F && de && !oe && !Ae || Ne && F && de || !Te && de || !Le) return -1;
                }
                return 0;
            }
            function EL(d, m, F) {
                for(var oe = -1, de = d.criteria, Ae = m.criteria, Te = de.length, Ne = F.length; ++oe < Te;){
                    var Le = j9(de[oe], Ae[oe]);
                    if (Le) {
                        if (oe >= Ne) return Le;
                        var at = F[oe];
                        return Le * (at == "desc" ? -1 : 1);
                    }
                }
                return d.index - m.index;
            }
            function F9(d, m, F, oe) {
                for(var de = -1, Ae = d.length, Te = F.length, Ne = -1, Le = m.length, at = Yn(Ae - Te, 0), ct = Ze(Le + at), ft = !oe; ++Ne < Le;)ct[Ne] = m[Ne];
                for(; ++de < Te;)(ft || de < Ae) && (ct[F[de]] = d[de]);
                for(; at--;)ct[Ne++] = d[de++];
                return ct;
            }
            function z9(d, m, F, oe) {
                for(var de = -1, Ae = d.length, Te = -1, Ne = F.length, Le = -1, at = m.length, ct = Yn(Ae - Ne, 0), ft = Ze(ct + at), St = !oe; ++de < ct;)ft[de] = d[de];
                for(var jt = de; ++Le < at;)ft[jt + Le] = m[Le];
                for(; ++Te < Ne;)(St || de < Ae) && (ft[jt + F[Te]] = d[de++]);
                return ft;
            }
            function fo(d, m) {
                var F = -1, oe = d.length;
                for(m || (m = Ze(oe)); ++F < oe;)m[F] = d[F];
                return m;
            }
            function ys(d, m, F, oe) {
                var de = !F;
                F || (F = {});
                for(var Ae = -1, Te = m.length; ++Ae < Te;){
                    var Ne = m[Ae], Le = oe ? oe(F[Ne], d[Ne], Ne, F, d) : r;
                    Le === r && (Le = d[Ne]), de ? su(F, Ne, Le) : lp(F, Ne, Le);
                }
                return F;
            }
            function SL(d, m) {
                return ys(d, zw(d), m);
            }
            function xL(d, m) {
                return ys(d, J9(d), m);
            }
            function Ag(d, m) {
                return function(F, oe) {
                    var de = hr(F) ? BF : Wz, Ae = m ? m() : {};
                    return de(F, d, Gt(oe, 2), Ae);
                };
            }
            function ed(d) {
                return Pr(function(m, F) {
                    var oe = -1, de = F.length, Ae = de > 1 ? F[de - 1] : r, Te = de > 2 ? F[2] : r;
                    for(Ae = d.length > 3 && typeof Ae == "function" ? (de--, Ae) : r, Te && Zi(F[0], F[1], Te) && (Ae = de < 3 ? r : Ae, de = 1), m = hn(m); ++oe < de;){
                        var Ne = F[oe];
                        Ne && d(m, Ne, oe, Ae);
                    }
                    return m;
                });
            }
            function L9(d, m) {
                return function(F, oe) {
                    if (F == null) return F;
                    if (!ho(F)) return d(F, oe);
                    for(var de = F.length, Ae = m ? de : -1, Te = hn(F); (m ? Ae-- : ++Ae < de) && oe(Te[Ae], Ae, Te) !== !1;);
                    return F;
                };
            }
            function H9(d) {
                return function(m, F, oe) {
                    for(var de = -1, Ae = hn(m), Te = oe(m), Ne = Te.length; Ne--;){
                        var Le = Te[d ? Ne : ++de];
                        if (F(Ae[Le], Le, Ae) === !1) break;
                    }
                    return m;
                };
            }
            function _L(d, m, F) {
                var oe = m & P, de = gp(d);
                function Ae() {
                    var Te = this && this !== wi && this instanceof Ae ? de : d;
                    return Te.apply(oe ? F : this, arguments);
                }
                return Ae;
            }
            function K9(d) {
                return function(m) {
                    m = Jr(m);
                    var F = Gf(m) ? Fa(m) : r, oe = F ? F[0] : m.charAt(0), de = F ? Ju(F, 1).join("") : m.slice(1);
                    return oe[d]() + de;
                };
            }
            function td(d) {
                return function(m) {
                    return iw(LE(zE(m).replace(gF, "")), d, "");
                };
            }
            function gp(d) {
                return function() {
                    var m = arguments;
                    switch(m.length){
                        case 0:
                            return new d();
                        case 1:
                            return new d(m[0]);
                        case 2:
                            return new d(m[0], m[1]);
                        case 3:
                            return new d(m[0], m[1], m[2]);
                        case 4:
                            return new d(m[0], m[1], m[2], m[3]);
                        case 5:
                            return new d(m[0], m[1], m[2], m[3], m[4]);
                        case 6:
                            return new d(m[0], m[1], m[2], m[3], m[4], m[5]);
                        case 7:
                            return new d(m[0], m[1], m[2], m[3], m[4], m[5], m[6]);
                    }
                    var F = Jf(d.prototype), oe = d.apply(F, m);
                    return _n(oe) ? oe : F;
                };
            }
            function kL(d, m, F) {
                var oe = gp(d);
                function de() {
                    for(var Ae = arguments.length, Te = Ze(Ae), Ne = Ae, Le = rd(de); Ne--;)Te[Ne] = arguments[Ne];
                    var at = Ae < 3 && Te[0] !== Le && Te[Ae - 1] !== Le ? [] : Qu(Te, Le);
                    if (Ae -= at.length, Ae < F) return Q9(d, m, vg, de.placeholder, r, Te, at, r, r, F - Ae);
                    var ct = this && this !== wi && this instanceof de ? oe : d;
                    return Ro(ct, this, Te);
                }
                return de;
            }
            function q9(d) {
                return function(m, F, oe) {
                    var de = hn(m);
                    if (!ho(m)) {
                        var Ae = Gt(F, 3);
                        m = li(m), F = function(Ne) {
                            return Ae(de[Ne], Ne, de);
                        };
                    }
                    var Te = d(m, F, oe);
                    return Te > -1 ? de[Ae ? m[Te] : Te] : r;
                };
            }
            function V9(d) {
                return cu(function(m) {
                    var F = m.length, oe = F, de = aa.prototype.thru;
                    for(d && m.reverse(); oe--;){
                        var Ae = m[oe];
                        if (typeof Ae != "function") throw new oa(a);
                        if (de && !Te && _g(Ae) == "wrapper") var Te = new aa([], !0);
                    }
                    for(oe = Te ? oe : F; ++oe < F;){
                        Ae = m[oe];
                        var Ne = _g(Ae), Le = Ne == "wrapper" ? jw(Ae) : r;
                        Le && Hw(Le[0]) && Le[1] == (ee | z | $ | q) && !Le[4].length && Le[9] == 1 ? Te = Te[_g(Le[0])].apply(Te, Le[3]) : Te = Ae.length == 1 && Hw(Ae) ? Te[Ne]() : Te.thru(Ae);
                    }
                    return function() {
                        var at = arguments, ct = at[0];
                        if (Te && at.length == 1 && hr(ct)) return Te.plant(ct).value();
                        for(var ft = 0, St = F ? m[ft].apply(this, at) : ct; ++ft < F;)St = m[ft].call(this, St);
                        return St;
                    };
                });
            }
            function vg(d, m, F, oe, de, Ae, Te, Ne, Le, at) {
                var ct = m & ee, ft = m & P, St = m & M, jt = m & (z | K), Qt = m & U, xr = St ? r : gp(d);
                function $t() {
                    for(var Rr = arguments.length, Hr = Ze(Rr), Fo = Rr; Fo--;)Hr[Fo] = arguments[Fo];
                    if (jt) var Xi = rd($t), zo = jF(Hr, Xi);
                    if (oe && (Hr = F9(Hr, oe, de, jt)), Ae && (Hr = z9(Hr, Ae, Te, jt)), Rr -= zo, jt && Rr < at) {
                        var Ln = Qu(Hr, Xi);
                        return Q9(d, m, vg, $t.placeholder, F, Hr, Ln, Ne, Le, at - Rr);
                    }
                    var Ha = ft ? F : this, hu = St ? Ha[d] : d;
                    return Rr = Hr.length, Ne ? Hr = WL(Hr, Ne) : Qt && Rr > 1 && Hr.reverse(), ct && Le < Rr && (Hr.length = Le), this && this !== wi && this instanceof $t && (hu = xr || gp(hu)), hu.apply(Ha, Hr);
                }
                return $t;
            }
            function W9(d, m) {
                return function(F, oe) {
                    return eL(F, d, m(oe), {});
                };
            }
            function Eg(d, m) {
                return function(F, oe) {
                    var de;
                    if (F === r && oe === r) return m;
                    if (F !== r && (de = F), oe !== r) {
                        if (de === r) return oe;
                        typeof F == "string" || typeof oe == "string" ? (F = Do(F), oe = Do(oe)) : (F = P9(F), oe = P9(oe)), de = d(F, oe);
                    }
                    return de;
                };
            }
            function Nw(d) {
                return cu(function(m) {
                    return m = vn(m, Uo(Gt())), Pr(function(F) {
                        var oe = this;
                        return d(m, function(de) {
                            return Ro(de, oe, F);
                        });
                    });
                });
            }
            function Sg(d, m) {
                m = m === r ? " " : Do(m);
                var F = m.length;
                if (F < 2) return F ? Ow(m, d) : m;
                var oe = Ow(m, cg(d / Qf(m)));
                return Gf(m) ? Ju(Fa(oe), 0, d).join("") : oe.slice(0, d);
            }
            function OL(d, m, F, oe) {
                var de = m & P, Ae = gp(d);
                function Te() {
                    for(var Ne = -1, Le = arguments.length, at = -1, ct = oe.length, ft = Ze(ct + Le), St = this && this !== wi && this instanceof Te ? Ae : d; ++at < ct;)ft[at] = oe[at];
                    for(; Le--;)ft[at++] = arguments[++Ne];
                    return Ro(St, de ? F : this, ft);
                }
                return Te;
            }
            function G9(d) {
                return function(m, F, oe) {
                    return oe && typeof oe != "number" && Zi(m, F, oe) && (F = oe = r), m = du(m), F === r ? (F = m, m = 0) : F = du(F), oe = oe === r ? m < F ? 1 : -1 : du(oe), dL(m, F, oe, d);
                };
            }
            function xg(d) {
                return function(m, F) {
                    return typeof m == "string" && typeof F == "string" || (m = la(m), F = la(F)), d(m, F);
                };
            }
            function Q9(d, m, F, oe, de, Ae, Te, Ne, Le, at) {
                var ct = m & z, ft = ct ? Te : r, St = ct ? r : Te, jt = ct ? Ae : r, Qt = ct ? r : Ae;
                m |= ct ? $ : ne, m &= ~(ct ? ne : $), m & N || (m &= -4);
                var xr = [
                    d,
                    m,
                    de,
                    jt,
                    ft,
                    Qt,
                    St,
                    Ne,
                    Le,
                    at
                ], $t = F.apply(r, xr);
                return Hw(d) && aE($t, xr), $t.placeholder = oe, sE($t, d, m);
            }
            function Rw(d) {
                var m = Xn[d];
                return function(F, oe) {
                    if (F = la(F), oe = oe == null ? 0 : Pi(wr(oe), 292), oe && s9(F)) {
                        var de = (Jr(F) + "e").split("e"), Ae = m(de[0] + "e" + (+de[1] + oe));
                        return de = (Jr(Ae) + "e").split("e"), +(de[0] + "e" + (+de[1] - oe));
                    }
                    return m(F);
                };
            }
            var IL = Xf && 1 / J1(new Xf([
                ,
                -0
            ]))[1] == O ? function(d) {
                return new Xf(d);
            } : nA;
            function $9(d) {
                return function(m) {
                    var F = Ci(m);
                    return F == C ? fw(m) : F == Ge ? VF(m) : DF(m, d(m));
                };
            }
            function uu(d, m, F, oe, de, Ae, Te, Ne) {
                var Le = m & M;
                if (!Le && typeof d != "function") throw new oa(a);
                var at = oe ? oe.length : 0;
                if (at || (m &= -97, oe = de = r), Te = Te === r ? Te : Yn(wr(Te), 0), Ne = Ne === r ? Ne : wr(Ne), at -= de ? de.length : 0, m & ne) {
                    var ct = oe, ft = de;
                    oe = de = r;
                }
                var St = Le ? r : jw(d), jt = [
                    d,
                    m,
                    F,
                    oe,
                    de,
                    ct,
                    ft,
                    Ae,
                    Te,
                    Ne
                ];
                if (St && KL(jt, St), d = jt[0], m = jt[1], F = jt[2], oe = jt[3], de = jt[4], Ne = jt[9] = jt[9] === r ? Le ? 0 : d.length : Yn(jt[9] - at, 0), !Ne && m & (z | K) && (m &= -25), !m || m == P) var Qt = _L(d, m, F);
                else m == z || m == K ? Qt = kL(d, m, Ne) : (m == $ || m == (P | $)) && !de.length ? Qt = OL(d, m, F, oe) : Qt = vg.apply(r, jt);
                var xr = St ? B9 : aE;
                return sE(xr(Qt, jt), d, m);
            }
            function Z9(d, m, F, oe) {
                return d === r || La(d, Zf[F]) && !on.call(oe, F) ? m : d;
            }
            function X9(d, m, F, oe, de, Ae) {
                return _n(d) && _n(m) && (Ae.set(m, d), mg(d, m, r, X9, Ae), Ae.delete(m)), d;
            }
            function BL(d) {
                return bp(d) ? r : d;
            }
            function Y9(d, m, F, oe, de, Ae) {
                var Te = F & S, Ne = d.length, Le = m.length;
                if (Ne != Le && !(Te && Le > Ne)) return !1;
                var at = Ae.get(d), ct = Ae.get(m);
                if (at && ct) return at == m && ct == d;
                var ft = -1, St = !0, jt = F & k ? new bl() : r;
                for(Ae.set(d, m), Ae.set(m, d); ++ft < Ne;){
                    var Qt = d[ft], xr = m[ft];
                    if (oe) var $t = Te ? oe(xr, Qt, ft, m, d, Ae) : oe(Qt, xr, ft, d, m, Ae);
                    if ($t !== r) {
                        if ($t) continue;
                        St = !1;
                        break;
                    }
                    if (jt) {
                        if (!ow(m, function(Rr, Hr) {
                            if (!ip(jt, Hr) && (Qt === Rr || de(Qt, Rr, F, oe, Ae))) return jt.push(Hr);
                        })) {
                            St = !1;
                            break;
                        }
                    } else if (!(Qt === xr || de(Qt, xr, F, oe, Ae))) {
                        St = !1;
                        break;
                    }
                }
                return Ae.delete(d), Ae.delete(m), St;
            }
            function TL(d, m, F, oe, de, Ae, Te) {
                switch(F){
                    case X:
                        if (d.byteLength != m.byteLength || d.byteOffset != m.byteOffset) return !1;
                        d = d.buffer, m = m.buffer;
                    case L:
                        return !(d.byteLength != m.byteLength || !Ae(new og(d), new og(m)));
                    case ie:
                    case pe:
                    case J:
                        return La(+d, +m);
                    case Ie:
                        return d.name == m.name && d.message == m.message;
                    case We:
                    case p:
                        return d == m + "";
                    case C:
                        var Ne = fw;
                    case Ge:
                        var Le = oe & S;
                        if (Ne || (Ne = J1), d.size != m.size && !Le) return !1;
                        var at = Te.get(d);
                        if (at) return at == m;
                        oe |= k, Te.set(d, m);
                        var ct = Y9(Ne(d), Ne(m), oe, de, Ae, Te);
                        return Te.delete(d), ct;
                    case A:
                        if (cp) return cp.call(d) == cp.call(m);
                }
                return !1;
            }
            function PL(d, m, F, oe, de, Ae) {
                var Te = F & S, Ne = Uw(d), Le = Ne.length, at = Uw(m), ct = at.length;
                if (Le != ct && !Te) return !1;
                for(var ft = Le; ft--;){
                    var St = Ne[ft];
                    if (!(Te ? St in m : on.call(m, St))) return !1;
                }
                var jt = Ae.get(d), Qt = Ae.get(m);
                if (jt && Qt) return jt == m && Qt == d;
                var xr = !0;
                Ae.set(d, m), Ae.set(m, d);
                for(var $t = Te; ++ft < Le;){
                    St = Ne[ft];
                    var Rr = d[St], Hr = m[St];
                    if (oe) var Fo = Te ? oe(Hr, Rr, St, m, d, Ae) : oe(Rr, Hr, St, d, m, Ae);
                    if (!(Fo === r ? Rr === Hr || de(Rr, Hr, F, oe, Ae) : Fo)) {
                        xr = !1;
                        break;
                    }
                    $t || ($t = St == "constructor");
                }
                if (xr && !$t) {
                    var Xi = d.constructor, zo = m.constructor;
                    Xi != zo && "constructor" in d && "constructor" in m && !(typeof Xi == "function" && Xi instanceof Xi && typeof zo == "function" && zo instanceof zo) && (xr = !1);
                }
                return Ae.delete(d), Ae.delete(m), xr;
            }
            function cu(d) {
                return qw(iE(d, r, hE), d + "");
            }
            function Uw(d) {
                return b9(d, li, zw);
            }
            function Dw(d) {
                return b9(d, po, J9);
            }
            var jw = fg ? function(d) {
                return fg.get(d);
            } : nA;
            function _g(d) {
                for(var m = d.name + "", F = Yf[m], oe = on.call(Yf, m) ? F.length : 0; oe--;){
                    var de = F[oe], Ae = de.func;
                    if (Ae == null || Ae == d) return de.name;
                }
                return m;
            }
            function rd(d) {
                var m = on.call(be, "placeholder") ? be : d;
                return m.placeholder;
            }
            function Gt() {
                var d = be.iteratee || tA;
                return d = d === tA ? v9 : d, arguments.length ? d(arguments[0], arguments[1]) : d;
            }
            function kg(d, m) {
                var F = d.__data__;
                return FL(m) ? F[typeof m == "string" ? "string" : "hash"] : F.map;
            }
            function Fw(d) {
                for(var m = li(d), F = m.length; F--;){
                    var oe = m[F], de = d[oe];
                    m[F] = [
                        oe,
                        de,
                        rE(de)
                    ];
                }
                return m;
            }
            function vl(d, m) {
                var F = HF(d, m);
                return A9(F) ? F : r;
            }
            function CL(d) {
                var m = on.call(d, yl), F = d[yl];
                try {
                    d[yl] = r;
                    var oe = !0;
                } catch  {}
                var de = ng.call(d);
                return oe && (m ? d[yl] = F : delete d[yl]), de;
            }
            var zw = hw ? function(d) {
                return d == null ? [] : (d = hn(d), Wu(hw(d), function(m) {
                    return o9.call(d, m);
                }));
            } : iA, J9 = hw ? function(d) {
                for(var m = []; d;)Gu(m, zw(d)), d = ag(d);
                return m;
            } : iA, Ci = $i;
            (pw && Ci(new pw(new ArrayBuffer(1))) != X || ap && Ci(new ap()) != C || gw && Ci(gw.resolve()) != Ve || Xf && Ci(new Xf()) != Ge || sp && Ci(new sp()) != re) && (Ci = function(d) {
                var m = $i(d), F = m == je ? d.constructor : r, oe = F ? El(F) : "";
                if (oe) switch(oe){
                    case pz:
                        return X;
                    case gz:
                        return C;
                    case yz:
                        return Ve;
                    case mz:
                        return Ge;
                    case bz:
                        return re;
                }
                return m;
            });
            function ML(d, m, F) {
                for(var oe = -1, de = F.length; ++oe < de;){
                    var Ae = F[oe], Te = Ae.size;
                    switch(Ae.type){
                        case "drop":
                            d += Te;
                            break;
                        case "dropRight":
                            m -= Te;
                            break;
                        case "take":
                            m = Pi(m, d + Te);
                            break;
                        case "takeRight":
                            d = Yn(d, m - Te);
                            break;
                    }
                }
                return {
                    start: d,
                    end: m
                };
            }
            function NL(d) {
                var m = d.match(et);
                return m ? m[1].split(vt) : [];
            }
            function eE(d, m, F) {
                m = Yu(m, d);
                for(var oe = -1, de = m.length, Ae = !1; ++oe < de;){
                    var Te = ms(m[oe]);
                    if (!(Ae = d != null && F(d, Te))) break;
                    d = d[Te];
                }
                return Ae || ++oe != de ? Ae : (de = d == null ? 0 : d.length, !!de && Mg(de) && lu(Te, de) && (hr(d) || Sl(d)));
            }
            function RL(d) {
                var m = d.length, F = new d.constructor(m);
                return m && typeof d[0] == "string" && on.call(d, "index") && (F.index = d.index, F.input = d.input), F;
            }
            function tE(d) {
                return typeof d.constructor == "function" && !yp(d) ? Jf(ag(d)) : {};
            }
            function UL(d, m, F) {
                var oe = d.constructor;
                switch(m){
                    case L:
                        return Mw(d);
                    case ie:
                    case pe:
                        return new oe(+d);
                    case X:
                        return wL(d, F);
                    case ae:
                    case D:
                    case H:
                    case te:
                    case ge:
                    case ce:
                    case Ue:
                    case qe:
                    case ot:
                        return D9(d, F);
                    case C:
                        return new oe();
                    case J:
                    case p:
                        return new oe(d);
                    case We:
                        return AL(d);
                    case Ge:
                        return new oe();
                    case A:
                        return vL(d);
                }
            }
            function DL(d, m) {
                var F = m.length;
                if (!F) return d;
                var oe = F - 1;
                return m[oe] = (F > 1 ? "& " : "") + m[oe], m = m.join(F > 2 ? ", " : " "), d.replace(lt, `{
/* [wrapped with ` + m + `] */
`);
            }
            function jL(d) {
                return hr(d) || Sl(d) || !!(a9 && d && d[a9]);
            }
            function lu(d, m) {
                var F = typeof d;
                return m = m ?? I, !!m && (F == "number" || F != "symbol" && ut.test(d)) && d > -1 && d % 1 == 0 && d < m;
            }
            function Zi(d, m, F) {
                if (!_n(F)) return !1;
                var oe = typeof m;
                return (oe == "number" ? ho(F) && lu(m, F.length) : oe == "string" && m in F) ? La(F[m], d) : !1;
            }
            function Lw(d, m) {
                if (hr(d)) return !1;
                var F = typeof d;
                return F == "number" || F == "symbol" || F == "boolean" || d == null || jo(d) ? !0 : xe.test(d) || !Dr.test(d) || m != null && d in hn(m);
            }
            function FL(d) {
                var m = typeof d;
                return m == "string" || m == "number" || m == "symbol" || m == "boolean" ? d !== "__proto__" : d === null;
            }
            function Hw(d) {
                var m = _g(d), F = be[m];
                if (typeof F != "function" || !(m in jr.prototype)) return !1;
                if (d === F) return !0;
                var oe = jw(F);
                return !!oe && d === oe[0];
            }
            function zL(d) {
                return !!r9 && r9 in d;
            }
            var LL = tg ? fu : oA;
            function yp(d) {
                var m = d && d.constructor, F = typeof m == "function" && m.prototype || Zf;
                return d === F;
            }
            function rE(d) {
                return d === d && !_n(d);
            }
            function nE(d, m) {
                return function(F) {
                    return F == null ? !1 : F[d] === m && (m !== r || d in hn(F));
                };
            }
            function HL(d) {
                var m = Pg(d, function(oe) {
                    return F.size === l && F.clear(), oe;
                }), F = m.cache;
                return m;
            }
            function KL(d, m) {
                var F = d[1], oe = m[1], de = F | oe, Ae = de < (P | M | ee), Te = oe == ee && F == z || oe == ee && F == q && d[7].length <= m[8] || oe == (ee | q) && m[7].length <= m[8] && F == z;
                if (!(Ae || Te)) return d;
                oe & P && (d[2] = m[2], de |= F & P ? 0 : N);
                var Ne = m[3];
                if (Ne) {
                    var Le = d[3];
                    d[3] = Le ? F9(Le, Ne, m[4]) : Ne, d[4] = Le ? Qu(d[3], u) : m[4];
                }
                return Ne = m[5], Ne && (Le = d[5], d[5] = Le ? z9(Le, Ne, m[6]) : Ne, d[6] = Le ? Qu(d[5], u) : m[6]), Ne = m[7], Ne && (d[7] = Ne), oe & ee && (d[8] = d[8] == null ? m[8] : Pi(d[8], m[8])), d[9] == null && (d[9] = m[9]), d[0] = m[0], d[1] = de, d;
            }
            function qL(d) {
                var m = [];
                if (d != null) for(var F in hn(d))m.push(F);
                return m;
            }
            function VL(d) {
                return ng.call(d);
            }
            function iE(d, m, F) {
                return m = Yn(m === r ? d.length - 1 : m, 0), function() {
                    for(var oe = arguments, de = -1, Ae = Yn(oe.length - m, 0), Te = Ze(Ae); ++de < Ae;)Te[de] = oe[m + de];
                    de = -1;
                    for(var Ne = Ze(m + 1); ++de < m;)Ne[de] = oe[de];
                    return Ne[m] = F(Te), Ro(d, this, Ne);
                };
            }
            function oE(d, m) {
                return m.length < 2 ? d : Al(d, ua(m, 0, -1));
            }
            function WL(d, m) {
                for(var F = d.length, oe = Pi(m.length, F), de = fo(d); oe--;){
                    var Ae = m[oe];
                    d[oe] = lu(Ae, F) ? de[Ae] : r;
                }
                return d;
            }
            function Kw(d, m) {
                if (!(m === "constructor" && typeof d[m] == "function") && m != "__proto__") return d[m];
            }
            var aE = uE(B9), mp = sz || function(d, m) {
                return wi.setTimeout(d, m);
            }, qw = uE(gL);
            function sE(d, m, F) {
                var oe = m + "";
                return qw(d, DL(oe, GL(NL(oe), F)));
            }
            function uE(d) {
                var m = 0, F = 0;
                return function() {
                    var oe = fz(), de = g - (oe - F);
                    if (F = oe, de > 0) {
                        if (++m >= B) return arguments[0];
                    } else m = 0;
                    return d.apply(r, arguments);
                };
            }
            function Og(d, m) {
                var F = -1, oe = d.length, de = oe - 1;
                for(m = m === r ? oe : m; ++F < m;){
                    var Ae = kw(F, de), Te = d[Ae];
                    d[Ae] = d[F], d[F] = Te;
                }
                return d.length = m, d;
            }
            var cE = HL(function(d) {
                var m = [];
                return d.charCodeAt(0) === 46 && m.push(""), d.replace(ye, function(F, oe, de, Ae) {
                    m.push(de ? Ae.replace(Tt, "$1") : oe || F);
                }), m;
            });
            function ms(d) {
                if (typeof d == "string" || jo(d)) return d;
                var m = d + "";
                return m == "0" && 1 / d == -O ? "-0" : m;
            }
            function El(d) {
                if (d != null) {
                    try {
                        return rg.call(d);
                    } catch  {}
                    try {
                        return d + "";
                    } catch  {}
                }
                return "";
            }
            function GL(d, m) {
                return ia(ue, function(F) {
                    var oe = "_." + F[0];
                    m & F[1] && !X1(d, oe) && d.push(oe);
                }), d.sort();
            }
            function lE(d) {
                if (d instanceof jr) return d.clone();
                var m = new aa(d.__wrapped__, d.__chain__);
                return m.__actions__ = fo(d.__actions__), m.__index__ = d.__index__, m.__values__ = d.__values__, m;
            }
            function QL(d, m, F) {
                (F ? Zi(d, m, F) : m === r) ? m = 1 : m = Yn(wr(m), 0);
                var oe = d == null ? 0 : d.length;
                if (!oe || m < 1) return [];
                for(var de = 0, Ae = 0, Te = Ze(cg(oe / m)); de < oe;)Te[Ae++] = ua(d, de, de += m);
                return Te;
            }
            function $L(d) {
                for(var m = -1, F = d == null ? 0 : d.length, oe = 0, de = []; ++m < F;){
                    var Ae = d[m];
                    Ae && (de[oe++] = Ae);
                }
                return de;
            }
            function ZL() {
                var d = arguments.length;
                if (!d) return [];
                for(var m = Ze(d - 1), F = arguments[0], oe = d; oe--;)m[oe - 1] = arguments[oe];
                return Gu(hr(F) ? fo(F) : [
                    F
                ], Ai(m, 1));
            }
            var XL = Pr(function(d, m) {
                return zn(d) ? fp(d, Ai(m, 1, zn, !0)) : [];
            }), YL = Pr(function(d, m) {
                var F = ca(m);
                return zn(F) && (F = r), zn(d) ? fp(d, Ai(m, 1, zn, !0), Gt(F, 2)) : [];
            }), JL = Pr(function(d, m) {
                var F = ca(m);
                return zn(F) && (F = r), zn(d) ? fp(d, Ai(m, 1, zn, !0), r, F) : [];
            });
            function eH(d, m, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (m = F || m === r ? 1 : wr(m), ua(d, m < 0 ? 0 : m, oe)) : [];
            }
            function tH(d, m, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (m = F || m === r ? 1 : wr(m), m = oe - m, ua(d, 0, m < 0 ? 0 : m)) : [];
            }
            function rH(d, m) {
                return d && d.length ? wg(d, Gt(m, 3), !0, !0) : [];
            }
            function nH(d, m) {
                return d && d.length ? wg(d, Gt(m, 3), !0) : [];
            }
            function iH(d, m, F, oe) {
                var de = d == null ? 0 : d.length;
                return de ? (F && typeof F != "number" && Zi(d, m, F) && (F = 0, oe = de), Zz(d, m, F, oe)) : [];
            }
            function fE(d, m, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var de = F == null ? 0 : wr(F);
                return de < 0 && (de = Yn(oe + de, 0)), Y1(d, Gt(m, 3), de);
            }
            function dE(d, m, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var de = oe - 1;
                return F !== r && (de = wr(F), de = F < 0 ? Yn(oe + de, 0) : Pi(de, oe - 1)), Y1(d, Gt(m, 3), de, !0);
            }
            function hE(d) {
                var m = d == null ? 0 : d.length;
                return m ? Ai(d, 1) : [];
            }
            function oH(d) {
                var m = d == null ? 0 : d.length;
                return m ? Ai(d, O) : [];
            }
            function aH(d, m) {
                var F = d == null ? 0 : d.length;
                return F ? (m = m === r ? 1 : wr(m), Ai(d, m)) : [];
            }
            function sH(d) {
                for(var m = -1, F = d == null ? 0 : d.length, oe = {}; ++m < F;){
                    var de = d[m];
                    oe[de[0]] = de[1];
                }
                return oe;
            }
            function pE(d) {
                return d && d.length ? d[0] : r;
            }
            function uH(d, m, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var de = F == null ? 0 : wr(F);
                return de < 0 && (de = Yn(oe + de, 0)), Wf(d, m, de);
            }
            function cH(d) {
                var m = d == null ? 0 : d.length;
                return m ? ua(d, 0, -1) : [];
            }
            var lH = Pr(function(d) {
                var m = vn(d, Pw);
                return m.length && m[0] === d[0] ? vw(m) : [];
            }), fH = Pr(function(d) {
                var m = ca(d), F = vn(d, Pw);
                return m === ca(F) ? m = r : F.pop(), F.length && F[0] === d[0] ? vw(F, Gt(m, 2)) : [];
            }), dH = Pr(function(d) {
                var m = ca(d), F = vn(d, Pw);
                return m = typeof m == "function" ? m : r, m && F.pop(), F.length && F[0] === d[0] ? vw(F, r, m) : [];
            });
            function hH(d, m) {
                return d == null ? "" : cz.call(d, m);
            }
            function ca(d) {
                var m = d == null ? 0 : d.length;
                return m ? d[m - 1] : r;
            }
            function pH(d, m, F) {
                var oe = d == null ? 0 : d.length;
                if (!oe) return -1;
                var de = oe;
                return F !== r && (de = wr(F), de = de < 0 ? Yn(oe + de, 0) : Pi(de, oe - 1)), m === m ? GF(d, m, de) : Y1(d, Q7, de, !0);
            }
            function gH(d, m) {
                return d && d.length ? _9(d, wr(m)) : r;
            }
            var yH = Pr(gE);
            function gE(d, m) {
                return d && d.length && m && m.length ? _w(d, m) : d;
            }
            function mH(d, m, F) {
                return d && d.length && m && m.length ? _w(d, m, Gt(F, 2)) : d;
            }
            function bH(d, m, F) {
                return d && d.length && m && m.length ? _w(d, m, r, F) : d;
            }
            var wH = cu(function(d, m) {
                var F = d == null ? 0 : d.length, oe = mw(d, m);
                return I9(d, vn(m, function(de) {
                    return lu(de, F) ? +de : de;
                }).sort(j9)), oe;
            });
            function AH(d, m) {
                var F = [];
                if (!(d && d.length)) return F;
                var oe = -1, de = [], Ae = d.length;
                for(m = Gt(m, 3); ++oe < Ae;){
                    var Te = d[oe];
                    m(Te, oe, d) && (F.push(Te), de.push(oe));
                }
                return I9(d, de), F;
            }
            function Vw(d) {
                return d == null ? d : hz.call(d);
            }
            function vH(d, m, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (F && typeof F != "number" && Zi(d, m, F) ? (m = 0, F = oe) : (m = m == null ? 0 : wr(m), F = F === r ? oe : wr(F)), ua(d, m, F)) : [];
            }
            function EH(d, m) {
                return bg(d, m);
            }
            function SH(d, m, F) {
                return Iw(d, m, Gt(F, 2));
            }
            function xH(d, m) {
                var F = d == null ? 0 : d.length;
                if (F) {
                    var oe = bg(d, m);
                    if (oe < F && La(d[oe], m)) return oe;
                }
                return -1;
            }
            function _H(d, m) {
                return bg(d, m, !0);
            }
            function kH(d, m, F) {
                return Iw(d, m, Gt(F, 2), !0);
            }
            function OH(d, m) {
                var F = d == null ? 0 : d.length;
                if (F) {
                    var oe = bg(d, m, !0) - 1;
                    if (La(d[oe], m)) return oe;
                }
                return -1;
            }
            function IH(d) {
                return d && d.length ? T9(d) : [];
            }
            function BH(d, m) {
                return d && d.length ? T9(d, Gt(m, 2)) : [];
            }
            function TH(d) {
                var m = d == null ? 0 : d.length;
                return m ? ua(d, 1, m) : [];
            }
            function PH(d, m, F) {
                return d && d.length ? (m = F || m === r ? 1 : wr(m), ua(d, 0, m < 0 ? 0 : m)) : [];
            }
            function CH(d, m, F) {
                var oe = d == null ? 0 : d.length;
                return oe ? (m = F || m === r ? 1 : wr(m), m = oe - m, ua(d, m < 0 ? 0 : m, oe)) : [];
            }
            function MH(d, m) {
                return d && d.length ? wg(d, Gt(m, 3), !1, !0) : [];
            }
            function NH(d, m) {
                return d && d.length ? wg(d, Gt(m, 3)) : [];
            }
            var RH = Pr(function(d) {
                return Xu(Ai(d, 1, zn, !0));
            }), UH = Pr(function(d) {
                var m = ca(d);
                return zn(m) && (m = r), Xu(Ai(d, 1, zn, !0), Gt(m, 2));
            }), DH = Pr(function(d) {
                var m = ca(d);
                return m = typeof m == "function" ? m : r, Xu(Ai(d, 1, zn, !0), r, m);
            });
            function jH(d) {
                return d && d.length ? Xu(d) : [];
            }
            function FH(d, m) {
                return d && d.length ? Xu(d, Gt(m, 2)) : [];
            }
            function zH(d, m) {
                return m = typeof m == "function" ? m : r, d && d.length ? Xu(d, r, m) : [];
            }
            function Ww(d) {
                if (!(d && d.length)) return [];
                var m = 0;
                return d = Wu(d, function(F) {
                    if (zn(F)) return m = Yn(F.length, m), !0;
                }), cw(m, function(F) {
                    return vn(d, aw(F));
                });
            }
            function yE(d, m) {
                if (!(d && d.length)) return [];
                var F = Ww(d);
                return m == null ? F : vn(F, function(oe) {
                    return Ro(m, r, oe);
                });
            }
            var LH = Pr(function(d, m) {
                return zn(d) ? fp(d, m) : [];
            }), HH = Pr(function(d) {
                return Tw(Wu(d, zn));
            }), KH = Pr(function(d) {
                var m = ca(d);
                return zn(m) && (m = r), Tw(Wu(d, zn), Gt(m, 2));
            }), qH = Pr(function(d) {
                var m = ca(d);
                return m = typeof m == "function" ? m : r, Tw(Wu(d, zn), r, m);
            }), VH = Pr(Ww);
            function WH(d, m) {
                return N9(d || [], m || [], lp);
            }
            function GH(d, m) {
                return N9(d || [], m || [], pp);
            }
            var QH = Pr(function(d) {
                var m = d.length, F = m > 1 ? d[m - 1] : r;
                return F = typeof F == "function" ? (d.pop(), F) : r, yE(d, F);
            });
            function mE(d) {
                var m = be(d);
                return m.__chain__ = !0, m;
            }
            function $H(d, m) {
                return m(d), d;
            }
            function Ig(d, m) {
                return m(d);
            }
            var ZH = cu(function(d) {
                var m = d.length, F = m ? d[0] : 0, oe = this.__wrapped__, de = function(Ae) {
                    return mw(Ae, d);
                };
                return m > 1 || this.__actions__.length || !(oe instanceof jr) || !lu(F) ? this.thru(de) : (oe = oe.slice(F, +F + (m ? 1 : 0)), oe.__actions__.push({
                    func: Ig,
                    args: [
                        de
                    ],
                    thisArg: r
                }), new aa(oe, this.__chain__).thru(function(Ae) {
                    return m && !Ae.length && Ae.push(r), Ae;
                }));
            });
            function XH() {
                return mE(this);
            }
            function YH() {
                return new aa(this.value(), this.__chain__);
            }
            function JH() {
                this.__values__ === r && (this.__values__ = PE(this.value()));
                var d = this.__index__ >= this.__values__.length, m = d ? r : this.__values__[this.__index__++];
                return {
                    done: d,
                    value: m
                };
            }
            function eK() {
                return this;
            }
            function tK(d) {
                for(var m, F = this; F instanceof hg;){
                    var oe = lE(F);
                    oe.__index__ = 0, oe.__values__ = r, m ? de.__wrapped__ = oe : m = oe;
                    var de = oe;
                    F = F.__wrapped__;
                }
                return de.__wrapped__ = d, m;
            }
            function rK() {
                var d = this.__wrapped__;
                if (d instanceof jr) {
                    var m = d;
                    return this.__actions__.length && (m = new jr(this)), m = m.reverse(), m.__actions__.push({
                        func: Ig,
                        args: [
                            Vw
                        ],
                        thisArg: r
                    }), new aa(m, this.__chain__);
                }
                return this.thru(Vw);
            }
            function nK() {
                return M9(this.__wrapped__, this.__actions__);
            }
            var iK = Ag(function(d, m, F) {
                on.call(d, F) ? ++d[F] : su(d, F, 1);
            });
            function oK(d, m, F) {
                var oe = hr(d) ? W7 : $z;
                return F && Zi(d, m, F) && (m = r), oe(d, Gt(m, 3));
            }
            function aK(d, m) {
                var F = hr(d) ? Wu : y9;
                return F(d, Gt(m, 3));
            }
            var sK = q9(fE), uK = q9(dE);
            function cK(d, m) {
                return Ai(Bg(d, m), 1);
            }
            function lK(d, m) {
                return Ai(Bg(d, m), O);
            }
            function fK(d, m, F) {
                return F = F === r ? 1 : wr(F), Ai(Bg(d, m), F);
            }
            function bE(d, m) {
                var F = hr(d) ? ia : Zu;
                return F(d, Gt(m, 3));
            }
            function wE(d, m) {
                var F = hr(d) ? TF : g9;
                return F(d, Gt(m, 3));
            }
            var dK = Ag(function(d, m, F) {
                on.call(d, F) ? d[F].push(m) : su(d, F, [
                    m
                ]);
            });
            function hK(d, m, F, oe) {
                d = ho(d) ? d : id(d), F = F && !oe ? wr(F) : 0;
                var de = d.length;
                return F < 0 && (F = Yn(de + F, 0)), Ng(d) ? F <= de && d.indexOf(m, F) > -1 : !!de && Wf(d, m, F) > -1;
            }
            var pK = Pr(function(d, m, F) {
                var oe = -1, de = typeof m == "function", Ae = ho(d) ? Ze(d.length) : [];
                return Zu(d, function(Te) {
                    Ae[++oe] = de ? Ro(m, Te, F) : dp(Te, m, F);
                }), Ae;
            }), gK = Ag(function(d, m, F) {
                su(d, F, m);
            });
            function Bg(d, m) {
                var F = hr(d) ? vn : E9;
                return F(d, Gt(m, 3));
            }
            function yK(d, m, F, oe) {
                return d == null ? [] : (hr(m) || (m = m == null ? [] : [
                    m
                ]), F = oe ? r : F, hr(F) || (F = F == null ? [] : [
                    F
                ]), k9(d, m, F));
            }
            var mK = Ag(function(d, m, F) {
                d[F ? 0 : 1].push(m);
            }, function() {
                return [
                    [],
                    []
                ];
            });
            function bK(d, m, F) {
                var oe = hr(d) ? iw : Z7, de = arguments.length < 3;
                return oe(d, Gt(m, 4), F, de, Zu);
            }
            function wK(d, m, F) {
                var oe = hr(d) ? PF : Z7, de = arguments.length < 3;
                return oe(d, Gt(m, 4), F, de, g9);
            }
            function AK(d, m) {
                var F = hr(d) ? Wu : y9;
                return F(d, Cg(Gt(m, 3)));
            }
            function vK(d) {
                var m = hr(d) ? f9 : hL;
                return m(d);
            }
            function EK(d, m, F) {
                (F ? Zi(d, m, F) : m === r) ? m = 1 : m = wr(m);
                var oe = hr(d) ? qz : pL;
                return oe(d, m);
            }
            function SK(d) {
                var m = hr(d) ? Vz : yL;
                return m(d);
            }
            function xK(d) {
                if (d == null) return 0;
                if (ho(d)) return Ng(d) ? Qf(d) : d.length;
                var m = Ci(d);
                return m == C || m == Ge ? d.size : Sw(d).length;
            }
            function _K(d, m, F) {
                var oe = hr(d) ? ow : mL;
                return F && Zi(d, m, F) && (m = r), oe(d, Gt(m, 3));
            }
            var kK = Pr(function(d, m) {
                if (d == null) return [];
                var F = m.length;
                return F > 1 && Zi(d, m[0], m[1]) ? m = [] : F > 2 && Zi(m[0], m[1], m[2]) && (m = [
                    m[0]
                ]), k9(d, Ai(m, 1), []);
            }), Tg = az || function() {
                return wi.Date.now();
            };
            function OK(d, m) {
                if (typeof m != "function") throw new oa(a);
                return d = wr(d), function() {
                    if (--d < 1) return m.apply(this, arguments);
                };
            }
            function AE(d, m, F) {
                return m = F ? r : m, m = d && m == null ? d.length : m, uu(d, ee, r, r, r, r, m);
            }
            function vE(d, m) {
                var F;
                if (typeof m != "function") throw new oa(a);
                return d = wr(d), function() {
                    return --d > 0 && (F = m.apply(this, arguments)), d <= 1 && (m = r), F;
                };
            }
            var Gw = Pr(function(d, m, F) {
                var oe = P;
                if (F.length) {
                    var de = Qu(F, rd(Gw));
                    oe |= $;
                }
                return uu(d, oe, m, F, de);
            }), EE = Pr(function(d, m, F) {
                var oe = P | M;
                if (F.length) {
                    var de = Qu(F, rd(EE));
                    oe |= $;
                }
                return uu(m, oe, d, F, de);
            });
            function SE(d, m, F) {
                m = F ? r : m;
                var oe = uu(d, z, r, r, r, r, r, m);
                return oe.placeholder = SE.placeholder, oe;
            }
            function xE(d, m, F) {
                m = F ? r : m;
                var oe = uu(d, K, r, r, r, r, r, m);
                return oe.placeholder = xE.placeholder, oe;
            }
            function _E(d, m, F) {
                var oe, de, Ae, Te, Ne, Le, at = 0, ct = !1, ft = !1, St = !0;
                if (typeof d != "function") throw new oa(a);
                m = la(m) || 0, _n(F) && (ct = !!F.leading, ft = "maxWait" in F, Ae = ft ? Yn(la(F.maxWait) || 0, m) : Ae, St = "trailing" in F ? !!F.trailing : St);
                function jt(Ln) {
                    var Ha = oe, hu = de;
                    return oe = de = r, at = Ln, Te = d.apply(hu, Ha), Te;
                }
                function Qt(Ln) {
                    return at = Ln, Ne = mp(Rr, m), ct ? jt(Ln) : Te;
                }
                function xr(Ln) {
                    var Ha = Ln - Le, hu = Ln - at, qE = m - Ha;
                    return ft ? Pi(qE, Ae - hu) : qE;
                }
                function $t(Ln) {
                    var Ha = Ln - Le, hu = Ln - at;
                    return Le === r || Ha >= m || Ha < 0 || ft && hu >= Ae;
                }
                function Rr() {
                    var Ln = Tg();
                    if ($t(Ln)) return Hr(Ln);
                    Ne = mp(Rr, xr(Ln));
                }
                function Hr(Ln) {
                    return Ne = r, St && oe ? jt(Ln) : (oe = de = r, Te);
                }
                function Fo() {
                    Ne !== r && R9(Ne), at = 0, oe = Le = de = Ne = r;
                }
                function Xi() {
                    return Ne === r ? Te : Hr(Tg());
                }
                function zo() {
                    var Ln = Tg(), Ha = $t(Ln);
                    if (oe = arguments, de = this, Le = Ln, Ha) {
                        if (Ne === r) return Qt(Le);
                        if (ft) return R9(Ne), Ne = mp(Rr, m), jt(Le);
                    }
                    return Ne === r && (Ne = mp(Rr, m)), Te;
                }
                return zo.cancel = Fo, zo.flush = Xi, zo;
            }
            var IK = Pr(function(d, m) {
                return p9(d, 1, m);
            }), BK = Pr(function(d, m, F) {
                return p9(d, la(m) || 0, F);
            });
            function TK(d) {
                return uu(d, U);
            }
            function Pg(d, m) {
                if (typeof d != "function" || m != null && typeof m != "function") throw new oa(a);
                var F = function() {
                    var oe = arguments, de = m ? m.apply(this, oe) : oe[0], Ae = F.cache;
                    if (Ae.has(de)) return Ae.get(de);
                    var Te = d.apply(this, oe);
                    return F.cache = Ae.set(de, Te) || Ae, Te;
                };
                return F.cache = new (Pg.Cache || au)(), F;
            }
            Pg.Cache = au;
            function Cg(d) {
                if (typeof d != "function") throw new oa(a);
                return function() {
                    var m = arguments;
                    switch(m.length){
                        case 0:
                            return !d.call(this);
                        case 1:
                            return !d.call(this, m[0]);
                        case 2:
                            return !d.call(this, m[0], m[1]);
                        case 3:
                            return !d.call(this, m[0], m[1], m[2]);
                    }
                    return !d.apply(this, m);
                };
            }
            function PK(d) {
                return vE(2, d);
            }
            var CK = bL(function(d, m) {
                m = m.length == 1 && hr(m[0]) ? vn(m[0], Uo(Gt())) : vn(Ai(m, 1), Uo(Gt()));
                var F = m.length;
                return Pr(function(oe) {
                    for(var de = -1, Ae = Pi(oe.length, F); ++de < Ae;)oe[de] = m[de].call(this, oe[de]);
                    return Ro(d, this, oe);
                });
            }), Qw = Pr(function(d, m) {
                var F = Qu(m, rd(Qw));
                return uu(d, $, r, m, F);
            }), kE = Pr(function(d, m) {
                var F = Qu(m, rd(kE));
                return uu(d, ne, r, m, F);
            }), MK = cu(function(d, m) {
                return uu(d, q, r, r, r, m);
            });
            function NK(d, m) {
                if (typeof d != "function") throw new oa(a);
                return m = m === r ? m : wr(m), Pr(d, m);
            }
            function RK(d, m) {
                if (typeof d != "function") throw new oa(a);
                return m = m == null ? 0 : Yn(wr(m), 0), Pr(function(F) {
                    var oe = F[m], de = Ju(F, 0, m);
                    return oe && Gu(de, oe), Ro(d, this, de);
                });
            }
            function UK(d, m, F) {
                var oe = !0, de = !0;
                if (typeof d != "function") throw new oa(a);
                return _n(F) && (oe = "leading" in F ? !!F.leading : oe, de = "trailing" in F ? !!F.trailing : de), _E(d, m, {
                    leading: oe,
                    maxWait: m,
                    trailing: de
                });
            }
            function DK(d) {
                return AE(d, 1);
            }
            function jK(d, m) {
                return Qw(Cw(m), d);
            }
            function FK() {
                if (!arguments.length) return [];
                var d = arguments[0];
                return hr(d) ? d : [
                    d
                ];
            }
            function zK(d) {
                return sa(d, y);
            }
            function LK(d, m) {
                return m = typeof m == "function" ? m : r, sa(d, y, m);
            }
            function HK(d) {
                return sa(d, f | y);
            }
            function KK(d, m) {
                return m = typeof m == "function" ? m : r, sa(d, f | y, m);
            }
            function qK(d, m) {
                return m == null || h9(d, m, li(m));
            }
            function La(d, m) {
                return d === m || d !== d && m !== m;
            }
            var VK = xg(Aw), WK = xg(function(d, m) {
                return d >= m;
            }), Sl = w9(/* @__PURE__ */ function() {
                return arguments;
            }()) ? w9 : function(d) {
                return Un(d) && on.call(d, "callee") && !o9.call(d, "callee");
            }, hr = Ze.isArray, GK = z7 ? Uo(z7) : tL;
            function ho(d) {
                return d != null && Mg(d.length) && !fu(d);
            }
            function zn(d) {
                return Un(d) && ho(d);
            }
            function QK(d) {
                return d === !0 || d === !1 || Un(d) && $i(d) == ie;
            }
            var ec = uz || oA, $K = L7 ? Uo(L7) : rL;
            function ZK(d) {
                return Un(d) && d.nodeType === 1 && !bp(d);
            }
            function XK(d) {
                if (d == null) return !0;
                if (ho(d) && (hr(d) || typeof d == "string" || typeof d.splice == "function" || ec(d) || nd(d) || Sl(d))) return !d.length;
                var m = Ci(d);
                if (m == C || m == Ge) return !d.size;
                if (yp(d)) return !Sw(d).length;
                for(var F in d)if (on.call(d, F)) return !1;
                return !0;
            }
            function YK(d, m) {
                return hp(d, m);
            }
            function JK(d, m, F) {
                F = typeof F == "function" ? F : r;
                var oe = F ? F(d, m) : r;
                return oe === r ? hp(d, m, r, F) : !!oe;
            }
            function $w(d) {
                if (!Un(d)) return !1;
                var m = $i(d);
                return m == Ie || m == ve || typeof d.message == "string" && typeof d.name == "string" && !bp(d);
            }
            function eq(d) {
                return typeof d == "number" && s9(d);
            }
            function fu(d) {
                if (!_n(d)) return !1;
                var m = $i(d);
                return m == Me || m == Re || m == Z || m == nt;
            }
            function OE(d) {
                return typeof d == "number" && d == wr(d);
            }
            function Mg(d) {
                return typeof d == "number" && d > -1 && d % 1 == 0 && d <= I;
            }
            function _n(d) {
                var m = typeof d;
                return d != null && (m == "object" || m == "function");
            }
            function Un(d) {
                return d != null && typeof d == "object";
            }
            var IE = H7 ? Uo(H7) : iL;
            function tq(d, m) {
                return d === m || Ew(d, m, Fw(m));
            }
            function rq(d, m, F) {
                return F = typeof F == "function" ? F : r, Ew(d, m, Fw(m), F);
            }
            function nq(d) {
                return BE(d) && d != +d;
            }
            function iq(d) {
                if (LL(d)) throw new lr(o);
                return A9(d);
            }
            function oq(d) {
                return d === null;
            }
            function aq(d) {
                return d == null;
            }
            function BE(d) {
                return typeof d == "number" || Un(d) && $i(d) == J;
            }
            function bp(d) {
                if (!Un(d) || $i(d) != je) return !1;
                var m = ag(d);
                if (m === null) return !0;
                var F = on.call(m, "constructor") && m.constructor;
                return typeof F == "function" && F instanceof F && rg.call(F) == rz;
            }
            var Zw = K7 ? Uo(K7) : oL;
            function sq(d) {
                return OE(d) && d >= -I && d <= I;
            }
            var TE = q7 ? Uo(q7) : aL;
            function Ng(d) {
                return typeof d == "string" || !hr(d) && Un(d) && $i(d) == p;
            }
            function jo(d) {
                return typeof d == "symbol" || Un(d) && $i(d) == A;
            }
            var nd = V7 ? Uo(V7) : sL;
            function uq(d) {
                return d === r;
            }
            function cq(d) {
                return Un(d) && Ci(d) == re;
            }
            function lq(d) {
                return Un(d) && $i(d) == le;
            }
            var fq = xg(xw), dq = xg(function(d, m) {
                return d <= m;
            });
            function PE(d) {
                if (!d) return [];
                if (ho(d)) return Ng(d) ? Fa(d) : fo(d);
                if (op && d[op]) return qF(d[op]());
                var m = Ci(d), F = m == C ? fw : m == Ge ? J1 : id;
                return F(d);
            }
            function du(d) {
                if (!d) return d === 0 ? d : 0;
                if (d = la(d), d === O || d === -O) {
                    var m = d < 0 ? -1 : 1;
                    return m * x;
                }
                return d === d ? d : 0;
            }
            function wr(d) {
                var m = du(d), F = m % 1;
                return m === m ? F ? m - F : m : 0;
            }
            function CE(d) {
                return d ? wl(wr(d), 0, j) : 0;
            }
            function la(d) {
                if (typeof d == "number") return d;
                if (jo(d)) return R;
                if (_n(d)) {
                    var m = typeof d.valueOf == "function" ? d.valueOf() : d;
                    d = _n(m) ? m + "" : m;
                }
                if (typeof d != "string") return d === 0 ? d : +d;
                d = X7(d);
                var F = Et.test(d);
                return F || mt.test(d) ? OF(d.slice(2), F ? 2 : 8) : rt.test(d) ? R : +d;
            }
            function ME(d) {
                return ys(d, po(d));
            }
            function hq(d) {
                return d ? wl(wr(d), -I, I) : d === 0 ? d : 0;
            }
            function Jr(d) {
                return d == null ? "" : Do(d);
            }
            var pq = ed(function(d, m) {
                if (yp(m) || ho(m)) {
                    ys(m, li(m), d);
                    return;
                }
                for(var F in m)on.call(m, F) && lp(d, F, m[F]);
            }), NE = ed(function(d, m) {
                ys(m, po(m), d);
            }), Rg = ed(function(d, m, F, oe) {
                ys(m, po(m), d, oe);
            }), gq = ed(function(d, m, F, oe) {
                ys(m, li(m), d, oe);
            }), yq = cu(mw);
            function mq(d, m) {
                var F = Jf(d);
                return m == null ? F : d9(F, m);
            }
            var bq = Pr(function(d, m) {
                d = hn(d);
                var F = -1, oe = m.length, de = oe > 2 ? m[2] : r;
                for(de && Zi(m[0], m[1], de) && (oe = 1); ++F < oe;)for(var Ae = m[F], Te = po(Ae), Ne = -1, Le = Te.length; ++Ne < Le;){
                    var at = Te[Ne], ct = d[at];
                    (ct === r || La(ct, Zf[at]) && !on.call(d, at)) && (d[at] = Ae[at]);
                }
                return d;
            }), wq = Pr(function(d) {
                return d.push(r, X9), Ro(RE, r, d);
            });
            function Aq(d, m) {
                return G7(d, Gt(m, 3), gs);
            }
            function vq(d, m) {
                return G7(d, Gt(m, 3), ww);
            }
            function Eq(d, m) {
                return d == null ? d : bw(d, Gt(m, 3), po);
            }
            function Sq(d, m) {
                return d == null ? d : m9(d, Gt(m, 3), po);
            }
            function xq(d, m) {
                return d && gs(d, Gt(m, 3));
            }
            function _q(d, m) {
                return d && ww(d, Gt(m, 3));
            }
            function kq(d) {
                return d == null ? [] : yg(d, li(d));
            }
            function Oq(d) {
                return d == null ? [] : yg(d, po(d));
            }
            function Xw(d, m, F) {
                var oe = d == null ? r : Al(d, m);
                return oe === r ? F : oe;
            }
            function Iq(d, m) {
                return d != null && eE(d, m, Xz);
            }
            function Yw(d, m) {
                return d != null && eE(d, m, Yz);
            }
            var Bq = W9(function(d, m, F) {
                m != null && typeof m.toString != "function" && (m = ng.call(m)), d[m] = F;
            }, eA(go)), Tq = W9(function(d, m, F) {
                m != null && typeof m.toString != "function" && (m = ng.call(m)), on.call(d, m) ? d[m].push(F) : d[m] = [
                    F
                ];
            }, Gt), Pq = Pr(dp);
            function li(d) {
                return ho(d) ? l9(d) : Sw(d);
            }
            function po(d) {
                return ho(d) ? l9(d, !0) : uL(d);
            }
            function Cq(d, m) {
                var F = {};
                return m = Gt(m, 3), gs(d, function(oe, de, Ae) {
                    su(F, m(oe, de, Ae), oe);
                }), F;
            }
            function Mq(d, m) {
                var F = {};
                return m = Gt(m, 3), gs(d, function(oe, de, Ae) {
                    su(F, de, m(oe, de, Ae));
                }), F;
            }
            var Nq = ed(function(d, m, F) {
                mg(d, m, F);
            }), RE = ed(function(d, m, F, oe) {
                mg(d, m, F, oe);
            }), Rq = cu(function(d, m) {
                var F = {};
                if (d == null) return F;
                var oe = !1;
                m = vn(m, function(Ae) {
                    return Ae = Yu(Ae, d), oe || (oe = Ae.length > 1), Ae;
                }), ys(d, Dw(d), F), oe && (F = sa(F, f | h | y, BL));
                for(var de = m.length; de--;)Bw(F, m[de]);
                return F;
            });
            function Uq(d, m) {
                return UE(d, Cg(Gt(m)));
            }
            var Dq = cu(function(d, m) {
                return d == null ? {} : lL(d, m);
            });
            function UE(d, m) {
                if (d == null) return {};
                var F = vn(Dw(d), function(oe) {
                    return [
                        oe
                    ];
                });
                return m = Gt(m), O9(d, F, function(oe, de) {
                    return m(oe, de[0]);
                });
            }
            function jq(d, m, F) {
                m = Yu(m, d);
                var oe = -1, de = m.length;
                for(de || (de = 1, d = r); ++oe < de;){
                    var Ae = d == null ? r : d[ms(m[oe])];
                    Ae === r && (oe = de, Ae = F), d = fu(Ae) ? Ae.call(d) : Ae;
                }
                return d;
            }
            function Fq(d, m, F) {
                return d == null ? d : pp(d, m, F);
            }
            function zq(d, m, F, oe) {
                return oe = typeof oe == "function" ? oe : r, d == null ? d : pp(d, m, F, oe);
            }
            var DE = $9(li), jE = $9(po);
            function Lq(d, m, F) {
                var oe = hr(d), de = oe || ec(d) || nd(d);
                if (m = Gt(m, 4), F == null) {
                    var Ae = d && d.constructor;
                    de ? F = oe ? new Ae() : [] : _n(d) ? F = fu(Ae) ? Jf(ag(d)) : {} : F = {};
                }
                return (de ? ia : gs)(d, function(Te, Ne, Le) {
                    return m(F, Te, Ne, Le);
                }), F;
            }
            function Hq(d, m) {
                return d == null ? !0 : Bw(d, m);
            }
            function Kq(d, m, F) {
                return d == null ? d : C9(d, m, Cw(F));
            }
            function qq(d, m, F, oe) {
                return oe = typeof oe == "function" ? oe : r, d == null ? d : C9(d, m, Cw(F), oe);
            }
            function id(d) {
                return d == null ? [] : lw(d, li(d));
            }
            function Vq(d) {
                return d == null ? [] : lw(d, po(d));
            }
            function Wq(d, m, F) {
                return F === r && (F = m, m = r), F !== r && (F = la(F), F = F === F ? F : 0), m !== r && (m = la(m), m = m === m ? m : 0), wl(la(d), m, F);
            }
            function Gq(d, m, F) {
                return m = du(m), F === r ? (F = m, m = 0) : F = du(F), d = la(d), Jz(d, m, F);
            }
            function Qq(d, m, F) {
                if (F && typeof F != "boolean" && Zi(d, m, F) && (m = F = r), F === r && (typeof m == "boolean" ? (F = m, m = r) : typeof d == "boolean" && (F = d, d = r)), d === r && m === r ? (d = 0, m = 1) : (d = du(d), m === r ? (m = d, d = 0) : m = du(m)), d > m) {
                    var oe = d;
                    d = m, m = oe;
                }
                if (F || d % 1 || m % 1) {
                    var de = u9();
                    return Pi(d + de * (m - d + kF("1e-" + ((de + "").length - 1))), m);
                }
                return kw(d, m);
            }
            var $q = td(function(d, m, F) {
                return m = m.toLowerCase(), d + (F ? FE(m) : m);
            });
            function FE(d) {
                return Jw(Jr(d).toLowerCase());
            }
            function zE(d) {
                return d = Jr(d), d && d.replace(Jt, FF).replace(yF, "");
            }
            function Zq(d, m, F) {
                d = Jr(d), m = Do(m);
                var oe = d.length;
                F = F === r ? oe : wl(wr(F), 0, oe);
                var de = F;
                return F -= m.length, F >= 0 && d.slice(F, de) == m;
            }
            function Xq(d) {
                return d = Jr(d), d && Wt.test(d) ? d.replace(br, zF) : d;
            }
            function Yq(d) {
                return d = Jr(d), d && Ce.test(d) ? d.replace(ke, "\\$&") : d;
            }
            var Jq = td(function(d, m, F) {
                return d + (F ? "-" : "") + m.toLowerCase();
            }), eV = td(function(d, m, F) {
                return d + (F ? " " : "") + m.toLowerCase();
            }), tV = K9("toLowerCase");
            function rV(d, m, F) {
                d = Jr(d), m = wr(m);
                var oe = m ? Qf(d) : 0;
                if (!m || oe >= m) return d;
                var de = (m - oe) / 2;
                return Sg(lg(de), F) + d + Sg(cg(de), F);
            }
            function nV(d, m, F) {
                d = Jr(d), m = wr(m);
                var oe = m ? Qf(d) : 0;
                return m && oe < m ? d + Sg(m - oe, F) : d;
            }
            function iV(d, m, F) {
                d = Jr(d), m = wr(m);
                var oe = m ? Qf(d) : 0;
                return m && oe < m ? Sg(m - oe, F) + d : d;
            }
            function oV(d, m, F) {
                return F || m == null ? m = 0 : m && (m = +m), dz(Jr(d).replace(De, ""), m || 0);
            }
            function aV(d, m, F) {
                return (F ? Zi(d, m, F) : m === r) ? m = 1 : m = wr(m), Ow(Jr(d), m);
            }
            function sV() {
                var d = arguments, m = Jr(d[0]);
                return d.length < 3 ? m : m.replace(d[1], d[2]);
            }
            var uV = td(function(d, m, F) {
                return d + (F ? "_" : "") + m.toLowerCase();
            });
            function cV(d, m, F) {
                return F && typeof F != "number" && Zi(d, m, F) && (m = F = r), F = F === r ? j : F >>> 0, F ? (d = Jr(d), d && (typeof m == "string" || m != null && !Zw(m)) && (m = Do(m), !m && Gf(d)) ? Ju(Fa(d), 0, F) : d.split(m, F)) : [];
            }
            var lV = td(function(d, m, F) {
                return d + (F ? " " : "") + Jw(m);
            });
            function fV(d, m, F) {
                return d = Jr(d), F = F == null ? 0 : wl(wr(F), 0, d.length), m = Do(m), d.slice(F, F + m.length) == m;
            }
            function dV(d, m, F) {
                var oe = be.templateSettings;
                F && Zi(d, m, F) && (m = r), d = Jr(d), m = Rg({}, m, oe, Z9);
                var de = Rg({}, m.imports, oe.imports, Z9), Ae = li(de), Te = lw(de, Ae), Ne, Le, at = 0, ct = m.interpolate || we, ft = "__p += '", St = dw((m.escape || we).source + "|" + ct.source + "|" + (ct === Lt ? Pt : we).source + "|" + (m.evaluate || we).source + "|$", "g"), jt = "//# sourceURL=" + (on.call(m, "sourceURL") ? (m.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++vF + "]") + `
`;
                d.replace(St, function($t, Rr, Hr, Fo, Xi, zo) {
                    return Hr || (Hr = Fo), ft += d.slice(at, zo).replace(Tr, LF), Rr && (Ne = !0, ft += `' +
__e(` + Rr + `) +
'`), Xi && (Le = !0, ft += `';
` + Xi + `;
__p += '`), Hr && (ft += `' +
((__t = (` + Hr + `)) == null ? '' : __t) +
'`), at = zo + $t.length, $t;
                }), ft += `';
`;
                var Qt = on.call(m, "variable") && m.variable;
                if (!Qt) ft = `with (obj) {
` + ft + `
}
`;
                else if (dt.test(Qt)) throw new lr(s);
                ft = (Le ? ft.replace(yt, "") : ft).replace(Ut, "$1").replace(Xe, "$1;"), ft = "function(" + (Qt || "obj") + `) {
` + (Qt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Ne ? ", __e = _.escape" : "") + (Le ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ft + `return __p
}`;
                var xr = HE(function() {
                    return Xr(Ae, jt + "return " + ft).apply(r, Te);
                });
                if (xr.source = ft, $w(xr)) throw xr;
                return xr;
            }
            function hV(d) {
                return Jr(d).toLowerCase();
            }
            function pV(d) {
                return Jr(d).toUpperCase();
            }
            function gV(d, m, F) {
                if (d = Jr(d), d && (F || m === r)) return X7(d);
                if (!d || !(m = Do(m))) return d;
                var oe = Fa(d), de = Fa(m), Ae = Y7(oe, de), Te = J7(oe, de) + 1;
                return Ju(oe, Ae, Te).join("");
            }
            function yV(d, m, F) {
                if (d = Jr(d), d && (F || m === r)) return d.slice(0, t9(d) + 1);
                if (!d || !(m = Do(m))) return d;
                var oe = Fa(d), de = J7(oe, Fa(m)) + 1;
                return Ju(oe, 0, de).join("");
            }
            function mV(d, m, F) {
                if (d = Jr(d), d && (F || m === r)) return d.replace(De, "");
                if (!d || !(m = Do(m))) return d;
                var oe = Fa(d), de = Y7(oe, Fa(m));
                return Ju(oe, de).join("");
            }
            function bV(d, m) {
                var F = Q, oe = v;
                if (_n(m)) {
                    var de = "separator" in m ? m.separator : de;
                    F = "length" in m ? wr(m.length) : F, oe = "omission" in m ? Do(m.omission) : oe;
                }
                d = Jr(d);
                var Ae = d.length;
                if (Gf(d)) {
                    var Te = Fa(d);
                    Ae = Te.length;
                }
                if (F >= Ae) return d;
                var Ne = F - Qf(oe);
                if (Ne < 1) return oe;
                var Le = Te ? Ju(Te, 0, Ne).join("") : d.slice(0, Ne);
                if (de === r) return Le + oe;
                if (Te && (Ne += Le.length - Ne), Zw(de)) {
                    if (d.slice(Ne).search(de)) {
                        var at, ct = Le;
                        for(de.global || (de = dw(de.source, Jr(Rt.exec(de)) + "g")), de.lastIndex = 0; at = de.exec(ct);)var ft = at.index;
                        Le = Le.slice(0, ft === r ? Ne : ft);
                    }
                } else if (d.indexOf(Do(de), Ne) != Ne) {
                    var St = Le.lastIndexOf(de);
                    St > -1 && (Le = Le.slice(0, St));
                }
                return Le + oe;
            }
            function wV(d) {
                return d = Jr(d), d && Lr.test(d) ? d.replace(_t, QF) : d;
            }
            var AV = td(function(d, m, F) {
                return d + (F ? " " : "") + m.toUpperCase();
            }), Jw = K9("toUpperCase");
            function LE(d, m, F) {
                return d = Jr(d), m = F ? r : m, m === r ? KF(d) ? XF(d) : NF(d) : d.match(m) || [];
            }
            var HE = Pr(function(d, m) {
                try {
                    return Ro(d, r, m);
                } catch (F) {
                    return $w(F) ? F : new lr(F);
                }
            }), vV = cu(function(d, m) {
                return ia(m, function(F) {
                    F = ms(F), su(d, F, Gw(d[F], d));
                }), d;
            });
            function EV(d) {
                var m = d == null ? 0 : d.length, F = Gt();
                return d = m ? vn(d, function(oe) {
                    if (typeof oe[1] != "function") throw new oa(a);
                    return [
                        F(oe[0]),
                        oe[1]
                    ];
                }) : [], Pr(function(oe) {
                    for(var de = -1; ++de < m;){
                        var Ae = d[de];
                        if (Ro(Ae[0], this, oe)) return Ro(Ae[1], this, oe);
                    }
                });
            }
            function SV(d) {
                return Qz(sa(d, f));
            }
            function eA(d) {
                return function() {
                    return d;
                };
            }
            function xV(d, m) {
                return d == null || d !== d ? m : d;
            }
            var _V = V9(), kV = V9(!0);
            function go(d) {
                return d;
            }
            function tA(d) {
                return v9(typeof d == "function" ? d : sa(d, f));
            }
            function OV(d) {
                return S9(sa(d, f));
            }
            function IV(d, m) {
                return x9(d, sa(m, f));
            }
            var BV = Pr(function(d, m) {
                return function(F) {
                    return dp(F, d, m);
                };
            }), TV = Pr(function(d, m) {
                return function(F) {
                    return dp(d, F, m);
                };
            });
            function rA(d, m, F) {
                var oe = li(m), de = yg(m, oe);
                F == null && !(_n(m) && (de.length || !oe.length)) && (F = m, m = d, d = this, de = yg(m, li(m)));
                var Ae = !(_n(F) && "chain" in F) || !!F.chain, Te = fu(d);
                return ia(de, function(Ne) {
                    var Le = m[Ne];
                    d[Ne] = Le, Te && (d.prototype[Ne] = function() {
                        var at = this.__chain__;
                        if (Ae || at) {
                            var ct = d(this.__wrapped__), ft = ct.__actions__ = fo(this.__actions__);
                            return ft.push({
                                func: Le,
                                args: arguments,
                                thisArg: d
                            }), ct.__chain__ = at, ct;
                        }
                        return Le.apply(d, Gu([
                            this.value()
                        ], arguments));
                    });
                }), d;
            }
            function PV() {
                return wi._ === this && (wi._ = nz), this;
            }
            function nA() {}
            function CV(d) {
                return d = wr(d), Pr(function(m) {
                    return _9(m, d);
                });
            }
            var MV = Nw(vn), NV = Nw(W7), RV = Nw(ow);
            function KE(d) {
                return Lw(d) ? aw(ms(d)) : fL(d);
            }
            function UV(d) {
                return function(m) {
                    return d == null ? r : Al(d, m);
                };
            }
            var DV = G9(), jV = G9(!0);
            function iA() {
                return [];
            }
            function oA() {
                return !1;
            }
            function FV() {
                return {};
            }
            function zV() {
                return "";
            }
            function LV() {
                return !0;
            }
            function HV(d, m) {
                if (d = wr(d), d < 1 || d > I) return [];
                var F = j, oe = Pi(d, j);
                m = Gt(m), d -= j;
                for(var de = cw(oe, m); ++F < d;)m(F);
                return de;
            }
            function KV(d) {
                return hr(d) ? vn(d, ms) : jo(d) ? [
                    d
                ] : fo(cE(Jr(d)));
            }
            function qV(d) {
                var m = ++tz;
                return Jr(d) + m;
            }
            var VV = Eg(function(d, m) {
                return d + m;
            }, 0), WV = Rw("ceil"), GV = Eg(function(d, m) {
                return d / m;
            }, 1), QV = Rw("floor");
            function $V(d) {
                return d && d.length ? gg(d, go, Aw) : r;
            }
            function ZV(d, m) {
                return d && d.length ? gg(d, Gt(m, 2), Aw) : r;
            }
            function XV(d) {
                return $7(d, go);
            }
            function YV(d, m) {
                return $7(d, Gt(m, 2));
            }
            function JV(d) {
                return d && d.length ? gg(d, go, xw) : r;
            }
            function eW(d, m) {
                return d && d.length ? gg(d, Gt(m, 2), xw) : r;
            }
            var tW = Eg(function(d, m) {
                return d * m;
            }, 1), rW = Rw("round"), nW = Eg(function(d, m) {
                return d - m;
            }, 0);
            function iW(d) {
                return d && d.length ? uw(d, go) : 0;
            }
            function oW(d, m) {
                return d && d.length ? uw(d, Gt(m, 2)) : 0;
            }
            return be.after = OK, be.ary = AE, be.assign = pq, be.assignIn = NE, be.assignInWith = Rg, be.assignWith = gq, be.at = yq, be.before = vE, be.bind = Gw, be.bindAll = vV, be.bindKey = EE, be.castArray = FK, be.chain = mE, be.chunk = QL, be.compact = $L, be.concat = ZL, be.cond = EV, be.conforms = SV, be.constant = eA, be.countBy = iK, be.create = mq, be.curry = SE, be.curryRight = xE, be.debounce = _E, be.defaults = bq, be.defaultsDeep = wq, be.defer = IK, be.delay = BK, be.difference = XL, be.differenceBy = YL, be.differenceWith = JL, be.drop = eH, be.dropRight = tH, be.dropRightWhile = rH, be.dropWhile = nH, be.fill = iH, be.filter = aK, be.flatMap = cK, be.flatMapDeep = lK, be.flatMapDepth = fK, be.flatten = hE, be.flattenDeep = oH, be.flattenDepth = aH, be.flip = TK, be.flow = _V, be.flowRight = kV, be.fromPairs = sH, be.functions = kq, be.functionsIn = Oq, be.groupBy = dK, be.initial = cH, be.intersection = lH, be.intersectionBy = fH, be.intersectionWith = dH, be.invert = Bq, be.invertBy = Tq, be.invokeMap = pK, be.iteratee = tA, be.keyBy = gK, be.keys = li, be.keysIn = po, be.map = Bg, be.mapKeys = Cq, be.mapValues = Mq, be.matches = OV, be.matchesProperty = IV, be.memoize = Pg, be.merge = Nq, be.mergeWith = RE, be.method = BV, be.methodOf = TV, be.mixin = rA, be.negate = Cg, be.nthArg = CV, be.omit = Rq, be.omitBy = Uq, be.once = PK, be.orderBy = yK, be.over = MV, be.overArgs = CK, be.overEvery = NV, be.overSome = RV, be.partial = Qw, be.partialRight = kE, be.partition = mK, be.pick = Dq, be.pickBy = UE, be.property = KE, be.propertyOf = UV, be.pull = yH, be.pullAll = gE, be.pullAllBy = mH, be.pullAllWith = bH, be.pullAt = wH, be.range = DV, be.rangeRight = jV, be.rearg = MK, be.reject = AK, be.remove = AH, be.rest = NK, be.reverse = Vw, be.sampleSize = EK, be.set = Fq, be.setWith = zq, be.shuffle = SK, be.slice = vH, be.sortBy = kK, be.sortedUniq = IH, be.sortedUniqBy = BH, be.split = cV, be.spread = RK, be.tail = TH, be.take = PH, be.takeRight = CH, be.takeRightWhile = MH, be.takeWhile = NH, be.tap = $H, be.throttle = UK, be.thru = Ig, be.toArray = PE, be.toPairs = DE, be.toPairsIn = jE, be.toPath = KV, be.toPlainObject = ME, be.transform = Lq, be.unary = DK, be.union = RH, be.unionBy = UH, be.unionWith = DH, be.uniq = jH, be.uniqBy = FH, be.uniqWith = zH, be.unset = Hq, be.unzip = Ww, be.unzipWith = yE, be.update = Kq, be.updateWith = qq, be.values = id, be.valuesIn = Vq, be.without = LH, be.words = LE, be.wrap = jK, be.xor = HH, be.xorBy = KH, be.xorWith = qH, be.zip = VH, be.zipObject = WH, be.zipObjectDeep = GH, be.zipWith = QH, be.entries = DE, be.entriesIn = jE, be.extend = NE, be.extendWith = Rg, rA(be, be), be.add = VV, be.attempt = HE, be.camelCase = $q, be.capitalize = FE, be.ceil = WV, be.clamp = Wq, be.clone = zK, be.cloneDeep = HK, be.cloneDeepWith = KK, be.cloneWith = LK, be.conformsTo = qK, be.deburr = zE, be.defaultTo = xV, be.divide = GV, be.endsWith = Zq, be.eq = La, be.escape = Xq, be.escapeRegExp = Yq, be.every = oK, be.find = sK, be.findIndex = fE, be.findKey = Aq, be.findLast = uK, be.findLastIndex = dE, be.findLastKey = vq, be.floor = QV, be.forEach = bE, be.forEachRight = wE, be.forIn = Eq, be.forInRight = Sq, be.forOwn = xq, be.forOwnRight = _q, be.get = Xw, be.gt = VK, be.gte = WK, be.has = Iq, be.hasIn = Yw, be.head = pE, be.identity = go, be.includes = hK, be.indexOf = uH, be.inRange = Gq, be.invoke = Pq, be.isArguments = Sl, be.isArray = hr, be.isArrayBuffer = GK, be.isArrayLike = ho, be.isArrayLikeObject = zn, be.isBoolean = QK, be.isBuffer = ec, be.isDate = $K, be.isElement = ZK, be.isEmpty = XK, be.isEqual = YK, be.isEqualWith = JK, be.isError = $w, be.isFinite = eq, be.isFunction = fu, be.isInteger = OE, be.isLength = Mg, be.isMap = IE, be.isMatch = tq, be.isMatchWith = rq, be.isNaN = nq, be.isNative = iq, be.isNil = aq, be.isNull = oq, be.isNumber = BE, be.isObject = _n, be.isObjectLike = Un, be.isPlainObject = bp, be.isRegExp = Zw, be.isSafeInteger = sq, be.isSet = TE, be.isString = Ng, be.isSymbol = jo, be.isTypedArray = nd, be.isUndefined = uq, be.isWeakMap = cq, be.isWeakSet = lq, be.join = hH, be.kebabCase = Jq, be.last = ca, be.lastIndexOf = pH, be.lowerCase = eV, be.lowerFirst = tV, be.lt = fq, be.lte = dq, be.max = $V, be.maxBy = ZV, be.mean = XV, be.meanBy = YV, be.min = JV, be.minBy = eW, be.stubArray = iA, be.stubFalse = oA, be.stubObject = FV, be.stubString = zV, be.stubTrue = LV, be.multiply = tW, be.nth = gH, be.noConflict = PV, be.noop = nA, be.now = Tg, be.pad = rV, be.padEnd = nV, be.padStart = iV, be.parseInt = oV, be.random = Qq, be.reduce = bK, be.reduceRight = wK, be.repeat = aV, be.replace = sV, be.result = jq, be.round = rW, be.runInContext = ze, be.sample = vK, be.size = xK, be.snakeCase = uV, be.some = _K, be.sortedIndex = EH, be.sortedIndexBy = SH, be.sortedIndexOf = xH, be.sortedLastIndex = _H, be.sortedLastIndexBy = kH, be.sortedLastIndexOf = OH, be.startCase = lV, be.startsWith = fV, be.subtract = nW, be.sum = iW, be.sumBy = oW, be.template = dV, be.times = HV, be.toFinite = du, be.toInteger = wr, be.toLength = CE, be.toLower = hV, be.toNumber = la, be.toSafeInteger = hq, be.toString = Jr, be.toUpper = pV, be.trim = gV, be.trimEnd = yV, be.trimStart = mV, be.truncate = bV, be.unescape = wV, be.uniqueId = qV, be.upperCase = AV, be.upperFirst = Jw, be.each = bE, be.eachRight = wE, be.first = pE, rA(be, function() {
                var d = {};
                return gs(be, function(m, F) {
                    on.call(be.prototype, F) || (d[F] = m);
                }), d;
            }(), {
                chain: !1
            }), be.VERSION = n, ia([
                "bind",
                "bindKey",
                "curry",
                "curryRight",
                "partial",
                "partialRight"
            ], function(d) {
                be[d].placeholder = be;
            }), ia([
                "drop",
                "take"
            ], function(d, m) {
                jr.prototype[d] = function(F) {
                    F = F === r ? 1 : Yn(wr(F), 0);
                    var oe = this.__filtered__ && !m ? new jr(this) : this.clone();
                    return oe.__filtered__ ? oe.__takeCount__ = Pi(F, oe.__takeCount__) : oe.__views__.push({
                        size: Pi(F, j),
                        type: d + (oe.__dir__ < 0 ? "Right" : "")
                    }), oe;
                }, jr.prototype[d + "Right"] = function(F) {
                    return this.reverse()[d](F).reverse();
                };
            }), ia([
                "filter",
                "map",
                "takeWhile"
            ], function(d, m) {
                var F = m + 1, oe = F == E || F == _;
                jr.prototype[d] = function(de) {
                    var Ae = this.clone();
                    return Ae.__iteratees__.push({
                        iteratee: Gt(de, 3),
                        type: F
                    }), Ae.__filtered__ = Ae.__filtered__ || oe, Ae;
                };
            }), ia([
                "head",
                "last"
            ], function(d, m) {
                var F = "take" + (m ? "Right" : "");
                jr.prototype[d] = function() {
                    return this[F](1).value()[0];
                };
            }), ia([
                "initial",
                "tail"
            ], function(d, m) {
                var F = "drop" + (m ? "" : "Right");
                jr.prototype[d] = function() {
                    return this.__filtered__ ? new jr(this) : this[F](1);
                };
            }), jr.prototype.compact = function() {
                return this.filter(go);
            }, jr.prototype.find = function(d) {
                return this.filter(d).head();
            }, jr.prototype.findLast = function(d) {
                return this.reverse().find(d);
            }, jr.prototype.invokeMap = Pr(function(d, m) {
                return typeof d == "function" ? new jr(this) : this.map(function(F) {
                    return dp(F, d, m);
                });
            }), jr.prototype.reject = function(d) {
                return this.filter(Cg(Gt(d)));
            }, jr.prototype.slice = function(d, m) {
                d = wr(d);
                var F = this;
                return F.__filtered__ && (d > 0 || m < 0) ? new jr(F) : (d < 0 ? F = F.takeRight(-d) : d && (F = F.drop(d)), m !== r && (m = wr(m), F = m < 0 ? F.dropRight(-m) : F.take(m - d)), F);
            }, jr.prototype.takeRightWhile = function(d) {
                return this.reverse().takeWhile(d).reverse();
            }, jr.prototype.toArray = function() {
                return this.take(j);
            }, gs(jr.prototype, function(d, m) {
                var F = /^(?:filter|find|map|reject)|While$/.test(m), oe = /^(?:head|last)$/.test(m), de = be[oe ? "take" + (m == "last" ? "Right" : "") : m], Ae = oe || /^find/.test(m);
                de && (be.prototype[m] = function() {
                    var Te = this.__wrapped__, Ne = oe ? [
                        1
                    ] : arguments, Le = Te instanceof jr, at = Ne[0], ct = Le || hr(Te), ft = function(Rr) {
                        var Hr = de.apply(be, Gu([
                            Rr
                        ], Ne));
                        return oe && St ? Hr[0] : Hr;
                    };
                    ct && F && typeof at == "function" && at.length != 1 && (Le = ct = !1);
                    var St = this.__chain__, jt = !!this.__actions__.length, Qt = Ae && !St, xr = Le && !jt;
                    if (!Ae && ct) {
                        Te = xr ? Te : new jr(this);
                        var $t = d.apply(Te, Ne);
                        return $t.__actions__.push({
                            func: Ig,
                            args: [
                                ft
                            ],
                            thisArg: r
                        }), new aa($t, St);
                    }
                    return Qt && xr ? d.apply(this, Ne) : ($t = this.thru(ft), Qt ? oe ? $t.value()[0] : $t.value() : $t);
                });
            }), ia([
                "pop",
                "push",
                "shift",
                "sort",
                "splice",
                "unshift"
            ], function(d) {
                var m = eg[d], F = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru", oe = /^(?:pop|shift)$/.test(d);
                be.prototype[d] = function() {
                    var de = arguments;
                    if (oe && !this.__chain__) {
                        var Ae = this.value();
                        return m.apply(hr(Ae) ? Ae : [], de);
                    }
                    return this[F](function(Te) {
                        return m.apply(hr(Te) ? Te : [], de);
                    });
                };
            }), gs(jr.prototype, function(d, m) {
                var F = be[m];
                if (F) {
                    var oe = F.name + "";
                    on.call(Yf, oe) || (Yf[oe] = []), Yf[oe].push({
                        name: m,
                        func: F
                    });
                }
            }), Yf[vg(r, M).name] = [
                {
                    name: "wrapper",
                    func: r
                }
            ], jr.prototype.clone = wz, jr.prototype.reverse = Az, jr.prototype.value = vz, be.prototype.at = ZH, be.prototype.chain = XH, be.prototype.commit = YH, be.prototype.next = JH, be.prototype.plant = tK, be.prototype.reverse = rK, be.prototype.toJSON = be.prototype.valueOf = be.prototype.value = nK, be.prototype.first = be.prototype.head, op && (be.prototype[op] = eK), be;
        }, $f = YF();
        gl ? ((gl.exports = $f)._ = $f, tw._ = $f) : wi._ = $f;
    }).call(Qe);
})(Fm, Fm.exports);
var Nle = Fm.exports;
Object.defineProperty(Ib, "__esModule", {
    value: !0
});
Ib.SandshrewProvider = void 0;
const Rle = U1, Ule = Nle;
let Dle = 0;
class jle extends Rle.AbstractProvider {
    constructor(t){
        super(), this.url = t;
    }
    async call(t, r) {
        const n = await (await fetch(this.url, {
            method: "POST",
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: Dle++,
                params: r,
                method: t
            }),
            headers: {
                "Content-Type": "application/json"
            }
        })).text();
        return JSON.parse(n).result;
    }
    async enrichOutput({ vout: t, txid: r }) {
        return await this.call("ord_output", [
            `${r}:${t}`
        ]);
    }
    async getBTCOnlyUTXOs(t) {
        const r = await this.getUTXOs(t), { inscriptions: n } = await this.call("ord_address", [
            t
        ]), i1 = (0, Ule.zipObject)(n, n);
        return r.filter((o)=>!i1[`${o.outpoint.txid}:${o.outpoint.vout}`] && o.runes.length === 0);
    }
    async getUTXOs(t) {
        return (await this.call("alkanes_protorunesbyaddress", [
            {
                address: t,
                protocolTag: "1"
            }
        ])).outpoints;
    }
}
Ib.SandshrewProvider = jle;
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(U1, e), r(D1, e), r(Ob, e), r(Ib, e);
})(mR);
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(I1, e), r(uR, e), r(rn, e), r(Oo, e), r(N1, e), r(mR, e);
})(Bu);
const gI = BigInt(546), Fle = 77;
function f4(e, t, r) {
    const n = e * 64 + t * 42, i1 = r * 40;
    return 10 + n + i1;
}
const Pc = 546n, ga = {
    mainnet: {
        p2pkh: /^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(bc1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(bc1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    },
    testnet: {
        p2pkh: /^[mn][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[2][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(tb1[qp]|bcrt1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(tb1p|bcrt1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    },
    regtest: {
        p2pkh: /^[mn][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2sh: /^[2][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
        p2wpkh: /^(tb1[qp]|bcrt1[qp])[a-zA-HJ-NP-Z0-9]{14,74}$/,
        p2tr: /^(tb1p|bcrt1p)[a-zA-HJ-NP-Z0-9]{14,74}$/
    }
};
function zle(e) {
    return ga.mainnet.p2pkh.test(e) || ga.testnet.p2pkh.test(e) || ga.regtest.p2pkh.test(e) ? 0 : ga.mainnet.p2tr.test(e) || ga.testnet.p2tr.test(e) || ga.regtest.p2tr.test(e) ? 1 : ga.mainnet.p2sh.test(e) || ga.testnet.p2sh.test(e) || ga.regtest.p2sh.test(e) ? 2 : ga.mainnet.p2wpkh.test(e) || ga.testnet.p2wpkh.test(e) || ga.regtest.p2wpkh.test(e) ? 3 : null;
}
function zm(e, t) {
    let r = 0;
    const n = [];
    for (const i1 of e){
        if (r >= t) break;
        n.push(i1), r += i1.btcValue;
    }
    return {
        utxos: n,
        totalAmount: r
    };
}
const bR = async ({ _psbt: e, senderPublicKey: t, network: r })=>{
    let n = 0;
    for await (const i1 of e.data.inputs){
        const o = i1.finalScriptSig || i1.finalScriptWitness, a = !i1.tapInternalKey;
        if (!o || a) {
            const s = Zo(Ke.from(t, "hex")), c = Mh({
                internalPubkey: s,
                network: r
            });
            (i1.witnessUtxo && Ke.from(i1.witnessUtxo.script).toString("hex")) === (c.output && Ke.from(c.output).toString("hex")) && e.updateInput(n, {
                tapInternalKey: s
            });
        }
        n++;
    }
    return e;
}, Lle = async ({ address: e, greatestToLeast: t, client: r, alkaneId: n, targetNumberOfAlkanes: i1 })=>{
    const o = (await r.dataSourceManager.getAlkanesByAddress(e)).flatMap((l)=>l.runes.filter((u)=>Number(u.rune.id.block) === Number(n.block) && Number(u.rune.id.tx) === Number(n.tx)).map((u)=>({
                rune: u,
                outpoint: l
            }))).sort((l, u)=>t ? Number(u.rune.balance) - Number(l.rune.balance) : Number(l.rune.balance) - Number(u.rune.balance));
    let a = 0, s = 0;
    const c = [];
    for (const l of o)if (s < i1 && Number(l.rune.balance) > 0) {
        const u = Number(l.outpoint.output.value);
        c.push({
            txId: l.outpoint.outpoint.txid,
            txIndex: l.outpoint.outpoint.vout,
            script: l.outpoint.output.script,
            address: e,
            amountOfAlkanes: l.rune.balance,
            satoshis: u,
            ...l.rune.rune
        }), a += u, s += Number(l.rune.balance) / (l.rune.rune.divisibility === 1 ? 1 : 10 ** l.rune.rune.divisibility);
    }
    if (s < i1) throw new Error("Insuffiecient balance of alkanes.");
    return {
        alkaneUtxos: c,
        totalSatoshis: a,
        totalBalanceBeingSent: s
    };
};
async function Lm(e, t, { pubkey: r } = {}) {
    switch(zle(t.address)){
        case 0:
            {
                e.addInput({
                    hash: t.txHash,
                    index: +t.txOutputIndex
                });
                break;
            }
        case 2:
            {
                if (!r) throw new Error("Pubkey is required for nested SegWit");
                const n = Vi([
                    Zr.OP_0,
                    os(Ke.from(r, "hex"))
                ]);
                e.addInput({
                    hash: t.txHash,
                    index: +t.txOutputIndex,
                    redeemScript: n,
                    witnessUtxo: {
                        value: BigInt(t.btcValue),
                        script: Vi([
                            Zr.OP_HASH160,
                            os(n),
                            Zr.OP_EQUAL
                        ])
                    }
                });
                break;
            }
        case 1:
        case 3:
        default:
            e.addInput({
                hash: t.txHash,
                index: +t.txOutputIndex,
                witnessUtxo: {
                    value: BigInt(t.btcValue),
                    script: Ke.from(t.scriptPubKey, "hex")
                }
            });
    }
}
const Hle = async ({ utxos: e, account: t, alkaneId: r, client: n, toAddress: i1, amount: o, feeRate: a, fee: s })=>{
    const c = {
        utxos: e,
        totalAmount: e.reduce((q, U)=>q + U.btcValue, 0)
    }, l = f4(2, 0, 4), u = BigInt(Math.max(l * a, 250));
    let f = s ? BigInt(s) : u, h = zm(c.utxos, Number(f) + Number(Pc) * 4);
    const y = [
        BigInt(2),
        BigInt(100),
        BigInt(77)
    ], S = Bu.encodeRunestoneProtostone({
        protostones: [
            Bu.ProtoStone.message({
                protocolTag: 1n,
                pointer: 0,
                refundPointer: 0,
                calldata: Bu.encipher(y),
                edicts: []
            })
        ]
    }).encodedRunestone;
    if (console.log("protostone23", S.toString("hex")), h.totalAmount < f + Pc) throw console.log("gatheredUtxos.totalAmount", h.totalAmount), new Error("Insufficient Balanceeeee");
    if (h.utxos.length > 1) {
        const q = f4(h.utxos.length, 0, 4);
        f = BigInt(Math.max(q * a, 250)), h = zm(c.utxos, Number(f) + Number(Pc));
    }
    const k = f + Pc * 2n, P = n.$network.get(), M = new zr({
        network: Vr(P)
    }), { alkaneUtxos: N } = await Lle({
        address: t.taproot.address,
        greatestToLeast: t.spendStrategy.utxoSortGreatestToLeast,
        alkaneId: r,
        client: n,
        targetNumberOfAlkanes: o
    });
    if (N.length === 0) throw new Error("No Alkane Utxos Found");
    let z = 0n;
    const K = /* @__PURE__ */ new Set();
    for await (const q of N)Lm(M, {
        txHash: q.txId,
        txOutputIndex: q.txIndex,
        btcValue: q.satoshis,
        scriptPubKey: q.script,
        address: q.address
    }), z += BigInt(q.satoshis), K.add(`${q.txId}:${q.txIndex.toString()}`);
    if (h.totalAmount < k) throw new Error("Insufficient Balance");
    for (const q of h.utxos){
        if (z > k) break;
        K.has(`${q.txHash}:${q.txOutputIndex.toString()}`) || (Lm(M, q), z += BigInt(q.btcValue), K.add(`${q.txHash}:${q.txOutputIndex.toString()}`));
    }
    const $ = Bu.encodeRunestoneProtostone({
        protostones: [
            Bu.ProtoStone.message({
                protocolTag: 1n,
                edicts: [
                    {
                        id: new nR(Jp.u128(BigInt(r.block)), Jp.u128(BigInt(r.tx))),
                        amount: Jp.u128(BigInt(o)),
                        output: ui.u32(1n)
                    }
                ],
                pointer: 0,
                refundPointer: 0,
                calldata: Ke.from([])
            })
        ]
    }).encodedRunestone;
    M.addOutput({
        value: Pc,
        address: t.taproot.address
    }), M.addOutput({
        value: Pc,
        address: i1
    }), M.addOutput({
        script: $,
        value: 0n
    });
    const ne = M.txOutputs.reduce((q, U)=>q + U.value, 0n), ee = z - ne - f;
    return M.addOutput({
        address: t[t.spendStrategy.changeAddress].address,
        value: ee
    }), {
        psbt: (await bR({
            _psbt: M,
            senderPublicKey: t.taproot.pubkey,
            network: Vr(P)
        })).toBase64()
    };
}, Kle = async ({ toAddress: e, network: t, alkaneId: r, changeAddress: n, frontendFeeAddress: i1, frontendFeeAmount: o, feeRate: a = 1, spendableUtxos: s, inputAlkaneUtxos: c, senderPublicKey: l, inputData: u })=>{
    const f = [
        r.block,
        r.tx,
        BigInt(Fle),
        ...u ?? []
    ], h = Bu.encodeRunestoneProtostone({
        protostones: [
            Bu.ProtoStone.message({
                protocolTag: 1n,
                calldata: Bu.encipher(f),
                pointer: 0,
                refundPointer: 0
            })
        ]
    }).encodedRunestone, y = Vr(t), S = new zr({
        network: y
    }), k = i1 && o && o >= gI ? o : 0n, P = k + BigInt(Pc);
    function M(E) {
        return f4(E, 0, 2 + (k > 0 ? 1 : 0)) + h.byteLength;
    }
    const N = M(2), z = BigInt(Math.ceil(Math.max(N * a, 250)));
    let K = {
        utxos: s,
        totalAmount: s.reduce((E, w)=>E + w.btcValue, 0)
    };
    if (K = zm(K.utxos, Number(z) + Number(P)), K.utxos.length < 1) throw new Error("Insufficient balance");
    const $ = M(K.utxos.length), ne = BigInt(Math.ceil(Math.max($ * a, 250)));
    K.totalAmount < ne && (K = zm(K.utxos, Number(ne) + Number(P)));
    const ee = M(K.utxos.length), q = BigInt(Math.ceil(Math.max(ee * a, 250)));
    if (K.totalAmount < q) throw new Error("Insufficient balance");
    for (const E of c)Lm(S, E);
    for (const E of K.utxos)Lm(S, E);
    console.log("protostone byte length", h.length), S.addOutput({
        value: BigInt(Pc),
        address: e
    }), S.addOutput({
        script: h,
        value: 0n
    }), i1 && o && o > 0 && S.addOutput({
        value: o,
        address: i1
    });
    const U = c ? c.reduce((E, w)=>E + BigInt(w.btcValue), 0n) : 0n, Q = BigInt(K.totalAmount) + U, v = S.txOutputs.reduce((E, w)=>E + w.value, 0n), B = Q - v - q;
    if (B < 0) throw new Error("Insufficient balance");
    B >= gI && S.addOutput({
        address: n,
        value: B
    });
    const g = await bR({
        _psbt: S,
        senderPublicKey: l,
        network: y
    });
    return {
        psbtBase64: g.toBase64(),
        psbtHex: g.toHex()
    };
};
class wR {
    constructor(t){
        this.client = t;
    }
    async send(t, r, n) {
        const { connected: i1, address: o, publicKey: a } = this.client.$store.get();
        if (!i1) throw new Error("Client is not connected");
        const s = {
            block: t.split(":")[0],
            tx: t.split(":")[1]
        };
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const c = this.client.$network.get(), l = {
            network: Vr(c),
            spendStrategy: {
                utxoSortGreatestToLeast: !0,
                changeAddress: "taproot",
                addressOrder: [
                    "taproot",
                    "nestedSegwit",
                    "legacy",
                    "nativeSegwit"
                ]
            },
            taproot: {
                address: o,
                pubkey: a,
                pubKeyXOnly: Zo(Ke.from(a, "hex")).toString(),
                hdPath: "m/84'/1'/0'/0/0"
            },
            nestedSegwit: {
                address: o,
                pubkey: a,
                hdPath: "m/84'/1'/0'/0/0"
            },
            legacy: {
                address: o,
                pubkey: a,
                hdPath: "m/49'/1'/0'/0/0"
            },
            nativeSegwit: {
                address: o,
                pubkey: a,
                hdPath: "m/84'/1'/0'/0/0"
            }
        }, { fastFee: u } = await this.client.dataSourceManager.getRecommendedFees(), f = await this.client.dataSourceManager.getFormattedUTXOs(o), { psbt: h } = await Hle({
            utxos: f,
            account: l,
            alkaneId: s,
            client: this.client,
            toAddress: n,
            amount: r,
            feeRate: u
        }), y = await this.client.signPsbt({
            tx: h,
            broadcast: !0,
            finalize: !0
        });
        if (!y) throw new Error("Failed to sign transaction");
        if (y.txId) return y.txId;
        const S = await this.client.pushPsbt(y.signedPsbtHex ?? y.signedPsbtBase64);
        if (S) return S;
        throw new Error("Failed to broadcast transaction");
    }
    async getAlkanes({ limit: t = 10, offset: r }) {
        return (await this.client.dataSourceManager.getSource("sandshrew").alkanesRpc.getAlkanes({
            limit: t,
            offset: r
        })).flatMap((n)=>({
                ...n
            }));
    }
    async getAlkaneById(t) {
        return await this.client.dataSourceManager.getSource("sandshrew").alkanesRpc.getAlkaneById(t);
    }
    async mintAlkane({ toAddress: t, id: r, changeAddress: n, feeRate: i1, inputData: o }) {
        const a = this.client.$network.get(), { connected: s, address: c, publicKey: l } = this.client.$store.get();
        if (!s) throw new Error("Client is not connected");
        const u = await this.client.dataSourceManager.getFormattedUTXOs(c), { utxos: f } = gle(u), h = u.filter((M)=>M.hasAlkanes && !1), { fastFee: y } = await this.client.dataSourceManager.getRecommendedFees(), { psbtBase64: S } = await Kle({
            alkaneId: r,
            network: a,
            toAddress: t ?? c,
            changeAddress: n ?? c,
            senderPublicKey: l,
            inputAlkaneUtxos: h,
            spendableUtxos: f,
            feeRate: i1 ?? y,
            inputData: o
        }), k = await this.client.signPsbt({
            tx: S,
            broadcast: !0,
            finalize: !0
        });
        if (!k) throw new Error("Failed to sign transaction");
        if (k.txId) return k.txId;
        const P = await this.client.pushPsbt(k.signedPsbtHex ?? k.signedPsbtBase64);
        if (P) return P;
        throw new Error("Failed to broadcast transaction");
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const U5 = /* @__PURE__ */ BigInt(0), d4 = /* @__PURE__ */ BigInt(1);
function Hm(e, t) {
    if (typeof t != "boolean") throw new Error(e + " boolean expected, got " + t);
}
function vy(e) {
    const t = e.toString(16);
    return t.length & 1 ? "0" + t : t;
}
function AR(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return e === "" ? U5 : BigInt("0x" + e);
}
function Bb(e) {
    return AR(Qr.bytesToHex(e));
}
function vR(e) {
    return Qr.abytes(e), AR(Qr.bytesToHex(Uint8Array.from(e).reverse()));
}
function D5(e, t) {
    return Qr.hexToBytes(e.toString(16).padStart(t * 2, "0"));
}
function ER(e, t) {
    return D5(e, t).reverse();
}
function Sa(e, t, r) {
    let n;
    if (typeof t == "string") try {
        n = Qr.hexToBytes(t);
    } catch (o) {
        throw new Error(e + " must be hex string or Uint8Array, cause: " + o);
    }
    else if (Qr.isBytes(t)) n = Uint8Array.from(t);
    else throw new Error(e + " must be hex string or Uint8Array");
    const i1 = n.length;
    if (typeof r == "number" && i1 !== r) throw new Error(e + " of length " + r + " expected, got " + i1);
    return n;
}
const z3 = (e)=>typeof e == "bigint" && U5 <= e;
function qle(e, t, r) {
    return z3(e) && z3(t) && z3(r) && t <= e && e < r;
}
function Vle(e, t, r, n) {
    if (!qle(t, r, n)) throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Wle(e) {
    let t;
    for(t = 0; e > U5; e >>= d4, t += 1);
    return t;
}
const Tb = (e)=>(d4 << BigInt(e)) - d4;
function Gle(e, t, r) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    const n = (h)=>new Uint8Array(h), i1 = (h)=>Uint8Array.of(h);
    let o = n(e), a = n(e), s = 0;
    const c = ()=>{
        o.fill(1), a.fill(0), s = 0;
    }, l = (...h)=>r(a, o, ...h), u = (h = n(0))=>{
        a = l(i1(0), h), o = l(), h.length !== 0 && (a = l(i1(1), h), o = l());
    }, f = ()=>{
        if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let h = 0;
        const y = [];
        for(; h < t;){
            o = l();
            const S = o.slice();
            y.push(S), h += o.length;
        }
        return Qr.concatBytes(...y);
    };
    return (h, y)=>{
        c(), u(h);
        let S;
        for(; !(S = y(f()));)u();
        return c(), S;
    };
}
function j5(e, t, r = {}) {
    if (!e || typeof e != "object") throw new Error("expected valid options object");
    function n(i1, o, a) {
        const s = e[i1];
        if (a && s === void 0) return;
        const c = typeof s;
        if (c !== o || s === null) throw new Error(`param "${i1}" is invalid: expected ${o}, got ${c}`);
    }
    Object.entries(t).forEach(([i1, o])=>n(i1, o, !1)), Object.entries(r).forEach(([i1, o])=>n(i1, o, !0));
}
function yI(e) {
    const t = /* @__PURE__ */ new WeakMap();
    return (r, ...n)=>{
        const i1 = t.get(r);
        if (i1 !== void 0) return i1;
        const o = e(r, ...n);
        return t.set(r, o), o;
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Io = BigInt(0), io = BigInt(1), Wl = /* @__PURE__ */ BigInt(2), Qle = /* @__PURE__ */ BigInt(3), SR = /* @__PURE__ */ BigInt(4), xR = /* @__PURE__ */ BigInt(5), _R = /* @__PURE__ */ BigInt(8);
function Wo(e, t) {
    const r = e % t;
    return r >= Io ? r : t + r;
}
function ya(e, t, r) {
    let n = e;
    for(; t-- > Io;)n *= n, n %= r;
    return n;
}
function mI(e, t) {
    if (e === Io) throw new Error("invert: expected non-zero number");
    if (t <= Io) throw new Error("invert: expected positive modulus, got " + t);
    let r = Wo(e, t), n = t, i1 = Io, o = io;
    for(; r !== Io;){
        const a = n / r, s = n % r, c = i1 - o * a;
        n = r, r = s, i1 = o, o = c;
    }
    if (n !== io) throw new Error("invert: does not exist");
    return Wo(i1, t);
}
function kR(e, t) {
    const r = (e.ORDER + io) / SR, n = e.pow(t, r);
    if (!e.eql(e.sqr(n), t)) throw new Error("Cannot find square root");
    return n;
}
function $le(e, t) {
    const r = (e.ORDER - xR) / _R, n = e.mul(t, Wl), i1 = e.pow(n, r), o = e.mul(t, i1), a = e.mul(e.mul(o, Wl), i1), s = e.mul(o, e.sub(a, e.ONE));
    if (!e.eql(e.sqr(s), t)) throw new Error("Cannot find square root");
    return s;
}
function Zle(e) {
    if (e < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let t = e - io, r = 0;
    for(; t % Wl === Io;)t /= Wl, r++;
    let n = Wl;
    const i1 = j1(e);
    for(; bI(i1, n) === 1;)if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return kR;
    let o = i1.pow(n, t);
    const a = (t + io) / Wl;
    return function(s, c) {
        if (s.is0(c)) return c;
        if (bI(s, c) !== 1) throw new Error("Cannot find square root");
        let l = r, u = s.mul(s.ONE, o), f = s.pow(c, t), h = s.pow(c, a);
        for(; !s.eql(f, s.ONE);){
            if (s.is0(f)) return s.ZERO;
            let y = 1, S = s.sqr(f);
            for(; !s.eql(S, s.ONE);)if (y++, S = s.sqr(S), y === l) throw new Error("Cannot find square root");
            const k = io << BigInt(l - y - 1), P = s.pow(u, k);
            l = y, u = s.sqr(P), f = s.mul(f, u), h = s.mul(h, P);
        }
        return h;
    };
}
function Xle(e) {
    return e % SR === Qle ? kR : e % _R === xR ? $le : Zle(e);
}
const Yle = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function Jle(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, r = Yle.reduce((n, i1)=>(n[i1] = "function", n), t);
    return j5(e, r), e;
}
function efe(e, t, r) {
    if (r < Io) throw new Error("invalid exponent, negatives unsupported");
    if (r === Io) return e.ONE;
    if (r === io) return t;
    let n = e.ONE, i1 = t;
    for(; r > Io;)r & io && (n = e.mul(n, i1)), i1 = e.sqr(i1), r >>= io;
    return n;
}
function OR(e, t, r = !1) {
    const n = new Array(t.length).fill(r ? e.ZERO : void 0), i1 = t.reduce((a, s, c)=>e.is0(s) ? a : (n[c] = a, e.mul(a, s)), e.ONE), o = e.inv(i1);
    return t.reduceRight((a, s, c)=>e.is0(s) ? a : (n[c] = e.mul(a, n[c]), e.mul(a, s)), o), n;
}
function bI(e, t) {
    const r = (e.ORDER - io) / Wl, n = e.pow(t, r), i1 = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), a = e.eql(n, e.neg(e.ONE));
    if (!i1 && !o && !a) throw new Error("invalid Legendre symbol result");
    return i1 ? 1 : o ? 0 : -1;
}
function tfe(e, t) {
    t !== void 0 && Qr.anumber(t);
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function j1(e, t, r = !1, n = {}) {
    if (e <= Io) throw new Error("invalid field: expected ORDER > 0, got " + e);
    let i1, o;
    if (typeof t == "object" && t != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const u = t;
        u.BITS && (i1 = u.BITS), u.sqrt && (o = u.sqrt), typeof u.isLE == "boolean" && (r = u.isLE);
    } else typeof t == "number" && (i1 = t), n.sqrt && (o = n.sqrt);
    const { nBitLength: a, nByteLength: s } = tfe(e, i1);
    if (s > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let c;
    const l = Object.freeze({
        ORDER: e,
        isLE: r,
        BITS: a,
        BYTES: s,
        MASK: Tb(a),
        ZERO: Io,
        ONE: io,
        create: (u)=>Wo(u, e),
        isValid: (u)=>{
            if (typeof u != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof u);
            return Io <= u && u < e;
        },
        is0: (u)=>u === Io,
        // is valid and invertible
        isValidNot0: (u)=>!l.is0(u) && l.isValid(u),
        isOdd: (u)=>(u & io) === io,
        neg: (u)=>Wo(-u, e),
        eql: (u, f)=>u === f,
        sqr: (u)=>Wo(u * u, e),
        add: (u, f)=>Wo(u + f, e),
        sub: (u, f)=>Wo(u - f, e),
        mul: (u, f)=>Wo(u * f, e),
        pow: (u, f)=>efe(l, u, f),
        div: (u, f)=>Wo(u * mI(f, e), e),
        // Same as above, but doesn't normalize
        sqrN: (u)=>u * u,
        addN: (u, f)=>u + f,
        subN: (u, f)=>u - f,
        mulN: (u, f)=>u * f,
        inv: (u)=>mI(u, e),
        sqrt: o || ((u)=>(c || (c = Xle(e)), c(l, u))),
        toBytes: (u)=>r ? ER(u, s) : D5(u, s),
        fromBytes: (u)=>{
            if (u.length !== s) throw new Error("Field.fromBytes: expected " + s + " bytes, got " + u.length);
            return r ? vR(u) : Bb(u);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (u)=>OR(l, u),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (u, f, h)=>h ? f : u
    });
    return Object.freeze(l);
}
function IR(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function BR(e) {
    const t = IR(e);
    return t + Math.ceil(t / 2);
}
function rfe(e, t, r = !1) {
    const n = e.length, i1 = IR(t), o = BR(t);
    if (n < 16 || n < o || n > 1024) throw new Error("expected " + o + "-1024 bytes of input, got " + n);
    const a = r ? vR(e) : Bb(e), s = Wo(a, t - io) + io;
    return r ? ER(s, i1) : D5(s, i1);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const mh = BigInt(0), Gl = BigInt(1);
function n0(e, t) {
    const r = t.negate();
    return e ? r : t;
}
function nfe(e, t, r) {
    const n = (o)=>o.pz, i1 = OR(e.Fp, r.map(n));
    return r.map((o, a)=>o.toAffine(i1[a])).map(e.fromAffine);
}
function TR(e, t) {
    if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function L3(e, t) {
    TR(e, t);
    const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i1 = 2 ** e, o = Tb(e), a = BigInt(e);
    return {
        windows: r,
        windowSize: n,
        mask: o,
        maxNumber: i1,
        shiftBy: a
    };
}
function wI(e, t, r) {
    const { windowSize: n, mask: i1, maxNumber: o, shiftBy: a } = r;
    let s = Number(e & i1), c = e >> a;
    s > n && (s -= o, c += Gl);
    const l = t * n, u = l + Math.abs(s) - 1, f = s === 0, h = s < 0, y = t % 2 !== 0;
    return {
        nextN: c,
        offset: u,
        isZero: f,
        isNeg: h,
        isNegF: y,
        offsetF: l
    };
}
function ife(e, t) {
    if (!Array.isArray(e)) throw new Error("array expected");
    e.forEach((r, n)=>{
        if (!(r instanceof t)) throw new Error("invalid point at index " + n);
    });
}
function ofe(e, t) {
    if (!Array.isArray(e)) throw new Error("array of scalars expected");
    e.forEach((r, n)=>{
        if (!t.isValid(r)) throw new Error("invalid scalar at index " + n);
    });
}
const H3 = /* @__PURE__ */ new WeakMap(), PR = /* @__PURE__ */ new WeakMap();
function K3(e) {
    return PR.get(e) || 1;
}
function AI(e) {
    if (e !== mh) throw new Error("invalid wNAF");
}
function afe(e, t) {
    return {
        constTimeNegate: n0,
        hasPrecomputes (r) {
            return K3(r) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (r, n, i1 = e.ZERO) {
            let o = r;
            for(; n > mh;)n & Gl && (i1 = i1.add(o)), o = o.double(), n >>= Gl;
            return i1;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (r, n) {
            const { windows: i1, windowSize: o } = L3(n, t), a = [];
            let s = r, c = s;
            for(let l = 0; l < i1; l++){
                c = s, a.push(c);
                for(let u = 1; u < o; u++)c = c.add(s), a.push(c);
                s = c.double();
            }
            return a;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (r, n, i1) {
            let o = e.ZERO, a = e.BASE;
            const s = L3(r, t);
            for(let c = 0; c < s.windows; c++){
                const { nextN: l, offset: u, isZero: f, isNeg: h, isNegF: y, offsetF: S } = wI(i1, c, s);
                i1 = l, f ? a = a.add(n0(y, n[S])) : o = o.add(n0(h, n[u]));
            }
            return AI(i1), {
                p: o,
                f: a
            };
        },
        /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */ wNAFUnsafe (r, n, i1, o = e.ZERO) {
            const a = L3(r, t);
            for(let s = 0; s < a.windows && i1 !== mh; s++){
                const { nextN: c, offset: l, isZero: u, isNeg: f } = wI(i1, s, a);
                if (i1 = c, !u) {
                    const h = n[l];
                    o = o.add(f ? h.negate() : h);
                }
            }
            return AI(i1), o;
        },
        getPrecomputes (r, n, i1) {
            let o = H3.get(n);
            return o || (o = this.precomputeWindow(n, r), r !== 1 && (typeof i1 == "function" && (o = i1(o)), H3.set(n, o))), o;
        },
        wNAFCached (r, n, i1) {
            const o = K3(r);
            return this.wNAF(o, this.getPrecomputes(o, r, i1), n);
        },
        wNAFCachedUnsafe (r, n, i1, o) {
            const a = K3(r);
            return a === 1 ? this.unsafeLadder(r, n, o) : this.wNAFUnsafe(a, this.getPrecomputes(a, r, i1), n, o);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (r, n) {
            TR(n, t), PR.set(r, n), H3.delete(r);
        }
    };
}
function sfe(e, t, r, n) {
    let i1 = t, o = e.ZERO, a = e.ZERO;
    for(; r > mh || n > mh;)r & Gl && (o = o.add(i1)), n & Gl && (a = a.add(i1)), i1 = i1.double(), r >>= Gl, n >>= Gl;
    return {
        p1: o,
        p2: a
    };
}
function ufe(e, t, r, n) {
    ife(r, e), ofe(n, t);
    const i1 = r.length, o = n.length;
    if (i1 !== o) throw new Error("arrays of points and scalars must have equal length");
    const a = e.ZERO, s = Wle(BigInt(i1));
    let c = 1;
    s > 12 ? c = s - 3 : s > 4 ? c = s - 2 : s > 0 && (c = 2);
    const l = Tb(c), u = new Array(Number(l) + 1).fill(a), f = Math.floor((t.BITS - 1) / c) * c;
    let h = a;
    for(let y = f; y >= 0; y -= c){
        u.fill(a);
        for(let k = 0; k < o; k++){
            const P = n[k], M = Number(P >> BigInt(y) & l);
            u[M] = u[M].add(r[k]);
        }
        let S = a;
        for(let k = u.length - 1, P = a; k > 0; k--)P = P.add(u[k]), S = S.add(P);
        if (h = h.add(S), y !== 0) for(let k = 0; k < c; k++)h = h.double();
    }
    return h;
}
function vI(e, t) {
    if (t) {
        if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return Jle(t), t;
    } else return j1(e);
}
function cfe(e, t, r = {}) {
    if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`);
    for (const a of [
        "p",
        "n",
        "h"
    ]){
        const s = t[a];
        if (!(typeof s == "bigint" && s > mh)) throw new Error(`CURVE.${a} must be positive bigint`);
    }
    const n = vI(t.p, r.Fp), i1 = vI(t.n, r.Fn), o = [
        "Gx",
        "Gy",
        "a",
        "b"
    ];
    for (const a of o)if (!n.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i1
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function EI(e) {
    e.lowS !== void 0 && Hm("lowS", e.lowS), e.prehash !== void 0 && Hm("prehash", e.prehash);
}
class lfe extends Error {
    constructor(t = ""){
        super(t);
    }
}
const ku = {
    // asn.1 DER encoding utils
    Err: lfe,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (e, t)=>{
            const { Err: r } = ku;
            if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
            if (t.length & 1) throw new r("tlv.encode: unpadded data");
            const n = t.length / 2, i1 = vy(n);
            if (i1.length / 2 & 128) throw new r("tlv.encode: long form length too big");
            const o = n > 127 ? vy(i1.length / 2 | 128) : "";
            return vy(e) + o + i1 + t;
        },
        // v - value, l - left bytes (unparsed)
        decode (e, t) {
            const { Err: r } = ku;
            let n = 0;
            if (e < 0 || e > 256) throw new r("tlv.encode: wrong tag");
            if (t.length < 2 || t[n++] !== e) throw new r("tlv.decode: wrong tlv");
            const i1 = t[n++], o = !!(i1 & 128);
            let a = 0;
            if (!o) a = i1;
            else {
                const c = i1 & 127;
                if (!c) throw new r("tlv.decode(long): indefinite length not supported");
                if (c > 4) throw new r("tlv.decode(long): byte length is too big");
                const l = t.subarray(n, n + c);
                if (l.length !== c) throw new r("tlv.decode: length bytes not complete");
                if (l[0] === 0) throw new r("tlv.decode(long): zero leftmost byte");
                for (const u of l)a = a << 8 | u;
                if (n += c, a < 128) throw new r("tlv.decode(long): not minimal encoding");
            }
            const s = t.subarray(n, n + a);
            if (s.length !== a) throw new r("tlv.decode: wrong value length");
            return {
                v: s,
                l: t.subarray(n + a)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (e) {
            const { Err: t } = ku;
            if (e < i0) throw new t("integer: negative integers are not allowed");
            let r = vy(e);
            if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1) throw new t("unexpected DER parsing assertion: unpadded hex");
            return r;
        },
        decode (e) {
            const { Err: t } = ku;
            if (e[0] & 128) throw new t("invalid signature integer: negative");
            if (e[0] === 0 && !(e[1] & 128)) throw new t("invalid signature integer: unnecessary leading zero");
            return Bb(e);
        }
    },
    toSig (e) {
        const { Err: t, _int: r, _tlv: n } = ku, i1 = Sa("signature", e), { v: o, l: a } = n.decode(48, i1);
        if (a.length) throw new t("invalid signature: left bytes after parsing");
        const { v: s, l: c } = n.decode(2, o), { v: l, l: u } = n.decode(2, c);
        if (u.length) throw new t("invalid signature: left bytes after parsing");
        return {
            r: r.decode(s),
            s: r.decode(l)
        };
    },
    hexFromSig (e) {
        const { _tlv: t, _int: r } = ku, n = t.encode(2, r.encode(e.r)), i1 = t.encode(2, r.encode(e.s)), o = n + i1;
        return t.encode(48, o);
    }
}, i0 = BigInt(0), o0 = BigInt(1), ffe = BigInt(2), Ey = BigInt(3), dfe = BigInt(4);
function hfe(e, t, r) {
    function n(i1) {
        const o = e.sqr(i1), a = e.mul(o, i1);
        return e.add(e.add(a, e.mul(i1, t)), r);
    }
    return n;
}
function CR(e, t, r) {
    const { BYTES: n } = e;
    function i1(o) {
        let a;
        if (typeof o == "bigint") a = o;
        else {
            let s = Sa("private key", o);
            if (t) {
                if (!t.includes(s.length * 2)) throw new Error("invalid private key");
                const c = new Uint8Array(n);
                c.set(s, c.length - s.length), s = c;
            }
            try {
                a = e.fromBytes(s);
            } catch  {
                throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof o}`);
            }
        }
        if (r && (a = e.create(a)), !e.isValidNot0(a)) throw new Error("invalid private key: out of range [1..N-1]");
        return a;
    }
    return i1;
}
function pfe(e, t = {}) {
    const { Fp: r, Fn: n } = cfe("weierstrass", e, t), { h: i1, n: o } = e;
    j5(t, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const { endo: a } = t;
    if (a && (!r.is0(e.a) || typeof a.beta != "bigint" || typeof a.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    function s() {
        if (!r.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function c(q, U, Q) {
        const { x: v, y: B } = U.toAffine(), g = r.toBytes(v);
        if (Hm("isCompressed", Q), Q) {
            s();
            const E = !r.isOdd(B);
            return Qr.concatBytes(MR(E), g);
        } else return Qr.concatBytes(Uint8Array.of(4), g, r.toBytes(B));
    }
    function l(q) {
        Qr.abytes(q);
        const U = r.BYTES, Q = U + 1, v = 2 * U + 1, B = q.length, g = q[0], E = q.subarray(1);
        if (B === Q && (g === 2 || g === 3)) {
            const w = r.fromBytes(E);
            if (!r.isValid(w)) throw new Error("bad point: is not on curve, wrong x");
            const _ = h(w);
            let O;
            try {
                O = r.sqrt(_);
            } catch (x) {
                const R = x instanceof Error ? ": " + x.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + R);
            }
            s();
            const I = r.isOdd(O);
            return (g & 1) === 1 !== I && (O = r.neg(O)), {
                x: w,
                y: O
            };
        } else if (B === v && g === 4) {
            const w = r.fromBytes(E.subarray(U * 0, U * 1)), _ = r.fromBytes(E.subarray(U * 1, U * 2));
            if (!y(w, _)) throw new Error("bad point: is not on curve");
            return {
                x: w,
                y: _
            };
        } else throw new Error(`bad point: got length ${B}, expected compressed=${Q} or uncompressed=${v}`);
    }
    const u = t.toBytes || c, f = t.fromBytes || l, h = hfe(r, e.a, e.b);
    function y(q, U) {
        const Q = r.sqr(U), v = h(q);
        return r.eql(Q, v);
    }
    if (!y(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
    const S = r.mul(r.pow(e.a, Ey), dfe), k = r.mul(r.sqr(e.b), BigInt(27));
    if (r.is0(r.add(S, k))) throw new Error("bad curve params: a or b");
    function P(q, U, Q = !1) {
        if (!r.isValid(U) || Q && r.is0(U)) throw new Error(`bad point coordinate ${q}`);
        return U;
    }
    function M(q) {
        if (!(q instanceof $)) throw new Error("ProjectivePoint expected");
    }
    const N = yI((q, U)=>{
        const { px: Q, py: v, pz: B } = q;
        if (r.eql(B, r.ONE)) return {
            x: Q,
            y: v
        };
        const g = q.is0();
        U == null && (U = g ? r.ONE : r.inv(B));
        const E = r.mul(Q, U), w = r.mul(v, U), _ = r.mul(B, U);
        if (g) return {
            x: r.ZERO,
            y: r.ZERO
        };
        if (!r.eql(_, r.ONE)) throw new Error("invZ was invalid");
        return {
            x: E,
            y: w
        };
    }), z = yI((q)=>{
        if (q.is0()) {
            if (t.allowInfinityPoint && !r.is0(q.py)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: U, y: Q } = q.toAffine();
        if (!r.isValid(U) || !r.isValid(Q)) throw new Error("bad point: x or y not field elements");
        if (!y(U, Q)) throw new Error("bad point: equation left != right");
        if (!q.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    function K(q, U, Q, v, B) {
        return Q = new $(r.mul(Q.px, q), Q.py, Q.pz), U = n0(v, U), Q = n0(B, Q), U.add(Q);
    }
    class $ {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(U, Q, v){
            this.px = P("x", U), this.py = P("y", Q, !0), this.pz = P("z", v), Object.freeze(this);
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(U) {
            const { x: Q, y: v } = U || {};
            if (!U || !r.isValid(Q) || !r.isValid(v)) throw new Error("invalid affine point");
            if (U instanceof $) throw new Error("projective point not allowed");
            return r.is0(Q) && r.is0(v) ? $.ZERO : new $(Q, v, r.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(U) {
            return nfe($, "pz", U);
        }
        static fromBytes(U) {
            return Qr.abytes(U), $.fromHex(U);
        }
        /** Converts hash string or Uint8Array to Point. */ static fromHex(U) {
            const Q = $.fromAffine(f(Sa("pointHex", U)));
            return Q.assertValidity(), Q;
        }
        /** Multiplies generator point by privateKey. */ static fromPrivateKey(U) {
            const Q = CR(n, t.allowedPrivateKeyLengths, t.wrapPrivateKey);
            return $.BASE.multiply(Q(U));
        }
        /** Multiscalar Multiplication */ static msm(U, Q) {
            return ufe($, n, U, Q);
        }
        /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */ precompute(U = 8, Q = !0) {
            return ee.setWindowSize(this, U), Q || this.multiply(Ey), this;
        }
        /** "Private method", don't use it directly */ _setWindowSize(U) {
            this.precompute(U);
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */ assertValidity() {
            z(this);
        }
        hasEvenY() {
            const { y: U } = this.toAffine();
            if (!r.isOdd) throw new Error("Field doesn't support isOdd");
            return !r.isOdd(U);
        }
        /** Compare one point to another. */ equals(U) {
            M(U);
            const { px: Q, py: v, pz: B } = this, { px: g, py: E, pz: w } = U, _ = r.eql(r.mul(Q, w), r.mul(g, B)), O = r.eql(r.mul(v, w), r.mul(E, B));
            return _ && O;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
            return new $(this.px, r.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: U, b: Q } = e, v = r.mul(Q, Ey), { px: B, py: g, pz: E } = this;
            let w = r.ZERO, _ = r.ZERO, O = r.ZERO, I = r.mul(B, B), x = r.mul(g, g), R = r.mul(E, E), j = r.mul(B, g);
            return j = r.add(j, j), O = r.mul(B, E), O = r.add(O, O), w = r.mul(U, O), _ = r.mul(v, R), _ = r.add(w, _), w = r.sub(x, _), _ = r.add(x, _), _ = r.mul(w, _), w = r.mul(j, w), O = r.mul(v, O), R = r.mul(U, R), j = r.sub(I, R), j = r.mul(U, j), j = r.add(j, O), O = r.add(I, I), I = r.add(O, I), I = r.add(I, R), I = r.mul(I, j), _ = r.add(_, I), R = r.mul(g, E), R = r.add(R, R), I = r.mul(R, j), w = r.sub(w, I), O = r.mul(R, x), O = r.add(O, O), O = r.add(O, O), new $(w, _, O);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(U) {
            M(U);
            const { px: Q, py: v, pz: B } = this, { px: g, py: E, pz: w } = U;
            let _ = r.ZERO, O = r.ZERO, I = r.ZERO;
            const x = e.a, R = r.mul(e.b, Ey);
            let j = r.mul(Q, g), Y = r.mul(v, E), he = r.mul(B, w), ue = r.add(Q, v), G = r.add(g, E);
            ue = r.mul(ue, G), G = r.add(j, Y), ue = r.sub(ue, G), G = r.add(Q, B);
            let se = r.add(g, w);
            return G = r.mul(G, se), se = r.add(j, he), G = r.sub(G, se), se = r.add(v, B), _ = r.add(E, w), se = r.mul(se, _), _ = r.add(Y, he), se = r.sub(se, _), I = r.mul(x, G), _ = r.mul(R, he), I = r.add(_, I), _ = r.sub(Y, I), I = r.add(Y, I), O = r.mul(_, I), Y = r.add(j, j), Y = r.add(Y, j), he = r.mul(x, he), G = r.mul(R, G), Y = r.add(Y, he), he = r.sub(j, he), he = r.mul(x, he), G = r.add(G, he), j = r.mul(Y, G), O = r.add(O, j), j = r.mul(se, G), _ = r.mul(ue, _), _ = r.sub(_, j), j = r.mul(ue, Y), I = r.mul(se, I), I = r.add(I, j), new $(_, O, I);
        }
        subtract(U) {
            return this.add(U.negate());
        }
        is0() {
            return this.equals($.ZERO);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(U) {
            const { endo: Q } = t;
            if (!n.isValidNot0(U)) throw new Error("invalid scalar: out of range");
            let v, B;
            const g = (E)=>ee.wNAFCached(this, E, $.normalizeZ);
            if (Q) {
                const { k1neg: E, k1: w, k2neg: _, k2: O } = Q.splitScalar(U), { p: I, f: x } = g(w), { p: R, f: j } = g(O);
                B = x.add(j), v = K(Q.beta, I, R, E, _);
            } else {
                const { p: E, f: w } = g(U);
                v = E, B = w;
            }
            return $.normalizeZ([
                v,
                B
            ])[0];
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(U) {
            const { endo: Q } = t, v = this;
            if (!n.isValid(U)) throw new Error("invalid scalar: out of range");
            if (U === i0 || v.is0()) return $.ZERO;
            if (U === o0) return v;
            if (ee.hasPrecomputes(this)) return this.multiply(U);
            if (Q) {
                const { k1neg: B, k1: g, k2neg: E, k2: w } = Q.splitScalar(U), { p1: _, p2: O } = sfe($, v, g, w);
                return K(Q.beta, _, O, B, E);
            } else return ee.wNAFCachedUnsafe(v, U);
        }
        multiplyAndAddUnsafe(U, Q, v) {
            const B = this.multiplyUnsafe(Q).add(U.multiplyUnsafe(v));
            return B.is0() ? void 0 : B;
        }
        /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */ toAffine(U) {
            return N(this, U);
        }
        /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */ isTorsionFree() {
            const { isTorsionFree: U } = t;
            return i1 === o0 ? !0 : U ? U($, this) : ee.wNAFCachedUnsafe(this, o).is0();
        }
        clearCofactor() {
            const { clearCofactor: U } = t;
            return i1 === o0 ? this : U ? U($, this) : this.multiplyUnsafe(i1);
        }
        toBytes(U = !0) {
            return Hm("isCompressed", U), this.assertValidity(), u($, this, U);
        }
        /** @deprecated use `toBytes` */ toRawBytes(U = !0) {
            return this.toBytes(U);
        }
        toHex(U = !0) {
            return Qr.bytesToHex(this.toBytes(U));
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
    }
    $.BASE = new $(e.Gx, e.Gy, r.ONE), $.ZERO = new $(r.ZERO, r.ONE, r.ZERO), $.Fp = r, $.Fn = n;
    const ne = n.BITS, ee = afe($, t.endo ? Math.ceil(ne / 2) : ne);
    return $;
}
function MR(e) {
    return Uint8Array.of(e ? 2 : 3);
}
function gfe(e, t, r = {}) {
    j5(t, {
        hash: "function"
    }, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const n = t.randomBytes || Qr.randomBytes, i1 = t.hmac || ((v, ...B)=>p1.hmac(t.hash, v, Qr.concatBytes(...B))), { Fp: o, Fn: a } = e, { ORDER: s, BITS: c } = a;
    function l(v) {
        const B = s >> o0;
        return v > B;
    }
    function u(v) {
        return l(v) ? a.neg(v) : v;
    }
    function f(v, B) {
        if (!a.isValidNot0(B)) throw new Error(`invalid signature ${v}: out of range 1..CURVE.n`);
    }
    class h {
        constructor(B, g, E){
            f("r", B), f("s", g), this.r = B, this.s = g, E != null && (this.recovery = E), Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(B) {
            const g = a.BYTES, E = Sa("compactSignature", B, g * 2);
            return new h(a.fromBytes(E.subarray(0, g)), a.fromBytes(E.subarray(g, g * 2)));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(B) {
            const { r: g, s: E } = ku.toSig(Sa("DER", B));
            return new h(g, E);
        }
        /**
     * @todo remove
     * @deprecated
     */ assertValidity() {}
        addRecoveryBit(B) {
            return new h(this.r, this.s, B);
        }
        // ProjPointType<bigint>
        recoverPublicKey(B) {
            const g = o.ORDER, { r: E, s: w, recovery: _ } = this;
            if (_ == null || ![
                0,
                1,
                2,
                3
            ].includes(_)) throw new Error("recovery id invalid");
            if (s * ffe < g && _ > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const O = _ === 2 || _ === 3 ? E + s : E;
            if (!o.isValid(O)) throw new Error("recovery id 2 or 3 invalid");
            const I = o.toBytes(O), x = e.fromHex(Qr.concatBytes(MR((_ & 1) === 0), I)), R = a.inv(O), j = z(Sa("msgHash", B)), Y = a.create(-j * R), he = a.create(w * R), ue = e.BASE.multiplyUnsafe(Y).add(x.multiplyUnsafe(he));
            if (ue.is0()) throw new Error("point at infinify");
            return ue.assertValidity(), ue;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return l(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new h(this.r, a.neg(this.s), this.recovery) : this;
        }
        toBytes(B) {
            if (B === "compact") return Qr.concatBytes(a.toBytes(this.r), a.toBytes(this.s));
            if (B === "der") return Qr.hexToBytes(ku.hexFromSig(this));
            throw new Error("invalid format");
        }
        // DER-encoded
        toDERRawBytes() {
            return this.toBytes("der");
        }
        toDERHex() {
            return Qr.bytesToHex(this.toBytes("der"));
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return this.toBytes("compact");
        }
        toCompactHex() {
            return Qr.bytesToHex(this.toBytes("compact"));
        }
    }
    const y = CR(a, r.allowedPrivateKeyLengths, r.wrapPrivateKey), S = {
        isValidPrivateKey (v) {
            try {
                return y(v), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: y,
        /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */ randomPrivateKey: ()=>{
            const v = s;
            return rfe(n(BR(v)), v);
        },
        precompute (v = 8, B = e.BASE) {
            return B.precompute(v, !1);
        }
    };
    function k(v, B = !0) {
        return e.fromPrivateKey(v).toBytes(B);
    }
    function P(v) {
        if (typeof v == "bigint") return !1;
        if (v instanceof e) return !0;
        const B = Sa("key", v).length, g = o.BYTES, E = g + 1, w = 2 * g + 1;
        if (!(r.allowedPrivateKeyLengths || a.BYTES === E)) return B === E || B === w;
    }
    function M(v, B, g = !0) {
        if (P(v) === !0) throw new Error("first arg must be private key");
        if (P(B) === !1) throw new Error("second arg must be public key");
        return e.fromHex(B).multiply(y(v)).toBytes(g);
    }
    const N = t.bits2int || function(v) {
        if (v.length > 8192) throw new Error("input is too large");
        const B = Bb(v), g = v.length * 8 - c;
        return g > 0 ? B >> BigInt(g) : B;
    }, z = t.bits2int_modN || function(v) {
        return a.create(N(v));
    }, K = Tb(c);
    function $(v) {
        return Vle("num < 2^" + c, v, i0, K), a.toBytes(v);
    }
    function ne(v, B, g = ee) {
        if ([
            "recovered",
            "canonical"
        ].some((ue)=>ue in g)) throw new Error("sign() legacy options not supported");
        const { hash: E } = t;
        let { lowS: w, prehash: _, extraEntropy: O } = g;
        w == null && (w = !0), v = Sa("msgHash", v), EI(g), _ && (v = Sa("prehashed msgHash", E(v)));
        const I = z(v), x = y(B), R = [
            $(x),
            $(I)
        ];
        if (O != null && O !== !1) {
            const ue = O === !0 ? n(o.BYTES) : O;
            R.push(Sa("extraEntropy", ue));
        }
        const j = Qr.concatBytes(...R), Y = I;
        function he(ue) {
            const G = N(ue);
            if (!a.isValidNot0(G)) return;
            const se = a.inv(G), Z = e.BASE.multiply(G).toAffine(), ie = a.create(Z.x);
            if (ie === i0) return;
            const pe = a.create(se * a.create(Y + ie * x));
            if (pe === i0) return;
            let ve = (Z.x === ie ? 0 : 2) | Number(Z.y & o0), Ie = pe;
            return w && l(pe) && (Ie = u(pe), ve ^= 1), new h(ie, Ie, ve);
        }
        return {
            seed: j,
            k2sig: he
        };
    }
    const ee = {
        lowS: t.lowS,
        prehash: !1
    }, q = {
        lowS: t.lowS,
        prehash: !1
    };
    function U(v, B, g = ee) {
        const { seed: E, k2sig: w } = ne(v, B, g);
        return Gle(t.hash.outputLen, a.BYTES, i1)(E, w);
    }
    e.BASE.precompute(8);
    function Q(v, B, g, E = q) {
        const w = v;
        B = Sa("msgHash", B), g = Sa("publicKey", g), EI(E);
        const { lowS: _, prehash: O, format: I } = E;
        if ("strict" in E) throw new Error("options.strict was renamed to lowS");
        if (I !== void 0 && ![
            "compact",
            "der",
            "js"
        ].includes(I)) throw new Error('format must be "compact", "der" or "js"');
        const x = typeof w == "string" || Qr.isBytes(w), R = !x && !I && typeof w == "object" && w !== null && typeof w.r == "bigint" && typeof w.s == "bigint";
        if (!x && !R) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let j, Y;
        try {
            if (R) if (I === void 0 || I === "js") j = new h(w.r, w.s);
            else throw new Error("invalid format");
            if (x) {
                try {
                    I !== "compact" && (j = h.fromDER(w));
                } catch (ve) {
                    if (!(ve instanceof ku.Err)) throw ve;
                }
                !j && I !== "der" && (j = h.fromCompact(w));
            }
            Y = e.fromHex(g);
        } catch  {
            return !1;
        }
        if (!j || _ && j.hasHighS()) return !1;
        O && (B = t.hash(B));
        const { r: he, s: ue } = j, G = z(B), se = a.inv(ue), Z = a.create(G * se), ie = a.create(he * se), pe = e.BASE.multiplyUnsafe(Z).add(Y.multiplyUnsafe(ie));
        return pe.is0() ? !1 : a.create(pe.x) === he;
    }
    return Object.freeze({
        getPublicKey: k,
        getSharedSecret: M,
        sign: U,
        verify: Q,
        utils: S,
        Point: e,
        Signature: h
    });
}
function yfe(e) {
    const t = {
        a: e.a,
        b: e.b,
        p: e.Fp.ORDER,
        n: e.n,
        h: e.h,
        Gx: e.Gx,
        Gy: e.Gy
    }, r = e.Fp, n = j1(t.n, e.nBitLength), i1 = {
        Fp: r,
        Fn: n,
        allowedPrivateKeyLengths: e.allowedPrivateKeyLengths,
        allowInfinityPoint: e.allowInfinityPoint,
        endo: e.endo,
        wrapPrivateKey: e.wrapPrivateKey,
        isTorsionFree: e.isTorsionFree,
        clearCofactor: e.clearCofactor,
        fromBytes: e.fromBytes,
        toBytes: e.toBytes
    };
    return {
        CURVE: t,
        curveOpts: i1
    };
}
function mfe(e) {
    const { CURVE: t, curveOpts: r } = yfe(e), n = {
        hash: e.hash,
        hmac: e.hmac,
        randomBytes: e.randomBytes,
        lowS: e.lowS,
        bits2int: e.bits2int,
        bits2int_modN: e.bits2int_modN
    };
    return {
        CURVE: t,
        curveOpts: r,
        ecdsaOpts: n
    };
}
function bfe(e, t) {
    return Object.assign({}, t, {
        ProjectivePoint: t.Point,
        CURVE: e
    });
}
function wfe(e) {
    const { CURVE: t, curveOpts: r, ecdsaOpts: n } = mfe(e), i1 = pfe(t, r), o = gfe(i1, n, r);
    return bfe(e, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Afe(e, t) {
    const r = (n)=>wfe({
            ...e,
            hash: n
        });
    return {
        ...r(t),
        create: r
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Km = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const vfe = BigInt(1), h4 = BigInt(2), SI = (e, t)=>(e + t / h4) / t;
function Efe(e) {
    const t = Km.p, r = BigInt(3), n = BigInt(6), i1 = BigInt(11), o = BigInt(22), a = BigInt(23), s = BigInt(44), c = BigInt(88), l = e * e * e % t, u = l * l * e % t, f = ya(u, r, t) * u % t, h = ya(f, r, t) * u % t, y = ya(h, h4, t) * l % t, S = ya(y, i1, t) * y % t, k = ya(S, o, t) * S % t, P = ya(k, s, t) * k % t, M = ya(P, c, t) * P % t, N = ya(M, s, t) * k % t, z = ya(N, r, t) * u % t, K = ya(z, a, t) * S % t, $ = ya(K, n, t) * l % t, ne = ya($, h4, t);
    if (!p4.eql(p4.sqr(ne), e)) throw new Error("Cannot find square root");
    return ne;
}
const p4 = j1(Km.p, void 0, void 0, {
    sqrt: Efe
}), k0 = Afe({
    ...Km,
    Fp: p4,
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (e)=>{
            const t = Km.n, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -vfe * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i1 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, a = BigInt("0x100000000000000000000000000000000"), s = SI(o * e, t), c = SI(-n * e, t);
            let l = Wo(e - s * r - c * i1, t), u = Wo(-s * n - c * o, t);
            const f = l > a, h = u > a;
            if (f && (l = t - l), h && (u = t - u), l > a || u > a) throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: f,
                k1: l,
                k2neg: h,
                k2: u
            };
        }
    }
}, UP);
function Sfe(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function xI(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function xfe(e, t) {
    Sfe(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _fe = (e)=>e instanceof Uint8Array, q3 = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), ks = (e, t)=>e << 32 - t | e >>> t, kfe = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!kfe) throw new Error("Non little-endian hardware is not supported");
function Ofe(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
}
function NR(e) {
    if (typeof e == "string" && (e = Ofe(e)), !_fe(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e;
}
let Ife = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function Bfe(e) {
    const t = (n)=>e().update(NR(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function Tfe(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
let Pfe = class extends Ife {
    constructor(e, t, r, n){
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = q3(this.buffer);
    }
    update(e) {
        xI(this);
        const { view: t, buffer: r, blockLen: n } = this;
        e = NR(e);
        const i1 = e.length;
        for(let o = 0; o < i1;){
            const a = Math.min(n - this.pos, i1 - o);
            if (a === n) {
                const s = q3(e);
                for(; n <= i1 - o; o += n)this.process(s, o);
                continue;
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        xI(this), xfe(e, this), this.finished = !0;
        const { buffer: t, view: r, blockLen: n, isLE: i1 } = this;
        let { pos: o } = this;
        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for(let u = o; u < n; u++)t[u] = 0;
        Tfe(r, n - 8, BigInt(this.length * 8), i1), this.process(r, 0);
        const a = q3(e), s = this.outputLen;
        if (s % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = s / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let u = 0; u < c; u++)a.setUint32(4 * u, l[u], i1);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: r, length: n, finished: i1, destroyed: o, pos: a } = this;
        return e.length = n, e.pos = a, e.finished = i1, e.destroyed = o, n % t && e.buffer.set(r), e;
    }
};
const Cfe = (e, t, r)=>e & t ^ ~e & r, Mfe = (e, t, r)=>e & t ^ e & r ^ t & r, Nfe = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), fc = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), dc = /* @__PURE__ */ new Uint32Array(64);
let Rfe = class extends Pfe {
    constructor(){
        super(64, 32, 8, !1), this.A = fc[0] | 0, this.B = fc[1] | 0, this.C = fc[2] | 0, this.D = fc[3] | 0, this.E = fc[4] | 0, this.F = fc[5] | 0, this.G = fc[6] | 0, this.H = fc[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n, E: i1, F: o, G: a, H: s } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i1 | 0, this.F = o | 0, this.G = a | 0, this.H = s | 0;
    }
    process(e, t) {
        for(let u = 0; u < 16; u++, t += 4)dc[u] = e.getUint32(t, !1);
        for(let u = 16; u < 64; u++){
            const f = dc[u - 15], h = dc[u - 2], y = ks(f, 7) ^ ks(f, 18) ^ f >>> 3, S = ks(h, 17) ^ ks(h, 19) ^ h >>> 10;
            dc[u] = S + dc[u - 7] + y + dc[u - 16] | 0;
        }
        let { A: r, B: n, C: i1, D: o, E: a, F: s, G: c, H: l } = this;
        for(let u = 0; u < 64; u++){
            const f = ks(a, 6) ^ ks(a, 11) ^ ks(a, 25), h = l + f + Cfe(a, s, c) + Nfe[u] + dc[u] | 0, y = (ks(r, 2) ^ ks(r, 13) ^ ks(r, 22)) + Mfe(r, n, i1) | 0;
            l = c, c = s, s = a, a = o + h | 0, o = i1, i1 = n, n = r, r = h + y | 0;
        }
        r = r + this.A | 0, n = n + this.B | 0, i1 = i1 + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, n, i1, o, a, s, c, l);
    }
    roundClean() {
        dc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
};
const g4 = /* @__PURE__ */ Bfe(()=>new Rfe());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // @__NO_SIDE_EFFECTS__
function F1(...e) {
    const t = (i1, o)=>(a)=>i1(o(a)), r = Array.from(e).reverse().reduce((i1, o)=>i1 ? t(i1, o.encode) : o.encode, void 0), n = e.reduce((i1, o)=>i1 ? t(i1, o.decode) : o.decode, void 0);
    return {
        encode: r,
        decode: n
    };
}
// @__NO_SIDE_EFFECTS__
function Pb(e) {
    return {
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
            return t.map((r)=>{
                if (r < 0 || r >= e.length) throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
                return e[r];
            });
        },
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("alphabet.decode input should be array of strings");
            return t.map((r)=>{
                if (typeof r != "string") throw new Error(`alphabet.decode: not string element=${r}`);
                const n = e.indexOf(r);
                if (n === -1) throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
                return n;
            });
        }
    };
}
// @__NO_SIDE_EFFECTS__
function Cb(e = "") {
    if (typeof e != "string") throw new Error("join separator should be string");
    return {
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "string") throw new Error("join.encode input should be array of strings");
            for (let r of t)if (typeof r != "string") throw new Error(`join.encode: non-string input=${r}`);
            return t.join(e);
        },
        decode: (t)=>{
            if (typeof t != "string") throw new Error("join.decode input should be string");
            return t.split(e);
        }
    };
}
// @__NO_SIDE_EFFECTS__
function RR(e, t = "=") {
    if (typeof t != "string") throw new Error("padding chr should be string");
    return {
        encode (r) {
            if (!Array.isArray(r) || r.length && typeof r[0] != "string") throw new Error("padding.encode input should be array of strings");
            for (let n of r)if (typeof n != "string") throw new Error(`padding.encode: non-string input=${n}`);
            for(; r.length * e % 8;)r.push(t);
            return r;
        },
        decode (r) {
            if (!Array.isArray(r) || r.length && typeof r[0] != "string") throw new Error("padding.encode input should be array of strings");
            for (let i1 of r)if (typeof i1 != "string") throw new Error(`padding.decode: non-string input=${i1}`);
            let n = r.length;
            if (n * e % 8) throw new Error("Invalid padding: string should have whole number of bytes");
            for(; n > 0 && r[n - 1] === t; n--)if (!((n - 1) * e % 8)) throw new Error("Invalid padding: string has too much padding");
            return r.slice(0, n);
        }
    };
}
// @__NO_SIDE_EFFECTS__
function _I(e, t, r) {
    if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
    if (!Array.isArray(e)) throw new Error("convertRadix: data should be array");
    if (!e.length) return [];
    let n = 0;
    const i1 = [], o = Array.from(e);
    for(o.forEach((a)=>{
        if (a < 0 || a >= t) throw new Error(`Wrong integer: ${a}`);
    });;){
        let a = 0, s = !0;
        for(let c = n; c < o.length; c++){
            const l = o[c], u = t * a + l;
            if (!Number.isSafeInteger(u) || t * a / t !== a || u - l !== t * a) throw new Error("convertRadix: carry overflow");
            a = u % r;
            const f = Math.floor(u / r);
            if (o[c] = f, !Number.isSafeInteger(f) || f * r + a !== u) throw new Error("convertRadix: carry overflow");
            if (s) f ? s = !1 : n = c;
            else continue;
        }
        if (i1.push(a), s) break;
    }
    for(let a = 0; a < e.length - 1 && e[a] === 0; a++)i1.push(0);
    return i1.reverse();
}
const UR = /* @__NO_SIDE_EFFECTS__ */ (e, t)=>t ? /* @__PURE__ */ UR(t, e % t) : e, qm = /* @__NO_SIDE_EFFECTS__ */ (e, t)=>e + (t - /* @__PURE__ */ UR(e, t));
// @__NO_SIDE_EFFECTS__
function y4(e, t, r, n) {
    if (!Array.isArray(e)) throw new Error("convertRadix2: data should be array");
    if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);
    if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
    if (/* @__PURE__ */ qm(t, r) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ qm(t, r)}`);
    let i1 = 0, o = 0;
    const a = 2 ** r - 1, s = [];
    for (const c of e){
        if (c >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${c} from=${t}`);
        if (i1 = i1 << t | c, o + t > 32) throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);
        for(o += t; o >= r; o -= r)s.push((i1 >> o - r & a) >>> 0);
        i1 &= 2 ** o - 1;
    }
    if (i1 = i1 << r - o & a, !n && o >= t) throw new Error("Excess padding");
    if (!n && i1) throw new Error(`Non-zero padding: ${i1}`);
    return n && o > 0 && s.push(i1 >>> 0), s;
}
// @__NO_SIDE_EFFECTS__
function Ufe(e) {
    return {
        encode: (t)=>{
            if (!(t instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
            return /* @__PURE__ */ _I(Array.from(t), 2 ** 8, e);
        },
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && typeof t[0] != "number") throw new Error("radix.decode input should be array of strings");
            return Uint8Array.from(/* @__PURE__ */ _I(t, e, 2 ** 8));
        }
    };
}
// @__NO_SIDE_EFFECTS__
function F5(e, t = !1) {
    if (e <= 0 || e > 32) throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ qm(8, e) > 32 || /* @__PURE__ */ qm(e, 8) > 32) throw new Error("radix2: carry overflow");
    return {
        encode: (r)=>{
            if (!(r instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
            return /* @__PURE__ */ y4(Array.from(r), 8, e, !t);
        },
        decode: (r)=>{
            if (!Array.isArray(r) || r.length && typeof r[0] != "number") throw new Error("radix2.decode input should be array of strings");
            return Uint8Array.from(/* @__PURE__ */ y4(r, e, 8, t));
        }
    };
}
// @__NO_SIDE_EFFECTS__
function kI(e) {
    if (typeof e != "function") throw new Error("unsafeWrapper fn should be function");
    return function(...t) {
        try {
            return e.apply(null, t);
        } catch  {}
    };
}
// @__NO_SIDE_EFFECTS__
function Dfe(e, t) {
    if (typeof t != "function") throw new Error("checksum fn should be function");
    return {
        encode (r) {
            if (!(r instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
            const n = t(r).slice(0, e), i1 = new Uint8Array(r.length + e);
            return i1.set(r), i1.set(n, r.length), i1;
        },
        decode (r) {
            if (!(r instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
            const n = r.slice(0, -e), i1 = t(n).slice(0, e), o = r.slice(-e);
            for(let a = 0; a < e; a++)if (i1[a] !== o[a]) throw new Error("Invalid checksum");
            return n;
        }
    };
}
const OI = /* @__PURE__ */ F1(/* @__PURE__ */ F5(6), /* @__PURE__ */ Pb("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ RR(6), /* @__PURE__ */ Cb("")), II = /* @__PURE__ */ F1(/* @__PURE__ */ F5(6), /* @__PURE__ */ Pb("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ RR(6), /* @__PURE__ */ Cb("")), jfe = (e)=>/* @__PURE__ */ F1(/* @__PURE__ */ Ufe(58), /* @__PURE__ */ Pb(e), /* @__PURE__ */ Cb("")), Ffe = /* @__PURE__ */ jfe("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), BI = (e)=>/* @__PURE__ */ F1(/* @__PURE__ */ Dfe(4, (t)=>e(e(t))), Ffe), m4 = /* @__PURE__ */ F1(/* @__PURE__ */ Pb("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ Cb("")), TI = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
];
// @__NO_SIDE_EFFECTS__
function kp(e) {
    const t = e >> 25;
    let r = (e & 33554431) << 5;
    for(let n = 0; n < TI.length; n++)(t >> n & 1) === 1 && (r ^= TI[n]);
    return r;
}
// @__NO_SIDE_EFFECTS__
function PI(e, t, r = 1) {
    const n = e.length;
    let i1 = 1;
    for(let o = 0; o < n; o++){
        const a = e.charCodeAt(o);
        if (a < 33 || a > 126) throw new Error(`Invalid prefix (${e})`);
        i1 = /* @__PURE__ */ kp(i1) ^ a >> 5;
    }
    i1 = /* @__PURE__ */ kp(i1);
    for(let o = 0; o < n; o++)i1 = /* @__PURE__ */ kp(i1) ^ e.charCodeAt(o) & 31;
    for (let o of t)i1 = /* @__PURE__ */ kp(i1) ^ o;
    for(let o = 0; o < 6; o++)i1 = /* @__PURE__ */ kp(i1);
    return i1 ^= r, m4.encode(/* @__PURE__ */ y4([
        i1 % 2 ** 30
    ], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function DR(e) {
    const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ F5(5), n = r.decode, i1 = r.encode, o = /* @__PURE__ */ kI(n);
    function a(u, f, h = 90) {
        if (typeof u != "string") throw new Error(`bech32.encode prefix should be string, not ${typeof u}`);
        if (!Array.isArray(f) || f.length && typeof f[0] != "number") throw new Error(`bech32.encode words should be array of numbers, not ${typeof f}`);
        const y = u.length + 7 + f.length;
        if (h !== !1 && y > h) throw new TypeError(`Length ${y} exceeds limit ${h}`);
        const S = u.toLowerCase(), k = /* @__PURE__ */ PI(S, f, t);
        return `${S}1${m4.encode(f)}${k}`;
    }
    function s(u, f = 90) {
        if (typeof u != "string") throw new Error(`bech32.decode input should be string, not ${typeof u}`);
        if (u.length < 8 || f !== !1 && u.length > f) throw new TypeError(`Wrong string length: ${u.length} (${u}). Expected (8..${f})`);
        const h = u.toLowerCase();
        if (u !== h && u !== u.toUpperCase()) throw new Error("String must be lowercase or uppercase");
        u = h;
        const y = u.lastIndexOf("1");
        if (y === 0 || y === -1) throw new Error('Letter "1" must be present between prefix and data only');
        const S = u.slice(0, y), k = u.slice(y + 1);
        if (k.length < 6) throw new Error("Data must be at least 6 characters long");
        const P = m4.decode(k).slice(0, -6), M = /* @__PURE__ */ PI(S, P, t);
        if (!k.endsWith(M)) throw new Error(`Invalid checksum in ${u}: expected "${M}"`);
        return {
            prefix: S,
            words: P
        };
    }
    const c = /* @__PURE__ */ kI(s);
    function l(u) {
        const { prefix: f, words: h } = s(u, !1);
        return {
            prefix: f,
            words: h,
            bytes: n(h)
        };
    }
    return {
        encode: a,
        decode: s,
        decodeToBytes: l,
        decodeUnsafe: c,
        fromWords: n,
        fromWordsUnsafe: o,
        toWords: i1
    };
}
const Sy = /* @__PURE__ */ DR("bech32"), xy = /* @__PURE__ */ DR("bech32m"), Ks = {
    b58chk: {
        encode: (e)=>BI(g4).encode(e),
        decode: (e)=>BI(g4).decode(e)
    },
    base64: {
        encode: (e)=>OI.encode(e),
        decode: (e)=>OI.decode(e)
    },
    b64url: {
        encode: (e)=>II.encode(e),
        decode: (e)=>II.decode(e)
    },
    bech32: {
        to_words: Sy.toWords,
        to_bytes: Sy.fromWords,
        encode: (e, t, r = !1)=>Sy.encode(e, t, r),
        decode: (e, t = !1)=>{
            const { prefix: r, words: n } = Sy.decode(e, t);
            return {
                prefix: r,
                words: n
            };
        }
    },
    bech32m: {
        to_words: xy.toWords,
        to_bytes: xy.fromWords,
        encode: (e, t, r = !1)=>xy.encode(e, t, r),
        decode: (e, t = !1)=>{
            const { prefix: r, words: n } = xy.decode(e, t);
            return {
                prefix: r,
                words: n
            };
        }
    }
};
function zfe(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Lfe(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Hfe(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
function jR(e, t) {
    if (e !== t) throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
const Kfe = BigInt(0), qfe = BigInt(255), FR = BigInt(256);
function Vfe(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Wfe(e, t, r = "be") {
    t === void 0 && (t = Vfe(e));
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(; e > Kfe;){
        const s = e & qfe, c = Number(s);
        n ? o.setUint8(a++, c) : o.setUint8(a--, c), e = (e - s) / FR;
    }
    return new Uint8Array(i1);
}
function Gfe(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * FR + BigInt(e[r]);
    return BigInt(t);
}
function Qfe(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i1 = 0; n < t.length; n += 8, i1++){
        let o = 0;
        for(let a = 0; a < 8; a++)o |= t[n + a] << 7 - a;
        r[i1] = o;
    }
    return r;
}
function $fe(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i1 = 7; i1 >= 0; i1--, r++)t[r] = n >> i1 & 1;
    }
    return t.join("");
}
function Zfe(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Xfe(e, t, r = "be") {
    t === void 0 && (t = Zfe(e));
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(; e > 0;){
        const s = e & 255;
        n ? o.setUint8(a++, e) : o.setUint8(a--, e), e = (e - s) / 256;
    }
    return new Uint8Array(i1);
}
function Yfe(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], Hfe(t);
    return t;
}
const Jfe = new TextEncoder(), ede = new TextDecoder();
function z5(e) {
    return Jfe.encode(e);
}
function V3(e) {
    return ede.decode(e);
}
function tde(e, t) {
    Lfe(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function rde(e, t, r = "le") {
    t = tde(e, t);
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(let s = 0; s < e.length; s += 2){
        const c = e.substring(s, s + 2), l = parseInt(c, 16);
        n ? o.setUint8(a++, l) : o.setUint8(a--, l);
    }
    return new Uint8Array(i1);
}
function nde(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
const { getRandomValues: ide } = crypto ?? globalThis.crypto ?? window.crypto;
function ode(e = 32) {
    if (typeof ide == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function zR(e) {
    return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function ade(e) {
    return typeof e == "string" && zR(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? !0 : !!(Array.isArray(e) && e.every((t)=>typeof t == "number"));
}
function sde(e, t, r = "be") {
    t === void 0 && (t = e.length), zfe(e, t);
    const n = new Uint8Array(t).fill(0), i1 = r === "be" ? 0 : t - e.length;
    return n.set(e, i1), n;
}
function LR(e) {
    let t, r = 0;
    const n = e.reduce((o, a)=>o + a.length, 0), i1 = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i1.set(o, r), r += o.length;
    }
    return i1;
}
function ude(e, t) {
    return typeof t == "bigint" ? `${t}n` : t;
}
function cde(e, t) {
    return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function lde(e, t, r) {
    const n = e.length, i1 = r / t;
    if (r % t !== 0) throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
    if (n !== r) throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
    if (n % t !== 0) throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
    const o = new Array(i1);
    for(let a = 0; a < i1; a++){
        const s = a * t;
        o[a] = e.subarray(s, s + t);
    }
    return o;
}
function L5(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return sde(e, t, r);
    if (Array.isArray(e)) {
        const n = e.map((i1)=>L5(i1, t, r));
        return LR(n);
    } else {
        if (typeof e == "string") return rde(e, t, r);
        if (typeof e == "bigint") return Wfe(e, t, r);
        if (typeof e == "number") return Xfe(e, t, r);
        if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    }
    throw new TypeError("Unsupported format:" + typeof e);
}
var or;
let fn = (or = class extends Uint8Array {
    static random(e = 32) {
        const t = ode(e);
        return new or(t, e);
    }
    static now(e = 4) {
        const t = Math.floor(Date.now() / 1e3);
        return new or(t, e);
    }
    constructor(e, t, r){
        if (e instanceof or && t === void 0) return e;
        const n = L5(e, t, r);
        super(n);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.to_num();
    }
    get big() {
        return this.to_big();
    }
    get str() {
        return this.to_str();
    }
    get hex() {
        return this.to_hex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.to_bin();
    }
    get b58chk() {
        return this.to_b58chk();
    }
    get base64() {
        return this.to_base64();
    }
    get b64url() {
        return this.to_b64url();
    }
    get digest() {
        return this.to_hash();
    }
    get id() {
        return this.to_hash().hex;
    }
    get stream() {
        return new xde(this);
    }
    to_num(e = "be") {
        const t = e === "be" ? this.reverse() : this;
        return Yfe(t);
    }
    to_big(e = "be") {
        const t = e === "be" ? this.reverse() : this;
        return Gfe(t);
    }
    to_bin() {
        return $fe(this);
    }
    to_hash() {
        const e = g4(this);
        return new or(e);
    }
    to_json(e) {
        e === void 0 && (e = cde);
        const t = V3(this);
        return JSON.parse(t, e);
    }
    to_bech32(e, t) {
        const { encode: r, to_words: n } = Ks.bech32, i1 = n(this);
        return r(e, i1, t);
    }
    to_bech32m(e, t) {
        const { encode: r, to_words: n } = Ks.bech32m, i1 = n(this);
        return r(e, i1, t);
    }
    to_str() {
        return V3(this);
    }
    to_hex() {
        return nde(this);
    }
    to_bytes() {
        return new Uint8Array(this);
    }
    to_b58chk() {
        return Ks.b58chk.encode(this);
    }
    to_base64() {
        return Ks.base64.encode(this);
    }
    to_b64url() {
        return Ks.b64url.encode(this);
    }
    append(e) {
        return or.join([
            this,
            or.bytes(e)
        ]);
    }
    prepend(e) {
        return or.join([
            or.bytes(e),
            this
        ]);
    }
    reverse() {
        const e = new Uint8Array(this).reverse();
        return new or(e);
    }
    slice(e, t) {
        const r = new Uint8Array(this).slice(e, t);
        return new or(r);
    }
    set(e, t) {
        this.set(e, t);
    }
    subarray(e, t) {
        const r = new Uint8Array(this).subarray(e, t);
        return new or(r);
    }
    write(e, t) {
        const r = or.bytes(e);
        this.set(r, t);
    }
    add_varint(e) {
        const t = or.calc_varint(this.length, e);
        return or.join([
            t,
            this
        ]);
    }
    static from(e) {
        return new or(Uint8Array.from(e));
    }
    static of(...e) {
        return new or(Uint8Array.of(...e));
    }
    static join(e) {
        const t = e.map((n)=>or.bytes(n)), r = LR(t);
        return new or(r);
    }
    static sort(e, t) {
        const r = e.map((n)=>CI(n, t).hex);
        return r.sort(), r.map((n)=>or.hex(n, t));
    }
    static calc_varint(e, t) {
        if (e < 253) return or.num(e, 1);
        if (e < 65536) return or.of(253, ...or.num(e, 2, t));
        if (e < 4294967296) return or.of(254, ...or.num(e, 4, t));
        if (BigInt(e) < 0x10000000000000000n) return or.of(255, ...or.num(e, 8, t));
        throw new Error(`Value is too large: ${e}`);
    }
}, or.num = fde, or.big = hde, or.bin = dde, or.raw = pde, or.str = gde, or.hex = yde, or.bytes = CI, or.json = mde, or.base64 = bde, or.b64url = wde, or.bech32 = Ade, or.bech32m = vde, or.b58chk = Ede, or.encode = z5, or.decode = V3, or.parse = Sde, or.is_bytes = ade, or.is_hex = zR, or);
function fde(e, t, r) {
    return new fn(e, t, r);
}
function dde(e, t, r) {
    return new fn(Qfe(e), t, r);
}
function hde(e, t, r) {
    return new fn(e, t, r);
}
function pde(e, t, r) {
    return new fn(e, t, r);
}
function gde(e, t, r) {
    return new fn(z5(e), t, r);
}
function yde(e, t, r) {
    return new fn(e, t, r);
}
function mde(e, t) {
    t === void 0 && (t = ude);
    const r = JSON.stringify(e, t);
    return new fn(z5(r));
}
function bde(e) {
    return new fn(Ks.base64.decode(e));
}
function wde(e) {
    return new fn(Ks.b64url.decode(e));
}
function Ade(e, t, r) {
    const { decode: n, to_bytes: i1 } = Ks.bech32, { prefix: o, words: a } = n(e, t), s = i1(a);
    return typeof r == "string" && jR(o, r), new fn(s);
}
function vde(e, t, r) {
    const { decode: n, to_bytes: i1 } = Ks.bech32m, { prefix: o, words: a } = n(e, t), s = i1(a);
    return typeof r == "string" && jR(o, r), new fn(s);
}
function Ede(e) {
    return new fn(Ks.b58chk.decode(e));
}
function Sde(e, t, r) {
    const n = L5(e);
    return lde(n, t, r).map((i1)=>fn.bytes(i1));
}
let xde = class {
    constructor(e){
        this.data = fn.bytes(e), this.size = this.data.length;
    }
    peek(e) {
        if (e > this.size) throw new Error(`Size greater than stream: ${e} > ${this.size}`);
        return new fn(this.data.slice(0, e));
    }
    read(e) {
        const t = this.peek(e);
        return this.data = this.data.slice(e), this.size = this.data.length, t;
    }
    read_varint(e) {
        const t = this.read(1).num;
        switch(!0){
            case t >= 0 && t < 253:
                return t;
            case t === 253:
                return this.read(2).to_num(e);
            case t === 254:
                return this.read(4).to_num(e);
            case t === 255:
                return this.read(8).to_num(e);
            default:
                throw new Error(`Varint is out of range: ${t}`);
        }
    }
};
function CI(e, t, r) {
    return new fn(e, t, r);
}
const Vm = k0.CURVE, Mb = Vm.n, _de = Vm.p, MI = {
    x: Vm.Gx,
    y: Vm.Gy
}, kde = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const Ode = (e)=>Wo(e, Mb);
function HR(e, t = !1) {
    if (!t) return !1;
    throw new Error(e);
}
function Ide(e, t, r) {
    const n = fn.bytes(e);
    return n.length !== t ? HR(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function Bde(e, t) {
    return typeof e == "bigint" && kde < e && e < Mb || HR("x value is not in the field!", t), !0;
}
const Tde = j1(Mb, 32, !0), NI = k0.ProjectivePoint, Op = Tde;
var kn;
let bh = (kn = class extends Uint8Array {
    static add(e) {
        return e.map((t)=>kn.mod(t)).reduce((t, r)=>t.add(r));
    }
    static mod(e) {
        return new kn(e);
    }
    static mul(e) {
        return e.map((t)=>kn.mod(t)).reduce((t, r)=>t.mul(r));
    }
    static is_valid(e, t) {
        const r = fn.bytes(e, 32).big;
        return Bde(r, t);
    }
    constructor(e){
        const t = Ode(Pde(e));
        kn.is_valid(t, !0), super(fn.big(t, 32), 32);
    }
    get buff() {
        return new fn(this);
    }
    get raw() {
        return this.buff.raw;
    }
    get big() {
        return this.buff.big;
    }
    get hex() {
        return this.buff.hex;
    }
    get point() {
        return this.generate();
    }
    get hasOddY() {
        return this.point.hasOddY;
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    gt(e) {
        return new kn(e).big > this.big;
    }
    lt(e) {
        return new kn(e).big < this.big;
    }
    eq(e) {
        return new kn(e).big === this.big;
    }
    ne(e) {
        return new kn(e).big !== this.big;
    }
    add(e) {
        const t = kn.mod(e), r = Op.add(this.big, t.big);
        return new kn(r);
    }
    sub(e) {
        const t = kn.mod(e), r = Op.sub(this.big, t.big);
        return new kn(r);
    }
    mul(e) {
        const t = kn.mod(e), r = Op.mul(this.big, t.big);
        return new kn(r);
    }
    pow(e) {
        const t = kn.mod(e), r = Op.pow(this.big, t.big);
        return new kn(r);
    }
    div(e) {
        const t = kn.mod(e), r = Op.div(this.big, t.big);
        return new kn(r);
    }
    negate() {
        return new kn(kn.N - this.big);
    }
    generate() {
        const e = k0.ProjectivePoint.BASE.multiply(this.big);
        return H5.import(e);
    }
}, kn.N = Mb, kn);
var ln;
let H5 = (ln = class {
    static from_x(e, t = !1) {
        let r = Cde(e);
        r.length === 32 ? r = r.prepend(2) : t && (r[0] = 2), Ide(r, 33);
        const n = NI.fromHex(r.hex);
        return n.assertValidity(), new ln(n.x, n.y);
    }
    static generate(e) {
        const t = bh.mod(e), r = ln.base.multiply(t.big);
        return ln.import(r);
    }
    static import(e) {
        const t = e instanceof ln ? {
            x: e.x.big,
            y: e.y.big
        } : {
            x: e.x,
            y: e.y
        };
        return new ln(t.x, t.y);
    }
    constructor(e, t){
        this._p = new NI(e, t, 1n), this.p.assertValidity();
    }
    get p() {
        return this._p;
    }
    get x() {
        return fn.big(this.p.x, 32);
    }
    get y() {
        return fn.big(this.p.y, 32);
    }
    get buff() {
        return fn.raw(this.p.toRawBytes(!0));
    }
    get raw() {
        return this.buff.raw;
    }
    get hex() {
        return this.buff.hex;
    }
    get hasEvenY() {
        return this.p.hasEvenY();
    }
    get hasOddY() {
        return !this.p.hasEvenY();
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    eq(e) {
        const t = e instanceof ln ? e : ln.from_x(e);
        return this.x.big === t.x.big && this.y.big === t.y.big;
    }
    add(e) {
        return e instanceof ln ? ln.import(this.p.add(e.p)) : ln.import(this.p.add(ln.generate(e).p));
    }
    sub(e) {
        return e instanceof ln ? ln.import(this.p.subtract(e.p)) : ln.import(this.p.subtract(ln.generate(e).p));
    }
    mul(e) {
        return e instanceof ln ? ln.import(this.p.multiply(e.x.big)) : ln.import(this.p.multiply(bh.mod(e).big));
    }
    negate() {
        return ln.import(this.p.negate());
    }
}, ln.P = _de, ln.G = new ln(MI.x, MI.y), ln.curve = k0.CURVE, ln.base = k0.ProjectivePoint.BASE, ln.mul = ln.generate, ln);
function Pde(e) {
    if (e instanceof bh) return e.big;
    if (e instanceof H5) return e.x.big;
    if (e instanceof Uint8Array) return fn.raw(e).big;
    if (typeof e == "string") return fn.hex(e).big;
    if (typeof e == "number") return fn.num(e).big;
    if (typeof e == "bigint") return BigInt(e);
    throw TypeError("Invalid input type:" + typeof e);
}
function Cde(e) {
    if (e instanceof bh) return e.point.buff;
    if (e instanceof H5) return e.buff;
    if (e instanceof Uint8Array || typeof e == "string") return fn.bytes(e);
    if (typeof e == "number" || typeof e == "bigint") return fn.bytes(e, 32);
    throw new TypeError(`Unknown type: ${typeof e}`);
}
function Mde(e, t = !1) {
    const r = bh.mod(e);
    return t ? r.negated.buff : r.buff;
}
function KR(e, t = !1) {
    const r = bh.mod(e).point;
    return t ? r.x : r.buff;
}
function b4(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function Nde(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function qR(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Rde(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    b4(e.outputLen), b4(e.blockLen);
}
function Ude(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function Dde(e, t) {
    qR(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const jde = {
    number: b4,
    bool: Nde,
    bytes: qR,
    hash: Rde,
    exists: Ude,
    output: Dde
};
var W3 = jde;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const G3 = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), Os = (e, t)=>e << 32 - t | e >>> t, Fde = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!Fde) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function zde(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function VR(e) {
    if (typeof e == "string" && (e = zde(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
let Lde = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function WR(e) {
    const t = (n)=>e().update(VR(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function Hde(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
let Kde = class extends Lde {
    constructor(e, t, r, n){
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = G3(this.buffer);
    }
    update(e) {
        W3.exists(this);
        const { view: t, buffer: r, blockLen: n } = this;
        e = VR(e);
        const i1 = e.length;
        for(let o = 0; o < i1;){
            const a = Math.min(n - this.pos, i1 - o);
            if (a === n) {
                const s = G3(e);
                for(; n <= i1 - o; o += n)this.process(s, o);
                continue;
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        W3.exists(this), W3.output(e, this), this.finished = !0;
        const { buffer: t, view: r, blockLen: n, isLE: i1 } = this;
        let { pos: o } = this;
        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for(let u = o; u < n; u++)t[u] = 0;
        Hde(r, n - 8, BigInt(this.length * 8), i1), this.process(r, 0);
        const a = G3(e), s = this.outputLen;
        if (s % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = s / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let u = 0; u < c; u++)a.setUint32(4 * u, l[u], i1);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: r, length: n, finished: i1, destroyed: o, pos: a } = this;
        return e.length = n, e.pos = a, e.finished = i1, e.destroyed = o, n % t && e.buffer.set(r), e;
    }
};
const qde = (e, t, r)=>e & t ^ ~e & r, Vde = (e, t, r)=>e & t ^ e & r ^ t & r, Wde = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), hc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), pc = new Uint32Array(64);
let GR = class extends Kde {
    constructor(){
        super(64, 32, 8, !1), this.A = hc[0] | 0, this.B = hc[1] | 0, this.C = hc[2] | 0, this.D = hc[3] | 0, this.E = hc[4] | 0, this.F = hc[5] | 0, this.G = hc[6] | 0, this.H = hc[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n, E: i1, F: o, G: a, H: s } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i1 | 0, this.F = o | 0, this.G = a | 0, this.H = s | 0;
    }
    process(e, t) {
        for(let u = 0; u < 16; u++, t += 4)pc[u] = e.getUint32(t, !1);
        for(let u = 16; u < 64; u++){
            const f = pc[u - 15], h = pc[u - 2], y = Os(f, 7) ^ Os(f, 18) ^ f >>> 3, S = Os(h, 17) ^ Os(h, 19) ^ h >>> 10;
            pc[u] = S + pc[u - 7] + y + pc[u - 16] | 0;
        }
        let { A: r, B: n, C: i1, D: o, E: a, F: s, G: c, H: l } = this;
        for(let u = 0; u < 64; u++){
            const f = Os(a, 6) ^ Os(a, 11) ^ Os(a, 25), h = l + f + qde(a, s, c) + Wde[u] + pc[u] | 0, y = (Os(r, 2) ^ Os(r, 13) ^ Os(r, 22)) + Vde(r, n, i1) | 0;
            l = c, c = s, s = a, a = o + h | 0, o = i1, i1 = n, n = r, r = h + y | 0;
        }
        r = r + this.A | 0, n = n + this.B | 0, i1 = i1 + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, n, i1, o, a, s, c, l);
    }
    roundClean() {
        pc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, Gde = class extends GR {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const w4 = WR(()=>new GR());
WR(()=>new Gde());
function Qde(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function $de(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Zde(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Xde } = crypto ?? globalThis.crypto ?? window.crypto;
function Yde(e = 32) {
    if (typeof Xde == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function Jde(e, t, r = "be") {
    t === void 0 && (t = e.length), Qde(e, t);
    const n = new Uint8Array(t).fill(0), i1 = r === "be" ? 0 : t - e.length;
    return n.set(e, i1), n;
}
function QR(e) {
    let t, r = 0;
    const n = e.reduce((o, a)=>o + a.length, 0), i1 = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i1.set(o, r), r += o.length;
    }
    return i1;
}
const ehe = new TextEncoder(), the = [
    {
        name: "base58",
        charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }
];
function $R(e) {
    for (const t of the)if (t.name === e) return t.charset;
    throw TypeError("Charset does not exist: " + e);
}
function rhe(e, t, r = !1) {
    typeof e == "string" && (e = ehe.encode(e));
    const n = $R(t), i1 = n.length, o = [];
    let a = "", s, c = 0, l, u;
    for(s = 0; s < e.length; s++)for(c = 0, l = e[s], a += l > 0 || (a.length ^ s) > 0 ? "" : "1"; c in o || l > 0;)u = o[c], u = u > 0 ? u * 256 + l : l, l = u / i1 | 0, o[c] = u % i1, c++;
    for(; c-- > 0;)a += n[o[c]];
    return r && a.length % 4 > 0 ? a + "=".repeat(4 - a.length % 4) : a;
}
function nhe(e, t) {
    const r = $R(t), n = r.length, i1 = [], o = [];
    e = e.replace("=", "");
    let a, s = 0, c, l;
    for(a = 0; a < e.length; a++){
        if (s = 0, c = r.indexOf(e[a]), c < 0) throw new Error(`Character range out of bounds: ${c}`);
        for(c > 0 || (o.length ^ a) > 0 || o.push(0); s in i1 || c > 0;)l = i1[s], l = l > 0 ? l * n + c : c, c = l >> 8, i1[s] = l % 256, s++;
    }
    for(; s-- > 0;)o.push(i1[s]);
    return new Uint8Array(o);
}
function ZR(e) {
    return w4(w4(e));
}
function ihe(e) {
    const t = ZR(e);
    return QR([
        e,
        t.slice(0, 4)
    ]);
}
function ohe(e) {
    const t = e.slice(0, -4), r = e.slice(-4);
    if (ZR(t).slice(0, 4).toString() !== r.toString()) throw new Error("Invalid checksum!");
    return t;
}
const RI = {
    encode: rhe,
    decode: nhe
}, XR = {
    encode: (e)=>{
        const t = ihe(e);
        return RI.encode(t, "base58");
    },
    decode: (e)=>{
        const t = RI.decode(e, "base58");
        return ohe(t);
    }
}, YR = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ahe = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
], Wm = [
    {
        version: 0,
        name: "bech32",
        const: 1
    },
    {
        version: 1,
        name: "bech32m",
        const: 734539939
    }
];
function JR(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = t >> 25;
        t = (t & 33554431) << 5 ^ e[r];
        for(let i1 = 0; i1 < 5; ++i1)n >> i1 & 1 && (t ^= ahe[i1]);
    }
    return t;
}
function eU(e) {
    const t = [];
    let r;
    for(r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) >> 5);
    for(t.push(0), r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) & 31);
    return t;
}
function she(e, t, r) {
    const n = eU(e).concat(t);
    return JR(n) === r.const;
}
function uhe(e, t, r) {
    const n = eU(e).concat(t).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ]), i1 = JR(n) ^ r.const, o = [];
    for(let a = 0; a < 6; ++a)o.push(i1 >> 5 * (5 - a) & 31);
    return o;
}
function tU(e, t, r, n = !0) {
    const i1 = [];
    let o = 0, a = 0;
    const s = (1 << r) - 1, c = (1 << t + r - 1) - 1;
    for (const l of e){
        if (l < 0 || l >> t > 0) throw new Error("Failed to perform base conversion. Invalid value: " + String(l));
        for(o = (o << t | l) & c, a += t; a >= r;)a -= r, i1.push(o >> a & s);
    }
    if (n) a > 0 && i1.push(o << r - a & s);
    else if (a >= t || (o << r - a & s) > 0) throw new Error("Failed to perform base conversion. Invalid Size!");
    return i1;
}
function che(e, t, r) {
    const n = t.concat(uhe(e, t, r));
    let i1 = e + "1";
    for(let o = 0; o < n.length; ++o)i1 += YR.charAt(n[o]);
    return i1;
}
function rU(e) {
    if (!lhe(e)) throw new Error("Encoded string goes out of bounds!");
    if (e = e.toLowerCase(), !fhe(e)) throw new Error("Encoded string has invalid separator!");
    const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
    for(let o = r + 1; o < e.length; ++o){
        const a = YR.indexOf(e.charAt(o));
        if (a === -1) throw new Error("Character idx out of bounds: " + String(o));
        t.push(a);
    }
    const i1 = Wm.find((o)=>o.version === t[0]) ?? Wm[0];
    if (!she(n, t, i1)) throw new Error("Checksum verification failed!");
    return [
        n,
        t.slice(0, t.length - 6)
    ];
}
function lhe(e) {
    let t, r, n = !1, i1 = !1;
    for(t = 0; t < e.length; ++t){
        if (r = e.charCodeAt(t), r < 33 || r > 126) return !1;
        r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i1 = !0);
    }
    return !(n && i1);
}
function fhe(e) {
    const t = e.lastIndexOf("1");
    return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function dhe(e, t = "bc", r = 0) {
    const n = [
        r,
        ...tU([
            ...e
        ], 8, 5)
    ], i1 = Wm.find((a)=>a.version === r) ?? Wm[0], o = che(t, n, i1);
    return nU(o), o;
}
function nU(e) {
    e = e.toLowerCase();
    const t = e.split("1", 1)[0], [r, n] = rU(e), i1 = tU(n.slice(1), 5, 8, !1), o = i1.length;
    switch(!0){
        case t !== r:
            throw new Error("Returned hrp string is invalid.");
        case i1 === null || o < 2 || o > 40:
            throw new Error("Decoded string is invalid or out of spec.");
        case n[0] > 16:
            throw new Error("Returned version bit is out of range.");
        default:
            return Uint8Array.from(i1);
    }
}
function hhe(e) {
    e = e.toLowerCase();
    const [t, r] = rU(e);
    return r[0];
}
const iU = {
    encode: dhe,
    decode: nU,
    version: hhe
}, oU = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", aU = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", phe = new TextEncoder();
function sU(e, t = !1, r = !0) {
    typeof e == "string" && (e = phe.encode(e));
    const n = t ? aU : oU;
    let i1 = "", o = 0, a = 0;
    for(let s = 0; s < e.length; s++)for(a = a << 8 | e[s], o += 8; o >= 6;)o -= 6, i1 += n[a >> o & 63];
    if (o > 0) for(a <<= 6 - o, i1 += n[a & 63]; o < 6;)i1 += r ? "=" : "", o += 2;
    return i1;
}
function uU(e, t = !1) {
    const r = t || e.includes("-") || e.includes("_") ? aU.split("") : oU.split("");
    e = e.replace(/=+$/, "");
    const n = e.split("");
    let i1 = 0, o = 0;
    const a = [];
    for(let s = 0; s < n.length; s++){
        const c = n[s], l = r.indexOf(c);
        if (l === -1) throw new Error("Invalid character: " + c);
        i1 += 6, o <<= 6, o |= l, i1 >= 8 && (i1 -= 8, a.push(o >>> i1 & 255));
    }
    return new Uint8Array(a);
}
const cU = {
    encode: sU,
    decode: uU
}, lU = {
    encode: (e)=>sU(e, !0, !1),
    decode: (e)=>uU(e, !0)
}, ghe = BigInt(0), yhe = BigInt(255), fU = BigInt(256);
function mhe(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function bhe(e, t, r = "be") {
    t === void 0 && (t = mhe(e));
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(; e > ghe;){
        const s = e & yhe, c = Number(s);
        n ? o.setUint8(a++, c) : o.setUint8(a--, c), e = (e - s) / fU;
    }
    return new Uint8Array(i1);
}
function whe(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * fU + BigInt(e[r]);
    return BigInt(t);
}
function Ahe(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i1 = 0; n < t.length; n += 8, i1++){
        let o = 0;
        for(let a = 0; a < 8; a++)o |= t[n + a] << 7 - a;
        r[i1] = o;
    }
    return r;
}
function vhe(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i1 = 7; i1 >= 0; i1--, r++)t[r] = n >> i1 & 1;
    }
    return t.join("");
}
function Ehe(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function She(e, t, r = "be") {
    t === void 0 && (t = Ehe(e));
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(; e > 0;){
        const s = e & 255;
        n ? o.setUint8(a++, e) : o.setUint8(a--, e), e = (e - s) / 256;
    }
    return new Uint8Array(i1);
}
function xhe(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], Zde(t);
    return t;
}
const _he = new TextEncoder(), khe = new TextDecoder();
function K5(e) {
    return _he.encode(e);
}
function Q3(e) {
    return khe.decode(e);
}
function Ohe(e, t) {
    $de(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function Ihe(e, t, r = "le") {
    t = Ohe(e, t);
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(let s = 0; s < e.length; s += 2){
        const c = e.substring(s, s + 2), l = parseInt(c, 16);
        n ? o.setUint8(a++, l) : o.setUint8(a--, l);
    }
    return new Uint8Array(i1);
}
function Bhe(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
function The(e) {
    const t = JSON.stringify(e, (r, n)=>typeof n == "bigint" ? `${n}n` : n);
    return K5(t);
}
function Phe(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return Jde(e, t, r);
    if (typeof e == "string") return Ihe(e, t, r);
    if (typeof e == "bigint") return bhe(e, t, r);
    if (typeof e == "number") return She(e, t, r);
    if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    throw TypeError("Unsupported format:" + typeof e);
}
var Cr;
let $e = (Cr = class extends Uint8Array {
    static random(e = 32) {
        const t = Yde(e);
        return new Cr(t, e);
    }
    constructor(e, t, r){
        const n = Phe(e, t, r);
        super(n);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new Jh(this);
    }
    toNum(e = "be") {
        const t = e === "be" ? this.reverse() : this;
        return xhe(t);
    }
    toBin() {
        return vhe(this);
    }
    toBig(e = "be") {
        const t = e === "be" ? this.reverse() : this;
        return whe(t);
    }
    toHash() {
        const e = w4(this);
        return new Cr(e);
    }
    toJson() {
        const e = Q3(this);
        return JSON.parse(e);
    }
    toBech32(e, t = 0) {
        return iU.encode(this, e, t);
    }
    toStr() {
        return Q3(this);
    }
    toHex() {
        return Bhe(this);
    }
    toBytes() {
        return new Uint8Array(this);
    }
    tob58chk() {
        return XR.encode(this);
    }
    toBase64() {
        return cU.encode(this);
    }
    toB64url() {
        return lU.encode(this);
    }
    prepend(e) {
        return Cr.join([
            Cr.bytes(e),
            this
        ]);
    }
    append(e) {
        return Cr.join([
            this,
            Cr.bytes(e)
        ]);
    }
    slice(e, t) {
        const r = new Uint8Array(this).slice(e, t);
        return new Cr(r);
    }
    subarray(e, t) {
        const r = new Uint8Array(this).subarray(e, t);
        return new Cr(r);
    }
    reverse() {
        const e = new Uint8Array(this).reverse();
        return new Cr(e);
    }
    write(e, t) {
        const r = Cr.bytes(e);
        this.set(r, t);
    }
    prefixSize(e) {
        const t = Cr.varInt(this.length, e);
        return Cr.join([
            t,
            this
        ]);
    }
    static from(e) {
        return new Cr(Uint8Array.from(e));
    }
    static of(...e) {
        return new Cr(Uint8Array.of(...e));
    }
    static join(e) {
        const t = e.map((n)=>Cr.bytes(n)), r = QR(t);
        return new Cr(r);
    }
    static varInt(e, t) {
        if (e < 253) return Cr.num(e, 1);
        if (e < 65536) return Cr.of(253, ...Cr.num(e, 2, t));
        if (e < 4294967296) return Cr.of(254, ...Cr.num(e, 4, t));
        if (BigInt(e) < 0x10000000000000000n) return Cr.of(255, ...Cr.num(e, 8, t));
        throw new Error(`Value is too large: ${e}`);
    }
}, Cr.num = Che, Cr.big = Nhe, Cr.bin = Mhe, Cr.raw = Rhe, Cr.str = Uhe, Cr.hex = Dhe, Cr.bytes = jhe, Cr.json = Fhe, Cr.base64 = zhe, Cr.b64url = Lhe, Cr.bech32 = Hhe, Cr.b58chk = Khe, Cr.encode = K5, Cr.decode = Q3, Cr);
function Che(e, t, r) {
    return new $e(e, t, r);
}
function Mhe(e, t, r) {
    return new $e(Ahe(e), t, r);
}
function Nhe(e, t, r) {
    return new $e(e, t, r);
}
function Rhe(e, t, r) {
    return new $e(e, t, r);
}
function Uhe(e, t, r) {
    return new $e(K5(e), t, r);
}
function Dhe(e, t, r) {
    return new $e(e, t, r);
}
function jhe(e, t, r) {
    return new $e(e, t, r);
}
function Fhe(e) {
    return new $e(The(e));
}
function zhe(e) {
    return new $e(cU.decode(e));
}
function Lhe(e) {
    return new $e(lU.decode(e));
}
function Hhe(e) {
    return new $e(iU.decode(e));
}
function Khe(e) {
    return new $e(XR.decode(e));
}
let Jh = class {
    constructor(e){
        this.data = $e.bytes(e), this.size = this.data.length;
    }
    peek(e) {
        if (e > this.size) throw new Error(`Size greater than stream: ${e} > ${this.size}`);
        return new $e(this.data.slice(0, e));
    }
    read(e) {
        e = e ?? this.readSize();
        const t = this.peek(e);
        return this.data = this.data.slice(e), this.size = this.data.length, t;
    }
    readSize(e) {
        const t = this.read(1).num;
        switch(!0){
            case t >= 0 && t < 253:
                return t;
            case t === 253:
                return this.read(2).toNum(e);
            case t === 254:
                return this.read(4).toNum(e);
            case t === 255:
                return this.read(8).toNum(e);
            default:
                throw new Error(`Varint is out of range: ${t}`);
        }
    }
};
function ru(e, t) {
    const r = $e.bytes(e);
    if (r.length !== t) throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function Go(e, t) {
    if (t) throw new Error(e);
    return !1;
}
function Zy(e, ...t) {
    const r = $e.str(e).digest.raw, n = t.map((i1)=>$e.bytes(i1));
    return $e.join([
        r,
        r,
        $e.join(n)
    ]).digest;
}
const dU = {
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_SUCCESS80: 80,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_SUCCESS98: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_SUCCESS126: 126,
    OP_SUCCESS127: 127,
    OP_SUCCESS128: 128,
    OP_SUCCESS129: 129,
    OP_SIZE: 130,
    OP_SUCCESS131: 131,
    OP_SUCCESS132: 132,
    OP_SUCCESS133: 133,
    OP_SUCCESS134: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_SUCCESS137: 137,
    OP_SUCCESS138: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_SUCCESS141: 141,
    OP_SUCCESS142: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_SUCCESS149: 149,
    OP_SUCCESS150: 150,
    OP_SUCCESS151: 151,
    OP_SUCCESS152: 152,
    OP_SUCCESS153: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_SUCCESS187: 187,
    OP_SUCCESS188: 188,
    OP_SUCCESS189: 189,
    OP_SUCCESS190: 190,
    OP_SUCCESS191: 191,
    OP_SUCCESS192: 192,
    OP_SUCCESS193: 193,
    OP_SUCCESS194: 194,
    OP_SUCCESS195: 195,
    OP_SUCCESS196: 196,
    OP_SUCCESS197: 197,
    OP_SUCCESS198: 198,
    OP_SUCCESS199: 199,
    OP_SUCCESS200: 200,
    OP_SUCCESS201: 201,
    OP_SUCCESS202: 202,
    OP_SUCCESS203: 203,
    OP_SUCCESS204: 204,
    OP_SUCCESS205: 205,
    OP_SUCCESS206: 206,
    OP_SUCCESS207: 207,
    OP_SUCCESS208: 208,
    OP_SUCCESS209: 209,
    OP_SUCCESS210: 210,
    OP_SUCCESS211: 211,
    OP_SUCCESS212: 212,
    OP_SUCCESS213: 213,
    OP_SUCCESS214: 214,
    OP_SUCCESS215: 215,
    OP_SUCCESS216: 216,
    OP_SUCCESS217: 217,
    OP_SUCCESS218: 218,
    OP_SUCCESS219: 219,
    OP_SUCCESS220: 220,
    OP_SUCCESS221: 221,
    OP_SUCCESS222: 222,
    OP_SUCCESS223: 223,
    OP_SUCCESS224: 224,
    OP_SUCCESS225: 225,
    OP_SUCCESS226: 226,
    OP_SUCCESS227: 227,
    OP_SUCCESS228: 228,
    OP_SUCCESS229: 229,
    OP_SUCCESS230: 230,
    OP_SUCCESS231: 231,
    OP_SUCCESS232: 232,
    OP_SUCCESS233: 233,
    OP_SUCCESS234: 234,
    OP_SUCCESS235: 235,
    OP_SUCCESS236: 236,
    OP_SUCCESS237: 237,
    OP_SUCCESS238: 238,
    OP_SUCCESS239: 239,
    OP_SUCCESS240: 240,
    OP_SUCCESS241: 241,
    OP_SUCCESS242: 242,
    OP_SUCCESS243: 243,
    OP_SUCCESS244: 244,
    OP_SUCCESS245: 245,
    OP_SUCCESS246: 246,
    OP_SUCCESS247: 247,
    OP_SUCCESS248: 248,
    OP_SUCCESS249: 249,
    OP_SUCCESS250: 250,
    OP_SUCCESS251: 251,
    OP_SUCCESS252: 252,
    OP_SUCCESS253: 253,
    OP_SUCCESS254: 254
};
function qhe(e) {
    if (e > 186 && e < 255) return "OP_SUCCESS" + String(e);
    for (const [t, r] of Object.entries(dU))if (r === e) return t;
    throw new Error("OPCODE not found:" + String(e));
}
function Vhe(e) {
    for (const [t, r] of Object.entries(dU))if (t === e) return Number(r);
    throw new Error("OPCODE not found:" + e);
}
function Whe(e) {
    switch(!0){
        case e === 0:
            return "opcode";
        case e >= 1 && e <= 75:
            return "varint";
        case e === 76:
            return "pushdata1";
        case e === 77:
            return "pushdata2";
        case e === 78:
            return "pushdata4";
        case e <= 254:
            return "opcode";
        default:
            throw new Error(`Invalid word range: ${e}`);
    }
}
function Ghe(e) {
    const t = [];
    switch(!0){
        case typeof e != "number":
            return !1;
        case e === 0:
            return !0;
        case t.includes(e):
            return !1;
        case 75 < e && e < 254:
            return !0;
        default:
            return !1;
    }
}
function Vu(e) {
    return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function hU(e) {
    return Vu(e) || e instanceof Uint8Array;
}
const Gm = 520;
function zf(e = [], t = !0) {
    let r = $e.num(0);
    return Array.isArray(e) && (r = $e.raw(pU(e))), Vu(e) && (r = $e.hex(e)), e instanceof Uint8Array && (r = $e.raw(e)), t && (r = r.prefixSize("le")), r;
}
function pU(e) {
    const t = [];
    for (const r of e)t.push(Qhe(r));
    return t.length > 0 ? $e.join(t) : new Uint8Array();
}
function Qhe(e) {
    let t = new Uint8Array();
    if (typeof e == "string") {
        if (e.startsWith("OP_")) return $e.num(Vhe(e), 1);
        Vu(e) ? t = $e.hex(e) : t = $e.str(e);
    } else t = $e.bytes(e);
    if (t.length === 1) return t[0] !== 0 && t[0] <= 16 ? (t[0] += 80, t) : (t[0] > 128 && t[0] <= 255 && (t = new Uint8Array([
        t[0],
        0
    ])), $e.join([
        UI(t.length),
        t
    ]));
    if (t.length > Gm) {
        const r = $he(t);
        return pU(r);
    } else return $e.join([
        UI(t.length),
        t
    ]);
}
function UI(e) {
    const t = $e.num(76, 1), r = $e.num(77, 1);
    switch(!0){
        case e <= 75:
            return $e.num(e);
        case e > 75 && e < 256:
            return $e.join([
                t,
                $e.num(e, 1, "le")
            ]);
        case e >= 256 && e <= Gm:
            return $e.join([
                r,
                $e.num(e, 2, "le")
            ]);
        default:
            throw new Error("Invalid word size:" + e.toString());
    }
}
function $he(e) {
    const t = [], r = new Jh(e);
    for(; r.size > Gm;)t.push(r.read(Gm));
    return t.push(r.read(r.size)), t;
}
function q5(e, t = !1) {
    let r = $e.bytes(e);
    if (t) {
        const n = r.stream.readSize("le");
        if (r = r.slice(1), r.length !== n) throw new Error(`Varint does not match stream size: ${n} !== ${r.length}`);
    }
    return Zhe(r);
}
function Zhe(e) {
    const t = new Jh(e), r = [], n = t.size;
    let i1, o, a, s = 0;
    for(; s < n;)switch(i1 = t.read(1).num, o = Whe(i1), s++, o){
        case "varint":
            r.push(t.read(i1).hex), s += i1;
            break;
        case "pushdata1":
            a = t.read(1).reverse().num, r.push(t.read(a).hex), s += a + 1;
            break;
        case "pushdata2":
            a = t.read(2).reverse().num, r.push(t.read(a).hex), s += a + 2;
            break;
        case "pushdata4":
            a = t.read(4).reverse().num, r.push(t.read(a).hex), s += a + 4;
            break;
        case "opcode":
            if (!Ghe(i1)) throw new Error(`Invalid OPCODE: ${i1}`);
            r.push(qhe(i1));
            break;
        default:
            throw new Error(`Word type undefined: ${i1}`);
    }
    return r;
}
function Xhe(e, t) {
    if (Array.isArray(e) && (e = zf(e, t)), e instanceof Uint8Array || Vu(e)) return q5(e, t);
    throw new Error("Invalid format: " + typeof e);
}
function Yhe(e, t) {
    if ((e instanceof Uint8Array || Vu(e)) && (e = q5(e, t)), Array.isArray(e)) return zf(e, t);
    throw new Error("Invalid format: " + typeof e);
}
function Jhe(e) {
    if (!Array.isArray(e)) return $e.bytes(e);
    throw new Error("Invalid format: " + typeof e);
}
const epe = {
    toAsm: Xhe,
    toBytes: Yhe,
    toParam: Jhe
}, nu = {
    encode: zf,
    decode: q5,
    fmt: epe
};
function A4(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function tpe(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function gU(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function rpe(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    A4(e.outputLen), A4(e.blockLen);
}
function npe(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function ipe(e, t) {
    gU(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const ope = {
    number: A4,
    bool: tpe,
    bytes: gU,
    hash: rpe,
    exists: npe,
    output: ipe
};
var Ql = ope;
const $3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Z3 = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), Is = (e, t)=>e << 32 - t | e >>> t, ape = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!ape) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function spe(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function V5(e) {
    if (typeof e == "string" && (e = spe(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
function upe(...e) {
    if (!e.every((n)=>n instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (e.length === 1) return e[0];
    const t = e.reduce((n, i1)=>n + i1.length, 0), r = new Uint8Array(t);
    for(let n = 0, i1 = 0; n < e.length; n++){
        const o = e[n];
        r.set(o, i1), i1 += o.length;
    }
    return r;
}
let yU = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function mU(e) {
    const t = (n)=>e().update(V5(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function cpe(e = 32) {
    if ($3 && typeof $3.getRandomValues == "function") return $3.getRandomValues(new Uint8Array(e));
    throw new Error("crypto.getRandomValues must be defined");
}
function lpe(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
let fpe = class extends yU {
    constructor(e, t, r, n){
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Z3(this.buffer);
    }
    update(e) {
        Ql.exists(this);
        const { view: t, buffer: r, blockLen: n } = this;
        e = V5(e);
        const i1 = e.length;
        for(let o = 0; o < i1;){
            const a = Math.min(n - this.pos, i1 - o);
            if (a === n) {
                const s = Z3(e);
                for(; n <= i1 - o; o += n)this.process(s, o);
                continue;
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        Ql.exists(this), Ql.output(e, this), this.finished = !0;
        const { buffer: t, view: r, blockLen: n, isLE: i1 } = this;
        let { pos: o } = this;
        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for(let u = o; u < n; u++)t[u] = 0;
        lpe(r, n - 8, BigInt(this.length * 8), i1), this.process(r, 0);
        const a = Z3(e), s = this.outputLen;
        if (s % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = s / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let u = 0; u < c; u++)a.setUint32(4 * u, l[u], i1);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: r, length: n, finished: i1, destroyed: o, pos: a } = this;
        return e.length = n, e.pos = a, e.finished = i1, e.destroyed = o, n % t && e.buffer.set(r), e;
    }
};
const dpe = (e, t, r)=>e & t ^ ~e & r, hpe = (e, t, r)=>e & t ^ e & r ^ t & r, ppe = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), gc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), yc = new Uint32Array(64);
let bU = class extends fpe {
    constructor(){
        super(64, 32, 8, !1), this.A = gc[0] | 0, this.B = gc[1] | 0, this.C = gc[2] | 0, this.D = gc[3] | 0, this.E = gc[4] | 0, this.F = gc[5] | 0, this.G = gc[6] | 0, this.H = gc[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n, E: i1, F: o, G: a, H: s } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i1 | 0, this.F = o | 0, this.G = a | 0, this.H = s | 0;
    }
    process(e, t) {
        for(let u = 0; u < 16; u++, t += 4)yc[u] = e.getUint32(t, !1);
        for(let u = 16; u < 64; u++){
            const f = yc[u - 15], h = yc[u - 2], y = Is(f, 7) ^ Is(f, 18) ^ f >>> 3, S = Is(h, 17) ^ Is(h, 19) ^ h >>> 10;
            yc[u] = S + yc[u - 7] + y + yc[u - 16] | 0;
        }
        let { A: r, B: n, C: i1, D: o, E: a, F: s, G: c, H: l } = this;
        for(let u = 0; u < 64; u++){
            const f = Is(a, 6) ^ Is(a, 11) ^ Is(a, 25), h = l + f + dpe(a, s, c) + ppe[u] + yc[u] | 0, y = (Is(r, 2) ^ Is(r, 13) ^ Is(r, 22)) + hpe(r, n, i1) | 0;
            l = c, c = s, s = a, a = o + h | 0, o = i1, i1 = n, n = r, r = h + y | 0;
        }
        r = r + this.A | 0, n = n + this.B | 0, i1 = i1 + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, n, i1, o, a, s, c, l);
    }
    roundClean() {
        yc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, gpe = class extends bU {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const wU = mU(()=>new bU());
mU(()=>new gpe());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ype = BigInt(0), W5 = BigInt(1), mpe = BigInt(2), Nb = (e)=>e instanceof Uint8Array, bpe = Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function wh(e) {
    if (!Nb(e)) throw new Error("Uint8Array expected");
    let t = "";
    for(let r = 0; r < e.length; r++)t += bpe[e[r]];
    return t;
}
function AU(e) {
    const t = e.toString(16);
    return t.length & 1 ? `0${t}` : t;
}
function G5(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return BigInt(e === "" ? "0" : `0x${e}`);
}
function Ah(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    if (e.length % 2) throw new Error("hex string is invalid: unpadded " + e.length);
    const t = new Uint8Array(e.length / 2);
    for(let r = 0; r < t.length; r++){
        const n = r * 2, i1 = e.slice(n, n + 2), o = Number.parseInt(i1, 16);
        if (Number.isNaN(o) || o < 0) throw new Error("invalid byte sequence");
        t[r] = o;
    }
    return t;
}
function Vc(e) {
    return G5(wh(e));
}
function Q5(e) {
    if (!Nb(e)) throw new Error("Uint8Array expected");
    return G5(wh(Uint8Array.from(e).reverse()));
}
const Qd = (e, t)=>Ah(e.toString(16).padStart(t * 2, "0")), vU = (e, t)=>Qd(e, t).reverse(), wpe = (e)=>Ah(AU(e));
function ka(e, t, r) {
    let n;
    if (typeof t == "string") try {
        n = Ah(t);
    } catch (o) {
        throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
    else if (Nb(t)) n = Uint8Array.from(t);
    else throw new Error(`${e} must be hex string or Uint8Array`);
    const i1 = n.length;
    if (typeof r == "number" && i1 !== r) throw new Error(`${e} expected ${r} bytes, got ${i1}`);
    return n;
}
function es(...e) {
    const t = new Uint8Array(e.reduce((n, i1)=>n + i1.length, 0));
    let r = 0;
    return e.forEach((n)=>{
        if (!Nb(n)) throw new Error("Uint8Array expected");
        t.set(n, r), r += n.length;
    }), t;
}
function Ape(e, t) {
    if (e.length !== t.length) return !1;
    for(let r = 0; r < e.length; r++)if (e[r] !== t[r]) return !1;
    return !0;
}
function Rb(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function vpe(e) {
    let t;
    for(t = 0; e > 0n; e >>= W5, t += 1);
    return t;
}
const Epe = (e, t)=>e >> BigInt(t) & 1n, Spe = (e, t, r)=>e | (r ? W5 : ype) << BigInt(t), $5 = (e)=>(mpe << BigInt(e - 1)) - W5, X3 = (e)=>new Uint8Array(e), DI = (e)=>Uint8Array.from(e);
function EU(e, t, r) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    let n = X3(e), i1 = X3(e), o = 0;
    const a = ()=>{
        n.fill(1), i1.fill(0), o = 0;
    }, s = (...u)=>r(i1, n, ...u), c = (u = X3())=>{
        i1 = s(DI([
            0
        ]), u), n = s(), u.length !== 0 && (i1 = s(DI([
            1
        ]), u), n = s());
    }, l = ()=>{
        if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let u = 0;
        const f = [];
        for(; u < t;){
            n = s();
            const h = n.slice();
            f.push(h), u += n.length;
        }
        return es(...f);
    };
    return (u, f)=>{
        a(), c(u);
        let h;
        for(; !(h = f(l()));)c();
        return a(), h;
    };
}
const xpe = {
    bigint: (e)=>typeof e == "bigint",
    function: (e)=>typeof e == "function",
    boolean: (e)=>typeof e == "boolean",
    string: (e)=>typeof e == "string",
    isSafeInteger: (e)=>Number.isSafeInteger(e),
    array: (e)=>Array.isArray(e),
    field: (e, t)=>t.Fp.isValid(e),
    hash: (e)=>typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function ep(e, t, r = {}) {
    const n = (i1, o, a)=>{
        const s = xpe[o];
        if (typeof s != "function") throw new Error(`Invalid validator "${o}", expected function`);
        const c = e[i1];
        if (!(a && c === void 0) && !s(c, e)) throw new Error(`Invalid param ${String(i1)}=${c} (${typeof c}), expected ${o}`);
    };
    for (const [i1, o] of Object.entries(t))n(i1, o, !1);
    for (const [i1, o] of Object.entries(r))n(i1, o, !0);
    return e;
}
var _pe = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    bitGet: Epe,
    bitLen: vpe,
    bitMask: $5,
    bitSet: Spe,
    bytesToHex: wh,
    bytesToNumberBE: Vc,
    bytesToNumberLE: Q5,
    concatBytes: es,
    createHmacDrbg: EU,
    ensureBytes: ka,
    equalBytes: Ape,
    hexToBytes: Ah,
    hexToNumber: G5,
    numberToBytesBE: Qd,
    numberToBytesLE: vU,
    numberToHexUnpadded: AU,
    numberToVarBytesBE: wpe,
    utf8ToBytes: Rb,
    validateObject: ep
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const yi = BigInt(0), qn = BigInt(1), Nl = BigInt(2), kpe = BigInt(3), v4 = BigInt(4), jI = BigInt(5), FI = BigInt(8);
BigInt(9);
BigInt(16);
function Li(e, t) {
    const r = e % t;
    return r >= yi ? r : t + r;
}
function Ope(e, t, r) {
    if (r <= yi || t < yi) throw new Error("Expected power/modulo > 0");
    if (r === qn) return yi;
    let n = qn;
    for(; t > yi;)t & qn && (n = n * e % r), e = e * e % r, t >>= qn;
    return n;
}
function ma(e, t, r) {
    let n = e;
    for(; t-- > yi;)n *= n, n %= r;
    return n;
}
function E4(e, t) {
    if (e === yi || t <= yi) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
    let r = Li(e, t), n = t, i1 = yi, o = qn;
    for(; r !== yi;){
        const a = n / r, s = n % r, c = i1 - o * a;
        n = r, r = s, i1 = o, o = c;
    }
    if (n !== qn) throw new Error("invert: does not exist");
    return Li(i1, t);
}
function Ipe(e) {
    const t = (e - qn) / Nl;
    let r, n, i1;
    for(r = e - qn, n = 0; r % Nl === yi; r /= Nl, n++);
    for(i1 = Nl; i1 < e && Ope(i1, t, e) !== e - qn; i1++);
    if (n === 1) {
        const a = (e + qn) / v4;
        return function(s, c) {
            const l = s.pow(c, a);
            if (!s.eql(s.sqr(l), c)) throw new Error("Cannot find square root");
            return l;
        };
    }
    const o = (r + qn) / Nl;
    return function(a, s) {
        if (a.pow(s, t) === a.neg(a.ONE)) throw new Error("Cannot find square root");
        let c = n, l = a.pow(a.mul(a.ONE, i1), r), u = a.pow(s, o), f = a.pow(s, r);
        for(; !a.eql(f, a.ONE);){
            if (a.eql(f, a.ZERO)) return a.ZERO;
            let h = 1;
            for(let S = a.sqr(f); h < c && !a.eql(S, a.ONE); h++)S = a.sqr(S);
            const y = a.pow(l, qn << BigInt(c - h - 1));
            l = a.sqr(y), u = a.mul(u, y), f = a.mul(f, l), c = h;
        }
        return u;
    };
}
function Bpe(e) {
    if (e % v4 === kpe) {
        const t = (e + qn) / v4;
        return function(r, n) {
            const i1 = r.pow(n, t);
            if (!r.eql(r.sqr(i1), n)) throw new Error("Cannot find square root");
            return i1;
        };
    }
    if (e % FI === jI) {
        const t = (e - jI) / FI;
        return function(r, n) {
            const i1 = r.mul(n, Nl), o = r.pow(i1, t), a = r.mul(n, o), s = r.mul(r.mul(a, Nl), o), c = r.mul(a, r.sub(s, r.ONE));
            if (!r.eql(r.sqr(c), n)) throw new Error("Cannot find square root");
            return c;
        };
    }
    return Ipe(e);
}
const Tpe = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function SU(e) {
    const t = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }, r = Tpe.reduce((n, i1)=>(n[i1] = "function", n), t);
    return ep(e, r);
}
function Ppe(e, t, r) {
    if (r < yi) throw new Error("Expected power > 0");
    if (r === yi) return e.ONE;
    if (r === qn) return t;
    let n = e.ONE, i1 = t;
    for(; r > yi;)r & qn && (n = e.mul(n, i1)), i1 = e.sqr(i1), r >>= qn;
    return n;
}
function Cpe(e, t) {
    const r = new Array(t.length), n = t.reduce((o, a, s)=>e.is0(a) ? o : (r[s] = o, e.mul(o, a)), e.ONE), i1 = e.inv(n);
    return t.reduceRight((o, a, s)=>e.is0(a) ? o : (r[s] = e.mul(o, r[s]), e.mul(o, a)), i1), r;
}
function Z5(e, t) {
    const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    };
}
function xU(e, t, r = !1, n = {}) {
    if (e <= yi) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
    const { nBitLength: i1, nByteLength: o } = Z5(e, t);
    if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const a = Bpe(e), s = Object.freeze({
        ORDER: e,
        BITS: i1,
        BYTES: o,
        MASK: $5(i1),
        ZERO: yi,
        ONE: qn,
        create: (c)=>Li(c, e),
        isValid: (c)=>{
            if (typeof c != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
            return yi <= c && c < e;
        },
        is0: (c)=>c === yi,
        isOdd: (c)=>(c & qn) === qn,
        neg: (c)=>Li(-c, e),
        eql: (c, l)=>c === l,
        sqr: (c)=>Li(c * c, e),
        add: (c, l)=>Li(c + l, e),
        sub: (c, l)=>Li(c - l, e),
        mul: (c, l)=>Li(c * l, e),
        pow: (c, l)=>Ppe(s, c, l),
        div: (c, l)=>Li(c * E4(l, e), e),
        // Same as above, but doesn't normalize
        sqrN: (c)=>c * c,
        addN: (c, l)=>c + l,
        subN: (c, l)=>c - l,
        mulN: (c, l)=>c * l,
        inv: (c)=>E4(c, e),
        sqrt: n.sqrt || ((c)=>a(s, c)),
        invertBatch: (c)=>Cpe(s, c),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (c, l, u)=>u ? l : c,
        toBytes: (c)=>r ? vU(c, o) : Qd(c, o),
        fromBytes: (c)=>{
            if (c.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);
            return r ? Q5(c) : Vc(c);
        }
    });
    return Object.freeze(s);
}
function Mpe(e, t, r = !1) {
    e = ka("privateHash", e);
    const n = e.length, i1 = Z5(t).nByteLength + 8;
    if (i1 < 24 || n < i1 || n > 1024) throw new Error(`hashToPrivateScalar: expected ${i1}-1024 bytes of input, got ${n}`);
    const o = r ? Q5(e) : Vc(e);
    return Li(o, t - qn) + qn;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Npe = BigInt(0), Y3 = BigInt(1);
function Rpe(e, t) {
    const r = (i1, o)=>{
        const a = o.negate();
        return i1 ? a : o;
    }, n = (i1)=>{
        const o = Math.ceil(t / i1) + 1, a = 2 ** (i1 - 1);
        return {
            windows: o,
            windowSize: a
        };
    };
    return {
        constTimeNegate: r,
        // non-const time multiplication ladder
        unsafeLadder (i1, o) {
            let a = e.ZERO, s = i1;
            for(; o > Npe;)o & Y3 && (a = a.add(s)), s = s.double(), o >>= Y3;
            return a;
        },
        /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */ precomputeWindow (i1, o) {
            const { windows: a, windowSize: s } = n(o), c = [];
            let l = i1, u = l;
            for(let f = 0; f < a; f++){
                u = l, c.push(u);
                for(let h = 1; h < s; h++)u = u.add(l), c.push(u);
                l = u.double();
            }
            return c;
        },
        /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */ wNAF (i1, o, a) {
            const { windows: s, windowSize: c } = n(i1);
            let l = e.ZERO, u = e.BASE;
            const f = BigInt(2 ** i1 - 1), h = 2 ** i1, y = BigInt(i1);
            for(let S = 0; S < s; S++){
                const k = S * c;
                let P = Number(a & f);
                a >>= y, P > c && (P -= h, a += Y3);
                const M = k, N = k + Math.abs(P) - 1, z = S % 2 !== 0, K = P < 0;
                P === 0 ? u = u.add(r(z, o[M])) : l = l.add(r(K, o[N]));
            }
            return {
                p: l,
                f: u
            };
        },
        wNAFCached (i1, o, a, s) {
            const c = i1._WINDOW_SIZE || 1;
            let l = o.get(i1);
            return l || (l = this.precomputeWindow(i1, c), c !== 1 && o.set(i1, s(l))), this.wNAF(c, l, a);
        }
    };
}
function _U(e) {
    return SU(e.Fp), ep(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...Z5(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Upe(e) {
    const t = _U(e);
    ep(t, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const { endo: r, Fp: n, a: i1 } = t;
    if (r) {
        if (!n.eql(i1, n.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...t
    });
}
const { bytesToNumberBE: Dpe, hexToBytes: jpe } = _pe, $l = {
    // asn.1 DER encoding utils
    Err: class extends Error {
        constructor(e = ""){
            super(e);
        }
    },
    _parseInt (e) {
        const { Err: t } = $l;
        if (e.length < 2 || e[0] !== 2) throw new t("Invalid signature integer tag");
        const r = e[1], n = e.subarray(2, r + 2);
        if (!r || n.length !== r) throw new t("Invalid signature integer: wrong length");
        if (n[0] === 0 && n[1] <= 127) throw new t("Invalid signature integer: trailing length");
        return {
            d: Dpe(n),
            l: e.subarray(r + 2)
        };
    },
    toSig (e) {
        const { Err: t } = $l, r = typeof e == "string" ? jpe(e) : e;
        if (!(r instanceof Uint8Array)) throw new Error("ui8a expected");
        let n = r.length;
        if (n < 2 || r[0] != 48) throw new t("Invalid signature tag");
        if (r[1] !== n - 2) throw new t("Invalid signature: incorrect length");
        const { d: i1, l: o } = $l._parseInt(r.subarray(2)), { d: a, l: s } = $l._parseInt(o);
        if (s.length) throw new t("Invalid signature: left bytes after parsing");
        return {
            r: i1,
            s: a
        };
    },
    hexFromSig (e) {
        const t = (l)=>Number.parseInt(l[0], 16) >= 8 ? "00" + l : l, r = (l)=>{
            const u = l.toString(16);
            return u.length & 1 ? `0${u}` : u;
        }, n = t(r(e.s)), i1 = t(r(e.r)), o = n.length / 2, a = i1.length / 2, s = r(o), c = r(a);
        return `30${r(a + o + 4)}02${c}${i1}02${s}${n}`;
    }
}, rs = BigInt(0), ii = BigInt(1), bu = BigInt(2), Qm = BigInt(3), zI = BigInt(4);
function Fpe(e) {
    const t = Upe(e), { Fp: r } = t, n = t.toBytes || ((S, k, P)=>{
        const M = k.toAffine();
        return es(Uint8Array.from([
            4
        ]), r.toBytes(M.x), r.toBytes(M.y));
    }), i1 = t.fromBytes || ((S)=>{
        const k = S.subarray(1), P = r.fromBytes(k.subarray(0, r.BYTES)), M = r.fromBytes(k.subarray(r.BYTES, 2 * r.BYTES));
        return {
            x: P,
            y: M
        };
    });
    function o(S) {
        const { a: k, b: P } = t, M = r.sqr(S), N = r.mul(M, S);
        return r.add(r.add(N, r.mul(S, k)), P);
    }
    function a(S) {
        return typeof S == "bigint" && rs < S && S < t.n;
    }
    function s(S) {
        if (!a(S)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function c(S) {
        const { allowedPrivateKeyLengths: k, nByteLength: P, wrapPrivateKey: M, n: N } = t;
        if (k && typeof S != "bigint") {
            if (S instanceof Uint8Array && (S = wh(S)), typeof S != "string" || !k.includes(S.length)) throw new Error("Invalid key");
            S = S.padStart(P * 2, "0");
        }
        let z;
        try {
            z = typeof S == "bigint" ? S : Vc(ka("private key", S, P));
        } catch  {
            throw new Error(`private key must be ${P} bytes, hex or bigint, not ${typeof S}`);
        }
        return M && (z = Li(z, N)), s(z), z;
    }
    const l = /* @__PURE__ */ new Map();
    function u(S) {
        if (!(S instanceof f)) throw new Error("ProjectivePoint expected");
    }
    class f {
        constructor(k, P, M){
            if (this.px = k, this.py = P, this.pz = M, k == null || !r.isValid(k)) throw new Error("x required");
            if (P == null || !r.isValid(P)) throw new Error("y required");
            if (M == null || !r.isValid(M)) throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(k) {
            const { x: P, y: M } = k || {};
            if (!k || !r.isValid(P) || !r.isValid(M)) throw new Error("invalid affine point");
            if (k instanceof f) throw new Error("projective point not allowed");
            const N = (z)=>r.eql(z, r.ZERO);
            return N(P) && N(M) ? f.ZERO : new f(P, M, r.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */ static normalizeZ(k) {
            const P = r.invertBatch(k.map((M)=>M.pz));
            return k.map((M, N)=>M.toAffine(P[N])).map(f.fromAffine);
        }
        /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */ static fromHex(k) {
            const P = f.fromAffine(i1(ka("pointHex", k)));
            return P.assertValidity(), P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(k) {
            return f.BASE.multiply(c(k));
        }
        // "Private method", don't use it directly
        _setWindowSize(k) {
            this._WINDOW_SIZE = k, l.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                if (t.allowInfinityPoint) return;
                throw new Error("bad point: ZERO");
            }
            const { x: k, y: P } = this.toAffine();
            if (!r.isValid(k) || !r.isValid(P)) throw new Error("bad point: x or y not FE");
            const M = r.sqr(P), N = o(k);
            if (!r.eql(M, N)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
            const { y: k } = this.toAffine();
            if (r.isOdd) return !r.isOdd(k);
            throw new Error("Field doesn't support isOdd");
        }
        /**
     * Compare one point to another.
     */ equals(k) {
            u(k);
            const { px: P, py: M, pz: N } = this, { px: z, py: K, pz: $ } = k, ne = r.eql(r.mul(P, $), r.mul(z, N)), ee = r.eql(r.mul(M, $), r.mul(K, N));
            return ne && ee;
        }
        /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */ negate() {
            return new f(this.px, r.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: k, b: P } = t, M = r.mul(P, Qm), { px: N, py: z, pz: K } = this;
            let $ = r.ZERO, ne = r.ZERO, ee = r.ZERO, q = r.mul(N, N), U = r.mul(z, z), Q = r.mul(K, K), v = r.mul(N, z);
            return v = r.add(v, v), ee = r.mul(N, K), ee = r.add(ee, ee), $ = r.mul(k, ee), ne = r.mul(M, Q), ne = r.add($, ne), $ = r.sub(U, ne), ne = r.add(U, ne), ne = r.mul($, ne), $ = r.mul(v, $), ee = r.mul(M, ee), Q = r.mul(k, Q), v = r.sub(q, Q), v = r.mul(k, v), v = r.add(v, ee), ee = r.add(q, q), q = r.add(ee, q), q = r.add(q, Q), q = r.mul(q, v), ne = r.add(ne, q), Q = r.mul(z, K), Q = r.add(Q, Q), q = r.mul(Q, v), $ = r.sub($, q), ee = r.mul(Q, U), ee = r.add(ee, ee), ee = r.add(ee, ee), new f($, ne, ee);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(k) {
            u(k);
            const { px: P, py: M, pz: N } = this, { px: z, py: K, pz: $ } = k;
            let ne = r.ZERO, ee = r.ZERO, q = r.ZERO;
            const U = t.a, Q = r.mul(t.b, Qm);
            let v = r.mul(P, z), B = r.mul(M, K), g = r.mul(N, $), E = r.add(P, M), w = r.add(z, K);
            E = r.mul(E, w), w = r.add(v, B), E = r.sub(E, w), w = r.add(P, N);
            let _ = r.add(z, $);
            return w = r.mul(w, _), _ = r.add(v, g), w = r.sub(w, _), _ = r.add(M, N), ne = r.add(K, $), _ = r.mul(_, ne), ne = r.add(B, g), _ = r.sub(_, ne), q = r.mul(U, w), ne = r.mul(Q, g), q = r.add(ne, q), ne = r.sub(B, q), q = r.add(B, q), ee = r.mul(ne, q), B = r.add(v, v), B = r.add(B, v), g = r.mul(U, g), w = r.mul(Q, w), B = r.add(B, g), g = r.sub(v, g), g = r.mul(U, g), w = r.add(w, g), v = r.mul(B, w), ee = r.add(ee, v), v = r.mul(_, w), ne = r.mul(E, ne), ne = r.sub(ne, v), v = r.mul(E, B), q = r.mul(_, q), q = r.add(q, v), new f(ne, ee, q);
        }
        subtract(k) {
            return this.add(k.negate());
        }
        is0() {
            return this.equals(f.ZERO);
        }
        wNAF(k) {
            return y.wNAFCached(this, l, k, (P)=>{
                const M = r.invertBatch(P.map((N)=>N.pz));
                return P.map((N, z)=>N.toAffine(M[z])).map(f.fromAffine);
            });
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(k) {
            const P = f.ZERO;
            if (k === rs) return P;
            if (s(k), k === ii) return this;
            const { endo: M } = t;
            if (!M) return y.unsafeLadder(this, k);
            let { k1neg: N, k1: z, k2neg: K, k2: $ } = M.splitScalar(k), ne = P, ee = P, q = this;
            for(; z > rs || $ > rs;)z & ii && (ne = ne.add(q)), $ & ii && (ee = ee.add(q)), q = q.double(), z >>= ii, $ >>= ii;
            return N && (ne = ne.negate()), K && (ee = ee.negate()), ee = new f(r.mul(ee.px, M.beta), ee.py, ee.pz), ne.add(ee);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(k) {
            s(k);
            let P = k, M, N;
            const { endo: z } = t;
            if (z) {
                const { k1neg: K, k1: $, k2neg: ne, k2: ee } = z.splitScalar(P);
                let { p: q, f: U } = this.wNAF($), { p: Q, f: v } = this.wNAF(ee);
                q = y.constTimeNegate(K, q), Q = y.constTimeNegate(ne, Q), Q = new f(r.mul(Q.px, z.beta), Q.py, Q.pz), M = q.add(Q), N = U.add(v);
            } else {
                const { p: K, f: $ } = this.wNAF(P);
                M = K, N = $;
            }
            return f.normalizeZ([
                M,
                N
            ])[0];
        }
        /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */ multiplyAndAddUnsafe(k, P, M) {
            const N = f.BASE, z = ($, ne)=>ne === rs || ne === ii || !$.equals(N) ? $.multiplyUnsafe(ne) : $.multiply(ne), K = z(this, P).add(z(k, M));
            return K.is0() ? void 0 : K;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(k) {
            const { px: P, py: M, pz: N } = this, z = this.is0();
            k == null && (k = z ? r.ONE : r.inv(N));
            const K = r.mul(P, k), $ = r.mul(M, k), ne = r.mul(N, k);
            if (z) return {
                x: r.ZERO,
                y: r.ZERO
            };
            if (!r.eql(ne, r.ONE)) throw new Error("invZ was invalid");
            return {
                x: K,
                y: $
            };
        }
        isTorsionFree() {
            const { h: k, isTorsionFree: P } = t;
            if (k === ii) return !0;
            if (P) return P(f, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: k, clearCofactor: P } = t;
            return k === ii ? this : P ? P(f, this) : this.multiplyUnsafe(t.h);
        }
        toRawBytes(k = !0) {
            return this.assertValidity(), n(f, this, k);
        }
        toHex(k = !0) {
            return wh(this.toRawBytes(k));
        }
    }
    f.BASE = new f(t.Gx, t.Gy, r.ONE), f.ZERO = new f(r.ZERO, r.ONE, r.ZERO);
    const h = t.nBitLength, y = Rpe(f, t.endo ? Math.ceil(h / 2) : h);
    return {
        CURVE: t,
        ProjectivePoint: f,
        normPrivateKeyToScalar: c,
        weierstrassEquation: o,
        isWithinCurveOrder: a
    };
}
function zpe(e) {
    const t = _U(e);
    return ep(t, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...t
    });
}
function Lpe(e) {
    const t = zpe(e), { Fp: r, n } = t, i1 = r.BYTES + 1, o = 2 * r.BYTES + 1;
    function a(w) {
        return rs < w && w < r.ORDER;
    }
    function s(w) {
        return Li(w, n);
    }
    function c(w) {
        return E4(w, n);
    }
    const { ProjectivePoint: l, normPrivateKeyToScalar: u, weierstrassEquation: f, isWithinCurveOrder: h } = Fpe({
        ...t,
        toBytes (w, _, O) {
            const I = _.toAffine(), x = r.toBytes(I.x), R = es;
            return O ? R(Uint8Array.from([
                _.hasEvenY() ? 2 : 3
            ]), x) : R(Uint8Array.from([
                4
            ]), x, r.toBytes(I.y));
        },
        fromBytes (w) {
            const _ = w.length, O = w[0], I = w.subarray(1);
            if (_ === i1 && (O === 2 || O === 3)) {
                const x = Vc(I);
                if (!a(x)) throw new Error("Point is not on curve");
                const R = f(x);
                let j = r.sqrt(R);
                const Y = (j & ii) === ii;
                return (O & 1) === 1 !== Y && (j = r.neg(j)), {
                    x,
                    y: j
                };
            } else if (_ === o && O === 4) {
                const x = r.fromBytes(I.subarray(0, r.BYTES)), R = r.fromBytes(I.subarray(r.BYTES, 2 * r.BYTES));
                return {
                    x,
                    y: R
                };
            } else throw new Error(`Point of length ${_} was invalid. Expected ${i1} compressed bytes or ${o} uncompressed bytes`);
        }
    }), y = (w)=>wh(Qd(w, t.nByteLength));
    function S(w) {
        const _ = n >> ii;
        return w > _;
    }
    function k(w) {
        return S(w) ? s(-w) : w;
    }
    const P = (w, _, O)=>Vc(w.slice(_, O));
    class M {
        constructor(_, O, I){
            this.r = _, this.s = O, this.recovery = I, this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(_) {
            const O = t.nByteLength;
            return _ = ka("compactSignature", _, O * 2), new M(P(_, 0, O), P(_, O, 2 * O));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(_) {
            const { r: O, s: I } = $l.toSig(ka("DER", _));
            return new M(O, I);
        }
        assertValidity() {
            if (!h(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!h(this.s)) throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(_) {
            return new M(this.r, this.s, _);
        }
        recoverPublicKey(_) {
            const { r: O, s: I, recovery: x } = this, R = ee(ka("msgHash", _));
            if (x == null || ![
                0,
                1,
                2,
                3
            ].includes(x)) throw new Error("recovery id invalid");
            const j = x === 2 || x === 3 ? O + t.n : O;
            if (j >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const Y = x & 1 ? "03" : "02", he = l.fromHex(Y + y(j)), ue = c(j), G = s(-R * ue), se = s(I * ue), Z = l.BASE.multiplyAndAddUnsafe(he, G, se);
            if (!Z) throw new Error("point at infinify");
            return Z.assertValidity(), Z;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return S(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new M(this.r, s(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return Ah(this.toDERHex());
        }
        toDERHex() {
            return $l.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return Ah(this.toCompactHex());
        }
        toCompactHex() {
            return y(this.r) + y(this.s);
        }
    }
    const N = {
        isValidPrivateKey (w) {
            try {
                return u(w), !0;
            } catch  {
                return !1;
            }
        },
        normPrivateKeyToScalar: u,
        /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */ randomPrivateKey: ()=>{
            const w = t.randomBytes(r.BYTES + 8), _ = Mpe(w, n);
            return Qd(_, t.nByteLength);
        },
        /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */ precompute (w = 8, _ = l.BASE) {
            return _._setWindowSize(w), _.multiply(BigInt(3)), _;
        }
    };
    function z(w, _ = !0) {
        return l.fromPrivateKey(w).toRawBytes(_);
    }
    function K(w) {
        const _ = w instanceof Uint8Array, O = typeof w == "string", I = (_ || O) && w.length;
        return _ ? I === i1 || I === o : O ? I === 2 * i1 || I === 2 * o : w instanceof l;
    }
    function $(w, _, O = !0) {
        if (K(w)) throw new Error("first arg must be private key");
        if (!K(_)) throw new Error("second arg must be public key");
        return l.fromHex(_).multiply(u(w)).toRawBytes(O);
    }
    const ne = t.bits2int || function(w) {
        const _ = Vc(w), O = w.length * 8 - t.nBitLength;
        return O > 0 ? _ >> BigInt(O) : _;
    }, ee = t.bits2int_modN || function(w) {
        return s(ne(w));
    }, q = $5(t.nBitLength);
    function U(w) {
        if (typeof w != "bigint") throw new Error("bigint expected");
        if (!(rs <= w && w < q)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
        return Qd(w, t.nByteLength);
    }
    function Q(w, _, O = v) {
        if ([
            "recovered",
            "canonical"
        ].some((pe)=>pe in O)) throw new Error("sign() legacy options not supported");
        const { hash: I, randomBytes: x } = t;
        let { lowS: R, prehash: j, extraEntropy: Y } = O;
        R == null && (R = !0), w = ka("msgHash", w), j && (w = ka("prehashed msgHash", I(w)));
        const he = ee(w), ue = u(_), G = [
            U(ue),
            U(he)
        ];
        if (Y != null) {
            const pe = Y === !0 ? x(r.BYTES) : Y;
            G.push(ka("extraEntropy", pe, r.BYTES));
        }
        const se = es(...G), Z = he;
        function ie(pe) {
            const ve = ne(pe);
            if (!h(ve)) return;
            const Ie = c(ve), Me = l.BASE.multiply(ve).toAffine(), Re = s(Me.x);
            if (Re === rs) return;
            const C = s(Ie * s(Z + Re * ue));
            if (C === rs) return;
            let J = (Me.x === Re ? 0 : 2) | Number(Me.y & ii), me = C;
            return R && S(C) && (me = k(C), J ^= 1), new M(Re, me, J);
        }
        return {
            seed: se,
            k2sig: ie
        };
    }
    const v = {
        lowS: t.lowS,
        prehash: !1
    }, B = {
        lowS: t.lowS,
        prehash: !1
    };
    function g(w, _, O = v) {
        const { seed: I, k2sig: x } = Q(w, _, O);
        return EU(t.hash.outputLen, t.nByteLength, t.hmac)(I, x);
    }
    l.BASE._setWindowSize(8);
    function E(w, _, O, I = B) {
        var x;
        const R = w;
        if (_ = ka("msgHash", _), O = ka("publicKey", O), "strict" in I) throw new Error("options.strict was renamed to lowS");
        const { lowS: j, prehash: Y } = I;
        let he, ue;
        try {
            if (typeof R == "string" || R instanceof Uint8Array) try {
                he = M.fromDER(R);
            } catch (Me) {
                if (!(Me instanceof $l.Err)) throw Me;
                he = M.fromCompact(R);
            }
            else if (typeof R == "object" && typeof R.r == "bigint" && typeof R.s == "bigint") {
                const { r: Me, s: Re } = R;
                he = new M(Me, Re);
            } else throw new Error("PARSE");
            ue = l.fromHex(O);
        } catch (Me) {
            if (Me.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1;
        }
        if (j && he.hasHighS()) return !1;
        Y && (_ = t.hash(_));
        const { r: G, s: se } = he, Z = ee(_), ie = c(se), pe = s(Z * ie), ve = s(G * ie), Ie = (x = l.BASE.multiplyAndAddUnsafe(ue, pe, ve)) == null ? void 0 : x.toAffine();
        return Ie ? s(Ie.x) === G : !1;
    }
    return {
        CURVE: t,
        getPublicKey: z,
        getSharedSecret: $,
        sign: g,
        verify: E,
        ProjectivePoint: l,
        Signature: M,
        utils: N
    };
}
function Hpe(e, t) {
    const r = e.ORDER;
    let n = rs;
    for(let h = r - ii; h % bu === rs; h /= bu)n += ii;
    const i1 = n, o = (r - ii) / bu ** i1, a = (o - ii) / bu, s = bu ** i1 - ii, c = bu ** (i1 - ii), l = e.pow(t, o), u = e.pow(t, (o + ii) / bu);
    let f = (h, y)=>{
        let S = l, k = e.pow(y, s), P = e.sqr(k);
        P = e.mul(P, y);
        let M = e.mul(h, P);
        M = e.pow(M, a), M = e.mul(M, k), k = e.mul(M, y), P = e.mul(M, h);
        let N = e.mul(P, k);
        M = e.pow(N, c);
        let z = e.eql(M, e.ONE);
        k = e.mul(P, u), M = e.mul(N, S), P = e.cmov(k, P, z), N = e.cmov(M, N, z);
        for(let K = i1; K > 1; K--){
            let $ = bu ** (K - bu), ne = e.pow(N, $);
            const ee = e.eql(ne, e.ONE);
            k = e.mul(P, S), S = e.mul(S, S), ne = e.mul(N, S), P = e.cmov(k, P, ee), N = e.cmov(ne, N, ee);
        }
        return {
            isValid: z,
            value: P
        };
    };
    if (e.ORDER % zI === Qm) {
        const h = (e.ORDER - Qm) / zI, y = e.sqrt(e.neg(t));
        f = (S, k)=>{
            let P = e.sqr(k);
            const M = e.mul(S, k);
            P = e.mul(P, M);
            let N = e.pow(P, h);
            N = e.mul(N, M);
            const z = e.mul(N, y), K = e.mul(e.sqr(N), k), $ = e.eql(K, S);
            let ne = e.cmov(z, N, $);
            return {
                isValid: $,
                value: ne
            };
        };
    }
    return f;
}
function Kpe(e, t) {
    if (SU(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r = Hpe(e, t.Z);
    if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n)=>{
        let i1, o, a, s, c, l, u, f;
        i1 = e.sqr(n), i1 = e.mul(i1, t.Z), o = e.sqr(i1), o = e.add(o, i1), a = e.add(o, e.ONE), a = e.mul(a, t.B), s = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), s = e.mul(s, t.A), o = e.sqr(a), l = e.sqr(s), c = e.mul(l, t.A), o = e.add(o, c), o = e.mul(o, a), l = e.mul(l, s), c = e.mul(l, t.B), o = e.add(o, c), u = e.mul(i1, a);
        const { isValid: h, value: y } = r(o, l);
        f = e.mul(i1, n), f = e.mul(f, y), u = e.cmov(u, a, h), f = e.cmov(f, y, h);
        const S = e.isOdd(n) === e.isOdd(f);
        return f = e.cmov(e.neg(f), f, S), u = e.div(u, s), {
            x: u,
            y: f
        };
    };
}
function qpe(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return Rb(e);
    throw new Error("DST must be Uint8Array or string");
}
const Vpe = Vc;
function Cc(e, t) {
    if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
    const r = Array.from({
        length: t
    }).fill(0);
    for(let n = t - 1; n >= 0; n--)r[n] = e & 255, e >>>= 8;
    return new Uint8Array(r);
}
function Wpe(e, t) {
    const r = new Uint8Array(e.length);
    for(let n = 0; n < e.length; n++)r[n] = e[n] ^ t[n];
    return r;
}
function O0(e) {
    if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
function X5(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function Gpe(e, t, r, n) {
    O0(e), O0(t), X5(r), t.length > 255 && (t = n(es(Rb("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i1, blockLen: o } = n, a = Math.ceil(r / i1);
    if (a > 255) throw new Error("Invalid xmd length");
    const s = es(t, Cc(t.length, 1)), c = Cc(0, o), l = Cc(r, 2), u = new Array(a), f = n(es(c, e, l, Cc(0, 1), s));
    u[0] = n(es(f, Cc(1, 1), s));
    for(let h = 1; h <= a; h++){
        const y = [
            Wpe(f, u[h - 1]),
            Cc(h + 1, 1),
            s
        ];
        u[h] = n(es(...y));
    }
    return es(...u).slice(0, r);
}
function Qpe(e, t, r, n, i1) {
    if (O0(e), O0(t), X5(r), t.length > 255) {
        const o = Math.ceil(2 * n / 8);
        t = i1.create({
            dkLen: o
        }).update(Rb("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (r > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i1.create({
        dkLen: r
    }).update(e).update(Cc(r, 2)).update(t).update(Cc(t.length, 1)).digest();
}
function LI(e, t, r) {
    ep(r, {
        DST: "string",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p: n, k: i1, m: o, hash: a, expand: s, DST: c } = r;
    O0(e), X5(t);
    const l = qpe(c), u = n.toString(2).length, f = Math.ceil((u + i1) / 8), h = t * o * f;
    let y;
    if (s === "xmd") y = Gpe(e, l, h, a);
    else if (s === "xof") y = Qpe(e, l, h, i1, a);
    else if (s === void 0) y = e;
    else throw new Error('expand must be "xmd", "xof" or undefined');
    const S = new Array(t);
    for(let k = 0; k < t; k++){
        const P = new Array(o);
        for(let M = 0; M < o; M++){
            const N = f * (M + k * o), z = y.subarray(N, N + f);
            P[M] = Li(Vpe(z), n);
        }
        S[k] = P;
    }
    return S;
}
function $pe(e, t) {
    const r = t.map((n)=>Array.from(n).reverse());
    return (n, i1)=>{
        const [o, a, s, c] = r.map((l)=>l.reduce((u, f)=>e.add(e.mul(u, n), f)));
        return n = e.div(o, a), i1 = e.mul(i1, e.div(s, c)), {
            x: n,
            y: i1
        };
    };
}
function Zpe(e, t, r) {
    if (typeof t != "function") throw new Error("mapToCurve() must be defined");
    return {
        // Encodes byte string to elliptic curve
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        hashToCurve (n, i1) {
            const o = LI(n, 2, {
                ...r,
                DST: r.DST,
                ...i1
            }), a = e.fromAffine(t(o[0])), s = e.fromAffine(t(o[1])), c = a.add(s).clearCofactor();
            return c.assertValidity(), c;
        },
        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
        encodeToCurve (n, i1) {
            const o = LI(n, 1, {
                ...r,
                DST: r.encodeDST,
                ...i1
            }), a = e.fromAffine(t(o[0])).clearCofactor();
            return a.assertValidity(), a;
        }
    };
}
let kU = class extends yU {
    constructor(e, t){
        super(), this.finished = !1, this.destroyed = !1, Ql.hash(e);
        const r = V5(t);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const n = this.blockLen, i1 = new Uint8Array(n);
        i1.set(r.length > n ? e.create().update(r).digest() : r);
        for(let o = 0; o < i1.length; o++)i1[o] ^= 54;
        this.iHash.update(i1), this.oHash = e.create();
        for(let o = 0; o < i1.length; o++)i1[o] ^= 106;
        this.oHash.update(i1), i1.fill(0);
    }
    update(e) {
        return Ql.exists(this), this.iHash.update(e), this;
    }
    digestInto(e) {
        Ql.exists(this), Ql.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: t, iHash: r, finished: n, destroyed: i1, blockLen: o, outputLen: a } = this;
        return e = e, e.finished = n, e.destroyed = i1, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
};
const OU = (e, t, r)=>new kU(e, t).update(r).digest();
OU.create = (e, t)=>new kU(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Xpe(e) {
    return {
        hash: e,
        hmac: (t, ...r)=>OU(e, t, upe(...r)),
        randomBytes: cpe
    };
}
function Ype(e, t) {
    const r = (n)=>Lpe({
            ...e,
            ...Xpe(n)
        });
    return Object.freeze({
        ...r(t),
        create: r
    });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const IU = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), HI = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Jpe = BigInt(1), S4 = BigInt(2), KI = (e, t)=>(e + t / S4) / t;
function e0e(e) {
    const t = IU, r = BigInt(3), n = BigInt(6), i1 = BigInt(11), o = BigInt(22), a = BigInt(23), s = BigInt(44), c = BigInt(88), l = e * e * e % t, u = l * l * e % t, f = ma(u, r, t) * u % t, h = ma(f, r, t) * u % t, y = ma(h, S4, t) * l % t, S = ma(y, i1, t) * y % t, k = ma(S, o, t) * S % t, P = ma(k, s, t) * k % t, M = ma(P, c, t) * P % t, N = ma(M, s, t) * k % t, z = ma(N, r, t) * u % t, K = ma(z, a, t) * S % t, $ = ma(K, n, t) * l % t, ne = ma($, S4, t);
    if (!el.eql(el.sqr(ne), e)) throw new Error("Cannot find square root");
    return ne;
}
const el = xU(IU, void 0, void 0, {
    sqrt: e0e
}), hl = Ype({
    a: BigInt(0),
    b: BigInt(7),
    Fp: el,
    n: HI,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */ endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (e)=>{
            const t = HI, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Jpe * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i1 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, a = BigInt("0x100000000000000000000000000000000"), s = KI(o * e, t), c = KI(-n * e, t);
            let l = Li(e - s * r - c * i1, t), u = Li(-s * n - c * o, t);
            const f = l > a, h = u > a;
            if (f && (l = t - l), h && (u = t - u), l > a || u > a) throw new Error("splitScalar: Endomorphism failed, k=" + e);
            return {
                k1neg: f,
                k1: l,
                k2neg: h,
                k2: u
            };
        }
    }
}, wU);
BigInt(0);
hl.ProjectivePoint;
hl.utils.randomPrivateKey;
const t0e = $pe(el, [
    // xNum
    [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    // yNum
    [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
].map((e)=>e.map((t)=>BigInt(t)))), r0e = Kpe(el, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: el.create(BigInt("-11"))
});
Zpe(hl.ProjectivePoint, (e)=>{
    const { x: t, y: r } = r0e(el.create(e[0]));
    return t0e(t, r);
}, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: el.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: wU
});
function x4(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function n0e(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function BU(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function i0e(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    x4(e.outputLen), x4(e.blockLen);
}
function o0e(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function a0e(e, t) {
    BU(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const s0e = {
    number: x4,
    bool: n0e,
    bytes: BU,
    hash: i0e,
    exists: o0e,
    output: a0e
};
var J3 = s0e;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const e8 = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), Bs = (e, t)=>e << 32 - t | e >>> t, u0e = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!u0e) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function c0e(e) {
    if (typeof e != "string") throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
    return new TextEncoder().encode(e);
}
function TU(e) {
    if (typeof e == "string" && (e = c0e(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
    return e;
}
let l0e = class {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
};
function PU(e) {
    const t = (n)=>e().update(TU(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function f0e(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
let d0e = class extends l0e {
    constructor(e, t, r, n){
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = e8(this.buffer);
    }
    update(e) {
        J3.exists(this);
        const { view: t, buffer: r, blockLen: n } = this;
        e = TU(e);
        const i1 = e.length;
        for(let o = 0; o < i1;){
            const a = Math.min(n - this.pos, i1 - o);
            if (a === n) {
                const s = e8(e);
                for(; n <= i1 - o; o += n)this.process(s, o);
                continue;
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        J3.exists(this), J3.output(e, this), this.finished = !0;
        const { buffer: t, view: r, blockLen: n, isLE: i1 } = this;
        let { pos: o } = this;
        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for(let u = o; u < n; u++)t[u] = 0;
        f0e(r, n - 8, BigInt(this.length * 8), i1), this.process(r, 0);
        const a = e8(e), s = this.outputLen;
        if (s % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = s / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let u = 0; u < c; u++)a.setUint32(4 * u, l[u], i1);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: r, length: n, finished: i1, destroyed: o, pos: a } = this;
        return e.length = n, e.pos = a, e.finished = i1, e.destroyed = o, n % t && e.buffer.set(r), e;
    }
};
const h0e = (e, t, r)=>e & t ^ ~e & r, p0e = (e, t, r)=>e & t ^ e & r ^ t & r, g0e = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), mc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), bc = new Uint32Array(64);
let CU = class extends d0e {
    constructor(){
        super(64, 32, 8, !1), this.A = mc[0] | 0, this.B = mc[1] | 0, this.C = mc[2] | 0, this.D = mc[3] | 0, this.E = mc[4] | 0, this.F = mc[5] | 0, this.G = mc[6] | 0, this.H = mc[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n, E: i1, F: o, G: a, H: s } = this;
        return [
            e,
            t,
            r,
            n,
            i1,
            o,
            a,
            s
        ];
    }
    // prettier-ignore
    set(e, t, r, n, i1, o, a, s) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i1 | 0, this.F = o | 0, this.G = a | 0, this.H = s | 0;
    }
    process(e, t) {
        for(let u = 0; u < 16; u++, t += 4)bc[u] = e.getUint32(t, !1);
        for(let u = 16; u < 64; u++){
            const f = bc[u - 15], h = bc[u - 2], y = Bs(f, 7) ^ Bs(f, 18) ^ f >>> 3, S = Bs(h, 17) ^ Bs(h, 19) ^ h >>> 10;
            bc[u] = S + bc[u - 7] + y + bc[u - 16] | 0;
        }
        let { A: r, B: n, C: i1, D: o, E: a, F: s, G: c, H: l } = this;
        for(let u = 0; u < 64; u++){
            const f = Bs(a, 6) ^ Bs(a, 11) ^ Bs(a, 25), h = l + f + h0e(a, s, c) + g0e[u] + bc[u] | 0, y = (Bs(r, 2) ^ Bs(r, 13) ^ Bs(r, 22)) + p0e(r, n, i1) | 0;
            l = c, c = s, s = a, a = o + h | 0, o = i1, i1 = n, n = r, r = h + y | 0;
        }
        r = r + this.A | 0, n = n + this.B | 0, i1 = i1 + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, n, i1, o, a, s, c, l);
    }
    roundClean() {
        bc.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}, y0e = class extends CU {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
};
const _4 = PU(()=>new CU());
PU(()=>new y0e());
function m0e(e, t) {
    if (e.length > t) throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function b0e(e) {
    if (e.match(/[^a-fA-f0-9]/) !== null) throw new TypeError("Invalid characters in hex string: " + e);
    if (e.length % 2 !== 0) throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function w0e(e) {
    if (e > Number.MAX_SAFE_INTEGER) throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: A0e } = crypto ?? globalThis.crypto ?? window.crypto;
function v0e(e = 32) {
    if (typeof A0e == "function") return crypto.getRandomValues(new Uint8Array(e));
    throw new Error("Crypto module missing getRandomValues!");
}
function E0e(e, t, r = "be") {
    t === void 0 && (t = e.length), m0e(e, t);
    const n = new Uint8Array(t).fill(0), i1 = r === "be" ? 0 : t - e.length;
    return n.set(e, i1), n;
}
function MU(e) {
    let t, r = 0;
    const n = e.reduce((o, a)=>o + a.length, 0), i1 = new Uint8Array(n);
    for(t = 0; t < e.length; t++){
        const o = e[t];
        i1.set(o, r), r += o.length;
    }
    return i1;
}
const S0e = new TextEncoder(), x0e = [
    {
        name: "base58",
        charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }
];
function NU(e) {
    for (const t of x0e)if (t.name === e) return t.charset;
    throw TypeError("Charset does not exist: " + e);
}
function _0e(e, t, r = !1) {
    typeof e == "string" && (e = S0e.encode(e));
    const n = NU(t), i1 = n.length, o = [];
    let a = "", s, c = 0, l, u;
    for(s = 0; s < e.length; s++)for(c = 0, l = e[s], a += l > 0 || (a.length ^ s) > 0 ? "" : "1"; c in o || l > 0;)u = o[c], u = u > 0 ? u * 256 + l : l, l = u / i1 | 0, o[c] = u % i1, c++;
    for(; c-- > 0;)a += n[o[c]];
    return r && a.length % 4 > 0 ? a + "=".repeat(4 - a.length % 4) : a;
}
function k0e(e, t) {
    const r = NU(t), n = r.length, i1 = [], o = [];
    e = e.replace("=", "");
    let a, s = 0, c, l;
    for(a = 0; a < e.length; a++){
        if (s = 0, c = r.indexOf(e[a]), c < 0) throw new Error(`Character range out of bounds: ${c}`);
        for(c > 0 || (o.length ^ a) > 0 || o.push(0); s in i1 || c > 0;)l = i1[s], l = l > 0 ? l * n + c : c, c = l >> 8, i1[s] = l % 256, s++;
    }
    for(; s-- > 0;)o.push(i1[s]);
    return new Uint8Array(o);
}
function RU(e) {
    return _4(_4(e));
}
function O0e(e) {
    const t = RU(e);
    return MU([
        e,
        t.slice(0, 4)
    ]);
}
function I0e(e) {
    const t = e.slice(0, -4), r = e.slice(-4);
    if (RU(t).slice(0, 4).toString() !== r.toString()) throw new Error("Invalid checksum!");
    return t;
}
const qI = {
    encode: _0e,
    decode: k0e
}, UU = {
    encode: (e)=>{
        const t = O0e(e);
        return qI.encode(t, "base58");
    },
    decode: (e)=>{
        const t = qI.decode(e, "base58");
        return I0e(t);
    }
}, DU = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", B0e = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
], $m = [
    {
        version: 0,
        name: "bech32",
        const: 1
    },
    {
        version: 1,
        name: "bech32m",
        const: 734539939
    }
];
function jU(e) {
    let t = 1;
    for(let r = 0; r < e.length; ++r){
        const n = t >> 25;
        t = (t & 33554431) << 5 ^ e[r];
        for(let i1 = 0; i1 < 5; ++i1)n >> i1 & 1 && (t ^= B0e[i1]);
    }
    return t;
}
function FU(e) {
    const t = [];
    let r;
    for(r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) >> 5);
    for(t.push(0), r = 0; r < e.length; ++r)t.push(e.charCodeAt(r) & 31);
    return t;
}
function T0e(e, t, r) {
    const n = FU(e).concat(t);
    return jU(n) === r.const;
}
function P0e(e, t, r) {
    const n = FU(e).concat(t).concat([
        0,
        0,
        0,
        0,
        0,
        0
    ]), i1 = jU(n) ^ r.const, o = [];
    for(let a = 0; a < 6; ++a)o.push(i1 >> 5 * (5 - a) & 31);
    return o;
}
function zU(e, t, r, n = !0) {
    const i1 = [];
    let o = 0, a = 0;
    const s = (1 << r) - 1, c = (1 << t + r - 1) - 1;
    for (const l of e){
        if (l < 0 || l >> t > 0) throw new Error("Failed to perform base conversion. Invalid value: " + String(l));
        for(o = (o << t | l) & c, a += t; a >= r;)a -= r, i1.push(o >> a & s);
    }
    if (n) a > 0 && i1.push(o << r - a & s);
    else if (a >= t || (o << r - a & s) > 0) throw new Error("Failed to perform base conversion. Invalid Size!");
    return i1;
}
function C0e(e, t, r) {
    const n = t.concat(P0e(e, t, r));
    let i1 = e + "1";
    for(let o = 0; o < n.length; ++o)i1 += DU.charAt(n[o]);
    return i1;
}
function LU(e) {
    if (!M0e(e)) throw new Error("Encoded string goes out of bounds!");
    if (e = e.toLowerCase(), !N0e(e)) throw new Error("Encoded string has invalid separator!");
    const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
    for(let o = r + 1; o < e.length; ++o){
        const a = DU.indexOf(e.charAt(o));
        if (a === -1) throw new Error("Character idx out of bounds: " + String(o));
        t.push(a);
    }
    const i1 = $m.find((o)=>o.version === t[0]) ?? $m[0];
    if (!T0e(n, t, i1)) throw new Error("Checksum verification failed!");
    return [
        n,
        t.slice(0, t.length - 6)
    ];
}
function M0e(e) {
    let t, r, n = !1, i1 = !1;
    for(t = 0; t < e.length; ++t){
        if (r = e.charCodeAt(t), r < 33 || r > 126) return !1;
        r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i1 = !0);
    }
    return !(n && i1);
}
function N0e(e) {
    const t = e.lastIndexOf("1");
    return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function R0e(e, t = "bc", r = 0) {
    const n = [
        r,
        ...zU([
            ...e
        ], 8, 5)
    ], i1 = $m.find((a)=>a.version === r) ?? $m[0], o = C0e(t, n, i1);
    return HU(o), o;
}
function HU(e) {
    e = e.toLowerCase();
    const t = e.split("1", 1)[0], [r, n] = LU(e), i1 = zU(n.slice(1), 5, 8, !1), o = i1.length;
    switch(!0){
        case t !== r:
            throw new Error("Returned hrp string is invalid.");
        case i1 === null || o < 2 || o > 40:
            throw new Error("Decoded string is invalid or out of spec.");
        case n[0] > 16:
            throw new Error("Returned version bit is out of range.");
        default:
            return Uint8Array.from(i1);
    }
}
function U0e(e) {
    e = e.toLowerCase();
    const [t, r] = LU(e);
    return r[0];
}
const KU = {
    encode: R0e,
    decode: HU,
    version: U0e
}, qU = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", VU = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", D0e = new TextEncoder();
function WU(e, t = !1, r = !0) {
    typeof e == "string" && (e = D0e.encode(e));
    const n = t ? VU : qU;
    let i1 = "", o = 0, a = 0;
    for(let s = 0; s < e.length; s++)for(a = a << 8 | e[s], o += 8; o >= 6;)o -= 6, i1 += n[a >> o & 63];
    if (o > 0) for(a <<= 6 - o, i1 += n[a & 63]; o < 6;)i1 += r ? "=" : "", o += 2;
    return i1;
}
function GU(e, t = !1) {
    const r = t || e.includes("-") || e.includes("_") ? VU.split("") : qU.split("");
    e = e.replace(/=+$/, "");
    const n = e.split("");
    let i1 = 0, o = 0;
    const a = [];
    for(let s = 0; s < n.length; s++){
        const c = n[s], l = r.indexOf(c);
        if (l === -1) throw new Error("Invalid character: " + c);
        i1 += 6, o <<= 6, o |= l, i1 >= 8 && (i1 -= 8, a.push(o >>> i1 & 255));
    }
    return new Uint8Array(a);
}
const QU = {
    encode: WU,
    decode: GU
}, $U = {
    encode: (e)=>WU(e, !0, !1),
    decode: (e)=>GU(e, !0)
}, j0e = BigInt(0), F0e = BigInt(255), ZU = BigInt(256);
function z0e(e) {
    if (e <= 0xffn) return 1;
    if (e <= 0xffffn) return 2;
    if (e <= 0xffffffffn) return 4;
    if (e <= 0xffffffffffffffffn) return 8;
    if (e <= 0xffffffffffffffffffffffffffffffffn) return 16;
    if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) return 32;
    throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function L0e(e, t, r = "be") {
    t === void 0 && (t = z0e(e));
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(; e > j0e;){
        const s = e & F0e, c = Number(s);
        n ? o.setUint8(a++, c) : o.setUint8(a--, c), e = (e - s) / ZU;
    }
    return new Uint8Array(i1);
}
function H0e(e) {
    let t = BigInt(0);
    for(let r = e.length - 1; r >= 0; r--)t = t * ZU + BigInt(e[r]);
    return BigInt(t);
}
function K0e(e) {
    const t = e.split("").map(Number);
    if (t.length % 8 !== 0) throw new Error(`Binary array is invalid length: ${e.length}`);
    const r = new Uint8Array(t.length / 8);
    for(let n = 0, i1 = 0; n < t.length; n += 8, i1++){
        let o = 0;
        for(let a = 0; a < 8; a++)o |= t[n + a] << 7 - a;
        r[i1] = o;
    }
    return r;
}
function q0e(e) {
    const t = new Array(e.length * 8);
    let r = 0;
    for (const n of e){
        if (n > 255) throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
        for(let i1 = 7; i1 >= 0; i1--, r++)t[r] = n >> i1 & 1;
    }
    return t.join("");
}
function V0e(e) {
    if (e <= 255) return 1;
    if (e <= 65535) return 2;
    if (e <= 4294967295) return 4;
    throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function W0e(e, t, r = "be") {
    t === void 0 && (t = V0e(e));
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(; e > 0;){
        const s = e & 255;
        n ? o.setUint8(a++, e) : o.setUint8(a--, e), e = (e - s) / 256;
    }
    return new Uint8Array(i1);
}
function G0e(e) {
    let t = 0;
    for(let r = e.length - 1; r >= 0; r--)t = t * 256 + e[r], w0e(t);
    return t;
}
const Q0e = new TextEncoder(), $0e = new TextDecoder();
function Y5(e) {
    return Q0e.encode(e);
}
function k4(e) {
    return $0e.decode(e);
}
function Z0e(e, t) {
    b0e(e);
    const r = e.length / 2;
    if (t === void 0 && (t = r), r > t) throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
    return t;
}
function X0e(e, t, r = "le") {
    t = Z0e(e, t);
    const n = r === "le", i1 = new ArrayBuffer(t), o = new DataView(i1);
    let a = n ? 0 : t - 1;
    for(let s = 0; s < e.length; s += 2){
        const c = e.substring(s, s + 2), l = parseInt(c, 16);
        n ? o.setUint8(a++, l) : o.setUint8(a--, l);
    }
    return new Uint8Array(i1);
}
function Y0e(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0");
    return t;
}
function J0e(e) {
    const t = JSON.stringify(e, (r, n)=>typeof n == "bigint" ? `${n}n` : n);
    return Y5(t);
}
function e1e(e, t, r) {
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (e instanceof Uint8Array) return E0e(e, t, r);
    if (typeof e == "string") return X0e(e, t, r);
    if (typeof e == "bigint") return L0e(e, t, r);
    if (typeof e == "number") return W0e(e, t, r);
    if (typeof e == "boolean") return Uint8Array.of(e ? 1 : 0);
    throw TypeError("Unsupported format:" + typeof e);
}
const Ji = class Sn extends Uint8Array {
    static random(t = 32) {
        const r = v0e(t);
        return new Sn(r, t);
    }
    constructor(t, r, n){
        const i1 = e1e(t, r, n);
        super(i1);
    }
    get arr() {
        return [
            ...this
        ];
    }
    get num() {
        return this.toNum();
    }
    get big() {
        return this.toBig();
    }
    get str() {
        return this.toStr();
    }
    get hex() {
        return this.toHex();
    }
    get raw() {
        return new Uint8Array(this);
    }
    get bin() {
        return this.toBin();
    }
    get b58chk() {
        return this.tob58chk();
    }
    get base64() {
        return this.toBase64();
    }
    get b64url() {
        return this.toB64url();
    }
    get digest() {
        return this.toHash();
    }
    get id() {
        return this.toHash().hex;
    }
    get stream() {
        return new h1e(this);
    }
    toNum(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return G0e(r);
    }
    toBin() {
        return q0e(this);
    }
    toBig(t = "be") {
        const r = t === "be" ? this.reverse() : this;
        return H0e(r);
    }
    toHash() {
        const t = _4(this);
        return new Sn(t);
    }
    toJson() {
        const t = k4(this);
        return JSON.parse(t);
    }
    toBech32(t, r = 0) {
        return KU.encode(this, t, r);
    }
    toStr() {
        return k4(this);
    }
    toHex() {
        return Y0e(this);
    }
    toBytes() {
        return new Uint8Array(this);
    }
    tob58chk() {
        return UU.encode(this);
    }
    toBase64() {
        return QU.encode(this);
    }
    toB64url() {
        return $U.encode(this);
    }
    prepend(t) {
        return Sn.join([
            Sn.bytes(t),
            this
        ]);
    }
    append(t) {
        return Sn.join([
            this,
            Sn.bytes(t)
        ]);
    }
    slice(t, r) {
        const n = new Uint8Array(this).slice(t, r);
        return new Sn(n);
    }
    subarray(t, r) {
        const n = new Uint8Array(this).subarray(t, r);
        return new Sn(n);
    }
    reverse() {
        const t = new Uint8Array(this).reverse();
        return new Sn(t);
    }
    write(t, r) {
        const n = Sn.bytes(t);
        this.set(n, r);
    }
    prefixSize(t) {
        const r = Sn.varInt(this.length, t);
        return Sn.join([
            r,
            this
        ]);
    }
    static from(t) {
        return new Sn(Uint8Array.from(t));
    }
    static of(...t) {
        return new Sn(Uint8Array.of(...t));
    }
    static join(t) {
        const r = t.map((i1)=>Sn.bytes(i1)), n = MU(r);
        return new Sn(n);
    }
    static varInt(t, r) {
        if (t < 253) return Sn.num(t, 1);
        if (t < 65536) return Sn.of(253, ...Sn.num(t, 2, r));
        if (t < 4294967296) return Sn.of(254, ...Sn.num(t, 4, r));
        if (BigInt(t) < 0x10000000000000000n) return Sn.of(255, ...Sn.num(t, 8, r));
        throw new Error(`Value is too large: ${t}`);
    }
};
Ji.num = t1e, Ji.big = n1e, Ji.bin = r1e, Ji.raw = i1e, Ji.str = o1e, Ji.hex = a1e, Ji.bytes = s1e, Ji.json = u1e, Ji.base64 = c1e, Ji.b64url = l1e, Ji.bech32 = f1e, Ji.b58chk = d1e, Ji.encode = Y5, Ji.decode = k4;
let ur = Ji;
function t1e(e, t, r) {
    return new ur(e, t, r);
}
function r1e(e, t, r) {
    return new ur(K0e(e), t, r);
}
function n1e(e, t, r) {
    return new ur(e, t, r);
}
function i1e(e, t, r) {
    return new ur(e, t, r);
}
function o1e(e, t, r) {
    return new ur(Y5(e), t, r);
}
function a1e(e, t, r) {
    return new ur(e, t, r);
}
function s1e(e, t, r) {
    return new ur(e, t, r);
}
function u1e(e) {
    return new ur(J0e(e));
}
function c1e(e) {
    return new ur(QU.decode(e));
}
function l1e(e) {
    return new ur($U.decode(e));
}
function f1e(e) {
    return new ur(KU.decode(e));
}
function d1e(e) {
    return new ur(UU.decode(e));
}
class h1e {
    constructor(t){
        this.data = ur.bytes(t), this.size = this.data.length;
    }
    peek(t) {
        if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
        return new ur(this.data.slice(0, t));
    }
    read(t) {
        t = t ?? this.readSize();
        const r = this.peek(t);
        return this.data = this.data.slice(t), this.size = this.data.length, r;
    }
    readSize(t) {
        const r = this.read(1).num;
        switch(!0){
            case r >= 0 && r < 253:
                return r;
            case r === 253:
                return this.read(2).toNum(t);
            case r === 254:
                return this.read(4).toNum(t);
            case r === 255:
                return this.read(8).toNum(t);
            default:
                throw new Error(`Varint is out of range: ${r}`);
        }
    }
}
const Zm = hl.CURVE, J5 = Zm.n, p1e = Zm.p, g1e = {
    x: Zm.Gx,
    y: Zm.Gy
}, y1e = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const O4 = {
    N: J5,
    P: p1e,
    G: g1e,
    _0n: y1e
}, Ip = xU(J5, 32, !0), XU = (e)=>Li(e, J5);
function e7(e, t = !1) {
    if (t) throw new Error(e);
    return !1;
}
function YU(e) {
    return ur.random(e);
}
function m1e(e) {
    const t = ur.bytes(e).big;
    return ur.big(XU(t), 32);
}
var b1e = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fail: e7,
    mod_bytes: m1e,
    random: YU
});
const { N: w1e, _0n: A1e } = O4;
function v1e(e, t, r) {
    const n = ur.bytes(e);
    return n.length !== t ? e7(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function E1e(e, t) {
    return typeof e == "bigint" && A1e < e && e < w1e || e7("x value is not in the field!", t), !0;
}
const VI = hl.ProjectivePoint, JU = class ti extends Uint8Array {
    static mod(t) {
        return new ti(t);
    }
    static is_valid(t, r) {
        const n = ur.bytes(t, 32).big;
        return E1e(n, r);
    }
    constructor(t){
        let r = S1e(t);
        r = XU(r), ti.is_valid(r, !0), super(ur.big(r, 32), 32);
    }
    get buff() {
        return new ur(this);
    }
    get raw() {
        return this.buff.raw;
    }
    get big() {
        return this.buff.big;
    }
    get hex() {
        return this.buff.hex;
    }
    get point() {
        return this.generate();
    }
    get hasOddY() {
        return this.point.hasOddY;
    }
    get negated() {
        return this.hasOddY ? this.negate() : this;
    }
    gt(t) {
        return new ti(t).big > this.big;
    }
    lt(t) {
        return new ti(t).big < this.big;
    }
    eq(t) {
        return new ti(t).big === this.big;
    }
    ne(t) {
        return new ti(t).big !== this.big;
    }
    add(t) {
        const r = ti.mod(t), n = Ip.add(this.big, r.big);
        return new ti(n);
    }
    sub(t) {
        const r = ti.mod(t), n = Ip.sub(this.big, r.big);
        return new ti(n);
    }
    mul(t) {
        const r = ti.mod(t), n = Ip.mul(this.big, r.big);
        return new ti(n);
    }
    pow(t) {
        const r = ti.mod(t), n = Ip.pow(this.big, r.big);
        return new ti(n);
    }
    div(t) {
        const r = ti.mod(t), n = Ip.div(this.big, r.big);
        return new ti(n);
    }
    negate() {
        return new ti(ti.N - this.big);
    }
    generate() {
        const t = hl.ProjectivePoint.BASE.multiply(this.big);
        return Lf.import(t);
    }
};
JU.N = hl.CURVE.n;
let no = JU;
const Xy = class Wn {
    static from_x(t) {
        let r = x1e(t);
        r.length === 32 && (r = r.prepend(2)), v1e(r, 33);
        const n = VI.fromHex(r.hex);
        return n.assertValidity(), new Wn(n.x, n.y);
    }
    static generate(t) {
        const r = no.mod(t), n = Wn.base.multiply(r.big);
        return Wn.import(n);
    }
    static import(t) {
        const r = t instanceof Wn ? {
            x: t.x.big,
            y: t.y.big
        } : {
            x: t.x,
            y: t.y
        };
        return new Wn(r.x, r.y);
    }
    constructor(t, r){
        this._p = new VI(t, r, 1n), this.p.assertValidity();
    }
    get p() {
        return this._p;
    }
    get x() {
        return ur.big(this.p.x, 32);
    }
    get y() {
        return ur.big(this.p.y, 32);
    }
    get buff() {
        return ur.raw(this.p.toRawBytes(!0));
    }
    get raw() {
        return this.buff.raw;
    }
    get hex() {
        return this.buff.hex;
    }
    get hasEvenY() {
        return this.p.hasEvenY();
    }
    get hasOddY() {
        return !this.p.hasEvenY();
    }
    eq(t) {
        const r = t instanceof Wn ? t : Wn.from_x(t);
        return this.x.big === r.x.big && this.y.big === r.y.big;
    }
    add(t) {
        return t instanceof Wn ? Wn.import(this.p.add(t.p)) : Wn.import(this.p.add(Wn.generate(t).p));
    }
    sub(t) {
        return t instanceof Wn ? Wn.import(this.p.subtract(t.p)) : Wn.import(this.p.subtract(Wn.generate(t).p));
    }
    mul(t) {
        return t instanceof Wn ? Wn.import(this.p.multiply(t.x.big)) : Wn.import(this.p.multiply(no.mod(t).big));
    }
    negate() {
        return Wn.import(this.p.negate());
    }
};
Xy.P = O4.P, Xy.G = O4.G, Xy.base = hl.ProjectivePoint.BASE;
let Lf = Xy;
function S1e(e) {
    if (e instanceof no) return e.big;
    if (e instanceof Lf) return e.x.big;
    if (e instanceof Uint8Array) return ur.raw(e).big;
    if (typeof e == "string") return ur.hex(e).big;
    if (typeof e == "number") return ur.num(e).big;
    if (typeof e == "bigint") return BigInt(e);
    throw TypeError("Invalid input type:" + typeof e);
}
function x1e(e) {
    if (e instanceof no) return e.point.buff;
    if (e instanceof Lf) return e.buff;
    if (e instanceof Uint8Array || typeof e == "string") return ur.bytes(e);
    if (typeof e == "number" || typeof e == "bigint") return ur.bytes(e, 32);
    throw new TypeError(`Unknown type: ${typeof e}`);
}
function I4(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
}
function _1e(e) {
    if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function eD(e, ...t) {
    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function k1e(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    I4(e.outputLen), I4(e.blockLen);
}
function O1e(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function I1e(e, t) {
    eD(e);
    const r = t.outputLen;
    if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const B1e = {
    number: I4,
    bool: _1e,
    bytes: eD,
    hash: k1e,
    exists: O1e,
    output: I1e
};
var Zl = B1e;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const T1e = (e)=>e instanceof Uint8Array, t8 = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), Ts = (e, t)=>e << 32 - t | e >>> t, P1e = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
if (!P1e) throw new Error("Non little-endian hardware is not supported");
Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function C1e(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e));
}
function t7(e) {
    if (typeof e == "string" && (e = C1e(e)), !T1e(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
    return e;
}
class tD {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function Hf(e) {
    const t = (n)=>e().update(t7(n)).digest(), r = e();
    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;
}
function M1e(e, t, r, n) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, r, n);
    const i1 = BigInt(32), o = BigInt(4294967295), a = Number(r >> i1 & o), s = Number(r & o), c = n ? 4 : 0, l = n ? 0 : 4;
    e.setUint32(t + c, a, n), e.setUint32(t + l, s, n);
}
class r7 extends tD {
    constructor(t, r, n, i1){
        super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i1, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = t8(this.buffer);
    }
    update(t) {
        Zl.exists(this);
        const { view: r, buffer: n, blockLen: i1 } = this;
        t = t7(t);
        const o = t.length;
        for(let a = 0; a < o;){
            const s = Math.min(i1 - this.pos, o - a);
            if (s === i1) {
                const c = t8(t);
                for(; i1 <= o - a; a += i1)this.process(c, a);
                continue;
            }
            n.set(t.subarray(a, a + s), this.pos), this.pos += s, a += s, this.pos === i1 && (this.process(r, 0), this.pos = 0);
        }
        return this.length += t.length, this.roundClean(), this;
    }
    digestInto(t) {
        Zl.exists(this), Zl.output(t, this), this.finished = !0;
        const { buffer: r, view: n, blockLen: i1, isLE: o } = this;
        let { pos: a } = this;
        r[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i1 - a && (this.process(n, 0), a = 0);
        for(let f = a; f < i1; f++)r[f] = 0;
        M1e(n, i1 - 8, BigInt(this.length * 8), o), this.process(n, 0);
        const s = t8(t), c = this.outputLen;
        if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4, u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for(let f = 0; f < l; f++)s.setUint32(4 * f, u[f], o);
    }
    digest() {
        const { buffer: t, outputLen: r } = this;
        this.digestInto(t);
        const n = t.slice(0, r);
        return this.destroy(), n;
    }
    _cloneInto(t) {
        t || (t = new this.constructor()), t.set(...this.get());
        const { blockLen: r, buffer: n, length: i1, finished: o, destroyed: a, pos: s } = this;
        return t.length = i1, t.pos = s, t.finished = o, t.destroyed = a, i1 % r && t.buffer.set(n), t;
    }
}
const N1e = (e, t, r)=>e & t ^ ~e & r, R1e = (e, t, r)=>e & t ^ e & r ^ t & r, U1e = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), wc = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Ac = new Uint32Array(64);
class rD extends r7 {
    constructor(){
        super(64, 32, 8, !1), this.A = wc[0] | 0, this.B = wc[1] | 0, this.C = wc[2] | 0, this.D = wc[3] | 0, this.E = wc[4] | 0, this.F = wc[5] | 0, this.G = wc[6] | 0, this.H = wc[7] | 0;
    }
    get() {
        const { A: t, B: r, C: n, D: i1, E: o, F: a, G: s, H: c } = this;
        return [
            t,
            r,
            n,
            i1,
            o,
            a,
            s,
            c
        ];
    }
    // prettier-ignore
    set(t, r, n, i1, o, a, s, c) {
        this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i1 | 0, this.E = o | 0, this.F = a | 0, this.G = s | 0, this.H = c | 0;
    }
    process(t, r) {
        for(let f = 0; f < 16; f++, r += 4)Ac[f] = t.getUint32(r, !1);
        for(let f = 16; f < 64; f++){
            const h = Ac[f - 15], y = Ac[f - 2], S = Ts(h, 7) ^ Ts(h, 18) ^ h >>> 3, k = Ts(y, 17) ^ Ts(y, 19) ^ y >>> 10;
            Ac[f] = k + Ac[f - 7] + S + Ac[f - 16] | 0;
        }
        let { A: n, B: i1, C: o, D: a, E: s, F: c, G: l, H: u } = this;
        for(let f = 0; f < 64; f++){
            const h = Ts(s, 6) ^ Ts(s, 11) ^ Ts(s, 25), y = u + h + N1e(s, c, l) + U1e[f] + Ac[f] | 0, S = (Ts(n, 2) ^ Ts(n, 13) ^ Ts(n, 22)) + R1e(n, i1, o) | 0;
            u = l, l = c, c = s, s = a + y | 0, a = o, o = i1, i1 = n, n = y + S | 0;
        }
        n = n + this.A | 0, i1 = i1 + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, s = s + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(n, i1, o, a, s, c, l, u);
    }
    roundClean() {
        Ac.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}
class D1e extends rD {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
}
const Xm = Hf(()=>new rD());
Hf(()=>new D1e());
const _y = BigInt(2 ** 32 - 1), B4 = BigInt(32);
function nD(e, t = !1) {
    return t ? {
        h: Number(e & _y),
        l: Number(e >> B4 & _y)
    } : {
        h: Number(e >> B4 & _y) | 0,
        l: Number(e & _y) | 0
    };
}
function j1e(e, t = !1) {
    let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
    for(let i1 = 0; i1 < e.length; i1++){
        const { h: o, l: a } = nD(e[i1], t);
        [r[i1], n[i1]] = [
            o,
            a
        ];
    }
    return [
        r,
        n
    ];
}
const F1e = (e, t)=>BigInt(e >>> 0) << B4 | BigInt(t >>> 0), z1e = (e, t, r)=>e >>> r, L1e = (e, t, r)=>e << 32 - r | t >>> r, H1e = (e, t, r)=>e >>> r | t << 32 - r, K1e = (e, t, r)=>e << 32 - r | t >>> r, q1e = (e, t, r)=>e << 64 - r | t >>> r - 32, V1e = (e, t, r)=>e >>> r - 32 | t << 64 - r, W1e = (e, t)=>t, G1e = (e, t)=>e, Q1e = (e, t, r)=>e << r | t >>> 32 - r, $1e = (e, t, r)=>t << r | e >>> 32 - r, Z1e = (e, t, r)=>t << r - 32 | e >>> 64 - r, X1e = (e, t, r)=>e << r - 32 | t >>> 64 - r;
function Y1e(e, t, r, n) {
    const i1 = (t >>> 0) + (n >>> 0);
    return {
        h: e + r + (i1 / 2 ** 32 | 0) | 0,
        l: i1 | 0
    };
}
const J1e = (e, t, r)=>(e >>> 0) + (t >>> 0) + (r >>> 0), ege = (e, t, r, n)=>t + r + n + (e / 2 ** 32 | 0) | 0, tge = (e, t, r, n)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), rge = (e, t, r, n, i1)=>t + r + n + i1 + (e / 2 ** 32 | 0) | 0, nge = (e, t, r, n, i1)=>(e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i1 >>> 0), ige = (e, t, r, n, i1, o)=>t + r + n + i1 + o + (e / 2 ** 32 | 0) | 0, oge = {
    fromBig: nD,
    split: j1e,
    toBig: F1e,
    shrSH: z1e,
    shrSL: L1e,
    rotrSH: H1e,
    rotrSL: K1e,
    rotrBH: q1e,
    rotrBL: V1e,
    rotr32H: W1e,
    rotr32L: G1e,
    rotlSH: Q1e,
    rotlSL: $1e,
    rotlBH: Z1e,
    rotlBL: X1e,
    add: Y1e,
    add3L: J1e,
    add3H: ege,
    add4L: tge,
    add4H: rge,
    add5H: ige,
    add5L: nge
};
var kr = oge;
const [age, sge] = kr.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((e)=>BigInt(e))), vc = new Uint32Array(80), Ec = new Uint32Array(80);
class Ub extends r7 {
    constructor(){
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    // prettier-ignore
    get() {
        const { Ah: t, Al: r, Bh: n, Bl: i1, Ch: o, Cl: a, Dh: s, Dl: c, Eh: l, El: u, Fh: f, Fl: h, Gh: y, Gl: S, Hh: k, Hl: P } = this;
        return [
            t,
            r,
            n,
            i1,
            o,
            a,
            s,
            c,
            l,
            u,
            f,
            h,
            y,
            S,
            k,
            P
        ];
    }
    // prettier-ignore
    set(t, r, n, i1, o, a, s, c, l, u, f, h, y, S, k, P) {
        this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i1 | 0, this.Ch = o | 0, this.Cl = a | 0, this.Dh = s | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = f | 0, this.Fl = h | 0, this.Gh = y | 0, this.Gl = S | 0, this.Hh = k | 0, this.Hl = P | 0;
    }
    process(t, r) {
        for(let z = 0; z < 16; z++, r += 4)vc[z] = t.getUint32(r), Ec[z] = t.getUint32(r += 4);
        for(let z = 16; z < 80; z++){
            const K = vc[z - 15] | 0, $ = Ec[z - 15] | 0, ne = kr.rotrSH(K, $, 1) ^ kr.rotrSH(K, $, 8) ^ kr.shrSH(K, $, 7), ee = kr.rotrSL(K, $, 1) ^ kr.rotrSL(K, $, 8) ^ kr.shrSL(K, $, 7), q = vc[z - 2] | 0, U = Ec[z - 2] | 0, Q = kr.rotrSH(q, U, 19) ^ kr.rotrBH(q, U, 61) ^ kr.shrSH(q, U, 6), v = kr.rotrSL(q, U, 19) ^ kr.rotrBL(q, U, 61) ^ kr.shrSL(q, U, 6), B = kr.add4L(ee, v, Ec[z - 7], Ec[z - 16]), g = kr.add4H(B, ne, Q, vc[z - 7], vc[z - 16]);
            vc[z] = g | 0, Ec[z] = B | 0;
        }
        let { Ah: n, Al: i1, Bh: o, Bl: a, Ch: s, Cl: c, Dh: l, Dl: u, Eh: f, El: h, Fh: y, Fl: S, Gh: k, Gl: P, Hh: M, Hl: N } = this;
        for(let z = 0; z < 80; z++){
            const K = kr.rotrSH(f, h, 14) ^ kr.rotrSH(f, h, 18) ^ kr.rotrBH(f, h, 41), $ = kr.rotrSL(f, h, 14) ^ kr.rotrSL(f, h, 18) ^ kr.rotrBL(f, h, 41), ne = f & y ^ ~f & k, ee = h & S ^ ~h & P, q = kr.add5L(N, $, ee, sge[z], Ec[z]), U = kr.add5H(q, M, K, ne, age[z], vc[z]), Q = q | 0, v = kr.rotrSH(n, i1, 28) ^ kr.rotrBH(n, i1, 34) ^ kr.rotrBH(n, i1, 39), B = kr.rotrSL(n, i1, 28) ^ kr.rotrBL(n, i1, 34) ^ kr.rotrBL(n, i1, 39), g = n & o ^ n & s ^ o & s, E = i1 & a ^ i1 & c ^ a & c;
            M = k | 0, N = P | 0, k = y | 0, P = S | 0, y = f | 0, S = h | 0, ({ h: f, l: h } = kr.add(l | 0, u | 0, U | 0, Q | 0)), l = s | 0, u = c | 0, s = o | 0, c = a | 0, o = n | 0, a = i1 | 0;
            const w = kr.add3L(Q, B, E);
            n = kr.add3H(w, U, v, g), i1 = w | 0;
        }
        ({ h: n, l: i1 } = kr.add(this.Ah | 0, this.Al | 0, n | 0, i1 | 0)), ({ h: o, l: a } = kr.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0)), ({ h: s, l: c } = kr.add(this.Ch | 0, this.Cl | 0, s | 0, c | 0)), ({ h: l, l: u } = kr.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0)), ({ h: f, l: h } = kr.add(this.Eh | 0, this.El | 0, f | 0, h | 0)), ({ h: y, l: S } = kr.add(this.Fh | 0, this.Fl | 0, y | 0, S | 0)), ({ h: k, l: P } = kr.add(this.Gh | 0, this.Gl | 0, k | 0, P | 0)), ({ h: M, l: N } = kr.add(this.Hh | 0, this.Hl | 0, M | 0, N | 0)), this.set(n, i1, o, a, s, c, l, u, f, h, y, S, k, P, M, N);
    }
    roundClean() {
        vc.fill(0), Ec.fill(0);
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class uge extends Ub {
    constructor(){
        super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
    }
}
class cge extends Ub {
    constructor(){
        super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
    }
}
class lge extends Ub {
    constructor(){
        super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
    }
}
const fge = Hf(()=>new Ub());
Hf(()=>new uge());
Hf(()=>new cge());
Hf(()=>new lge());
const dge = new Uint8Array([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]), iD = Uint8Array.from({
    length: 16
}, (e, t)=>t), hge = iD.map((e)=>(9 * e + 5) % 16);
let n7 = [
    iD
], i7 = [
    hge
];
for(let e = 0; e < 4; e++)for (let t of [
    n7,
    i7
])t.push(t[e].map((r)=>dge[r]));
const oD = [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((e)=>new Uint8Array(e)), pge = n7.map((e, t)=>e.map((r)=>oD[t][r])), gge = i7.map((e, t)=>e.map((r)=>oD[t][r])), yge = new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
]), mge = new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
]), ky = (e, t)=>e << t | e >>> 32 - t;
function WI(e, t, r, n) {
    return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const Oy = new Uint32Array(16);
class bge extends r7 {
    constructor(){
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
        const { h0: t, h1: r, h2: n, h3: i1, h4: o } = this;
        return [
            t,
            r,
            n,
            i1,
            o
        ];
    }
    set(t, r, n, i1, o) {
        this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i1 | 0, this.h4 = o | 0;
    }
    process(t, r) {
        for(let y = 0; y < 16; y++, r += 4)Oy[y] = t.getUint32(r, !0);
        let n = this.h0 | 0, i1 = n, o = this.h1 | 0, a = o, s = this.h2 | 0, c = s, l = this.h3 | 0, u = l, f = this.h4 | 0, h = f;
        for(let y = 0; y < 5; y++){
            const S = 4 - y, k = yge[y], P = mge[y], M = n7[y], N = i7[y], z = pge[y], K = gge[y];
            for(let $ = 0; $ < 16; $++){
                const ne = ky(n + WI(y, o, s, l) + Oy[M[$]] + k, z[$]) + f | 0;
                n = f, f = l, l = ky(s, 10) | 0, s = o, o = ne;
            }
            for(let $ = 0; $ < 16; $++){
                const ne = ky(i1 + WI(S, a, c, u) + Oy[N[$]] + P, K[$]) + h | 0;
                i1 = h, h = u, u = ky(c, 10) | 0, c = a, a = ne;
            }
        }
        this.set(this.h1 + s + u | 0, this.h2 + l + h | 0, this.h3 + f + i1 | 0, this.h4 + n + a | 0, this.h0 + o + c | 0);
    }
    roundClean() {
        Oy.fill(0);
    }
    destroy() {
        this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
    }
}
const wge = Hf(()=>new bge());
class aD extends tD {
    constructor(t, r){
        super(), this.finished = !1, this.destroyed = !1, Zl.hash(t);
        const n = t7(r);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i1 = this.blockLen, o = new Uint8Array(i1);
        o.set(n.length > i1 ? t.create().update(n).digest() : n);
        for(let a = 0; a < o.length; a++)o[a] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for(let a = 0; a < o.length; a++)o[a] ^= 106;
        this.oHash.update(o), o.fill(0);
    }
    update(t) {
        return Zl.exists(this), this.iHash.update(t), this;
    }
    digestInto(t) {
        Zl.exists(this), Zl.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t;
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: r, iHash: n, finished: i1, destroyed: o, blockLen: a, outputLen: s } = this;
        return t = t, t.finished = i1, t.destroyed = o, t.blockLen = a, t.outputLen = s, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
}
const sD = (e, t, r)=>new aD(e, t).update(r).digest();
sD.create = (e, t)=>new aD(e, t);
function Age(e) {
    const t = ur.bytes(e);
    return ur.raw(Xm(t));
}
function vge(e) {
    const t = ur.bytes(e);
    return ur.raw(Xm(Xm(t)));
}
function uD(e) {
    const t = ur.bytes(e);
    return ur.raw(wge(Xm(t)));
}
function Ege(e, t) {
    const r = ur.bytes(e), n = ur.bytes(t);
    return ur.raw(sD(fge, r, n));
}
function Sge(e) {
    const t = ur.str(e).digest;
    return ur.join([
        t,
        t
    ]);
}
function xge(e = 32) {
    return o7(YU(e));
}
function o7(e) {
    return no.mod(e).buff;
}
function cD(e, t = !1) {
    const r = no.mod(e).point;
    return t ? r.x : r.buff;
}
function lD(e, t) {
    const r = Lf.from_x(t), n = no.mod(e);
    return r.mul(n).buff;
}
function _ge(e, t, r = "ecdh/code") {
    const n = Sge(r), i1 = o7(e), o = cD(i1), a = ur.bytes(t), s = lD(i1, a), c = [
        o.hex,
        a.hex
    ];
    return c.sort(), Ege(s, ur.join([
        n,
        ...c
    ]));
}
function kge(e) {
    const t = ur.bytes(e);
    switch(!0){
        case t.length === 32:
            return !0;
        case t.length === 33 && t[0] === 2:
            return !0;
        case t.length === 33 && t[0] === 3:
            return !1;
        default:
            throw new TypeError(`Invalid public key: ${t.hex}`);
    }
}
function Oge(e) {
    const t = ur.bytes(e);
    switch(t.length){
        case 32:
            return t;
        case 33:
            return t.slice(1, 33);
        default:
            throw new Error(`Invalid key length: ${t.length}`);
    }
}
var Ige = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    genSecretKey: xge,
    getPublicKey: cD,
    getSecretKey: o7,
    getSharedCode: _ge,
    getSharedKey: lD,
    is_even_pub: kge,
    xonly_pub: Oge
});
ur.random(32);
const T4 = {
    ...Ige,
    ...b1e
};
function Db(e) {
    const t = $e.bytes(e);
    return ru(t, 33), uD(t);
}
function fD(e) {
    const t = nu.fmt.toBytes(e, !1);
    return uD(t);
}
function dD(e) {
    const t = nu.fmt.toBytes(e, !1);
    return Age(t);
}
function hD(e, t = "main") {
    const r = t === "main" ? [
        "1"
    ] : [
        "m",
        "n"
    ];
    for (const n of r)if (e.startsWith(n)) return !0;
    return !1;
}
function pD(e, t = "main") {
    const r = $e.bytes(e), n = t === "main" ? $e.num(0) : $e.num(111);
    return ru(e, 20), r.prepend(n).tob58chk();
}
function Bge(e, t = "main") {
    if (!hD(e, t)) throw new TypeError("Invalid p2pkh address!");
    return $e.b58chk(e).slice(1);
}
function Tge(e) {
    const t = $e.bytes(e);
    return ru(t, 20), [
        "OP_DUP",
        "OP_HASH160",
        t.hex,
        "OP_EQUALVERIFY",
        "OP_CHECKSIG"
    ];
}
function Pge(e, t) {
    const r = Db(e);
    return pD(r, t);
}
const gD = {
    check: hD,
    encode: pD,
    decode: Bge,
    hash: Db,
    scriptPubKey: Tge,
    fromPubKey: Pge
};
function yD(e, t = "main") {
    const r = t === "main" ? [
        "3"
    ] : [
        "2"
    ];
    for (const n of r)if (e.startsWith(n)) return !0;
    return !1;
}
function mD(e, t = "main") {
    const r = t === "main" ? $e.num(5) : $e.num(196), n = $e.bytes(e);
    return ru(n, 20), n.prepend(r).tob58chk();
}
function Cge(e, t = "main") {
    if (!yD(e, t)) throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
    return $e.b58chk(e).slice(1);
}
function Mge(e) {
    return [
        "OP_HASH160",
        $e.bytes(e).hex,
        "OP_EQUAL"
    ];
}
function Nge(e, t) {
    const r = fD(e);
    return mD(r, t);
}
const bD = {
    check: yD,
    encode: mD,
    decode: Cge,
    hash: fD,
    scriptPubKey: Mge,
    fromScript: Nge
}, a7 = {
    main: "bc",
    testnet: "tb",
    signet: "tb",
    regtest: "bcrt"
}, Rge = [
    "bc1q",
    "tb1q",
    "bcrt1q"
];
function wD(e) {
    for (const t of Rge)if (e.startsWith(t)) return !0;
    return !1;
}
function AD(e, t = "main") {
    const r = a7[t], n = $e.bytes(e);
    return ru(n, 20), n.toBech32(r, 0);
}
function Uge(e) {
    if (!wD(e)) throw new TypeError("Invalid segwit address!");
    return $e.bech32(e);
}
function Dge(e) {
    const t = $e.bytes(e);
    return ru(t, 20), [
        "OP_0",
        t.hex
    ];
}
function jge(e, t) {
    const r = Db(e);
    return AD(r, t);
}
const vD = {
    check: wD,
    encode: AD,
    decode: Uge,
    hash: Db,
    scriptPubKey: Dge,
    fromPubKey: jge
}, Fge = [
    "bc1q",
    "tb1q",
    "bcrt1q"
];
function ED(e) {
    for (const t of Fge)if (e.startsWith(t)) return !0;
    return !1;
}
function SD(e, t = "main") {
    const r = a7[t], n = $e.bytes(e);
    return ru(n, 32), n.toBech32(r, 0);
}
function zge(e) {
    if (!ED(e)) throw new TypeError("Invalid segwit address!");
    return $e.bech32(e);
}
function Lge(e) {
    const t = $e.bytes(e);
    return ru(t, 32), [
        "OP_0",
        t.hex
    ];
}
function Hge(e, t) {
    const r = dD(e);
    return SD(r, t);
}
const xD = {
    check: ED,
    encode: SD,
    decode: zge,
    hash: dD,
    scriptPubKey: Lge,
    fromScript: Hge
};
function vf(e) {
    const t = $e.bytes(e);
    return t.length > 32 ? t.slice(1, 33) : t;
}
const Kge = [
    "bc1p",
    "tb1p",
    "bcrt1p"
];
function _D(e) {
    for (const t of Kge)if (e.startsWith(t)) return !0;
    return !1;
}
function kD(e, t = "main") {
    const r = a7[t], n = $e.bytes(e);
    return ru(n, 32), n.toBech32(r, 1);
}
function qge(e) {
    if (!_D(e)) throw new TypeError("Invalid taproot address!");
    return $e.bech32(e);
}
function Vge(e) {
    const t = $e.bytes(e);
    return ru(t, 32), [
        "OP_1",
        t.hex
    ];
}
function Wge(e, t) {
    const r = vf(e);
    return kD(r, t);
}
const OD = {
    check: _D,
    encode: kD,
    decode: qge,
    scriptPubKey: Vge,
    fromPubKey: Wge
}, Gge = {
    version: 2,
    vin: [],
    vout: [],
    locktime: 0
}, Qge = {
    scriptSig: [],
    sequence: 4294967293,
    witness: []
}, $ge = {
    value: 0n,
    scriptPubKey: []
};
function s7(e) {
    const t = {
        ...Gge,
        ...e
    };
    return t.vin = t.vin.map((r)=>({
            ...Qge,
            ...r
        })), t.vout = t.vout.map((r)=>({
            ...$ge,
            ...r
        })), t;
}
function vh(e, t) {
    const { version: r, vin: n, vout: i1, locktime: o } = s7(e), a = t !== !0 && Zge(n), s = [
        ID(r)
    ];
    a && s.push($e.hex("0001")), s.push(Xge(n)), s.push(Yge(i1));
    for (const c of n)a && s.push(eye(c.witness));
    return s.push(BD(o)), $e.join(s);
}
function Zge(e) {
    for (const t of e){
        const { witness: r } = t;
        if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0) return !0;
    }
    return !1;
}
function ID(e) {
    return $e.num(e, 4).reverse();
}
function u7(e) {
    return $e.hex(e, 32).reverse();
}
function c7(e) {
    return $e.num(e, 4).reverse();
}
function l7(e) {
    if (typeof e == "string") return $e.hex(e, 4).reverse();
    if (typeof e == "number") return $e.num(e, 4).reverse();
    throw new Error("Unrecognized format: " + String(e));
}
function Xge(e) {
    const t = [
        $e.varInt(e.length, "le")
    ];
    for (const r of e){
        const { txid: n, vout: i1, scriptSig: o, sequence: a } = r;
        t.push(u7(n)), t.push(c7(i1)), t.push(zf(o, !0)), t.push(l7(a));
    }
    return $e.join(t);
}
function z1(e) {
    if (typeof e == "number") {
        if (e % 1 !== 0) throw new Error("Value must be an integer:" + String(e));
        return $e.num(e, 8).reverse();
    }
    return $e.big(e, 8).reverse();
}
function Yge(e) {
    const t = [
        $e.varInt(e.length, "le")
    ];
    for (const r of e)t.push(Jge(r));
    return $e.join(t);
}
function Jge(e) {
    const { value: t, scriptPubKey: r } = e, n = [];
    return n.push(z1(t)), n.push(zf(r, !0)), $e.join(n);
}
function eye(e = []) {
    const t = [];
    if (Array.isArray(e)) {
        const r = $e.varInt(e.length);
        t.push(r);
        for (const n of e)t.push(tye(n));
        return $e.join(t);
    } else return $e.bytes(e);
}
function tye(e) {
    return rye(e) ? new $e(0) : zf(e, !0);
}
function rye(e) {
    if (Array.isArray(e)) return e.length === 0;
    if (typeof e == "string" && e === "") return !0;
    const t = $e.bytes(e);
    return t.length === 1 && t[0] === 0;
}
function BD(e) {
    if (typeof e == "string") return $e.hex(e, 4);
    if (typeof e == "number") return $e.num(e, 4).reverse();
    throw new Error("Unrecognized format: " + String(e));
}
function f7(e) {
    typeof e == "string" && (e = $e.hex(e).raw);
    const t = new Jh(e), r = nye(t), n = iye(t), i1 = oye(t), o = sye(t);
    if (n) for (const s of i1)s.witness = cye(t);
    const a = lye(t);
    return {
        version: r,
        vin: i1,
        vout: o,
        locktime: a
    };
}
function nye(e) {
    return e.read(4).reverse().toNum();
}
function iye(e) {
    const [t, r] = [
        ...e.peek(2)
    ];
    if (t === 0) {
        if (e.read(2), r === 1) return !0;
        throw new Error(`Invalid witness flag: ${r}`);
    }
    return !1;
}
function oye(e) {
    const t = [], r = e.readSize("le");
    for(let n = 0; n < r; n++)t.push(aye(e));
    return t;
}
function aye(e) {
    return {
        txid: e.read(32).reverse().toHex(),
        vout: e.read(4).reverse().toNum(),
        scriptSig: PD(e),
        sequence: e.read(4).reverse().toHex(),
        witness: []
    };
}
function sye(e) {
    const t = [], r = e.readSize("le");
    for(let n = 0; n < r; n++)t.push(uye(e));
    return t;
}
function uye(e) {
    return {
        value: e.read(8).reverse().big,
        scriptPubKey: PD(e)
    };
}
function cye(e) {
    const t = [], r = e.readSize();
    for(let n = 0; n < r; n++){
        const i1 = TD(e);
        t.push(i1 ?? "");
    }
    return t;
}
function TD(e, t) {
    const r = e.readSize("le");
    return r > 0 ? e.read(r).hex : null;
}
function PD(e, t) {
    const r = TD(e);
    return r !== null ? r : [];
}
function lye(e) {
    return e.read(4).reverse().toNum();
}
function fye(e) {
    if (hU(e)) return f7(e);
    if (typeof e == "object" && !(e instanceof Uint8Array)) return vh(e), s7(e);
    throw new Error("Invalid format: " + typeof e);
}
function dye(e) {
    if (hU(e)) return f7(e), $e.bytes(e);
    if (typeof e == "object") return vh(e);
    throw new Error("Invalid format: " + typeof e);
}
const d7 = {
    toBytes: dye,
    toJson: fye
}, hye = [
    [
        "p2pkh",
        /^76a914(?<hash>\w{40})88ac$/
    ],
    [
        "p2sh",
        /^a914(?<hash>\w{40})87$/
    ],
    [
        "p2w-pkh",
        /^0014(?<hash>\w{40})$/
    ],
    [
        "p2w-sh",
        /^0020(?<hash>\w{64})$/
    ],
    [
        "p2tr",
        /^5120(?<hash>\w{64})$/
    ]
], pye = [
    192,
    194,
    196,
    198,
    200,
    202,
    204,
    206,
    208,
    210,
    212,
    214,
    216,
    218,
    220,
    222,
    224,
    226,
    228,
    230,
    232,
    234,
    236,
    238,
    240,
    242,
    244,
    246,
    248,
    250,
    252,
    254,
    102,
    126,
    128,
    132,
    150,
    152,
    186,
    188,
    190
];
function gye(e) {
    let t = e.at(-1);
    return Vu(t) && (t = $e.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), $e.raw(t)) : null;
}
function yye(e) {
    let t = e.at(-1);
    return Vu(t) && (t = $e.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && pye.includes(t[0] & 254) ? (e.pop(), $e.raw(t)) : null;
}
function mye(e) {
    if (e.length > 1) {
        const t = e.at(-1);
        try {
            const r = nu.fmt.toBytes(t);
            return e.pop(), r;
        } catch  {
            return null;
        }
    }
    return null;
}
function bye(e) {
    const t = [];
    for (const r of e)if (Vu(r) || r instanceof Uint8Array || typeof r == "number") t.push($e.bytes(r));
    else throw new Error("unrecognized value: " + String(r));
    return t;
}
function wye(e = []) {
    const t = [
        ...e
    ], r = gye(t), n = yye(t), i1 = mye(t), o = bye(t);
    return {
        annex: r,
        cblock: n,
        script: i1,
        params: o
    };
}
function Aye(e) {
    const t = nu.fmt.toBytes(e, !1).hex;
    for (const [r, n] of hye){
        const i1 = r, { groups: o } = n.exec(t) ?? {}, { hash: a } = o ?? {};
        if (Vu(a)) return {
            type: i1,
            data: $e.hex(a)
        };
    }
    return {
        type: "raw",
        data: $e.hex(t)
    };
}
function vye(e) {
    const t = d7.toJson(e), r = vh(t, !0);
    return vge(r).reverse().hex;
}
function Eye(e) {
    const t = d7.toJson(e), r = vh(t, !0).length, n = vh(t, !1).length, i1 = r * 3 + n, o = i1 % 4 > 0 ? 1 : 0, a = Math.floor(i1 / 4) + o;
    return {
        size: n,
        bsize: r,
        vsize: a,
        weight: i1
    };
}
const Wc = {
    create: s7,
    encode: vh,
    decode: f7,
    fmt: d7,
    util: {
        getTxSize: Eye,
        getTxid: vye,
        readScriptPubKey: Aye,
        readWitness: wye
    }
}, Sye = [
    [
        "1",
        "p2pkh",
        "main",
        20,
        "base58"
    ],
    [
        "3",
        "p2sh",
        "main",
        20,
        "base58"
    ],
    [
        "m",
        "p2pkh",
        "testnet",
        20,
        "base58"
    ],
    [
        "n",
        "p2pkh",
        "testnet",
        20,
        "base58"
    ],
    [
        "2",
        "p2sh",
        "testnet",
        20,
        "base58"
    ],
    [
        "bc1q",
        "p2w-pkh",
        "main",
        20,
        "bech32"
    ],
    [
        "tb1q",
        "p2w-pkh",
        "testnet",
        20,
        "bech32"
    ],
    [
        "bcrt1q",
        "p2w-pkh",
        "regtest",
        20,
        "bech32"
    ],
    [
        "bc1q",
        "p2w-sh",
        "main",
        32,
        "bech32"
    ],
    [
        "tb1q",
        "p2w-sh",
        "testnet",
        32,
        "bech32"
    ],
    [
        "bcrt1q",
        "p2w-sh",
        "regtest",
        32,
        "bech32"
    ],
    [
        "bc1p",
        "p2tr",
        "main",
        32,
        "bech32m"
    ],
    [
        "tb1p",
        "p2tr",
        "testnet",
        32,
        "bech32m"
    ],
    [
        "bcrt1p",
        "p2tr",
        "regtest",
        32,
        "bech32m"
    ]
];
function xye(e, t) {
    switch(t){
        case "base58":
            return $e.b58chk(e).slice(1);
        case "bech32":
            return $e.bech32(e);
        case "bech32m":
            return $e.bech32(e);
        default:
            throw new Error("Invalid address format: " + t);
    }
}
function _ye(e) {
    for (const t of Sye){
        const [r, n, i1, o, a] = t;
        if (e.startsWith(r) && xye(e, a).length === o) return t;
    }
    throw new Error("Invalid address: " + e);
}
function CD(e) {
    switch(e){
        case "p2pkh":
            return gD;
        case "p2sh":
            return bD;
        case "p2w-pkh":
            return vD;
        case "p2w-sh":
            return xD;
        case "p2tr":
            return OD;
        default:
            throw new Error("Invalid address type: " + e);
    }
}
function MD(e) {
    const [t, r, n] = _ye(e), i1 = CD(r), o = i1.decode(e, n), a = i1.scriptPubKey(o);
    return {
        prefix: t,
        type: r,
        network: n,
        data: o,
        script: a
    };
}
function kye(e, t) {
    const { type: r, data: n } = Wc.util.readScriptPubKey(e);
    return CD(r).encode(n, t);
}
function Oye(e) {
    const { script: t } = MD(e);
    return nu.fmt.toAsm(t, !1);
}
const ND = {
    p2pkh: gD,
    p2sh: bD,
    p2wpkh: vD,
    p2wsh: xD,
    p2tr: OD,
    decode: MD,
    fromScriptPubKey: kye,
    toScriptPubKey: Oye
}, Iye = [
    0,
    1,
    2,
    3,
    129,
    130,
    131
];
function h7(e, t, r = {}) {
    const { extension: n, sigflag: i1 = 0, extflag: o = 0, key_version: a = 0, separator_pos: s = 4294967295 } = r, c = Wc.fmt.toJson(e), { version: l, vin: u, vout: f, locktime: h } = c;
    if (t >= u.length) throw new Error("Index out of bounds: " + String(t));
    if (!Iye.includes(i1)) throw new Error("Invalid hash type: " + String(i1));
    if (o < 0 || o > 127) throw new Error("Extention flag out of range: " + String(o));
    const { txid: y, vout: S, sequence: k, witness: P = [] } = u[t], M = (i1 & 128) === 128, N = Rye(P), z = N !== void 0 ? 1 : 0, K = (o + (n !== void 0 ? 1 : 0)) * 2 + z, $ = $e.str("TapSighash").digest, ne = [
        $,
        $,
        $e.num(0, 1),
        $e.num(i1, 1),
        ID(l),
        BD(h)
    ];
    if (!M) {
        const ee = u.map((q)=>GI(q));
        ne.push(Bye(u), Pye(ee), Cye(ee), Tye(u));
    }
    if (((i1 & 3) < 2 || (i1 & 3) > 3) && ne.push(Mye(f)), ne.push($e.num(K, 1)), M) {
        const { value: ee, scriptPubKey: q } = GI(u[t]);
        ne.push(u7(y), c7(S), z1(ee), nu.encode(q, !0), l7(k));
    } else ne.push($e.num(t, 4).reverse());
    return N !== void 0 && ne.push(N), (i1 & 3) === 3 && ne.push(Nye(f[t])), n !== void 0 && ne.push($e.bytes(n), $e.num(a), $e.num(s, 4, "le")), $e.join(ne).digest;
}
function Bye(e) {
    const t = [];
    for (const { txid: r, vout: n } of e)t.push(u7(r)), t.push(c7(n));
    return $e.join(t).digest;
}
function Tye(e) {
    const t = [];
    for (const { sequence: r } of e)t.push(l7(r));
    return $e.join(t).digest;
}
function Pye(e) {
    const t = [];
    for (const { value: r } of e)t.push(z1(r));
    return $e.join(t).digest;
}
function Cye(e) {
    const t = [];
    for (const { scriptPubKey: r } of e)t.push(zf(r, !0));
    return $e.join(t).digest;
}
function Mye(e) {
    const t = [];
    for (const { value: r, scriptPubKey: n } of e)t.push(z1(r)), t.push(nu.encode(n, !0));
    return $e.join(t).digest;
}
function Nye(e) {
    return $e.join([
        z1(e.value),
        nu.encode(e.scriptPubKey, !0)
    ]).digest;
}
function Rye(e) {
    if (e === void 0 || e.length < 2) return;
    let t = e.at(-1);
    if (typeof t == "string" && (t = $e.hex(t)), t instanceof Uint8Array && t[0] === 80) return $e.raw(t).prefixSize("be").digest;
}
function GI(e) {
    if (e.prevout === void 0) throw new Error("Prevout data missing for input: " + String(e.txid));
    return e.prevout;
}
const Uye = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, Dye = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function jye(e, t, r, n = {}) {
    const { sigflag: i1 = 0 } = n, o = h7(t, r, n), a = Fye(e, o);
    return i1 === 0 ? $e.raw(a) : $e.join([
        a,
        i1
    ]);
}
function Fye(e, t, r = $e.random(32)) {
    const n = $e.bytes(t), i1 = new no(e), o = i1.point, a = o.hasEvenY ? i1.big : i1.negated.big, s = Zy("BIP0340/aux", $e.bytes(r)), c = a ^ s.big, l = Zy("BIP0340/nonce", c, o.x.raw, n), u = new no(l), f = u.point, h = f.hasEvenY ? u.big : u.negated.big, y = new no(Zy("BIP0340/challenge", f.x.raw, o.x.raw, n)), S = new no(h + y.big * a);
    return $e.join([
        f.x.raw,
        S.raw
    ]);
}
function zye(e, t, r, n = !1) {
    const i1 = Lf.from_x(vf(r)), o = $e.bytes(t), a = $e.bytes(e).stream;
    a.size < 64 && Go("Signature length is too small: " + String(a.size), n);
    const s = a.read(32);
    s.big > Uye && Go("Signature r value greater than field size!", n);
    const c = a.read(32);
    c.big > Dye && Go("Signature s value greater than curve order!", n);
    const l = new no(Zy("BIP0340/challenge", s.raw, i1.x.raw, o)), u = new no(c).point, f = i1.mul(l.big), h = u.sub(f);
    return h.hasOddY && Go("Signature R value has odd Y coordinate!", n), h.x.big === 0n && Go("Signature R value is infinite!", n), h.x.big === s.big;
}
const Lye = 192;
function jb(e) {
    const t = $e.str(e).digest;
    return $e.join([
        t,
        t
    ]);
}
function p7(e, t = Lye) {
    return $e.join([
        jb("TapLeaf"),
        qye(t),
        $e.bytes(e)
    ]).digest.hex;
}
function Hye(e, t) {
    return p7(nu.fmt.toBytes(e), t);
}
function g7(e, t) {
    return t < e && ([e, t] = [
        t,
        e
    ]), $e.join([
        jb("TapBranch"),
        $e.hex(e).raw,
        $e.hex(t).raw
    ]).digest.hex;
}
function Kye(e) {
    return $e.hex(Ym(e)[0]);
}
function Ym(e, t, r = []) {
    const n = [], i1 = [];
    if (e.length < 1) throw new Error("Tree is empty!");
    for(let o = 0; o < e.length; o++){
        const a = e[o];
        if (Array.isArray(a)) {
            const [s, c, l] = Ym(a, t);
            t = c, n.push(s);
            for (const u of l)r.push(u);
        } else n.push(a);
    }
    if (n.length === 1) return [
        n[0],
        t,
        r
    ];
    n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
    for(let o = 0; o < n.length - 1; o += 2){
        const a = g7(n[o], n[o + 1]);
        i1.push(a), typeof t == "string" && (t === n[o] ? (r.push(n[o + 1]), t = a) : t === n[o + 1] && (r.push(n[o]), t = a));
    }
    return Ym(i1, t, r);
}
function qye(e = 192) {
    return e & 254;
}
function RD(e, t = new Uint8Array(), r = !1) {
    const n = r ? new no(e).point.x.raw : vf(e);
    return $e.join([
        jb("TapTweak"),
        n,
        $e.bytes(t)
    ]).digest;
}
function $d(e, t, r = !1) {
    t === void 0 && (t = new Uint8Array());
    const n = $e.bytes(e), i1 = RD(e, t, r);
    return r ? UD(n, i1) : DD(n, i1);
}
function Vye(e, t) {
    return $d(e, t);
}
function Wye(e, t) {
    return $d(e, t, !0);
}
function UD(e, t) {
    let r = new no(e);
    return r.point.hasOddY && (r = r.negate()), $e.raw(r.add(t).raw);
}
function DD(e, t) {
    e = vf(e);
    const r = Lf.from_x(e).add(t);
    return $e.raw(r.raw);
}
function Gye() {
    const e = $e.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
    return Lf.from_x(e.digest).x;
}
const Qye = Gye(), $ye = 192;
function Zye(e, t = {}) {
    return jD(e, {
        ...t,
        isPrivate: !0
    });
}
function Xye(e, t = {}) {
    return jD(e, {
        ...t,
        isPrivate: !1
    });
}
function jD(e, t = {}) {
    const { isPrivate: r = !1, tree: n = [], version: i1 = $ye } = t, o = r ? T4.getPublicKey(e, !0) : vf(e);
    let { target: a } = t;
    a !== void 0 && (a = $e.bytes(a).hex);
    let s, c = [];
    if (n.length > 0) {
        const [h, y, S] = Ym(n, a);
        c = S, s = $d(e, h, r);
    } else a !== void 0 ? s = $d(e, a, r) : s = $d(e, void 0, r);
    const l = r ? T4.getPublicKey(s)[0] : s[0], u = [
        $e.num(i1 + zD(l)),
        o
    ];
    c.length > 0 && c.forEach((h)=>u.push($e.hex(h)));
    const f = $e.join(u);
    if (a !== void 0 && !y7(s, a, f, t)) throw new Error("Path checking failed! Unable to generate path.");
    return [
        vf(s).hex,
        f.hex
    ];
}
function y7(e, t, r, n = {}) {
    const { isPrivate: i1 = !1, throws: o = !1 } = n, { parity: a, paths: s, intkey: c } = FD(r), l = i1 ? T4.getPublicKey(e, !0) : vf(e), u = $e.join([
        a,
        l
    ]);
    if (u.length !== 33) return Go("Invalid tapkey: " + u.hex, o);
    let f = $e.bytes(t).hex;
    for (const y of s)f = g7(f, y);
    const h = $d(c, f);
    return $e.raw(h).hex === $e.raw(u).hex;
}
function FD(e) {
    const t = new Jh($e.bytes(e)), r = t.read(1).num, n = t.read(32), [i1, o] = r % 2 === 0 ? [
        r,
        2
    ] : [
        r - 1,
        3
    ], a = [];
    for(; t.size >= 32;)a.push(t.read(32).hex);
    if (t.size !== 0) throw new Error("Non-empty buffer on control block: " + String(t));
    return {
        intkey: n,
        paths: a,
        parity: o,
        version: i1
    };
}
function zD(e = 2) {
    if (e === 0 || e === 1) return e;
    if (e === 2 || e === "02") return 0;
    if (e === 3 || e === "03") return 1;
    throw new Error("Invalid parity bit: " + String(e));
}
function Yye(e, t, r = {}) {
    const n = Wc.fmt.toJson(e), { throws: i1 = !1 } = r, { prevout: o, witness: a = [] } = n.vin[t], s = Wc.util.readWitness(a), { cblock: c, script: l, params: u } = s;
    let f;
    if (u.length < 1) return Go("Invalid witness data: " + String(a), i1);
    const { scriptPubKey: h } = o ?? {};
    if (h === void 0) return Go("Prevout scriptPubKey is empty!", i1);
    const { type: y, data: S } = Wc.util.readScriptPubKey(h);
    if (y !== "p2tr") return Go("Prevout script is not a valid taproot output:" + S.hex, i1);
    if (S.length !== 32) return Go("Invalid tapkey length: " + String(S.length), i1);
    if (c !== null && l !== null) {
        const z = c[0] & 254, K = p7(l, z);
        if (r.extension = K, !y7(S, K, c, {
            throws: i1
        })) return Go("cblock verification failed!", i1);
    }
    r.pubkey !== void 0 ? f = $e.bytes(r.pubkey) : u.length > 1 && u[1].length === 32 ? f = $e.bytes(u[1]) : f = $e.bytes(S);
    const k = nu.fmt.toParam(u[0]), P = new Jh(k), M = P.read(64).raw;
    if (P.size === 1 && (r.sigflag = P.read(1).num, r.sigflag === 0)) return Go("0x00 is not a valid appended sigflag!", i1);
    const N = h7(n, t, r);
    return zye(M, N, f, i1) ? !0 : Go("Invalid signature!", i1);
}
const Jye = {
    hash: h7,
    sign: jye,
    verify: Yye
}, eme = {
    taproot: Jye
}, tme = {
    getTag: jb,
    getLeaf: p7,
    getBranch: g7,
    getRoot: Kye
}, rme = {
    readCtrlBlock: FD,
    readParityBit: zD
}, nme = {
    getPubKey: Vye,
    getSecKey: Wye,
    getTweak: RD,
    tweakSecKey: UD,
    tweakPubKey: DD
}, Jm = {
    getPubKey: Xye,
    getSecKey: Zye,
    encodeScript: Hye,
    checkPath: y7,
    tree: tme,
    tweak: nme,
    util: rme,
    SCRIPT_PUBKEY: Qye
};
var $r;
(function(e) {
    e.assertEqual = (i1)=>i1;
    function t(i1) {}
    e.assertIs = t;
    function r(i1) {
        throw new Error();
    }
    e.assertNever = r, e.arrayToEnum = (i1)=>{
        const o = {};
        for (const a of i1)o[a] = a;
        return o;
    }, e.getValidEnumValues = (i1)=>{
        const o = e.objectKeys(i1).filter((s)=>typeof i1[i1[s]] != "number"), a = {};
        for (const s of o)a[s] = i1[s];
        return e.objectValues(a);
    }, e.objectValues = (i1)=>e.objectKeys(i1).map(function(o) {
            return i1[o];
        }), e.objectKeys = typeof Object.keys == "function" ? (i1)=>Object.keys(i1) : (i1)=>{
        const o = [];
        for(const a in i1)Object.prototype.hasOwnProperty.call(i1, a) && o.push(a);
        return o;
    }, e.find = (i1, o)=>{
        for (const a of i1)if (o(a)) return a;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i1)=>Number.isInteger(i1) : (i1)=>typeof i1 == "number" && isFinite(i1) && Math.floor(i1) === i1;
    function n(i1, o = " | ") {
        return i1.map((a)=>typeof a == "string" ? `'${a}'` : a).join(o);
    }
    e.joinValues = n, e.jsonStringifyReplacer = (i1, o)=>typeof o == "bigint" ? o.toString() : o;
})($r || ($r = {}));
var P4;
(function(e) {
    e.mergeShapes = (t, r)=>({
            ...t,
            ...r
        });
})(P4 || (P4 = {}));
const It = $r.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), Nc = (e)=>{
    switch(typeof e){
        case "undefined":
            return It.undefined;
        case "string":
            return It.string;
        case "number":
            return isNaN(e) ? It.nan : It.number;
        case "boolean":
            return It.boolean;
        case "function":
            return It.function;
        case "bigint":
            return It.bigint;
        case "symbol":
            return It.symbol;
        case "object":
            return Array.isArray(e) ? It.array : e === null ? It.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? It.promise : typeof Map < "u" && e instanceof Map ? It.map : typeof Set < "u" && e instanceof Set ? It.set : typeof Date < "u" && e instanceof Date ? It.date : It.object;
        default:
            return It.unknown;
    }
}, bt = $r.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]), ime = (e)=>JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let ss = class extends Error {
    constructor(e){
        super(), this.issues = [], this.addIssue = (r)=>{
            this.issues = [
                ...this.issues,
                r
            ];
        }, this.addIssues = (r = [])=>{
            this.issues = [
                ...this.issues,
                ...r
            ];
        };
        const t = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
    }
    get errors() {
        return this.issues;
    }
    format(e) {
        const t = e || function(i1) {
            return i1.message;
        }, r = {
            _errors: []
        }, n = (i1)=>{
            for (const o of i1.issues)if (o.code === "invalid_union") o.unionErrors.map(n);
            else if (o.code === "invalid_return_type") n(o.returnTypeError);
            else if (o.code === "invalid_arguments") n(o.argumentsError);
            else if (o.path.length === 0) r._errors.push(t(o));
            else {
                let a = r, s = 0;
                for(; s < o.path.length;){
                    const c = o.path[s];
                    s === o.path.length - 1 ? (a[c] = a[c] || {
                        _errors: []
                    }, a[c]._errors.push(t(o))) : a[c] = a[c] || {
                        _errors: []
                    }, a = a[c], s++;
                }
            }
        };
        return n(this), r;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, $r.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(e = (t)=>t.message) {
        const t = {}, r = [];
        for (const n of this.issues)n.path.length > 0 ? (t[n.path[0]] = t[n.path[0]] || [], t[n.path[0]].push(e(n))) : r.push(e(n));
        return {
            formErrors: r,
            fieldErrors: t
        };
    }
    get formErrors() {
        return this.flatten();
    }
};
ss.create = (e)=>new ss(e);
const I0 = (e, t)=>{
    let r;
    switch(e.code){
        case bt.invalid_type:
            e.received === It.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
            break;
        case bt.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(e.expected, $r.jsonStringifyReplacer)}`;
            break;
        case bt.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${$r.joinValues(e.keys, ", ")}`;
            break;
        case bt.invalid_union:
            r = "Invalid input";
            break;
        case bt.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${$r.joinValues(e.options)}`;
            break;
        case bt.invalid_enum_value:
            r = `Invalid enum value. Expected ${$r.joinValues(e.options)}, received '${e.received}'`;
            break;
        case bt.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case bt.invalid_return_type:
            r = "Invalid function return type";
            break;
        case bt.invalid_date:
            r = "Invalid date";
            break;
        case bt.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : $r.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
            break;
        case bt.too_small:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
            break;
        case bt.too_big:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
            break;
        case bt.custom:
            r = "Invalid input";
            break;
        case bt.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case bt.not_multiple_of:
            r = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case bt.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = t.defaultError, $r.assertNever(e);
    }
    return {
        message: r
    };
};
let LD = I0;
function ome(e) {
    LD = e;
}
function e2() {
    return LD;
}
const t2 = (e)=>{
    const { data: t, path: r, errorMaps: n, issueData: i1 } = e, o = [
        ...r,
        ...i1.path || []
    ], a = {
        ...i1,
        path: o
    };
    let s = "";
    const c = n.filter((l)=>!!l).slice().reverse();
    for (const l of c)s = l(a, {
        data: t,
        defaultError: s
    }).message;
    return {
        ...i1,
        path: o,
        message: i1.message || s
    };
}, ame = [];
function Mt(e, t) {
    const r = t2({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            e2(),
            I0
        ].filter((n)=>!!n)
    });
    e.common.issues.push(r);
}
let Mo = class HD {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
        const n = [];
        for (const i1 of r){
            if (i1.status === "aborted") return gr;
            i1.status === "dirty" && t.dirty(), n.push(i1.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const i1 of r)n.push({
            key: await i1.key,
            value: await i1.value
        });
        return HD.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const i1 of r){
            const { key: o, value: a } = i1;
            if (o.status === "aborted" || a.status === "aborted") return gr;
            o.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), (typeof a.value < "u" || i1.alwaysSet) && (n[o.value] = a.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
};
const gr = Object.freeze({
    status: "aborted"
}), KD = (e)=>({
        status: "dirty",
        value: e
    }), ao = (e)=>({
        status: "valid",
        value: e
    }), C4 = (e)=>e.status === "aborted", M4 = (e)=>e.status === "dirty", r2 = (e)=>e.status === "valid", n2 = (e)=>typeof Promise < "u" && e instanceof Promise;
var qt;
(function(e) {
    e.errToObj = (t)=>typeof t == "string" ? {
            message: t
        } : t || {}, e.toString = (t)=>typeof t == "string" ? t : t == null ? void 0 : t.message;
})(qt || (qt = {}));
let Qs = class {
    constructor(e, t, r, n){
        this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = n;
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
};
const QI = (e, t)=>{
    if (r2(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const r = new ss(e.common.issues);
            return this._error = r, this._error;
        }
    };
};
function Sr(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: r, required_error: n, description: i1 } = e;
    if (t && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i1
    } : {
        errorMap: (o, a)=>o.code !== "invalid_type" ? {
                message: a.defaultError
            } : typeof a.data > "u" ? {
                message: n ?? a.defaultError
            } : {
                message: r ?? a.defaultError
            },
        description: i1
    };
}
let Mr = class {
    constructor(e){
        this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(e) {
        return Nc(e.data);
    }
    _getOrReturnCtx(e, t) {
        return t || {
            common: e.parent.common,
            data: e.data,
            parsedType: Nc(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        };
    }
    _processInputParams(e) {
        return {
            status: new Mo(),
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: Nc(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        };
    }
    _parseSync(e) {
        const t = this._parse(e);
        if (n2(t)) throw new Error("Synchronous parse encountered promise.");
        return t;
    }
    _parseAsync(e) {
        const t = this._parse(e);
        return Promise.resolve(t);
    }
    parse(e, t) {
        const r = this.safeParse(e, t);
        if (r.success) return r.data;
        throw r.error;
    }
    safeParse(e, t) {
        var r;
        const n = {
            common: {
                issues: [],
                async: (r = t == null ? void 0 : t.async) !== null && r !== void 0 ? r : !1,
                contextualErrorMap: t == null ? void 0 : t.errorMap
            },
            path: (t == null ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Nc(e)
        }, i1 = this._parseSync({
            data: e,
            path: n.path,
            parent: n
        });
        return QI(n, i1);
    }
    async parseAsync(e, t) {
        const r = await this.safeParseAsync(e, t);
        if (r.success) return r.data;
        throw r.error;
    }
    async safeParseAsync(e, t) {
        const r = {
            common: {
                issues: [],
                contextualErrorMap: t == null ? void 0 : t.errorMap,
                async: !0
            },
            path: (t == null ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Nc(e)
        }, n = this._parse({
            data: e,
            path: r.path,
            parent: r
        }), i1 = await (n2(n) ? n : Promise.resolve(n));
        return QI(r, i1);
    }
    refine(e, t) {
        const r = (n)=>typeof t == "string" || typeof t > "u" ? {
                message: t
            } : typeof t == "function" ? t(n) : t;
        return this._refinement((n, i1)=>{
            const o = e(n), a = ()=>i1.addIssue({
                    code: bt.custom,
                    ...r(n)
                });
            return typeof Promise < "u" && o instanceof Promise ? o.then((s)=>s ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
        });
    }
    refinement(e, t) {
        return this._refinement((r, n)=>e(r) ? !0 : (n.addIssue(typeof t == "function" ? t(r, n) : t), !1));
    }
    _refinement(e) {
        return new ls({
            schema: this,
            typeName: rr.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        });
    }
    superRefine(e) {
        return this._refinement(e);
    }
    optional() {
        return Mu.create(this, this._def);
    }
    nullable() {
        return Sf.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return Ef.create(this, this._def);
    }
    promise() {
        return xh.create(this, this._def);
    }
    or(e) {
        return R0.create([
            this,
            e
        ], this._def);
    }
    and(e) {
        return U0.create(this, e, this._def);
    }
    transform(e) {
        return new ls({
            ...Sr(this._def),
            schema: this,
            typeName: rr.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        });
    }
    default(e) {
        const t = typeof e == "function" ? e : ()=>e;
        return new z0({
            ...Sr(this._def),
            innerType: this,
            defaultValue: t,
            typeName: rr.ZodDefault
        });
    }
    brand() {
        return new XD({
            typeName: rr.ZodBranded,
            type: this,
            ...Sr(this._def)
        });
    }
    catch(e) {
        const t = typeof e == "function" ? e : ()=>e;
        return new u2({
            ...Sr(this._def),
            innerType: this,
            catchValue: t,
            typeName: rr.ZodCatch
        });
    }
    describe(e) {
        const t = this.constructor;
        return new t({
            ...this._def,
            description: e
        });
    }
    pipe(e) {
        return m7.create(this, e);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
};
const sme = /^c[^\s-]{8,}$/i, ume = /^[a-z][a-z0-9]*$/, cme = /[0-9A-HJKMNP-TV-Z]{26}/, lme = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, fme = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, dme = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), hme = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, pme = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, gme = (e)=>e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function yme(e, t) {
    return !!((t === "v4" || !t) && hme.test(e) || (t === "v6" || !t) && pme.test(e));
}
let Eh = class Fp extends Mr {
    constructor(){
        super(...arguments), this._regex = (t, r, n)=>this.refinement((i1)=>t.test(i1), {
                validation: r,
                code: bt.invalid_string,
                ...qt.errToObj(n)
            }), this.nonempty = (t)=>this.min(1, qt.errToObj(t)), this.trim = ()=>new Fp({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "trim"
                    }
                ]
            }), this.toLowerCase = ()=>new Fp({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toLowerCase"
                    }
                ]
            }), this.toUpperCase = ()=>new Fp({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toUpperCase"
                    }
                ]
            });
    }
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== It.string) {
            const i1 = this._getOrReturnCtx(t);
            return Mt(i1, {
                code: bt.invalid_type,
                expected: It.string,
                received: i1.parsedType
            }), gr;
        }
        const r = new Mo();
        let n;
        for (const i1 of this._def.checks)if (i1.kind === "min") t.data.length < i1.value && (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.too_small,
            minimum: i1.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "max") t.data.length > i1.value && (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.too_big,
            maximum: i1.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "length") {
            const o = t.data.length > i1.value, a = t.data.length < i1.value;
            (o || a) && (n = this._getOrReturnCtx(t, n), o ? Mt(n, {
                code: bt.too_big,
                maximum: i1.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i1.message
            }) : a && Mt(n, {
                code: bt.too_small,
                minimum: i1.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i1.message
            }), r.dirty());
        } else if (i1.kind === "email") fme.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "email",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "emoji") dme.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "emoji",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "uuid") lme.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "uuid",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "cuid") sme.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "cuid",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "cuid2") ume.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "cuid2",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "ulid") cme.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "ulid",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "url") try {
            new URL(t.data);
        } catch  {
            n = this._getOrReturnCtx(t, n), Mt(n, {
                validation: "url",
                code: bt.invalid_string,
                message: i1.message
            }), r.dirty();
        }
        else i1.kind === "regex" ? (i1.regex.lastIndex = 0, i1.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "regex",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty())) : i1.kind === "trim" ? t.data = t.data.trim() : i1.kind === "includes" ? t.data.includes(i1.value, i1.position) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.invalid_string,
            validation: {
                includes: i1.value,
                position: i1.position
            },
            message: i1.message
        }), r.dirty()) : i1.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i1.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i1.kind === "startsWith" ? t.data.startsWith(i1.value) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.invalid_string,
            validation: {
                startsWith: i1.value
            },
            message: i1.message
        }), r.dirty()) : i1.kind === "endsWith" ? t.data.endsWith(i1.value) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.invalid_string,
            validation: {
                endsWith: i1.value
            },
            message: i1.message
        }), r.dirty()) : i1.kind === "datetime" ? gme(i1).test(t.data) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.invalid_string,
            validation: "datetime",
            message: i1.message
        }), r.dirty()) : i1.kind === "ip" ? yme(t.data, i1.version) || (n = this._getOrReturnCtx(t, n), Mt(n, {
            validation: "ip",
            code: bt.invalid_string,
            message: i1.message
        }), r.dirty()) : $r.assertNever(i1);
        return {
            status: r.value,
            value: t.data
        };
    }
    _addCheck(t) {
        return new Fp({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...qt.errToObj(t)
        });
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...qt.errToObj(t)
        });
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...qt.errToObj(t)
        });
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...qt.errToObj(t)
        });
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...qt.errToObj(t)
        });
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...qt.errToObj(t)
        });
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...qt.errToObj(t)
        });
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...qt.errToObj(t)
        });
    }
    datetime(t) {
        var r;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            ...qt.errToObj(t == null ? void 0 : t.message)
        });
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...qt.errToObj(r)
        });
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...qt.errToObj(r == null ? void 0 : r.message)
        });
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...qt.errToObj(r)
        });
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...qt.errToObj(r)
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...qt.errToObj(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...qt.errToObj(r)
        });
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...qt.errToObj(r)
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((t)=>t.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((t)=>t.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((t)=>t.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((t)=>t.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((t)=>t.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((t)=>t.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((t)=>t.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((t)=>t.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((t)=>t.kind === "ip");
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
};
Eh.create = (e)=>{
    var t;
    return new Eh({
        checks: [],
        typeName: rr.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...Sr(e)
    });
};
function mme(e, t) {
    const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i1 = r > n ? r : n, o = parseInt(e.toFixed(i1).replace(".", "")), a = parseInt(t.toFixed(i1).replace(".", ""));
    return o % a / Math.pow(10, i1);
}
let B0 = class N4 extends Mr {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== It.number) {
            const i1 = this._getOrReturnCtx(t);
            return Mt(i1, {
                code: bt.invalid_type,
                expected: It.number,
                received: i1.parsedType
            }), gr;
        }
        let r;
        const n = new Mo();
        for (const i1 of this._def.checks)i1.kind === "int" ? $r.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.invalid_type,
            expected: "integer",
            received: "float",
            message: i1.message
        }), n.dirty()) : i1.kind === "min" ? (i1.inclusive ? t.data < i1.value : t.data <= i1.value) && (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.too_small,
            minimum: i1.value,
            type: "number",
            inclusive: i1.inclusive,
            exact: !1,
            message: i1.message
        }), n.dirty()) : i1.kind === "max" ? (i1.inclusive ? t.data > i1.value : t.data >= i1.value) && (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.too_big,
            maximum: i1.value,
            type: "number",
            inclusive: i1.inclusive,
            exact: !1,
            message: i1.message
        }), n.dirty()) : i1.kind === "multipleOf" ? mme(t.data, i1.value) !== 0 && (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.not_multiple_of,
            multipleOf: i1.value,
            message: i1.message
        }), n.dirty()) : i1.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.not_finite,
            message: i1.message
        }), n.dirty()) : $r.assertNever(i1);
        return {
            status: n.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, qt.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, qt.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, qt.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, qt.toString(r));
    }
    setLimit(t, r, n, i1) {
        return new N4({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: qt.toString(i1)
                }
            ]
        });
    }
    _addCheck(t) {
        return new N4({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: qt.toString(t)
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: qt.toString(r)
        });
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: qt.toString(t)
        });
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: qt.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: qt.toString(t)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
    get isInt() {
        return !!this._def.checks.find((t)=>t.kind === "int" || t.kind === "multipleOf" && $r.isInteger(t.value));
    }
    get isFinite() {
        let t = null, r = null;
        for (const n of this._def.checks){
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        }
        return Number.isFinite(r) && Number.isFinite(t);
    }
};
B0.create = (e)=>new B0({
        checks: [],
        typeName: rr.ZodNumber,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...Sr(e)
    });
let T0 = class R4 extends Mr {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== It.bigint) {
            const i1 = this._getOrReturnCtx(t);
            return Mt(i1, {
                code: bt.invalid_type,
                expected: It.bigint,
                received: i1.parsedType
            }), gr;
        }
        let r;
        const n = new Mo();
        for (const i1 of this._def.checks)i1.kind === "min" ? (i1.inclusive ? t.data < i1.value : t.data <= i1.value) && (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.too_small,
            type: "bigint",
            minimum: i1.value,
            inclusive: i1.inclusive,
            message: i1.message
        }), n.dirty()) : i1.kind === "max" ? (i1.inclusive ? t.data > i1.value : t.data >= i1.value) && (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.too_big,
            type: "bigint",
            maximum: i1.value,
            inclusive: i1.inclusive,
            message: i1.message
        }), n.dirty()) : i1.kind === "multipleOf" ? t.data % i1.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Mt(r, {
            code: bt.not_multiple_of,
            multipleOf: i1.value,
            message: i1.message
        }), n.dirty()) : $r.assertNever(i1);
        return {
            status: n.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, qt.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, qt.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, qt.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, qt.toString(r));
    }
    setLimit(t, r, n, i1) {
        return new R4({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: qt.toString(i1)
                }
            ]
        });
    }
    _addCheck(t) {
        return new R4({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: qt.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: qt.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: qt.toString(r)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
};
T0.create = (e)=>{
    var t;
    return new T0({
        checks: [],
        typeName: rr.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...Sr(e)
    });
};
let P0 = class extends Mr {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== It.boolean) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                code: bt.invalid_type,
                expected: It.boolean,
                received: t.parsedType
            }), gr;
        }
        return ao(e.data);
    }
};
P0.create = (e)=>new P0({
        typeName: rr.ZodBoolean,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...Sr(e)
    });
let C0 = class qD extends Mr {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== It.date) {
            const i1 = this._getOrReturnCtx(t);
            return Mt(i1, {
                code: bt.invalid_type,
                expected: It.date,
                received: i1.parsedType
            }), gr;
        }
        if (isNaN(t.data.getTime())) {
            const i1 = this._getOrReturnCtx(t);
            return Mt(i1, {
                code: bt.invalid_date
            }), gr;
        }
        const r = new Mo();
        let n;
        for (const i1 of this._def.checks)i1.kind === "min" ? t.data.getTime() < i1.value && (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.too_small,
            message: i1.message,
            inclusive: !0,
            exact: !1,
            minimum: i1.value,
            type: "date"
        }), r.dirty()) : i1.kind === "max" ? t.data.getTime() > i1.value && (n = this._getOrReturnCtx(t, n), Mt(n, {
            code: bt.too_big,
            message: i1.message,
            inclusive: !0,
            exact: !1,
            maximum: i1.value,
            type: "date"
        }), r.dirty()) : $r.assertNever(i1);
        return {
            status: r.value,
            value: new Date(t.data.getTime())
        };
    }
    _addCheck(t) {
        return new qD({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: qt.toString(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: qt.toString(r)
        });
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
};
C0.create = (e)=>new C0({
        checks: [],
        coerce: (e == null ? void 0 : e.coerce) || !1,
        typeName: rr.ZodDate,
        ...Sr(e)
    });
let i2 = class extends Mr {
    _parse(e) {
        if (this._getType(e) !== It.symbol) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                code: bt.invalid_type,
                expected: It.symbol,
                received: t.parsedType
            }), gr;
        }
        return ao(e.data);
    }
};
i2.create = (e)=>new i2({
        typeName: rr.ZodSymbol,
        ...Sr(e)
    });
let M0 = class extends Mr {
    _parse(e) {
        if (this._getType(e) !== It.undefined) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                code: bt.invalid_type,
                expected: It.undefined,
                received: t.parsedType
            }), gr;
        }
        return ao(e.data);
    }
};
M0.create = (e)=>new M0({
        typeName: rr.ZodUndefined,
        ...Sr(e)
    });
let N0 = class extends Mr {
    _parse(e) {
        if (this._getType(e) !== It.null) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                code: bt.invalid_type,
                expected: It.null,
                received: t.parsedType
            }), gr;
        }
        return ao(e.data);
    }
};
N0.create = (e)=>new N0({
        typeName: rr.ZodNull,
        ...Sr(e)
    });
let Sh = class extends Mr {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(e) {
        return ao(e.data);
    }
};
Sh.create = (e)=>new Sh({
        typeName: rr.ZodAny,
        ...Sr(e)
    });
let hf = class extends Mr {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(e) {
        return ao(e.data);
    }
};
hf.create = (e)=>new hf({
        typeName: rr.ZodUnknown,
        ...Sr(e)
    });
let ju = class extends Mr {
    _parse(e) {
        const t = this._getOrReturnCtx(e);
        return Mt(t, {
            code: bt.invalid_type,
            expected: It.never,
            received: t.parsedType
        }), gr;
    }
};
ju.create = (e)=>new ju({
        typeName: rr.ZodNever,
        ...Sr(e)
    });
let o2 = class extends Mr {
    _parse(e) {
        if (this._getType(e) !== It.undefined) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                code: bt.invalid_type,
                expected: It.void,
                received: t.parsedType
            }), gr;
        }
        return ao(e.data);
    }
};
o2.create = (e)=>new o2({
        typeName: rr.ZodVoid,
        ...Sr(e)
    });
let Ef = class Yy extends Mr {
    _parse(t) {
        const { ctx: r, status: n } = this._processInputParams(t), i1 = this._def;
        if (r.parsedType !== It.array) return Mt(r, {
            code: bt.invalid_type,
            expected: It.array,
            received: r.parsedType
        }), gr;
        if (i1.exactLength !== null) {
            const a = r.data.length > i1.exactLength.value, s = r.data.length < i1.exactLength.value;
            (a || s) && (Mt(r, {
                code: a ? bt.too_big : bt.too_small,
                minimum: s ? i1.exactLength.value : void 0,
                maximum: a ? i1.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i1.exactLength.message
            }), n.dirty());
        }
        if (i1.minLength !== null && r.data.length < i1.minLength.value && (Mt(r, {
            code: bt.too_small,
            minimum: i1.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i1.minLength.message
        }), n.dirty()), i1.maxLength !== null && r.data.length > i1.maxLength.value && (Mt(r, {
            code: bt.too_big,
            maximum: i1.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i1.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([
            ...r.data
        ].map((a, s)=>i1.type._parseAsync(new Qs(r, a, r.path, s)))).then((a)=>Mo.mergeArray(n, a));
        const o = [
            ...r.data
        ].map((a, s)=>i1.type._parseSync(new Qs(r, a, r.path, s)));
        return Mo.mergeArray(n, o);
    }
    get element() {
        return this._def.type;
    }
    min(t, r) {
        return new Yy({
            ...this._def,
            minLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    max(t, r) {
        return new Yy({
            ...this._def,
            maxLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    length(t, r) {
        return new Yy({
            ...this._def,
            exactLength: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    nonempty(t) {
        return this.min(1, t);
    }
};
Ef.create = (e, t)=>new Ef({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: rr.ZodArray,
        ...Sr(t)
    });
function Id(e) {
    if (e instanceof Na) {
        const t = {};
        for(const r in e.shape){
            const n = e.shape[r];
            t[r] = Mu.create(Id(n));
        }
        return new Na({
            ...e._def,
            shape: ()=>t
        });
    } else return e instanceof Ef ? new Ef({
        ...e._def,
        type: Id(e.element)
    }) : e instanceof Mu ? Mu.create(Id(e.unwrap())) : e instanceof Sf ? Sf.create(Id(e.unwrap())) : e instanceof tl ? tl.create(e.items.map((t)=>Id(t))) : e;
}
let Na = class Ga extends Mr {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(), r = $r.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        };
    }
    _parse(t) {
        if (this._getType(t) !== It.object) {
            const c = this._getOrReturnCtx(t);
            return Mt(c, {
                code: bt.invalid_type,
                expected: It.object,
                received: c.parsedType
            }), gr;
        }
        const { status: r, ctx: n } = this._processInputParams(t), { shape: i1, keys: o } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof ju && this._def.unknownKeys === "strip")) for(const c in n.data)o.includes(c) || a.push(c);
        const s = [];
        for (const c of o){
            const l = i1[c], u = n.data[c];
            s.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: l._parse(new Qs(n, u, n.path, c)),
                alwaysSet: c in n.data
            });
        }
        if (this._def.catchall instanceof ju) {
            const c = this._def.unknownKeys;
            if (c === "passthrough") for (const l of a)s.push({
                key: {
                    status: "valid",
                    value: l
                },
                value: {
                    status: "valid",
                    value: n.data[l]
                }
            });
            else if (c === "strict") a.length > 0 && (Mt(n, {
                code: bt.unrecognized_keys,
                keys: a
            }), r.dirty());
            else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const c = this._def.catchall;
            for (const l of a){
                const u = n.data[l];
                s.push({
                    key: {
                        status: "valid",
                        value: l
                    },
                    value: c._parse(new Qs(n, u, n.path, l)),
                    alwaysSet: l in n.data
                });
            }
        }
        return n.common.async ? Promise.resolve().then(async ()=>{
            const c = [];
            for (const l of s){
                const u = await l.key;
                c.push({
                    key: u,
                    value: await l.value,
                    alwaysSet: l.alwaysSet
                });
            }
            return c;
        }).then((c)=>Mo.mergeObjectSync(r, c)) : Mo.mergeObjectSync(r, s);
    }
    get shape() {
        return this._def.shape();
    }
    strict(t) {
        return new Ga({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n)=>{
                    var i1, o, a, s;
                    const c = (a = (o = (i1 = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i1, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (s = qt.errToObj(t).message) !== null && s !== void 0 ? s : c
                    } : {
                        message: c
                    };
                }
            } : {}
        });
    }
    strip() {
        return new Ga({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new Ga({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
        return new Ga({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(t) {
        return new Ga({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
            typeName: rr.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
        return this.augment({
            [t]: r
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
        return new Ga({
            ...this._def,
            catchall: t
        });
    }
    pick(t) {
        const r = {};
        return $r.objectKeys(t).forEach((n)=>{
            t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }), new Ga({
            ...this._def,
            shape: ()=>r
        });
    }
    omit(t) {
        const r = {};
        return $r.objectKeys(this.shape).forEach((n)=>{
            t[n] || (r[n] = this.shape[n]);
        }), new Ga({
            ...this._def,
            shape: ()=>r
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return Id(this);
    }
    partial(t) {
        const r = {};
        return $r.objectKeys(this.shape).forEach((n)=>{
            const i1 = this.shape[n];
            t && !t[n] ? r[n] = i1 : r[n] = i1.optional();
        }), new Ga({
            ...this._def,
            shape: ()=>r
        });
    }
    required(t) {
        const r = {};
        return $r.objectKeys(this.shape).forEach((n)=>{
            if (t && !t[n]) r[n] = this.shape[n];
            else {
                let i1 = this.shape[n];
                for(; i1 instanceof Mu;)i1 = i1._def.innerType;
                r[n] = i1;
            }
        }), new Ga({
            ...this._def,
            shape: ()=>r
        });
    }
    keyof() {
        return ZD($r.objectKeys(this.shape));
    }
};
Na.create = (e, t)=>new Na({
        shape: ()=>e,
        unknownKeys: "strip",
        catchall: ju.create(),
        typeName: rr.ZodObject,
        ...Sr(t)
    });
Na.strictCreate = (e, t)=>new Na({
        shape: ()=>e,
        unknownKeys: "strict",
        catchall: ju.create(),
        typeName: rr.ZodObject,
        ...Sr(t)
    });
Na.lazycreate = (e, t)=>new Na({
        shape: e,
        unknownKeys: "strip",
        catchall: ju.create(),
        typeName: rr.ZodObject,
        ...Sr(t)
    });
let R0 = class extends Mr {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e), r = this._def.options;
        function n(i1) {
            for (const a of i1)if (a.result.status === "valid") return a.result;
            for (const a of i1)if (a.result.status === "dirty") return t.common.issues.push(...a.ctx.common.issues), a.result;
            const o = i1.map((a)=>new ss(a.ctx.common.issues));
            return Mt(t, {
                code: bt.invalid_union,
                unionErrors: o
            }), gr;
        }
        if (t.common.async) return Promise.all(r.map(async (i1)=>{
            const o = {
                ...t,
                common: {
                    ...t.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await i1._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: o
                }),
                ctx: o
            };
        })).then(n);
        {
            let i1;
            const o = [];
            for (const s of r){
                const c = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                }, l = s._parseSync({
                    data: t.data,
                    path: t.path,
                    parent: c
                });
                if (l.status === "valid") return l;
                l.status === "dirty" && !i1 && (i1 = {
                    result: l,
                    ctx: c
                }), c.common.issues.length && o.push(c.common.issues);
            }
            if (i1) return t.common.issues.push(...i1.ctx.common.issues), i1.result;
            const a = o.map((s)=>new ss(s));
            return Mt(t, {
                code: bt.invalid_union,
                unionErrors: a
            }), gr;
        }
    }
    get options() {
        return this._def.options;
    }
};
R0.create = (e, t)=>new R0({
        options: e,
        typeName: rr.ZodUnion,
        ...Sr(t)
    });
const Jy = (e)=>e instanceof D0 ? Jy(e.schema) : e instanceof ls ? Jy(e.innerType()) : e instanceof j0 ? [
        e.value
    ] : e instanceof L1 ? e.options : e instanceof F0 ? Object.keys(e.enum) : e instanceof z0 ? Jy(e._def.innerType) : e instanceof M0 ? [
        void 0
    ] : e instanceof N0 ? [
        null
    ] : null;
let VD = class WD extends Mr {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== It.object) return Mt(r, {
            code: bt.invalid_type,
            expected: It.object,
            received: r.parsedType
        }), gr;
        const n = this.discriminator, i1 = r.data[n], o = this.optionsMap.get(i1);
        return o ? r.common.async ? o._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : o._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (Mt(r, {
            code: bt.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                n
            ]
        }), gr);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(t, r, n) {
        const i1 = /* @__PURE__ */ new Map();
        for (const o of r){
            const a = Jy(o.shape[t]);
            if (!a) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const s of a){
                if (i1.has(s)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
                i1.set(s, o);
            }
        }
        return new WD({
            typeName: rr.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: i1,
            ...Sr(n)
        });
    }
};
function U4(e, t) {
    const r = Nc(e), n = Nc(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (r === It.object && n === It.object) {
        const i1 = $r.objectKeys(t), o = $r.objectKeys(e).filter((s)=>i1.indexOf(s) !== -1), a = {
            ...e,
            ...t
        };
        for (const s of o){
            const c = U4(e[s], t[s]);
            if (!c.valid) return {
                valid: !1
            };
            a[s] = c.data;
        }
        return {
            valid: !0,
            data: a
        };
    } else if (r === It.array && n === It.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i1 = [];
        for(let o = 0; o < e.length; o++){
            const a = e[o], s = t[o], c = U4(a, s);
            if (!c.valid) return {
                valid: !1
            };
            i1.push(c.data);
        }
        return {
            valid: !0,
            data: i1
        };
    } else return r === It.date && n === It.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    };
}
let U0 = class extends Mr {
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e), n = (i1, o)=>{
            if (C4(i1) || C4(o)) return gr;
            const a = U4(i1.value, o.value);
            return a.valid ? ((M4(i1) || M4(o)) && t.dirty(), {
                status: t.value,
                value: a.data
            }) : (Mt(r, {
                code: bt.invalid_intersection_types
            }), gr);
        };
        return r.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }),
            this._def.right._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            })
        ]).then(([i1, o])=>n(i1, o)) : n(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }));
    }
};
U0.create = (e, t, r)=>new U0({
        left: e,
        right: t,
        typeName: rr.ZodIntersection,
        ...Sr(r)
    });
let tl = class GD extends Mr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== It.array) return Mt(n, {
            code: bt.invalid_type,
            expected: It.array,
            received: n.parsedType
        }), gr;
        if (n.data.length < this._def.items.length) return Mt(n, {
            code: bt.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), gr;
        !this._def.rest && n.data.length > this._def.items.length && (Mt(n, {
            code: bt.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const i1 = [
            ...n.data
        ].map((o, a)=>{
            const s = this._def.items[a] || this._def.rest;
            return s ? s._parse(new Qs(n, o, n.path, a)) : null;
        }).filter((o)=>!!o);
        return n.common.async ? Promise.all(i1).then((o)=>Mo.mergeArray(r, o)) : Mo.mergeArray(r, i1);
    }
    get items() {
        return this._def.items;
    }
    rest(t) {
        return new GD({
            ...this._def,
            rest: t
        });
    }
};
tl.create = (e, t)=>{
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new tl({
        items: e,
        typeName: rr.ZodTuple,
        rest: null,
        ...Sr(t)
    });
};
let QD = class D4 extends Mr {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== It.object) return Mt(n, {
            code: bt.invalid_type,
            expected: It.object,
            received: n.parsedType
        }), gr;
        const i1 = [], o = this._def.keyType, a = this._def.valueType;
        for(const s in n.data)i1.push({
            key: o._parse(new Qs(n, s, n.path, s)),
            value: a._parse(new Qs(n, n.data[s], n.path, s))
        });
        return n.common.async ? Mo.mergeObjectAsync(r, i1) : Mo.mergeObjectSync(r, i1);
    }
    get element() {
        return this._def.valueType;
    }
    static create(t, r, n) {
        return r instanceof Mr ? new D4({
            keyType: t,
            valueType: r,
            typeName: rr.ZodRecord,
            ...Sr(n)
        }) : new D4({
            keyType: Eh.create(),
            valueType: t,
            typeName: rr.ZodRecord,
            ...Sr(r)
        });
    }
}, a2 = class extends Mr {
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== It.map) return Mt(r, {
            code: bt.invalid_type,
            expected: It.map,
            received: r.parsedType
        }), gr;
        const n = this._def.keyType, i1 = this._def.valueType, o = [
            ...r.data.entries()
        ].map(([a, s], c)=>({
                key: n._parse(new Qs(r, a, r.path, [
                    c,
                    "key"
                ])),
                value: i1._parse(new Qs(r, s, r.path, [
                    c,
                    "value"
                ]))
            }));
        if (r.common.async) {
            const a = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const s of o){
                    const c = await s.key, l = await s.value;
                    if (c.status === "aborted" || l.status === "aborted") return gr;
                    (c.status === "dirty" || l.status === "dirty") && t.dirty(), a.set(c.value, l.value);
                }
                return {
                    status: t.value,
                    value: a
                };
            });
        } else {
            const a = /* @__PURE__ */ new Map();
            for (const s of o){
                const c = s.key, l = s.value;
                if (c.status === "aborted" || l.status === "aborted") return gr;
                (c.status === "dirty" || l.status === "dirty") && t.dirty(), a.set(c.value, l.value);
            }
            return {
                status: t.value,
                value: a
            };
        }
    }
};
a2.create = (e, t, r)=>new a2({
        valueType: t,
        keyType: e,
        typeName: rr.ZodMap,
        ...Sr(r)
    });
let s2 = class j4 extends Mr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== It.set) return Mt(n, {
            code: bt.invalid_type,
            expected: It.set,
            received: n.parsedType
        }), gr;
        const i1 = this._def;
        i1.minSize !== null && n.data.size < i1.minSize.value && (Mt(n, {
            code: bt.too_small,
            minimum: i1.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i1.minSize.message
        }), r.dirty()), i1.maxSize !== null && n.data.size > i1.maxSize.value && (Mt(n, {
            code: bt.too_big,
            maximum: i1.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i1.maxSize.message
        }), r.dirty());
        const o = this._def.valueType;
        function a(c) {
            const l = /* @__PURE__ */ new Set();
            for (const u of c){
                if (u.status === "aborted") return gr;
                u.status === "dirty" && r.dirty(), l.add(u.value);
            }
            return {
                status: r.value,
                value: l
            };
        }
        const s = [
            ...n.data.values()
        ].map((c, l)=>o._parse(new Qs(n, c, n.path, l)));
        return n.common.async ? Promise.all(s).then((c)=>a(c)) : a(s);
    }
    min(t, r) {
        return new j4({
            ...this._def,
            minSize: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    max(t, r) {
        return new j4({
            ...this._def,
            maxSize: {
                value: t,
                message: qt.toString(r)
            }
        });
    }
    size(t, r) {
        return this.min(t, r).max(t, r);
    }
    nonempty(t) {
        return this.min(1, t);
    }
};
s2.create = (e, t)=>new s2({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: rr.ZodSet,
        ...Sr(t)
    });
let $D = class em extends Mr {
    constructor(){
        super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== It.function) return Mt(r, {
            code: bt.invalid_type,
            expected: It.function,
            received: r.parsedType
        }), gr;
        function n(s, c) {
            return t2({
                data: s,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    e2(),
                    I0
                ].filter((l)=>!!l),
                issueData: {
                    code: bt.invalid_arguments,
                    argumentsError: c
                }
            });
        }
        function i1(s, c) {
            return t2({
                data: s,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    e2(),
                    I0
                ].filter((l)=>!!l),
                issueData: {
                    code: bt.invalid_return_type,
                    returnTypeError: c
                }
            });
        }
        const o = {
            errorMap: r.common.contextualErrorMap
        }, a = r.data;
        return this._def.returns instanceof xh ? ao(async (...s)=>{
            const c = new ss([]), l = await this._def.args.parseAsync(s, o).catch((f)=>{
                throw c.addIssue(n(s, f)), c;
            }), u = await a(...l);
            return await this._def.returns._def.type.parseAsync(u, o).catch((f)=>{
                throw c.addIssue(i1(u, f)), c;
            });
        }) : ao((...s)=>{
            const c = this._def.args.safeParse(s, o);
            if (!c.success) throw new ss([
                n(s, c.error)
            ]);
            const l = a(...c.data), u = this._def.returns.safeParse(l, o);
            if (!u.success) throw new ss([
                i1(l, u.error)
            ]);
            return u.data;
        });
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...t) {
        return new em({
            ...this._def,
            args: tl.create(t).rest(hf.create())
        });
    }
    returns(t) {
        return new em({
            ...this._def,
            returns: t
        });
    }
    implement(t) {
        return this.parse(t);
    }
    strictImplement(t) {
        return this.parse(t);
    }
    static create(t, r, n) {
        return new em({
            args: t || tl.create([]).rest(hf.create()),
            returns: r || hf.create(),
            typeName: rr.ZodFunction,
            ...Sr(n)
        });
    }
}, D0 = class extends Mr {
    get schema() {
        return this._def.getter();
    }
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        return this._def.getter()._parse({
            data: t.data,
            path: t.path,
            parent: t
        });
    }
};
D0.create = (e, t)=>new D0({
        getter: e,
        typeName: rr.ZodLazy,
        ...Sr(t)
    });
let j0 = class extends Mr {
    _parse(e) {
        if (e.data !== this._def.value) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                received: t.data,
                code: bt.invalid_literal,
                expected: this._def.value
            }), gr;
        }
        return {
            status: "valid",
            value: e.data
        };
    }
    get value() {
        return this._def.value;
    }
};
j0.create = (e, t)=>new j0({
        value: e,
        typeName: rr.ZodLiteral,
        ...Sr(t)
    });
function ZD(e, t) {
    return new L1({
        values: e,
        typeName: rr.ZodEnum,
        ...Sr(t)
    });
}
let L1 = class F4 extends Mr {
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Mt(r, {
                expected: $r.joinValues(n),
                received: r.parsedType,
                code: bt.invalid_type
            }), gr;
        }
        if (this._def.values.indexOf(t.data) === -1) {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return Mt(r, {
                received: r.data,
                code: bt.invalid_enum_value,
                options: n
            }), gr;
        }
        return ao(t.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    extract(t) {
        return F4.create(t);
    }
    exclude(t) {
        return F4.create(this.options.filter((r)=>!t.includes(r)));
    }
};
L1.create = ZD;
let F0 = class extends Mr {
    _parse(e) {
        const t = $r.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
        if (r.parsedType !== It.string && r.parsedType !== It.number) {
            const n = $r.objectValues(t);
            return Mt(r, {
                expected: $r.joinValues(n),
                received: r.parsedType,
                code: bt.invalid_type
            }), gr;
        }
        if (t.indexOf(e.data) === -1) {
            const n = $r.objectValues(t);
            return Mt(r, {
                received: r.data,
                code: bt.invalid_enum_value,
                options: n
            }), gr;
        }
        return ao(e.data);
    }
    get enum() {
        return this._def.values;
    }
};
F0.create = (e, t)=>new F0({
        values: e,
        typeName: rr.ZodNativeEnum,
        ...Sr(t)
    });
let xh = class extends Mr {
    unwrap() {
        return this._def.type;
    }
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        if (t.parsedType !== It.promise && t.common.async === !1) return Mt(t, {
            code: bt.invalid_type,
            expected: It.promise,
            received: t.parsedType
        }), gr;
        const r = t.parsedType === It.promise ? t.data : Promise.resolve(t.data);
        return ao(r.then((n)=>this._def.type.parseAsync(n, {
                path: t.path,
                errorMap: t.common.contextualErrorMap
            })));
    }
};
xh.create = (e, t)=>new xh({
        type: e,
        typeName: rr.ZodPromise,
        ...Sr(t)
    });
let ls = class extends Mr {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === rr.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e), n = this._def.effect || null;
        if (n.type === "preprocess") {
            const o = n.transform(r.data);
            return r.common.async ? Promise.resolve(o).then((a)=>this._def.schema._parseAsync({
                    data: a,
                    path: r.path,
                    parent: r
                })) : this._def.schema._parseSync({
                data: o,
                path: r.path,
                parent: r
            });
        }
        const i1 = {
            addIssue: (o)=>{
                Mt(r, o), o.fatal ? t.abort() : t.dirty();
            },
            get path () {
                return r.path;
            }
        };
        if (i1.addIssue = i1.addIssue.bind(i1), n.type === "refinement") {
            const o = (a)=>{
                const s = n.refinement(a, i1);
                if (r.common.async) return Promise.resolve(s);
                if (s instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a;
            };
            if (r.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? gr : (a.status === "dirty" && t.dirty(), o(a.value), {
                    status: t.value,
                    value: a.value
                });
            } else return this._def.schema._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }).then((a)=>a.status === "aborted" ? gr : (a.status === "dirty" && t.dirty(), o(a.value).then(()=>({
                        status: t.value,
                        value: a.value
                    }))));
        }
        if (n.type === "transform") if (r.common.async === !1) {
            const o = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            if (!r2(o)) return o;
            const a = n.transform(o.value, i1);
            if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: t.value,
                value: a
            };
        } else return this._def.schema._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }).then((o)=>r2(o) ? Promise.resolve(n.transform(o.value, i1)).then((a)=>({
                    status: t.value,
                    value: a
                })) : o);
        $r.assertNever(n);
    }
};
ls.create = (e, t, r)=>new ls({
        schema: e,
        typeName: rr.ZodEffects,
        effect: t,
        ...Sr(r)
    });
ls.createWithPreprocess = (e, t, r)=>new ls({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: rr.ZodEffects,
        ...Sr(r)
    });
let Mu = class extends Mr {
    _parse(e) {
        return this._getType(e) === It.undefined ? ao(void 0) : this._def.innerType._parse(e);
    }
    unwrap() {
        return this._def.innerType;
    }
};
Mu.create = (e, t)=>new Mu({
        innerType: e,
        typeName: rr.ZodOptional,
        ...Sr(t)
    });
let Sf = class extends Mr {
    _parse(e) {
        return this._getType(e) === It.null ? ao(null) : this._def.innerType._parse(e);
    }
    unwrap() {
        return this._def.innerType;
    }
};
Sf.create = (e, t)=>new Sf({
        innerType: e,
        typeName: rr.ZodNullable,
        ...Sr(t)
    });
let z0 = class extends Mr {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        let r = t.data;
        return t.parsedType === It.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
            data: r,
            path: t.path,
            parent: t
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
};
z0.create = (e, t)=>new z0({
        innerType: e,
        typeName: rr.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : ()=>t.default,
        ...Sr(t)
    });
let u2 = class extends Mr {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e), r = {
            ...t,
            common: {
                ...t.common,
                issues: []
            }
        }, n = this._def.innerType._parse({
            data: r.data,
            path: r.path,
            parent: {
                ...r
            }
        });
        return n2(n) ? n.then((i1)=>({
                status: "valid",
                value: i1.status === "valid" ? i1.value : this._def.catchValue({
                    get error () {
                        return new ss(r.common.issues);
                    },
                    input: r.data
                })
            })) : {
            status: "valid",
            value: n.status === "valid" ? n.value : this._def.catchValue({
                get error () {
                    return new ss(r.common.issues);
                },
                input: r.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
};
u2.create = (e, t)=>new u2({
        innerType: e,
        typeName: rr.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : ()=>t.catch,
        ...Sr(t)
    });
let c2 = class extends Mr {
    _parse(e) {
        if (this._getType(e) !== It.nan) {
            const t = this._getOrReturnCtx(e);
            return Mt(t, {
                code: bt.invalid_type,
                expected: It.nan,
                received: t.parsedType
            }), gr;
        }
        return {
            status: "valid",
            value: e.data
        };
    }
};
c2.create = (e)=>new c2({
        typeName: rr.ZodNaN,
        ...Sr(e)
    });
const bme = Symbol("zod_brand");
let XD = class extends Mr {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e), r = t.data;
        return this._def.type._parse({
            data: r,
            path: t.path,
            parent: t
        });
    }
    unwrap() {
        return this._def.type;
    }
}, m7 = class YD extends Mr {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.common.async) return (async ()=>{
            const i1 = await this._def.in._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i1.status === "aborted" ? gr : i1.status === "dirty" ? (r.dirty(), KD(i1.value)) : this._def.out._parseAsync({
                data: i1.value,
                path: n.path,
                parent: n
            });
        })();
        {
            const i1 = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i1.status === "aborted" ? gr : i1.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i1.value
            }) : this._def.out._parseSync({
                data: i1.value,
                path: n.path,
                parent: n
            });
        }
    }
    static create(t, r) {
        return new YD({
            in: t,
            out: r,
            typeName: rr.ZodPipeline
        });
    }
};
const JD = (e, t = {}, r)=>e ? Sh.create().superRefine((n, i1)=>{
        var o, a;
        if (!e(n)) {
            const s = typeof t == "function" ? t(n) : typeof t == "string" ? {
                message: t
            } : t, c = (a = (o = s.fatal) !== null && o !== void 0 ? o : r) !== null && a !== void 0 ? a : !0, l = typeof s == "string" ? {
                message: s
            } : s;
            i1.addIssue({
                code: "custom",
                ...l,
                fatal: c
            });
        }
    }) : Sh.create(), wme = {
    object: Na.lazycreate
};
var rr;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(rr || (rr = {}));
const Ame = (e, t = {
    message: `Input not instance of ${e.name}`
})=>JD((r)=>r instanceof e, t), ej = Eh.create, tj = B0.create, vme = c2.create, Eme = T0.create, rj = P0.create, Sme = C0.create, xme = i2.create, _me = M0.create, kme = N0.create, Ome = Sh.create, Ime = hf.create, Bme = ju.create, Tme = o2.create, Pme = Ef.create, Cme = Na.create, Mme = Na.strictCreate, Nme = R0.create, Rme = VD.create, Ume = U0.create, Dme = tl.create, jme = QD.create, Fme = a2.create, zme = s2.create, Lme = $D.create, Hme = D0.create, Kme = j0.create, qme = L1.create, Vme = F0.create, Wme = xh.create, $I = ls.create, Gme = Mu.create, Qme = Sf.create, $me = ls.createWithPreprocess, Zme = m7.create, Xme = ()=>ej().optional(), Yme = ()=>tj().optional(), Jme = ()=>rj().optional(), e2e = {
    string: (e)=>Eh.create({
            ...e,
            coerce: !0
        }),
    number: (e)=>B0.create({
            ...e,
            coerce: !0
        }),
    boolean: (e)=>P0.create({
            ...e,
            coerce: !0
        }),
    bigint: (e)=>T0.create({
            ...e,
            coerce: !0
        }),
    date: (e)=>C0.create({
            ...e,
            coerce: !0
        })
}, t2e = gr;
var oo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: I0,
    setErrorMap: ome,
    getErrorMap: e2,
    makeIssue: t2,
    EMPTY_PATH: ame,
    addIssueToContext: Mt,
    ParseStatus: Mo,
    INVALID: gr,
    DIRTY: KD,
    OK: ao,
    isAborted: C4,
    isDirty: M4,
    isValid: r2,
    isAsync: n2,
    get util () {
        return $r;
    },
    get objectUtil () {
        return P4;
    },
    ZodParsedType: It,
    getParsedType: Nc,
    ZodType: Mr,
    ZodString: Eh,
    ZodNumber: B0,
    ZodBigInt: T0,
    ZodBoolean: P0,
    ZodDate: C0,
    ZodSymbol: i2,
    ZodUndefined: M0,
    ZodNull: N0,
    ZodAny: Sh,
    ZodUnknown: hf,
    ZodNever: ju,
    ZodVoid: o2,
    ZodArray: Ef,
    ZodObject: Na,
    ZodUnion: R0,
    ZodDiscriminatedUnion: VD,
    ZodIntersection: U0,
    ZodTuple: tl,
    ZodRecord: QD,
    ZodMap: a2,
    ZodSet: s2,
    ZodFunction: $D,
    ZodLazy: D0,
    ZodLiteral: j0,
    ZodEnum: L1,
    ZodNativeEnum: F0,
    ZodPromise: xh,
    ZodEffects: ls,
    ZodTransformer: ls,
    ZodOptional: Mu,
    ZodNullable: Sf,
    ZodDefault: z0,
    ZodCatch: u2,
    ZodNaN: c2,
    BRAND: bme,
    ZodBranded: XD,
    ZodPipeline: m7,
    custom: JD,
    Schema: Mr,
    ZodSchema: Mr,
    late: wme,
    get ZodFirstPartyTypeKind () {
        return rr;
    },
    coerce: e2e,
    any: Ome,
    array: Pme,
    bigint: Eme,
    boolean: rj,
    date: Sme,
    discriminatedUnion: Rme,
    effect: $I,
    enum: qme,
    function: Lme,
    instanceof: Ame,
    intersection: Ume,
    lazy: Hme,
    literal: Kme,
    map: Fme,
    nan: vme,
    nativeEnum: Vme,
    never: Bme,
    null: kme,
    nullable: Qme,
    number: tj,
    object: Cme,
    oboolean: Jme,
    onumber: Yme,
    optional: Gme,
    ostring: Xme,
    pipeline: Zme,
    preprocess: $me,
    promise: Wme,
    record: jme,
    set: zme,
    strictObject: Mme,
    string: ej,
    symbol: xme,
    transformer: $I,
    tuple: Dme,
    undefined: _me,
    union: Nme,
    unknown: Ime,
    void: Tme,
    NEVER: t2e,
    ZodIssueCode: bt,
    quotelessJson: ime,
    ZodError: ss
});
const nj = oo.string().regex(/^[a-fA-F0-9]$/), r2e = oo.string().regex(/^[a-fA-F0-9]{64}$/), _h = oo.number().min(0).max(4294967295), n2e = oo.bigint(), ij = oo.instanceof(Uint8Array), i2e = oo.union([
    nj,
    _h,
    oo.string(),
    ij
]).array(), b7 = oo.union([
    i2e,
    nj,
    ij
]), o2e = oo.array(b7), oj = oo.object({
    value: oo.union([
        _h,
        n2e
    ]),
    scriptPubKey: b7
}), a2e = oo.object({
    txid: r2e,
    vout: _h,
    scriptSig: b7,
    sequence: _h,
    prevout: oj.optional(),
    witness: o2e
});
oo.object({
    version: _h,
    vin: oo.array(a2e),
    vout: oo.array(oj),
    locktime: _h
});
w6(j2);
const aj = async ({ contentBase64: e, mimeType: t, quantity: r = 1, inscriptions: n, ordinalAddress: i1, paymentAddress: o, paymentPublicKey: a, signPsbt: s, dataSourceManager: c, opReturn: l, network: u = mn })=>{
    if (!e && !n) throw new Error("contentBase64 or inscriptions is required");
    if (!c) throw new Error("missing data source");
    if (!c.broadcastTransaction) throw new Error("missing broadcastTransaction");
    const f = await goe(u), h = Ke.from(f).toString("hex"), y = n || Array(r).fill({
        content: e,
        mimeType: t
    }), S = await s2e({
        inscriptions: y,
        paymentAddress: o,
        paymentPublicKey: a,
        privKey: h,
        dataSourceManager: c,
        network: u
    });
    if (!S || !(S != null && S.psbtHex)) throw new Error("couldn't get commit tx");
    const k = String(S == null ? void 0 : S.psbtHex), P = String(S == null ? void 0 : S.psbtBase64), M = await s({
        tx: k,
        psbtHex: k,
        psbtBase64: P,
        finalize: !0,
        broadcast: !1,
        network: u
    });
    if (!M) throw new Error("sign psbt failed");
    const N = zr.fromHex((M == null ? void 0 : M.signedPsbtHex) || "").extractTransaction(), z = await c.broadcastTransaction(N.toHex());
    if (!z) throw new Error("commit tx failed");
    return await u2e({
        inscriptions: y,
        ordinalAddress: i1,
        privKey: h,
        commitTxId: z,
        dataSourceManager: c,
        opReturn: l
    });
}, s2e = async ({ inscriptions: e, paymentAddress: t, paymentPublicKey: r, privKey: n, dataSourceManager: i1, network: o })=>{
    const a = e.length, s = e.reduce((ne, ee)=>ne + Ke.from(ee.content).length, 0);
    if (s > 39e4) throw new Error("Content size is too large, must be less than 390kb");
    if (!i1) throw new Error("missing data source");
    if (!i1.getRecommendedFees) throw new Error("missing getRecommendedFees");
    if (!i1.getAddressUtxos) throw new Error("missing getAddressUtxos");
    const { fastFee: c } = await i1.getRecommendedFees(), l = KR(String(n), !0), u = new zr({
        network: Vr(o)
    }), { inscriberAddress: f } = c2e(l, e, o), h = 5 * 34 * a, y = Math.floor(h * c * a), S = Math.floor(s * c / 3) + 1e3 + 546 * a, k = Math.floor(y + S), P = (await i1.getAddressUtxos(t)).filter((ne)=>ne.value > 3e3).sort((ne, ee)=>ee.value - ne.value), M = ub(P);
    if (M === 0) throw new Error("insufficient funds");
    if (M < k) throw new Error("insufficient funds");
    let N = 0;
    const z = Ma(t, Vr(o));
    let K = 0;
    for await (const ne of P){
        const ee = bb(t, o);
        if (u.addInput({
            hash: ne.txid,
            index: ne.vout,
            witnessUtxo: {
                value: BigInt(ne.value),
                script: z
            }
        }), ee === sf && u.updateInput(K, {
            // biome-ignore lint/style/noNonNullAssertion: <explanation>
            tapInternalKey: Zo(Ke.from(r, "hex"))
        }), ee === d1) {
            const q = O1(r, o);
            u.updateInput(K, {
                redeemScript: q
            });
        }
        if (K++, N += ne.value, N > k) break;
    }
    const $ = N - k;
    return u.addOutput({
        value: BigInt(S),
        address: f
    }), $ > 546 && u.addOutput({
        value: BigInt($),
        address: t
    }), {
        psbtHex: u.toHex(),
        psbtBase64: u.toBase64()
    };
}, u2e = async ({ inscriptions: e, ordinalAddress: t, commitTxId: r, privKey: n, dataSourceManager: i1, opReturn: o, isDry: a })=>{
    const s = Mde(n), c = KR(n, !0), l = sj(c, e), u = Jm.encodeScript(l), [f, h] = Jm.getPubKey(c, {
        target: u
    });
    if (!i1) throw new Error("missing data source");
    if (!i1.waitForTransaction) throw new Error("missing waitForTransaction");
    if (!i1.getOutputValueByVOutIndex) throw new Error("missing waitForTransaction");
    if (!i1.broadcastTransaction) throw new Error("missing broadcastTransaction");
    if (!await i1.waitForTransaction(String(r))) throw new Error("ERROR WAITING FOR COMMIT TX");
    const y = await i1.getOutputValueByVOutIndex(r, 0);
    if (y === 0 || !y) throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const S = Wc.create({
        vin: [
            {
                txid: r,
                vout: 0,
                prevout: {
                    value: y,
                    scriptPubKey: [
                        "OP_1",
                        f
                    ]
                }
            }
        ],
        vout: [
            ...Array(e.length).fill({
                value: 546,
                scriptPubKey: ND.toScriptPubKey(t)
            })
        ],
        ...o ? {
            vout: [
                {
                    value: 0,
                    scriptPubKey: [
                        "OP_RETURN",
                        o
                    ]
                }
            ]
        } : {}
    }), k = eme.taproot.sign(s, S, 0, {
        extension: u
    });
    return S.vin[0].witness = [
        k,
        l,
        h
    ], a ? Wc.util.getTxid(S) : await i1.broadcastTransaction(Wc.encode(S).hex);
}, sj = (e, t)=>{
    const r = new TextEncoder(), n = r.encode("ord"), i1 = 546, o = (s, c)=>{
        let l;
        if (c === hoe) {
            const f = Ke.from(s, "base64").toString("utf-8");
            l = Ke.from(f, "utf-8");
        } else l = Ke.from(s, "base64");
        const u = [];
        for(let f = 0; f < l.length; f += 520)u.push(l.slice(f, f + 520));
        return u;
    }, a = [
        e,
        "OP_CHECKSIG"
    ];
    return t.forEach((s, c)=>{
        const { content: l, mimeType: u } = s, f = o(l, u);
        if (a.push("OP_0", "OP_IF", n, "01", r.encode(u), "OP_0"), c > 0) {
            const h = i1 * (c + 1), y = Ke.from([
                h
            ]);
            a.push(Ke.from([
                2
            ])), a.push(y);
        }
        a.push(...f.map((h)=>h), "OP_ENDIF");
    }), a;
}, c2e = (e, t, r = mn)=>{
    const n = sj(e, t), i1 = Jm.encodeScript(n), [o] = Jm.getPubKey(e, {
        target: i1
    });
    return {
        inscriberAddress: ND.p2tr.fromPubKey(o, mre(r)),
        tpubkey: o,
        tapleaf: i1
    };
};
var l2e = {}, H1 = {};
Object.defineProperty(H1, "__esModule", {
    value: !0
});
H1.isRunestone = void 0;
function f2e(e) {
    return !("flaws" in e);
}
H1.isRunestone = f2e;
var tp = {};
Object.defineProperty(tp, "__esModule", {
    value: !0
});
tp.Flaw = void 0;
var ZI;
(function(e) {
    e[e.EDICT_OUTPUT = 0] = "EDICT_OUTPUT", e[e.EDICT_RUNE_ID = 1] = "EDICT_RUNE_ID", e[e.INVALID_SCRIPT = 2] = "INVALID_SCRIPT", e[e.OPCODE = 3] = "OPCODE", e[e.SUPPLY_OVERFLOW = 4] = "SUPPLY_OVERFLOW", e[e.TRAILING_INTEGERS = 5] = "TRAILING_INTEGERS", e[e.TRUNCATED_FIELD = 6] = "TRUNCATED_FIELD", e[e.UNRECOGNIZED_EVEN_TAG = 7] = "UNRECOGNIZED_EVEN_TAG", e[e.UNRECOGNIZED_FLAG = 8] = "UNRECOGNIZED_FLAG", e[e.VARINT = 9] = "VARINT";
})(ZI || (tp.Flaw = ZI = {}));
var rp = {};
Object.defineProperty(rp, "__esModule", {
    value: !0
});
rp.RuneId = void 0;
const Sc = Ti, Ps = ui;
class a0 {
    constructor(t, r){
        this.block = t, this.tx = r;
    }
    static new(t, r) {
        const n = new a0(t, r);
        return n.block === 0n && n.tx > 0 ? Sc.None : (0, Sc.Some)(n);
    }
    static sort(t) {
        return [
            ...t
        ].sort((r, n)=>Number(r.block - n.block || r.tx - n.tx));
    }
    delta(t) {
        const r = Ps.u64.checkedSub(t.block, this.block);
        if (r.isNone()) return Sc.None;
        const n = r.unwrap();
        let i1;
        if (n === 0n) {
            const o = Ps.u32.checkedSub(t.tx, this.tx);
            if (o.isNone()) return Sc.None;
            i1 = o.unwrap();
        } else i1 = t.tx;
        return (0, Sc.Some)([
            (0, Ps.u128)(n),
            (0, Ps.u128)(i1)
        ]);
    }
    next(t, r) {
        const n = Ps.u128.tryIntoU64(t), i1 = Ps.u128.tryIntoU32(r);
        if (n.isNone() || i1.isNone()) return Sc.None;
        const o = n.unwrap(), a = i1.unwrap(), s = Ps.u64.checkedAdd(this.block, o);
        if (s.isNone()) return Sc.None;
        let c;
        if (o === 0n) {
            const l = Ps.u32.checkedAdd(this.tx, a);
            if (l.isNone()) return Sc.None;
            c = l.unwrap();
        } else c = a;
        return a0.new(s.unwrap(), c);
    }
    toString() {
        return `${this.block}:${this.tx}`;
    }
    static fromString(t) {
        const r = t.split(":");
        if (r.length !== 2) throw new Error(`invalid rune ID: ${t}`);
        const [n, i1] = r;
        if (!/^\d+$/.test(n) || !/^\d+$/.test(i1)) throw new Error(`invalid rune ID: ${t}`);
        return new a0((0, Ps.u64)(BigInt(n)), (0, Ps.u32)(BigInt(i1)));
    }
}
rp.RuneId = a0;
var w7 = {}, Fb = {};
Object.defineProperty(Fb, "__esModule", {
    value: !0
});
Fb.Instruction = void 0;
var XI;
(function(e) {
    function t(n) {
        return typeof n == "number";
    }
    e.isNumber = t;
    function r(n) {
        return typeof n != "number";
    }
    e.isBuffer = r;
})(XI || (Fb.Instruction = XI = {}));
var zb = {}, Lb = {};
Object.defineProperty(Lb, "__esModule", {
    value: !0
});
Lb.Edict = void 0;
const Iy = Ti, d2e = ui;
var YI;
(function(e) {
    function t(r, n, i1, o) {
        if (n.block === 0n && n.tx > 0n) return Iy.None;
        const a = d2e.u128.tryIntoU32(o);
        if (a.isNone()) return Iy.None;
        const s = a.unwrap();
        return s > r ? Iy.None : (0, Iy.Some)({
            id: n,
            amount: i1,
            output: s
        });
    }
    e.fromIntegers = t;
})(YI || (Lb.Edict = YI = {}));
Object.defineProperty(zb, "__esModule", {
    value: !0
});
zb.Message = void 0;
const h2e = Lb, By = tp, r8 = ui, p2e = rp, g2e = Df;
class A7 {
    constructor(t, r, n){
        this.flaws = t, this.edicts = r, this.fields = n;
    }
    static fromIntegers(t, r) {
        const n = [], i1 = /* @__PURE__ */ new Map(), o = [];
        for (const a of [
            ...Array(Math.ceil(r.length / 2)).keys()
        ].map((s)=>s * 2)){
            const s = r[a];
            if ((0, r8.u128)(g2e.Tag.BODY) === s) {
                let u = new p2e.RuneId((0, r8.u64)(0), (0, r8.u32)(0));
                const f = 4, h = r.slice(a + 1);
                for(let y = 0; y < h.length; y += f){
                    const S = h.slice(y, y + f);
                    if (S.length !== f) {
                        o.push(By.Flaw.TRAILING_INTEGERS);
                        break;
                    }
                    const k = u.next(S[0], S[1]);
                    if (k.isNone()) {
                        o.push(By.Flaw.EDICT_RUNE_ID);
                        break;
                    }
                    const P = k.unwrap(), M = h2e.Edict.fromIntegers(t, P, S[2], S[3]);
                    if (M.isNone()) {
                        o.push(By.Flaw.EDICT_OUTPUT);
                        break;
                    }
                    const N = M.unwrap();
                    u = P, n.push(N);
                }
                break;
            }
            const c = r[a + 1];
            if (c === void 0) {
                o.push(By.Flaw.TRUNCATED_FIELD);
                break;
            }
            const l = i1.get(s) ?? [];
            l.push(c), i1.set(s, l);
        }
        return new A7(o, n, i1);
    }
}
zb.Message = A7;
var Hb = {};
Object.defineProperty(Hb, "__esModule", {
    value: !0
});
Hb.Cenotaph = void 0;
const JI = Ti;
class y2e {
    constructor(t, r = JI.None, n = JI.None){
        this.flaws = t, this.etching = r, this.mint = n;
    }
}
Hb.Cenotaph = y2e;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Runestone = e.isValidPayload = e.MAX_SPACERS = void 0;
    const t = wn, r = Wh, n = M1, i1 = Df, o = ui, a = Ti, s = Zh, c = Qh, l = Fb, u = rp, f = Du, h = zb, y = tp, S = Hb;
    e.MAX_SPACERS = 134217727;
    function k(M) {
        return Ke.isBuffer(M);
    }
    e.isValidPayload = k;
    class P {
        constructor(N, z, K, $){
            this.mint = N, this.pointer = z, this.edicts = K, this.etching = $;
        }
        static decipher(N) {
            const z = P.payload(N);
            if (z.isNone()) return a.None;
            const K = z.unwrap();
            if (!k(K)) return (0, a.Some)(new S.Cenotaph([
                K
            ]));
            const $ = P.integers(K);
            if ($.isNone()) return (0, a.Some)(new S.Cenotaph([
                y.Flaw.VARINT
            ]));
            const { flaws: ne, edicts: ee, fields: q } = h.Message.fromIntegers(N.vout.length, $.unwrap());
            let U = i1.Tag.take(i1.Tag.FLAGS, q, 1, ([w])=>(0, a.Some)(w)).unwrapOr((0, o.u128)(0));
            const Q = c.Flag.take(U, c.Flag.ETCHING), v = Q.set;
            U = Q.flags;
            const B = v ? (()=>{
                const w = i1.Tag.take(i1.Tag.DIVISIBILITY, q, 1, ([G])=>o.u128.tryIntoU8(G).andThen((se)=>se <= t.MAX_DIVISIBILITY ? (0, a.Some)(se) : a.None)), _ = i1.Tag.take(i1.Tag.RUNE, q, 1, ([G])=>(0, a.Some)(new s.Rune(G))), O = i1.Tag.take(i1.Tag.SPACERS, q, 1, ([G])=>o.u128.tryIntoU32(G).andThen((se)=>se <= e.MAX_SPACERS ? (0, a.Some)(se) : a.None)), I = i1.Tag.take(i1.Tag.SYMBOL, q, 1, ([G])=>o.u128.tryIntoU32(G).andThen((se)=>{
                        try {
                            return (0, a.Some)(String.fromCodePoint(Number(se)));
                        } catch  {
                            return a.None;
                        }
                    })), x = c.Flag.take(U, c.Flag.TERMS), R = x.set;
                U = x.flags;
                const j = R ? (()=>{
                    const G = i1.Tag.take(i1.Tag.AMOUNT, q, 1, ([pe])=>(0, a.Some)(pe)), se = i1.Tag.take(i1.Tag.CAP, q, 1, ([pe])=>(0, a.Some)(pe)), Z = [
                        i1.Tag.take(i1.Tag.OFFSET_START, q, 1, ([pe])=>o.u128.tryIntoU64(pe)),
                        i1.Tag.take(i1.Tag.OFFSET_END, q, 1, ([pe])=>o.u128.tryIntoU64(pe))
                    ], ie = [
                        i1.Tag.take(i1.Tag.HEIGHT_START, q, 1, ([pe])=>o.u128.tryIntoU64(pe)),
                        i1.Tag.take(i1.Tag.HEIGHT_END, q, 1, ([pe])=>o.u128.tryIntoU64(pe))
                    ];
                    return (0, a.Some)({
                        amount: G,
                        cap: se,
                        offset: Z,
                        height: ie
                    });
                })() : a.None, Y = i1.Tag.take(i1.Tag.PREMINE, q, 1, ([G])=>(0, a.Some)(G)), he = c.Flag.take(U, c.Flag.TURBO), ue = Q.set;
                return U = he.flags, (0, a.Some)(new r.Etching(w, _, O, I, j, Y, ue));
            })() : a.None, g = i1.Tag.take(i1.Tag.MINT, q, 2, ([w, _])=>{
                const O = o.u128.tryIntoU64(w), I = o.u128.tryIntoU32(_);
                return O.isNone() || I.isNone() ? a.None : u.RuneId.new(O.unwrap(), I.unwrap());
            }), E = i1.Tag.take(i1.Tag.POINTER, q, 1, ([w])=>o.u128.tryIntoU32(w).andThen((_)=>_ < N.vout.length ? (0, a.Some)(_) : a.None));
            return B.map((w)=>w.supply.isNone()).unwrapOr(!1) && ne.push(y.Flaw.SUPPLY_OVERFLOW), U !== 0n && ne.push(y.Flaw.UNRECOGNIZED_FLAG), [
                ...q.keys()
            ].find((w)=>w % 2n === 0n) !== void 0 && ne.push(y.Flaw.UNRECOGNIZED_EVEN_TAG), ne.length !== 0 ? (0, a.Some)(new S.Cenotaph(ne, B.andThen((w)=>w.rune), g)) : (0, a.Some)(new P(g, E, ee, B));
        }
        encipher() {
            const N = [];
            if (this.etching.isSome()) {
                const $ = this.etching.unwrap();
                let ne = (0, o.u128)(0);
                if (ne = c.Flag.set(ne, c.Flag.ETCHING), $.terms.isSome() && (ne = c.Flag.set(ne, c.Flag.TERMS)), $.turbo && (ne = c.Flag.set(ne, c.Flag.TURBO)), N.push(i1.Tag.encode(i1.Tag.FLAGS, [
                    ne
                ])), N.push(i1.Tag.encodeOptionInt(i1.Tag.RUNE, $.rune.map((ee)=>ee.value))), N.push(i1.Tag.encodeOptionInt(i1.Tag.DIVISIBILITY, $.divisibility.map(o.u128))), N.push(i1.Tag.encodeOptionInt(i1.Tag.SPACERS, $.spacers.map(o.u128))), N.push(i1.Tag.encodeOptionInt(i1.Tag.SYMBOL, $.symbol.map((ee)=>(0, o.u128)(ee.codePointAt(0))))), N.push(i1.Tag.encodeOptionInt(i1.Tag.PREMINE, $.premine)), $.terms.isSome()) {
                    const ee = $.terms.unwrap();
                    N.push(i1.Tag.encodeOptionInt(i1.Tag.AMOUNT, ee.amount)), N.push(i1.Tag.encodeOptionInt(i1.Tag.CAP, ee.cap)), N.push(i1.Tag.encodeOptionInt(i1.Tag.HEIGHT_START, ee.height[0])), N.push(i1.Tag.encodeOptionInt(i1.Tag.HEIGHT_END, ee.height[1])), N.push(i1.Tag.encodeOptionInt(i1.Tag.OFFSET_START, ee.offset[0])), N.push(i1.Tag.encodeOptionInt(i1.Tag.OFFSET_END, ee.offset[1]));
                }
            }
            if (this.mint.isSome()) {
                const $ = this.mint.unwrap();
                N.push(i1.Tag.encode(i1.Tag.MINT, [
                    $.block,
                    $.tx
                ].map(o.u128)));
            }
            if (N.push(i1.Tag.encodeOptionInt(i1.Tag.POINTER, this.pointer.map(o.u128))), this.edicts.length) {
                N.push(o.u128.encodeVarInt((0, o.u128)(i1.Tag.BODY)));
                const $ = [
                    ...this.edicts
                ].sort((ee, q)=>Number(ee.id.block - q.id.block || ee.id.tx - q.id.tx));
                let ne = new u.RuneId((0, o.u64)(0), (0, o.u32)(0));
                for (const ee of $){
                    const [q, U] = ne.delta(ee.id).unwrap();
                    N.push(o.u128.encodeVarInt(q)), N.push(o.u128.encodeVarInt(U)), N.push(o.u128.encodeVarInt(ee.amount)), N.push(o.u128.encodeVarInt((0, o.u128)(ee.output))), ne = ee.id;
                }
            }
            const z = [];
            z.push(t.OP_RETURN), z.push(t.MAGIC_NUMBER);
            const K = Ke.concat(N);
            for(let $ = 0; $ < K.length; $ += t.MAX_SCRIPT_ELEMENT_SIZE)z.push(K.subarray($, $ + t.MAX_SCRIPT_ELEMENT_SIZE));
            return f.script.compile(z);
        }
        static payload(N) {
            for (const z of N.vout){
                const K = f.script.decompile(Ke.from(z.scriptPubKey.hex, "hex"));
                if (K === null) throw new Error("unable to decompile");
                let $ = K.next();
                if ($.done || $.value !== t.OP_RETURN || ($ = K.next(), $.done || l.Instruction.isBuffer($.value) || $.value !== t.MAGIC_NUMBER)) continue;
                let ne = [];
                do {
                    if ($ = K.next(), $.done) {
                        if (!$.value) return (0, a.Some)(y.Flaw.INVALID_SCRIPT);
                        break;
                    }
                    const ee = $.value;
                    if (l.Instruction.isBuffer(ee)) ne.push(ee);
                    else return (0, a.Some)(y.Flaw.OPCODE);
                }while (!0)
                return (0, a.Some)(Ke.concat(ne));
            }
            return a.None;
        }
        static integers(N) {
            const z = [], K = new n.SeekBuffer(N);
            for(; !K.isFinished();){
                const $ = o.u128.decodeVarInt(K);
                if ($.isNone()) return a.None;
                z.push($.unwrap());
            }
            return (0, a.Some)(z);
        }
    }
    e.Runestone = P;
})(w7);
var uj = {}, L0 = {}, K1 = {};
Object.defineProperty(K1, "__esModule", {
    value: !0
});
K1.RuneLocation = void 0;
var eB;
(function(e) {
    function t(r) {
        return `${r.block}:${r.tx}`;
    }
    e.toString = t;
})(eB || (K1.RuneLocation = eB = {}));
Object.defineProperty(L0, "__esModule", {
    value: !0
});
L0.RuneUpdater = void 0;
const Bp = H1, tm = wn, Er = ui, Ko = Ti, tB = Zh, m2e = w7, b2e = Du, rB = $h, wu = K1;
function n8(e) {
    return e && Ke.from(e, "hex")[0] === tm.OP_RETURN;
}
class w2e {
    constructor(t, r, n, i1, o){
        this.reorg = n, this._storage = i1, this._rpc = o, this.etchings = [], this.utxoBalances = [], this.spentBalances = [], this._mintCountsByRuneLocation = /* @__PURE__ */ new Map(), this._burnedBalancesByRuneLocation = /* @__PURE__ */ new Map(), this.block = {
            height: r.height,
            hash: r.hash,
            previousblockhash: r.previousblockhash,
            time: r.time
        }, this._minimum = tB.Rune.getMinimumAtHeight(t, (0, Er.u128)(r.height));
    }
    get mintCounts() {
        return [
            ...this._mintCountsByRuneLocation.values()
        ];
    }
    get burnedBalances() {
        return [
            ...this._burnedBalancesByRuneLocation.values()
        ];
    }
    async indexRunes(t, r) {
        const n = m2e.Runestone.decipher(t), i1 = await this.unallocated(t), o = [
            ...new Array(t.vout.length)
        ].map(()=>/* @__PURE__ */ new Map());
        function a(u) {
            const f = wu.RuneLocation.toString(u), h = i1.get(f) ?? {
                runeId: u,
                amount: 0n
            };
            return i1.set(f, h), h;
        }
        function s(u, f) {
            const h = wu.RuneLocation.toString(f), y = o[u].get(h) ?? {
                runeId: f,
                amount: 0n
            };
            return o[u].set(h, y), y;
        }
        if (n.isSome()) {
            const u = n.unwrap(), f = u.mint;
            if (f.isSome()) {
                const y = f.unwrap(), S = {
                    block: Number(y.block),
                    tx: Number(y.tx)
                }, k = await this.mint(S, t.txid);
                if (k.isSome()) {
                    const P = k.unwrap(), M = a(S);
                    M.amount = Er.u128.checkedAddThrow((0, Er.u128)(M.amount), (0, Er.u128)(P));
                }
            }
            const h = await this.etched(r, t, u);
            if ((0, Bp.isRunestone)(u)) {
                const y = u;
                if (h.isSome()) {
                    const S = h.unwrap(), k = a(S.runeId);
                    k.amount = Er.u128.checkedAddThrow((0, Er.u128)(k.amount), y.etching.unwrap().premine.unwrapOr((0, Er.u128)(0)));
                }
                for (const { id: S, amount: k, output: P } of [
                    ...y.edicts
                ]){
                    if (P > t.vout.length) throw new Error("Runestone edict output should never exceed transaction output size");
                    if (S.block === 0n && S.tx === 0n && h.isNone()) continue;
                    const M = S.block === 0n && S.tx === 0n ? h.unwrap().runeId : {
                        block: Number(S.block),
                        tx: Number(S.tx)
                    }, N = wu.RuneLocation.toString(M), z = i1.get(N);
                    if (z === void 0) continue;
                    let K = ($, ne)=>{
                        if ($ > 0n) {
                            const ee = s(ne, M);
                            z.amount = Er.u128.checkedSubThrow((0, Er.u128)(z.amount), $), ee.amount = Er.u128.checkedAddThrow((0, Er.u128)(ee.amount), $);
                        }
                    };
                    if (Number(P) === t.vout.length) {
                        const $ = [
                            ...t.vout.entries()
                        ].filter(([ne, ee])=>!n8(ee.scriptPubKey.hex)).map(([ne])=>ne);
                        if ($.length !== 0) if (k === 0n) {
                            const ne = (0, Er.u128)((0, Er.u128)(z.amount) / (0, Er.u128)($.length)), ee = (0, Er.u128)(z.amount) % (0, Er.u128)($.length);
                            for (const [q, U] of $.entries())K(q < ee ? Er.u128.checkedAddThrow(ne, (0, Er.u128)(1)) : ne, U);
                        } else for (const ne of $)K(k < z.amount ? k : (0, Er.u128)(z.amount), ne);
                    } else K(k !== 0n && k < (0, Er.u128)(z.amount) ? k : (0, Er.u128)(z.amount), Number(P));
                }
            }
            if (h.isSome()) {
                const { runeId: y, rune: S } = h.unwrap();
                this.createEtching(t.txid, u, y, S);
            }
        }
        const c = /* @__PURE__ */ new Map();
        function l(u) {
            const f = wu.RuneLocation.toString(u), h = c.get(f) ?? {
                runeId: u,
                amount: 0n
            };
            return c.set(f, h), h;
        }
        if (n.isSome() && !(0, Bp.isRunestone)(n.unwrap())) for (const u of i1.values()){
            const f = l(u.runeId);
            f.amount = Er.u128.checkedAddThrow((0, Er.u128)(f.amount), (0, Er.u128)(u.amount));
        }
        else {
            const u = n.map((f)=>{
                if (!(0, Bp.isRunestone)(f)) throw new Error("unreachable");
                return f.pointer;
            }).unwrapOr(Ko.None).map((f)=>Number(f)).inspect((f)=>{
                if (f < 0 || f >= o.length) throw new Error("Pointer is invalid");
            }).orElse(()=>{
                const f = [
                    ...t.vout.entries()
                ].find(([h, y])=>!n8(y.scriptPubKey.hex));
                return f !== void 0 ? (0, Ko.Some)(f[0]) : Ko.None;
            });
            if (u.isSome()) {
                const f = u.unwrap();
                for (const h of i1.values())if (h.amount > 0) {
                    const y = s(f, h.runeId);
                    y.amount = Er.u128.checkedAddThrow((0, Er.u128)(y.amount), (0, Er.u128)(h.amount));
                }
            } else for (const [f, h] of i1)if (h.amount > 0) {
                const y = l(h.runeId);
                c.set(f, {
                    runeId: h.runeId,
                    amount: Er.u128.checkedAddThrow((0, Er.u128)(y.amount), (0, Er.u128)(h.amount))
                });
            }
        }
        for (const [u, f] of o.entries()){
            if (f.size === 0) continue;
            const h = t.vout[u];
            if (n8(h.scriptPubKey.hex)) {
                for (const [S, k] of f){
                    const P = l(k.runeId);
                    P.amount = Er.u128.checkedAddThrow((0, Er.u128)(P.amount), (0, Er.u128)(k.amount));
                }
                continue;
            }
            const y = new Map(this.etchings.map((S)=>[
                    wu.RuneLocation.toString(S.runeId),
                    S
                ]));
            for (const S of f.values()){
                const k = wu.RuneLocation.toString(S.runeId), P = y.get(k) ?? await this._storage.getEtching(k);
                if (P === null) throw new Error("Rune should exist at this point");
                this.utxoBalances.push({
                    runeId: S.runeId,
                    runeTicker: P.runeTicker,
                    amount: S.amount,
                    scriptPubKey: Ke.from(h.scriptPubKey.hex),
                    txid: t.txid,
                    vout: u,
                    address: h.scriptPubKey.address
                });
            }
        }
        for (const [u, f] of c)this._burnedBalancesByRuneLocation.set(u, f);
    }
    async etched(t, r, n) {
        let i1;
        if ((0, Bp.isRunestone)(n)) {
            const a = n;
            if (a.etching.isNone()) return Ko.None;
            i1 = a.etching.unwrap().rune;
        } else {
            const a = n;
            if (a.etching.isNone()) return Ko.None;
            i1 = a.etching;
        }
        let o;
        if (i1.isSome()) {
            if (o = i1.unwrap(), o.value < this._minimum.value || o.reserved || this.etchings.find((s)=>rB.SpacedRune.fromString(s.runeName).rune.toString() === o.toString())) return Ko.None;
            const a = await this._storage.getRuneLocation(o.toString());
            if (a && a.block < this.block.height || !await this.txCommitsToRune(r, o)) return Ko.None;
        } else o = tB.Rune.getReserved((0, Er.u64)(this.block.height), (0, Er.u32)(t));
        return (0, Ko.Some)({
            runeId: {
                block: this.block.height,
                tx: t
            },
            rune: o
        });
    }
    async mint(t, r) {
        var n, i1, o, a;
        const s = wu.RuneLocation.toString(t), c = new Map(this.etchings.map((z)=>[
                wu.RuneLocation.toString(z.runeId),
                z
            ])).get(s) ?? await this._storage.getEtching(s);
        if (c === null || !c.valid || !c.terms) return Ko.None;
        const l = c.terms, u = ((n = l.offset) == null ? void 0 : n.start) !== void 0 ? c.runeId.block + Number(l.offset.start) : null, f = ((i1 = l.height) == null ? void 0 : i1.start) !== void 0 ? Number(l.height.start) : null, h = u !== null || f !== null ? Math.max(u ?? -1 / 0, f ?? -1 / 0) : null;
        if (h !== null && this.block.height < h) return Ko.None;
        const y = ((o = l.offset) == null ? void 0 : o.end) !== void 0 ? c.runeId.block + Number(l.offset.end) : null, S = ((a = l.height) == null ? void 0 : a.end) !== void 0 ? Number(l.height.end) : null, k = y !== null || S !== null ? Math.max(y ?? -1 / 0, S ?? -1 / 0) : null;
        if (k !== null && this.block.height >= k) return Ko.None;
        const P = l.cap ?? 0n, M = this._mintCountsByRuneLocation.get(s) ?? {
            mint: t,
            count: 0
        };
        if (this._mintCountsByRuneLocation.set(s, M), M.count + await this._storage.getValidMintCount(s, this.block.height - 1) >= P) return Ko.None;
        const N = l.amount ?? 0n;
        return M.count++, (0, Ko.Some)(N);
    }
    async unallocated(t) {
        const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
        for (const i1 of this.utxoBalances){
            const o = `${i1.txid}:${i1.vout}`, a = n.get(o) ?? [];
            a.push(i1), n.set(o, a);
        }
        for (const i1 of t.vin){
            if ("coinbase" in i1) continue;
            const o = n.get(`${i1.txid}:${i1.vout}`) ?? await this._storage.getUtxoBalance(i1.txid, i1.vout);
            for (const a of o){
                const s = a.runeId, c = wu.RuneLocation.toString(s), l = r.get(c) ?? {
                    runeId: s,
                    amount: 0n
                };
                r.set(c, l), l.amount = Er.u128.checkedAddThrow((0, Er.u128)(l.amount), (0, Er.u128)(a.amount)), this.spentBalances.push({
                    txid: i1.txid,
                    vout: i1.vout,
                    address: a.address,
                    scriptPubKey: a.scriptPubKey,
                    runeId: a.runeId,
                    runeTicker: a.runeTicker,
                    amount: a.amount,
                    spentTxid: t.txid
                });
            }
        }
        return r;
    }
    async txCommitsToRune(t, r) {
        const n = r.commitment;
        for (const i1 of t.vin){
            if ("coinbase" in i1) continue;
            const o = i1.txinwitness.map((u)=>Ke.from(u, "hex")), a = o[o.length - 1], s = o.length >= 2 && a[0] === tm.TAPROOT_ANNEX_PREFIX ? 3 : 2;
            if (s > o.length) continue;
            const c = o[o.length - s];
            if (c === void 0) continue;
            const l = b2e.script.decompile(c);
            for (const u of l){
                if (!Ke.isBuffer(u) || Ke.compare(u, n) !== 0) continue;
                const f = await this._rpc.getrawtransaction({
                    txid: i1.txid,
                    verbose: !0
                });
                if (f.error !== null) throw f.error;
                const h = f.result;
                if (h.vout[i1.vout].scriptPubKey.type !== tm.TAPROOT_SCRIPT_PUBKEY_TYPE) continue;
                const y = await this._rpc.getblock({
                    blockhash: h.blockhash
                });
                if (y.error !== null) throw y.error;
                const S = y.result.height;
                if (Er.u128.checkedSubThrow((0, Er.u128)(this.block.height), (0, Er.u128)(S)) + 1n >= tm.COMMIT_CONFIRMATIONS) return !0;
            }
        }
        return !1;
    }
    createEtching(t, r, n, i1) {
        if ((0, Bp.isRunestone)(r)) {
            const { divisibility: o, terms: a, premine: s, spacers: c, symbol: l } = r.etching.unwrap();
            this.etchings.push({
                valid: !0,
                runeTicker: i1.toString(),
                runeName: new rB.SpacedRune(i1, Number(c.map(Number).unwrapOr(0))).toString(),
                runeId: n,
                txid: t,
                ...o.isSome() ? {
                    divisibility: o.map(Number).unwrap()
                } : {},
                ...s.isSome() ? {
                    premine: s.unwrap()
                } : {},
                ...l.isSome() ? {
                    symbol: l.unwrap()
                } : {},
                ...a.isSome() ? {
                    terms: (()=>{
                        const u = a.unwrap();
                        return {
                            ...u.amount.isSome() ? {
                                amount: u.amount.unwrap()
                            } : {},
                            ...u.cap.isSome() ? {
                                cap: u.cap.unwrap()
                            } : {},
                            ...u.height.filter((f)=>f.isSome()).length ? {
                                height: {
                                    ...u.height[0].isSome() ? {
                                        start: u.height[0].unwrap()
                                    } : {},
                                    ...u.height[1].isSome() ? {
                                        end: u.height[1].unwrap()
                                    } : {}
                                }
                            } : {},
                            ...u.offset.filter((f)=>f.isSome()).length ? {
                                offset: {
                                    ...u.offset[0].isSome() ? {
                                        start: u.offset[0].unwrap()
                                    } : {},
                                    ...u.offset[1].isSome() ? {
                                        end: u.offset[1].unwrap()
                                    } : {}
                                }
                            } : {}
                        };
                    })()
                } : {}
            });
        } else this.etchings.push({
            valid: !1,
            runeId: n,
            txid: t,
            runeTicker: i1.toString(),
            runeName: i1.toString()
        });
    }
}
L0.RuneUpdater = w2e;
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(c, l, u, f) {
        f === void 0 && (f = u);
        var h = Object.getOwnPropertyDescriptor(l, u);
        (!h || ("get" in h ? !l.__esModule : h.writable || h.configurable)) && (h = {
            enumerable: !0,
            get: function() {
                return l[u];
            }
        }), Object.defineProperty(c, f, h);
    } : function(c, l, u, f) {
        f === void 0 && (f = u), c[f] = l[u];
    }), r = Qe && Qe.__exportStar || function(c, l) {
        for(var u in c)u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, c, u);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RunestoneIndexer = e.RuneUpdater = void 0;
    const n = jf, i1 = L0, o = ui;
    r(K1, e);
    var a = L0;
    Object.defineProperty(e, "RuneUpdater", {
        enumerable: !0,
        get: function() {
            return a.RuneUpdater;
        }
    });
    class s {
        constructor(l){
            this._started = !1, this._updateInProgress = !1, this._rpc = l.bitcoinRpcClient, this._storage = l.storage, this._network = l.network;
        }
        async start() {
            this._started || (await this._storage.connect(), this._started = !0, this._network === n.Network.MAINNET && this._storage.seedEtchings([
                {
                    runeTicker: "UNCOMMONGOODS",
                    runeName: "UNCOMMONGOODS",
                    runeId: {
                        block: 1,
                        tx: 0
                    },
                    txid: "0000000000000000000000000000000000000000000000000000000000000000",
                    valid: !0,
                    symbol: "",
                    terms: {
                        amount: 1n,
                        cap: o.u128.MAX,
                        height: {
                            start: 840000n,
                            end: 1050000n
                        }
                    }
                }
            ]));
        }
        async stop() {
            this._started && (await this._storage.disconnect(), this._started = !1);
        }
        async updateRuneUtxoBalances() {
            if (!this._started) throw new Error("Runestone indexer is not started");
            if (!this._updateInProgress) {
                this._updateInProgress = !0;
                try {
                    await this.updateRuneUtxoBalancesImpl();
                } finally{
                    this._updateInProgress = !1;
                }
            }
        }
        async updateRuneUtxoBalancesImpl() {
            const l = await this._storage.getCurrentBlock();
            if (l) {
                const h = [];
                let y = l.height, S = (await this._rpc.getblockhash({
                    height: y
                })).result, k = l.hash;
                for(; k !== S;)S && h.push(S), y--, S = (await this._rpc.getblockhash({
                    height: y
                })).result, k = await this._storage.getBlockhash(y);
                h.reverse();
                for (const P of h){
                    const M = await this._rpc.getblock({
                        blockhash: P,
                        verbosity: 2
                    });
                    if (M.error !== null) throw M.error;
                    const N = M.result, z = new i1.RuneUpdater(this._network, N, !0, this._storage, this._rpc);
                    for (const [K, $] of N.tx.entries())await z.indexRunes($, K);
                    await this._storage.saveBlockIndex(z);
                }
            }
            let u = Math.max(n.Network.getFirstRuneHeight(this._network), l ? l.height + 1 : 0), f = (await this._rpc.getblockhash({
                height: u
            })).result;
            for(; f !== null;){
                const h = await this._rpc.getblock({
                    blockhash: f,
                    verbosity: 2
                });
                if (h.error !== null) throw h.error;
                const y = h.result, S = new i1.RuneUpdater(this._network, y, !1, this._storage, this._rpc);
                for (const [k, P] of y.tx.entries())await S.indexRunes(P, k);
                await this._storage.saveBlockIndex(S), u++, f = (await this._rpc.getblockhash({
                    height: u
                })).result;
            }
        }
    }
    e.RunestoneIndexer = s;
})(uj);
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.tryDecodeRunestone = e.isRunestone = e.encodeRunestone = e.Network = e.RunestoneIndexer = e.RuneUpdater = e.RuneLocation = void 0;
    const t = H1, r = wn, n = Wh, i1 = tp, o = ui, a = Ti, s = rp, c = w7, l = $h;
    var u = uj;
    Object.defineProperty(e, "RuneLocation", {
        enumerable: !0,
        get: function() {
            return u.RuneLocation;
        }
    }), Object.defineProperty(e, "RuneUpdater", {
        enumerable: !0,
        get: function() {
            return u.RuneUpdater;
        }
    }), Object.defineProperty(e, "RunestoneIndexer", {
        enumerable: !0,
        get: function() {
            return u.RunestoneIndexer;
        }
    });
    var f = jf;
    Object.defineProperty(e, "Network", {
        enumerable: !0,
        get: function() {
            return f.Network;
        }
    });
    function h(K) {
        switch(K){
            case i1.Flaw.EDICT_OUTPUT:
                return "edict_output";
            case i1.Flaw.EDICT_RUNE_ID:
                return "edict_rune_id";
            case i1.Flaw.INVALID_SCRIPT:
                return "invalid_script";
            case i1.Flaw.OPCODE:
                return "opcode";
            case i1.Flaw.SUPPLY_OVERFLOW:
                return "supply_overflow";
            case i1.Flaw.TRAILING_INTEGERS:
                return "trailing_integers";
            case i1.Flaw.TRUNCATED_FIELD:
                return "truncated_field";
            case i1.Flaw.UNRECOGNIZED_EVEN_TAG:
                return "unrecognized_even_tag";
            case i1.Flaw.UNRECOGNIZED_FLAG:
                return "unrecognized_flag";
            case i1.Flaw.VARINT:
                return "varint";
        }
    }
    const y = (K)=>{
        const $ = BigInt(K);
        if ($ < 0n || $ > o.u8.MAX) throw Error("u8 overflow");
        return (0, o.u8)($);
    }, S = (K)=>{
        const $ = BigInt(K);
        if ($ < 0n || $ > o.u32.MAX) throw Error("u32 overflow");
        return (0, o.u32)($);
    }, k = (K)=>{
        const $ = BigInt(K);
        if ($ < 0n || $ > o.u64.MAX) throw Error("u64 overflow");
        return (0, o.u64)($);
    }, P = (K)=>{
        const $ = BigInt(K);
        if ($ < 0n || $ > o.u128.MAX) throw Error("u128 overflow");
        return (0, o.u128)($);
    };
    function M(K) {
        const $ = K.mint ? (0, a.Some)(new s.RuneId(k(K.mint.block), S(K.mint.tx))) : a.None, ne = K.pointer !== void 0 ? (0, a.Some)(K.pointer).map(S) : a.None, ee = (K.edicts ?? []).map((Q)=>({
                id: new s.RuneId(k(Q.id.block), S(Q.id.tx)),
                amount: P(Q.amount),
                output: S(Q.output)
            }));
        let q = a.None, U;
        if (K.etching) {
            const Q = K.etching, v = Q.runeName ? l.SpacedRune.fromString(Q.runeName) : void 0, B = (v == null ? void 0 : v.rune) !== void 0 ? (0, a.Some)(v.rune) : a.None;
            if (Q.symbol && !(Q.symbol.length === 1 || Q.symbol.length === 2 && Q.symbol.codePointAt(0) >= 65536)) throw Error("Symbol must be one code point");
            const g = Q.divisibility !== void 0 ? (0, a.Some)(Q.divisibility).map(y) : a.None, E = Q.premine !== void 0 ? (0, a.Some)(Q.premine).map(P) : a.None, w = (v == null ? void 0 : v.spacers) !== void 0 && v.spacers !== 0 ? (0, a.Some)(S(v.spacers)) : a.None, _ = Q.symbol ? (0, a.Some)(Q.symbol) : a.None;
            if (g.isSome() && g.unwrap() > r.MAX_DIVISIBILITY) throw Error(`Divisibility is greater than protocol max ${r.MAX_DIVISIBILITY}`);
            let O = a.None;
            if (Q.terms) {
                const x = Q.terms, R = x.amount !== void 0 ? (0, a.Some)(x.amount).map(P) : a.None, j = x.cap !== void 0 ? (0, a.Some)(x.cap).map(P) : a.None, Y = x.height ? [
                    x.height.start !== void 0 ? (0, a.Some)(x.height.start).map(k) : a.None,
                    x.height.end !== void 0 ? (0, a.Some)(x.height.end).map(k) : a.None
                ] : [
                    a.None,
                    a.None
                ], he = x.offset ? [
                    x.offset.start !== void 0 ? (0, a.Some)(x.offset.start).map(k) : a.None,
                    x.offset.end !== void 0 ? (0, a.Some)(x.offset.end).map(k) : a.None
                ] : [
                    a.None,
                    a.None
                ];
                if (R.isSome() && j.isSome() && R.unwrap() * j.unwrap() > o.u128.MAX) throw Error("Terms overflow with amount times cap");
                O = (0, a.Some)({
                    amount: R,
                    cap: j,
                    height: Y,
                    offset: he
                });
            }
            const I = Q.turbo ?? !1;
            q = (0, a.Some)(new n.Etching(g, B, w, _, O, E, I)), U = B.isSome() ? B.unwrap().commitment : void 0;
        }
        return {
            encodedRunestone: new c.Runestone($, ne, ee, q).encipher(),
            etchingCommitment: U
        };
    }
    e.encodeRunestone = M;
    function N(K) {
        return !("flaws" in K);
    }
    e.isRunestone = N;
    function z(K) {
        const $ = c.Runestone.decipher(K);
        if ($.isNone()) return null;
        const ne = $.unwrap();
        if ((0, t.isRunestone)(ne)) {
            const ee = ne, q = ()=>ee.etching.unwrap(), U = ()=>q().terms.unwrap();
            return {
                ...ee.etching.isSome() ? {
                    etching: {
                        ...q().divisibility.isSome() ? {
                            divisibility: q().divisibility.map(Number).unwrap()
                        } : {},
                        ...q().premine.isSome() ? {
                            premine: q().premine.unwrap()
                        } : {},
                        ...q().rune.isSome() ? {
                            runeName: new l.SpacedRune(q().rune.unwrap(), q().spacers.map(Number).unwrapOr(0)).toString()
                        } : {},
                        ...q().symbol.isSome() ? {
                            symbol: q().symbol.unwrap()
                        } : {},
                        ...q().terms.isSome() ? {
                            terms: {
                                ...U().amount.isSome() ? {
                                    amount: U().amount.unwrap()
                                } : {},
                                ...U().cap.isSome() ? {
                                    cap: U().cap.unwrap()
                                } : {},
                                ...U().height.find((Q)=>Q.isSome()) ? {
                                    height: {
                                        ...U().height[0].isSome() ? {
                                            start: U().height[0].unwrap()
                                        } : {},
                                        ...U().height[1].isSome() ? {
                                            end: U().height[1].unwrap()
                                        } : {}
                                    }
                                } : {},
                                ...U().offset.find((Q)=>Q.isSome()) ? {
                                    offset: {
                                        ...U().offset[0].isSome() ? {
                                            start: U().offset[0].unwrap()
                                        } : {},
                                        ...U().offset[1].isSome() ? {
                                            end: U().offset[1].unwrap()
                                        } : {}
                                    }
                                } : {}
                            }
                        } : {},
                        turbo: q().turbo
                    }
                } : {},
                ...ee.mint.isSome() ? {
                    mint: {
                        block: ee.mint.unwrap().block,
                        tx: Number(ee.mint.unwrap().tx)
                    }
                } : {},
                ...ee.pointer.isSome() ? {
                    pointer: Number(ee.pointer.unwrap())
                } : {},
                ...ee.edicts.length ? {
                    edicts: ee.edicts.map((Q)=>({
                            id: {
                                block: Q.id.block,
                                tx: Number(Q.id.tx)
                            },
                            amount: Q.amount,
                            output: Number(Q.output)
                        }))
                } : {}
            };
        } else {
            const ee = ne;
            return {
                flaws: ee.flaws.map(h),
                ...ee.etching.isSome() ? {
                    etching: ee.etching.unwrap().toString()
                } : {},
                ...ee.mint.isSome() ? {
                    mint: {
                        block: ee.mint.unwrap().block,
                        tx: Number(ee.mint.unwrap().tx)
                    }
                } : {}
            };
        }
    }
    e.tryDecodeRunestone = z;
})(l2e);
const A2e = ({ runeId: e, amount: t, divisibility: r = 0, sendOutputIndex: n = 1, pointer: i1 = 0 })=>{
    r === 0 && (t = Math.floor(t));
    const o = Ol(BigInt(22)).varint, a = Ol(BigInt(i1)).varint, s = Ol(BigInt(0)).varint, c = Ol(BigInt(t * 10 ** r)).varint, l = Ol(BigInt(n)).varint, u = e.split(":"), f = Number(u[0]), h = Number(u[1]), y = Ol(BigInt(f)).varint, S = Ol(BigInt(h)).varint, k = Ke.concat([
        o,
        a,
        s,
        y,
        S,
        c,
        l
    ]);
    let P = k.byteLength.toString(16);
    return P.length % 2 !== 0 && (P = "0" + k.byteLength.toString(16)), Ke.concat([
        Ke.from("6a", "hex"),
        Ke.from("5d", "hex"),
        Ke.from(P, "hex"),
        k
    ]);
}, Kb = async (e, t)=>{
    const r = JSON.stringify({
        jsonrpc: "2.0",
        id: e,
        method: e,
        params: t
    });
    return await un.post(`${KM}/${Kd}`, r, {
        headers: {
            "content-type": "application/json"
        }
    }).then((n)=>n.data).catch((n)=>{
        throw n;
    });
}, v2e = async (e)=>(await Kb("ord_address", [
        e
    ])).result, cj = async (e)=>(await Kb("ord_rune", [
        e
    ])).result, E2e = async (e)=>(await Kb("ord_rune", [
        e
    ])).result, S2e = async ({ outpoints: e, rune_name: t })=>{
    const r = [];
    for(let n = 0; n < e.length; n += 1e3){
        const i1 = e.slice(n, n + 1e3), o = i1.map((c)=>[
                "ord_output",
                [
                    c
                ]
            ]), { result: a } = await Kb("sandshrew_multicall", o);
        for(let c = 0; c < a.length; c++)a[c].result.output = i1[c];
        const s = a.filter((c)=>Object.keys(c.result.runes).includes(t));
        r.push(...s);
    }
    return r;
}, x2e = async ({ ordOutputs: e })=>{
    var t;
    const r = [];
    for(let n = 0; n < e.length; n++){
        const i1 = e[n], { result: o } = i1;
        if (!((t = o.output) != null && t.split(":"))) throw new Error("No output found");
        const { output: a, address: s, runes: c } = o, l = {
            output: a,
            wallet_addr: s,
            script: "",
            balances: [],
            decimals: [],
            rune_ids: [],
            value: o.value
        }, [u, f] = a.split(":");
        if (console.log(u, f, a), l.script = Ke.from(dN(s, mn)).toString("hex"), typeof c == "object" && !Array.isArray(c)) for(const h in c)l.balances.push(c[h].amount), l.decimals.push(c[h].divisibility), l.rune_ids.push((await E2e(h)).id);
        r.push(l);
    }
    return r;
}, _2e = async ({ address: e, runeId: t })=>{
    const r = await v2e(e), { entry: n } = await cj(t), i1 = n.spaced_rune, o = await S2e({
        outpoints: r.outputs,
        rune_name: i1
    });
    return await x2e({
        ordOutputs: o
    });
}, k2e = async ({ runeId: e, amount: t, ordinalAddress: r, ordinalPublicKey: n, paymentAddress: i1, paymentPublicKey: o, toAddress: a, signPsbt: s, network: c = mn })=>{
    try {
        const l = await O2e({
            fromAddress: r,
            fromAddressPublicKey: n,
            fromPaymentAddress: i1,
            fromPaymentPublicKey: o,
            toAddress: a,
            runeId: e,
            amount: t,
            network: c
        });
        if (!l || !(l != null && l.psbtHex)) throw new Error("couldn't get commit tx");
        const u = String(l == null ? void 0 : l.psbtHex), f = String(l == null ? void 0 : l.psbtBase64), h = await s({
            tx: u,
            psbtHex: u,
            psbtBase64: f,
            finalize: !0,
            broadcast: !1,
            network: c
        });
        if (!h) throw new Error("sign psbt failed");
        const y = zr.fromHex((h == null ? void 0 : h.signedPsbtHex) || "").extractTransaction();
        return await cb(y.toHex(), c);
    } catch (l) {
        throw l;
    }
}, O2e = async ({ fromAddress: e, fromAddressPublicKey: t, fromPaymentAddress: r, fromPaymentPublicKey: n, toAddress: i1, runeId: o, amount: a, network: s })=>{
    try {
        const { fastestFee: c } = await fN(s);
        let l = (await d5(r, s)).sort((ne, ee)=>ee.value - ne.value).filter((ne)=>ne.value > 3e3);
        if (l.length === 0) throw new Error("No utxos found");
        let u = new zr({
            network: Vr(s)
        }), f = 0;
        const h = await cj(o), y = await _2e({
            runeId: o,
            address: e
        }), S = ub(l), k = f5(y.length, 2, 4);
        let P = k * c < 250 ? 250 : k * c, M = 0;
        for await (const ne of y){
            const { output: ee, value: q, script: U } = ne, Q = ee.split(":"), v = Q[0], B = Q[1];
            u.addInput({
                hash: v,
                index: parseInt(B),
                witnessUtxo: {
                    value: BigInt(q),
                    script: Ke.from(U, "hex")
                },
                tapInternalKey: Zo(Ke.from(t, "hex"))
            }), M++, f += q;
        }
        const N = bb(r, s);
        for(let ne = 0; ne < l.length; ne++){
            const ee = Ma(r, Vr(mn)), q = l[ne];
            if (N === sf && u.addInput({
                hash: q.txid,
                index: q.vout,
                witnessUtxo: {
                    value: BigInt(q.value),
                    script: ee
                },
                tapInternalKey: Zo(Ke.from(n, "hex"))
            }), N === d1) {
                let U = O1(n, s);
                u.addInput({
                    hash: q.txid,
                    index: q.vout,
                    witnessUtxo: {
                        value: BigInt(q.value),
                        script: ee
                    },
                    redeemScript: U
                });
            }
            N === "p2wpkh" && u.addInput({
                hash: q.txid,
                index: q.vout,
                witnessUtxo: {
                    value: BigInt(q.value),
                    script: ee
                }
            });
        }
        const z = {
            script: A2e({
                runeId: h.id,
                amount: a,
                divisibility: h.entry.divisibility,
                sendOutputIndex: 2,
                pointer: 1
            }),
            value: BigInt(0)
        };
        u.addOutput(z);
        const K = 546, $ = S - (P + K * 2);
        return u.addOutput({
            value: BigInt(K),
            address: e
        }), u.addOutput({
            value: BigInt(K),
            address: i1
        }), u.addOutput({
            address: r,
            value: BigInt($)
        }), {
            psbtBase64: u.toBase64(),
            psbtHex: u.toHex()
        };
    } catch (c) {
        throw c;
    }
}, I2e = (e, t)=>`{"p":"brc-20","op":"transfer","tick":"${e}","amt":"${t}"}`, B2e = async ({ ticker: e, amount: t, ordinalAddress: r, ordinalPublicKey: n, paymentAddress: i1, paymentPublicKey: o, toAddress: a, signPsbt: s, dataSourceManager: c, network: l = mn })=>{
    let u;
    if (c ? u = c : u = ff.getInstance(), !u) throw new Error("Data source not found");
    if (!(u != null && u.getAddressBrc20Balances)) throw new Error("Data source not found");
    if (!await (u == null ? void 0 : u.getAddressBrc20Balances(r))) throw new Error("Address balance not found");
    const f = I2e(e, t), h = await aj({
        contentBase64: btoa(f),
        mimeType: "text/plain",
        ordinalAddress: r,
        paymentAddress: i1,
        paymentPublicKey: o,
        signPsbt: s,
        dataSourceManager: u,
        network: l
    });
    await u.waitForTransaction(h);
    const { fastFee: y } = await u.getRecommendedFees(), S = 5 * 34 * 1, k = Math.floor(S * y * 1);
    await new Promise((Q)=>setTimeout(Q, 1e4));
    const P = (await u.getAddressUtxos(i1)).filter((Q)=>Q.value > 3e3).sort((Q, v)=>v.value - Q.value);
    if (ub(P) < k) throw new Error("insufficient funds");
    console.log("inscriptionTxId", h);
    const M = new zr({
        network: Vr(l)
    }), N = Ma(r, Vr(l));
    M.addInput({
        hash: h,
        index: 0,
        witnessUtxo: {
            script: N,
            value: BigInt(546)
        },
        tapInternalKey: Zo(Ke.from(n, "hex"))
    }), M.addOutput({
        address: a,
        value: BigInt(546)
    });
    let z = 0, K = 0;
    for await (const Q of P){
        const v = Ma(i1, Vr(l)), B = bb(i1, l);
        if (M.addInput({
            hash: Q.txid,
            index: Q.vout,
            witnessUtxo: {
                value: BigInt(Q.value),
                script: v
            },
            tapInternalKey: Zo(Ke.from(o, "hex"))
        }), B === d1) {
            const g = O1(o, l);
            M.updateInput(z, {
                redeemScript: g
            });
        }
        if (z++, K += Q.value, K > k) {
            console.log("BREAKING");
            break;
        }
    }
    const $ = K - k;
    $ > 546 && M.addOutput({
        value: BigInt($),
        address: i1
    });
    const ne = M == null ? void 0 : M.toHex(), ee = M == null ? void 0 : M.toBase64(), q = await s({
        tx: "",
        psbtHex: ne,
        psbtBase64: ee,
        finalize: !0,
        broadcast: !0,
        network: l
    });
    if (!q) throw new Error("sign psbt failed");
    const U = zr.fromHex((q == null ? void 0 : q.signedPsbtHex) || "").extractTransaction();
    return await cb(U.toHex(), l);
}, T2e = async ({ inscriptionIds: e, ordinalAddress: t, ordinalPublicKey: r, paymentAddress: n, paymentPublicKey: i1, toAddress: o, signPsbt: a, dataSourceManager: s, network: c = mn })=>{
    try {
        const l = await P2e({
            inscriptionIds: e,
            fromAddress: t,
            fromAddressPublicKey: r,
            fromPaymentAddress: n,
            fromPaymentPublicKey: i1,
            dataSourceManager: s,
            toAddress: o,
            network: c
        });
        if (!l || !(l != null && l.psbtHex)) throw new Error("couldn't get commit tx");
        const u = String(l == null ? void 0 : l.psbtHex), f = String(l == null ? void 0 : l.psbtBase64), h = await a({
            tx: "",
            psbtHex: u,
            psbtBase64: f,
            finalize: !0,
            broadcast: !1,
            network: c
        });
        if (!h) throw new Error("sign psbt failed");
        const y = zr.fromHex((h == null ? void 0 : h.signedPsbtHex) || "").extractTransaction();
        return await cb(y.toHex(), c);
    } catch (l) {
        throw l;
    }
}, P2e = async ({ fromAddress: e, fromAddressPublicKey: t, fromPaymentAddress: r, fromPaymentPublicKey: n, toAddress: i1, inscriptionIds: o, dataSourceManager: a, network: s })=>{
    try {
        const { fastestFee: c } = await fN(s);
        let l = (await a.getAddressUtxos(r)).sort((z, K)=>K.value - z.value).filter((z)=>z.value > 3e3);
        if (l.length === 0) throw new Error("No utxos found");
        const u = a.getSource("sandshrew");
        if (!u || !u.batchOrdInscriptionInfo) throw new Error("Sandshrew data source not found");
        const f = await (u == null ? void 0 : u.batchOrdInscriptionInfo(o));
        console.log(f);
        let h = new zr({
            network: Vr(s)
        });
        const y = ub(l), S = f5(f.length, 2, 4);
        let k = S * c < 250 ? 250 : S * c, P = 0;
        for await (const z of f){
            const { value: K, satpoint: $ } = z, [ne, ee] = $.split(":");
            if (!K || !ne || !ee) throw new Error("Invalid satpoint or value");
            const q = Ma(e, Vr(mn));
            h.addInput({
                hash: ne,
                index: parseInt(ee),
                witnessUtxo: {
                    value: BigInt(K),
                    script: q
                },
                tapInternalKey: Zo(Ke.from(t, "hex"))
            }), h.addOutput({
                value: BigInt(K),
                address: i1
            }), P++;
        }
        const M = bb(r, s);
        for(let z = 0; z < l.length; z++){
            const K = Ma(r, Vr(mn)), $ = l[z];
            if (M === sf && h.addInput({
                hash: $.txid,
                index: $.vout,
                witnessUtxo: {
                    value: BigInt($.value),
                    script: K
                },
                tapInternalKey: Zo(Ke.from(n, "hex"))
            }), M === d1) {
                let ne = O1(n, s);
                h.addInput({
                    hash: $.txid,
                    index: $.vout,
                    witnessUtxo: {
                        value: BigInt($.value),
                        script: K
                    },
                    redeemScript: ne
                });
            }
            M === "p2wpkh" && h.addInput({
                hash: $.txid,
                index: $.vout,
                witnessUtxo: {
                    value: BigInt($.value),
                    script: K
                }
            });
        }
        const N = y - k;
        return h.addOutput({
            address: e,
            value: BigInt(N)
        }), {
            psbtBase64: h.toBase64(),
            psbtHex: h.toHex()
        };
    } catch (c) {
        throw c;
    }
}, nB = new Error("The connected wallet doesn't support this method..."), C2e = new Error("Wallet is not installed");
class ra {
    constructor(t, r, n){
        wt(this, "$store"), wt(this, "$network"), wt(this, "dataSourceManager"), wt(this, "send", async (i1, o)=>{
            switch(i1){
                case Md:
                    {
                        const a = o;
                        return await this.sendBTC(a.toAddress, a.amount);
                    }
                case wO:
                    {
                        if (this.$network.get() !== mn) throw new Error("Unsupported network");
                        const a = o;
                        if (!a.runeId || !a.amount || !a.toAddress) throw new Error("Missing required parameters");
                        return await k2e({
                            runeId: a.runeId,
                            amount: a.amount,
                            ordinalAddress: this.$store.get().address,
                            ordinalPublicKey: this.$store.get().publicKey,
                            paymentAddress: this.$store.get().paymentAddress,
                            paymentPublicKey: this.$store.get().paymentPublicKey,
                            toAddress: a.toAddress,
                            signPsbt: this.signPsbt.bind(this),
                            network: this.$network.get()
                        });
                    }
                case bO:
                    {
                        if (this.$network.get() !== mn) throw new Error("Unsupported network");
                        const a = o;
                        if (!a.ticker || !a.amount || !a.toAddress) throw new Error("Missing required parameters");
                        return await B2e({
                            ticker: a.ticker,
                            amount: a.amount,
                            ordinalAddress: this.$store.get().address,
                            ordinalPublicKey: this.$store.get().publicKey,
                            paymentAddress: this.$store.get().paymentAddress,
                            paymentPublicKey: this.$store.get().paymentPublicKey,
                            signPsbt: this.signPsbt.bind(this),
                            toAddress: a.toAddress,
                            dataSourceManager: this.dataSourceManager,
                            network: this.$network.get()
                        });
                    }
                case G8:
                    {
                        const a = o;
                        if (!a.id || !a.amount || !a.toAddress) throw new Error("Missing required parameters");
                        return await new wR(this.parent).send(a.id, a.amount, a.toAddress);
                    }
                default:
                    throw new Error("Unsupported protocol");
            }
        }), this.parent = r, this.config = n, this.$store = t.$store, this.$network = t.$network, this.config = n;
        try {
            this.dataSourceManager = ff.getInstance();
        } catch  {
            ff.init(n), this.dataSourceManager = ff.getInstance();
        }
        this.initialize();
    }
    disconnect() {}
    async requestAccounts() {
        return this.$store.get().accounts;
    }
    async switchNetwork(t) {
        throw this.parent.disconnect(), nB;
    }
    async getNetwork() {
        const { address: t } = this.$store.get();
        return t.slice(0, 1) === "t" && [
            Ki,
            _o,
            Xo,
            ko
        ].includes(this.$network.get()) ? this.$network.get() : mn;
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async getBalance() {
        if (!this.dataSourceManager.getAddressBtcBalance) throw new Error("Method not found on data source");
        return await this.dataSourceManager.getAddressBtcBalance(this.$store.get().paymentAddress);
    }
    async getMetaBalances(t) {
        switch(t){
            case Md:
                return await this.getBalance();
            case wO:
                {
                    if (this.$network.get() !== mn) throw new Error("Unsupported network");
                    if (!this.dataSourceManager.getAddressRunesBalances) throw new Error("Method not found on data source");
                    return await this.dataSourceManager.getAddressRunesBalances(this.$store.get().address);
                }
            case bO:
                if (!this.dataSourceManager.getAddressBrc20Balances) throw new Error("Method not found on data source");
                return await this.dataSourceManager.getAddressBrc20Balances(this.$store.get().address);
            case G8:
                if (!this.dataSourceManager.getAddressAlkanesBalances) throw new Error("Method not found on data source");
                return await this.dataSourceManager.getAddressAlkanesBalances(this.$store.get().address);
            default:
                throw new Error("Unsupported protocol");
        }
    }
    async getInscriptions(t, r) {
        if (!this.dataSourceManager.getAddressInscriptions) throw new Error("Method not found on data source");
        return await this.dataSourceManager.getAddressInscriptions(this.$store.get().address, t, r);
    }
    async signPsbts(t) {
        throw nB;
    }
    async pushPsbt(t) {
        let r = t;
        return r.startsWith("02") || (r = zr.fromHex(r).extractTransaction().toHex()), await cb(r, this.$network.get());
    }
    async inscribe(t, r, n, i1) {
        return await aj({
            contentBase64: t,
            mimeType: r,
            ordinalAddress: this.$store.get().address,
            paymentAddress: this.$store.get().paymentAddress,
            paymentPublicKey: this.$store.get().paymentPublicKey,
            signPsbt: this.signPsbt.bind(this),
            dataSourceManager: n || this.dataSourceManager,
            opReturn: i1,
            network: this.$network.get()
        });
    }
    async sendInscriptions(t, r) {
        if ((await this.getInscriptions()).filter((n)=>t.includes(n.id)).length !== t.length) throw new Error("Missing inscriptions");
        return await T2e({
            inscriptionIds: t,
            ordinalAddress: this.$store.get().address,
            ordinalPublicKey: this.$store.get().publicKey,
            paymentAddress: this.$store.get().paymentAddress,
            paymentPublicKey: this.$store.get().paymentPublicKey,
            toAddress: r,
            signPsbt: this.signPsbt.bind(this),
            dataSourceManager: this.dataSourceManager,
            network: this.$network.get()
        });
    }
    getDeviceInfo() {
        const t = navigator.userAgent.toLowerCase(), r = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(t), n = /ipad|android(?!.*mobile)|tablet/i.test(t), i1 = "ontouchstart" in window || navigator.maxTouchPoints > 0, o = window.innerWidth <= 768;
        let a;
        return n ? a = "tablet" : r || i1 && o ? a = "mobile" : a = "desktop", {
            isMobile: a === "mobile" || a === "tablet",
            isDesktop: a === "desktop",
            deviceType: a,
            userAgent: navigator.userAgent
        };
    }
    isMobile() {
        return this.getDeviceInfo().isMobile;
    }
    isDesktop() {
        return this.getDeviceInfo().isDesktop;
    }
    getSuggestedConnectionMethod() {
        const t = this.getDeviceInfo();
        return t.deviceType === "mobile" ? "deep-link" : t.deviceType === "tablet" ? "qr-code" : "browser-extension";
    }
}
class M2e extends ra {
    constructor(){
        super(...arguments), wt(this, "observer"), wt(this, "handleNetworkChanged", (t)=>{
            const r = t === "mainnet" ? pt.MAINNET : t === "testnet" ? pt.TESTNET : pt.SIGNET;
            this.network !== r && this.connect(Hl);
        });
    }
    get library() {
        var t;
        return ((t = window.keplr) == null ? void 0 : t.bitcoin) ?? window.bitcoin_keplr;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Hl]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            var r;
            if (t.provider !== Hl) {
                this == null || this.removeListeners();
                return;
            }
            (r = this.library) == null || r.getAccounts().then((n)=>{
                this.handleAccountsChanged(n);
            }), this.addListeners();
        });
    }
    addListeners() {
        var t, r;
        (t = this.library) == null || t.on("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var t, r;
        (t = this.library) == null || t.off("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.off("networkChanged", this.handleNetworkChanged.bind(this));
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(t) {
        if (!t.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Hl) : this.parent.disconnect());
    }
    async connect(t) {
        if (!this.library) if (this.isMobile()) {
            const o = `https://deeplink.keplr.app/web-browser?url=${window.location.href}`, a = window.open(o);
            if (!a) throw new Error("Keplr wallet not found");
            return a.focus(), !1;
        } else throw new Error("Keplr wallet not found");
        const r = await this.library.requestAccounts();
        if (!r) throw new Error("No accounts found");
        const n = await this.library.getPublicKey();
        if (!n) throw new Error("No public key found");
        this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n);
        const i1 = await this.getNetwork();
        this.$network.set(i1);
    }
    async getNetwork() {
        var t;
        const r = await ((t = this.library) == null ? void 0 : t.getChain());
        return r ? bre(r.enum) : this.network;
    }
    async sendBTC(t, r) {
        var n;
        const i1 = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
        if (!i1) throw new Error("Transaction failed");
        return i1;
    }
    async signMessage(t, r) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const n = (r == null ? void 0 : r.protocol) === mb ? k1 : r == null ? void 0 : r.protocol;
        return await this.library.signMessage(t, n);
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const o = await this.library.signPsbt(t, Af({
            autoFinalized: n,
            toSignInputs: i1
        })), a = zr.fromHex(o);
        if (n && r) {
            const s = await this.pushPsbt(o);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: s
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        var t;
        return await ((t = this.library) == null ? void 0 : t.getPublicKey());
    }
    async getBalance() {
        if (!this.library) throw new Error("Keplr isn't installed");
        return (await this.library.getBalance()).total;
    }
    async requestAccounts() {
        if (!this.library) throw new Error("Keplr isn't installed");
        return await this.library.requestAccounts();
    }
    async switchNetwork(t) {
        if (!this.library) throw new Error("Keplr isn't installed");
        const r = [
            pt.MAINNET,
            pt.TESTNET,
            pt.SIGNET
        ];
        if (!r.includes(t)) throw new Error(`Invalid network: ${t}. Keplr supports ${r.join(", ")}`);
        const n = yre(t);
        await this.library.switchChain(n);
    }
}
var Gr;
(function(e) {
    e.assertEqual = (i1)=>i1;
    function t(i1) {}
    e.assertIs = t;
    function r(i1) {
        throw new Error();
    }
    e.assertNever = r, e.arrayToEnum = (i1)=>{
        const o = {};
        for (const a of i1)o[a] = a;
        return o;
    }, e.getValidEnumValues = (i1)=>{
        const o = e.objectKeys(i1).filter((s)=>typeof i1[i1[s]] != "number"), a = {};
        for (const s of o)a[s] = i1[s];
        return e.objectValues(a);
    }, e.objectValues = (i1)=>e.objectKeys(i1).map(function(o) {
            return i1[o];
        }), e.objectKeys = typeof Object.keys == "function" ? (i1)=>Object.keys(i1) : (i1)=>{
        const o = [];
        for(const a in i1)Object.prototype.hasOwnProperty.call(i1, a) && o.push(a);
        return o;
    }, e.find = (i1, o)=>{
        for (const a of i1)if (o(a)) return a;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i1)=>Number.isInteger(i1) : (i1)=>typeof i1 == "number" && isFinite(i1) && Math.floor(i1) === i1;
    function n(i1, o = " | ") {
        return i1.map((a)=>typeof a == "string" ? `'${a}'` : a).join(o);
    }
    e.joinValues = n, e.jsonStringifyReplacer = (i1, o)=>typeof o == "bigint" ? o.toString() : o;
})(Gr || (Gr = {}));
var z4;
(function(e) {
    e.mergeShapes = (t, r)=>({
            ...t,
            ...r
        });
})(z4 || (z4 = {}));
const Bt = Gr.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), Ou = (e)=>{
    switch(typeof e){
        case "undefined":
            return Bt.undefined;
        case "string":
            return Bt.string;
        case "number":
            return isNaN(e) ? Bt.nan : Bt.number;
        case "boolean":
            return Bt.boolean;
        case "function":
            return Bt.function;
        case "bigint":
            return Bt.bigint;
        case "symbol":
            return Bt.symbol;
        case "object":
            return Array.isArray(e) ? Bt.array : e === null ? Bt.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Bt.promise : typeof Map < "u" && e instanceof Map ? Bt.map : typeof Set < "u" && e instanceof Set ? Bt.set : typeof Date < "u" && e instanceof Date ? Bt.date : Bt.object;
        default:
            return Bt.unknown;
    }
}, gt = Gr.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]), N2e = (e)=>JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Yo extends Error {
    get errors() {
        return this.issues;
    }
    constructor(t){
        super(), this.issues = [], this.addIssue = (n)=>{
            this.issues = [
                ...this.issues,
                n
            ];
        }, this.addIssues = (n = [])=>{
            this.issues = [
                ...this.issues,
                ...n
            ];
        };
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    format(t) {
        const r = t || function(o) {
            return o.message;
        }, n = {
            _errors: []
        }, i1 = (o)=>{
            for (const a of o.issues)if (a.code === "invalid_union") a.unionErrors.map(i1);
            else if (a.code === "invalid_return_type") i1(a.returnTypeError);
            else if (a.code === "invalid_arguments") i1(a.argumentsError);
            else if (a.path.length === 0) n._errors.push(r(a));
            else {
                let s = n, c = 0;
                for(; c < a.path.length;){
                    const l = a.path[c];
                    c === a.path.length - 1 ? (s[l] = s[l] || {
                        _errors: []
                    }, s[l]._errors.push(r(a))) : s[l] = s[l] || {
                        _errors: []
                    }, s = s[l], c++;
                }
            }
        };
        return i1(this), n;
    }
    static assert(t) {
        if (!(t instanceof Yo)) throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, Gr.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(t = (r)=>r.message) {
        const r = {}, n = [];
        for (const i1 of this.issues)i1.path.length > 0 ? (r[i1.path[0]] = r[i1.path[0]] || [], r[i1.path[0]].push(t(i1))) : n.push(t(i1));
        return {
            formErrors: n,
            fieldErrors: r
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
Yo.create = (e)=>new Yo(e);
const kh = (e, t)=>{
    let r;
    switch(e.code){
        case gt.invalid_type:
            e.received === Bt.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
            break;
        case gt.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(e.expected, Gr.jsonStringifyReplacer)}`;
            break;
        case gt.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${Gr.joinValues(e.keys, ", ")}`;
            break;
        case gt.invalid_union:
            r = "Invalid input";
            break;
        case gt.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${Gr.joinValues(e.options)}`;
            break;
        case gt.invalid_enum_value:
            r = `Invalid enum value. Expected ${Gr.joinValues(e.options)}, received '${e.received}'`;
            break;
        case gt.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case gt.invalid_return_type:
            r = "Invalid function return type";
            break;
        case gt.invalid_date:
            r = "Invalid date";
            break;
        case gt.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Gr.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
            break;
        case gt.too_small:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
            break;
        case gt.too_big:
            e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
            break;
        case gt.custom:
            r = "Invalid input";
            break;
        case gt.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case gt.not_multiple_of:
            r = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case gt.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = t.defaultError, Gr.assertNever(e);
    }
    return {
        message: r
    };
};
let lj = kh;
function R2e(e) {
    lj = e;
}
function l2() {
    return lj;
}
const f2 = (e)=>{
    const { data: t, path: r, errorMaps: n, issueData: i1 } = e, o = [
        ...r,
        ...i1.path || []
    ], a = {
        ...i1,
        path: o
    };
    if (i1.message !== void 0) return {
        ...i1,
        path: o,
        message: i1.message
    };
    let s = "";
    const c = n.filter((l)=>!!l).slice().reverse();
    for (const l of c)s = l(a, {
        data: t,
        defaultError: s
    }).message;
    return {
        ...i1,
        path: o,
        message: s
    };
}, U2e = [];
function xt(e, t) {
    const r = l2(), n = f2({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [
            e.common.contextualErrorMap,
            // contextual error map is first priority
            e.schemaErrorMap,
            // then schema-bound map if available
            r,
            // then global override map
            r === kh ? void 0 : kh
        ].filter((i1)=>!!i1)
    });
    e.common.issues.push(n);
}
class Gi {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
        const n = [];
        for (const i1 of r){
            if (i1.status === "aborted") return ir;
            i1.status === "dirty" && t.dirty(), n.push(i1.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const i1 of r){
            const o = await i1.key, a = await i1.value;
            n.push({
                key: o,
                value: a
            });
        }
        return Gi.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const i1 of r){
            const { key: o, value: a } = i1;
            if (o.status === "aborted" || a.status === "aborted") return ir;
            o.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof a.value < "u" || i1.alwaysSet) && (n[o.value] = a.value);
        }
        return {
            status: t.value,
            value: n
        };
    }
}
const ir = Object.freeze({
    status: "aborted"
}), d2 = (e)=>({
        status: "dirty",
        value: e
    }), so = (e)=>({
        status: "valid",
        value: e
    }), L4 = (e)=>e.status === "aborted", H4 = (e)=>e.status === "dirty", xf = (e)=>e.status === "valid", H0 = (e)=>typeof Promise < "u" && e instanceof Promise;
function h2(e, t, r, n) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t.get(e);
}
function fj(e, t, r, n, i1) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, r), r;
}
var Ft;
(function(e) {
    e.errToObj = (t)=>typeof t == "string" ? {
            message: t
        } : t || {}, e.toString = (t)=>typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Ft || (Ft = {}));
var zp, Lp;
class $s {
    constructor(t, r, n, i1){
        this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i1;
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
}
const iB = (e, t)=>{
    if (xf(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const r = new Yo(e.common.issues);
            return this._error = r, this._error;
        }
    };
};
function mr(e) {
    if (!e) return {};
    const { errorMap: t, invalid_type_error: r, required_error: n, description: i1 } = e;
    if (t && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i1
    } : {
        errorMap: (o, a)=>{
            var s, c;
            const { message: l } = e;
            return o.code === "invalid_enum_value" ? {
                message: l ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: (s = l ?? n) !== null && s !== void 0 ? s : a.defaultError
            } : o.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: (c = l ?? r) !== null && c !== void 0 ? c : a.defaultError
            };
        },
        description: i1
    };
}
class Ir {
    get description() {
        return this._def.description;
    }
    _getType(t) {
        return Ou(t.data);
    }
    _getOrReturnCtx(t, r) {
        return r || {
            common: t.parent.common,
            data: t.data,
            parsedType: Ou(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        };
    }
    _processInputParams(t) {
        return {
            status: new Gi(),
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: Ou(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        };
    }
    _parseSync(t) {
        const r = this._parse(t);
        if (H0(r)) throw new Error("Synchronous parse encountered promise.");
        return r;
    }
    _parseAsync(t) {
        const r = this._parse(t);
        return Promise.resolve(r);
    }
    parse(t, r) {
        const n = this.safeParse(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    safeParse(t, r) {
        var n;
        const i1 = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Ou(t)
        }, o = this._parseSync({
            data: t,
            path: i1.path,
            parent: i1
        });
        return iB(i1, o);
    }
    "~validate"(t) {
        var r, n;
        const i1 = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Ou(t)
        };
        if (!this["~standard"].async) try {
            const o = this._parseSync({
                data: t,
                path: [],
                parent: i1
            });
            return xf(o) ? {
                value: o.value
            } : {
                issues: i1.common.issues
            };
        } catch (o) {
            !((n = (r = o == null ? void 0 : o.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0), i1.common = {
                issues: [],
                async: !0
            };
        }
        return this._parseAsync({
            data: t,
            path: [],
            parent: i1
        }).then((o)=>xf(o) ? {
                value: o.value
            } : {
                issues: i1.common.issues
            });
    }
    async parseAsync(t, r) {
        const n = await this.safeParseAsync(t, r);
        if (n.success) return n.data;
        throw n.error;
    }
    async safeParseAsync(t, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Ou(t)
        }, i1 = this._parse({
            data: t,
            path: n.path,
            parent: n
        }), o = await (H0(i1) ? i1 : Promise.resolve(i1));
        return iB(n, o);
    }
    refine(t, r) {
        const n = (i1)=>typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(i1) : r;
        return this._refinement((i1, o)=>{
            const a = t(i1), s = ()=>o.addIssue({
                    code: gt.custom,
                    ...n(i1)
                });
            return typeof Promise < "u" && a instanceof Promise ? a.then((c)=>c ? !0 : (s(), !1)) : a ? !0 : (s(), !1);
        });
    }
    refinement(t, r) {
        return this._refinement((n, i1)=>t(n) ? !0 : (i1.addIssue(typeof r == "function" ? r(n, i1) : r), !1));
    }
    _refinement(t) {
        return new fs({
            schema: this,
            typeName: er.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        });
    }
    superRefine(t) {
        return this._refinement(t);
    }
    constructor(t){
        this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (r)=>this["~validate"](r)
        };
    }
    optional() {
        return Vs.create(this, this._def);
    }
    nullable() {
        return ol.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return us.create(this);
    }
    promise() {
        return Ih.create(this, this._def);
    }
    or(t) {
        return W0.create([
            this,
            t
        ], this._def);
    }
    and(t) {
        return G0.create(this, t, this._def);
    }
    transform(t) {
        return new fs({
            ...mr(this._def),
            schema: this,
            typeName: er.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        });
    }
    default(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new Y0({
            ...mr(this._def),
            innerType: this,
            defaultValue: r,
            typeName: er.ZodDefault
        });
    }
    brand() {
        return new v7({
            typeName: er.ZodBranded,
            type: this,
            ...mr(this._def)
        });
    }
    catch(t) {
        const r = typeof t == "function" ? t : ()=>t;
        return new J0({
            ...mr(this._def),
            innerType: this,
            catchValue: r,
            typeName: er.ZodCatch
        });
    }
    describe(t) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: t
        });
    }
    pipe(t) {
        return q1.create(this, t);
    }
    readonly() {
        return e1.create(this);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const D2e = /^c[^\s-]{8,}$/i, j2e = /^[0-9a-z]+$/, F2e = /^[0-9A-HJKMNP-TV-Z]{26}$/i, z2e = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, L2e = /^[a-z0-9_-]{21}$/i, H2e = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, K2e = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, q2e = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, V2e = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let i8;
const W2e = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, G2e = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Q2e = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, $2e = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Z2e = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, X2e = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dj = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Y2e = new RegExp(`^${dj}$`);
function hj(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function J2e(e) {
    return new RegExp(`^${hj(e)}$`);
}
function pj(e) {
    let t = `${dj}T${hj(e)}`;
    const r = [];
    return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
}
function ebe(e, t) {
    return !!((t === "v4" || !t) && W2e.test(e) || (t === "v6" || !t) && Q2e.test(e));
}
function tbe(e, t) {
    if (!H2e.test(e)) return !1;
    try {
        const [r] = e.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), i1 = JSON.parse(atob(n));
        return !(typeof i1 != "object" || i1 === null || !i1.typ || !i1.alg || t && i1.alg !== t);
    } catch  {
        return !1;
    }
}
function rbe(e, t) {
    return !!((t === "v4" || !t) && G2e.test(e) || (t === "v6" || !t) && $2e.test(e));
}
class ns extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Bt.string) {
            const i1 = this._getOrReturnCtx(t);
            return xt(i1, {
                code: gt.invalid_type,
                expected: Bt.string,
                received: i1.parsedType
            }), ir;
        }
        const r = new Gi();
        let n;
        for (const i1 of this._def.checks)if (i1.kind === "min") t.data.length < i1.value && (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.too_small,
            minimum: i1.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "max") t.data.length > i1.value && (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.too_big,
            maximum: i1.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "length") {
            const o = t.data.length > i1.value, a = t.data.length < i1.value;
            (o || a) && (n = this._getOrReturnCtx(t, n), o ? xt(n, {
                code: gt.too_big,
                maximum: i1.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i1.message
            }) : a && xt(n, {
                code: gt.too_small,
                minimum: i1.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i1.message
            }), r.dirty());
        } else if (i1.kind === "email") q2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "email",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "emoji") i8 || (i8 = new RegExp(V2e, "u")), i8.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "emoji",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "uuid") z2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "uuid",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "nanoid") L2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "nanoid",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "cuid") D2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "cuid",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "cuid2") j2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "cuid2",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "ulid") F2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "ulid",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty());
        else if (i1.kind === "url") try {
            new URL(t.data);
        } catch  {
            n = this._getOrReturnCtx(t, n), xt(n, {
                validation: "url",
                code: gt.invalid_string,
                message: i1.message
            }), r.dirty();
        }
        else i1.kind === "regex" ? (i1.regex.lastIndex = 0, i1.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "regex",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty())) : i1.kind === "trim" ? t.data = t.data.trim() : i1.kind === "includes" ? t.data.includes(i1.value, i1.position) || (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.invalid_string,
            validation: {
                includes: i1.value,
                position: i1.position
            },
            message: i1.message
        }), r.dirty()) : i1.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i1.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i1.kind === "startsWith" ? t.data.startsWith(i1.value) || (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.invalid_string,
            validation: {
                startsWith: i1.value
            },
            message: i1.message
        }), r.dirty()) : i1.kind === "endsWith" ? t.data.endsWith(i1.value) || (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.invalid_string,
            validation: {
                endsWith: i1.value
            },
            message: i1.message
        }), r.dirty()) : i1.kind === "datetime" ? pj(i1).test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.invalid_string,
            validation: "datetime",
            message: i1.message
        }), r.dirty()) : i1.kind === "date" ? Y2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.invalid_string,
            validation: "date",
            message: i1.message
        }), r.dirty()) : i1.kind === "time" ? J2e(i1).test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.invalid_string,
            validation: "time",
            message: i1.message
        }), r.dirty()) : i1.kind === "duration" ? K2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "duration",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty()) : i1.kind === "ip" ? ebe(t.data, i1.version) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "ip",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty()) : i1.kind === "jwt" ? tbe(t.data, i1.alg) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "jwt",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty()) : i1.kind === "cidr" ? rbe(t.data, i1.version) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "cidr",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty()) : i1.kind === "base64" ? Z2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "base64",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty()) : i1.kind === "base64url" ? X2e.test(t.data) || (n = this._getOrReturnCtx(t, n), xt(n, {
            validation: "base64url",
            code: gt.invalid_string,
            message: i1.message
        }), r.dirty()) : Gr.assertNever(i1);
        return {
            status: r.value,
            value: t.data
        };
    }
    _regex(t, r, n) {
        return this.refinement((i1)=>t.test(i1), {
            validation: r,
            code: gt.invalid_string,
            ...Ft.errToObj(n)
        });
    }
    _addCheck(t) {
        return new ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...Ft.errToObj(t)
        });
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...Ft.errToObj(t)
        });
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...Ft.errToObj(t)
        });
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...Ft.errToObj(t)
        });
    }
    nanoid(t) {
        return this._addCheck({
            kind: "nanoid",
            ...Ft.errToObj(t)
        });
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...Ft.errToObj(t)
        });
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...Ft.errToObj(t)
        });
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...Ft.errToObj(t)
        });
    }
    base64(t) {
        return this._addCheck({
            kind: "base64",
            ...Ft.errToObj(t)
        });
    }
    base64url(t) {
        return this._addCheck({
            kind: "base64url",
            ...Ft.errToObj(t)
        });
    }
    jwt(t) {
        return this._addCheck({
            kind: "jwt",
            ...Ft.errToObj(t)
        });
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...Ft.errToObj(t)
        });
    }
    cidr(t) {
        return this._addCheck({
            kind: "cidr",
            ...Ft.errToObj(t)
        });
    }
    datetime(t) {
        var r, n;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            local: (n = t == null ? void 0 : t.local) !== null && n !== void 0 ? n : !1,
            ...Ft.errToObj(t == null ? void 0 : t.message)
        });
    }
    date(t) {
        return this._addCheck({
            kind: "date",
            message: t
        });
    }
    time(t) {
        return typeof t == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: t
        }) : this._addCheck({
            kind: "time",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            ...Ft.errToObj(t == null ? void 0 : t.message)
        });
    }
    duration(t) {
        return this._addCheck({
            kind: "duration",
            ...Ft.errToObj(t)
        });
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...Ft.errToObj(r)
        });
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...Ft.errToObj(r == null ? void 0 : r.message)
        });
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...Ft.errToObj(r)
        });
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...Ft.errToObj(r)
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...Ft.errToObj(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...Ft.errToObj(r)
        });
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...Ft.errToObj(r)
        });
    }
    /**
   * Equivalent to `.min(1)`
   */ nonempty(t) {
        return this.min(1, Ft.errToObj(t));
    }
    trim() {
        return new ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new ns({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((t)=>t.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((t)=>t.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((t)=>t.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((t)=>t.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((t)=>t.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((t)=>t.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((t)=>t.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((t)=>t.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((t)=>t.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((t)=>t.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((t)=>t.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((t)=>t.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((t)=>t.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((t)=>t.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((t)=>t.kind === "base64");
    }
    get isBase64url() {
        return !!this._def.checks.find((t)=>t.kind === "base64url");
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
}
ns.create = (e)=>{
    var t;
    return new ns({
        checks: [],
        typeName: er.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...mr(e)
    });
};
function nbe(e, t) {
    const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i1 = r > n ? r : n, o = parseInt(e.toFixed(i1).replace(".", "")), a = parseInt(t.toFixed(i1).replace(".", ""));
    return o % a / Math.pow(10, i1);
}
class rl extends Ir {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Bt.number) {
            const i1 = this._getOrReturnCtx(t);
            return xt(i1, {
                code: gt.invalid_type,
                expected: Bt.number,
                received: i1.parsedType
            }), ir;
        }
        let r;
        const n = new Gi();
        for (const i1 of this._def.checks)i1.kind === "int" ? Gr.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.invalid_type,
            expected: "integer",
            received: "float",
            message: i1.message
        }), n.dirty()) : i1.kind === "min" ? (i1.inclusive ? t.data < i1.value : t.data <= i1.value) && (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.too_small,
            minimum: i1.value,
            type: "number",
            inclusive: i1.inclusive,
            exact: !1,
            message: i1.message
        }), n.dirty()) : i1.kind === "max" ? (i1.inclusive ? t.data > i1.value : t.data >= i1.value) && (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.too_big,
            maximum: i1.value,
            type: "number",
            inclusive: i1.inclusive,
            exact: !1,
            message: i1.message
        }), n.dirty()) : i1.kind === "multipleOf" ? nbe(t.data, i1.value) !== 0 && (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.not_multiple_of,
            multipleOf: i1.value,
            message: i1.message
        }), n.dirty()) : i1.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.not_finite,
            message: i1.message
        }), n.dirty()) : Gr.assertNever(i1);
        return {
            status: n.value,
            value: t.data
        };
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, Ft.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, Ft.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, Ft.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, Ft.toString(r));
    }
    setLimit(t, r, n, i1) {
        return new rl({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: Ft.toString(i1)
                }
            ]
        });
    }
    _addCheck(t) {
        return new rl({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: Ft.toString(t)
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Ft.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Ft.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Ft.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Ft.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: Ft.toString(r)
        });
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: Ft.toString(t)
        });
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Ft.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Ft.toString(t)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
    get isInt() {
        return !!this._def.checks.find((t)=>t.kind === "int" || t.kind === "multipleOf" && Gr.isInteger(t.value));
    }
    get isFinite() {
        let t = null, r = null;
        for (const n of this._def.checks){
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        }
        return Number.isFinite(r) && Number.isFinite(t);
    }
}
rl.create = (e)=>new rl({
        checks: [],
        typeName: er.ZodNumber,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...mr(e)
    });
class nl extends Ir {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
        if (this._def.coerce) try {
            t.data = BigInt(t.data);
        } catch  {
            return this._getInvalidInput(t);
        }
        if (this._getType(t) !== Bt.bigint) return this._getInvalidInput(t);
        let r;
        const n = new Gi();
        for (const i1 of this._def.checks)i1.kind === "min" ? (i1.inclusive ? t.data < i1.value : t.data <= i1.value) && (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.too_small,
            type: "bigint",
            minimum: i1.value,
            inclusive: i1.inclusive,
            message: i1.message
        }), n.dirty()) : i1.kind === "max" ? (i1.inclusive ? t.data > i1.value : t.data >= i1.value) && (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.too_big,
            type: "bigint",
            maximum: i1.value,
            inclusive: i1.inclusive,
            message: i1.message
        }), n.dirty()) : i1.kind === "multipleOf" ? t.data % i1.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), xt(r, {
            code: gt.not_multiple_of,
            multipleOf: i1.value,
            message: i1.message
        }), n.dirty()) : Gr.assertNever(i1);
        return {
            status: n.value,
            value: t.data
        };
    }
    _getInvalidInput(t) {
        const r = this._getOrReturnCtx(t);
        return xt(r, {
            code: gt.invalid_type,
            expected: Bt.bigint,
            received: r.parsedType
        }), ir;
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, Ft.toString(r));
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, Ft.toString(r));
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, Ft.toString(r));
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, Ft.toString(r));
    }
    setLimit(t, r, n, i1) {
        return new nl({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: t,
                    value: r,
                    inclusive: n,
                    message: Ft.toString(i1)
                }
            ]
        });
    }
    _addCheck(t) {
        return new nl({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Ft.toString(t)
        });
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Ft.toString(t)
        });
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Ft.toString(t)
        });
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Ft.toString(t)
        });
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: Ft.toString(r)
        });
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t;
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t;
    }
}
nl.create = (e)=>{
    var t;
    return new nl({
        checks: [],
        typeName: er.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...mr(e)
    });
};
class K0 extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Bt.boolean) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                code: gt.invalid_type,
                expected: Bt.boolean,
                received: r.parsedType
            }), ir;
        }
        return so(t.data);
    }
}
K0.create = (e)=>new K0({
        typeName: er.ZodBoolean,
        coerce: (e == null ? void 0 : e.coerce) || !1,
        ...mr(e)
    });
class _f extends Ir {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Bt.date) {
            const i1 = this._getOrReturnCtx(t);
            return xt(i1, {
                code: gt.invalid_type,
                expected: Bt.date,
                received: i1.parsedType
            }), ir;
        }
        if (isNaN(t.data.getTime())) {
            const i1 = this._getOrReturnCtx(t);
            return xt(i1, {
                code: gt.invalid_date
            }), ir;
        }
        const r = new Gi();
        let n;
        for (const i1 of this._def.checks)i1.kind === "min" ? t.data.getTime() < i1.value && (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.too_small,
            message: i1.message,
            inclusive: !0,
            exact: !1,
            minimum: i1.value,
            type: "date"
        }), r.dirty()) : i1.kind === "max" ? t.data.getTime() > i1.value && (n = this._getOrReturnCtx(t, n), xt(n, {
            code: gt.too_big,
            message: i1.message,
            inclusive: !0,
            exact: !1,
            maximum: i1.value,
            type: "date"
        }), r.dirty()) : Gr.assertNever(i1);
        return {
            status: r.value,
            value: new Date(t.data.getTime())
        };
    }
    _addCheck(t) {
        return new _f({
            ...this._def,
            checks: [
                ...this._def.checks,
                t
            ]
        });
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: Ft.toString(r)
        });
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: Ft.toString(r)
        });
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null;
    }
}
_f.create = (e)=>new _f({
        checks: [],
        coerce: (e == null ? void 0 : e.coerce) || !1,
        typeName: er.ZodDate,
        ...mr(e)
    });
class p2 extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.symbol) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                code: gt.invalid_type,
                expected: Bt.symbol,
                received: r.parsedType
            }), ir;
        }
        return so(t.data);
    }
}
p2.create = (e)=>new p2({
        typeName: er.ZodSymbol,
        ...mr(e)
    });
class q0 extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.undefined) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                code: gt.invalid_type,
                expected: Bt.undefined,
                received: r.parsedType
            }), ir;
        }
        return so(t.data);
    }
}
q0.create = (e)=>new q0({
        typeName: er.ZodUndefined,
        ...mr(e)
    });
class V0 extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.null) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                code: gt.invalid_type,
                expected: Bt.null,
                received: r.parsedType
            }), ir;
        }
        return so(t.data);
    }
}
V0.create = (e)=>new V0({
        typeName: er.ZodNull,
        ...mr(e)
    });
class Oh extends Ir {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(t) {
        return so(t.data);
    }
}
Oh.create = (e)=>new Oh({
        typeName: er.ZodAny,
        ...mr(e)
    });
class pf extends Ir {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(t) {
        return so(t.data);
    }
}
pf.create = (e)=>new pf({
        typeName: er.ZodUnknown,
        ...mr(e)
    });
class Fu extends Ir {
    _parse(t) {
        const r = this._getOrReturnCtx(t);
        return xt(r, {
            code: gt.invalid_type,
            expected: Bt.never,
            received: r.parsedType
        }), ir;
    }
}
Fu.create = (e)=>new Fu({
        typeName: er.ZodNever,
        ...mr(e)
    });
class g2 extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.undefined) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                code: gt.invalid_type,
                expected: Bt.void,
                received: r.parsedType
            }), ir;
        }
        return so(t.data);
    }
}
g2.create = (e)=>new g2({
        typeName: er.ZodVoid,
        ...mr(e)
    });
class us extends Ir {
    _parse(t) {
        const { ctx: r, status: n } = this._processInputParams(t), i1 = this._def;
        if (r.parsedType !== Bt.array) return xt(r, {
            code: gt.invalid_type,
            expected: Bt.array,
            received: r.parsedType
        }), ir;
        if (i1.exactLength !== null) {
            const a = r.data.length > i1.exactLength.value, s = r.data.length < i1.exactLength.value;
            (a || s) && (xt(r, {
                code: a ? gt.too_big : gt.too_small,
                minimum: s ? i1.exactLength.value : void 0,
                maximum: a ? i1.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i1.exactLength.message
            }), n.dirty());
        }
        if (i1.minLength !== null && r.data.length < i1.minLength.value && (xt(r, {
            code: gt.too_small,
            minimum: i1.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i1.minLength.message
        }), n.dirty()), i1.maxLength !== null && r.data.length > i1.maxLength.value && (xt(r, {
            code: gt.too_big,
            maximum: i1.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i1.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([
            ...r.data
        ].map((a, s)=>i1.type._parseAsync(new $s(r, a, r.path, s)))).then((a)=>Gi.mergeArray(n, a));
        const o = [
            ...r.data
        ].map((a, s)=>i1.type._parseSync(new $s(r, a, r.path, s)));
        return Gi.mergeArray(n, o);
    }
    get element() {
        return this._def.type;
    }
    min(t, r) {
        return new us({
            ...this._def,
            minLength: {
                value: t,
                message: Ft.toString(r)
            }
        });
    }
    max(t, r) {
        return new us({
            ...this._def,
            maxLength: {
                value: t,
                message: Ft.toString(r)
            }
        });
    }
    length(t, r) {
        return new us({
            ...this._def,
            exactLength: {
                value: t,
                message: Ft.toString(r)
            }
        });
    }
    nonempty(t) {
        return this.min(1, t);
    }
}
us.create = (e, t)=>new us({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: er.ZodArray,
        ...mr(t)
    });
function Bd(e) {
    if (e instanceof In) {
        const t = {};
        for(const r in e.shape){
            const n = e.shape[r];
            t[r] = Vs.create(Bd(n));
        }
        return new In({
            ...e._def,
            shape: ()=>t
        });
    } else return e instanceof us ? new us({
        ...e._def,
        type: Bd(e.element)
    }) : e instanceof Vs ? Vs.create(Bd(e.unwrap())) : e instanceof ol ? ol.create(Bd(e.unwrap())) : e instanceof Zs ? Zs.create(e.items.map((t)=>Bd(t))) : e;
}
class In extends Ir {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(), r = Gr.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        };
    }
    _parse(t) {
        if (this._getType(t) !== Bt.object) {
            const c = this._getOrReturnCtx(t);
            return xt(c, {
                code: gt.invalid_type,
                expected: Bt.object,
                received: c.parsedType
            }), ir;
        }
        const { status: r, ctx: n } = this._processInputParams(t), { shape: i1, keys: o } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof Fu && this._def.unknownKeys === "strip")) for(const c in n.data)o.includes(c) || a.push(c);
        const s = [];
        for (const c of o){
            const l = i1[c], u = n.data[c];
            s.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: l._parse(new $s(n, u, n.path, c)),
                alwaysSet: c in n.data
            });
        }
        if (this._def.catchall instanceof Fu) {
            const c = this._def.unknownKeys;
            if (c === "passthrough") for (const l of a)s.push({
                key: {
                    status: "valid",
                    value: l
                },
                value: {
                    status: "valid",
                    value: n.data[l]
                }
            });
            else if (c === "strict") a.length > 0 && (xt(n, {
                code: gt.unrecognized_keys,
                keys: a
            }), r.dirty());
            else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const c = this._def.catchall;
            for (const l of a){
                const u = n.data[l];
                s.push({
                    key: {
                        status: "valid",
                        value: l
                    },
                    value: c._parse(new $s(n, u, n.path, l)),
                    alwaysSet: l in n.data
                });
            }
        }
        return n.common.async ? Promise.resolve().then(async ()=>{
            const c = [];
            for (const l of s){
                const u = await l.key, f = await l.value;
                c.push({
                    key: u,
                    value: f,
                    alwaysSet: l.alwaysSet
                });
            }
            return c;
        }).then((c)=>Gi.mergeObjectSync(r, c)) : Gi.mergeObjectSync(r, s);
    }
    get shape() {
        return this._def.shape();
    }
    strict(t) {
        return Ft.errToObj, new In({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n)=>{
                    var i1, o, a, s;
                    const c = (a = (o = (i1 = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i1, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (s = Ft.errToObj(t).message) !== null && s !== void 0 ? s : c
                    } : {
                        message: c
                    };
                }
            } : {}
        });
    }
    strip() {
        return new In({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new In({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
        return new In({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(t) {
        return new In({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
            typeName: er.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
        return this.augment({
            [t]: r
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
        return new In({
            ...this._def,
            catchall: t
        });
    }
    pick(t) {
        const r = {};
        return Gr.objectKeys(t).forEach((n)=>{
            t[n] && this.shape[n] && (r[n] = this.shape[n]);
        }), new In({
            ...this._def,
            shape: ()=>r
        });
    }
    omit(t) {
        const r = {};
        return Gr.objectKeys(this.shape).forEach((n)=>{
            t[n] || (r[n] = this.shape[n]);
        }), new In({
            ...this._def,
            shape: ()=>r
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return Bd(this);
    }
    partial(t) {
        const r = {};
        return Gr.objectKeys(this.shape).forEach((n)=>{
            const i1 = this.shape[n];
            t && !t[n] ? r[n] = i1 : r[n] = i1.optional();
        }), new In({
            ...this._def,
            shape: ()=>r
        });
    }
    required(t) {
        const r = {};
        return Gr.objectKeys(this.shape).forEach((n)=>{
            if (t && !t[n]) r[n] = this.shape[n];
            else {
                let i1 = this.shape[n];
                for(; i1 instanceof Vs;)i1 = i1._def.innerType;
                r[n] = i1;
            }
        }), new In({
            ...this._def,
            shape: ()=>r
        });
    }
    keyof() {
        return gj(Gr.objectKeys(this.shape));
    }
}
In.create = (e, t)=>new In({
        shape: ()=>e,
        unknownKeys: "strip",
        catchall: Fu.create(),
        typeName: er.ZodObject,
        ...mr(t)
    });
In.strictCreate = (e, t)=>new In({
        shape: ()=>e,
        unknownKeys: "strict",
        catchall: Fu.create(),
        typeName: er.ZodObject,
        ...mr(t)
    });
In.lazycreate = (e, t)=>new In({
        shape: e,
        unknownKeys: "strip",
        catchall: Fu.create(),
        typeName: er.ZodObject,
        ...mr(t)
    });
class W0 extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = this._def.options;
        function i1(o) {
            for (const s of o)if (s.result.status === "valid") return s.result;
            for (const s of o)if (s.result.status === "dirty") return r.common.issues.push(...s.ctx.common.issues), s.result;
            const a = o.map((s)=>new Yo(s.ctx.common.issues));
            return xt(r, {
                code: gt.invalid_union,
                unionErrors: a
            }), ir;
        }
        if (r.common.async) return Promise.all(n.map(async (o)=>{
            const a = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await o._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: a
                }),
                ctx: a
            };
        })).then(i1);
        {
            let o;
            const a = [];
            for (const c of n){
                const l = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }, u = c._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: l
                });
                if (u.status === "valid") return u;
                u.status === "dirty" && !o && (o = {
                    result: u,
                    ctx: l
                }), l.common.issues.length && a.push(l.common.issues);
            }
            if (o) return r.common.issues.push(...o.ctx.common.issues), o.result;
            const s = a.map((c)=>new Yo(c));
            return xt(r, {
                code: gt.invalid_union,
                unionErrors: s
            }), ir;
        }
    }
    get options() {
        return this._def.options;
    }
}
W0.create = (e, t)=>new W0({
        options: e,
        typeName: er.ZodUnion,
        ...mr(t)
    });
const Oc = (e)=>e instanceof $0 ? Oc(e.schema) : e instanceof fs ? Oc(e.innerType()) : e instanceof Z0 ? [
        e.value
    ] : e instanceof il ? e.options : e instanceof X0 ? Gr.objectValues(e.enum) : e instanceof Y0 ? Oc(e._def.innerType) : e instanceof q0 ? [
        void 0
    ] : e instanceof V0 ? [
        null
    ] : e instanceof Vs ? [
        void 0,
        ...Oc(e.unwrap())
    ] : e instanceof ol ? [
        null,
        ...Oc(e.unwrap())
    ] : e instanceof v7 || e instanceof e1 ? Oc(e.unwrap()) : e instanceof J0 ? Oc(e._def.innerType) : [];
class qb extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.object) return xt(r, {
            code: gt.invalid_type,
            expected: Bt.object,
            received: r.parsedType
        }), ir;
        const n = this.discriminator, i1 = r.data[n], o = this.optionsMap.get(i1);
        return o ? r.common.async ? o._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : o._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (xt(r, {
            code: gt.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                n
            ]
        }), ir);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(t, r, n) {
        const i1 = /* @__PURE__ */ new Map();
        for (const o of r){
            const a = Oc(o.shape[t]);
            if (!a.length) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const s of a){
                if (i1.has(s)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
                i1.set(s, o);
            }
        }
        return new qb({
            typeName: er.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: i1,
            ...mr(n)
        });
    }
}
function K4(e, t) {
    const r = Ou(e), n = Ou(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (r === Bt.object && n === Bt.object) {
        const i1 = Gr.objectKeys(t), o = Gr.objectKeys(e).filter((s)=>i1.indexOf(s) !== -1), a = {
            ...e,
            ...t
        };
        for (const s of o){
            const c = K4(e[s], t[s]);
            if (!c.valid) return {
                valid: !1
            };
            a[s] = c.data;
        }
        return {
            valid: !0,
            data: a
        };
    } else if (r === Bt.array && n === Bt.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i1 = [];
        for(let o = 0; o < e.length; o++){
            const a = e[o], s = t[o], c = K4(a, s);
            if (!c.valid) return {
                valid: !1
            };
            i1.push(c.data);
        }
        return {
            valid: !0,
            data: i1
        };
    } else return r === Bt.date && n === Bt.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    };
}
class G0 extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i1 = (o, a)=>{
            if (L4(o) || L4(a)) return ir;
            const s = K4(o.value, a.value);
            return s.valid ? ((H4(o) || H4(a)) && r.dirty(), {
                status: r.value,
                value: s.data
            }) : (xt(n, {
                code: gt.invalid_intersection_types
            }), ir);
        };
        return n.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }),
            this._def.right._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            })
        ]).then(([o, a])=>i1(o, a)) : i1(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }));
    }
}
G0.create = (e, t, r)=>new G0({
        left: e,
        right: t,
        typeName: er.ZodIntersection,
        ...mr(r)
    });
class Zs extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.array) return xt(n, {
            code: gt.invalid_type,
            expected: Bt.array,
            received: n.parsedType
        }), ir;
        if (n.data.length < this._def.items.length) return xt(n, {
            code: gt.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), ir;
        !this._def.rest && n.data.length > this._def.items.length && (xt(n, {
            code: gt.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const i1 = [
            ...n.data
        ].map((o, a)=>{
            const s = this._def.items[a] || this._def.rest;
            return s ? s._parse(new $s(n, o, n.path, a)) : null;
        }).filter((o)=>!!o);
        return n.common.async ? Promise.all(i1).then((o)=>Gi.mergeArray(r, o)) : Gi.mergeArray(r, i1);
    }
    get items() {
        return this._def.items;
    }
    rest(t) {
        return new Zs({
            ...this._def,
            rest: t
        });
    }
}
Zs.create = (e, t)=>{
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Zs({
        items: e,
        typeName: er.ZodTuple,
        rest: null,
        ...mr(t)
    });
};
class Q0 extends Ir {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.object) return xt(n, {
            code: gt.invalid_type,
            expected: Bt.object,
            received: n.parsedType
        }), ir;
        const i1 = [], o = this._def.keyType, a = this._def.valueType;
        for(const s in n.data)i1.push({
            key: o._parse(new $s(n, s, n.path, s)),
            value: a._parse(new $s(n, n.data[s], n.path, s)),
            alwaysSet: s in n.data
        });
        return n.common.async ? Gi.mergeObjectAsync(r, i1) : Gi.mergeObjectSync(r, i1);
    }
    get element() {
        return this._def.valueType;
    }
    static create(t, r, n) {
        return r instanceof Ir ? new Q0({
            keyType: t,
            valueType: r,
            typeName: er.ZodRecord,
            ...mr(n)
        }) : new Q0({
            keyType: ns.create(),
            valueType: t,
            typeName: er.ZodRecord,
            ...mr(r)
        });
    }
}
class y2 extends Ir {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.map) return xt(n, {
            code: gt.invalid_type,
            expected: Bt.map,
            received: n.parsedType
        }), ir;
        const i1 = this._def.keyType, o = this._def.valueType, a = [
            ...n.data.entries()
        ].map(([s, c], l)=>({
                key: i1._parse(new $s(n, s, n.path, [
                    l,
                    "key"
                ])),
                value: o._parse(new $s(n, c, n.path, [
                    l,
                    "value"
                ]))
            }));
        if (n.common.async) {
            const s = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const c of a){
                    const l = await c.key, u = await c.value;
                    if (l.status === "aborted" || u.status === "aborted") return ir;
                    (l.status === "dirty" || u.status === "dirty") && r.dirty(), s.set(l.value, u.value);
                }
                return {
                    status: r.value,
                    value: s
                };
            });
        } else {
            const s = /* @__PURE__ */ new Map();
            for (const c of a){
                const l = c.key, u = c.value;
                if (l.status === "aborted" || u.status === "aborted") return ir;
                (l.status === "dirty" || u.status === "dirty") && r.dirty(), s.set(l.value, u.value);
            }
            return {
                status: r.value,
                value: s
            };
        }
    }
}
y2.create = (e, t, r)=>new y2({
        valueType: t,
        keyType: e,
        typeName: er.ZodMap,
        ...mr(r)
    });
class kf extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.parsedType !== Bt.set) return xt(n, {
            code: gt.invalid_type,
            expected: Bt.set,
            received: n.parsedType
        }), ir;
        const i1 = this._def;
        i1.minSize !== null && n.data.size < i1.minSize.value && (xt(n, {
            code: gt.too_small,
            minimum: i1.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i1.minSize.message
        }), r.dirty()), i1.maxSize !== null && n.data.size > i1.maxSize.value && (xt(n, {
            code: gt.too_big,
            maximum: i1.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i1.maxSize.message
        }), r.dirty());
        const o = this._def.valueType;
        function a(c) {
            const l = /* @__PURE__ */ new Set();
            for (const u of c){
                if (u.status === "aborted") return ir;
                u.status === "dirty" && r.dirty(), l.add(u.value);
            }
            return {
                status: r.value,
                value: l
            };
        }
        const s = [
            ...n.data.values()
        ].map((c, l)=>o._parse(new $s(n, c, n.path, l)));
        return n.common.async ? Promise.all(s).then((c)=>a(c)) : a(s);
    }
    min(t, r) {
        return new kf({
            ...this._def,
            minSize: {
                value: t,
                message: Ft.toString(r)
            }
        });
    }
    max(t, r) {
        return new kf({
            ...this._def,
            maxSize: {
                value: t,
                message: Ft.toString(r)
            }
        });
    }
    size(t, r) {
        return this.min(t, r).max(t, r);
    }
    nonempty(t) {
        return this.min(1, t);
    }
}
kf.create = (e, t)=>new kf({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: er.ZodSet,
        ...mr(t)
    });
class Zd extends Ir {
    constructor(){
        super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.function) return xt(r, {
            code: gt.invalid_type,
            expected: Bt.function,
            received: r.parsedType
        }), ir;
        function n(s, c) {
            return f2({
                data: s,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    l2(),
                    kh
                ].filter((l)=>!!l),
                issueData: {
                    code: gt.invalid_arguments,
                    argumentsError: c
                }
            });
        }
        function i1(s, c) {
            return f2({
                data: s,
                path: r.path,
                errorMaps: [
                    r.common.contextualErrorMap,
                    r.schemaErrorMap,
                    l2(),
                    kh
                ].filter((l)=>!!l),
                issueData: {
                    code: gt.invalid_return_type,
                    returnTypeError: c
                }
            });
        }
        const o = {
            errorMap: r.common.contextualErrorMap
        }, a = r.data;
        if (this._def.returns instanceof Ih) {
            const s = this;
            return so(async function(...c) {
                const l = new Yo([]), u = await s._def.args.parseAsync(c, o).catch((h)=>{
                    throw l.addIssue(n(c, h)), l;
                }), f = await Reflect.apply(a, this, u);
                return await s._def.returns._def.type.parseAsync(f, o).catch((h)=>{
                    throw l.addIssue(i1(f, h)), l;
                });
            });
        } else {
            const s = this;
            return so(function(...c) {
                const l = s._def.args.safeParse(c, o);
                if (!l.success) throw new Yo([
                    n(c, l.error)
                ]);
                const u = Reflect.apply(a, this, l.data), f = s._def.returns.safeParse(u, o);
                if (!f.success) throw new Yo([
                    i1(u, f.error)
                ]);
                return f.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...t) {
        return new Zd({
            ...this._def,
            args: Zs.create(t).rest(pf.create())
        });
    }
    returns(t) {
        return new Zd({
            ...this._def,
            returns: t
        });
    }
    implement(t) {
        return this.parse(t);
    }
    strictImplement(t) {
        return this.parse(t);
    }
    static create(t, r, n) {
        return new Zd({
            args: t || Zs.create([]).rest(pf.create()),
            returns: r || pf.create(),
            typeName: er.ZodFunction,
            ...mr(n)
        });
    }
}
class $0 extends Ir {
    get schema() {
        return this._def.getter();
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        });
    }
}
$0.create = (e, t)=>new $0({
        getter: e,
        typeName: er.ZodLazy,
        ...mr(t)
    });
class Z0 extends Ir {
    _parse(t) {
        if (t.data !== this._def.value) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                received: r.data,
                code: gt.invalid_literal,
                expected: this._def.value
            }), ir;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
    get value() {
        return this._def.value;
    }
}
Z0.create = (e, t)=>new Z0({
        value: e,
        typeName: er.ZodLiteral,
        ...mr(t)
    });
function gj(e, t) {
    return new il({
        values: e,
        typeName: er.ZodEnum,
        ...mr(t)
    });
}
class il extends Ir {
    constructor(){
        super(...arguments), zp.set(this, void 0);
    }
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return xt(r, {
                expected: Gr.joinValues(n),
                received: r.parsedType,
                code: gt.invalid_type
            }), ir;
        }
        if (h2(this, zp) || fj(this, zp, new Set(this._def.values)), !h2(this, zp).has(t.data)) {
            const r = this._getOrReturnCtx(t), n = this._def.values;
            return xt(r, {
                received: r.data,
                code: gt.invalid_enum_value,
                options: n
            }), ir;
        }
        return so(t.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)t[r] = r;
        return t;
    }
    extract(t, r = this._def) {
        return il.create(t, {
            ...this._def,
            ...r
        });
    }
    exclude(t, r = this._def) {
        return il.create(this.options.filter((n)=>!t.includes(n)), {
            ...this._def,
            ...r
        });
    }
}
zp = /* @__PURE__ */ new WeakMap();
il.create = gj;
class X0 extends Ir {
    constructor(){
        super(...arguments), Lp.set(this, void 0);
    }
    _parse(t) {
        const r = Gr.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
        if (n.parsedType !== Bt.string && n.parsedType !== Bt.number) {
            const i1 = Gr.objectValues(r);
            return xt(n, {
                expected: Gr.joinValues(i1),
                received: n.parsedType,
                code: gt.invalid_type
            }), ir;
        }
        if (h2(this, Lp) || fj(this, Lp, new Set(Gr.getValidEnumValues(this._def.values))), !h2(this, Lp).has(t.data)) {
            const i1 = Gr.objectValues(r);
            return xt(n, {
                received: n.data,
                code: gt.invalid_enum_value,
                options: i1
            }), ir;
        }
        return so(t.data);
    }
    get enum() {
        return this._def.values;
    }
}
Lp = /* @__PURE__ */ new WeakMap();
X0.create = (e, t)=>new X0({
        values: e,
        typeName: er.ZodNativeEnum,
        ...mr(t)
    });
class Ih extends Ir {
    unwrap() {
        return this._def.type;
    }
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        if (r.parsedType !== Bt.promise && r.common.async === !1) return xt(r, {
            code: gt.invalid_type,
            expected: Bt.promise,
            received: r.parsedType
        }), ir;
        const n = r.parsedType === Bt.promise ? r.data : Promise.resolve(r.data);
        return so(n.then((i1)=>this._def.type.parseAsync(i1, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })));
    }
}
Ih.create = (e, t)=>new Ih({
        type: e,
        typeName: er.ZodPromise,
        ...mr(t)
    });
class fs extends Ir {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === er.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t), i1 = this._def.effect || null, o = {
            addIssue: (a)=>{
                xt(n, a), a.fatal ? r.abort() : r.dirty();
            },
            get path () {
                return n.path;
            }
        };
        if (o.addIssue = o.addIssue.bind(o), i1.type === "preprocess") {
            const a = i1.transform(n.data, o);
            if (n.common.async) return Promise.resolve(a).then(async (s)=>{
                if (r.value === "aborted") return ir;
                const c = await this._def.schema._parseAsync({
                    data: s,
                    path: n.path,
                    parent: n
                });
                return c.status === "aborted" ? ir : c.status === "dirty" || r.value === "dirty" ? d2(c.value) : c;
            });
            {
                if (r.value === "aborted") return ir;
                const s = this._def.schema._parseSync({
                    data: a,
                    path: n.path,
                    parent: n
                });
                return s.status === "aborted" ? ir : s.status === "dirty" || r.value === "dirty" ? d2(s.value) : s;
            }
        }
        if (i1.type === "refinement") {
            const a = (s)=>{
                const c = i1.refinement(s, o);
                if (n.common.async) return Promise.resolve(c);
                if (c instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return s;
            };
            if (n.common.async === !1) {
                const s = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return s.status === "aborted" ? ir : (s.status === "dirty" && r.dirty(), a(s.value), {
                    status: r.value,
                    value: s.value
                });
            } else return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then((s)=>s.status === "aborted" ? ir : (s.status === "dirty" && r.dirty(), a(s.value).then(()=>({
                        status: r.value,
                        value: s.value
                    }))));
        }
        if (i1.type === "transform") if (n.common.async === !1) {
            const a = this._def.schema._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            if (!xf(a)) return a;
            const s = i1.transform(a.value, o);
            if (s instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: r.value,
                value: s
            };
        } else return this._def.schema._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }).then((a)=>xf(a) ? Promise.resolve(i1.transform(a.value, o)).then((s)=>({
                    status: r.value,
                    value: s
                })) : a);
        Gr.assertNever(i1);
    }
}
fs.create = (e, t, r)=>new fs({
        schema: e,
        typeName: er.ZodEffects,
        effect: t,
        ...mr(r)
    });
fs.createWithPreprocess = (e, t, r)=>new fs({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: er.ZodEffects,
        ...mr(r)
    });
class Vs extends Ir {
    _parse(t) {
        return this._getType(t) === Bt.undefined ? so(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Vs.create = (e, t)=>new Vs({
        innerType: e,
        typeName: er.ZodOptional,
        ...mr(t)
    });
class ol extends Ir {
    _parse(t) {
        return this._getType(t) === Bt.null ? so(null) : this._def.innerType._parse(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ol.create = (e, t)=>new ol({
        innerType: e,
        typeName: er.ZodNullable,
        ...mr(t)
    });
class Y0 extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t);
        let n = r.data;
        return r.parsedType === Bt.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
Y0.create = (e, t)=>new Y0({
        innerType: e,
        typeName: er.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : ()=>t.default,
        ...mr(t)
    });
class J0 extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }, i1 = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return H0(i1) ? i1.then((o)=>({
                status: "valid",
                value: o.status === "valid" ? o.value : this._def.catchValue({
                    get error () {
                        return new Yo(n.common.issues);
                    },
                    input: n.data
                })
            })) : {
            status: "valid",
            value: i1.status === "valid" ? i1.value : this._def.catchValue({
                get error () {
                    return new Yo(n.common.issues);
                },
                input: n.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
J0.create = (e, t)=>new J0({
        innerType: e,
        typeName: er.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : ()=>t.catch,
        ...mr(t)
    });
class m2 extends Ir {
    _parse(t) {
        if (this._getType(t) !== Bt.nan) {
            const r = this._getOrReturnCtx(t);
            return xt(r, {
                code: gt.invalid_type,
                expected: Bt.nan,
                received: r.parsedType
            }), ir;
        }
        return {
            status: "valid",
            value: t.data
        };
    }
}
m2.create = (e)=>new m2({
        typeName: er.ZodNaN,
        ...mr(e)
    });
const ibe = Symbol("zod_brand");
class v7 extends Ir {
    _parse(t) {
        const { ctx: r } = this._processInputParams(t), n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class q1 extends Ir {
    _parse(t) {
        const { status: r, ctx: n } = this._processInputParams(t);
        if (n.common.async) return (async ()=>{
            const i1 = await this._def.in._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i1.status === "aborted" ? ir : i1.status === "dirty" ? (r.dirty(), d2(i1.value)) : this._def.out._parseAsync({
                data: i1.value,
                path: n.path,
                parent: n
            });
        })();
        {
            const i1 = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return i1.status === "aborted" ? ir : i1.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i1.value
            }) : this._def.out._parseSync({
                data: i1.value,
                path: n.path,
                parent: n
            });
        }
    }
    static create(t, r) {
        return new q1({
            in: t,
            out: r,
            typeName: er.ZodPipeline
        });
    }
}
class e1 extends Ir {
    _parse(t) {
        const r = this._def.innerType._parse(t), n = (i1)=>(xf(i1) && (i1.value = Object.freeze(i1.value)), i1);
        return H0(r) ? r.then((i1)=>n(i1)) : n(r);
    }
    unwrap() {
        return this._def.innerType;
    }
}
e1.create = (e, t)=>new e1({
        innerType: e,
        typeName: er.ZodReadonly,
        ...mr(t)
    });
function oB(e, t) {
    const r = typeof e == "function" ? e(t) : typeof e == "string" ? {
        message: e
    } : e;
    return typeof r == "string" ? {
        message: r
    } : r;
}
function yj(e, t = {}, r) {
    return e ? Oh.create().superRefine((n, i1)=>{
        var o, a;
        const s = e(n);
        if (s instanceof Promise) return s.then((c)=>{
            var l, u;
            if (!c) {
                const f = oB(t, n), h = (u = (l = f.fatal) !== null && l !== void 0 ? l : r) !== null && u !== void 0 ? u : !0;
                i1.addIssue({
                    code: "custom",
                    ...f,
                    fatal: h
                });
            }
        });
        if (!s) {
            const c = oB(t, n), l = (a = (o = c.fatal) !== null && o !== void 0 ? o : r) !== null && a !== void 0 ? a : !0;
            i1.addIssue({
                code: "custom",
                ...c,
                fatal: l
            });
        }
    }) : Oh.create();
}
const obe = {
    object: In.lazycreate
};
var er;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(er || (er = {}));
const abe = (e, t = {
    message: `Input not instance of ${e.name}`
})=>yj((r)=>r instanceof e, t), mj = ns.create, bj = rl.create, sbe = m2.create, ube = nl.create, wj = K0.create, cbe = _f.create, lbe = p2.create, fbe = q0.create, dbe = V0.create, hbe = Oh.create, pbe = pf.create, gbe = Fu.create, ybe = g2.create, mbe = us.create, bbe = In.create, wbe = In.strictCreate, Abe = W0.create, vbe = qb.create, Ebe = G0.create, Sbe = Zs.create, xbe = Q0.create, _be = y2.create, kbe = kf.create, Obe = Zd.create, Ibe = $0.create, Bbe = Z0.create, Tbe = il.create, Pbe = X0.create, Cbe = Ih.create, aB = fs.create, Mbe = Vs.create, Nbe = ol.create, Rbe = fs.createWithPreprocess, Ube = q1.create, Dbe = ()=>mj().optional(), jbe = ()=>bj().optional(), Fbe = ()=>wj().optional(), zbe = {
    string: (e)=>ns.create({
            ...e,
            coerce: !0
        }),
    number: (e)=>rl.create({
            ...e,
            coerce: !0
        }),
    boolean: (e)=>K0.create({
            ...e,
            coerce: !0
        }),
    bigint: (e)=>nl.create({
            ...e,
            coerce: !0
        }),
    date: (e)=>_f.create({
            ...e,
            coerce: !0
        })
}, Lbe = ir;
var _e = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: kh,
    setErrorMap: R2e,
    getErrorMap: l2,
    makeIssue: f2,
    EMPTY_PATH: U2e,
    addIssueToContext: xt,
    ParseStatus: Gi,
    INVALID: ir,
    DIRTY: d2,
    OK: so,
    isAborted: L4,
    isDirty: H4,
    isValid: xf,
    isAsync: H0,
    get util () {
        return Gr;
    },
    get objectUtil () {
        return z4;
    },
    ZodParsedType: Bt,
    getParsedType: Ou,
    ZodType: Ir,
    datetimeRegex: pj,
    ZodString: ns,
    ZodNumber: rl,
    ZodBigInt: nl,
    ZodBoolean: K0,
    ZodDate: _f,
    ZodSymbol: p2,
    ZodUndefined: q0,
    ZodNull: V0,
    ZodAny: Oh,
    ZodUnknown: pf,
    ZodNever: Fu,
    ZodVoid: g2,
    ZodArray: us,
    ZodObject: In,
    ZodUnion: W0,
    ZodDiscriminatedUnion: qb,
    ZodIntersection: G0,
    ZodTuple: Zs,
    ZodRecord: Q0,
    ZodMap: y2,
    ZodSet: kf,
    ZodFunction: Zd,
    ZodLazy: $0,
    ZodLiteral: Z0,
    ZodEnum: il,
    ZodNativeEnum: X0,
    ZodPromise: Ih,
    ZodEffects: fs,
    ZodTransformer: fs,
    ZodOptional: Vs,
    ZodNullable: ol,
    ZodDefault: Y0,
    ZodCatch: J0,
    ZodNaN: m2,
    BRAND: ibe,
    ZodBranded: v7,
    ZodPipeline: q1,
    ZodReadonly: e1,
    custom: yj,
    Schema: Ir,
    ZodSchema: Ir,
    late: obe,
    get ZodFirstPartyTypeKind () {
        return er;
    },
    coerce: zbe,
    any: hbe,
    array: mbe,
    bigint: ube,
    boolean: wj,
    date: cbe,
    discriminatedUnion: vbe,
    effect: aB,
    enum: Tbe,
    function: Obe,
    instanceof: abe,
    intersection: Ebe,
    lazy: Ibe,
    literal: Bbe,
    map: _be,
    nan: sbe,
    nativeEnum: Pbe,
    never: gbe,
    null: dbe,
    nullable: Nbe,
    number: bj,
    object: bbe,
    oboolean: Fbe,
    onumber: jbe,
    optional: Mbe,
    ostring: Dbe,
    pipeline: Ube,
    preprocess: Rbe,
    promise: Cbe,
    record: xbe,
    set: kbe,
    strictObject: wbe,
    string: mj,
    symbol: lbe,
    transformer: aB,
    tuple: Sbe,
    undefined: fbe,
    union: Abe,
    unknown: pbe,
    void: ybe,
    NEVER: Lbe,
    ZodIssueCode: gt,
    quotelessJson: N2e,
    ZodError: Yo
}), Hbe = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, o8 = Math.ceil, wa = Math.floor, mo = "[BigNumber Error] ", sB = mo + "Number primitive has more than 15 significant digits: ", qa = 1e14, pr = 14, a8 = 9007199254740991, s8 = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8,
    1e9,
    1e10,
    1e11,
    1e12,
    1e13
], xc = 1e7, fi = 1e9;
function Aj(e) {
    var t, r, n, i1 = N.prototype = {
        constructor: N,
        toString: null,
        valueOf: null
    }, o = new N(1), a = 20, s = 4, c = -7, l = 21, u = -1e7, f = 1e7, h = !1, y = 1, S = 0, k = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
    }, P = "0123456789abcdefghijklmnopqrstuvwxyz", M = !0;
    function N(q, U) {
        var Q, v, B, g, E, w, _, O, I = this;
        if (!(I instanceof N)) return new N(q, U);
        if (U == null) {
            if (q && q._isBigNumber === !0) {
                I.s = q.s, !q.c || q.e > f ? I.c = I.e = null : q.e < u ? I.c = [
                    I.e = 0
                ] : (I.e = q.e, I.c = q.c.slice());
                return;
            }
            if ((w = typeof q == "number") && q * 0 == 0) {
                if (I.s = 1 / q < 0 ? (q = -q, -1) : 1, q === ~~q) {
                    for(g = 0, E = q; E >= 10; E /= 10, g++);
                    g > f ? I.c = I.e = null : (I.e = g, I.c = [
                        q
                    ]);
                    return;
                }
                O = String(q);
            } else {
                if (!Hbe.test(O = String(q))) return n(I, O, w);
                I.s = O.charCodeAt(0) == 45 ? (O = O.slice(1), -1) : 1;
            }
            (g = O.indexOf(".")) > -1 && (O = O.replace(".", "")), (E = O.search(/e/i)) > 0 ? (g < 0 && (g = E), g += +O.slice(E + 1), O = O.substring(0, E)) : g < 0 && (g = O.length);
        } else {
            if (On(U, 2, P.length, "Base"), U == 10 && M) return I = new N(q), ne(I, a + I.e + 1, s);
            if (O = String(q), w = typeof q == "number") {
                if (q * 0 != 0) return n(I, O, w, U);
                if (I.s = 1 / q < 0 ? (O = O.slice(1), -1) : 1, N.DEBUG && O.replace(/^0\.0*|\./, "").length > 15) throw Error(sB + q);
            } else I.s = O.charCodeAt(0) === 45 ? (O = O.slice(1), -1) : 1;
            for(Q = P.slice(0, U), g = E = 0, _ = O.length; E < _; E++)if (Q.indexOf(v = O.charAt(E)) < 0) {
                if (v == ".") {
                    if (E > g) {
                        g = _;
                        continue;
                    }
                } else if (!B && (O == O.toUpperCase() && (O = O.toLowerCase()) || O == O.toLowerCase() && (O = O.toUpperCase()))) {
                    B = !0, E = -1, g = 0;
                    continue;
                }
                return n(I, String(q), w, U);
            }
            w = !1, O = r(O, U, 10, I.s), (g = O.indexOf(".")) > -1 ? O = O.replace(".", "") : g = O.length;
        }
        for(E = 0; O.charCodeAt(E) === 48; E++);
        for(_ = O.length; O.charCodeAt(--_) === 48;);
        if (O = O.slice(E, ++_)) {
            if (_ -= E, w && N.DEBUG && _ > 15 && (q > a8 || q !== wa(q))) throw Error(sB + I.s * q);
            if ((g = g - E - 1) > f) I.c = I.e = null;
            else if (g < u) I.c = [
                I.e = 0
            ];
            else {
                if (I.e = g, I.c = [], E = (g + 1) % pr, g < 0 && (E += pr), E < _) {
                    for(E && I.c.push(+O.slice(0, E)), _ -= pr; E < _;)I.c.push(+O.slice(E, E += pr));
                    E = pr - (O = O.slice(E)).length;
                } else E -= _;
                for(; E--; O += "0");
                I.c.push(+O);
            }
        } else I.c = [
            I.e = 0
        ];
    }
    N.clone = Aj, N.ROUND_UP = 0, N.ROUND_DOWN = 1, N.ROUND_CEIL = 2, N.ROUND_FLOOR = 3, N.ROUND_HALF_UP = 4, N.ROUND_HALF_DOWN = 5, N.ROUND_HALF_EVEN = 6, N.ROUND_HALF_CEIL = 7, N.ROUND_HALF_FLOOR = 8, N.EUCLID = 9, N.config = N.set = function(q) {
        var U, Q;
        if (q != null) if (typeof q == "object") {
            if (q.hasOwnProperty(U = "DECIMAL_PLACES") && (Q = q[U], On(Q, 0, fi, U), a = Q), q.hasOwnProperty(U = "ROUNDING_MODE") && (Q = q[U], On(Q, 0, 8, U), s = Q), q.hasOwnProperty(U = "EXPONENTIAL_AT") && (Q = q[U], Q && Q.pop ? (On(Q[0], -fi, 0, U), On(Q[1], 0, fi, U), c = Q[0], l = Q[1]) : (On(Q, -fi, fi, U), c = -(l = Q < 0 ? -Q : Q))), q.hasOwnProperty(U = "RANGE")) if (Q = q[U], Q && Q.pop) On(Q[0], -fi, -1, U), On(Q[1], 1, fi, U), u = Q[0], f = Q[1];
            else if (On(Q, -fi, fi, U), Q) u = -(f = Q < 0 ? -Q : Q);
            else throw Error(mo + U + " cannot be zero: " + Q);
            if (q.hasOwnProperty(U = "CRYPTO")) if (Q = q[U], Q === !!Q) if (Q) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) h = Q;
            else throw h = !Q, Error(mo + "crypto unavailable");
            else h = Q;
            else throw Error(mo + U + " not true or false: " + Q);
            if (q.hasOwnProperty(U = "MODULO_MODE") && (Q = q[U], On(Q, 0, 9, U), y = Q), q.hasOwnProperty(U = "POW_PRECISION") && (Q = q[U], On(Q, 0, fi, U), S = Q), q.hasOwnProperty(U = "FORMAT")) if (Q = q[U], typeof Q == "object") k = Q;
            else throw Error(mo + U + " not an object: " + Q);
            if (q.hasOwnProperty(U = "ALPHABET")) if (Q = q[U], typeof Q == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Q)) M = Q.slice(0, 10) == "0123456789", P = Q;
            else throw Error(mo + U + " invalid: " + Q);
        } else throw Error(mo + "Object expected: " + q);
        return {
            DECIMAL_PLACES: a,
            ROUNDING_MODE: s,
            EXPONENTIAL_AT: [
                c,
                l
            ],
            RANGE: [
                u,
                f
            ],
            CRYPTO: h,
            MODULO_MODE: y,
            POW_PRECISION: S,
            FORMAT: k,
            ALPHABET: P
        };
    }, N.isBigNumber = function(q) {
        if (!q || q._isBigNumber !== !0) return !1;
        if (!N.DEBUG) return !0;
        var U, Q, v = q.c, B = q.e, g = q.s;
        e: if (({}).toString.call(v) == "[object Array]") {
            if ((g === 1 || g === -1) && B >= -fi && B <= fi && B === wa(B)) {
                if (v[0] === 0) {
                    if (B === 0 && v.length === 1) return !0;
                    break e;
                }
                if (U = (B + 1) % pr, U < 1 && (U += pr), String(v[0]).length == U) {
                    for(U = 0; U < v.length; U++)if (Q = v[U], Q < 0 || Q >= qa || Q !== wa(Q)) break e;
                    if (Q !== 0) return !0;
                }
            }
        } else if (v === null && B === null && (g === null || g === 1 || g === -1)) return !0;
        throw Error(mo + "Invalid BigNumber: " + q);
    }, N.maximum = N.max = function() {
        return K(arguments, -1);
    }, N.minimum = N.min = function() {
        return K(arguments, 1);
    }, N.random = function() {
        var q = 9007199254740992, U = Math.random() * q & 2097151 ? function() {
            return wa(Math.random() * q);
        } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(Q) {
            var v, B, g, E, w, _ = 0, O = [], I = new N(o);
            if (Q == null ? Q = a : On(Q, 0, fi), E = o8(Q / pr), h) if (crypto.getRandomValues) {
                for(v = crypto.getRandomValues(new Uint32Array(E *= 2)); _ < E;)w = v[_] * 131072 + (v[_ + 1] >>> 11), w >= 9e15 ? (B = crypto.getRandomValues(new Uint32Array(2)), v[_] = B[0], v[_ + 1] = B[1]) : (O.push(w % 1e14), _ += 2);
                _ = E / 2;
            } else if (crypto.randomBytes) {
                for(v = crypto.randomBytes(E *= 7); _ < E;)w = (v[_] & 31) * 281474976710656 + v[_ + 1] * 1099511627776 + v[_ + 2] * 4294967296 + v[_ + 3] * 16777216 + (v[_ + 4] << 16) + (v[_ + 5] << 8) + v[_ + 6], w >= 9e15 ? crypto.randomBytes(7).copy(v, _) : (O.push(w % 1e14), _ += 7);
                _ = E / 7;
            } else throw h = !1, Error(mo + "crypto unavailable");
            if (!h) for(; _ < E;)w = U(), w < 9e15 && (O[_++] = w % 1e14);
            for(E = O[--_], Q %= pr, E && Q && (w = s8[pr - Q], O[_] = wa(E / w) * w); O[_] === 0; O.pop(), _--);
            if (_ < 0) O = [
                g = 0
            ];
            else {
                for(g = -1; O[0] === 0; O.splice(0, 1), g -= pr);
                for(_ = 1, w = O[0]; w >= 10; w /= 10, _++);
                _ < pr && (g -= pr - _);
            }
            return I.e = g, I.c = O, I;
        };
    }(), N.sum = function() {
        for(var q = 1, U = arguments, Q = new N(U[0]); q < U.length;)Q = Q.plus(U[q++]);
        return Q;
    }, r = /* @__PURE__ */ function() {
        var q = "0123456789";
        function U(Q, v, B, g) {
            for(var E, w = [
                0
            ], _, O = 0, I = Q.length; O < I;){
                for(_ = w.length; _--; w[_] *= v);
                for(w[0] += g.indexOf(Q.charAt(O++)), E = 0; E < w.length; E++)w[E] > B - 1 && (w[E + 1] == null && (w[E + 1] = 0), w[E + 1] += w[E] / B | 0, w[E] %= B);
            }
            return w.reverse();
        }
        return function(Q, v, B, g, E) {
            var w, _, O, I, x, R, j, Y, he = Q.indexOf("."), ue = a, G = s;
            for(he >= 0 && (I = S, S = 0, Q = Q.replace(".", ""), Y = new N(v), R = Y.pow(Q.length - he), S = I, Y.c = U(Au(ba(R.c), R.e, "0"), 10, B, q), Y.e = Y.c.length), j = U(Q, v, B, E ? (w = P, q) : (w = q, P)), O = I = j.length; j[--I] == 0; j.pop());
            if (!j[0]) return w.charAt(0);
            if (he < 0 ? --O : (R.c = j, R.e = O, R.s = g, R = t(R, Y, ue, G, B), j = R.c, x = R.r, O = R.e), _ = O + ue + 1, he = j[_], I = B / 2, x = x || _ < 0 || j[_ + 1] != null, x = G < 4 ? (he != null || x) && (G == 0 || G == (R.s < 0 ? 3 : 2)) : he > I || he == I && (G == 4 || x || G == 6 && j[_ - 1] & 1 || G == (R.s < 0 ? 8 : 7)), _ < 1 || !j[0]) Q = x ? Au(w.charAt(1), -ue, w.charAt(0)) : w.charAt(0);
            else {
                if (j.length = _, x) for(--B; ++j[--_] > B;)j[_] = 0, _ || (++O, j = [
                    1
                ].concat(j));
                for(I = j.length; !j[--I];);
                for(he = 0, Q = ""; he <= I; Q += w.charAt(j[he++]));
                Q = Au(Q, O, w.charAt(0));
            }
            return Q;
        };
    }(), t = /* @__PURE__ */ function() {
        function q(v, B, g) {
            var E, w, _, O, I = 0, x = v.length, R = B % xc, j = B / xc | 0;
            for(v = v.slice(); x--;)_ = v[x] % xc, O = v[x] / xc | 0, E = j * _ + O * R, w = R * _ + E % xc * xc + I, I = (w / g | 0) + (E / xc | 0) + j * O, v[x] = w % g;
            return I && (v = [
                I
            ].concat(v)), v;
        }
        function U(v, B, g, E) {
            var w, _;
            if (g != E) _ = g > E ? 1 : -1;
            else for(w = _ = 0; w < g; w++)if (v[w] != B[w]) {
                _ = v[w] > B[w] ? 1 : -1;
                break;
            }
            return _;
        }
        function Q(v, B, g, E) {
            for(var w = 0; g--;)v[g] -= w, w = v[g] < B[g] ? 1 : 0, v[g] = w * E + v[g] - B[g];
            for(; !v[0] && v.length > 1; v.splice(0, 1));
        }
        return function(v, B, g, E, w) {
            var _, O, I, x, R, j, Y, he, ue, G, se, Z, ie, pe, ve, Ie, Me, Re = v.s == B.s ? 1 : -1, C = v.c, J = B.c;
            if (!C || !C[0] || !J || !J[0]) return new N(// Return NaN if either NaN, or both Infinity or 0.
            !v.s || !B.s || (C ? J && C[0] == J[0] : !J) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            C && C[0] == 0 || !J ? Re * 0 : Re / 0);
            for(he = new N(Re), ue = he.c = [], O = v.e - B.e, Re = g + O + 1, w || (w = qa, O = Aa(v.e / pr) - Aa(B.e / pr), Re = Re / pr | 0), I = 0; J[I] == (C[I] || 0); I++);
            if (J[I] > (C[I] || 0) && O--, Re < 0) ue.push(1), x = !0;
            else {
                for(pe = C.length, Ie = J.length, I = 0, Re += 2, R = wa(w / (J[0] + 1)), R > 1 && (J = q(J, R, w), C = q(C, R, w), Ie = J.length, pe = C.length), ie = Ie, G = C.slice(0, Ie), se = G.length; se < Ie; G[se++] = 0);
                Me = J.slice(), Me = [
                    0
                ].concat(Me), ve = J[0], J[1] >= w / 2 && ve++;
                do {
                    if (R = 0, _ = U(J, G, Ie, se), _ < 0) {
                        if (Z = G[0], Ie != se && (Z = Z * w + (G[1] || 0)), R = wa(Z / ve), R > 1) for(R >= w && (R = w - 1), j = q(J, R, w), Y = j.length, se = G.length; U(j, G, Y, se) == 1;)R--, Q(j, Ie < Y ? Me : J, Y, w), Y = j.length, _ = 1;
                        else R == 0 && (_ = R = 1), j = J.slice(), Y = j.length;
                        if (Y < se && (j = [
                            0
                        ].concat(j)), Q(G, j, se, w), se = G.length, _ == -1) for(; U(J, G, Ie, se) < 1;)R++, Q(G, Ie < se ? Me : J, se, w), se = G.length;
                    } else _ === 0 && (R++, G = [
                        0
                    ]);
                    ue[I++] = R, G[0] ? G[se++] = C[ie] || 0 : (G = [
                        C[ie]
                    ], se = 1);
                }while ((ie++ < pe || G[0] != null) && Re--)
                x = G[0] != null, ue[0] || ue.splice(0, 1);
            }
            if (w == qa) {
                for(I = 1, Re = ue[0]; Re >= 10; Re /= 10, I++);
                ne(he, g + (he.e = I + O * pr - 1) + 1, E, x);
            } else he.e = O, he.r = +x;
            return he;
        };
    }();
    function z(q, U, Q, v) {
        var B, g, E, w, _;
        if (Q == null ? Q = s : On(Q, 0, 8), !q.c) return q.toString();
        if (B = q.c[0], E = q.e, U == null) _ = ba(q.c), _ = v == 1 || v == 2 && (E <= c || E >= l) ? Py(_, E) : Au(_, E, "0");
        else if (q = ne(new N(q), U, Q), g = q.e, _ = ba(q.c), w = _.length, v == 1 || v == 2 && (U <= g || g <= c)) {
            for(; w < U; _ += "0", w++);
            _ = Py(_, g);
        } else if (U -= E, _ = Au(_, g, "0"), g + 1 > w) {
            if (--U > 0) for(_ += "."; U--; _ += "0");
        } else if (U += g - w, U > 0) for(g + 1 == w && (_ += "."); U--; _ += "0");
        return q.s < 0 && B ? "-" + _ : _;
    }
    function K(q, U) {
        for(var Q, v, B = 1, g = new N(q[0]); B < q.length; B++)v = new N(q[B]), (!v.s || (Q = Il(g, v)) === U || Q === 0 && g.s === U) && (g = v);
        return g;
    }
    function $(q, U, Q) {
        for(var v = 1, B = U.length; !U[--B]; U.pop());
        for(B = U[0]; B >= 10; B /= 10, v++);
        return (Q = v + Q * pr - 1) > f ? q.c = q.e = null : Q < u ? q.c = [
            q.e = 0
        ] : (q.e = Q, q.c = U), q;
    }
    n = /* @__PURE__ */ function() {
        var q = /^(-?)0([xbo])(?=\w[\w.]*$)/i, U = /^([^.]+)\.$/, Q = /^\.([^.]+)$/, v = /^-?(Infinity|NaN)$/, B = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(g, E, w, _) {
            var O, I = w ? E : E.replace(B, "");
            if (v.test(I)) g.s = isNaN(I) ? null : I < 0 ? -1 : 1;
            else {
                if (!w && (I = I.replace(q, function(x, R, j) {
                    return O = (j = j.toLowerCase()) == "x" ? 16 : j == "b" ? 2 : 8, !_ || _ == O ? R : x;
                }), _ && (O = _, I = I.replace(U, "$1").replace(Q, "0.$1")), E != I)) return new N(I, O);
                if (N.DEBUG) throw Error(mo + "Not a" + (_ ? " base " + _ : "") + " number: " + E);
                g.s = null;
            }
            g.c = g.e = null;
        };
    }();
    function ne(q, U, Q, v) {
        var B, g, E, w, _, O, I, x = q.c, R = s8;
        if (x) {
            e: {
                for(B = 1, w = x[0]; w >= 10; w /= 10, B++);
                if (g = U - B, g < 0) g += pr, E = U, _ = x[O = 0], I = wa(_ / R[B - E - 1] % 10);
                else if (O = o8((g + 1) / pr), O >= x.length) if (v) {
                    for(; x.length <= O; x.push(0));
                    _ = I = 0, B = 1, g %= pr, E = g - pr + 1;
                } else break e;
                else {
                    for(_ = w = x[O], B = 1; w >= 10; w /= 10, B++);
                    g %= pr, E = g - pr + B, I = E < 0 ? 0 : wa(_ / R[B - E - 1] % 10);
                }
                if (v = v || U < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                x[O + 1] != null || (E < 0 ? _ : _ % R[B - E - 1]), v = Q < 4 ? (I || v) && (Q == 0 || Q == (q.s < 0 ? 3 : 2)) : I > 5 || I == 5 && (Q == 4 || v || Q == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (g > 0 ? E > 0 ? _ / R[B - E] : 0 : x[O - 1]) % 10 & 1 || Q == (q.s < 0 ? 8 : 7)), U < 1 || !x[0]) return x.length = 0, v ? (U -= q.e + 1, x[0] = R[(pr - U % pr) % pr], q.e = -U || 0) : x[0] = q.e = 0, q;
                if (g == 0 ? (x.length = O, w = 1, O--) : (x.length = O + 1, w = R[pr - g], x[O] = E > 0 ? wa(_ / R[B - E] % R[E]) * w : 0), v) for(;;)if (O == 0) {
                    for(g = 1, E = x[0]; E >= 10; E /= 10, g++);
                    for(E = x[0] += w, w = 1; E >= 10; E /= 10, w++);
                    g != w && (q.e++, x[0] == qa && (x[0] = 1));
                    break;
                } else {
                    if (x[O] += w, x[O] != qa) break;
                    x[O--] = 0, w = 1;
                }
                for(g = x.length; x[--g] === 0; x.pop());
            }
            q.e > f ? q.c = q.e = null : q.e < u && (q.c = [
                q.e = 0
            ]);
        }
        return q;
    }
    function ee(q) {
        var U, Q = q.e;
        return Q === null ? q.toString() : (U = ba(q.c), U = Q <= c || Q >= l ? Py(U, Q) : Au(U, Q, "0"), q.s < 0 ? "-" + U : U);
    }
    return i1.absoluteValue = i1.abs = function() {
        var q = new N(this);
        return q.s < 0 && (q.s = 1), q;
    }, i1.comparedTo = function(q, U) {
        return Il(this, new N(q, U));
    }, i1.decimalPlaces = i1.dp = function(q, U) {
        var Q, v, B, g = this;
        if (q != null) return On(q, 0, fi), U == null ? U = s : On(U, 0, 8), ne(new N(g), q + g.e + 1, U);
        if (!(Q = g.c)) return null;
        if (v = ((B = Q.length - 1) - Aa(this.e / pr)) * pr, B = Q[B]) for(; B % 10 == 0; B /= 10, v--);
        return v < 0 && (v = 0), v;
    }, i1.dividedBy = i1.div = function(q, U) {
        return t(this, new N(q, U), a, s);
    }, i1.dividedToIntegerBy = i1.idiv = function(q, U) {
        return t(this, new N(q, U), 0, 1);
    }, i1.exponentiatedBy = i1.pow = function(q, U) {
        var Q, v, B, g, E, w, _, O, I, x = this;
        if (q = new N(q), q.c && !q.isInteger()) throw Error(mo + "Exponent not an integer: " + ee(q));
        if (U != null && (U = new N(U)), w = q.e > 14, !x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !q.c || !q.c[0]) return I = new N(Math.pow(+ee(x), w ? q.s * (2 - Ty(q)) : +ee(q))), U ? I.mod(U) : I;
        if (_ = q.s < 0, U) {
            if (U.c ? !U.c[0] : !U.s) return new N(NaN);
            v = !_ && x.isInteger() && U.isInteger(), v && (x = x.mod(U));
        } else {
            if (q.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || w && x.c[1] >= 24e7 : x.c[0] < 8e13 || w && x.c[0] <= 9999975e7))) return g = x.s < 0 && Ty(q) ? -0 : 0, x.e > -1 && (g = 1 / g), new N(_ ? 1 / g : g);
            S && (g = o8(S / pr + 2));
        }
        for(w ? (Q = new N(0.5), _ && (q.s = 1), O = Ty(q)) : (B = Math.abs(+ee(q)), O = B % 2), I = new N(o);;){
            if (O) {
                if (I = I.times(x), !I.c) break;
                g ? I.c.length > g && (I.c.length = g) : v && (I = I.mod(U));
            }
            if (B) {
                if (B = wa(B / 2), B === 0) break;
                O = B % 2;
            } else if (q = q.times(Q), ne(q, q.e + 1, 1), q.e > 14) O = Ty(q);
            else {
                if (B = +ee(q), B === 0) break;
                O = B % 2;
            }
            x = x.times(x), g ? x.c && x.c.length > g && (x.c.length = g) : v && (x = x.mod(U));
        }
        return v ? I : (_ && (I = o.div(I)), U ? I.mod(U) : g ? ne(I, S, s, E) : I);
    }, i1.integerValue = function(q) {
        var U = new N(this);
        return q == null ? q = s : On(q, 0, 8), ne(U, U.e + 1, q);
    }, i1.isEqualTo = i1.eq = function(q, U) {
        return Il(this, new N(q, U)) === 0;
    }, i1.isFinite = function() {
        return !!this.c;
    }, i1.isGreaterThan = i1.gt = function(q, U) {
        return Il(this, new N(q, U)) > 0;
    }, i1.isGreaterThanOrEqualTo = i1.gte = function(q, U) {
        return (U = Il(this, new N(q, U))) === 1 || U === 0;
    }, i1.isInteger = function() {
        return !!this.c && Aa(this.e / pr) > this.c.length - 2;
    }, i1.isLessThan = i1.lt = function(q, U) {
        return Il(this, new N(q, U)) < 0;
    }, i1.isLessThanOrEqualTo = i1.lte = function(q, U) {
        return (U = Il(this, new N(q, U))) === -1 || U === 0;
    }, i1.isNaN = function() {
        return !this.s;
    }, i1.isNegative = function() {
        return this.s < 0;
    }, i1.isPositive = function() {
        return this.s > 0;
    }, i1.isZero = function() {
        return !!this.c && this.c[0] == 0;
    }, i1.minus = function(q, U) {
        var Q, v, B, g, E = this, w = E.s;
        if (q = new N(q, U), U = q.s, !w || !U) return new N(NaN);
        if (w != U) return q.s = -U, E.plus(q);
        var _ = E.e / pr, O = q.e / pr, I = E.c, x = q.c;
        if (!_ || !O) {
            if (!I || !x) return I ? (q.s = -U, q) : new N(x ? E : NaN);
            if (!I[0] || !x[0]) return x[0] ? (q.s = -U, q) : new N(I[0] ? E : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            s == 3 ? -0 : 0);
        }
        if (_ = Aa(_), O = Aa(O), I = I.slice(), w = _ - O) {
            for((g = w < 0) ? (w = -w, B = I) : (O = _, B = x), B.reverse(), U = w; U--; B.push(0));
            B.reverse();
        } else for(v = (g = (w = I.length) < (U = x.length)) ? w : U, w = U = 0; U < v; U++)if (I[U] != x[U]) {
            g = I[U] < x[U];
            break;
        }
        if (g && (B = I, I = x, x = B, q.s = -q.s), U = (v = x.length) - (Q = I.length), U > 0) for(; U--; I[Q++] = 0);
        for(U = qa - 1; v > w;){
            if (I[--v] < x[v]) {
                for(Q = v; Q && !I[--Q]; I[Q] = U);
                --I[Q], I[v] += qa;
            }
            I[v] -= x[v];
        }
        for(; I[0] == 0; I.splice(0, 1), --O);
        return I[0] ? $(q, I, O) : (q.s = s == 3 ? -1 : 1, q.c = [
            q.e = 0
        ], q);
    }, i1.modulo = i1.mod = function(q, U) {
        var Q, v, B = this;
        return q = new N(q, U), !B.c || !q.s || q.c && !q.c[0] ? new N(NaN) : !q.c || B.c && !B.c[0] ? new N(B) : (y == 9 ? (v = q.s, q.s = 1, Q = t(B, q, 0, 3), q.s = v, Q.s *= v) : Q = t(B, q, 0, y), q = B.minus(Q.times(q)), !q.c[0] && y == 1 && (q.s = B.s), q);
    }, i1.multipliedBy = i1.times = function(q, U) {
        var Q, v, B, g, E, w, _, O, I, x, R, j, Y, he, ue, G = this, se = G.c, Z = (q = new N(q, U)).c;
        if (!se || !Z || !se[0] || !Z[0]) return !G.s || !q.s || se && !se[0] && !Z || Z && !Z[0] && !se ? q.c = q.e = q.s = null : (q.s *= G.s, !se || !Z ? q.c = q.e = null : (q.c = [
            0
        ], q.e = 0)), q;
        for(v = Aa(G.e / pr) + Aa(q.e / pr), q.s *= G.s, _ = se.length, x = Z.length, _ < x && (Y = se, se = Z, Z = Y, B = _, _ = x, x = B), B = _ + x, Y = []; B--; Y.push(0));
        for(he = qa, ue = xc, B = x; --B >= 0;){
            for(Q = 0, R = Z[B] % ue, j = Z[B] / ue | 0, E = _, g = B + E; g > B;)O = se[--E] % ue, I = se[E] / ue | 0, w = j * O + I * R, O = R * O + w % ue * ue + Y[g] + Q, Q = (O / he | 0) + (w / ue | 0) + j * I, Y[g--] = O % he;
            Y[g] = Q;
        }
        return Q ? ++v : Y.splice(0, 1), $(q, Y, v);
    }, i1.negated = function() {
        var q = new N(this);
        return q.s = -q.s || null, q;
    }, i1.plus = function(q, U) {
        var Q, v = this, B = v.s;
        if (q = new N(q, U), U = q.s, !B || !U) return new N(NaN);
        if (B != U) return q.s = -U, v.minus(q);
        var g = v.e / pr, E = q.e / pr, w = v.c, _ = q.c;
        if (!g || !E) {
            if (!w || !_) return new N(B / 0);
            if (!w[0] || !_[0]) return _[0] ? q : new N(w[0] ? v : B * 0);
        }
        if (g = Aa(g), E = Aa(E), w = w.slice(), B = g - E) {
            for(B > 0 ? (E = g, Q = _) : (B = -B, Q = w), Q.reverse(); B--; Q.push(0));
            Q.reverse();
        }
        for(B = w.length, U = _.length, B - U < 0 && (Q = _, _ = w, w = Q, U = B), B = 0; U;)B = (w[--U] = w[U] + _[U] + B) / qa | 0, w[U] = qa === w[U] ? 0 : w[U] % qa;
        return B && (w = [
            B
        ].concat(w), ++E), $(q, w, E);
    }, i1.precision = i1.sd = function(q, U) {
        var Q, v, B, g = this;
        if (q != null && q !== !!q) return On(q, 1, fi), U == null ? U = s : On(U, 0, 8), ne(new N(g), q, U);
        if (!(Q = g.c)) return null;
        if (B = Q.length - 1, v = B * pr + 1, B = Q[B]) {
            for(; B % 10 == 0; B /= 10, v--);
            for(B = Q[0]; B >= 10; B /= 10, v++);
        }
        return q && g.e + 1 > v && (v = g.e + 1), v;
    }, i1.shiftedBy = function(q) {
        return On(q, -a8, a8), this.times("1e" + q);
    }, i1.squareRoot = i1.sqrt = function() {
        var q, U, Q, v, B, g = this, E = g.c, w = g.s, _ = g.e, O = a + 4, I = new N("0.5");
        if (w !== 1 || !E || !E[0]) return new N(!w || w < 0 && (!E || E[0]) ? NaN : E ? g : 1 / 0);
        if (w = Math.sqrt(+ee(g)), w == 0 || w == 1 / 0 ? (U = ba(E), (U.length + _) % 2 == 0 && (U += "0"), w = Math.sqrt(+U), _ = Aa((_ + 1) / 2) - (_ < 0 || _ % 2), w == 1 / 0 ? U = "5e" + _ : (U = w.toExponential(), U = U.slice(0, U.indexOf("e") + 1) + _), Q = new N(U)) : Q = new N(w + ""), Q.c[0]) {
            for(_ = Q.e, w = _ + O, w < 3 && (w = 0);;)if (B = Q, Q = I.times(B.plus(t(g, B, O, 1))), ba(B.c).slice(0, w) === (U = ba(Q.c)).slice(0, w)) if (Q.e < _ && --w, U = U.slice(w - 3, w + 1), U == "9999" || !v && U == "4999") {
                if (!v && (ne(B, B.e + a + 2, 0), B.times(B).eq(g))) {
                    Q = B;
                    break;
                }
                O += 4, w += 4, v = 1;
            } else {
                (!+U || !+U.slice(1) && U.charAt(0) == "5") && (ne(Q, Q.e + a + 2, 1), q = !Q.times(Q).eq(g));
                break;
            }
        }
        return ne(Q, Q.e + a + 1, s, q);
    }, i1.toExponential = function(q, U) {
        return q != null && (On(q, 0, fi), q++), z(this, q, U, 1);
    }, i1.toFixed = function(q, U) {
        return q != null && (On(q, 0, fi), q = q + this.e + 1), z(this, q, U);
    }, i1.toFormat = function(q, U, Q) {
        var v, B = this;
        if (Q == null) q != null && U && typeof U == "object" ? (Q = U, U = null) : q && typeof q == "object" ? (Q = q, q = U = null) : Q = k;
        else if (typeof Q != "object") throw Error(mo + "Argument not an object: " + Q);
        if (v = B.toFixed(q, U), B.c) {
            var g, E = v.split("."), w = +Q.groupSize, _ = +Q.secondaryGroupSize, O = Q.groupSeparator || "", I = E[0], x = E[1], R = B.s < 0, j = R ? I.slice(1) : I, Y = j.length;
            if (_ && (g = w, w = _, _ = g, Y -= g), w > 0 && Y > 0) {
                for(g = Y % w || w, I = j.substr(0, g); g < Y; g += w)I += O + j.substr(g, w);
                _ > 0 && (I += O + j.slice(g)), R && (I = "-" + I);
            }
            v = x ? I + (Q.decimalSeparator || "") + ((_ = +Q.fractionGroupSize) ? x.replace(new RegExp("\\d{" + _ + "}\\B", "g"), "$&" + (Q.fractionGroupSeparator || "")) : x) : I;
        }
        return (Q.prefix || "") + v + (Q.suffix || "");
    }, i1.toFraction = function(q) {
        var U, Q, v, B, g, E, w, _, O, I, x, R, j = this, Y = j.c;
        if (q != null && (w = new N(q), !w.isInteger() && (w.c || w.s !== 1) || w.lt(o))) throw Error(mo + "Argument " + (w.isInteger() ? "out of range: " : "not an integer: ") + ee(w));
        if (!Y) return new N(j);
        for(U = new N(o), O = Q = new N(o), v = _ = new N(o), R = ba(Y), g = U.e = R.length - j.e - 1, U.c[0] = s8[(E = g % pr) < 0 ? pr + E : E], q = !q || w.comparedTo(U) > 0 ? g > 0 ? U : O : w, E = f, f = 1 / 0, w = new N(R), _.c[0] = 0; I = t(w, U, 0, 1), B = Q.plus(I.times(v)), B.comparedTo(q) != 1;)Q = v, v = B, O = _.plus(I.times(B = O)), _ = B, U = w.minus(I.times(B = U)), w = B;
        return B = t(q.minus(Q), v, 0, 1), _ = _.plus(B.times(O)), Q = Q.plus(B.times(v)), _.s = O.s = j.s, g = g * 2, x = t(O, v, g, s).minus(j).abs().comparedTo(t(_, Q, g, s).minus(j).abs()) < 1 ? [
            O,
            v
        ] : [
            _,
            Q
        ], f = E, x;
    }, i1.toNumber = function() {
        return +ee(this);
    }, i1.toPrecision = function(q, U) {
        return q != null && On(q, 1, fi), z(this, q, U, 2);
    }, i1.toString = function(q) {
        var U, Q = this, v = Q.s, B = Q.e;
        return B === null ? v ? (U = "Infinity", v < 0 && (U = "-" + U)) : U = "NaN" : (q == null ? U = B <= c || B >= l ? Py(ba(Q.c), B) : Au(ba(Q.c), B, "0") : q === 10 && M ? (Q = ne(new N(Q), a + B + 1, s), U = Au(ba(Q.c), Q.e, "0")) : (On(q, 2, P.length, "Base"), U = r(Au(ba(Q.c), B, "0"), 10, q, v, !0)), v < 0 && Q.c[0] && (U = "-" + U)), U;
    }, i1.valueOf = i1.toJSON = function() {
        return ee(this);
    }, i1._isBigNumber = !0, i1[Symbol.toStringTag] = "BigNumber", i1[Symbol.for("nodejs.util.inspect.custom")] = i1.valueOf, e != null && N.set(e), N;
}
function Aa(e) {
    var t = e | 0;
    return e > 0 || e === t ? t : t - 1;
}
function ba(e) {
    for(var t, r, n = 1, i1 = e.length, o = e[0] + ""; n < i1;){
        for(t = e[n++] + "", r = pr - t.length; r--; t = "0" + t);
        o += t;
    }
    for(i1 = o.length; o.charCodeAt(--i1) === 48;);
    return o.slice(0, i1 + 1 || 1);
}
function Il(e, t) {
    var r, n, i1 = e.c, o = t.c, a = e.s, s = t.s, c = e.e, l = t.e;
    if (!a || !s) return null;
    if (r = i1 && !i1[0], n = o && !o[0], r || n) return r ? n ? 0 : -s : a;
    if (a != s) return a;
    if (r = a < 0, n = c == l, !i1 || !o) return n ? 0 : !i1 ^ r ? 1 : -1;
    if (!n) return c > l ^ r ? 1 : -1;
    for(s = (c = i1.length) < (l = o.length) ? c : l, a = 0; a < s; a++)if (i1[a] != o[a]) return i1[a] > o[a] ^ r ? 1 : -1;
    return c == l ? 0 : c > l ^ r ? 1 : -1;
}
function On(e, t, r, n) {
    if (e < t || e > r || e !== wa(e)) throw Error(mo + (n || "Argument") + (typeof e == "number" ? e < t || e > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function Ty(e) {
    var t = e.c.length - 1;
    return Aa(e.e / pr) == t && e.c[t] % 2 != 0;
}
function Py(e, t) {
    return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function Au(e, t, r) {
    var n, i1;
    if (t < 0) {
        for(i1 = r + "."; ++t; i1 += r);
        e = i1 + e;
    } else if (n = e.length, ++t > n) {
        for(i1 = r, t -= n; --t; i1 += r);
        e += i1;
    } else t < n && (e = e.slice(0, t) + "." + e.slice(t));
    return e;
}
Aj();
var Kbe = [
    "mainnet",
    "testnet"
], qbe = [
    "testnet",
    "regtest",
    "signet"
], Vbe = [
    "mainnet",
    "testnet3",
    "testnet4",
    "regtest",
    "signet"
], Wbe = _e.enum([
    ...Kbe,
    ...qbe
]), Gbe = _e.enum([
    ...Vbe
]);
_e.object({
    name: _e.string(),
    id: _e.string(),
    chain: _e.object({
        bitcoin: _e.object({
            blockchain: _e.literal("bitcoin"),
            bitcoinUrl: _e.string(),
            bitcoinNetwork: Gbe,
            mode: Wbe
        }),
        stacks: _e.object({
            blockchain: _e.literal("stacks"),
            url: _e.string(),
            chainId: _e.number(),
            subnetChainId: _e.number().optional()
        })
    })
});
_e.string().email({
    message: "Invalid email address"
});
var Qbe = _e.object({
    fingerprint: _e.string()
}), $be = Qbe.merge(_e.object({
    accountIndex: _e.number()
})), Zbe = _e.object({
    taprootDescriptor: _e.string(),
    nativeSegwitDescriptor: _e.string()
}), Xbe = _e.object({
    stxAddress: _e.string()
});
_e.object({
    id: $be,
    bitcoin: Zbe.optional(),
    stacks: Xbe.optional()
});
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */ const { entries: vj, setPrototypeOf: uB, isFrozen: Ybe, getPrototypeOf: Jbe, getOwnPropertyDescriptor: ewe } = Object;
let { freeze: uo, seal: Ra, create: Ej } = Object, { apply: q4, construct: V4 } = typeof Reflect < "u" && Reflect;
uo || (uo = function(e) {
    return e;
});
Ra || (Ra = function(e) {
    return e;
});
q4 || (q4 = function(e, t, r) {
    return e.apply(t, r);
});
V4 || (V4 = function(e, t) {
    return new e(...t);
});
const Cy = co(Array.prototype.forEach), twe = co(Array.prototype.lastIndexOf), cB = co(Array.prototype.pop), Tp = co(Array.prototype.push), rwe = co(Array.prototype.splice), rm = co(String.prototype.toLowerCase), u8 = co(String.prototype.toString), lB = co(String.prototype.match), Pp = co(String.prototype.replace), nwe = co(String.prototype.indexOf), iwe = co(String.prototype.trim), Qa = co(Object.prototype.hasOwnProperty), Yi = co(RegExp.prototype.test), Cp = owe(TypeError);
function co(e) {
    return function(t) {
        for(var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i1 = 1; i1 < r; i1++)n[i1 - 1] = arguments[i1];
        return q4(e, t, n);
    };
}
function owe(e) {
    return function() {
        for(var t = arguments.length, r = new Array(t), n = 0; n < t; n++)r[n] = arguments[n];
        return V4(e, r);
    };
}
function Ur(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rm;
    uB && uB(e, null);
    let n = t.length;
    for(; n--;){
        let i1 = t[n];
        if (typeof i1 == "string") {
            const o = r(i1);
            o !== i1 && (Ybe(t) || (t[n] = o), i1 = o);
        }
        e[i1] = !0;
    }
    return e;
}
function awe(e) {
    for(let t = 0; t < e.length; t++)Qa(e, t) || (e[t] = null);
    return e;
}
function Cl(e) {
    const t = Ej(null);
    for (const [r, n] of vj(e))Qa(e, r) && (Array.isArray(n) ? t[r] = awe(n) : n && typeof n == "object" && n.constructor === Object ? t[r] = Cl(n) : t[r] = n);
    return t;
}
function Mp(e, t) {
    for(; e !== null;){
        const n = ewe(e, t);
        if (n) {
            if (n.get) return co(n.get);
            if (typeof n.value == "function") return co(n.value);
        }
        e = Jbe(e);
    }
    function r() {
        return null;
    }
    return r;
}
const fB = uo([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
]), c8 = uo([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
]), l8 = uo([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
]), swe = uo([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
]), f8 = uo([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts"
]), uwe = uo([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
]), dB = uo([
    "#text"
]), hB = uo([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "wrap",
    "xmlns",
    "slot"
]), d8 = uo([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "amplitude",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "exponent",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "intercept",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "slope",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "tablevalues",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
]), pB = uo([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
]), My = uo([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
]), cwe = Ra(/\{\{[\w\W]*|[\w\W]*\}\}/gm), lwe = Ra(/<%[\w\W]*|[\w\W]*%>/gm), fwe = Ra(/\$\{[\w\W]*/gm), dwe = Ra(/^data-[\-\w.\u00B7-\uFFFF]+$/), hwe = Ra(/^aria-[\-\w]+$/), Sj = Ra(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), pwe = Ra(/^(?:\w+script|data):/i), gwe = Ra(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), xj = Ra(/^html$/i), ywe = Ra(/^[a-z][.\w]*(-[.\w]+)+$/i);
var gB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR: hwe,
    ATTR_WHITESPACE: gwe,
    CUSTOM_ELEMENT: ywe,
    DATA_ATTR: dwe,
    DOCTYPE_NAME: xj,
    ERB_EXPR: lwe,
    IS_ALLOWED_URI: Sj,
    IS_SCRIPT_OR_DATA: pwe,
    MUSTACHE_EXPR: cwe,
    TMPLIT_EXPR: fwe
});
const Np = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
}, mwe = function() {
    return typeof window > "u" ? null : window;
}, bwe = function(e, t) {
    if (typeof e != "object" || typeof e.createPolicy != "function") return null;
    let r = null;
    const n = "data-tt-policy-suffix";
    t && t.hasAttribute(n) && (r = t.getAttribute(n));
    const i1 = "dompurify" + (r ? "#" + r : "");
    try {
        return e.createPolicy(i1, {
            createHTML (o) {
                return o;
            },
            createScriptURL (o) {
                return o;
            }
        });
    } catch  {
        return console.warn("TrustedTypes policy " + i1 + " could not be created."), null;
    }
}, yB = function() {
    return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
    };
};
function _j() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mwe();
    const t = (Pe)=>_j(Pe);
    if (t.version = "3.2.4", t.removed = [], !e || !e.document || e.document.nodeType !== Np.document || !e.Element) return t.isSupported = !1, t;
    let { document: r } = e;
    const n = r, i1 = n.currentScript, { DocumentFragment: o, HTMLTemplateElement: a, Node: s, Element: c, NodeFilter: l, NamedNodeMap: u = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: f, DOMParser: h, trustedTypes: y } = e, S = c.prototype, k = Mp(S, "cloneNode"), P = Mp(S, "remove"), M = Mp(S, "nextSibling"), N = Mp(S, "childNodes"), z = Mp(S, "parentNode");
    if (typeof a == "function") {
        const Pe = r.createElement("template");
        Pe.content && Pe.content.ownerDocument && (r = Pe.content.ownerDocument);
    }
    let K, $ = "";
    const { implementation: ne, createNodeIterator: ee, createDocumentFragment: q, getElementsByTagName: U } = r, { importNode: Q } = n;
    let v = yB();
    t.isSupported = typeof vj == "function" && typeof z == "function" && ne && ne.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: B, ERB_EXPR: g, TMPLIT_EXPR: E, DATA_ATTR: w, ARIA_ATTR: _, IS_SCRIPT_OR_DATA: O, ATTR_WHITESPACE: I, CUSTOM_ELEMENT: x } = gB;
    let { IS_ALLOWED_URI: R } = gB, j = null;
    const Y = Ur({}, [
        ...fB,
        ...c8,
        ...l8,
        ...f8,
        ...dB
    ]);
    let he = null;
    const ue = Ur({}, [
        ...hB,
        ...d8,
        ...pB,
        ...My
    ]);
    let G = Object.seal(Ej(null, {
        tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
        }
    })), se = null, Z = null, ie = !0, pe = !0, ve = !1, Ie = !0, Me = !1, Re = !0, C = !1, J = !1, me = !1, je = !1, Ve = !1, nt = !1, We = !0, Ge = !1;
    const p = "user-content-";
    let A = !0, V = !1, re = {}, le = null;
    const L = Ur({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
    ]);
    let X = null;
    const ae = Ur({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
    ]);
    let D = null;
    const H = Ur({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
    ]), te = "http://www.w3.org/1998/Math/MathML", ge = "http://www.w3.org/2000/svg", ce = "http://www.w3.org/1999/xhtml";
    let Ue = ce, qe = !1, ot = null;
    const yt = Ur({}, [
        te,
        ge,
        ce
    ], u8);
    let Ut = Ur({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
    ]), Xe = Ur({}, [
        "annotation-xml"
    ]);
    const _t = Ur({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
    ]);
    let br = null;
    const Lr = [
        "application/xhtml+xml",
        "text/html"
    ], Wt = "text/html";
    let Dt = null, Yt = null;
    const Lt = r.createElement("form"), Dr = function(Pe) {
        return Pe instanceof RegExp || Pe instanceof Function;
    }, xe = function() {
        let Pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(Yt && Yt === Pe)) {
            if ((!Pe || typeof Pe != "object") && (Pe = {}), Pe = Cl(Pe), br = Lr.indexOf(Pe.PARSER_MEDIA_TYPE) === -1 ? Wt : Pe.PARSER_MEDIA_TYPE, Dt = br === "application/xhtml+xml" ? u8 : rm, j = Qa(Pe, "ALLOWED_TAGS") ? Ur({}, Pe.ALLOWED_TAGS, Dt) : Y, he = Qa(Pe, "ALLOWED_ATTR") ? Ur({}, Pe.ALLOWED_ATTR, Dt) : ue, ot = Qa(Pe, "ALLOWED_NAMESPACES") ? Ur({}, Pe.ALLOWED_NAMESPACES, u8) : yt, D = Qa(Pe, "ADD_URI_SAFE_ATTR") ? Ur(Cl(H), Pe.ADD_URI_SAFE_ATTR, Dt) : H, X = Qa(Pe, "ADD_DATA_URI_TAGS") ? Ur(Cl(ae), Pe.ADD_DATA_URI_TAGS, Dt) : ae, le = Qa(Pe, "FORBID_CONTENTS") ? Ur({}, Pe.FORBID_CONTENTS, Dt) : L, se = Qa(Pe, "FORBID_TAGS") ? Ur({}, Pe.FORBID_TAGS, Dt) : {}, Z = Qa(Pe, "FORBID_ATTR") ? Ur({}, Pe.FORBID_ATTR, Dt) : {}, re = Qa(Pe, "USE_PROFILES") ? Pe.USE_PROFILES : !1, ie = Pe.ALLOW_ARIA_ATTR !== !1, pe = Pe.ALLOW_DATA_ATTR !== !1, ve = Pe.ALLOW_UNKNOWN_PROTOCOLS || !1, Ie = Pe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Me = Pe.SAFE_FOR_TEMPLATES || !1, Re = Pe.SAFE_FOR_XML !== !1, C = Pe.WHOLE_DOCUMENT || !1, je = Pe.RETURN_DOM || !1, Ve = Pe.RETURN_DOM_FRAGMENT || !1, nt = Pe.RETURN_TRUSTED_TYPE || !1, me = Pe.FORCE_BODY || !1, We = Pe.SANITIZE_DOM !== !1, Ge = Pe.SANITIZE_NAMED_PROPS || !1, A = Pe.KEEP_CONTENT !== !1, V = Pe.IN_PLACE || !1, R = Pe.ALLOWED_URI_REGEXP || Sj, Ue = Pe.NAMESPACE || ce, Ut = Pe.MATHML_TEXT_INTEGRATION_POINTS || Ut, Xe = Pe.HTML_INTEGRATION_POINTS || Xe, G = Pe.CUSTOM_ELEMENT_HANDLING || {}, Pe.CUSTOM_ELEMENT_HANDLING && Dr(Pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (G.tagNameCheck = Pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Pe.CUSTOM_ELEMENT_HANDLING && Dr(Pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (G.attributeNameCheck = Pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Pe.CUSTOM_ELEMENT_HANDLING && typeof Pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (G.allowCustomizedBuiltInElements = Pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Me && (pe = !1), Ve && (je = !0), re && (j = Ur({}, dB), he = [], re.html === !0 && (Ur(j, fB), Ur(he, hB)), re.svg === !0 && (Ur(j, c8), Ur(he, d8), Ur(he, My)), re.svgFilters === !0 && (Ur(j, l8), Ur(he, d8), Ur(he, My)), re.mathMl === !0 && (Ur(j, f8), Ur(he, pB), Ur(he, My))), Pe.ADD_TAGS && (j === Y && (j = Cl(j)), Ur(j, Pe.ADD_TAGS, Dt)), Pe.ADD_ATTR && (he === ue && (he = Cl(he)), Ur(he, Pe.ADD_ATTR, Dt)), Pe.ADD_URI_SAFE_ATTR && Ur(D, Pe.ADD_URI_SAFE_ATTR, Dt), Pe.FORBID_CONTENTS && (le === L && (le = Cl(le)), Ur(le, Pe.FORBID_CONTENTS, Dt)), A && (j["#text"] = !0), C && Ur(j, [
                "html",
                "head",
                "body"
            ]), j.table && (Ur(j, [
                "tbody"
            ]), delete se.tbody), Pe.TRUSTED_TYPES_POLICY) {
                if (typeof Pe.TRUSTED_TYPES_POLICY.createHTML != "function") throw Cp('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
                if (typeof Pe.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw Cp('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
                K = Pe.TRUSTED_TYPES_POLICY, $ = K.createHTML("");
            } else K === void 0 && (K = bwe(y, i1)), K !== null && typeof $ == "string" && ($ = K.createHTML(""));
            uo && uo(Pe), Yt = Pe;
        }
    }, ye = Ur({}, [
        ...c8,
        ...l8,
        ...swe
    ]), ke = Ur({}, [
        ...f8,
        ...uwe
    ]), Ce = function(Pe) {
        let mt = z(Pe);
        (!mt || !mt.tagName) && (mt = {
            namespaceURI: Ue,
            tagName: "template"
        });
        const ut = rm(Pe.tagName), Jt = rm(mt.tagName);
        return ot[Pe.namespaceURI] ? Pe.namespaceURI === ge ? mt.namespaceURI === ce ? ut === "svg" : mt.namespaceURI === te ? ut === "svg" && (Jt === "annotation-xml" || Ut[Jt]) : !!ye[ut] : Pe.namespaceURI === te ? mt.namespaceURI === ce ? ut === "math" : mt.namespaceURI === ge ? ut === "math" && Xe[Jt] : !!ke[ut] : Pe.namespaceURI === ce ? mt.namespaceURI === ge && !Xe[Jt] || mt.namespaceURI === te && !Ut[Jt] ? !1 : !ke[ut] && (_t[ut] || !ye[ut]) : !!(br === "application/xhtml+xml" && ot[Pe.namespaceURI]) : !1;
    }, De = function(Pe) {
        Tp(t.removed, {
            element: Pe
        });
        try {
            z(Pe).removeChild(Pe);
        } catch  {
            P(Pe);
        }
    }, Ye = function(Pe, mt) {
        try {
            Tp(t.removed, {
                attribute: mt.getAttributeNode(Pe),
                from: mt
            });
        } catch  {
            Tp(t.removed, {
                attribute: null,
                from: mt
            });
        }
        if (mt.removeAttribute(Pe), Pe === "is") if (je || Ve) try {
            De(mt);
        } catch  {}
        else try {
            mt.setAttribute(Pe, "");
        } catch  {}
    }, lt = function(Pe) {
        let mt = null, ut = null;
        if (me) Pe = "<remove></remove>" + Pe;
        else {
            const Tr = lB(Pe, /^[\r\n\t ]+/);
            ut = Tr && Tr[0];
        }
        br === "application/xhtml+xml" && Ue === ce && (Pe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Pe + "</body></html>");
        const Jt = K ? K.createHTML(Pe) : Pe;
        if (Ue === ce) try {
            mt = new h().parseFromString(Jt, br);
        } catch  {}
        if (!mt || !mt.documentElement) {
            mt = ne.createDocument(Ue, "template", null);
            try {
                mt.documentElement.innerHTML = qe ? $ : Jt;
            } catch  {}
        }
        const we = mt.body || mt.documentElement;
        return Pe && ut && we.insertBefore(r.createTextNode(ut), we.childNodes[0] || null), Ue === ce ? U.call(mt, C ? "html" : "body")[0] : C ? mt.documentElement : we;
    }, et = function(Pe) {
        return ee.call(Pe.ownerDocument || Pe, Pe, // eslint-disable-next-line no-bitwise
        l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT | l.SHOW_PROCESSING_INSTRUCTION | l.SHOW_CDATA_SECTION, null);
    }, vt = function(Pe) {
        return Pe instanceof f && (typeof Pe.nodeName != "string" || typeof Pe.textContent != "string" || typeof Pe.removeChild != "function" || !(Pe.attributes instanceof u) || typeof Pe.removeAttribute != "function" || typeof Pe.setAttribute != "function" || typeof Pe.namespaceURI != "string" || typeof Pe.insertBefore != "function" || typeof Pe.hasChildNodes != "function");
    }, At = function(Pe) {
        return typeof s == "function" && Pe instanceof s;
    };
    function dt(Pe, mt, ut) {
        Cy(Pe, (Jt)=>{
            Jt.call(t, mt, ut, Yt);
        });
    }
    const Tt = function(Pe) {
        let mt = null;
        if (dt(v.beforeSanitizeElements, Pe, null), vt(Pe)) return De(Pe), !0;
        const ut = Dt(Pe.nodeName);
        if (dt(v.uponSanitizeElement, Pe, {
            tagName: ut,
            allowedTags: j
        }), Pe.hasChildNodes() && !At(Pe.firstElementChild) && Yi(/<[/\w]/g, Pe.innerHTML) && Yi(/<[/\w]/g, Pe.textContent) || Pe.nodeType === Np.progressingInstruction || Re && Pe.nodeType === Np.comment && Yi(/<[/\w]/g, Pe.data)) return De(Pe), !0;
        if (!j[ut] || se[ut]) {
            if (!se[ut] && Rt(ut) && (G.tagNameCheck instanceof RegExp && Yi(G.tagNameCheck, ut) || G.tagNameCheck instanceof Function && G.tagNameCheck(ut))) return !1;
            if (A && !le[ut]) {
                const Jt = z(Pe) || Pe.parentNode, we = N(Pe) || Pe.childNodes;
                if (we && Jt) {
                    const Tr = we.length;
                    for(let ar = Tr - 1; ar >= 0; --ar){
                        const sr = k(we[ar], !0);
                        sr.__removalCount = (Pe.__removalCount || 0) + 1, Jt.insertBefore(sr, M(Pe));
                    }
                }
            }
            return De(Pe), !0;
        }
        return Pe instanceof c && !Ce(Pe) || (ut === "noscript" || ut === "noembed" || ut === "noframes") && Yi(/<\/no(script|embed|frames)/i, Pe.innerHTML) ? (De(Pe), !0) : (Me && Pe.nodeType === Np.text && (mt = Pe.textContent, Cy([
            B,
            g,
            E
        ], (Jt)=>{
            mt = Pp(mt, Jt, " ");
        }), Pe.textContent !== mt && (Tp(t.removed, {
            element: Pe.cloneNode()
        }), Pe.textContent = mt)), dt(v.afterSanitizeElements, Pe, null), !1);
    }, Pt = function(Pe, mt, ut) {
        if (We && (mt === "id" || mt === "name") && (ut in r || ut in Lt)) return !1;
        if (!(pe && !Z[mt] && Yi(w, mt)) && !(ie && Yi(_, mt))) {
            if (!he[mt] || Z[mt]) {
                if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(Rt(Pe) && (G.tagNameCheck instanceof RegExp && Yi(G.tagNameCheck, Pe) || G.tagNameCheck instanceof Function && G.tagNameCheck(Pe)) && (G.attributeNameCheck instanceof RegExp && Yi(G.attributeNameCheck, mt) || G.attributeNameCheck instanceof Function && G.attributeNameCheck(mt)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                mt === "is" && G.allowCustomizedBuiltInElements && (G.tagNameCheck instanceof RegExp && Yi(G.tagNameCheck, ut) || G.tagNameCheck instanceof Function && G.tagNameCheck(ut)))) return !1;
            } else if (!D[mt] && !Yi(R, Pp(ut, I, "")) && !((mt === "src" || mt === "xlink:href" || mt === "href") && Pe !== "script" && nwe(ut, "data:") === 0 && X[Pe]) && !(ve && !Yi(O, Pp(ut, I, ""))) && ut) return !1;
        }
        return !0;
    }, Rt = function(Pe) {
        return Pe !== "annotation-xml" && lB(Pe, x);
    }, rt = function(Pe) {
        dt(v.beforeSanitizeAttributes, Pe, null);
        const { attributes: mt } = Pe;
        if (!mt || vt(Pe)) return;
        const ut = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: he,
            forceKeepAttr: void 0
        };
        let Jt = mt.length;
        for(; Jt--;){
            const we = mt[Jt], { name: Tr, namespaceURI: ar, value: sr } = we, kt = Dt(Tr);
            let nn = Tr === "value" ? sr : iwe(sr);
            if (ut.attrName = kt, ut.attrValue = nn, ut.keepAttr = !0, ut.forceKeepAttr = void 0, dt(v.uponSanitizeAttribute, Pe, ut), nn = ut.attrValue, Ge && (kt === "id" || kt === "name") && (Ye(Tr, Pe), nn = p + nn), Re && Yi(/((--!?|])>)|<\/(style|title)/i, nn)) {
                Ye(Tr, Pe);
                continue;
            }
            if (ut.forceKeepAttr || (Ye(Tr, Pe), !ut.keepAttr)) continue;
            if (!Ie && Yi(/\/>/i, nn)) {
                Ye(Tr, Pe);
                continue;
            }
            Me && Cy([
                B,
                g,
                E
            ], (b)=>{
                nn = Pp(nn, b, " ");
            });
            const bi = Dt(Pe.nodeName);
            if (Pt(bi, kt, nn)) {
                if (K && typeof y == "object" && typeof y.getAttributeType == "function" && !ar) switch(y.getAttributeType(bi, kt)){
                    case "TrustedHTML":
                        {
                            nn = K.createHTML(nn);
                            break;
                        }
                    case "TrustedScriptURL":
                        {
                            nn = K.createScriptURL(nn);
                            break;
                        }
                }
                try {
                    ar ? Pe.setAttributeNS(ar, Tr, nn) : Pe.setAttribute(Tr, nn), vt(Pe) ? De(Pe) : cB(t.removed);
                } catch  {}
            }
        }
        dt(v.afterSanitizeAttributes, Pe, null);
    }, Et = function Pe(mt) {
        let ut = null;
        const Jt = et(mt);
        for(dt(v.beforeSanitizeShadowDOM, mt, null); ut = Jt.nextNode();)dt(v.uponSanitizeShadowNode, ut, null), Tt(ut), rt(ut), ut.content instanceof o && Pe(ut.content);
        dt(v.afterSanitizeShadowDOM, mt, null);
    };
    return t.sanitize = function(Pe) {
        let mt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ut = null, Jt = null, we = null, Tr = null;
        if (qe = !Pe, qe && (Pe = "<!-->"), typeof Pe != "string" && !At(Pe)) if (typeof Pe.toString == "function") {
            if (Pe = Pe.toString(), typeof Pe != "string") throw Cp("dirty is not a string, aborting");
        } else throw Cp("toString is not a function");
        if (!t.isSupported) return Pe;
        if (J || xe(mt), t.removed = [], typeof Pe == "string" && (V = !1), V) {
            if (Pe.nodeName) {
                const kt = Dt(Pe.nodeName);
                if (!j[kt] || se[kt]) throw Cp("root node is forbidden and cannot be sanitized in-place");
            }
        } else if (Pe instanceof s) ut = lt("<!---->"), Jt = ut.ownerDocument.importNode(Pe, !0), Jt.nodeType === Np.element && Jt.nodeName === "BODY" || Jt.nodeName === "HTML" ? ut = Jt : ut.appendChild(Jt);
        else {
            if (!je && !Me && !C && // eslint-disable-next-line unicorn/prefer-includes
            Pe.indexOf("<") === -1) return K && nt ? K.createHTML(Pe) : Pe;
            if (ut = lt(Pe), !ut) return je ? null : nt ? $ : "";
        }
        ut && me && De(ut.firstChild);
        const ar = et(V ? Pe : ut);
        for(; we = ar.nextNode();)Tt(we), rt(we), we.content instanceof o && Et(we.content);
        if (V) return Pe;
        if (je) {
            if (Ve) for(Tr = q.call(ut.ownerDocument); ut.firstChild;)Tr.appendChild(ut.firstChild);
            else Tr = ut;
            return (he.shadowroot || he.shadowrootmode) && (Tr = Q.call(n, Tr, !0)), Tr;
        }
        let sr = C ? ut.outerHTML : ut.innerHTML;
        return C && j["!doctype"] && ut.ownerDocument && ut.ownerDocument.doctype && ut.ownerDocument.doctype.name && Yi(xj, ut.ownerDocument.doctype.name) && (sr = "<!DOCTYPE " + ut.ownerDocument.doctype.name + `>
` + sr), Me && Cy([
            B,
            g,
            E
        ], (kt)=>{
            sr = Pp(sr, kt, " ");
        }), K && nt ? K.createHTML(sr) : sr;
    }, t.setConfig = function() {
        let Pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        xe(Pe), J = !0;
    }, t.clearConfig = function() {
        Yt = null, J = !1;
    }, t.isValidAttribute = function(Pe, mt, ut) {
        Yt || xe({});
        const Jt = Dt(Pe), we = Dt(mt);
        return Pt(Jt, we, ut);
    }, t.addHook = function(Pe, mt) {
        typeof mt == "function" && Tp(v[Pe], mt);
    }, t.removeHook = function(Pe, mt) {
        if (mt !== void 0) {
            const ut = twe(v[Pe], mt);
            return ut === -1 ? void 0 : rwe(v[Pe], ut, 1)[0];
        }
        return cB(v[Pe]);
    }, t.removeHooks = function(Pe) {
        v[Pe] = [];
    }, t.removeAllHooks = function() {
        v = yB();
    }, t;
}
_j();
var wwe = [
    {
        name: "US Dollar",
        symbol: "$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "USD",
        namePlural: "US dollars"
    },
    {
        name: "Canadian Dollar",
        symbol: "CA$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "CAD",
        namePlural: "Canadian dollars"
    },
    {
        name: "Euro",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "EUR",
        namePlural: "euros"
    },
    {
        name: "United Arab Emirates Dirham",
        symbol: "AED",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "AED",
        namePlural: "UAE dirhams"
    },
    {
        name: "Afghan Afghani",
        symbol: "Af",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "AFN",
        namePlural: "Afghan Afghanis"
    },
    {
        name: "Albanian Lek",
        symbol: "ALL",
        symbolNative: "Lek",
        decimalDigits: 0,
        rounding: 0,
        code: "ALL",
        namePlural: "Albanian lek"
    },
    {
        name: "Armenian Dram",
        symbol: "AMD",
        symbolNative: ".",
        decimalDigits: 0,
        rounding: 0,
        code: "AMD",
        namePlural: "Armenian drams"
    },
    {
        name: "Argentine Peso",
        symbol: "AR$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "ARS",
        namePlural: "Argentine pesos"
    },
    {
        name: "Australian Dollar",
        symbol: "AU$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "AUD",
        namePlural: "Australian dollars"
    },
    {
        name: "Azerbaijani Manat",
        symbol: "man.",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "AZN",
        namePlural: "Azerbaijani manats"
    },
    {
        name: "Bosnia-Herzegovina Convertible Mark",
        symbol: "KM",
        symbolNative: "KM",
        decimalDigits: 2,
        rounding: 0,
        code: "BAM",
        namePlural: "Bosnia-Herzegovina convertible marks"
    },
    {
        name: "Bangladeshi Taka",
        symbol: "Tk",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "BDT",
        namePlural: "Bangladeshi takas"
    },
    {
        name: "Bulgarian Lev",
        symbol: "BGN",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "BGN",
        namePlural: "Bulgarian leva"
    },
    {
        name: "Bahraini Dinar",
        symbol: "BD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "BHD",
        namePlural: "Bahraini dinars"
    },
    {
        name: "Burundian Franc",
        symbol: "FBu",
        symbolNative: "FBu",
        decimalDigits: 0,
        rounding: 0,
        code: "BIF",
        namePlural: "Burundian francs"
    },
    {
        name: "Brunei Dollar",
        symbol: "BN$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "BND",
        namePlural: "Brunei dollars"
    },
    {
        name: "Bolivian Boliviano",
        symbol: "Bs",
        symbolNative: "Bs",
        decimalDigits: 2,
        rounding: 0,
        code: "BOB",
        namePlural: "Bolivian bolivianos"
    },
    {
        name: "Brazilian Real",
        symbol: "R$",
        symbolNative: "R$",
        decimalDigits: 2,
        rounding: 0,
        code: "BRL",
        namePlural: "Brazilian reals"
    },
    {
        name: "Botswanan Pula",
        symbol: "BWP",
        symbolNative: "P",
        decimalDigits: 2,
        rounding: 0,
        code: "BWP",
        namePlural: "Botswanan pulas"
    },
    {
        name: "Belarusian Ruble",
        symbol: "Br",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "BYN",
        namePlural: "Belarusian rubles"
    },
    {
        name: "Belize Dollar",
        symbol: "BZ$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "BZD",
        namePlural: "Belize dollars"
    },
    {
        name: "Congolese Franc",
        symbol: "CDF",
        symbolNative: "FrCD",
        decimalDigits: 2,
        rounding: 0,
        code: "CDF",
        namePlural: "Congolese francs"
    },
    {
        name: "Swiss Franc",
        symbol: "CHF",
        symbolNative: "CHF",
        decimalDigits: 2,
        rounding: 0.05,
        code: "CHF",
        namePlural: "Swiss francs"
    },
    {
        name: "Chilean Peso",
        symbol: "CL$",
        symbolNative: "$",
        decimalDigits: 0,
        rounding: 0,
        code: "CLP",
        namePlural: "Chilean pesos"
    },
    {
        name: "Chinese Yuan",
        symbol: "CN",
        symbolNative: "CN",
        decimalDigits: 2,
        rounding: 0,
        code: "CNY",
        namePlural: "Chinese yuan"
    },
    {
        name: "Colombian Peso",
        symbol: "CO$",
        symbolNative: "$",
        decimalDigits: 0,
        rounding: 0,
        code: "COP",
        namePlural: "Colombian pesos"
    },
    {
        name: "Costa Rican Coln",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "CRC",
        namePlural: "Costa Rican colns"
    },
    {
        name: "Cape Verdean Escudo",
        symbol: "CV$",
        symbolNative: "CV$",
        decimalDigits: 2,
        rounding: 0,
        code: "CVE",
        namePlural: "Cape Verdean escudos"
    },
    {
        name: "Czech Republic Koruna",
        symbol: "K",
        symbolNative: "K",
        decimalDigits: 2,
        rounding: 0,
        code: "CZK",
        namePlural: "Czech Republic korunas"
    },
    {
        name: "Djiboutian Franc",
        symbol: "Fdj",
        symbolNative: "Fdj",
        decimalDigits: 0,
        rounding: 0,
        code: "DJF",
        namePlural: "Djiboutian francs"
    },
    {
        name: "Danish Krone",
        symbol: "Dkr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "DKK",
        namePlural: "Danish kroner"
    },
    {
        name: "Dominican Peso",
        symbol: "RD$",
        symbolNative: "RD$",
        decimalDigits: 2,
        rounding: 0,
        code: "DOP",
        namePlural: "Dominican pesos"
    },
    {
        name: "Algerian Dinar",
        symbol: "DA",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "DZD",
        namePlural: "Algerian dinars"
    },
    {
        name: "Estonian Kroon",
        symbol: "Ekr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "EEK",
        namePlural: "Estonian kroons"
    },
    {
        name: "Egyptian Pound",
        symbol: "EGP",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "EGP",
        namePlural: "Egyptian pounds"
    },
    {
        name: "Eritrean Nakfa",
        symbol: "Nfk",
        symbolNative: "Nfk",
        decimalDigits: 2,
        rounding: 0,
        code: "ERN",
        namePlural: "Eritrean nakfas"
    },
    {
        name: "Ethiopian Birr",
        symbol: "Br",
        symbolNative: "Br",
        decimalDigits: 2,
        rounding: 0,
        code: "ETB",
        namePlural: "Ethiopian birrs"
    },
    {
        name: "British Pound Sterling",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "GBP",
        namePlural: "British pounds sterling"
    },
    {
        name: "Georgian Lari",
        symbol: "GEL",
        symbolNative: "GEL",
        decimalDigits: 2,
        rounding: 0,
        code: "GEL",
        namePlural: "Georgian laris"
    },
    {
        name: "Ghanaian Cedi",
        symbol: "GH",
        symbolNative: "GH",
        decimalDigits: 2,
        rounding: 0,
        code: "GHS",
        namePlural: "Ghanaian cedis"
    },
    {
        name: "Guinean Franc",
        symbol: "FG",
        symbolNative: "FG",
        decimalDigits: 0,
        rounding: 0,
        code: "GNF",
        namePlural: "Guinean francs"
    },
    {
        name: "Guatemalan Quetzal",
        symbol: "GTQ",
        symbolNative: "Q",
        decimalDigits: 2,
        rounding: 0,
        code: "GTQ",
        namePlural: "Guatemalan quetzals"
    },
    {
        name: "Hong Kong Dollar",
        symbol: "HK$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "HKD",
        namePlural: "Hong Kong dollars"
    },
    {
        name: "Honduran Lempira",
        symbol: "HNL",
        symbolNative: "L",
        decimalDigits: 2,
        rounding: 0,
        code: "HNL",
        namePlural: "Honduran lempiras"
    },
    {
        name: "Croatian Kuna",
        symbol: "kn",
        symbolNative: "kn",
        decimalDigits: 2,
        rounding: 0,
        code: "HRK",
        namePlural: "Croatian kunas"
    },
    {
        name: "Hungarian Forint",
        symbol: "Ft",
        symbolNative: "Ft",
        decimalDigits: 0,
        rounding: 0,
        code: "HUF",
        namePlural: "Hungarian forints"
    },
    {
        name: "Indonesian Rupiah",
        symbol: "Rp",
        symbolNative: "Rp",
        decimalDigits: 0,
        rounding: 0,
        code: "IDR",
        namePlural: "Indonesian rupiahs"
    },
    {
        name: "Israeli New Sheqel",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "ILS",
        namePlural: "Israeli new sheqels"
    },
    {
        name: "Indian Rupee",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "INR",
        namePlural: "Indian rupees"
    },
    {
        name: "Iraqi Dinar",
        symbol: "IQD",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "IQD",
        namePlural: "Iraqi dinars"
    },
    {
        name: "Iranian Rial",
        symbol: "IRR",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "IRR",
        namePlural: "Iranian rials"
    },
    {
        name: "Icelandic Krna",
        symbol: "Ikr",
        symbolNative: "kr",
        decimalDigits: 0,
        rounding: 0,
        code: "ISK",
        namePlural: "Icelandic krnur"
    },
    {
        name: "Jamaican Dollar",
        symbol: "J$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "JMD",
        namePlural: "Jamaican dollars"
    },
    {
        name: "Jordanian Dinar",
        symbol: "JD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "JOD",
        namePlural: "Jordanian dinars"
    },
    {
        name: "Japanese Yen",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "JPY",
        namePlural: "Japanese yen"
    },
    {
        name: "Kenyan Shilling",
        symbol: "Ksh",
        symbolNative: "Ksh",
        decimalDigits: 2,
        rounding: 0,
        code: "KES",
        namePlural: "Kenyan shillings"
    },
    {
        name: "Cambodian Riel",
        symbol: "KHR",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "KHR",
        namePlural: "Cambodian riels"
    },
    {
        name: "Comorian Franc",
        symbol: "CF",
        symbolNative: "FC",
        decimalDigits: 0,
        rounding: 0,
        code: "KMF",
        namePlural: "Comorian francs"
    },
    {
        name: "South Korean Won",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "KRW",
        namePlural: "South Korean won"
    },
    {
        name: "Kuwaiti Dinar",
        symbol: "KD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "KWD",
        namePlural: "Kuwaiti dinars"
    },
    {
        name: "Kazakhstani Tenge",
        symbol: "KZT",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "KZT",
        namePlural: "Kazakhstani tenges"
    },
    {
        name: "Lebanese Pound",
        symbol: "LB",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "LBP",
        namePlural: "Lebanese pounds"
    },
    {
        name: "Sri Lankan Rupee",
        symbol: "SLRs",
        symbolNative: "SL Re",
        decimalDigits: 2,
        rounding: 0,
        code: "LKR",
        namePlural: "Sri Lankan rupees"
    },
    {
        name: "Lithuanian Litas",
        symbol: "Lt",
        symbolNative: "Lt",
        decimalDigits: 2,
        rounding: 0,
        code: "LTL",
        namePlural: "Lithuanian litai"
    },
    {
        name: "Latvian Lats",
        symbol: "Ls",
        symbolNative: "Ls",
        decimalDigits: 2,
        rounding: 0,
        code: "LVL",
        namePlural: "Latvian lati"
    },
    {
        name: "Libyan Dinar",
        symbol: "LD",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "LYD",
        namePlural: "Libyan dinars"
    },
    {
        name: "Moroccan Dirham",
        symbol: "MAD",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "MAD",
        namePlural: "Moroccan dirhams"
    },
    {
        name: "Moldovan Leu",
        symbol: "MDL",
        symbolNative: "MDL",
        decimalDigits: 2,
        rounding: 0,
        code: "MDL",
        namePlural: "Moldovan lei"
    },
    {
        name: "Malagasy Ariary",
        symbol: "MGA",
        symbolNative: "MGA",
        decimalDigits: 0,
        rounding: 0,
        code: "MGA",
        namePlural: "Malagasy Ariaries"
    },
    {
        name: "Macedonian Denar",
        symbol: "MKD",
        symbolNative: "MKD",
        decimalDigits: 2,
        rounding: 0,
        code: "MKD",
        namePlural: "Macedonian denari"
    },
    {
        name: "Myanma Kyat",
        symbol: "MMK",
        symbolNative: "K",
        decimalDigits: 0,
        rounding: 0,
        code: "MMK",
        namePlural: "Myanma kyats"
    },
    {
        name: "Macanese Pataca",
        symbol: "MOP$",
        symbolNative: "MOP$",
        decimalDigits: 2,
        rounding: 0,
        code: "MOP",
        namePlural: "Macanese patacas"
    },
    {
        name: "Mauritian Rupee",
        symbol: "MURs",
        symbolNative: "MURs",
        decimalDigits: 0,
        rounding: 0,
        code: "MUR",
        namePlural: "Mauritian rupees"
    },
    {
        name: "Mexican Peso",
        symbol: "MX$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "MXN",
        namePlural: "Mexican pesos"
    },
    {
        name: "Malaysian Ringgit",
        symbol: "RM",
        symbolNative: "RM",
        decimalDigits: 2,
        rounding: 0,
        code: "MYR",
        namePlural: "Malaysian ringgits"
    },
    {
        name: "Mozambican Metical",
        symbol: "MTn",
        symbolNative: "MTn",
        decimalDigits: 2,
        rounding: 0,
        code: "MZN",
        namePlural: "Mozambican meticals"
    },
    {
        name: "Namibian Dollar",
        symbol: "N$",
        symbolNative: "N$",
        decimalDigits: 2,
        rounding: 0,
        code: "NAD",
        namePlural: "Namibian dollars"
    },
    {
        name: "Nigerian Naira",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "NGN",
        namePlural: "Nigerian nairas"
    },
    {
        name: "Nicaraguan Crdoba",
        symbol: "C$",
        symbolNative: "C$",
        decimalDigits: 2,
        rounding: 0,
        code: "NIO",
        namePlural: "Nicaraguan crdobas"
    },
    {
        name: "Norwegian Krone",
        symbol: "Nkr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "NOK",
        namePlural: "Norwegian kroner"
    },
    {
        name: "Nepalese Rupee",
        symbol: "NPRs",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "NPR",
        namePlural: "Nepalese rupees"
    },
    {
        name: "New Zealand Dollar",
        symbol: "NZ$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "NZD",
        namePlural: "New Zealand dollars"
    },
    {
        name: "Omani Rial",
        symbol: "OMR",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "OMR",
        namePlural: "Omani rials"
    },
    {
        name: "Panamanian Balboa",
        symbol: "B/.",
        symbolNative: "B/.",
        decimalDigits: 2,
        rounding: 0,
        code: "PAB",
        namePlural: "Panamanian balboas"
    },
    {
        name: "Peruvian Nuevo Sol",
        symbol: "S/.",
        symbolNative: "S/.",
        decimalDigits: 2,
        rounding: 0,
        code: "PEN",
        namePlural: "Peruvian nuevos soles"
    },
    {
        name: "Philippine Peso",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "PHP",
        namePlural: "Philippine pesos"
    },
    {
        name: "Pakistani Rupee",
        symbol: "PKRs",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "PKR",
        namePlural: "Pakistani rupees"
    },
    {
        name: "Polish Zloty",
        symbol: "z",
        symbolNative: "z",
        decimalDigits: 2,
        rounding: 0,
        code: "PLN",
        namePlural: "Polish zlotys"
    },
    {
        name: "Paraguayan Guarani",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "PYG",
        namePlural: "Paraguayan guaranis"
    },
    {
        name: "Qatari Rial",
        symbol: "QR",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "QAR",
        namePlural: "Qatari rials"
    },
    {
        name: "Romanian Leu",
        symbol: "RON",
        symbolNative: "RON",
        decimalDigits: 2,
        rounding: 0,
        code: "RON",
        namePlural: "Romanian lei"
    },
    {
        name: "Serbian Dinar",
        symbol: "din.",
        symbolNative: ".",
        decimalDigits: 0,
        rounding: 0,
        code: "RSD",
        namePlural: "Serbian dinars"
    },
    {
        name: "Russian Ruble",
        symbol: "RUB",
        symbolNative: ".",
        decimalDigits: 2,
        rounding: 0,
        code: "RUB",
        namePlural: "Russian rubles"
    },
    {
        name: "Rwandan Franc",
        symbol: "RWF",
        symbolNative: "FR",
        decimalDigits: 0,
        rounding: 0,
        code: "RWF",
        namePlural: "Rwandan francs"
    },
    {
        name: "Saudi Riyal",
        symbol: "SR",
        symbolNative: "..",
        decimalDigits: 2,
        rounding: 0,
        code: "SAR",
        namePlural: "Saudi riyals"
    },
    {
        name: "Sudanese Pound",
        symbol: "SDG",
        symbolNative: "SDG",
        decimalDigits: 2,
        rounding: 0,
        code: "SDG",
        namePlural: "Sudanese pounds"
    },
    {
        name: "Swedish Krona",
        symbol: "Skr",
        symbolNative: "kr",
        decimalDigits: 2,
        rounding: 0,
        code: "SEK",
        namePlural: "Swedish kronor"
    },
    {
        name: "Singapore Dollar",
        symbol: "S$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "SGD",
        namePlural: "Singapore dollars"
    },
    {
        name: "Somali Shilling",
        symbol: "Ssh",
        symbolNative: "Ssh",
        decimalDigits: 0,
        rounding: 0,
        code: "SOS",
        namePlural: "Somali shillings"
    },
    {
        name: "Syrian Pound",
        symbol: "SY",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "SYP",
        namePlural: "Syrian pounds"
    },
    {
        name: "Thai Baht",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "THB",
        namePlural: "Thai baht"
    },
    {
        name: "Tunisian Dinar",
        symbol: "DT",
        symbolNative: "..",
        decimalDigits: 3,
        rounding: 0,
        code: "TND",
        namePlural: "Tunisian dinars"
    },
    {
        name: "Tongan Paanga",
        symbol: "T$",
        symbolNative: "T$",
        decimalDigits: 2,
        rounding: 0,
        code: "TOP",
        namePlural: "Tongan paanga"
    },
    {
        name: "Turkish Lira",
        symbol: "TL",
        symbolNative: "TL",
        decimalDigits: 2,
        rounding: 0,
        code: "TRY",
        namePlural: "Turkish Lira"
    },
    {
        name: "Trinidad and Tobago Dollar",
        symbol: "TT$",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "TTD",
        namePlural: "Trinidad and Tobago dollars"
    },
    {
        name: "New Taiwan Dollar",
        symbol: "NT$",
        symbolNative: "NT$",
        decimalDigits: 2,
        rounding: 0,
        code: "TWD",
        namePlural: "New Taiwan dollars"
    },
    {
        name: "Tanzanian Shilling",
        symbol: "TSh",
        symbolNative: "TSh",
        decimalDigits: 0,
        rounding: 0,
        code: "TZS",
        namePlural: "Tanzanian shillings"
    },
    {
        name: "Ukrainian Hryvnia",
        symbol: "",
        symbolNative: "",
        decimalDigits: 2,
        rounding: 0,
        code: "UAH",
        namePlural: "Ukrainian hryvnias"
    },
    {
        name: "Ugandan Shilling",
        symbol: "USh",
        symbolNative: "USh",
        decimalDigits: 0,
        rounding: 0,
        code: "UGX",
        namePlural: "Ugandan shillings"
    },
    {
        name: "Uruguayan Peso",
        symbol: "$U",
        symbolNative: "$",
        decimalDigits: 2,
        rounding: 0,
        code: "UYU",
        namePlural: "Uruguayan pesos"
    },
    {
        name: "Uzbekistan Som",
        symbol: "UZS",
        symbolNative: "UZS",
        decimalDigits: 0,
        rounding: 0,
        code: "UZS",
        namePlural: "Uzbekistan som"
    },
    {
        name: "Venezuelan Bolvar",
        symbol: "Bs.F.",
        symbolNative: "Bs.F.",
        decimalDigits: 2,
        rounding: 0,
        code: "VEF",
        namePlural: "Venezuelan bolvars"
    },
    {
        name: "Vietnamese Dong",
        symbol: "",
        symbolNative: "",
        decimalDigits: 0,
        rounding: 0,
        code: "VND",
        namePlural: "Vietnamese dong"
    },
    {
        name: "CFA Franc BEAC",
        symbol: "FCFA",
        symbolNative: "FCFA",
        decimalDigits: 0,
        rounding: 0,
        code: "XAF",
        namePlural: "CFA francs BEAC"
    },
    {
        name: "CFA Franc BCEAO",
        symbol: "CFA",
        symbolNative: "CFA",
        decimalDigits: 0,
        rounding: 0,
        code: "XOF",
        namePlural: "CFA francs BCEAO"
    },
    {
        name: "Yemeni Rial",
        symbol: "YR",
        symbolNative: "..",
        decimalDigits: 0,
        rounding: 0,
        code: "YER",
        namePlural: "Yemeni rials"
    },
    {
        name: "South African Rand",
        symbol: "R",
        symbolNative: "R",
        decimalDigits: 2,
        rounding: 0,
        code: "ZAR",
        namePlural: "South African rand"
    },
    {
        name: "Zambian Kwacha",
        symbol: "ZK",
        symbolNative: "ZK",
        decimalDigits: 0,
        rounding: 0,
        code: "ZMK",
        namePlural: "Zambian kwachas"
    },
    {
        name: "Zimbabwean Dollar",
        symbol: "ZWL$",
        symbolNative: "ZWL$",
        decimalDigits: 0,
        rounding: 0,
        code: "ZWL",
        namePlural: "Zimbabwean Dollar"
    }
];
new Set(wwe.map((e)=>e.code));
function mB(e) {
    return typeof e == "number";
}
function Awe(e) {
    return typeof e > "u";
}
function vwe(e) {
    return Array.isArray(e) ? e.every((t)=>mB(t)) : mB(e);
}
var Ewe = _e.string().array(), Swe = _e.record(_e.string(), _e.unknown());
_e.union([
    Ewe,
    Swe,
    _e.undefined()
]);
var b2 = _e.object({
    jsonrpc: _e.literal("2.0"),
    id: _e.string()
});
function bB(e, t) {
    return t ? b2.extend({
        method: _e.literal(e),
        params: t
    }) : b2.extend({
        method: _e.literal(e)
    });
}
var E7 = /* @__PURE__ */ ((e)=>(e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.SERVER_ERROR = -32e3] = "SERVER_ERROR", e[e.USER_REJECTION = 4001] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = 4002] = "METHOD_NOT_SUPPORTED", e[e.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", e[e.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", e))(E7 || {}), xwe = _e.nativeEnum(E7);
function _we(e) {
    return _e.object({
        code: _e.union([
            _e.number(),
            xwe
        ]),
        message: _e.string(),
        data: e.optional()
    });
}
function kwe(e) {
    return b2.extend({
        error: e
    });
}
var Owe = _we(_e.any());
function Iwe(e) {
    return b2.extend({
        result: e
    });
}
function wB(e, t) {
    return _e.union([
        Iwe(e),
        kwe(t)
    ]);
}
function ci(e) {
    const t = e.error ?? Owe;
    return "params" in e ? {
        method: e.method,
        params: e.params,
        result: e.result,
        error: t,
        request: bB(e.method, e.params),
        response: wB(e.result, t)
    } : {
        method: e.method,
        result: e.result,
        error: t,
        request: bB(e.method),
        response: wB(e.result, t)
    };
}
var Bwe = _e.object({
    account: _e.number().optional(),
    address: _e.string(),
    amount: _e.coerce.string(),
    network: _e.string()
}), Twe = _e.object({
    address: _e.string(),
    amount: _e.coerce.string()
}), Pwe = _e.object({
    account: _e.number().optional(),
    recipients: _e.array(Twe),
    network: _e.string()
}), Cwe = _e.union([
    Bwe,
    Pwe
]);
ci({
    method: "sendTransfer",
    params: Cwe,
    result: _e.object({
        txid: _e.string()
    })
});
var Mwe = _e.enum([
    "legacy",
    "bip322"
]), Nwe = _e.enum([
    "p2tr",
    "p2wpkh"
]), Rwe = _e.object({
    type: Mwe.optional(),
    account: _e.number().optional(),
    message: _e.string(),
    paymentType: Nwe
}).passthrough();
ci({
    method: "signMessage",
    params: Rwe,
    result: _e.object({
        signature: _e.string(),
        address: _e.string()
    }).passthrough()
});
function Uwe(e) {
    return Awe(e) ? !0 : vwe(e);
}
var Dwe = _e.object({
    account: _e.number().optional(),
    allowedSighash: _e.array(_e.any()).optional(),
    broadcast: _e.boolean().optional(),
    hex: _e.string(),
    network: _e.string().optional(),
    signAtIndex: _e.union([
        _e.number(),
        _e.array(_e.number())
    ]).optional().refine(Uwe)
}), jwe = _e.object({
    hex: _e.string(),
    txid: _e.string().optional()
});
ci({
    method: "signPsbt",
    params: Dwe,
    result: jwe
});
var Fwe = _e.enum([
    "p2pkh",
    "p2sh",
    "p2wpkh-p2sh",
    "p2wpkh",
    "p2tr"
]), kj = _e.object({
    symbol: _e.literal("BTC"),
    type: Fwe,
    address: _e.string(),
    publicKey: _e.string(),
    derivationPath: _e.string()
}), zwe = kj.extend({
    type: _e.literal("p2wpkh")
}).passthrough(), Lwe = kj.extend({
    type: _e.literal("p2tr"),
    tweakedPublicKey: _e.string()
}).passthrough(), Hwe = _e.discriminatedUnion("type", [
    zwe,
    Lwe
]), Kwe = _e.object({
    symbol: _e.literal("STX"),
    address: _e.string(),
    publicKey: _e.string()
}).passthrough(), qwe = _e.union([
    Hwe,
    Kwe
]), Vwe = _e.object({
    addresses: _e.array(qwe)
}).passthrough();
ci({
    method: "getAddresses",
    params: _e.object({
        network: _e.string().optional()
    }).optional(),
    result: Vwe
});
var Wwe = _e.object({
    version: _e.string(),
    supportedMethods: _e.array(_e.string()).optional(),
    platform: _e.union([
        _e.literal("mobile"),
        _e.literal("extension")
    ])
});
ci({
    method: "getInfo",
    result: Wwe
});
ci({
    method: "open",
    params: _e.object({
        mode: _e.enum([
            "fullpage",
            "popup"
        ])
    }).default({
        mode: "popup"
    }),
    result: _e.object({
        success: _e.literal(!0)
    })
});
var Gwe = _e.object({
    base: _e.string(),
    quote: _e.string()
}), Qwe = _e.object({
    message: _e.string()
});
ci({
    method: "openSwap",
    params: Gwe,
    result: Qwe
});
var np = _e.object({
    txid: _e.string(),
    transaction: _e.string()
}), V1 = _e.object({
    address: _e.string().optional(),
    network: _e.union([
        _e.literal("mainnet"),
        _e.literal("testnet"),
        _e.literal("regtest"),
        _e.literal("devnet"),
        _e.literal("mocknet"),
        _e.string()
    ]).optional(),
    fee: _e.coerce.number().optional(),
    nonce: _e.coerce.number().optional(),
    // add pc later when imported from stacks.js
    postConditions: _e.array(_e.string()).optional(),
    postConditionMode: _e.union([
        _e.literal("allow"),
        _e.literal("deny")
    ]).optional(),
    sponsored: _e.boolean().optional()
});
ci({
    method: "stx_callContract",
    params: _e.intersection(_e.object({
        contract: _e.string(),
        functionName: _e.string(),
        functionArgs: _e.array(_e.string()).optional()
    }), V1),
    result: np
});
var $we = np;
ci({
    method: "stx_deployContract",
    params: _e.intersection(_e.object({
        name: _e.string(),
        clarityCode: _e.string(),
        clarityVersion: _e.coerce.number().optional()
    }), V1),
    result: $we
});
var Zwe = _e.object({
    address: _e.string(),
    publicKey: _e.string(),
    derivationPath: _e.string()
}), Xwe = _e.array(Zwe);
ci({
    method: "stx_getAddresses",
    params: _e.object({
        network: _e.string().optional()
    }).optional(),
    result: Xwe
});
ci({
    method: "stx_getNetworks",
    result: _e.object({
        active: _e.string(),
        networks: _e.array(_e.object({
            id: _e.string(),
            chainId: _e.string(),
            transactionVersion: _e.string()
        }).passthrough())
    })
});
var Ywe = _e.enum([
    "utf8",
    "structured"
]), Oj = _e.object({
    messageType: Ywe.optional().default("utf8"),
    network: _e.optional(_e.enum([
        "mainnet",
        "testnet",
        "devnet",
        "mocknet"
    ]))
}), Jwe = Oj.merge(_e.object({
    messageType: _e.literal("utf8").default("utf8"),
    message: _e.string()
})), eAe = Oj.merge(_e.object({
    messageType: _e.literal("structured"),
    domain: _e.string(),
    message: _e.string()
}));
ci({
    method: "stx_signMessage",
    params: _e.union([
        Jwe,
        eAe
    ]),
    result: _e.object({
        signature: _e.string(),
        publicKey: _e.string()
    })
});
ci({
    method: "stx_signStructuredMessage",
    params: _e.object({
        domain: _e.string(),
        message: _e.string()
    }),
    result: _e.object({
        signature: _e.string(),
        publicKey: _e.string()
    })
});
var tAe = _e.object({
    txHex: _e.string(),
    stxAddress: _e.string().optional(),
    attachment: _e.string().optional(),
    accountIndex: _e.string().optional(),
    network: _e.string().optional()
}), rAe = _e.object({
    transaction: _e.string(),
    network: _e.string().optional()
});
ci({
    method: "stx_signTransaction",
    params: _e.union([
        tAe,
        rAe
    ]),
    result: _e.object({
        transaction: _e.string(),
        txHex: _e.string()
    })
});
ci({
    method: "stx_transferSip9Nft",
    params: _e.intersection(_e.object({
        recipient: _e.string(),
        asset: _e.string(),
        assetId: _e.string()
    }).passthrough(), V1),
    result: np
});
ci({
    method: "stx_transferSip10Ft",
    params: _e.intersection(_e.object({
        recipient: _e.string(),
        asset: _e.string(),
        amount: _e.coerce.number()
    }).passthrough(), V1),
    result: np
});
ci({
    method: "stx_transferStx",
    params: _e.intersection(_e.object({
        recipient: _e.string(),
        amount: _e.coerce.number().int("Amount must be an integer describing STX"),
        memo: _e.string().optional()
    }).passthrough(), V1),
    result: np
});
var nAe = _e.object({
    // schema.org/Person
    person: _e.object({}).passthrough()
}), iAe = np;
ci({
    method: "stx_updateProfile",
    params: nAe,
    result: iAe
});
var oAe = _e.object({
    name: _e.string(),
    docsUrl: _e.union([
        _e.string(),
        _e.array(_e.string())
    ])
});
ci({
    method: "supportedMethods",
    result: _e.object({
        documentation: _e.string(),
        methods: _e.array(oAe)
    })
});
var aAe = _e.object({
    type: _e.literal("int"),
    value: _e.coerce.string()
}), sAe = _e.object({
    type: _e.literal("uint"),
    value: _e.coerce.string()
}), uAe = _e.object({
    type: _e.literal("buffer"),
    value: _e.string()
}), cAe = _e.object({
    type: _e.literal("true")
}), lAe = _e.object({
    type: _e.literal("false")
}), fAe = _e.object({
    type: _e.literal("address"),
    value: _e.string()
}), dAe = _e.object({
    type: _e.literal("contract"),
    value: _e.string().refine((e)=>e.includes("."), {
        message: "Stacks contract principals are denoted with a dot"
    })
}), hAe = _e.object({
    type: _e.literal("ascii"),
    value: _e.string()
}), pAe = _e.object({
    type: _e.literal("utf8"),
    value: _e.string()
}), gAe = _e.object({
    type: _e.literal("ok"),
    value: _e.lazy(()=>W1)
}).transform((e)=>e), yAe = _e.object({
    type: _e.literal("err"),
    value: _e.lazy(()=>W1)
}), mAe = _e.object({
    type: _e.literal("none")
}), bAe = _e.object({
    type: _e.literal("some"),
    value: _e.lazy(()=>W1)
}), wAe = _e.object({
    type: _e.literal("list"),
    value: _e.array(_e.lazy(()=>W1))
}), AAe = _e.object({
    type: _e.literal("tuple"),
    value: _e.record(_e.lazy(()=>W1))
}), W1 = _e.union([
    aAe,
    sAe,
    uAe,
    cAe,
    lAe,
    fAe,
    dAe,
    gAe,
    yAe,
    mAe,
    bAe,
    wAe,
    AAe,
    hAe,
    pAe
]);
let AB = (e)=>e, Hp = {}, Ic = {
    addEventListener () {},
    removeEventListener () {}
};
function vAe() {
    try {
        return typeof localStorage < "u";
    } catch  {
        return !1;
    }
}
vAe() && (Hp = localStorage);
let EAe = {
    addEventListener (e, t, r) {
        window.addEventListener("storage", t), window.addEventListener("pageshow", r);
    },
    removeEventListener (e, t, r) {
        window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
    }
};
typeof window < "u" && (Ic = EAe);
function Kf(e, t = {}, r = {}) {
    let n = r.encode || AB, i1 = r.decode || AB, o = oP(), a = o.setKey, s = (f, h)=>{
        typeof h > "u" ? (r.listen !== !1 && Ic.perKey && Ic.removeEventListener(e + f, l, u), delete Hp[e + f]) : (r.listen !== !1 && Ic.perKey && !(f in o.value) && Ic.addEventListener(e + f, l, u), Hp[e + f] = n(h));
    };
    o.setKey = (f, h)=>{
        s(f, h), a(f, h);
    };
    let c = o.set;
    o.set = function(f) {
        for(let h in f)s(h, f[h]);
        for(let h in o.value)h in f || s(h, void 0);
        c(f);
    };
    function l(f) {
        f.key ? f.key.startsWith(e) && (f.newValue === null ? a(f.key.slice(e.length), void 0) : a(f.key.slice(e.length), i1(f.newValue))) : c({});
    }
    function u() {
        let f = {
            ...t
        };
        for(let h in Hp)h.startsWith(e) && (f[h.slice(e.length)] = i1(Hp[h]));
        for(let h in f)o.setKey(h, f[h]);
    }
    return MZ(o, ()=>{
        if (u(), r.listen !== !1) return Ic.addEventListener(e, l, u), ()=>{
            Ic.removeEventListener(e, l, u);
            for(let f in o.value)Ic.removeEventListener(e + f, l, u);
        };
    }), o;
}
function SAe(e) {
    typeof window < "u" && typeof localStorage < "u" && setTimeout(()=>{
        const t = document.createTextNode(" ");
        document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
    }, 1500);
}
function Ij() {
    return {
        $store: oP({
            provider: void 0,
            address: "",
            paymentAddress: "",
            publicKey: "",
            paymentPublicKey: "",
            connected: !1,
            isConnecting: !1,
            isInitializing: !0,
            accounts: [],
            balance: void 0,
            hasProvider: {
                [jd]: !1,
                [Dl]: !1,
                [_u]: !1,
                [Fd]: !1,
                [zl]: !1,
                [Mc]: !1,
                [Ul]: !1,
                [Ll]: !0,
                [Ld]: !1,
                [Fl]: !1,
                [zd]: !1,
                [jl]: !1,
                [Hl]: !1
            }
        }),
        $network: O8(mn),
        $library: O8(void 0)
    };
}
function xAe(e) {
    if (e) return {
        ...e
    };
}
const pl = [
    "address",
    "paymentAddress",
    "publicKey",
    "paymentPublicKey",
    "balance"
];
function qf(e, t, r, n) {
    var i1, o, a;
    t.provider === e && (r ? r === "balance" ? n.setKey("balance", ((i1 = t.balance) == null ? void 0 : i1.toString()) ?? "") : pl.includes(r) && n.setKey(r, ((o = t[r]) == null ? void 0 : o.toString()) ?? "") : n.set({
        address: t.address,
        paymentAddress: t.paymentAddress,
        paymentPublicKey: t.paymentPublicKey,
        publicKey: t.publicKey,
        balance: ((a = t.balance) == null ? void 0 : a.toString()) ?? ""
    }));
}
const _Ae = (e)=>{
    const t = e.match(/.{1,2}/g);
    if (!t) throw new Error("Invalid hex string");
    return Uint8Array.from(t.map((r)=>Number.parseInt(r, 16)));
}, kAe = "LEATHER_CONNECTED_WALLET_STATE";
class OAe extends ra {
    constructor(){
        super(...arguments), wt(this, "observer"), wt(this, "$valueStore", Kf(kAe, {
            address: "",
            publicKey: "",
            paymentAddress: "",
            paymentPublicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        return window == null ? void 0 : window.LeatherProvider;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl)r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(t, r, n) {
        qf(jd, t, n, this.$valueStore);
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            window != null && window.LeatherProvider && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [jd]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider !== jd ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect(t) {
        var r;
        const { address: n, paymentAddress: i1 } = this.$valueStore.get();
        if (n) if (n.startsWith("tb1") && lb(this.network)) this.disconnect();
        else {
            this.restorePersistedValues(), ph(i1, this.network).then((l)=>{
                this.$store.setKey("balance", l);
            });
            return;
        }
        if (!this.library) throw new Error("Leather isn't installed");
        const o = (await this.library.request("getAddresses", {
            network: ((r = this.config) == null ? void 0 : r.network) ?? this.network
        })).result.addresses;
        if (!o) throw new Error("No accounts found");
        const a = o.map((l)=>l.address), s = o.find((l)=>l.type === sf), c = o.find((l)=>l.type === Fy);
        if (!(s != null && s.publicKey) || !(c != null && c.publicKey)) throw new Error("No accounts found");
        this.$store.setKey("accounts", a), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", c.address), this.$store.setKey("publicKey", s.publicKey), this.$store.setKey("paymentPublicKey", c.publicKey);
    }
    async getNetwork() {
        return this.network;
    }
    async switchNetwork(t) {
        if (t !== this.network) {
            if (!this.library) throw new Error("Leather isn't installed");
            const r = (await this.library.request("getAddresses", {
                network: t
            })).result.addresses;
            if (!r) throw new Error("Failed to get new network details");
            const n = r.map((a)=>a.address), i1 = r.find((a)=>a.type === sf), o = r.find((a)=>a.type === Fy);
            if (!(i1 != null && i1.publicKey) || !(o != null && o.publicKey)) throw new Error("Failed to get new network details");
            this.$store.setKey("accounts", n), this.$store.setKey("address", i1.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", i1.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$network.set(t);
        }
    }
    async sendBTC(t, r) {
        var n, i1;
        try {
            const o = await ((n = this.library) == null ? void 0 : n.request("sendTransfer", {
                recipients: [
                    {
                        address: t,
                        amount: String(r)
                    }
                ],
                network: this.network
            }));
            if (o != null && o.result.txid) return o == null ? void 0 : o.result.txid;
            throw new Error("Error sending BTC");
        } catch (o) {
            if ((i1 = o.error) != null && i1.code) {
                const a = o.error;
                throw a.code === E7.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error sending BTC: ${a.message}`);
            }
            throw new Error("Error sending BTC");
        }
    }
    async signMessage(t, r) {
        var n, i1;
        const o = r == null ? void 0 : r.toSignAddress;
        if ((r == null ? void 0 : r.protocol) === _1) throw new Error("Leather doesn't support ECDSA message signing");
        const a = o === this.$store.get().address ? sf : Fy;
        if (o !== this.$store.get().address && o !== this.$store.get().paymentAddress) throw new Error("Invalid address to sign message");
        const s = await ((n = this.library) == null ? void 0 : n.request("signMessage", {
            message: t,
            paymentType: a
        }));
        return ((i1 = s == null ? void 0 : s.result) == null ? void 0 : i1.signature) ?? "";
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        var o;
        const a = {
            hex: t,
            broadcast: !1,
            network: this.network,
            signAtIndex: i1 == null ? void 0 : i1.map((u)=>u.index)
        }, s = await ((o = this.library) == null ? void 0 : o.request("signPsbt", a));
        if (!s) throw new Error("No response from Leather");
        const c = s.result.hex, l = zr.fromHex(String(c));
        if (n && r) {
            const u = l.finalizeAllInputs(), f = await this.pushPsbt(u.toHex());
            return {
                signedPsbtHex: l.toHex(),
                signedPsbtBase64: l.toBase64(),
                txId: f
            };
        }
        if (n) {
            const u = l.finalizeAllInputs();
            return {
                signedPsbtHex: u.toHex(),
                signedPsbtBase64: u.toBase64(),
                txId: void 0
            };
        }
        return {
            signedPsbtHex: l.toHex(),
            signedPsbtBase64: l.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async getBalance() {
        const t = await ph(this.$store.get().paymentAddress, this.network);
        return this.$store.setKey("balance", t), t.toString();
    }
    async requestAccounts() {
        var t;
        const { accounts: r } = this.$store.get();
        if (r.length > 0) return r;
        const n = await ((t = this.library) == null ? void 0 : t.request("getAddresses", {
            network: this.network
        }));
        if (!n) throw new Error("No accounts found");
        const i1 = n.result.addresses.map((o)=>o.address);
        return this.$store.setKey("accounts", i1), i1;
    }
}
const IAe = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
class BAe extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer"), wt(this, "$valueStore", Kf(IAe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        var t;
        return (t = window == null ? void 0 : window.magicEden) == null ? void 0 : t.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl){
            if (r === "balance") {
                this.$store.setKey(r, BigInt(t[r]));
                continue;
            }
            this.$store.setKey(r, t[r]);
        }
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(t, r, n) {
        qf(_u, t, n, this.$valueStore);
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t, r;
            (t = window == null ? void 0 : window.magicEden) != null && t.bitcoin && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [_u]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider !== _u ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect() {
        const { address: t, paymentAddress: r } = this.$valueStore.get();
        if (t) if (t.startsWith("tb1") && lb(this.network)) this.disconnect();
        else {
            ph(r, this.network).then((i1)=>{
                this.$store.setKey("balance", i1);
            }), this.restorePersistedValues();
            return;
        }
        if (VM(this.network)) throw new Error(`${this.network} is not supported by ${_u}`);
        const n = h3(this.network || mn);
        await $ee({
            getProvider: async ()=>this.library,
            payload: {
                purposes: [
                    "ordinals",
                    "payment"
                ],
                message: "Connecting with lasereyes",
                network: {
                    type: n
                }
            },
            onFinish: (i1)=>{
                const o = xm(i1.addresses), a = _m(i1.addresses);
                if (!o || !a) throw new Error("No address found");
                o && a && (this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", a.address), this.$store.setKey("accounts", i1.addresses.map((s)=>s.address))), this.$store.setKey("publicKey", String(i1.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(i1.addresses[1].publicKey));
            },
            onCancel: ()=>{
                throw new Error(`User canceled lasereyes to ${_u} wallet`);
            },
            onError: ()=>{
                throw new Error(`Can't lasereyes to ${_u} wallet`);
            }
        });
    }
    async sendBTC(t, r) {
        let n;
        if (await pre({
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: h3(this.network)
                },
                recipients: [
                    {
                        address: t,
                        amountSats: BigInt(r)
                    }
                ],
                senderAddress: this.$store.get().paymentAddress
            },
            onFinish: (i1)=>{
                n = i1;
            },
            onCancel: ()=>{
                throw console.error("Request canceled"), new Error("User canceled the request");
            }
        }), !n || !n.txid) throw new Error("Error sending BTC");
        return n.txid;
    }
    async signMessage(t, r) {
        const n = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress;
        let i1 = "";
        return await dre({
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: Qn.Mainnet
                },
                address: n,
                message: t,
                protocol: (r == null ? void 0 : r.protocol) === _1 ? mf.ECDSA : mf.BIP322
            },
            onFinish: (o)=>{
                i1 = o;
            },
            onCancel: ()=>{
                throw console.error("Request canceled"), new Error("User canceled the request");
            }
        }), i1;
    }
    async signPsbt({ psbtBase64: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        const o = zr.fromBase64(String(t), {
            network: Vr(this.network)
        }), a = o.data.inputs;
        let s = [];
        if (i1) {
            const S = i1.reduce((k, P)=>({
                    ...k,
                    [P.address]: [
                        ...k[P.address] || [],
                        P.index
                    ]
                }), {});
            s = Object.entries(S).map(([k, P])=>({
                    address: k,
                    signingIndexes: P
                }));
        } else {
            const { address: S, paymentAddress: k } = this.$store.get(), P = {
                address: S,
                signingIndexes: []
            }, M = {
                address: k,
                signingIndexes: []
            };
            for (const N of a.keys()){
                const z = a[N];
                if (z.witnessUtxo === void 0) {
                    M.signingIndexes.push(Number(N));
                    continue;
                }
                const { script: K } = z.witnessUtxo, $ = f1(K, Vr(this.network));
                $ === k ? (M.signingIndexes.push(Number(N)), z.sighashType && (console.log("Updating sigHash for paymentsAddressData"), M.sigHash = z.sighashType)) : $ === S && (P.signingIndexes.push(Number(N)), z.sighashType && (console.log("Updating sigHash for ordinalAddressData"), P.sigHash = z.sighashType));
            }
            P.signingIndexes.length > 0 && s.push(P), M.signingIndexes.length > 0 && s.push(M);
        }
        let c, l, u, f;
        const h = h3(this.network), y = {
            getProvider: async ()=>this.library,
            payload: {
                network: {
                    type: h
                },
                message: "Sign Transaction",
                psbtBase64: o.toBase64(),
                broadcast: r,
                inputsToSign: s
            },
            onFinish: async (S)=>{
                S.psbtBase64 && (f = zr.fromBase64(String(S.psbtBase64), {
                    network: Vr(this.network)
                }), l = f.toHex(), u = f.toBase64());
            },
            onCancel: ()=>{
                throw console.log("Canceled"), new Error("User canceled the request");
            },
            onError: (S)=>{
                throw console.log("error", S), S;
            }
        };
        if (await gre(y), !f) throw new Error("signature failed");
        return n || r ? (f.finalizeAllInputs(), {
            signedPsbtHex: f.toHex(),
            signedPsbtBase64: u,
            txId: c
        }) : {
            signedPsbtHex: l,
            signedPsbtBase64: u,
            txId: c
        };
    }
}
const TAe = "OKX_CONNECTED_WALLET_STATE";
class PAe extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer"), wt(this, "$valueStore", Kf(TAe, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        var t, r;
        let n;
        return this.network === Ki || this.network === _o || this.network === Xo || this.network === ko ? n = (t = window == null ? void 0 : window.okxwallet) == null ? void 0 : t.bitcoinTestnet : (this.network === mn || this.network === Ku) && (n = (r = window == null ? void 0 : window.okxwallet) == null ? void 0 : r.bitcoin), n;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl)r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(t, r, n) {
        qf(Fd, t, n, this.$valueStore);
    }
    initialize() {
        var t;
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Fd]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), (t = this.observer) == null || t.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Fd ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect(t) {
        const { address: r, paymentAddress: n } = this.$valueStore.get();
        if (r) if (r.startsWith("tb1") && lb(this.network)) this.disconnect();
        else {
            this.restorePersistedValues(), ph(n, this.network).then((i1)=>{
                this.$store.setKey("balance", i1);
            });
            return;
        }
        try {
            const i1 = await this.library.connect();
            if (!i1) throw new Error("No accounts found");
            this.$store.setKey("address", i1.address), this.$store.setKey("paymentAddress", i1.address), this.$store.setKey("publicKey", i1.publicKey), this.$store.setKey("paymentPublicKey", i1.publicKey), this.$store.setKey("accounts", [
                i1.address
            ]);
        } catch (i1) {
            throw i1;
        }
    }
    async requestAccounts() {
        const t = this.library, r = this.network;
        return r === Ki || r === _o || r === ko ? await t.connect() : await t.requestAccounts();
    }
    async getNetwork() {
        const { address: t } = this.$store.get(), r = this.network;
        if (t.slice(0, 1) === "t") return r === Ki ? Ki : r === _o ? _o : r === Xo ? Xo : r === ko ? ko : Ki;
        const n = await this.library.getNetwork();
        return wre(n);
    }
    async getPublicKey() {
        const t = this.library;
        return await (t == null ? void 0 : t.getPublicKey());
    }
    async getInscriptions(t, r) {
        const n = t || 0, i1 = r || 10;
        return (await this.library.getInscriptions(n, i1)).list.map((o)=>qd(o, void 0, this.network));
    }
    async sendBTC(t, r) {
        const n = await this.library.sendBitcoin(t, r);
        if (!n) throw new Error("Transaction failed");
        return n;
    }
    async signMessage(t, r) {
        const n = this.library, i1 = (r == null ? void 0 : r.protocol) === _1 ? k1 : r == null ? void 0 : r.protocol;
        return await (n == null ? void 0 : n.signMessage(t, i1));
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        const o = await this.library.signPsbt(t, Af({
            autoFinalized: n,
            toSignInputs: i1
        })), a = zr.fromHex(o);
        if (n && r) {
            const s = await this.pushPsbt(o);
            return {
                signedPsbtHex: a.toHex(),
                signedPsbtBase64: a.toBase64(),
                txId: s
            };
        }
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: void 0
        };
    }
}
class CAe extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer");
    }
    get library() {
        return window == null ? void 0 : window.opnet;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [zl]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            if (t.provider !== zl) {
                this.removeListeners();
                return;
            }
            this.library.getAccounts().then((r)=>{
                this.handleAccountsChanged(r);
            }), this.addListeners();
        });
    }
    addListeners() {
        var t, r;
        (t = this.library) == null || t.on("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var t, r;
        !this.library || !this.library.removeListener || ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(t) {
        if (!t.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(zl) : this.parent.disconnect());
    }
    handleNetworkChanged(t) {
        const r = Am(t);
        this.network !== r && this.switchNetwork(r), this.parent.connect(zl);
    }
    async connect(t) {
        if (!this.library) throw new Error("OP_NET isn't installed");
        const r = await this.library.requestAccounts();
        if (!r) throw new Error("No accounts found");
        const n = await this.library.getPublicKey();
        if (!n) throw new Error("No public key found");
        this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), await this.getNetwork().then((i1)=>{
            var o;
            ((o = this.config) == null ? void 0 : o.network) !== i1 && this.switchNetwork(i1);
        });
    }
    async getNetwork() {
        var t;
        const r = await ((t = this.library) == null ? void 0 : t.getChain());
        return r ? Am(r.enum) : this.network;
    }
    async sendBTC(t, r) {
        var n;
        const i1 = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
        if (!i1) throw new Error("Transaction failed");
        return i1;
    }
    async signMessage(t, r) {
        var n;
        const i1 = (r == null ? void 0 : r.protocol) === mb ? k1 : r == null ? void 0 : r.protocol;
        return await ((n = this.library) == null ? void 0 : n.signMessage(t, i1));
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        var o;
        const a = await ((o = this.library) == null ? void 0 : o.signPsbt(t, Af({
            autoFinalized: n,
            toSignInputs: i1
        }))), s = zr.fromHex(a);
        if (n && r) {
            const c = await this.pushPsbt(a);
            return {
                signedPsbtHex: s.toHex(),
                signedPsbtBase64: s.toBase64(),
                txId: c
            };
        }
        return {
            signedPsbtHex: s.toHex(),
            signedPsbtBase64: s.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        var t;
        return await ((t = this.library) == null ? void 0 : t.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(t, r) {
        return await this.library.getInscriptions(t, r);
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async switchNetwork(t) {
        var r;
        const n = mM(t);
        await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
    }
}
var s0 = {}, Bj = {}, ps = {}, Tj = {};
Object.defineProperty(Tj, "__esModule", {
    value: !0
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(a, s, c, l) {
        l === void 0 && (l = c);
        var u = Object.getOwnPropertyDescriptor(s, c);
        (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
            enumerable: !0,
            get: function() {
                return s[c];
            }
        }), Object.defineProperty(a, l, u);
    } : function(a, s, c, l) {
        l === void 0 && (l = c), a[l] = s[c];
    }), r = Qe && Qe.__exportStar || function(a, s) {
        for(var c in a)c !== "default" && !Object.prototype.hasOwnProperty.call(s, c) && t(s, a, c);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
    async function n(a) {
        var s, c;
        if (a) {
            const u = await a();
            if (u) return u;
        }
        const l = window.OrangeBitcoinProvider || ((s = window.OrangecryptoProviders) == null ? void 0 : s.BitcoinProvider) || ((c = window.OrangeWalletProviders) == null ? void 0 : c.OrangeBitcoinProvider);
        if (!l) throw new Error("No Orange Bitcoin wallet installed");
        return l;
    }
    e.getProviderOrThrow = n;
    function i1() {
        return window.btc_providers || (window.btc_providers = []), window.btc_providers;
    }
    e.getProviders = i1;
    function o(a) {
        var s;
        if (Array.isArray(window.btc_providers)) {
            const c = window.btc_providers.find((l)=>l.id === a);
            return (s = c == null ? void 0 : c.id) == null ? void 0 : s.split(".").reduce((l, u)=>l == null ? void 0 : l[u], window);
        } else {
            console.log("window.btc_providers is not defined or not an array");
            return;
        }
    }
    e.getProviderById = o, r(Tj, e);
})(ps);
var Pj = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.AddressType = e.AddressPurpose = void 0, function(t) {
        t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
    }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
        t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
    }(e.AddressType || (e.AddressType = {}));
})(Pj);
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(a, s, c, l) {
        l === void 0 && (l = c);
        var u = Object.getOwnPropertyDescriptor(s, c);
        (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
            enumerable: !0,
            get: function() {
                return s[c];
            }
        }), Object.defineProperty(a, l, u);
    } : function(a, s, c, l) {
        l === void 0 && (l = c), a[l] = s[c];
    }), r = Qe && Qe.__exportStar || function(a, s) {
        for(var c in a)c !== "default" && !Object.prototype.hasOwnProperty.call(s, c) && t(s, a, c);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getAddress = void 0;
    const n = ta, i1 = ps, o = async (a)=>{
        var s, c;
        const l = await (0, i1.getProviderOrThrow)(a.getProvider), { purposes: u } = a.payload;
        if (!u) throw new Error("Address purposes are required");
        try {
            const f = (0, n.createUnsecuredToken)(a.payload), h = await l.connect(f);
            (s = a.onFinish) == null || s.call(a, h);
        } catch (f) {
            console.error("[Connect] Error during address request", f), (c = a.onCancel) == null || c.call(a);
        }
    };
    e.getAddress = o, r(Pj, e);
})(Bj);
var Cj = {}, Mj = {}, Nj = {};
Object.defineProperty(Nj, "__esModule", {
    value: !0
});
var Rj = {};
Object.defineProperty(Rj, "__esModule", {
    value: !0
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Nj, e), r(Rj, e);
})(Mj);
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(a, s, c, l) {
        l === void 0 && (l = c);
        var u = Object.getOwnPropertyDescriptor(s, c);
        (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
            enumerable: !0,
            get: function() {
                return s[c];
            }
        }), Object.defineProperty(a, l, u);
    } : function(a, s, c, l) {
        l === void 0 && (l = c), a[l] = s[c];
    }), r = Qe && Qe.__exportStar || function(a, s) {
        for(var c in a)c !== "default" && !Object.prototype.hasOwnProperty.call(s, c) && t(s, a, c);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.request = void 0;
    const n = ps, i1 = async (a, s, c)=>{
        var l;
        let u = ((l = window.OrangecryptoProviders) == null ? void 0 : l.BitcoinProvider) || window.OrangeBitcoinProvider;
        if (c && (u = await (0, n.getProviderById)(c)), !u) throw new Error("no wallet provider was found");
        if (!a) throw new Error("A wallet method is required");
        const f = await u.request(a, s);
        return o(f) ? {
            status: "success",
            result: f.result
        } : {
            status: "error",
            error: f.error
        };
    };
    e.request = i1;
    const o = (a)=>Object.hasOwn(a, "result") && !!a.result;
    r(Mj, e);
})(Cj);
var Uj = {}, Dj = {};
Object.defineProperty(Dj, "__esModule", {
    value: !0
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(s, c, l, u) {
        u === void 0 && (u = l);
        var f = Object.getOwnPropertyDescriptor(c, l);
        (!f || ("get" in f ? !c.__esModule : f.writable || f.configurable)) && (f = {
            enumerable: !0,
            get: function() {
                return c[l];
            }
        }), Object.defineProperty(s, u, f);
    } : function(s, c, l, u) {
        u === void 0 && (u = l), s[u] = c[l];
    }), r = Qe && Qe.__exportStar || function(s, c) {
        for(var l in s)l !== "default" && !Object.prototype.hasOwnProperty.call(c, l) && t(c, s, l);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getCapabilities = void 0;
    const n = ta, i1 = ps, o = (s, c)=>{
        const l = (f)=>!(!s[f] || c && !c.has(f)), u = {
            request: l("request"),
            connect: l("connect"),
            signMessage: l("signMessage"),
            signTransaction: l("signTransaction"),
            sendBtcTransaction: l("sendBtcTransaction"),
            signMultipleTransactions: l("signMultipleTransactions")
        };
        return Object.entries(u).reduce((f, [h, y])=>y ? [
                ...f,
                h
            ] : f, []);
    }, a = async (s)=>{
        var c, l, u;
        const f = await (0, i1.getProviderOrThrow)(s.getProvider), h = (0, n.createUnsecuredToken)(s.payload);
        if (f.getCapabilities) try {
            const y = await f.getCapabilities(h);
            (c = s.onFinish) == null || c.call(s, o(f, new Set(y)));
        } catch (y) {
            console.error("[Connect] Error during capabilities request", y);
        }
        try {
            const y = o(f);
            (l = s.onFinish) == null || l.call(s, y);
        } catch (y) {
            console.error("[Connect] Error during capabilities request", y), (u = s.onCancel) == null || u.call(s);
        }
    };
    e.getCapabilities = a, r(Dj, e);
})(Uj);
var jj = {}, Vb = {}, G1 = {};
Object.defineProperty(G1, "__esModule", {
    value: !0
});
G1.validateInscriptionPayload = void 0;
const MAe = 4e5, NAe = 6e4, RAe = (e)=>{
    const { contentType: t, content: r, payloadType: n, network: i1, appFeeAddress: o, appFee: a } = e;
    if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t)) throw new Error("Invalid content type detected");
    if (!r || r.length === 0) throw new Error("Empty content not allowed");
    if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT") throw new Error("Empty invalid payloadType specified");
    if (r.length > (i1.type === "Mainnet" ? MAe : NAe)) throw new Error("Content too large");
    if (((o == null ? void 0 : o.length) ?? 0) > 0 && (a ?? 0) <= 0) throw new Error("Invalid combination of app fee address and fee provided");
};
G1.validateInscriptionPayload = RAe;
Object.defineProperty(Vb, "__esModule", {
    value: !0
});
Vb.createInscription = void 0;
const UAe = ta, DAe = ps, jAe = G1, FAe = async (e)=>{
    var t, r;
    const { getProvider: n } = e, i1 = await (0, DAe.getProviderOrThrow)(n);
    (0, jAe.validateInscriptionPayload)(e.payload);
    try {
        const o = (0, UAe.createUnsecuredToken)(e.payload);
        if (i1.createInscription) {
            const a = await i1.createInscription(o);
            (t = e.onFinish) == null || t.call(e, a);
        }
    } catch (o) {
        console.error("[Connect] Error during create inscription", o), (r = e.onCancel) == null || r.call(e);
    }
};
Vb.createInscription = FAe;
var Wb = {};
Object.defineProperty(Wb, "__esModule", {
    value: !0
});
Wb.createRepeatInscriptions = void 0;
const zAe = ps, LAe = ta, HAe = G1, KAe = async (e)=>{
    var t, r;
    const { getProvider: n } = e, i1 = await (0, zAe.getProviderOrThrow)(n);
    (0, HAe.validateInscriptionPayload)(e.payload);
    try {
        const o = (0, LAe.createUnsecuredToken)(e.payload);
        if (i1.createRepeatInscriptions) {
            const a = await i1.createRepeatInscriptions(o);
            (t = e.onFinish) == null || t.call(e, a);
        }
    } catch (o) {
        console.error("[Connect] Error during create repeat inscriptions", o), (r = e.onCancel) == null || r.call(e);
    }
};
Wb.createRepeatInscriptions = KAe;
var Fj = {};
Object.defineProperty(Fj, "__esModule", {
    value: !0
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Vb, e), r(Wb, e), r(Fj, e);
})(jj);
var zj = {}, Lj = {};
Object.defineProperty(Lj, "__esModule", {
    value: !0
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(a, s, c, l) {
        l === void 0 && (l = c);
        var u = Object.getOwnPropertyDescriptor(s, c);
        (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
            enumerable: !0,
            get: function() {
                return s[c];
            }
        }), Object.defineProperty(a, l, u);
    } : function(a, s, c, l) {
        l === void 0 && (l = c), a[l] = s[c];
    }), r = Qe && Qe.__exportStar || function(a, s) {
        for(var c in a)c !== "default" && !Object.prototype.hasOwnProperty.call(s, c) && t(s, a, c);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.signMessage = void 0;
    const n = ta, i1 = ps, o = async (a)=>{
        var s, c;
        const l = await (0, i1.getProviderOrThrow)(a.getProvider), { address: u, message: f } = a.payload;
        if (!u) throw new Error("An address is required to sign a message");
        if (!f) throw new Error("A message to be signed is required");
        try {
            const h = (0, n.createUnsecuredToken)(a.payload), y = await l.signMessage(h);
            (s = a.onFinish) == null || s.call(a, y);
        } catch (h) {
            console.error("[Connect] Error during sign message request", h), (c = a.onCancel) == null || c.call(a);
        }
    };
    e.signMessage = o, r(Lj, e);
})(zj);
var Hj = {}, Gb = {};
Object.defineProperty(Gb, "__esModule", {
    value: !0
});
Gb.sendBtcTransaction = void 0;
const qAe = ta, VAe = ps, WAe = (e)=>e.map((t)=>{
        const { address: r, amountSats: n } = t;
        return {
            address: r,
            amountSats: n.toString()
        };
    }), GAe = async (e)=>{
    var t, r;
    const n = await (0, VAe.getProviderOrThrow)(e.getProvider), { recipients: i1, senderAddress: o, network: a, message: s } = e.payload;
    if (!i1 || i1.length === 0) throw new Error("At least one recipient is required");
    if (i1.some((c)=>typeof c.address != "string" || typeof c.amountSats != "bigint")) throw new Error("Incorrect recipient format");
    if (!o) throw new Error("The sender address is required");
    try {
        const c = WAe(i1), l = {
            network: a,
            senderAddress: o,
            message: s,
            recipients: c
        }, u = (0, qAe.createUnsecuredToken)(l), f = await n.sendBtcTransaction(u);
        (t = e.onFinish) == null || t.call(e, f);
    } catch (c) {
        console.error("[Connect] Error during send BTC transaction request", c), (r = e.onCancel) == null || r.call(e);
    }
};
Gb.sendBtcTransaction = GAe;
var Qb = {};
Object.defineProperty(Qb, "__esModule", {
    value: !0
});
Qb.signTransaction = void 0;
const QAe = ta, $Ae = ps, ZAe = async (e)=>{
    var t, r;
    const n = await (0, $Ae.getProviderOrThrow)(e.getProvider), { psbtBase64: i1, inputsToSign: o } = e.payload;
    if (!i1) throw new Error("A value for psbtBase64 representing the tx hash is required");
    if (!o) throw new Error("An array specifying the inputs to be signed by the wallet is required");
    try {
        const a = (0, QAe.createUnsecuredToken)(e.payload), s = await n.signTransaction(a);
        (t = e.onFinish) == null || t.call(e, s);
    } catch (a) {
        console.error("[Connect] Error during sign transaction request", a), (r = e.onCancel) == null || r.call(e);
    }
};
Qb.signTransaction = ZAe;
var $b = {};
Object.defineProperty($b, "__esModule", {
    value: !0
});
$b.signMultipleTransactions = void 0;
const XAe = ta, YAe = ps, JAe = async (e)=>{
    var t, r;
    const n = await (0, YAe.getProviderOrThrow)(e.getProvider), { psbts: i1 } = e.payload;
    if (!i1 || !i1.length) throw new Error("psbts array is required");
    if (i1.length > 100) throw new Error("psbts array must contain less than 100 psbts");
    try {
        const o = (0, XAe.createUnsecuredToken)(e.payload), a = await n.signMultipleTransactions(o);
        (t = e.onFinish) == null || t.call(e, a);
    } catch (o) {
        console.error("[Connect] Error during sign Multiple transactions request", o), (r = e.onCancel) == null || r.call(e);
    }
};
$b.signMultipleTransactions = JAe;
var Kj = {};
Object.defineProperty(Kj, "__esModule", {
    value: !0
});
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Gb, e), r(Qb, e), r($b, e), r(Kj, e);
})(Hj);
var qj = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
        t.Mainnet = "Mainnet", t.Testnet = "Testnet";
    }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
        t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
    }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(qj);
(function(e) {
    var t = Qe && Qe.__createBinding || (Object.create ? function(n, i1, o, a) {
        a === void 0 && (a = o);
        var s = Object.getOwnPropertyDescriptor(i1, o);
        (!s || ("get" in s ? !i1.__esModule : s.writable || s.configurable)) && (s = {
            enumerable: !0,
            get: function() {
                return i1[o];
            }
        }), Object.defineProperty(n, a, s);
    } : function(n, i1, o, a) {
        a === void 0 && (a = o), n[a] = i1[o];
    }), r = Qe && Qe.__exportStar || function(n, i1) {
        for(var o in n)o !== "default" && !Object.prototype.hasOwnProperty.call(i1, o) && t(i1, n, o);
    };
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r(Bj, e), r(Cj, e), r(Uj, e), r(jj, e), r(zj, e), r(ps, e), r(Hj, e), r(qj, e);
})(s0);
const w2 = /* @__PURE__ */ gT(s0), eve = w2 == null ? void 0 : w2.signMessage, tve = w2 == null ? void 0 : w2.sendBtcTransaction, rve = "ORANGE_CONNECTED_WALLET_STATE";
class nve extends ra {
    constructor(){
        super(...arguments), wt(this, "observer"), wt(this, "$valueStore", Kf(rve, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        var t;
        return (t = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : t.OrangeBitcoinProvider;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl)r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(t, r, n) {
        qf(Mc, t, n, this.$valueStore);
    }
    initialize() {
        var t;
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var r;
            window.OrangeBitcoinProvider && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Mc]: !0
            }), (r = this.observer) == null || r.disconnect());
        }), (t = this.observer) == null || t.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (r)=>{
            r.provider !== Mc ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect(t) {
        const { address: r, paymentAddress: n } = this.$valueStore.get();
        if (r) {
            this.restorePersistedValues(), ph(n, this.network).then((a)=>{
                this.$store.setKey("balance", a);
            });
            return;
        }
        const i1 = p3(this.network || mn), o = {
            payload: {
                purposes: [
                    "ordinals",
                    "payment"
                ],
                message: "Address for receiving Ordinals and payments",
                network: {
                    type: i1
                }
            },
            onFinish: (a)=>{
                const s = xm(a.addresses), c = _m(a.addresses);
                if (!s || !(c != null && c.address)) throw new Error("Could not find addresses");
                s && c && (this.$store.setKey("provider", Mc), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", c.address)), this.$store.setKey("publicKey", String(s.publicKey)), this.$store.setKey("paymentPublicKey", String(c.publicKey)), this.$store.setKey("accounts", a.addresses.map((l)=>l.address));
            },
            onCancel: ()=>{
                throw new Error(`User canceled lasereyes to ${Mc} wallet`);
            }
        };
        await s0.getAddress(o), this.$store.setKey("connected", !0);
    }
    async getNetwork() {
        const { address: t } = this.$store.get();
        return t.slice(0, 1) === "t" && [
            Ki,
            _o,
            Xo,
            ko
        ].includes(this.network) ? this.network : mn;
    }
    async sendBTC(t, r) {
        let n = "";
        const i1 = {
            payload: {
                network: {
                    type: p3(this.network)
                },
                recipients: [
                    {
                        address: t,
                        amountSats: BigInt(r)
                    }
                ],
                senderAddress: this.$store.get().paymentAddress
            },
            onFinish: (o)=>{
                n = o;
            },
            onCancel: ()=>{
                throw new Error("User canceled the request");
            }
        };
        return await tve(i1), n;
    }
    async signMessage(t, r) {
        let n = "";
        const i1 = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress, o = {
            payload: {
                network: {
                    type: p3(this.network)
                },
                address: i1,
                message: t
            },
            onFinish: (a)=>{
                n = a;
            },
            onCancel: ()=>{
                throw new Error("User canceled the request");
            }
        };
        return await eve(o), n;
    }
    async signPsbt({ psbtBase64: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        try {
            const o = zr.fromBase64(String(t), {
                network: Vr(this.network)
            }).data.inputs;
            let a = {};
            if (i1) a = i1.reduce((h, y)=>(h[y.address] = [
                    ...h[y.address] || [],
                    y.index
                ], h), {});
            else {
                const { address: h, paymentAddress: y } = this.$store.get(), S = {
                    [h]: []
                }, k = {
                    [y]: []
                };
                for (const P of o.keys()){
                    const M = o[P];
                    if (M.witnessUtxo === void 0) {
                        k[y].push(Number(P));
                        continue;
                    }
                    const { script: N } = M.witnessUtxo, z = f1(N, Vr(this.network));
                    z === y ? k[y].push(Number(P)) : z === h && S[h].push(Number(P));
                }
                S[h].length > 0 && (a = {
                    ...a,
                    ...S
                }), k[y].length > 0 && (a = {
                    ...a,
                    ...k
                });
            }
            let s, c, l, u;
            const f = await s0.request("signPsbt", {
                psbt: t,
                broadcast: !!r,
                signInputs: a
            });
            if (f.status === "success") u = zr.fromBase64(f.result.psbt, {
                network: Vr(this.network)
            }), s = f.result.txid;
            else throw f.error.code === s0.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
            if (!u) throw new Error("Error signing psbt");
            return n && !s ? (u.finalizeAllInputs(), c = u.toHex(), l = u.toBase64()) : (c = u.toHex(), l = u.toBase64()), {
                signedPsbtHex: c,
                signedPsbtBase64: l,
                txId: s
            };
        } catch (o) {
            throw console.error(o), o;
        }
    }
}
const ive = "OYL_CONNECTED_WALLET_STATE";
class ove extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer"), wt(this, "$valueStore", Kf(ive, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        return window.oyl;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl)r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(t, r, n) {
        qf(Ul, t, n, this.$valueStore);
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            window != null && window.oyl && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ul]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider !== Ul ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect(t) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { nativeSegwit: r, taproot: n, nestedSegwit: i1, legacy: o } = await this.library.getAddresses();
        if (!r || !n) throw new Error("No accounts found");
        this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("accounts", [
            n.address,
            r.address,
            i1.address,
            o.address
        ]);
    }
    async getNetwork() {
        var t;
        return (t = this.library) == null ? void 0 : t.getNetwork();
    }
    async sendBTC(t, r) {
        const { psbtHex: n, psbtBase64: i1 } = await sb(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), o = await this.signPsbt({
            psbtBase64: i1,
            psbtHex: n,
            tx: n,
            broadcast: !0,
            finalize: !0
        });
        if (!o || !o.txId) throw new Error("Error sending BTC");
        return o.txId;
    }
    async signMessage(t, r) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const n = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress;
        return (await this.library.signMessage({
            address: n,
            message: t,
            protocol: r == null ? void 0 : r.protocol
        })).signature;
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n }) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { psbt: i1, txid: o } = await this.library.signPsbt({
            psbt: t,
            finalize: n,
            broadcast: r
        }), a = zr.fromHex(i1);
        return {
            signedPsbtHex: a.toHex(),
            signedPsbtBase64: a.toBase64(),
            txId: o
        };
    }
    async signPsbts(t) {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { psbts: r, finalize: n, broadcast: i1 } = t, o = r.map((s)=>({
                psbt: s,
                finalize: n,
                broadcast: i1
            })), a = await this.library.signPsbts(o);
        return {
            signedPsbts: a.map((s, c)=>{
                const l = zr.fromHex(s.psbt);
                return {
                    signedPsbtHex: l.toHex(),
                    signedPsbtBase64: l.toBase64(),
                    txId: a[c].txid
                };
            }) || []
        };
    }
    async pushPsbt(t) {
        if (!this.library) throw new Error("Oyl isn't installed");
        return (await this.library.pushPsbt({
            psbt: t
        })).txid;
    }
    async getPublicKey() {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { nativeSegwit: t, taproot: r } = await this.library.getAddresses();
        if (!t || !r) throw new Error("No accounts found");
        return this.$store.setKey("publicKey", r.publicKey), this.$store.setKey("paymentPublicKey", t.publicKey), r.publicKey;
    }
    async getBalance() {
        if (!this.library) throw new Error("Oyl isn't installed");
        const { total: t } = await this.library.getBalance();
        return this.$store.setKey("balance", BigInt(t)), t;
    }
    async requestAccounts() {
        return [
            this.$store.get().address,
            this.$store.get().paymentAddress
        ];
    }
    async switchNetwork(t) {
        if (!this.library) throw new Error("Oyl isn't installed");
        await this.library.switchNetwork(t), this.$network.set(t), await this.parent.connect(Ul);
    }
}
class ave extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer");
    }
    get library() {
        var t;
        return (t = window == null ? void 0 : window.phantom) == null ? void 0 : t.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Fl]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider === Fl && this.library.requestAccounts().then((r)=>{
                this.handleAccountsChanged(r);
            });
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    handleAccountsChanged(t) {
        if (!t.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Fl) : this.parent.disconnect());
    }
    async connect(t) {
        if (!this.library) throw new Error("Phantom isn't installed");
        if (VM(this.network)) throw new Error(`${this.network} is not supported by ${Fl}`);
        const r = await this.library.requestAccounts();
        if (!r) throw new Error("No accounts found");
        this.$store.setKey("accounts", r);
        const n = r.find((o)=>o.purpose === "ordinals"), i1 = r.find((o)=>o.purpose === "payment");
        this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", i1.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", i1.publicKey), this.$store.setKey("accounts", r.map((o)=>o.address));
    }
    async getNetwork() {
        return this.$store.get().address.slice(0, 1) === "t" ? Ki : mn;
    }
    async sendBTC(t, r) {
        const { psbtHex: n, psbtBase64: i1 } = await sb(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), o = await this.signPsbt({
            psbtBase64: i1,
            psbtHex: n,
            tx: n,
            broadcast: !0,
            finalize: !0
        });
        if (!o || !o.txId) throw new Error("Error sending BTC");
        return o.txId;
    }
    async signMessage(t, r) {
        var n;
        if ((r == null ? void 0 : r.protocol) === _1) throw new Error("ECDSA signing is not supported by Phantom");
        const i1 = new TextEncoder().encode(t), o = new Uint8Array(i1), a = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress, s = await ((n = this.library) == null ? void 0 : n.signMessage(a, o)), c = String.fromCharCode(...s.signature);
        return btoa(c);
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        const o = zr.fromHex(String(t), {
            network: Vr(this.network)
        }).data.inputs;
        let a = [];
        if (i1) {
            const l = i1.reduce((u, f)=>({
                    ...u,
                    [f.address]: [
                        ...u[f.address] || [],
                        f.index
                    ]
                }), {});
            a = Object.entries(l).map(([u, f])=>({
                    address: u,
                    signingIndexes: f
                }));
        } else {
            const { address: l, paymentAddress: u } = this.$store.get(), f = {
                address: l,
                signingIndexes: []
            }, h = {
                address: u,
                signingIndexes: []
            };
            for (let y of o.keys()){
                const S = o[y];
                if (S.witnessUtxo === void 0) {
                    h.signingIndexes.push(Number(y));
                    continue;
                }
                const { script: k } = S.witnessUtxo, P = f1(k, Vr(this.network));
                P === u ? h.signingIndexes.push(Number(y)) : P === l && f.signingIndexes.push(Number(y));
            }
            f.signingIndexes.length > 0 && a.push(f), h.signingIndexes.length > 0 && a.push(h);
        }
        const s = await this.library.signPSBT(_Ae(t), {
            inputsToSign: a
        }), c = zr.fromBuffer(s);
        if (n && a.forEach((l)=>{
            l.signingIndexes.forEach((u)=>{
                c.finalizeInput(u);
            });
        }), r) {
            const l = await this.pushPsbt(c.toHex());
            return {
                signedPsbtHex: c.toHex(),
                signedPsbtBase64: c.toBase64(),
                txId: l
            };
        }
        return {
            signedPsbtHex: c.toHex(),
            signedPsbtBase64: c.toBase64(),
            txId: void 0
        };
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
}
const Rp = {}, h8 = console.log;
function Up(e) {
    if (Rp[e]) return console.warn(`Multiple requests for "${e}" detected`), Rp[e];
    const t = new Promise((r, n)=>{
        const i1 = setTimeout(()=>{
            console.log = h8, Rp[e] = void 0, n(new Error(`Timeout waiting for "${e}" value`));
        }, 6e4);
        console.log = (...o)=>{
            o.length > 0 && typeof o[0] == "string" && (clearTimeout(i1), console.log = h8, Rp[e] = void 0, r(o[0]));
        }, h8(`Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`);
    });
    return Rp[e] = t, t;
}
class sve {
    async requestAccounts(t) {
        const r = await Up(`address_${t || "mainnet"}`);
        if (!r) throw new Error("No address provided");
        const n = await Up(`paymentAddress_${t || "mainnet"}`);
        if (!n) throw new Error("No payment address provided");
        return [
            r,
            n
        ];
    }
    async signMessage(t) {
        return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Up("message to sign");
    }
    async signPsbt(t) {
        return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Up("signed psbt hex");
    }
    async getPublicKey(t) {
        const r = await Up(`publicKey_${t || "mainnet"}`);
        if (!r) throw new Error("No public key provided");
        return r;
    }
    // TODO: Implement network switching between mainnet and testnet
    async getNetwork() {
        return "mainnet";
    }
    async switchNetwork(t) {
        const [r, n] = await this.requestAccounts(), i1 = await this.getPublicKey();
        return {
            address: r,
            paymentAddress: n,
            publicKey: i1
        };
    }
}
const uve = "SPARROW_CONNECTED_WALLET_STATE";
class cve extends ra {
    constructor(){
        super(...arguments), wt(this, "observer"), wt(this, "$valueStore", Kf(uve, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        return window == null ? void 0 : window.SparrowWalletProvider;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            this.library || (window.SparrowWalletProvider = new sve()), this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ll]: !0
            }), (t = this.observer) == null || t.disconnect();
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider !== Ll ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                paymentAddress: "",
                paymentPublicKey: "",
                publicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    watchStateChange(t, r, n) {
        qf(Ll, t, n, this.$valueStore);
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl)r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect(t) {
        try {
            const { address: r, paymentAddress: n } = this.$valueStore.get();
            if (r && n) if (r.startsWith("tb1") && lb(this.network)) this.disconnect();
            else {
                this.restorePersistedValues();
                return;
            }
            if (!this.library) throw new Error("Sparrow wallet isn't supported");
            const i1 = await this.library.requestAccounts();
            if (!i1) throw new Error("No accounts found");
            await this.getNetwork().then((a)=>{
                this.network !== a && this.switchNetwork(this.network);
            });
            const o = await this.library.getPublicKey();
            if (!o) throw new Error("No public key found");
            this.$store.setKey("accounts", i1), this.$store.setKey("address", i1[0]), this.$store.setKey("paymentAddress", i1[1]), this.$store.setKey("publicKey", o), this.$store.setKey("paymentPublicKey", o);
        } catch (r) {
            throw console.error("Error during sparrow connect:", r), r;
        }
    }
    async getNetwork() {
        return this.network;
    }
    async switchNetwork(t) {
        if (!this.library) throw new Error("Sparrow wallet isn't supported");
        try {
            const r = await this.library.switchNetwork(t);
            if (!r) throw new Error("No result returned from switchNetwork");
            const { address: n, paymentAddress: i1, publicKey: o } = r;
            this.$store.setKey("address", n), this.$store.setKey("paymentAddress", i1), this.$store.setKey("publicKey", o), this.$store.setKey("paymentPublicKey", o), this.$network.set(t);
        } catch (r) {
            throw console.error("Error during sparrow switchNetwork:", r), r;
        }
    }
    async sendBTC(t, r) {
        const { psbtBase64: n } = await sb(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), i1 = await this.library.signPsbt(n);
        if (!i1) throw new Error("No signed PSBT provided");
        const o = await this.pushPsbt(i1);
        if (!o) throw new Error("send failed, no txid returned");
        return o;
    }
    async signMessage(t) {
        return await this.library.signMessage(t);
    }
    async signPsbt({ psbtBase64: t, broadcast: r, finalize: n }) {
        const i1 = zr.fromBase64(t), o = await this.library.signPsbt(t);
        if (n && r) {
            const a = await this.pushPsbt(o);
            return {
                signedPsbtHex: o,
                signedPsbtBase64: i1.toBase64(),
                txId: a
            };
        }
        return {
            signedPsbtHex: o,
            signedPsbtBase64: i1.toBase64(),
            txId: void 0
        };
    }
    async getPublicKey() {
        const t = await this.library.getPublicKey();
        return this.$store.setKey("publicKey", t), t;
    }
    async getBalance() {
        const t = await ph(this.$store.get().paymentAddress, this.network);
        return this.$store.setKey("balance", t), t.toString();
    }
    async requestAccounts() {
        return await this.connect(Ll), this.$store.get().accounts;
    }
}
const lve = "TOKEO_CONNECTED_WALLET_STATE";
class fve extends ra {
    constructor(){
        super(...arguments), wt(this, "observer"), wt(this, "$valueStore", Kf(lve, {
            address: "",
            paymentAddress: "",
            paymentPublicKey: "",
            publicKey: "",
            balance: ""
        })), wt(this, "removeSubscriber");
    }
    get library() {
        var t;
        return (t = window.tokeo) == null ? void 0 : t.bitcoin;
    }
    get network() {
        return this.$network.get();
    }
    restorePersistedValues() {
        const t = this.$valueStore.get();
        for (const r of pl)r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
        this.$store.setKey("accounts", [
            t.address,
            t.paymentAddress
        ].filter(Boolean));
    }
    watchStateChange(t, r, n) {
        qf(Ld, t, n, this.$valueStore);
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Ld]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider !== Ld ? this.removeSubscriber && (this.$valueStore.set({
                address: "",
                publicKey: "",
                paymentAddress: "",
                paymentPublicKey: "",
                balance: ""
            }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
        });
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect();
    }
    async connect(t) {
        try {
            if (!this.library) if (this.isMobile()) {
                const o = `tokeo://open-url?url=${encodeURIComponent(window.location.href)}`, a = window.open(o);
                if (!a) throw new Error("Tokeo wallet not found");
                return a.focus(), !1;
            } else throw new Error("Tokeo wallet not found");
            await this.library.requestAccounts();
            const r = (await this.library.getAccounts()).accounts;
            if (!r || r.length === 0) throw new Error("No accounts found");
            const n = r.find((o)=>o.type === "p2tr"), i1 = r.find((o)=>o.type === "p2wpkh");
            if (!n) throw new Error("No p2tr address found");
            this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", (i1 == null ? void 0 : i1.address) ?? n.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", (i1 == null ? void 0 : i1.publicKey) ?? n.publicKey), this.$store.setKey("accounts", r.map((o)=>o.address));
        } catch (r) {
            throw console.error(r), r;
        }
    }
    async getNetwork() {
        return mn;
    }
    async sendBTC(t, r) {
        const { psbtHex: n, psbtBase64: i1 } = await sb(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), o = await this.signPsbt({
            psbtBase64: i1,
            psbtHex: n,
            tx: n,
            broadcast: !0,
            finalize: !0
        });
        if (!o || !o.txId) throw new Error("Error sending BTC");
        return o.txId;
    }
    async signMessage(t, r) {
        return await this.library.signMessage(t, r == null ? void 0 : r.protocol);
    }
    async signPsbt({ psbtBase64: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        const o = {
            autoFinalize: n,
            inputs: i1 == null ? void 0 : i1.map((l)=>({
                    index: l.index,
                    address: l.address
                }))
        }, a = await this.library.signPsbt(t, Af(o)), s = zr.fromBase64(a);
        let c;
        return r && (c = await this.pushPsbt(a)), {
            signedPsbtHex: s.toHex(),
            signedPsbtBase64: s.toBase64(),
            txId: c
        };
    }
    async getPublicKey() {
        return this.$store.get().publicKey;
    }
    async requestAccounts() {
        return await this.library.requestAccounts(), (await this.library.getAccounts()).accounts.map((t)=>t.address);
    }
}
class dve extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer");
    }
    get library() {
        return window.unisat;
    }
    get network() {
        return this.$network.get();
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [Dl]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        })), ea(this.$store, [
            "provider"
        ], (t)=>{
            var r;
            if (t.provider !== Dl) {
                this == null || this.removeListeners();
                return;
            }
            (r = this.library) == null || r.getAccounts().then((n)=>{
                this.handleAccountsChanged(n);
            }), this.addListeners();
        });
    }
    addListeners() {
        var t, r;
        (t = this.library) == null || t.on("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.on("networkChanged", this.handleNetworkChanged.bind(this));
    }
    removeListeners() {
        var t, r;
        !this.library || !this.library.removeListener || ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect(), this.removeListeners();
    }
    handleAccountsChanged(t) {
        if (!t.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Dl) : this.parent.disconnect());
    }
    handleNetworkChanged(t) {
        const r = Am(t);
        this.network !== r && this.switchNetwork(r), this.parent.connect(Dl);
    }
    async connect(t) {
        if (!this.library) throw new Error("Unisat isn't installed");
        const r = await this.library.requestAccounts();
        if (!r) throw new Error("No accounts found");
        const n = await this.library.getPublicKey();
        if (!n) throw new Error("No public key found");
        this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n);
    }
    async getNetwork() {
        var t;
        const r = await ((t = this.library) == null ? void 0 : t.getChain());
        return r ? Am(r.enum) : this.network;
    }
    async sendBTC(t, r) {
        var n;
        const i1 = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
        if (!i1) throw new Error("Transaction failed");
        return i1;
    }
    async signMessage(t, r) {
        var n;
        const i1 = (r == null ? void 0 : r.protocol) === mb ? k1 : r == null ? void 0 : r.protocol;
        return await ((n = this.library) == null ? void 0 : n.signMessage(t, i1));
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        var o;
        const a = await ((o = this.library) == null ? void 0 : o.signPsbt(t, Af({
            autoFinalized: n,
            toSignInputs: i1
        }))), s = zr.fromHex(a);
        if (n && r) {
            const c = await this.pushPsbt(a);
            return {
                signedPsbtHex: s.toHex(),
                signedPsbtBase64: s.toBase64(),
                txId: c
            };
        }
        return {
            signedPsbtHex: s.toHex(),
            signedPsbtBase64: s.toBase64(),
            txId: void 0
        };
    }
    async signPsbts(t) {
        const { psbts: r, finalize: n, broadcast: i1, inputsToSign: o } = t, a = await this.library.signPsbts(r, Af({
            autoFinalized: n,
            toSignInputs: o
        }));
        return {
            signedPsbts: await Promise.all(a.map(async (s)=>{
                const c = zr.fromHex(s);
                let l;
                return n && i1 && (l = await this.pushPsbt(s)), {
                    signedPsbtHex: c.toHex(),
                    signedPsbtBase64: c.toBase64(),
                    txId: l
                };
            }))
        };
    }
    async getPublicKey() {
        var t;
        return await ((t = this.library) == null ? void 0 : t.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(t, r) {
        const n = t || 0, i1 = r || 10;
        return (await this.library.getInscriptions(n, i1)).list.map((o)=>qd(o, void 0, this.network));
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async switchNetwork(t) {
        var r;
        const n = mM(t);
        await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
    }
}
class hve extends ra {
    constructor(t, r, n){
        super(t, r, n), wt(this, "observer");
    }
    get library() {
        return window.wizz;
    }
    get network() {
        return this.$network.get();
    }
    handleNetworkChanged(t) {
        this.parent.connect(zd);
    }
    handleAccountsChanged(t) {
        if (!t.length) {
            this.parent.disconnect();
            return;
        }
        this.$store.get().accounts[0] !== t[0] && this.$store.setKey("accounts", t);
    }
    initialize() {
        ea(this.$store, [
            "provider"
        ], (t)=>{
            t.provider === zd ? this.addLibraryListeners() : this.removeLibraryListeners();
        }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            this.library && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [zd]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        }));
    }
    removeLibraryListeners() {
        var t, r;
        !this.library || !this.library.removeListener || ((t = this.library) == null || t.removeListener("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)));
    }
    addLibraryListeners() {
        var t, r;
        (t = this.library) == null || t.on("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this));
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect(), this.removeLibraryListeners();
    }
    async connect() {
        if (!this.library) throw C2e;
        const t = await this.library.requestAccounts();
        if (!t) throw new Error("No accounts found");
        const r = await this.library.getPublicKey();
        if (!r) throw new Error("No public key found");
        this.$store.setKey("accounts", t), this.$store.setKey("address", t[0]), this.$store.setKey("paymentAddress", t[0]), this.$store.setKey("publicKey", r), this.$store.setKey("paymentPublicKey", r), await this.getNetwork().then((n)=>{
            var i1;
            n && ((i1 = this.config) == null ? void 0 : i1.network) !== n && this.parent.switchNetwork(n);
        });
    }
    async requestAccounts() {
        return await this.library.requestAccounts();
    }
    async getNetwork() {
        var t;
        const r = await ((t = this.library) == null ? void 0 : t.getNetwork());
        return r ? Xk(r) : void 0;
    }
    async switchNetwork(t) {
        var r;
        if (t === ko || t === Ku) return await this.library.switchNetwork(Oa.MAINNET);
        const n = Xk(t);
        await ((r = this.library) == null ? void 0 : r.switchNetwork(n)), this.$network.set(t), await this.parent.getBalance();
    }
    async getPublicKey() {
        var t;
        return await ((t = this.library) == null ? void 0 : t.getPublicKey());
    }
    async getBalance() {
        return (await this.library.getBalance()).total;
    }
    async getInscriptions(t, r) {
        const n = t || 0, i1 = r || 10;
        return (await this.library.getInscriptions(n, i1)).list.map((o)=>qd(o, void 0, this.network));
    }
    async sendBTC(t, r) {
        var n;
        const i1 = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
        if (i1) return i1;
        throw new Error("Error sending BTC");
    }
    async signMessage(t, r) {
        var n;
        const i1 = (r == null ? void 0 : r.protocol) === mb ? k1 : r == null ? void 0 : r.protocol;
        return await ((n = this.library) == null ? void 0 : n.signMessage(t, i1));
    }
    async signPsbt({ psbtHex: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        var o;
        const a = await ((o = this.library) == null ? void 0 : o.signPsbt(t, Af({
            autoFinalized: n,
            broadcast: !1,
            toSignInputs: i1
        }))), s = zr.fromHex(a);
        let c;
        return n && r && (c = await this.pushPsbt(a)), {
            signedPsbtHex: s.toHex(),
            signedPsbtBase64: s.toBase64(),
            txId: c
        };
    }
}
const pve = (e)=>e === mn ? Qn.Mainnet : e === Ki ? Qn.Testnet : e === Xo ? Qn.Signet : e === ko ? Qn.Testnet : e === Ku ? Qn.Mainnet : e === _o ? Qn.Testnet4 : Qn.Mainnet;
class gve extends ra {
    constructor(){
        super(...arguments), wt(this, "observer");
    }
    get network() {
        return this.$network.get();
    }
    get library() {
        var t;
        return (t = window == null ? void 0 : window.XverseProviders) == null ? void 0 : t.BitcoinProvider;
    }
    initialize() {
        typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(()=>{
            var t;
            (this.library || this.isMobile()) && (this.$store.setKey("hasProvider", {
                ...this.$store.get().hasProvider,
                [jl]: !0
            }), (t = this.observer) == null || t.disconnect());
        }), this.observer.observe(document, {
            childList: !0,
            subtree: !0
        }));
    }
    dispose() {
        var t;
        (t = this.observer) == null || t.disconnect(), this.removeListeners();
    }
    addListeners() {
        Zk("accountChange", ()=>{}), Zk("networkChange", (t)=>{
            t.type === "networkChange" && this.handleNetworkChanged(t.bitcoin.name);
        });
    }
    removeListeners() {
        console.log("removeListeners");
    }
    // private handleAccountsChanged(accounts: string[]) {
    //   console.log('handleAccountsChanged', accounts)
    //   if (!accounts.length) {
    //     this.parent.disconnect()
    //     return
    //   }
    //   // if (this.$store.get().accounts[0] === accounts[0]) {
    //   //   return
    //   // }
    //   // this.$store.setKey('accounts', accounts)
    //   // if (accounts.length > 0) {
    //   //   this.parent.connect(XVERSE)
    //   // } else {
    //   //   this.parent.disconnect()
    //   // }
    // }
    handleNetworkChanged(t) {
        const r = g3(t);
        this.$network.set(r), this.parent.connect(jl);
    }
    async connect(t) {
        if (this.isMobile() && !this.library) {
            const a = `xverse://browser?url=${encodeURIComponent(window.location.href)}`;
            window.location.href = a;
            return;
        }
        let r, n, i1, o = [];
        try {
            const a = await kl("wallet_getAccount", null);
            if (a.status === "success") r = xm(a.result.addresses), n = _m(a.result.addresses), i1 = a.result.network.bitcoin.name, o = a.result.addresses.map((s)=>s.address);
            else throw new Error(`Error getting account: ${a.error.message}`);
        } catch (a) {
            if (a instanceof Error && (a.message.toLowerCase().includes("failed to get") || a.message.toLowerCase().includes("access denied"))) {
                const s = await kl("wallet_connect", {
                    addresses: [
                        yf.Ordinals,
                        yf.Payment
                    ],
                    message: "Connecting with lasereyes"
                });
                if (s.status === "success") r = xm(s.result.addresses), n = _m(s.result.addresses), i1 = s.result.network.bitcoin.name, o = s.result.addresses.map((c)=>c.address);
                else throw s.error.code === jp.USER_REJECTION ? new Error(`User canceled lasereyes to ${jl} wallet`) : new Error(s.error.message);
            } else throw console.error(a), new Error(`Error connecting to ${jl} wallet`);
        }
        if (!r || !n) throw new Error("Could not find the addresses");
        this.$store.setKey("address", r.address), this.$store.setKey("paymentAddress", n.address), this.$store.setKey("publicKey", String(r.publicKey)), this.$store.setKey("paymentPublicKey", String(n.publicKey)), this.$store.setKey("accounts", o), i1 && this.$network.set(g3(i1));
    }
    async getNetwork() {
        try {
            const t = await kl("wallet_getNetwork", null);
            if (t.status === "success") return g3(t.result.bitcoin.name);
            throw new Error("Error getting network");
        } catch (t) {
            return console.error(t), this.network;
        }
    }
    async switchNetwork(t) {
        if ((await kl("wallet_changeNetwork", {
            name: pve(t)
        })).status === "success") this.handleNetworkChanged(t);
        else throw new Error("Error switching network");
    }
    async sendBTC(t, r) {
        const n = await kl("sendTransfer", {
            recipients: [
                {
                    address: t,
                    amount: r
                }
            ]
        });
        if (n.status === "success") return n.result.txid;
        throw n.error.code === jp.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error sending BTC: ${n.error.message}`);
    }
    async signMessage(t, { toSignAddress: r, protocol: n }) {
        const i1 = r || this.$store.get().paymentAddress, o = await kl("signMessage", {
            address: i1,
            message: t,
            protocol: n === _1 ? mf.ECDSA : mf.BIP322
        });
        if (o.status === "success") return o.result.signature;
        throw o.error.code === jp.USER_REJECTION ? new Error("User rejected the request") : new Error(`Error signing message: ${o.error.message}`);
    }
    async signPsbt({ psbtBase64: t, broadcast: r, finalize: n, inputsToSign: i1 }) {
        try {
            const o = zr.fromBase64(String(t), {
                network: Vr(this.network)
            }).data.inputs;
            let a = {};
            if (i1) a = i1.reduce((h, y)=>(h[y.address] = [
                    ...h[y.address] || [],
                    y.index
                ], h), {});
            else {
                const { address: h, paymentAddress: y } = this.$store.get(), S = {
                    [h]: []
                }, k = {
                    [y]: []
                };
                for (const P of o.keys()){
                    const M = o[P];
                    if (M.witnessUtxo === void 0) {
                        k[y].push(Number(P));
                        continue;
                    }
                    const { script: N } = M.witnessUtxo, z = f1(N, Vr(this.network));
                    z === y ? k[y].push(Number(P)) : z === h && S[h].push(Number(P));
                }
                S[h].length > 0 && (a = {
                    ...a,
                    ...S
                }), k[y].length > 0 && (a = {
                    ...a,
                    ...k
                });
            }
            let s, c, l, u;
            const f = await kl("signPsbt", {
                psbt: t,
                broadcast: !!r,
                signInputs: a
            });
            if (f.status === "success") u = zr.fromBase64(f.result.psbt, {
                network: Vr(this.network)
            }), s = f.result.txid;
            else throw f.error.code === jp.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
            if (!u) throw new Error("Error signing psbt");
            return n && !s ? (u.finalizeAllInputs(), c = u.toHex(), l = u.toBase64()) : (c = u.toHex(), l = u.toBase64()), {
                signedPsbtHex: c,
                signedPsbtBase64: l,
                txId: s
            };
        } catch (o) {
            throw console.error(o), o;
        }
    }
}
class yve {
    constructor(t, r){
        wt(this, "$store"), wt(this, "$network"), wt(this, "$providerMap"), wt(this, "disposed", !1), wt(this, "dataSourceManager"), wt(this, "modules"), this.config = r, this.$store = t.$store, this.$network = t.$network, NZ(this.$store), this.$providerMap = {
            [jd]: new OAe(t, this, r),
            [_u]: new BAe(t, this, r),
            [Fd]: new PAe(t, this, r),
            [zl]: new CAe(t, this, r),
            [Mc]: new nve(t, this, r),
            [Ul]: new ove(t, this, r),
            [Fl]: new ave(t, this, r),
            [Ll]: new cve(t, this, r),
            [Ld]: new fve(t, this, r),
            [Dl]: new dve(t, this, r),
            [jl]: new gve(t, this, r),
            [zd]: new hve(t, this, r),
            [Hl]: new M2e(t, this, r)
        }, this.modules = {
            alkanes: new wR(this)
        };
        try {
            this.dataSourceManager = ff.getInstance();
        } catch  {
            ff.init(r), this.dataSourceManager = ff.getInstance();
        }
    }
    dispose() {
        this.disposed = !0;
        for (const t of Object.values(this.$providerMap))t.dispose();
    }
    initialize() {
        this.$network.listen(this.watchNetworkChange.bind(this)), ea(this.$store, [
            "isInitializing"
        ], (t, r)=>{
            if (!this.disposed && t.isInitializing !== r.isInitializing) return this.handleIsInitializingChanged(t.isInitializing);
        }), SAe(()=>{
            this.$store.setKey("isInitializing", !1), this.checkNetwork();
        });
    }
    async checkNetwork() {
        var t;
        const { provider: r, isInitializing: n } = this.$store.get();
        if (!r || n) return;
        const i1 = await this.getNetwork();
        i1 && (this.dataSourceManager.updateNetwork(i1), this.$network.set(i1));
        try {
            (t = this.config) != null && t.network && this.config.network !== i1 && await this.switchNetwork(this.config.network);
        } catch (o) {
            console.error("Couldn't enforce config network", o), this.disconnect();
        }
    }
    handleIsInitializingChanged(t) {
        if (typeof window < "u" && typeof localStorage < "u" && !t) {
            const r = localStorage == null ? void 0 : localStorage.getItem(wA);
            r && this.connect(r);
        }
    }
    async connect(t) {
        if (this.disposed) {
            console.warn("Client disposed, cannot connect");
            return;
        }
        this.$store.setKey("isConnecting", !0);
        try {
            if (localStorage == null || localStorage.setItem(wA, t), !this.$providerMap[t]) throw new Error("Unsupported wallet provider");
            const r = this.$providerMap[t];
            if (await (r == null ? void 0 : r.connect(t)) === !1) {
                this.$store.setKey("isConnecting", !1), this.disconnect();
                return;
            }
            this.$store.setKey("provider", t), await this.checkNetwork(), this.$store.setKey("connected", !0);
        } catch (r) {
            throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", !1), this.disconnect(), r;
        } finally{
            this.$store.setKey("isConnecting", !1);
        }
    }
    async requestAccounts() {
        var t;
        const r = this.$store.get().provider;
        if (!r) throw new Error("No wallet provider connected");
        try {
            return await ((t = this.$providerMap[r]) == null ? void 0 : t.requestAccounts());
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : n;
        }
    }
    disconnect() {
        this.$store.set({
            provider: void 0,
            address: "",
            paymentAddress: "",
            publicKey: "",
            paymentPublicKey: "",
            balance: void 0,
            accounts: [],
            connected: !1,
            isConnecting: !1,
            isInitializing: !1,
            hasProvider: this.$store.get().hasProvider
        }), localStorage == null || localStorage.removeItem(wA);
    }
    async switchNetwork(t) {
        var r;
        try {
            const n = this.$store.get().provider;
            n && (console.log("switchNetwork", t), await ((r = this.$providerMap[n]) == null ? void 0 : r.switchNetwork(t)), this.dataSourceManager.updateNetwork(t));
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error("The connected wallet doesn't support programmatic network changes..")) : n;
        }
    }
    watchNetworkChange() {
        this.$store.setKey("balance", void 0), this.getBalance();
    }
    async getNetwork() {
        var t;
        const r = this.$store.get().provider;
        return r && this.$providerMap[r] ? await ((t = this.$providerMap[r]) == null ? void 0 : t.getNetwork()) : this.$network.get();
    }
    async sendBTC(t, r) {
        var n;
        if (r <= 0) throw new Error("Amount must be greater than 0");
        if (!Number.isInteger(r)) throw new Error("Amount must be an integer");
        const i1 = this.$store.get().provider;
        if (!i1) throw new Error("No wallet connected");
        if (i1 && this.$providerMap[i1]) try {
            return await ((n = this.$providerMap[i1]) == null ? void 0 : n.sendBTC(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending BTC...") : o;
        }
        throw new Error("Something went wrong");
    }
    async signMessage(t, r) {
        let n = {};
        typeof r == "string" ? n = {
            toSignAddress: r
        } : r && (n = r);
        const i1 = this.$store.get().provider;
        if (!i1) throw new Error("No wallet connected");
        if (i1 && this.$providerMap[i1]) try {
            return await this.$providerMap[i1].signMessage(t, n);
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support message signing...") : o;
        }
        throw new Error("Something went wrong");
    }
    async signPsbt(t, r, n) {
        var i1;
        let o, a, s, c;
        typeof t == "string" ? (o = t, a = r ?? !1, s = n ?? !1) : (o = t.tx, a = t.finalize ?? !1, s = t.broadcast ?? !1, c = t.inputsToSign);
        let l, u;
        if (!o) throw new Error("No PSBT provided");
        if (ple(o)) u = zr.fromHex(o).toBase64(), l = o;
        else if (hle(o)) u = o, l = zr.fromBase64(o).toHex();
        else throw new Error("Invalid PSBT format");
        const f = this.$store.get().provider;
        if (f && this.$providerMap[f]) try {
            return await ((i1 = this.$providerMap[f]) == null ? void 0 : i1.signPsbt({
                psbtHex: l,
                psbtBase64: u,
                tx: o,
                broadcast: s,
                finalize: a,
                inputsToSign: c
            }));
        } catch (h) {
            throw h instanceof Error && h.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : h;
        }
        else throw new Error("No wallet provider connected");
    }
    async signPsbts(t) {
        var r;
        const { psbts: n, finalize: i1 = !1, broadcast: o = !1, inputsToSign: a } = t;
        if (!n || n.length === 0) throw new Error("No PSBTs provided");
        const s = this.$store.get().provider;
        if (s && this.$providerMap[s]) try {
            return await ((r = this.$providerMap[s]) == null ? void 0 : r.signPsbts({
                psbts: n,
                finalize: i1,
                broadcast: o,
                inputsToSign: a
            }));
        } catch (c) {
            throw c instanceof Error && c.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : c;
        }
        else throw new Error("No wallet provider connected");
    }
    async pushPsbt(t) {
        var r;
        const n = this.$store.get().provider;
        if (n && n && this.$providerMap[n]) try {
            return await ((r = this.$providerMap[n]) == null ? void 0 : r.pushPsbt(t));
        } catch (i1) {
            throw i1 instanceof Error && i1.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : i1;
        }
    }
    async inscribe(t, r, n) {
        var i1;
        const o = this.$store.get().provider;
        if (o && o && this.$providerMap[o]) try {
            return await ((i1 = this.$providerMap[o]) == null ? void 0 : i1.inscribe(t, r, this.dataSourceManager, n));
        } catch (a) {
            throw a instanceof Error && a.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support inscribing...") : a;
        }
    }
    async send(t, r) {
        var n;
        const i1 = this.$store.get().provider;
        if (i1 && i1 && this.$providerMap[i1]) try {
            return await ((n = this.$providerMap[i1]) == null ? void 0 : n.send(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending stuff...") : o;
        }
    }
    async getPublicKey() {
        var t;
        const r = this.$store.get().provider;
        if (r && r && this.$providerMap[r]) try {
            return await ((t = this.$providerMap[r]) == null ? void 0 : t.getPublicKey());
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : n;
        }
    }
    async getBalance() {
        const t = this.$store.get().provider;
        if (t && t && this.$providerMap[t]) try {
            const r = await this.$providerMap[t].getBalance();
            return this.$store.setKey("balance", BigInt(r)), r;
        } catch (r) {
            throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : r;
        }
    }
    async getMetaBalances(t) {
        const r = this.$store.get().provider;
        if (r && r && this.$providerMap[r]) try {
            if (!t) throw new Error("No protocol provided");
            return await this.$providerMap[r].getMetaBalances(t);
        } catch (n) {
            throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : n;
        }
    }
    async getInscriptions(t, r) {
        var n;
        const i1 = this.$store.get().provider;
        if (i1 && i1 && this.$providerMap[i1]) try {
            return await ((n = this.$providerMap[i1]) == null ? void 0 : n.getInscriptions(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
        }
    }
    async sendInscriptions(t, r) {
        var n;
        const i1 = this.$store.get().provider;
        if (i1 && i1 && this.$providerMap[i1]) try {
            return await ((n = this.$providerMap[i1]) == null ? void 0 : n.sendInscriptions(t, r));
        } catch (o) {
            throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
        }
    }
}
const { $store: mve, $network: bve } = Ij(), di = {
    connect: async ()=>{},
    disconnect: ()=>{},
    getBalance: async ()=>"",
    getMetaBalances: async ()=>[],
    getInscriptions: async ()=>[],
    getNetwork: async ()=>"",
    getPublicKey: async ()=>"",
    pushPsbt: async ()=>"",
    signMessage: async ()=>"",
    requestAccounts: async ()=>[],
    sendBTC: async ()=>"",
    signPsbt: async ()=>({
            signedPsbtBase64: "",
            signedPsbtHex: ""
        }),
    signPsbts: async ()=>({
            signedPsbts: []
        }),
    switchNetwork: async ()=>{},
    inscribe: async ()=>"",
    send: async ()=>"",
    sendInscriptions: async ()=>"",
    getUtxos: async ()=>[]
}, Vj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])({
    $store: mve,
    $network: bve,
    client: null,
    methods: di
});
function vB(e, t) {
    return Object.keys(e).every(function(r) {
        return Object.prototype.hasOwnProperty.call(t, r) && (t[r] === e[r] || typeof e[r] == "number" && typeof t[r] == "number" && isNaN(t[r]) && isNaN(e[r]));
    });
}
function Wj(e, t) {
    return typeof e == "object" && typeof t == "object" ? vB(e, t) && vB(t, e) : e === t;
}
let W4 = Symbol("clean"), Va = [], _c = 0;
const Ny = 4;
let nm = 0, wve = (e)=>{
    let t = [], r = {
        get () {
            return r.lc || r.listen(()=>{})(), r.value;
        },
        lc: 0,
        listen (n) {
            return r.lc = t.push(n), ()=>{
                for(let o = _c + Ny; o < Va.length;)Va[o] === n ? Va.splice(o, Ny) : o += Ny;
                let i1 = t.indexOf(n);
                ~i1 && (t.splice(i1, 1), --r.lc || r.off());
            };
        },
        notify (n, i1) {
            nm++;
            let o = !Va.length;
            for (let a of t)Va.push(a, r.value, n, i1);
            if (o) {
                for(_c = 0; _c < Va.length; _c += Ny)Va[_c](Va[_c + 1], Va[_c + 2], Va[_c + 3]);
                Va.length = 0;
            }
        },
        /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */ off () {},
        set (n) {
            let i1 = r.value;
            i1 !== n && (r.value = n, r.notify(i1));
        },
        subscribe (n) {
            let i1 = r.listen(n);
            return n(r.value), i1;
        },
        value: e
    };
    return ("TURBOPACK compile-time value", "development") !== "production" && (r[W4] = ()=>{
        t = [], r.lc = 0, r.off();
    }), r;
};
const Ave = 5, Ed = 6, Ry = 10;
let vve = (e, t, r, n)=>(e.events = e.events || {}, e.events[r + Ry] || (e.events[r + Ry] = n((i1)=>{
        e.events[r].reduceRight((o, a)=>(a(o), o), {
            shared: {},
            ...i1
        });
    })), e.events[r] = e.events[r] || [], e.events[r].push(t), ()=>{
        let i1 = e.events[r], o = i1.indexOf(t);
        i1.splice(o, 1), i1.length || (delete e.events[r], e.events[r + Ry](), delete e.events[r + Ry]);
    }), Eve = 1e3, Sve = (e, t)=>vve(e, (n)=>{
        let i1 = t(n);
        i1 && e.events[Ed].push(i1);
    }, Ave, (n)=>{
        let i1 = e.listen;
        e.listen = (...a)=>(!e.lc && !e.active && (e.active = !0, n()), i1(...a));
        let o = e.off;
        if ("TURBOPACK compile-time truthy", 1) {
            let a = e[W4];
            e[W4] = ()=>{
                for (let s of e.events[Ed])s();
                e.events[Ed] = [], e.active = !1, a();
            };
        }
        return ()=>{
            e.listen = i1, e.off = o;
        };
    }), xve = (e, t, r)=>{
    Array.isArray(e) || (e = [
        e
    ]);
    let n, i1, o = ()=>{
        if (i1 === nm) return;
        i1 = nm;
        let u = e.map((f)=>f.get());
        if (!n || u.some((f, h)=>f !== n[h])) {
            n = u;
            let f = t(...u);
            f && f.then && f.t ? f.then((h)=>{
                n === u && a.set(h);
            }) : (a.set(f), i1 = nm);
        }
    }, a = wve(void 0), s = a.get;
    a.get = ()=>(o(), s());
    let c, l = ()=>{
        clearTimeout(c), c = setTimeout(o);
    };
    return Sve(a, ()=>{
        let u = e.map((f)=>f.listen(l));
        return o(), ()=>{
            for (let f of u)f();
        };
    }), a;
}, _ve = (e, t)=>xve(e, t), kve = (e)=>{
    e.listen(()=>{});
};
const Ove = (e)=>({
        ...e
    });
function iu(e) {
    const { $network: t, $store: r, methods: n, client: i1 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(Vj), o = e ?? Ove, a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])((u, f)=>({
            paymentAddress: u.paymentAddress,
            address: u.address,
            publicKey: u.publicKey,
            paymentPublicKey: u.paymentPublicKey,
            library: {},
            network: f,
            client: i1,
            accounts: u.accounts,
            balance: u.balance ? Number(u.balance) : void 0,
            connected: u.connected,
            isConnecting: u.isConnecting,
            isInitializing: u.isInitializing,
            provider: u.provider,
            hasLeather: u.hasProvider.leather ?? !1,
            hasMagicEden: u.hasProvider["magic-eden"] ?? !1,
            hasOkx: u.hasProvider.okx ?? !1,
            hasOyl: u.hasProvider.oyl ?? !1,
            hasOrange: u.hasProvider.orange ?? !1,
            hasOpNet: u.hasProvider.op_net ?? !1,
            hasPhantom: u.hasProvider.phantom ?? !1,
            hasUnisat: u.hasProvider.unisat ?? !1,
            hasSparrow: u.hasProvider.sparrow ?? !1,
            hasWizz: u.hasProvider.wizz ?? !1,
            hasXverse: u.hasProvider.xverse ?? !1,
            hasTokeo: u.hasProvider.tokeo ?? !1,
            hasKeplr: u.hasProvider.keplr ?? !1,
            ...n
        }), [
        i1,
        n
    ]), s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])(()=>{
        const u = _ve([
            r,
            t
        ], a);
        return kve(u), u;
    }, [
        r,
        t,
        a
    ]), [c, l] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(()=>o(s.get()));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        const u = s.listen((f)=>{
            const h = o(f);
            Wj(h, c) || l(h);
        });
        return ()=>u();
    }, [
        s,
        o,
        c
    ]), c;
}
var Q1 = class {
    constructor(){
        this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
    }
    subscribe(e) {
        return this.listeners.add(e), this.onSubscribe(), ()=>{
            this.listeners.delete(e), this.onUnsubscribe();
        };
    }
    hasListeners() {
        return this.listeners.size > 0;
    }
    onSubscribe() {}
    onUnsubscribe() {}
}, Of = typeof window > "u" || "Deno" in globalThis;
function wo() {}
function Ive(e, t) {
    return typeof e == "function" ? e(t) : e;
}
function G4(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Gj(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0);
}
function Gc(e, t) {
    return typeof e == "function" ? e(t) : e;
}
function ts(e, t) {
    return typeof e == "function" ? e(t) : e;
}
function EB(e, t) {
    const { type: r = "all", exact: n, fetchStatus: i1, predicate: o, queryKey: a, stale: s } = e;
    if (a) {
        if (n) {
            if (t.queryHash !== S7(a, t.options)) return !1;
        } else if (!r1(t.queryKey, a)) return !1;
    }
    if (r !== "all") {
        const c = t.isActive();
        if (r === "active" && !c || r === "inactive" && c) return !1;
    }
    return !(typeof s == "boolean" && t.isStale() !== s || i1 && i1 !== t.state.fetchStatus || o && !o(t));
}
function SB(e, t) {
    const { exact: r, status: n, predicate: i1, mutationKey: o } = e;
    if (o) {
        if (!t.options.mutationKey) return !1;
        if (r) {
            if (t1(t.options.mutationKey) !== t1(o)) return !1;
        } else if (!r1(t.options.mutationKey, o)) return !1;
    }
    return !(n && t.state.status !== n || i1 && !i1(t));
}
function S7(e, t) {
    return ((t == null ? void 0 : t.queryKeyHashFn) || t1)(e);
}
function t1(e) {
    return JSON.stringify(e, (t, r)=>Z4(r) ? Object.keys(r).sort().reduce((n, i1)=>(n[i1] = r[i1], n), {}) : r);
}
function r1(e, t) {
    return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((r)=>r1(e[r], t[r])) : !1;
}
function Q4(e, t) {
    if (e === t) return e;
    const r = xB(e) && xB(t);
    if (r || Z4(e) && Z4(t)) {
        const n = r ? e : Object.keys(e), i1 = n.length, o = r ? t : Object.keys(t), a = o.length, s = r ? [] : {}, c = new Set(n);
        let l = 0;
        for(let u = 0; u < a; u++){
            const f = r ? u : o[u];
            (!r && c.has(f) || r) && e[f] === void 0 && t[f] === void 0 ? (s[f] = void 0, l++) : (s[f] = Q4(e[f], t[f]), s[f] === e[f] && e[f] !== void 0 && l++);
        }
        return i1 === a && l === i1 ? e : s;
    }
    return t;
}
function $4(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
    for(const r in e)if (e[r] !== t[r]) return !1;
    return !0;
}
function xB(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Z4(e) {
    if (!_B(e)) return !1;
    const t = e.constructor;
    if (t === void 0) return !0;
    const r = t.prototype;
    return !(!_B(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function _B(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
}
function Bve(e) {
    return new Promise((t)=>{
        setTimeout(t, e);
    });
}
function X4(e, t, r) {
    if (typeof r.structuralSharing == "function") return r.structuralSharing(e, t);
    if (r.structuralSharing !== !1) {
        if ("TURBOPACK compile-time truthy", 1) try {
            return Q4(e, t);
        } catch (n) {
            throw console.error(`Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${n}`), n;
        }
        return Q4(e, t);
    }
    return t;
}
function Tve(e, t, r = 0) {
    const n = [
        ...e,
        t
    ];
    return r && n.length > r ? n.slice(1) : n;
}
function Pve(e, t, r = 0) {
    const n = [
        t,
        ...e
    ];
    return r && n.length > r ? n.slice(0, -1) : n;
}
var A2 = Symbol();
function Qj(e, t) {
    return ("TURBOPACK compile-time value", "development") !== "production" && e.queryFn === A2 && console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`), !e.queryFn && t != null && t.initialPromise ? ()=>t.initialPromise : !e.queryFn || e.queryFn === A2 ? ()=>Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
function Cve(e, t) {
    return typeof e == "function" ? e(...t) : !!e;
}
var Xl, Rc, Xd, TB, Mve = (TB = class extends Q1 {
    constructor(){
        super();
        tr(this, Xl);
        tr(this, Rc);
        tr(this, Xd);
        Nt(this, Xd, (t)=>{
            if (!Of && window.addEventListener) {
                const r = ()=>t();
                return window.addEventListener("visibilitychange", r, !1), ()=>{
                    window.removeEventListener("visibilitychange", r);
                };
            }
        });
    }
    onSubscribe() {
        Fe(this, Rc) || this.setEventListener(Fe(this, Xd));
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = Fe(this, Rc)) == null || t.call(this), Nt(this, Rc, void 0));
    }
    setEventListener(t) {
        var r;
        Nt(this, Xd, t), (r = Fe(this, Rc)) == null || r.call(this), Nt(this, Rc, t((n)=>{
            typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
        }));
    }
    setFocused(t) {
        Fe(this, Xl) !== t && (Nt(this, Xl, t), this.onFocus());
    }
    onFocus() {
        const t = this.isFocused();
        this.listeners.forEach((r)=>{
            r(t);
        });
    }
    isFocused() {
        var t;
        return typeof Fe(this, Xl) == "boolean" ? Fe(this, Xl) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden";
    }
}, Xl = new WeakMap(), Rc = new WeakMap(), Xd = new WeakMap(), TB), x7 = new Mve(), Yd, Uc, Jd, PB, Nve = (PB = class extends Q1 {
    constructor(){
        super();
        tr(this, Yd, !0);
        tr(this, Uc);
        tr(this, Jd);
        Nt(this, Jd, (t)=>{
            if (!Of && window.addEventListener) {
                const r = ()=>t(!0), n = ()=>t(!1);
                return window.addEventListener("online", r, !1), window.addEventListener("offline", n, !1), ()=>{
                    window.removeEventListener("online", r), window.removeEventListener("offline", n);
                };
            }
        });
    }
    onSubscribe() {
        Fe(this, Uc) || this.setEventListener(Fe(this, Jd));
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = Fe(this, Uc)) == null || t.call(this), Nt(this, Uc, void 0));
    }
    setEventListener(t) {
        var r;
        Nt(this, Jd, t), (r = Fe(this, Uc)) == null || r.call(this), Nt(this, Uc, t(this.setOnline.bind(this)));
    }
    setOnline(t) {
        Fe(this, Yd) !== t && (Nt(this, Yd, t), this.listeners.forEach((n)=>{
            n(t);
        }));
    }
    isOnline() {
        return Fe(this, Yd);
    }
}, Yd = new WeakMap(), Uc = new WeakMap(), Jd = new WeakMap(), PB), v2 = new Nve();
function Y4() {
    let e, t;
    const r = new Promise((i1, o)=>{
        e = i1, t = o;
    });
    r.status = "pending", r.catch(()=>{});
    function n(i1) {
        Object.assign(r, i1), delete r.resolve, delete r.reject;
    }
    return r.resolve = (i1)=>{
        n({
            status: "fulfilled",
            value: i1
        }), e(i1);
    }, r.reject = (i1)=>{
        n({
            status: "rejected",
            reason: i1
        }), t(i1);
    }, r;
}
function Rve(e) {
    return Math.min(1e3 * 2 ** e, 3e4);
}
function $j(e) {
    return (e ?? "online") === "online" ? v2.isOnline() : !0;
}
var Zj = class extends Error {
    constructor(e){
        super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent;
    }
};
function p8(e) {
    return e instanceof Zj;
}
function Xj(e) {
    let t = !1, r = 0, n = !1, i1;
    const o = Y4(), a = (k)=>{
        var P;
        n || (h(new Zj(k)), (P = e.abort) == null || P.call(e));
    }, s = ()=>{
        t = !0;
    }, c = ()=>{
        t = !1;
    }, l = ()=>x7.isFocused() && (e.networkMode === "always" || v2.isOnline()) && e.canRun(), u = ()=>$j(e.networkMode) && e.canRun(), f = (k)=>{
        var P;
        n || (n = !0, (P = e.onSuccess) == null || P.call(e, k), i1 == null || i1(), o.resolve(k));
    }, h = (k)=>{
        var P;
        n || (n = !0, (P = e.onError) == null || P.call(e, k), i1 == null || i1(), o.reject(k));
    }, y = ()=>new Promise((k)=>{
            var P;
            i1 = (M)=>{
                (n || l()) && k(M);
            }, (P = e.onPause) == null || P.call(e);
        }).then(()=>{
            var k;
            i1 = void 0, n || (k = e.onContinue) == null || k.call(e);
        }), S = ()=>{
        if (n) return;
        let k;
        const P = r === 0 ? e.initialPromise : void 0;
        try {
            k = P ?? e.fn();
        } catch (M) {
            k = Promise.reject(M);
        }
        Promise.resolve(k).then(f).catch((M)=>{
            var ne;
            if (n) return;
            const N = e.retry ?? (Of ? 0 : 3), z = e.retryDelay ?? Rve, K = typeof z == "function" ? z(r, M) : z, $ = N === !0 || typeof N == "number" && r < N || typeof N == "function" && N(r, M);
            if (t || !$) {
                h(M);
                return;
            }
            r++, (ne = e.onFail) == null || ne.call(e, r, M), Bve(K).then(()=>l() ? void 0 : y()).then(()=>{
                t ? h(M) : S();
            });
        });
    };
    return {
        promise: o,
        cancel: a,
        continue: ()=>(i1 == null || i1(), o),
        cancelRetry: s,
        continueRetry: c,
        canStart: u,
        start: ()=>(u() ? S() : y().then(S), o)
    };
}
var Uve = (e)=>setTimeout(e, 0);
function Dve() {
    let e = [], t = 0, r = (s)=>{
        s();
    }, n = (s)=>{
        s();
    }, i1 = Uve;
    const o = (s)=>{
        t ? e.push(s) : i1(()=>{
            r(s);
        });
    }, a = ()=>{
        const s = e;
        e = [], s.length && i1(()=>{
            n(()=>{
                s.forEach((c)=>{
                    r(c);
                });
            });
        });
    };
    return {
        batch: (s)=>{
            let c;
            t++;
            try {
                c = s();
            } finally{
                t--, t || a();
            }
            return c;
        },
        /**
     * All calls to the wrapped function will be batched.
     */ batchCalls: (s)=>(...c)=>{
                o(()=>{
                    s(...c);
                });
            },
        schedule: o,
        /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */ setNotifyFunction: (s)=>{
            r = s;
        },
        /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */ setBatchNotifyFunction: (s)=>{
            n = s;
        },
        setScheduler: (s)=>{
            i1 = s;
        }
    };
}
var Oi = Dve(), Yl, CB, Yj = (CB = class {
    constructor(){
        tr(this, Yl);
    }
    destroy() {
        this.clearGcTimeout();
    }
    scheduleGc() {
        this.clearGcTimeout(), G4(this.gcTime) && Nt(this, Yl, setTimeout(()=>{
            this.optionalRemove();
        }, this.gcTime));
    }
    updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (Of ? 1 / 0 : 5 * 60 * 1e3));
    }
    clearGcTimeout() {
        Fe(this, Yl) && (clearTimeout(Fe(this, Yl)), Nt(this, Yl, void 0));
    }
}, Yl = new WeakMap(), CB), eh, Jl, xa, ef, Fi, n1, tf, Za, vu, MB, jve = (MB = class extends Yj {
    constructor(t){
        super();
        tr(this, Za);
        tr(this, eh);
        tr(this, Jl);
        tr(this, xa);
        tr(this, ef);
        tr(this, Fi);
        tr(this, n1);
        tr(this, tf);
        Nt(this, tf, !1), Nt(this, n1, t.defaultOptions), this.setOptions(t.options), this.observers = [], Nt(this, ef, t.client), Nt(this, xa, Fe(this, ef).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, Nt(this, eh, Fve(this.options)), this.state = t.state ?? Fe(this, eh), this.scheduleGc();
    }
    get meta() {
        return this.options.meta;
    }
    get promise() {
        var t;
        return (t = Fe(this, Fi)) == null ? void 0 : t.promise;
    }
    setOptions(t) {
        this.options = {
            ...Fe(this, n1),
            ...t
        }, this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && Fe(this, xa).remove(this);
    }
    setData(t, r) {
        const n = X4(this.state.data, t, this.options);
        return Kr(this, Za, vu).call(this, {
            data: n,
            type: "success",
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
        }), n;
    }
    setState(t, r) {
        Kr(this, Za, vu).call(this, {
            type: "setState",
            state: t,
            setStateOptions: r
        });
    }
    cancel(t) {
        var n, i1;
        const r = (n = Fe(this, Fi)) == null ? void 0 : n.promise;
        return (i1 = Fe(this, Fi)) == null || i1.cancel(t), r ? r.then(wo).catch(wo) : Promise.resolve();
    }
    destroy() {
        super.destroy(), this.cancel({
            silent: !0
        });
    }
    reset() {
        this.destroy(), this.setState(Fe(this, eh));
    }
    isActive() {
        return this.observers.some((t)=>ts(t.options.enabled, this) !== !1);
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === A2 || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
    }
    isStatic() {
        return this.getObserversCount() > 0 ? this.observers.some((t)=>Gc(t.options.staleTime, this) === "static") : !1;
    }
    isStale() {
        return this.getObserversCount() > 0 ? this.observers.some((t)=>t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated;
    }
    isStaleByTime(t = 0) {
        return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !Gj(this.state.dataUpdatedAt, t);
    }
    onFocus() {
        var r;
        const t = this.observers.find((n)=>n.shouldFetchOnWindowFocus());
        t == null || t.refetch({
            cancelRefetch: !1
        }), (r = Fe(this, Fi)) == null || r.continue();
    }
    onOnline() {
        var r;
        const t = this.observers.find((n)=>n.shouldFetchOnReconnect());
        t == null || t.refetch({
            cancelRefetch: !1
        }), (r = Fe(this, Fi)) == null || r.continue();
    }
    addObserver(t) {
        this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), Fe(this, xa).notify({
            type: "observerAdded",
            query: this,
            observer: t
        }));
    }
    removeObserver(t) {
        this.observers.includes(t) && (this.observers = this.observers.filter((r)=>r !== t), this.observers.length || (Fe(this, Fi) && (Fe(this, tf) ? Fe(this, Fi).cancel({
            revert: !0
        }) : Fe(this, Fi).cancelRetry()), this.scheduleGc()), Fe(this, xa).notify({
            type: "observerRemoved",
            query: this,
            observer: t
        }));
    }
    getObserversCount() {
        return this.observers.length;
    }
    invalidate() {
        this.state.isInvalidated || Kr(this, Za, vu).call(this, {
            type: "invalidate"
        });
    }
    fetch(t, r) {
        var l, u, f;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && r != null && r.cancelRefetch) this.cancel({
                silent: !0
            });
            else if (Fe(this, Fi)) return Fe(this, Fi).continueRetry(), Fe(this, Fi).promise;
        }
        if (t && this.setOptions(t), !this.options.queryFn) {
            const h = this.observers.find((y)=>y.options.queryFn);
            h && this.setOptions(h.options);
        }
        ("TURBOPACK compile-time value", "development") !== "production" && (Array.isArray(this.options.queryKey) || console.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"));
        const n = new AbortController(), i1 = (h)=>{
            Object.defineProperty(h, "signal", {
                enumerable: !0,
                get: ()=>(Nt(this, tf, !0), n.signal)
            });
        }, o = ()=>{
            const h = Qj(this.options, r), S = (()=>{
                const k = {
                    client: Fe(this, ef),
                    queryKey: this.queryKey,
                    meta: this.meta
                };
                return i1(k), k;
            })();
            return Nt(this, tf, !1), this.options.persister ? this.options.persister(h, S, this) : h(S);
        }, s = (()=>{
            const h = {
                fetchOptions: r,
                options: this.options,
                queryKey: this.queryKey,
                client: Fe(this, ef),
                state: this.state,
                fetchFn: o
            };
            return i1(h), h;
        })();
        (l = this.options.behavior) == null || l.onFetch(s, this), Nt(this, Jl, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = s.fetchOptions) == null ? void 0 : u.meta)) && Kr(this, Za, vu).call(this, {
            type: "fetch",
            meta: (f = s.fetchOptions) == null ? void 0 : f.meta
        });
        const c = (h)=>{
            var y, S, k, P;
            p8(h) && h.silent || Kr(this, Za, vu).call(this, {
                type: "error",
                error: h
            }), p8(h) || ((S = (y = Fe(this, xa).config).onError) == null || S.call(y, h, this), (P = (k = Fe(this, xa).config).onSettled) == null || P.call(k, this.state.data, h, this)), this.scheduleGc();
        };
        return Nt(this, Fi, Xj({
            initialPromise: r == null ? void 0 : r.initialPromise,
            fn: s.fetchFn,
            abort: n.abort.bind(n),
            onSuccess: (h)=>{
                var y, S, k, P;
                if (h === void 0) {
                    ("TURBOPACK compile-time value", "development") !== "production" && console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`), c(new Error(`${this.queryHash} data is undefined`));
                    return;
                }
                try {
                    this.setData(h);
                } catch (M) {
                    c(M);
                    return;
                }
                (S = (y = Fe(this, xa).config).onSuccess) == null || S.call(y, h, this), (P = (k = Fe(this, xa).config).onSettled) == null || P.call(k, h, this.state.error, this), this.scheduleGc();
            },
            onError: c,
            onFail: (h, y)=>{
                Kr(this, Za, vu).call(this, {
                    type: "failed",
                    failureCount: h,
                    error: y
                });
            },
            onPause: ()=>{
                Kr(this, Za, vu).call(this, {
                    type: "pause"
                });
            },
            onContinue: ()=>{
                Kr(this, Za, vu).call(this, {
                    type: "continue"
                });
            },
            retry: s.options.retry,
            retryDelay: s.options.retryDelay,
            networkMode: s.options.networkMode,
            canRun: ()=>!0
        })), Fe(this, Fi).start();
    }
}, eh = new WeakMap(), Jl = new WeakMap(), xa = new WeakMap(), ef = new WeakMap(), Fi = new WeakMap(), n1 = new WeakMap(), tf = new WeakMap(), Za = new WeakSet(), vu = function(t) {
    const r = (n)=>{
        switch(t.type){
            case "failed":
                return {
                    ...n,
                    fetchFailureCount: t.failureCount,
                    fetchFailureReason: t.error
                };
            case "pause":
                return {
                    ...n,
                    fetchStatus: "paused"
                };
            case "continue":
                return {
                    ...n,
                    fetchStatus: "fetching"
                };
            case "fetch":
                return {
                    ...n,
                    ...Jj(n.data, this.options),
                    fetchMeta: t.meta ?? null
                };
            case "success":
                return Nt(this, Jl, void 0), {
                    ...n,
                    data: t.data,
                    dataUpdateCount: n.dataUpdateCount + 1,
                    dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: "success",
                    ...!t.manual && {
                        fetchStatus: "idle",
                        fetchFailureCount: 0,
                        fetchFailureReason: null
                    }
                };
            case "error":
                const i1 = t.error;
                return p8(i1) && i1.revert && Fe(this, Jl) ? {
                    ...Fe(this, Jl),
                    fetchStatus: "idle"
                } : {
                    ...n,
                    error: i1,
                    errorUpdateCount: n.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: n.fetchFailureCount + 1,
                    fetchFailureReason: i1,
                    fetchStatus: "idle",
                    status: "error"
                };
            case "invalidate":
                return {
                    ...n,
                    isInvalidated: !0
                };
            case "setState":
                return {
                    ...n,
                    ...t.state
                };
        }
    };
    this.state = r(this.state), Oi.batch(()=>{
        this.observers.forEach((n)=>{
            n.onQueryUpdate();
        }), Fe(this, xa).notify({
            query: this,
            type: "updated",
            action: t
        });
    });
}, MB);
function Jj(e, t) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: $j(t.networkMode) ? "fetching" : "paused",
        ...e === void 0 && {
            error: null,
            status: "pending"
        }
    };
}
function Fve(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = t !== void 0, n = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: r ? n ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: r ? "success" : "pending",
        fetchStatus: "idle"
    };
}
var Ds, NB, zve = (NB = class extends Q1 {
    constructor(t = {}){
        super();
        tr(this, Ds);
        this.config = t, Nt(this, Ds, /* @__PURE__ */ new Map());
    }
    build(t, r, n) {
        const i1 = r.queryKey, o = r.queryHash ?? S7(i1, r);
        let a = this.get(o);
        return a || (a = new jve({
            client: t,
            queryKey: i1,
            queryHash: o,
            options: t.defaultQueryOptions(r),
            state: n,
            defaultOptions: t.getQueryDefaults(i1)
        }), this.add(a)), a;
    }
    add(t) {
        Fe(this, Ds).has(t.queryHash) || (Fe(this, Ds).set(t.queryHash, t), this.notify({
            type: "added",
            query: t
        }));
    }
    remove(t) {
        const r = Fe(this, Ds).get(t.queryHash);
        r && (t.destroy(), r === t && Fe(this, Ds).delete(t.queryHash), this.notify({
            type: "removed",
            query: t
        }));
    }
    clear() {
        Oi.batch(()=>{
            this.getAll().forEach((t)=>{
                this.remove(t);
            });
        });
    }
    get(t) {
        return Fe(this, Ds).get(t);
    }
    getAll() {
        return [
            ...Fe(this, Ds).values()
        ];
    }
    find(t) {
        const r = {
            exact: !0,
            ...t
        };
        return this.getAll().find((n)=>EB(r, n));
    }
    findAll(t = {}) {
        const r = this.getAll();
        return Object.keys(t).length > 0 ? r.filter((n)=>EB(t, n)) : r;
    }
    notify(t) {
        Oi.batch(()=>{
            this.listeners.forEach((r)=>{
                r(t);
            });
        });
    }
    onFocus() {
        Oi.batch(()=>{
            this.getAll().forEach((t)=>{
                t.onFocus();
            });
        });
    }
    onOnline() {
        Oi.batch(()=>{
            this.getAll().forEach((t)=>{
                t.onOnline();
            });
        });
    }
}, Ds = new WeakMap(), NB), js, eo, rf, Fs, Bc, RB, Lve = (RB = class extends Yj {
    constructor(t){
        super();
        tr(this, Fs);
        tr(this, js);
        tr(this, eo);
        tr(this, rf);
        this.mutationId = t.mutationId, Nt(this, eo, t.mutationCache), Nt(this, js, []), this.state = t.state || Hve(), this.setOptions(t.options), this.scheduleGc();
    }
    setOptions(t) {
        this.options = t, this.updateGcTime(this.options.gcTime);
    }
    get meta() {
        return this.options.meta;
    }
    addObserver(t) {
        Fe(this, js).includes(t) || (Fe(this, js).push(t), this.clearGcTimeout(), Fe(this, eo).notify({
            type: "observerAdded",
            mutation: this,
            observer: t
        }));
    }
    removeObserver(t) {
        Nt(this, js, Fe(this, js).filter((r)=>r !== t)), this.scheduleGc(), Fe(this, eo).notify({
            type: "observerRemoved",
            mutation: this,
            observer: t
        });
    }
    optionalRemove() {
        Fe(this, js).length || (this.state.status === "pending" ? this.scheduleGc() : Fe(this, eo).remove(this));
    }
    continue() {
        var t;
        return ((t = Fe(this, rf)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
        this.execute(this.state.variables);
    }
    async execute(t) {
        var o, a, s, c, l, u, f, h, y, S, k, P, M, N, z, K, $, ne, ee, q;
        const r = ()=>{
            Kr(this, Fs, Bc).call(this, {
                type: "continue"
            });
        };
        Nt(this, rf, Xj({
            fn: ()=>this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
            onFail: (U, Q)=>{
                Kr(this, Fs, Bc).call(this, {
                    type: "failed",
                    failureCount: U,
                    error: Q
                });
            },
            onPause: ()=>{
                Kr(this, Fs, Bc).call(this, {
                    type: "pause"
                });
            },
            onContinue: r,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: ()=>Fe(this, eo).canRun(this)
        }));
        const n = this.state.status === "pending", i1 = !Fe(this, rf).canStart();
        try {
            if (n) r();
            else {
                Kr(this, Fs, Bc).call(this, {
                    type: "pending",
                    variables: t,
                    isPaused: i1
                }), await ((a = (o = Fe(this, eo).config).onMutate) == null ? void 0 : a.call(o, t, this));
                const Q = await ((c = (s = this.options).onMutate) == null ? void 0 : c.call(s, t));
                Q !== this.state.context && Kr(this, Fs, Bc).call(this, {
                    type: "pending",
                    context: Q,
                    variables: t,
                    isPaused: i1
                });
            }
            const U = await Fe(this, rf).start();
            return await ((u = (l = Fe(this, eo).config).onSuccess) == null ? void 0 : u.call(l, U, t, this.state.context, this)), await ((h = (f = this.options).onSuccess) == null ? void 0 : h.call(f, U, t, this.state.context)), await ((S = (y = Fe(this, eo).config).onSettled) == null ? void 0 : S.call(y, U, null, this.state.variables, this.state.context, this)), await ((P = (k = this.options).onSettled) == null ? void 0 : P.call(k, U, null, t, this.state.context)), Kr(this, Fs, Bc).call(this, {
                type: "success",
                data: U
            }), U;
        } catch (U) {
            try {
                throw await ((N = (M = Fe(this, eo).config).onError) == null ? void 0 : N.call(M, U, t, this.state.context, this)), await ((K = (z = this.options).onError) == null ? void 0 : K.call(z, U, t, this.state.context)), await ((ne = ($ = Fe(this, eo).config).onSettled) == null ? void 0 : ne.call($, void 0, U, this.state.variables, this.state.context, this)), await ((q = (ee = this.options).onSettled) == null ? void 0 : q.call(ee, void 0, U, t, this.state.context)), U;
            } finally{
                Kr(this, Fs, Bc).call(this, {
                    type: "error",
                    error: U
                });
            }
        } finally{
            Fe(this, eo).runNext(this);
        }
    }
}, js = new WeakMap(), eo = new WeakMap(), rf = new WeakMap(), Fs = new WeakSet(), Bc = function(t) {
    const r = (n)=>{
        switch(t.type){
            case "failed":
                return {
                    ...n,
                    failureCount: t.failureCount,
                    failureReason: t.error
                };
            case "pause":
                return {
                    ...n,
                    isPaused: !0
                };
            case "continue":
                return {
                    ...n,
                    isPaused: !1
                };
            case "pending":
                return {
                    ...n,
                    context: t.context,
                    data: void 0,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    isPaused: t.isPaused,
                    status: "pending",
                    variables: t.variables,
                    submittedAt: Date.now()
                };
            case "success":
                return {
                    ...n,
                    data: t.data,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    status: "success",
                    isPaused: !1
                };
            case "error":
                return {
                    ...n,
                    data: void 0,
                    error: t.error,
                    failureCount: n.failureCount + 1,
                    failureReason: t.error,
                    isPaused: !1,
                    status: "error"
                };
        }
    };
    this.state = r(this.state), Oi.batch(()=>{
        Fe(this, js).forEach((n)=>{
            n.onMutationUpdate(t);
        }), Fe(this, eo).notify({
            mutation: this,
            type: "updated",
            action: t
        });
    });
}, RB);
function Hve() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    };
}
var Iu, Xa, i1, UB, Kve = (UB = class extends Q1 {
    constructor(t = {}){
        super();
        tr(this, Iu);
        tr(this, Xa);
        tr(this, i1);
        this.config = t, Nt(this, Iu, /* @__PURE__ */ new Set()), Nt(this, Xa, /* @__PURE__ */ new Map()), Nt(this, i1, 0);
    }
    build(t, r, n) {
        const i2 = new Lve({
            mutationCache: this,
            mutationId: ++Ug(this, i1)._,
            options: t.defaultMutationOptions(r),
            state: n
        });
        return this.add(i2), i2;
    }
    add(t) {
        Fe(this, Iu).add(t);
        const r = Uy(t);
        if (typeof r == "string") {
            const n = Fe(this, Xa).get(r);
            n ? n.push(t) : Fe(this, Xa).set(r, [
                t
            ]);
        }
        this.notify({
            type: "added",
            mutation: t
        });
    }
    remove(t) {
        if (Fe(this, Iu).delete(t)) {
            const r = Uy(t);
            if (typeof r == "string") {
                const n = Fe(this, Xa).get(r);
                if (n) if (n.length > 1) {
                    const i1 = n.indexOf(t);
                    i1 !== -1 && n.splice(i1, 1);
                } else n[0] === t && Fe(this, Xa).delete(r);
            }
        }
        this.notify({
            type: "removed",
            mutation: t
        });
    }
    canRun(t) {
        const r = Uy(t);
        if (typeof r == "string") {
            const n = Fe(this, Xa).get(r), i1 = n == null ? void 0 : n.find((o)=>o.state.status === "pending");
            return !i1 || i1 === t;
        } else return !0;
    }
    runNext(t) {
        var n;
        const r = Uy(t);
        if (typeof r == "string") {
            const i1 = (n = Fe(this, Xa).get(r)) == null ? void 0 : n.find((o)=>o !== t && o.state.isPaused);
            return (i1 == null ? void 0 : i1.continue()) ?? Promise.resolve();
        } else return Promise.resolve();
    }
    clear() {
        Oi.batch(()=>{
            Fe(this, Iu).forEach((t)=>{
                this.notify({
                    type: "removed",
                    mutation: t
                });
            }), Fe(this, Iu).clear(), Fe(this, Xa).clear();
        });
    }
    getAll() {
        return Array.from(Fe(this, Iu));
    }
    find(t) {
        const r = {
            exact: !0,
            ...t
        };
        return this.getAll().find((n)=>SB(r, n));
    }
    findAll(t = {}) {
        return this.getAll().filter((r)=>SB(t, r));
    }
    notify(t) {
        Oi.batch(()=>{
            this.listeners.forEach((r)=>{
                r(t);
            });
        });
    }
    resumePausedMutations() {
        const t = this.getAll().filter((r)=>r.state.isPaused);
        return Oi.batch(()=>Promise.all(t.map((r)=>r.continue().catch(wo))));
    }
}, Iu = new WeakMap(), Xa = new WeakMap(), i1 = new WeakMap(), UB);
function Uy(e) {
    var t;
    return (t = e.options.scope) == null ? void 0 : t.id;
}
function E2(e) {
    return {
        onFetch: (t, r)=>{
            var u, f, h, y, S;
            const n = t.options, i1 = (h = (f = (u = t.fetchOptions) == null ? void 0 : u.meta) == null ? void 0 : f.fetchMore) == null ? void 0 : h.direction, o = ((y = t.state.data) == null ? void 0 : y.pages) || [], a = ((S = t.state.data) == null ? void 0 : S.pageParams) || [];
            let s = {
                pages: [],
                pageParams: []
            }, c = 0;
            const l = async ()=>{
                let k = !1;
                const P = (z)=>{
                    Object.defineProperty(z, "signal", {
                        enumerable: !0,
                        get: ()=>(t.signal.aborted ? k = !0 : t.signal.addEventListener("abort", ()=>{
                                k = !0;
                            }), t.signal)
                    });
                }, M = Qj(t.options, t.fetchOptions), N = async (z, K, $)=>{
                    if (k) return Promise.reject();
                    if (K == null && z.pages.length) return Promise.resolve(z);
                    const ee = (()=>{
                        const v = {
                            client: t.client,
                            queryKey: t.queryKey,
                            pageParam: K,
                            direction: $ ? "backward" : "forward",
                            meta: t.options.meta
                        };
                        return P(v), v;
                    })(), q = await M(ee), { maxPages: U } = t.options, Q = $ ? Pve : Tve;
                    return {
                        pages: Q(z.pages, q, U),
                        pageParams: Q(z.pageParams, K, U)
                    };
                };
                if (i1 && o.length) {
                    const z = i1 === "backward", K = z ? eF : J4, $ = {
                        pages: o,
                        pageParams: a
                    }, ne = K(n, $);
                    s = await N($, ne, z);
                } else {
                    const z = e ?? o.length;
                    do {
                        const K = c === 0 ? a[0] ?? n.initialPageParam : J4(n, s);
                        if (c > 0 && K == null) break;
                        s = await N(s, K), c++;
                    }while (c < z)
                }
                return s;
            };
            t.options.persister ? t.fetchFn = ()=>{
                var k, P;
                return (P = (k = t.options).persister) == null ? void 0 : P.call(k, l, {
                    client: t.client,
                    queryKey: t.queryKey,
                    meta: t.options.meta,
                    signal: t.signal
                }, r);
            } : t.fetchFn = l;
        }
    };
}
function J4(e, { pages: t, pageParams: r }) {
    const n = t.length - 1;
    return t.length > 0 ? e.getNextPageParam(t[n], t, r[n], r) : void 0;
}
function eF(e, { pages: t, pageParams: r }) {
    var n;
    return t.length > 0 ? (n = e.getPreviousPageParam) == null ? void 0 : n.call(e, t[0], t, r[0], r) : void 0;
}
function qve(e, t) {
    return t ? J4(e, t) != null : !1;
}
function Vve(e, t) {
    return !t || !e.getPreviousPageParam ? !1 : eF(e, t) != null;
}
var Fn, Dc, jc, th, rh, Fc, nh, ih, DB, Wve = (DB = class {
    constructor(e = {}){
        tr(this, Fn);
        tr(this, Dc);
        tr(this, jc);
        tr(this, th);
        tr(this, rh);
        tr(this, Fc);
        tr(this, nh);
        tr(this, ih);
        Nt(this, Fn, e.queryCache || new zve()), Nt(this, Dc, e.mutationCache || new Kve()), Nt(this, jc, e.defaultOptions || {}), Nt(this, th, /* @__PURE__ */ new Map()), Nt(this, rh, /* @__PURE__ */ new Map()), Nt(this, Fc, 0);
    }
    mount() {
        Ug(this, Fc)._++, Fe(this, Fc) === 1 && (Nt(this, nh, x7.subscribe(async (e)=>{
            e && (await this.resumePausedMutations(), Fe(this, Fn).onFocus());
        })), Nt(this, ih, v2.subscribe(async (e)=>{
            e && (await this.resumePausedMutations(), Fe(this, Fn).onOnline());
        })));
    }
    unmount() {
        var e, t;
        Ug(this, Fc)._--, Fe(this, Fc) === 0 && ((e = Fe(this, nh)) == null || e.call(this), Nt(this, nh, void 0), (t = Fe(this, ih)) == null || t.call(this), Nt(this, ih, void 0));
    }
    isFetching(e) {
        return Fe(this, Fn).findAll({
            ...e,
            fetchStatus: "fetching"
        }).length;
    }
    isMutating(e) {
        return Fe(this, Dc).findAll({
            ...e,
            status: "pending"
        }).length;
    }
    /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */ getQueryData(e) {
        var r;
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return (r = Fe(this, Fn).get(t.queryHash)) == null ? void 0 : r.state.data;
    }
    ensureQueryData(e) {
        const t = this.defaultQueryOptions(e), r = Fe(this, Fn).build(this, t), n = r.state.data;
        return n === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(Gc(t.staleTime, r)) && this.prefetchQuery(t), Promise.resolve(n));
    }
    getQueriesData(e) {
        return Fe(this, Fn).findAll(e).map(({ queryKey: t, state: r })=>{
            const n = r.data;
            return [
                t,
                n
            ];
        });
    }
    setQueryData(e, t, r) {
        const n = this.defaultQueryOptions({
            queryKey: e
        }), i1 = Fe(this, Fn).get(n.queryHash), o = i1 == null ? void 0 : i1.state.data, a = Ive(t, o);
        if (a !== void 0) return Fe(this, Fn).build(this, n).setData(a, {
            ...r,
            manual: !0
        });
    }
    setQueriesData(e, t, r) {
        return Oi.batch(()=>Fe(this, Fn).findAll(e).map(({ queryKey: n })=>[
                    n,
                    this.setQueryData(n, t, r)
                ]));
    }
    getQueryState(e) {
        var r;
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return (r = Fe(this, Fn).get(t.queryHash)) == null ? void 0 : r.state;
    }
    removeQueries(e) {
        const t = Fe(this, Fn);
        Oi.batch(()=>{
            t.findAll(e).forEach((r)=>{
                t.remove(r);
            });
        });
    }
    resetQueries(e, t) {
        const r = Fe(this, Fn);
        return Oi.batch(()=>(r.findAll(e).forEach((n)=>{
                n.reset();
            }), this.refetchQueries({
                type: "active",
                ...e
            }, t)));
    }
    cancelQueries(e, t = {}) {
        const r = {
            revert: !0,
            ...t
        }, n = Oi.batch(()=>Fe(this, Fn).findAll(e).map((i1)=>i1.cancel(r)));
        return Promise.all(n).then(wo).catch(wo);
    }
    invalidateQueries(e, t = {}) {
        return Oi.batch(()=>(Fe(this, Fn).findAll(e).forEach((r)=>{
                r.invalidate();
            }), (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
                ...e,
                type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active"
            }, t)));
    }
    refetchQueries(e, t = {}) {
        const r = {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }, n = Oi.batch(()=>Fe(this, Fn).findAll(e).filter((i1)=>!i1.isDisabled() && !i1.isStatic()).map((i1)=>{
                let o = i1.fetch(void 0, r);
                return r.throwOnError || (o = o.catch(wo)), i1.state.fetchStatus === "paused" ? Promise.resolve() : o;
            }));
        return Promise.all(n).then(wo);
    }
    fetchQuery(e) {
        const t = this.defaultQueryOptions(e);
        t.retry === void 0 && (t.retry = !1);
        const r = Fe(this, Fn).build(this, t);
        return r.isStaleByTime(Gc(t.staleTime, r)) ? r.fetch(t) : Promise.resolve(r.state.data);
    }
    prefetchQuery(e) {
        return this.fetchQuery(e).then(wo).catch(wo);
    }
    fetchInfiniteQuery(e) {
        return e.behavior = E2(e.pages), this.fetchQuery(e);
    }
    prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(wo).catch(wo);
    }
    ensureInfiniteQueryData(e) {
        return e.behavior = E2(e.pages), this.ensureQueryData(e);
    }
    resumePausedMutations() {
        return v2.isOnline() ? Fe(this, Dc).resumePausedMutations() : Promise.resolve();
    }
    getQueryCache() {
        return Fe(this, Fn);
    }
    getMutationCache() {
        return Fe(this, Dc);
    }
    getDefaultOptions() {
        return Fe(this, jc);
    }
    setDefaultOptions(e) {
        Nt(this, jc, e);
    }
    setQueryDefaults(e, t) {
        Fe(this, th).set(t1(e), {
            queryKey: e,
            defaultOptions: t
        });
    }
    getQueryDefaults(e) {
        const t = [
            ...Fe(this, th).values()
        ], r = {};
        return t.forEach((n)=>{
            r1(e, n.queryKey) && Object.assign(r, n.defaultOptions);
        }), r;
    }
    setMutationDefaults(e, t) {
        Fe(this, rh).set(t1(e), {
            mutationKey: e,
            defaultOptions: t
        });
    }
    getMutationDefaults(e) {
        const t = [
            ...Fe(this, rh).values()
        ], r = {};
        return t.forEach((n)=>{
            r1(e, n.mutationKey) && Object.assign(r, n.defaultOptions);
        }), r;
    }
    defaultQueryOptions(e) {
        if (e._defaulted) return e;
        const t = {
            ...Fe(this, jc).queries,
            ...this.getQueryDefaults(e.queryKey),
            ...e,
            _defaulted: !0
        };
        return t.queryHash || (t.queryHash = S7(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === A2 && (t.enabled = !1), t;
    }
    defaultMutationOptions(e) {
        return e != null && e._defaulted ? e : {
            ...Fe(this, jc).mutations,
            ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
            ...e,
            _defaulted: !0
        };
    }
    clear() {
        Fe(this, Fn).clear(), Fe(this, Dc).clear();
    }
}, Fn = new WeakMap(), Dc = new WeakMap(), jc = new WeakMap(), th = new WeakMap(), rh = new WeakMap(), Fc = new WeakMap(), nh = new WeakMap(), ih = new WeakMap(), DB), bo, qr, o1, to, nf, oh, zc, Lc, a1, ah, sh, of, af, Hc, uh, tn, Kp, e6, t6, r6, n6, i6, o6, a6, rF, jB, tF = (jB = class extends Q1 {
    constructor(t, r){
        super();
        tr(this, tn);
        tr(this, bo);
        tr(this, qr);
        tr(this, o1);
        tr(this, to);
        tr(this, nf);
        tr(this, oh);
        tr(this, zc);
        tr(this, Lc);
        tr(this, a1);
        tr(this, ah);
        // This property keeps track of the last query with defined data.
        // It will be used to pass the previous data and query to the placeholder function between renders.
        tr(this, sh);
        tr(this, of);
        tr(this, af);
        tr(this, Hc);
        tr(this, uh, /* @__PURE__ */ new Set());
        this.options = r, Nt(this, bo, t), Nt(this, Lc, null), Nt(this, zc, Y4()), this.options.experimental_prefetchInRender || Fe(this, zc).reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(r);
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
        this.listeners.size === 1 && (Fe(this, qr).addObserver(this), kB(Fe(this, qr), this.options) ? Kr(this, tn, Kp).call(this) : this.updateResult(), Kr(this, tn, n6).call(this));
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy();
    }
    shouldFetchOnReconnect() {
        return s6(Fe(this, qr), this.options, this.options.refetchOnReconnect);
    }
    shouldFetchOnWindowFocus() {
        return s6(Fe(this, qr), this.options, this.options.refetchOnWindowFocus);
    }
    destroy() {
        this.listeners = /* @__PURE__ */ new Set(), Kr(this, tn, i6).call(this), Kr(this, tn, o6).call(this), Fe(this, qr).removeObserver(this);
    }
    setOptions(t) {
        const r = this.options, n = Fe(this, qr);
        if (this.options = Fe(this, bo).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof ts(this.options.enabled, Fe(this, qr)) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        Kr(this, tn, a6).call(this), Fe(this, qr).setOptions(this.options), r._defaulted && !$4(this.options, r) && Fe(this, bo).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: Fe(this, qr),
            observer: this
        });
        const i1 = this.hasListeners();
        i1 && OB(Fe(this, qr), n, this.options, r) && Kr(this, tn, Kp).call(this), this.updateResult(), i1 && (Fe(this, qr) !== n || ts(this.options.enabled, Fe(this, qr)) !== ts(r.enabled, Fe(this, qr)) || Gc(this.options.staleTime, Fe(this, qr)) !== Gc(r.staleTime, Fe(this, qr))) && Kr(this, tn, e6).call(this);
        const o = Kr(this, tn, t6).call(this);
        i1 && (Fe(this, qr) !== n || ts(this.options.enabled, Fe(this, qr)) !== ts(r.enabled, Fe(this, qr)) || o !== Fe(this, Hc)) && Kr(this, tn, r6).call(this, o);
    }
    getOptimisticResult(t) {
        const r = Fe(this, bo).getQueryCache().build(Fe(this, bo), t), n = this.createResult(r, t);
        return Qve(this, n) && (Nt(this, to, n), Nt(this, oh, this.options), Nt(this, nf, Fe(this, qr).state)), n;
    }
    getCurrentResult() {
        return Fe(this, to);
    }
    trackResult(t, r) {
        return new Proxy(t, {
            get: (n, i1)=>(this.trackProp(i1), r == null || r(i1), Reflect.get(n, i1))
        });
    }
    trackProp(t) {
        Fe(this, uh).add(t);
    }
    getCurrentQuery() {
        return Fe(this, qr);
    }
    refetch({ ...t } = {}) {
        return this.fetch({
            ...t
        });
    }
    fetchOptimistic(t) {
        const r = Fe(this, bo).defaultQueryOptions(t), n = Fe(this, bo).getQueryCache().build(Fe(this, bo), r);
        return n.fetch().then(()=>this.createResult(n, r));
    }
    fetch(t) {
        return Kr(this, tn, Kp).call(this, {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }).then(()=>(this.updateResult(), Fe(this, to)));
    }
    createResult(t, r) {
        var U;
        const n = Fe(this, qr), i1 = this.options, o = Fe(this, to), a = Fe(this, nf), s = Fe(this, oh), l = t !== n ? t.state : Fe(this, o1), { state: u } = t;
        let f = {
            ...u
        }, h = !1, y;
        if (r._optimisticResults) {
            const Q = this.hasListeners(), v = !Q && kB(t, r), B = Q && OB(t, n, r, i1);
            (v || B) && (f = {
                ...f,
                ...Jj(u.data, t.options)
            }), r._optimisticResults === "isRestoring" && (f.fetchStatus = "idle");
        }
        let { error: S, errorUpdatedAt: k, status: P } = f;
        y = f.data;
        let M = !1;
        if (r.placeholderData !== void 0 && y === void 0 && P === "pending") {
            let Q;
            o != null && o.isPlaceholderData && r.placeholderData === (s == null ? void 0 : s.placeholderData) ? (Q = o.data, M = !0) : Q = typeof r.placeholderData == "function" ? r.placeholderData((U = Fe(this, sh)) == null ? void 0 : U.state.data, Fe(this, sh)) : r.placeholderData, Q !== void 0 && (P = "success", y = X4(o == null ? void 0 : o.data, Q, r), h = !0);
        }
        if (r.select && y !== void 0 && !M) if (o && y === (a == null ? void 0 : a.data) && r.select === Fe(this, a1)) y = Fe(this, ah);
        else try {
            Nt(this, a1, r.select), y = r.select(y), y = X4(o == null ? void 0 : o.data, y, r), Nt(this, ah, y), Nt(this, Lc, null);
        } catch (Q) {
            Nt(this, Lc, Q);
        }
        Fe(this, Lc) && (S = Fe(this, Lc), y = Fe(this, ah), k = Date.now(), P = "error");
        const N = f.fetchStatus === "fetching", z = P === "pending", K = P === "error", $ = z && N, ne = y !== void 0, q = {
            status: P,
            fetchStatus: f.fetchStatus,
            isPending: z,
            isSuccess: P === "success",
            isError: K,
            isInitialLoading: $,
            isLoading: $,
            data: y,
            dataUpdatedAt: f.dataUpdatedAt,
            error: S,
            errorUpdatedAt: k,
            failureCount: f.fetchFailureCount,
            failureReason: f.fetchFailureReason,
            errorUpdateCount: f.errorUpdateCount,
            isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
            isFetchedAfterMount: f.dataUpdateCount > l.dataUpdateCount || f.errorUpdateCount > l.errorUpdateCount,
            isFetching: N,
            isRefetching: N && !z,
            isLoadingError: K && !ne,
            isPaused: f.fetchStatus === "paused",
            isPlaceholderData: h,
            isRefetchError: K && ne,
            isStale: _7(t, r),
            refetch: this.refetch,
            promise: Fe(this, zc)
        };
        if (this.options.experimental_prefetchInRender) {
            const Q = (g)=>{
                q.status === "error" ? g.reject(q.error) : q.data !== void 0 && g.resolve(q.data);
            }, v = ()=>{
                const g = Nt(this, zc, q.promise = Y4());
                Q(g);
            }, B = Fe(this, zc);
            switch(B.status){
                case "pending":
                    t.queryHash === n.queryHash && Q(B);
                    break;
                case "fulfilled":
                    (q.status === "error" || q.data !== B.value) && v();
                    break;
                case "rejected":
                    (q.status !== "error" || q.error !== B.reason) && v();
                    break;
            }
        }
        return q;
    }
    updateResult() {
        const t = Fe(this, to), r = this.createResult(Fe(this, qr), this.options);
        if (Nt(this, nf, Fe(this, qr).state), Nt(this, oh, this.options), Fe(this, nf).data !== void 0 && Nt(this, sh, Fe(this, qr)), $4(r, t)) return;
        Nt(this, to, r);
        const n = ()=>{
            if (!t) return !0;
            const { notifyOnChangeProps: i1 } = this.options, o = typeof i1 == "function" ? i1() : i1;
            if (o === "all" || !o && !Fe(this, uh).size) return !0;
            const a = new Set(o ?? Fe(this, uh));
            return this.options.throwOnError && a.add("error"), Object.keys(Fe(this, to)).some((s)=>{
                const c = s;
                return Fe(this, to)[c] !== t[c] && a.has(c);
            });
        };
        Kr(this, tn, rF).call(this, {
            listeners: n()
        });
    }
    onQueryUpdate() {
        this.updateResult(), this.hasListeners() && Kr(this, tn, n6).call(this);
    }
}, bo = new WeakMap(), qr = new WeakMap(), o1 = new WeakMap(), to = new WeakMap(), nf = new WeakMap(), oh = new WeakMap(), zc = new WeakMap(), Lc = new WeakMap(), a1 = new WeakMap(), ah = new WeakMap(), sh = new WeakMap(), of = new WeakMap(), af = new WeakMap(), Hc = new WeakMap(), uh = new WeakMap(), tn = new WeakSet(), Kp = function(t) {
    Kr(this, tn, a6).call(this);
    let r = Fe(this, qr).fetch(this.options, t);
    return t != null && t.throwOnError || (r = r.catch(wo)), r;
}, e6 = function() {
    Kr(this, tn, i6).call(this);
    const t = Gc(this.options.staleTime, Fe(this, qr));
    if (Of || Fe(this, to).isStale || !G4(t)) return;
    const n = Gj(Fe(this, to).dataUpdatedAt, t) + 1;
    Nt(this, of, setTimeout(()=>{
        Fe(this, to).isStale || this.updateResult();
    }, n));
}, t6 = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(Fe(this, qr)) : this.options.refetchInterval) ?? !1;
}, r6 = function(t) {
    Kr(this, tn, o6).call(this), Nt(this, Hc, t), !(Of || ts(this.options.enabled, Fe(this, qr)) === !1 || !G4(Fe(this, Hc)) || Fe(this, Hc) === 0) && Nt(this, af, setInterval(()=>{
        (this.options.refetchIntervalInBackground || x7.isFocused()) && Kr(this, tn, Kp).call(this);
    }, Fe(this, Hc)));
}, n6 = function() {
    Kr(this, tn, e6).call(this), Kr(this, tn, r6).call(this, Kr(this, tn, t6).call(this));
}, i6 = function() {
    Fe(this, of) && (clearTimeout(Fe(this, of)), Nt(this, of, void 0));
}, o6 = function() {
    Fe(this, af) && (clearInterval(Fe(this, af)), Nt(this, af, void 0));
}, a6 = function() {
    const t = Fe(this, bo).getQueryCache().build(Fe(this, bo), this.options);
    if (t === Fe(this, qr)) return;
    const r = Fe(this, qr);
    Nt(this, qr, t), Nt(this, o1, t.state), this.hasListeners() && (r == null || r.removeObserver(this), t.addObserver(this));
}, rF = function(t) {
    Oi.batch(()=>{
        t.listeners && this.listeners.forEach((r)=>{
            r(Fe(this, to));
        }), Fe(this, bo).getQueryCache().notify({
            query: Fe(this, qr),
            type: "observerResultsUpdated"
        });
    });
}, jB);
function Gve(e, t) {
    return ts(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1);
}
function kB(e, t) {
    return Gve(e, t) || e.state.data !== void 0 && s6(e, t, t.refetchOnMount);
}
function s6(e, t, r) {
    if (ts(t.enabled, e) !== !1 && Gc(t.staleTime, e) !== "static") {
        const n = typeof r == "function" ? r(e) : r;
        return n === "always" || n !== !1 && _7(e, t);
    }
    return !1;
}
function OB(e, t, r, n) {
    return (e !== t || ts(n.enabled, e) === !1) && (!r.suspense || e.state.status !== "error") && _7(e, r);
}
function _7(e, t) {
    return ts(t.enabled, e) !== !1 && e.isStaleByTime(Gc(t.staleTime, e));
}
function Qve(e, t) {
    return !$4(e.getCurrentResult(), t);
}
var $ve = class extends tF {
    constructor(e, t){
        super(e, t);
    }
    bindMethods() {
        super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
    }
    setOptions(e) {
        super.setOptions({
            ...e,
            behavior: E2()
        });
    }
    getOptimisticResult(e) {
        return e.behavior = E2(), super.getOptimisticResult(e);
    }
    fetchNextPage(e) {
        return this.fetch({
            ...e,
            meta: {
                fetchMore: {
                    direction: "forward"
                }
            }
        });
    }
    fetchPreviousPage(e) {
        return this.fetch({
            ...e,
            meta: {
                fetchMore: {
                    direction: "backward"
                }
            }
        });
    }
    createResult(e, t) {
        var S, k;
        const { state: r } = e, n = super.createResult(e, t), { isFetching: i1, isRefetching: o, isError: a, isRefetchError: s } = n, c = (k = (S = r.fetchMeta) == null ? void 0 : S.fetchMore) == null ? void 0 : k.direction, l = a && c === "forward", u = i1 && c === "forward", f = a && c === "backward", h = i1 && c === "backward";
        return {
            ...n,
            fetchNextPage: this.fetchNextPage,
            fetchPreviousPage: this.fetchPreviousPage,
            hasNextPage: qve(t, r.data),
            hasPreviousPage: Vve(t, r.data),
            isFetchNextPageError: l,
            isFetchingNextPage: u,
            isFetchPreviousPageError: f,
            isFetchingPreviousPage: h,
            isRefetchError: s && !l && !f,
            isRefetching: o && !u && !h
        };
    }
}, nF = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](void 0), Zve = (e)=>{
    const t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](nF);
    if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t;
}, Xve = ({ client: e, children: t })=>(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "Xve.useEffect": ()=>(e.mount(), ({
                "Xve.useEffect": ()=>{
                    e.unmount();
                }
            })["Xve.useEffect"])
    }["Xve.useEffect"], [
        e
    ]), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(nF.Provider, {
        value: e,
        children: t
    })), iF = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](!1), Yve = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](iF);
iF.Provider;
function Jve() {
    let e = !1;
    return {
        clearReset: ()=>{
            e = !1;
        },
        reset: ()=>{
            e = !0;
        },
        isReset: ()=>e
    };
}
var e3e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](Jve()), t3e = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](e3e), r3e = (e, t)=>{
    (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1));
}, n3e = (e)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "n3e.useEffect": ()=>{
            e.clearReset();
        }
    }["n3e.useEffect"], [
        e
    ]);
}, i3e = ({ result: e, errorResetBoundary: t, throwOnError: r, query: n, suspense: i1 })=>e.isError && !t.isReset() && !e.isFetching && n && (i1 && e.data === void 0 || Cve(r, [
        e.error,
        n
    ])), o3e = (e)=>{
    if (e.suspense) {
        const t = (n)=>n === "static" ? n : Math.max(n ?? 1e3, 1e3), r = e.staleTime;
        e.staleTime = typeof r == "function" ? (...n)=>t(r(...n)) : t(r), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3));
    }
}, a3e = (e, t)=>e.isLoading && e.isFetching && !t, s3e = (e, t)=>(e == null ? void 0 : e.suspense) && t.isPending, IB = (e, t, r)=>t.fetchOptimistic(e).catch(()=>{
        r.clearReset();
    });
function oF(e, t, r) {
    var f, h, y, S, k;
    if (("TURBOPACK compile-time value", "development") !== "production" && (typeof e != "object" || Array.isArray(e))) throw new Error('Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');
    const n = Yve(), i1 = t3e(), o = Zve(), a = o.defaultQueryOptions(e);
    (h = (f = o.getDefaultOptions().queries) == null ? void 0 : f._experimental_beforeQuery) == null || h.call(f, a), ("TURBOPACK compile-time value", "development") !== "production" && (a.queryFn || console.error(`[${a.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`)), a._optimisticResults = n ? "isRestoring" : "optimistic", o3e(a), r3e(a, i1), n3e(i1);
    const s = !o.getQueryCache().get(a.queryHash), [c] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "oF.useState": ()=>new t(o, a)
    }["oF.useState"]), l = c.getOptimisticResult(a), u = !n && e.subscribed !== !1;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "oF.useSyncExternalStore.useCallback": (P)=>{
            const M = u ? c.subscribe(Oi.batchCalls(P)) : wo;
            return c.updateResult(), M;
        }
    }["oF.useSyncExternalStore.useCallback"], [
        c,
        u
    ]), {
        "oF.useSyncExternalStore": ()=>c.getCurrentResult()
    }["oF.useSyncExternalStore"], {
        "oF.useSyncExternalStore": ()=>c.getCurrentResult()
    }["oF.useSyncExternalStore"]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "oF.useEffect": ()=>{
            c.setOptions(a);
        }
    }["oF.useEffect"], [
        a,
        c
    ]), s3e(a, l)) throw IB(a, c, i1);
    if (i3e({
        result: l,
        errorResetBoundary: i1,
        throwOnError: a.throwOnError,
        query: o.getQueryCache().get(a.queryHash),
        suspense: a.suspense
    })) throw l.error;
    if ((S = (y = o.getDefaultOptions().queries) == null ? void 0 : y._experimental_afterQuery) == null || S.call(y, a, l), a.experimental_prefetchInRender && !Of && a3e(l, n)) {
        const P = s ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
        IB(a, c, i1) : // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
        (k = o.getQueryCache().get(a.queryHash)) == null ? void 0 : k.promise;
        P == null || P.catch(wo).finally(()=>{
            c.updateResult();
        });
    }
    return a.notifyOnChangeProps ? l : c.trackResult(l);
}
function Zb(e, t) {
    return oF(e, tF);
}
function u3e(e, t) {
    return oF(e, $ve);
}
const c3e = new Wve();
function N8e({ config: e, children: t }) {
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])(()=>Ij(), []), n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])(()=>xAe(e), [
        e
    ]), [i1, o] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        n != null && n.network && r.$network.set(n.network);
        const U = new yve(r, n);
        return o(()=>U), U.initialize(), ()=>U.dispose();
    }, [
        n,
        r
    ]);
    const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U)=>await (i1 == null ? void 0 : i1.connect(U)), [
        i1
    ]), s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(()=>i1 == null ? void 0 : i1.disconnect(), [
        i1
    ]), c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async ()=>{
        var U;
        return ((U = await ((i1 == null ? void 0 : i1.getBalance()) ?? di.getBalance())) == null ? void 0 : U.toString()) ?? "";
    }, [
        i1
    ]), l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U)=>await (i1 == null ? void 0 : i1.getMetaBalances(U)) ?? di.getMetaBalances(), [
        i1
    ]), u = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U, Q)=>await (i1 == null ? void 0 : i1.getInscriptions(U, Q)) ?? di.getInscriptions(), [
        i1
    ]), f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(()=>(i1 == null ? void 0 : i1.getNetwork()) ?? di.getNetwork(), [
        i1
    ]), h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async ()=>await (i1 == null ? void 0 : i1.getPublicKey()) ?? di.getPublicKey(), [
        i1
    ]), y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])((U)=>(i1 == null ? void 0 : i1.pushPsbt(U)) ?? di.pushPsbt(), [
        i1
    ]), S = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U, Q)=>{
        let v = {};
        return typeof Q == "string" ? v = {
            toSignAddress: Q
        } : Q && (v = Q), await (i1 == null ? void 0 : i1.signMessage(U, v)) ?? di.signMessage();
    }, [
        i1
    ]), k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async ()=>await (i1 == null ? void 0 : i1.requestAccounts()) ?? di.requestAccounts(), [
        i1
    ]), P = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U, Q)=>await (i1 == null ? void 0 : i1.sendBTC.call(i1, U, Q)) ?? di.sendBTC(), [
        i1
    ]), M = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (...U)=>{
        var v, B;
        if (typeof U[0] == "string") {
            const [g, E, w] = U;
            return await ((v = i1 == null ? void 0 : i1.signPsbt) == null ? void 0 : v.call(i1, g, E ?? !1, w ?? !1)) ?? di.signPsbt();
        }
        const [Q] = U;
        return await ((B = i1 == null ? void 0 : i1.signPsbt) == null ? void 0 : B.call(i1, Q)) ?? di.signPsbt();
    }, [
        i1
    ]), N = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U)=>{
        var Q;
        return await ((Q = i1 == null ? void 0 : i1.signPsbts) == null ? void 0 : Q.call(i1, U)) ?? di.signPsbts();
    }, [
        i1
    ]), z = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U)=>await (i1 == null ? void 0 : i1.switchNetwork.call(i1, U)), [
        i1
    ]), K = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U, Q)=>await (i1 == null ? void 0 : i1.inscribe.call(i1, U, Q)) ?? di.inscribe(), [
        i1
    ]), $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U, Q)=>await (i1 == null ? void 0 : i1.send.call(i1, U, Q)) ?? di.send(), [
        i1
    ]), ne = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U, Q)=>await (i1 == null ? void 0 : i1.sendInscriptions.call(i1, U, Q)) ?? di.sendInscriptions(), [
        i1
    ]), ee = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])(async (U)=>await (i1 == null ? void 0 : i1.dataSourceManager.getAddressUtxos(U)) ?? di.getUtxos(), [
        i1
    ]), q = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])(()=>i1 ? {
            connect: a,
            disconnect: s,
            getBalance: c,
            getMetaBalances: l,
            getInscriptions: u,
            getNetwork: f,
            getPublicKey: h,
            pushPsbt: y,
            signMessage: S,
            requestAccounts: k,
            sendBTC: P,
            signPsbt: M,
            signPsbts: N,
            switchNetwork: z,
            inscribe: K,
            send: $,
            sendInscriptions: ne,
            getUtxos: ee
        } : di, [
        i1,
        a,
        s,
        c,
        u,
        l,
        f,
        h,
        K,
        y,
        k,
        $,
        P,
        ne,
        S,
        M,
        N,
        z,
        ee
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Xve, {
        client: c3e,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Vj.Provider, {
            value: {
                $store: r.$store,
                $network: r.$network,
                client: i1,
                methods: q
            },
            children: t
        })
    });
}
const BB = ({ size: e = 42, variant: t = "first", className: r, ...n })=>t === "first" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "42",
                height: "42",
                rx: "10",
                fill: "#090A0C",
                style: {
                    fill: "#090A0C",
                    fillOpacity: 1
                }
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
                fill: "white",
                style: {
                    fill: "white",
                    fillOpacity: 1
                }
            })
        ]
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "42",
                height: "42",
                rx: "10",
                fill: "white",
                style: {
                    fill: "white",
                    fillOpacity: 1
                }
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
                fill: "#090A0C",
                style: {
                    fill: "#090A0C",
                    fillOpacity: 1
                }
            })
        ]
    }), l3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>t === "first" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        width: e,
        height: e,
        viewBox: "0 0 128 128",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "128",
                height: "128",
                rx: "26.8387",
                fill: "#12100F"
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M74.9171 52.7114C82.4766 51.5408 93.4087 43.5804 93.4087 37.3761C93.4087 35.5031 91.8968 34.2154 89.6871 34.2154C85.5004 34.2154 78.4061 40.5368 74.9171 52.7114ZM39.911 83.4991C30.0256 83.4991 29.2115 93.3324 39.0969 93.3324C43.5163 93.3324 48.8661 91.5764 51.6573 88.4157C47.5868 84.9038 44.2141 83.4991 39.911 83.4991ZM102.829 79.2848C103.41 95.7907 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.0249C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8463 40.0273 72.8463C45.3771 72.8463 49.9128 74.2511 55.7277 77.88L59.5656 64.4177C43.7489 60.0864 35.8405 47.9118 43.6326 30.4693H56.1929C49.215 42.0586 53.9832 51.6578 62.822 52.7114C67.5903 35.7372 77.8246 22.509 91.4316 22.509C99.1074 22.509 105.155 27.5428 105.155 36.6737C105.155 51.3066 86.0819 63.2471 71.6607 64.4177L65.7295 85.3721C72.4748 93.2153 91.199 100.824 91.199 79.2848H102.829Z",
                fill: "#F5F1ED"
            })
        ]
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        width: e,
        height: e,
        viewBox: "0 0 128 128",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "128",
                height: "128",
                rx: "26.8387",
                fill: "#F5F1ED"
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M74.9171 52.7115C82.4766 51.5409 93.4087 43.5806 93.4087 37.3762C93.4087 35.5032 91.8968 34.2155 89.6871 34.2155C85.5004 34.2155 78.4061 40.5369 74.9171 52.7115ZM39.911 83.4992C30.0256 83.4992 29.2115 93.3325 39.0969 93.3325C43.5163 93.3325 48.8661 91.5766 51.6573 88.4159C47.5868 84.904 44.2141 83.4992 39.911 83.4992ZM102.829 79.2849C103.41 95.7908 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.025C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8464 40.0273 72.8464C45.3771 72.8464 49.9128 74.2512 55.7277 77.8801L59.5656 64.4179C43.7489 60.0865 35.8405 47.9119 43.6326 30.4695H56.1929C49.215 42.0587 53.9832 51.6579 62.822 52.7115C67.5903 35.7373 77.8246 22.5092 91.4316 22.5092C99.1074 22.5092 105.155 27.5429 105.155 36.6738C105.155 51.3068 86.0819 63.2472 71.6607 64.4179L65.7295 85.3722C72.4748 93.2155 91.199 100.825 91.199 79.2849H102.829Z",
                fill: "#12100F"
            })
        ]
    }), f3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>t === "first" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#a)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#AB9FF2",
                        d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#FFFDF8",
                        fillRule: "evenodd",
                        d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
                        clipRule: "evenodd"
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("defs", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                    id: "a",
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#fff",
                        d: "M0 0h42v42H0z"
                    })
                })
            })
        ]
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#a)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#FFFDF8",
                        d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#AB9FF2",
                        fillRule: "evenodd",
                        d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
                        clipRule: "evenodd"
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("defs", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                    id: "a",
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#fff",
                        d: "M0 0h42v42H0z"
                    })
                })
            })
        ]
    }), d3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#clip0_3_53)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "M32 0H10C4.47715 0 0 4.47715 0 10V32C0 37.5228 4.47715 42 10 42H32C37.5228 42 42 37.5228 42 32V10C42 4.47715 37.5228 0 32 0Z",
                        fill: "#181818"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "M32 31.6745V27.6829C32 27.5233 31.9203 27.3636 31.8406 27.2438L14.8225 10.1597C14.7029 10.0399 14.5435 10 14.3841 10H10.3986C10.1993 10 10.0399 10.1597 10.0399 10.3592V14.0715C10.0399 14.2311 10.1196 14.3908 10.1993 14.5105L16.2971 20.6177C16.4565 20.7774 16.4565 20.977 16.2971 21.1366L10.1196 27.3237C10.0399 27.4035 10 27.4834 10 27.5632V31.6346C10 31.8342 10.1594 31.9939 10.3587 31.9939H17.0544C17.2536 31.9939 17.413 31.8342 17.413 31.6346V29.2396C17.413 29.1598 17.4529 29.0401 17.5326 29.0002L20.8406 25.6871C21 25.5275 21.1993 25.5275 21.3587 25.6871L27.4964 31.8342C27.6159 31.954 27.7753 31.9939 27.9348 31.9939H31.6413C31.8406 32.0337 32 31.8741 32 31.6745Z",
                        fill: "white"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "M23.3406 15.0793H26.5592C26.7507 15.0793 26.9039 15.2333 26.9039 15.4257V18.658C26.9039 18.9658 27.2871 19.1197 27.4788 18.8888L31.8851 14.4637C31.9617 14.3867 32 14.3097 32 14.2328V10.3463C32 10.1539 31.8468 10 31.6552 10H27.7469C27.6703 10 27.5554 10.0385 27.5171 10.1154L23.1107 14.5021C22.8808 14.6945 23.0341 15.0793 23.3406 15.0793Z",
                        fill: "#EE7A30"
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("defs", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                    id: "clip0_3_53",
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                        width: "42",
                        height: "42",
                        fill: "white"
                    })
                })
            })
        ]
    }), h3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        id: "Layer_2",
        "data-name": "Layer 2",
        className: r,
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        viewBox: "0 0 115.77 147.7",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("linearGradient", {
                        id: "__5",
                        x1: "3379.03",
                        x2: "3415.48",
                        y1: "-2102",
                        y2: "-2198.11",
                        "data-name": " 5",
                        gradientTransform: "rotate(-134.73 2187.667 -353.427)",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0",
                                stopColor: "#201c1b"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.36",
                                stopColor: "#77390d"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.67",
                                stopColor: "#ea8101"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "1",
                                stopColor: "#f4b852"
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("linearGradient", {
                        id: "__4",
                        x1: "3384.23",
                        x2: "3330.64",
                        y1: "-2231.42",
                        y2: "-2131.29",
                        "data-name": " 4",
                        gradientTransform: "rotate(-134.73 2187.667 -353.427)",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0",
                                stopColor: "#1f1d1c"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.37",
                                stopColor: "#77390d"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.67",
                                stopColor: "#ea8101"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "1",
                                stopColor: "#f4fb52"
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("radialGradient", {
                        id: "__6",
                        cx: "53.01",
                        cy: "45.84",
                        r: "11.13",
                        "data-name": " 6",
                        fx: "53.01",
                        fy: "45.84",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0",
                                stopColor: "#f4b852"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.33",
                                stopColor: "#ea8101"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.64",
                                stopColor: "#77390d"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "1",
                                stopColor: "#211c1d"
                            })
                        ]
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                id: "__1-2",
                "data-name": " 1",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#__5)",
                        d: "m81.66 13.29 30.31 30.02c2.58 2.55 3.85 5.13 3.81 7.73s-1.15 4.97-3.32 7.12c-2.27 2.25-4.72 3.39-7.34 3.44-2.62.04-5.22-1.22-7.8-3.77l-31-30.7c-3.52-3.49-6.92-5.96-10.19-7.41s-6.71-1.68-10.31-.68c-3.61.99-7.48 3.54-11.63 7.64-5.72 5.67-8.45 10.99-8.17 15.96s3.12 10.13 8.51 15.46l31.25 30.96c2.61 2.58 3.89 5.16 3.85 7.72-.04 2.57-1.16 4.94-3.37 7.13-2.2 2.18-4.63 3.32-7.27 3.41s-5.27-1.16-7.87-3.74L20.81 73.56q-7.395-7.32-10.68-13.86c-2.19-4.36-3.01-9.29-2.44-14.79.51-4.71 2.02-9.27 4.54-13.69 2.51-4.42 6.11-8.94 10.78-13.57 5.56-5.51 10.87-9.73 15.93-12.67C43.99 2.04 48.88.41 53.6.07c4.73-.34 9.39.6 14 2.82s9.29 5.68 14.05 10.4Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#__4)",
                        d: "M34.11 134.42 3.81 104.4C1.23 101.84-.04 99.27 0 96.67s1.15-4.97 3.32-7.12c2.27-2.25 4.72-3.39 7.34-3.44 2.62-.04 5.22 1.21 7.8 3.77l30.99 30.7c3.53 3.49 6.92 5.96 10.19 7.41s6.71 1.67 10.32.68 7.48-3.54 11.63-7.65c5.72-5.67 8.45-10.99 8.17-15.96s-3.12-10.13-8.51-15.47L64.6 73.24c-2.61-2.58-3.89-5.16-3.85-7.72.04-2.57 1.16-4.94 3.37-7.13 2.2-2.18 4.63-3.32 7.27-3.41s5.27 1.16 7.87 3.74l15.7 15.41q7.395 7.32 10.68 13.86c2.19 4.36 3.01 9.29 2.44 14.79-.51 4.71-2.02 9.27-4.54 13.69-2.51 4.42-6.11 8.94-10.78 13.57-5.56 5.51-10.87 9.73-15.93 12.67s-9.95 4.58-14.68 4.92-9.39-.6-14-2.82-9.29-5.68-14.05-10.4Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("circle", {
                        cx: "53.01",
                        cy: "45.83",
                        r: "11.13",
                        fill: "url(#__6)"
                    })
                ]
            })
        ]
    }), p3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#a)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#000",
                        d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                        fillRule: "evenodd",
                        clipPath: "url(#b)",
                        clipRule: "evenodd",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                                fill: "#FFD815",
                                d: "m26.507 17.74-1.623-1.623-1.624 1.623 1.623 1.623 1.624 1.624 1.623-1.624-1.623-1.623Z"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                                fill: "#FF9813",
                                d: "m26.507 8-1.624 1.623 1.624 1.624 1.623-1.624L26.507 8ZM33 14.493l-1.623-1.623-1.624 1.623 1.624 1.623L33 14.493ZM23.26 27.48l1.623 1.623 1.624-1.623-1.623-1.624-1.624 1.624ZM11.897 16.117l1.623 1.623 1.623-1.623-1.623-1.624-1.623 1.624ZM20.014 8 18.39 9.623l1.624 1.624 1.623-1.624L20.014 8ZM13.52 11.247l1.624 1.623 1.623-1.623-1.623-1.624-1.624 1.624ZM31.377 19.363l-1.624 1.623 1.624 1.624L33 20.987l-1.623-1.624ZM28.13 25.856l1.623 1.624 1.624-1.624-1.624-1.623-1.623 1.623Z"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                                fill: "#5B5B72",
                                d: "m26.507 20.986-1.624-1.623-1.623 1.623-1.623-1.623-1.623-1.623 1.623-1.624-1.623-1.623-1.624-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623 1.623-.812-.811-1.623 1.623 1.623 1.623-1.623 1.624-1.543 1.542-1.542 1.543-1.624 1.623L8 31.377 9.623 33l1.624-1.623 1.623-1.624 1.543-1.542.08-.08 1.462-1.463.08-.08 1.544-1.543 1.623 1.623 1.623-1.623-.811-.812 1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                                fill: "#FF9813",
                                d: "m26.507 14.493-1.624-1.623-1.623 1.623-1.623-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623 1.623 1.623 1.623-1.623-1.623-1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
                            })
                        ]
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "a",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            fill: "#fff",
                            d: "M0 0h42v42H0z"
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "b",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            fill: "#fff",
                            d: "M8 8h25v25H8z"
                        })
                    })
                ]
            })
        ]
    }), g3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        className: r,
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        fill: "none",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#a)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#000",
                        d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                        fill: "#fff",
                        clipPath: "url(#b)",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            d: "M24.578 17.052h-6.787a.523.523 0 0 0-.52.52v6.788c0 .286.235.52.52.52h6.787c.286 0 .521-.234.521-.52v-6.787a.523.523 0 0 0-.52-.521ZM16.733 9.223H9.946a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.285 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM32.424 9.223h-6.787a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.286 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM16.733 24.898H9.946a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.285 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52ZM32.424 24.898h-6.787a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.286 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52Z"
                        })
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "a",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            fill: "#fff",
                            d: "M0 0h42v42H0z"
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "b",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            fill: "#fff",
                            d: "M0 0h42v42H0z"
                        })
                    })
                ]
            })
        ]
    }), y3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        className: r,
        viewBox: "0 0 42 42",
        fill: "none",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#clip0_17_93)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#070C34",
                        d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#paint0_linear_17_93)",
                        d: "m27.666 16.837 1.874 2.177c.215.245.404.446.483.562.56.55.874 1.293.874 2.07-.053.915-.657 1.54-1.213 2.205l-1.311 1.521-.685.79a.184.184 0 0 0 .046.281c.033.02.07.028.107.026h6.835c1.045 0 2.36.868 2.283 2.184 0 .597-.247 1.171-.68 1.595a2.36 2.36 0 0 1-1.637.664H23.936c-.704 0-2.598.076-3.128-1.521a1.841 1.841 0 0 1-.043-1.035 4.5 4.5 0 0 1 .72-1.404 65.543 65.543 0 0 1 1.695-2.343c.741-1.002 1.503-1.971 2.251-2.992a.19.19 0 0 0 .04-.116.19.19 0 0 0-.04-.116l-2.72-3.156a.192.192 0 0 0-.153-.073.192.192 0 0 0-.152.073c-.728.96-3.917 5.203-4.598 6.063-.68.86-2.355.907-3.283 0l-4.255-4.161a.197.197 0 0 0-.1-.053.195.195 0 0 0-.2.082.192.192 0 0 0-.032.106v8a2.678 2.678 0 0 1-.494 1.594c-.33.466-.804.823-1.352 1.014a2.375 2.375 0 0 1-2.111-.293 2.271 2.271 0 0 1-.72-.805A2.22 2.22 0 0 1 5 28.736V14.349a2.416 2.416 0 0 1 .548-1.422c.33-.406.785-.7 1.298-.841a2.632 2.632 0 0 1 2.502.664l6.54 6.381c.019.02.043.034.07.043a.197.197 0 0 0 .161-.013.188.188 0 0 0 .061-.054l4.646-6.27c.215-.254.485-.46.79-.601.304-.142.636-.217.976-.221H34.68c.33 0 .657.07.959.204a2.31 2.31 0 0 1 1.263 1.409c.096.309.122.633.079.952a2.288 2.288 0 0 1-.813 1.42c-.439.364-.996.56-1.572.551h-6.768a.188.188 0 0 0-.163.099.187.187 0 0 0-.022.095c0 .032.013.065.032.093h-.008Z"
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("linearGradient", {
                        id: "paint0_linear_17_93",
                        x1: "-0.315",
                        x2: "35.366",
                        y1: "9.343",
                        y2: "30.176",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.23",
                                stopColor: "#FF0074"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.26",
                                stopColor: "#FF0068"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.32",
                                stopColor: "#FF0048"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.39",
                                stopColor: "#FF0015"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.41",
                                stopColor: "#FF0009"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.43",
                                stopColor: "#FF0908"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.54",
                                stopColor: "#FF4003"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.62",
                                stopColor: "#FF6201"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.66",
                                stopColor: "#FF6F00"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.72",
                                stopColor: "#FF8700"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.83",
                                stopColor: "#FFAB00"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.92",
                                stopColor: "#FFC100"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: "0.98",
                                stopColor: "#FFCA00"
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "clip0_17_93",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            fill: "#fff",
                            d: "M0 0h42v42H0z"
                        })
                    })
                ]
            })
        ]
    }), m3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        width: e,
        height: e,
        viewBox: "0 0 42 42",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "clip1",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 "
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("radialGradient", {
                        id: "radial0",
                        gradientUnits: "userSpaceOnUse",
                        cx: 0,
                        cy: 0,
                        fx: 0,
                        fy: 0,
                        r: 1,
                        gradientTransform: "matrix(0.000000000000001938,31.643555,-31.643555,0.000000000000001938,21,5.578125)",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: 0,
                                style: {
                                    stopColor: "rgb(5.098039%,5.490196%,7.058824%)",
                                    stopOpacity: 1
                                }
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: 1,
                                style: {
                                    stopColor: "rgb(0%,0%,0%)",
                                    stopOpacity: 1
                                }
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image91",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAIOUlEQVRYhe2YW4jcVx3HP+fyv8785z+XveUm040xaWraitaHFmkfpKCI6LMgLWq9IUUpiA9CwRdfiqBPtbbWy5MKhRbxnuZFRUSMxhBr2nR6Sdrd2ezOzs7szP9yzvFhdus2TEzWJD7l+zQw53/Oh+/vcjg/uKmbuqmbuqlrkbhB+8o2+CFUUoj6EEWgAQ/Ah2IMpQcbS5C9CkMg/3+Cyjb4GpIE4gLSCsROkyKJLCilAEHpWwbS0M8LNvrQG0KvAxngbiTo2wBzaISahpGknqTxxGE1RLoPSCkWcIwN7p9hYX/54Asc0YKLOuPNElYL6P0J+jcCVLQhKCFOoQo0Ak3NSGaUZPbJI2qolXvECXHnlG83TemeeOxf9jcvlXh+zvk+LC9B9wJsXk9Qrw2VBsQWGnriYAvJ7FOH6ChfPSIE91/pDGF57tNnzO8Cy8tRxusZLGdw8Y8wulZQeRgqGioGalWol4pZJ5n77iKnKon6jIVPAuHVbmgL99jDZ+252PCyzni1AW8uwvBRGL916G4A2xC+E1oRtBTsjTW3FB6HF2PUj2+TrShRz1p4aDeQANITn/pWmxdKzXwY0ahCDISnwd9eo69iH9HeysPKVh4qTVNK5oxg9odH1UUh3TecELfvBu4S1YUv3++UHStHWvjUKj7ZiQHl821k0sJcCVQuQpJCRUBqoYnPjJPMf+8Q5zxfPegE94O45u4h4BCWV0pN4kHse4RH6+TeALHBf3fU2w+JDzULc2I7D2/hVCVRH7aObztBcK2Ab4EKAqEIlCASkghDMLJ4PeBjUFwO1HsHVJtQk7BgfPYeDBl//aDcJ6X4poW5631VGMuKAO05VAAq9FAzErWi4LfruKmg+0HLSagXrE/7+0c47/nqMeCu64s3kXMUFPaMZ2kriUsDpK/xuhnBLGSHUsTUqs8gDaFlFXuevJVz2lc/uFGQAM7y+6+8xj2BoKhpjK9xkUMuhojcw39hk2AqaAoVH1KjWQi0+pqAW24UJM69bo15JpYM6ophYskrAtP0EP0YX1nkYnwZR0tIjKLxs8P8A8FHbhikdWeKsf3OV1/mfVXJeiLpJyGjhocFSD1EWIdzGj01R32olpJ6oeSt8up67a7kHD1n3XOPv277ZzPuqCuWZwQrDUV/XrM5F5LrEreaIRohbHqoqRAStIVQKnHg+hKSO2uP58Yd//JL3BspaGi6s4qlpsdaXdGvK8ZNR+4iysEIt33FTQV1IAVojSvK69OHnLXur6a0z37hJe6OFXc1PN6oC1Ybkm7dY63hc3HWsZEKRmODnSsxmcD1AJddpj0BTkgsjrPXymmte8VYnvn8WXssktzRUlxINOtVyWoq6DV91usevaZjY49g5DvyekzZHeH2B+QXMhziMo7mYHxLMSrsSc9T6wjSXRM61p11P3/8Nds/NeJgy+N8LOinirUU1hKf/oxgPQgYzVoGM5KRceR7fcbnR7h9AdmFDOfJSWFN9esgvNdTvKsQvPund8hEC/GlXQDmztrj49I9//A57qsq1iqKfl2ylkCv7rOeKjbSkEHdMYgtxYJi2DeYGUeWCdzMDsh2SNEdgpp2VgqpllSlJPzbqjv/waasIK/YSx2WvxSlefJzL3LgxDozDc1KU9KdlSzNKJZnQ7rzMavzgn7VMJqHYaoZeZBXLIWRGOnIhxa7GJMXGbZbQCZwU0FjiJRDe4JwxdL+eOCekr6QUoojTEsX614sS55+6KxNjq9TTxUXm5qVumKppVieDViZ16w0fQZzJcMFGLY8htKjqOdkQzCxIyvAlAo7YykubAFmY+xRTT419A1IF2DOwn5f0baKtpXs/dERfq2Q9wopDipBaKy9WFpx5osv2veEgmGsGMSCjZpmvQ69xKdfE6zXAsbzgmFLMKpCtiGxiaUsS8y+kHFnDEphZg1FF7ACl4+wx0KKHtDpXCZH2xCOoNaA+QjmpWKfUewVihaCVAgCZVFK4gJJEQpGFcFmRdBvSjZqIesVwaAZMW5YhrGjmFcMNkpsVVEGhtJITGgphhLbsuTbgGYTl4wpjMD1etADhmCnVn0HsvugfxrkASi1wcSKgRDMCEcqJaH2UNpCJCgriix1jFKPfkMxjAKyBclAG0wDxqEm146iBWbksB7kpcO1KmR2CF2gGGG3AZfWcUvgMnAJuHugvGyXdCCOQLU+eb/Uqh71miIpJUkoCYXDqypcoBBVQdHyGDcjxg1N5hlMXTD2FIUwmKqlGEnsnE/+5iVh3gm40ns74F1QdoBT4K7UzsV9UGmDthE1rYlSjR8pvMwQxwEqFbhEYGcEpe9jW4rCCRyWMjGUmcDtD8gul4cHxhSdHnTBbYDdBjwBbOyYmlzVvfMohBF4pkqofIKaRYceXsUhIx9RGHTFh5ai9H3IczBbDo7HMJTYd0Tk3eFkyFSMsEcj8k4POr1JDvpgpwGubv2+6gvyNPjLILsQHAKxXMXfHyHXSvy4jhAjRBhOkj9k8iBXCgMwrZpPdiZrV8Fsu/jcFMBdOfoW7G348RD59w6eraOCEM8ZVJvJW7pSgXMZej6gXMrQSUkJb3dxu910JyBmZx5eCrlnt6HfqZ/chj88jXygDb/o4++xyDvr8Ac1GRYoO9lTOoQVk4N29sSTnUmoE3C3Q3GC/4R6p4vbkJ+FAnY3KQFgMcS9AvbpDnyoRv6GxJ7swdGE/O6EPFdYI3GFwuYj7GFHdiycFMyfO7gh2E9AXtuCnKZLIeF/HJI9Dl4G8hiIB9rwqwHeG1VUfev/+iXrOz0oBW5zDftRKDrANuSlbk6DBPg3vtO3svqbCX0AAAAASUVORK5CYII="
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("filter", {
                        id: "alpha",
                        filterUnits: "objectBoundingBox",
                        x: "0%",
                        y: "0%",
                        width: "100%",
                        height: "100%",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("feColorMatrix", {
                            type: "matrix",
                            in: "SourceGraphic",
                            values: "0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image170",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACtklEQVRYhWNgGAWjYBSMglEwCkYcmGslLagZ26TedkTUMOD/H11nY2a5Sb+/sJBiBiOtHMfAwMCg73JCaNrNdN2kh/eF0eXKFXf+qZBhvfbqqMkdYsxior7zGBjUK65yXtwsbBq4/7wDNkcyMDAwdN53ZxE87KQX4tNtRIyZVA1Rc3M7ZpZn5eoNd1lVc1hCmInVJ7ov4fwRl0n38amhWoiyP3kmPbfVyfXNw0gNUhzJwMDA8D/3q1bnt2a8bqE4RFPWPhRMLPDTwxXFxIKtN84cUdFSe4VLnuwQhaVDmbBtjpQ6koGBgWHPo6d8+ORJKiIYGBDp0CgsQTXM4Dczw+9y8l2HBB4kJFEv6p2NmeVYi1m170ewcVLmLEzw6HHhye/yjU9xyRMV9XaXNnLcmHTA9slpbhNaONLtgvpfZV5TnOmTgYGIEP3LGciWdPSB/QmDu7zUcxoquNv66c6fWoZL+NQQDNFwZysdWjpS8mnzhzsL664RUoc3M9ld2sixVWiFvBz13IUC2HjqXtzv4z+jcCf/DyG1eKOeb66bnGTiCRPqOQ0Ccpjzvq3gTr5y9IviE2L14I163YZ8HsqdhQDP3hn9vf8m5tq3r+y7SHEkAwOBqH/ncPYvZU6DgEjWToYZ/8UefWbsusrwd9p3ckpevCEqdNL9E5lug4N58opvn6zy2v/iX/AZhr8nv5NrDl6H7vx0/ZXyhqBf5BisuOLXdxnTr2esH188OCdY/j15zkMAguUoX8haFclViXrEGvjsndHfn/+0bjbzSN4q56r9R5nzEICoKlQvzsrk54IreEspWDp8wdh1lZIoxgWIrusrJBTVpl6R15QSOofR1qzc+eH1kW+Pr1AjiqkCJv3+wuJszCwnwaeq23ZE1JC9Q0ktq+09/0C7axSMglEwCkbBKKA/AABq8ekilgplTAAAAABJRU5ErkJggg=="
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("mask", {
                        id: "mask0",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                            filter: "url(#alpha)",
                            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image170"
                            })
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image125",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEF0lEQVRYhe2WTYscVRSGn3NvVXdPzySabwQN2SlGkQgjCC4EFWMU/A+CG925EhN0JSiof8BtxC8SSVZZiK7MRjRElPwEF8Ik0z3d9XXPOS6qJhM1pHucGXHRLxRFN9Sth/d977kFCy200EILLfR/kvwXL/n69NFvs6Y56MmGjUIlsU55TK9998eT866xp6DfvHTkcm9Snop1epBkqDuNQulCHWNT9Xq/s5FOv/7rxo1Za2V7AXjhzLEv+pPy5ODm+KSoSlQDdZI5GCQVCtdcKzuuw/5V4MCsNXfV0S9feeD8YKM4vlKVq5J0kJsR3Ajq4JAcygSjBOMkbEhEl3Ky+5dGb/6wdt+91t41Ry8+f+jS8tr6M3nTHNwEjO5EBxdwQFwIAcBxcxSjqY1Q6vKs9XcMevHMka+WxtPV/mh8IqiSWwcISJdXCIFkYIB5+5/jaHJSdIJa3DPQCy8f+3w4nj7auzl6PDYq0YzMncwcCYBDkIAByaAxaBxq2/pdG6iC2ez3bRv0dg/X1p8KSfu5GcGMgBMFEBAEFyG1ewg1qB3qBJVCqU6lLbDOCbEt0AvPHbyyf219Nd7Rw+BOJrQOGnjnYrfRW/e8A0zOVJ0iQaFQK7hu1WHHoJ+9ePTKynjy8HC0cSIzpff3HhpICLc7qNbu8Mah0TbmonEKc6YJxg1MGiikBWiH1g5Bz79w7Pul9Y3Hsro+nJkykLv38E4HN11sNmO21sVJgo0E0wSlQQpCiELMg+4Y1CfFQxTN4dyULBhBWhfv1sOmm5W1Qp2c0pxSaSEVyqaNfCqCBSH2I/kg03wQZ87ze4J++uzhn8NocsJUMTcQcAOTgPtfY07eRlwlpzYo7ujitLuXBjWCx0DWjwxX8rRvf+5vXV3r7Qg01WlfXVmM6m2sgAQB6SB9K+5aodqMWWHadIDWXgnBsoDkgf4g08Ew0+u/jT++DO/MgpwJqrUNK3OkcfIAwQR1QLbibiHbmKvOvYlCqVAZ1CZoDHge6PWi5ctZWh5mcvanW/15AOcCTU5UBVOQbozkAuCdm23MlbbRFtqe5UWCMggmAoNA7EUfLGVpaZhx7tr6tgDnArUQaFyoVUjm1Or0usPuzsgLawHL7rSpRPAQyHqRwXKWloaZvXt99K8A5wINecg0hFQgWZmEQpzYQOiiT9qC1d7GnOSfPfzlxviDS8Z7O4GEOT7z3n9i/6hcr/bV0wZJRugect8aRykIEgOSBXr9aPnwdg9n7uZdA3018MapR1Y+KTaaflMlUmrnknePexQkD/Ty6P1hloZLkXPX1ncNcG5QgI+ePlSMxrVURerVlYl3oCEIsRfo92MaDqKf3QPAbYFu6sPVA1XdKEk9OEgWxXt54O0fb+V7BbjQQgsttNBC/0/9CbvrotNPsOneAAAAAElFTkSuQmCC"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image142",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAAmklEQVRYhe2U0QqAIBAE1/7/n+tFIaQyur21aAdEX4RhDgWMMemUul7BkciZ3JopMqKXGhWcJltOzldMkS3dfhe5bOTBSGWXwF3pjxARBYSyUVFAJMsQBQSyLNF0mKKpVdlF02R/OfpGStWsonTZX4++Qa3qohVaVRfdQanqoh3hqi7KRikaGr+LslGLPh6/i7KxKBuLsvmM6AZK+AVU/UCtAQAAAABJRU5ErkJggg=="
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("mask", {
                        id: "mask1",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                            filter: "url(#alpha)",
                            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                                x: 0,
                                y: 0,
                                width: 42,
                                height: 42,
                                style: {
                                    fill: "rgb(0%,0%,0%)",
                                    fillOpacity: 0.6,
                                    stroke: "none"
                                }
                            })
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image148",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEI0lEQVRYhe3XTW4kuREF4I9kZqX+7B61gAFGR5CWPsucZ9zn6Sv4Ct5ZfQAv1IABuaftaUlVmWR4kZS6tPKitBjDegCRZBaT9RA/Lxi84Q1veMMbDkF6msTTPPChz28kP+NTX99+3/+MSwGuhI+47utfhETS169BNEgvCF5JPkluJZeSO8lF/+3rHtl3ncSdcCHcCpfCjXAtXpPs8ILkjeRa8kVyJ7uUkE0SknvJuz2idzgWJg3hUkNzLlxpPiBEJOlQsilI/txJnu+RI7tXJPl5TJKtZJaMwiRshdCE5lhF8141aT4LNL+IlA4jml+QnGRfFQwejE6Mso1qMplwpDl2tj6POTKZVJNs49GIwd8NPituJVfSc0gdgAFcd9d+lb1T/GpwrPhmlAyKwaKoiiy7lxTxsNX626paDDJmZ9At/hd80Q4lmt30pCErsgdFMUg2Tm1kR5IjyYlwKpwa+zOcSk40xzbdst9sMLhXDD2Ufj6UJsOe/GRniq3BHwxmG4uNbFKMFhvJICua1L+omA3mHsfJpsflieY3zZ32LG8HEf0keS/5Z0+gSTEbVWNfTZpJ6cRDUSRNqKowS7bmrh5VM/dwyKqLZ48dSPR2T3pWCsXOIPdEaibVUSe9urVKslAsmkHuKlBVG7MHA93Kt3KXrQOJ/gnfJA/dootiUIRBMqg2hp75q2WH7vjAIssDbVlUYbE1SP2cU0k93Jor0c/doqw2mCRNlrtMMQijbBRGYUDWRElSJRYWydzTsXhUjJLHfu7d4WTz8+xYspEsUo/B78KvOzo6kbyGSE2KppT9fbV/v3StuH8di+b/vuX3ge9EH4SdMAhVyF1mnsYabVXrI9QSa2bX/X2lfz8Ij8LJ69yesp+EP/bDRmHutbuqWDzFXzMXdpoZO9murlV/HWHp9WmVplk46udevMLtyV+td8roFhlUO1W2CItit+a2VJNQ1C74a9aHnWRnsFN7mZi79R+Ef4leUg8keim8F/4h/KiiShbVjNKTg6RZVHlP8Jsqm4WtpRN+tGiq0ndcam5fw6JXwifhx27RrWoy00siqxgtandz2RP8JptVs9HWbKeYHVlQewmN5y7gIKIfcd4vvb+piuTfXU/HnhBh0SxjUebaLVp7smXLJsy7MCt2dmajxb2qai6Eq9cguvY4659WyZnqV0kI30SX/8Fonmu/SDdPJaIJdRe95ofFqRmLE9Vd99LHQ2k+ydNN73cWzVfVD6sFLXaKrerR4MHkXnP/4jl4UD0abTU7T0qxhlF77p8OxP9QK8La2l6LfhNvflLdqU7Mjs0WO5Ote1uTrTOPJlt3/f1i57i7nMXfNOf9rN6JHoohWbtEIXwA4Vzq7W9yqdlKziQnXrbLT0K+Fc722uUvXUleubd/wxve8IY3/B/gP+5/MI8x65+AAAAAAElFTkSuQmCC"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("mask", {
                        id: "mask2",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                            filter: "url(#alpha)",
                            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                                x: 0,
                                y: 0,
                                width: 42,
                                height: 42,
                                style: {
                                    fill: "rgb(0%,0%,0%)",
                                    fillOpacity: 0.701961,
                                    stroke: "none"
                                }
                            })
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image154",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAA/ElEQVRYhe2VwW7DIAxAn9M0qcSN///G3JDaFEIPwRvqoUHdWKXJT/IhMokeNiZgGIZhGIZh/EPkVTLnLGWNxvD0Ti6xAVlEtk6eDA1rBDgBZ2ACZu/9DMzleSz5lm+9zVFFh0pyrELYK5m89/dlWSIQRWT9lOipiE1VnCvRCKwaInLtJXrULj2Xdesn4EJpvXPuT1o/NqxR2Vp4YB+gLYSgki+781PeqUL+dYsGWkT1+tmAxH4uNZJzLpVc1w0ctV4lE3Dne4i+himEEEu+2x0KxxV9Fr0B1ypu3vuVvbpdRVv+TDpEGvXmdBMJ2EQkdvI0DMMwDMMwjI/yAInrT4nWGUiJAAAAAElFTkSuQmCC"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image160",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("mask", {
                        id: "mask3",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                            filter: "url(#alpha)",
                            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                                x: 0,
                                y: 0,
                                width: 42,
                                height: 42,
                                style: {
                                    fill: "rgb(0%,0%,0%)",
                                    fillOpacity: 0.2,
                                    stroke: "none"
                                }
                            })
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        id: "image166",
                        width: 42,
                        height: 42,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "clip2",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                            x: 0,
                            y: 0,
                            width: 42,
                            height: 42
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                        id: "surface169",
                        clipPath: "url(#clip2)",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image125"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image142"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image148",
                                mask: "url(#mask1)"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image154",
                                mask: "url(#mask2)"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image160"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                                xlinkHref: "#image166",
                                mask: "url(#mask3)"
                            })
                        ]
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                id: "surface1",
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                    clipPath: "url(#clip1)",
                    clipRule: "nonzero",
                    children: [
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            style: {
                                stroke: "none",
                                fillRule: "nonzero",
                                fill: "url(#radial0)"
                            },
                            d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 "
                        }),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                            xlinkHref: "#image42"
                        }),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                            xlinkHref: "#image91"
                        }),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("use", {
                            xlinkHref: "#surface169",
                            mask: "url(#mask0)"
                        })
                    ]
                })
            })
        ]
    }), b3e = [
    {
        transform: "translate(40.2375 0.627991) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.627991)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(63.9086 32.1895) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 16.4087) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4087)",
        fill: "#FFF065"
    },
    {
        transform: "translate(32.3471 16.4087) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4087)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(32.3471 32.1895) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(48.1278 32.1895) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(48.1278 16.4087) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4087)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(48.1278 32.1895) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 32.1895) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.1895)",
        fill: "#FFF065"
    },
    {
        transform: "translate(32.3471 32.1895) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 40.0798) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.0798)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(24.4567 32.1895) rotate(-180)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.1895)",
        fill: "#FFF065"
    },
    {
        transform: "translate(40.2375 47.9702) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.9702)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(16.5664 32.1895) rotate(-180)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.1895)",
        fill: "#FFF065"
    },
    {
        transform: "translate(8.67601 32.1895) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 8.51831) rotate(90)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.51831)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(56.0182 32.1895) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.1895)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 24.2991) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.2991)",
        fill: "#FFF065"
    }
], w3e = [
    {
        transform: "translate(40.2375 0.232574) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.232574)",
        fill: "#00E45D"
    },
    {
        transform: "translate(63.9086 31.794) rotate(-180)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.794)",
        fill: "#00E45D"
    },
    {
        transform: "translate(40.2375 16.0133) rotate(90)",
        fill: "#8AFF76"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.0133)",
        fill: "#8AFF76"
    },
    {
        transform: "translate(32.3471 16.0133) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.0133)",
        fill: "#00E45D"
    },
    {
        transform: "translate(32.3471 31.794) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.794)",
        fill: "#00E45D"
    },
    {
        transform: "translate(48.1278 31.794) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.794)",
        fill: "#00E45D"
    },
    {
        transform: "translate(48.1278 16.0133) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.0133)",
        fill: "#00E45D"
    },
    {
        transform: "translate(48.1278 31.794) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.794)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 31.794) rotate(90)",
        fill: "#8AFF76"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.794)",
        fill: "#8AFF76"
    },
    {
        transform: "translate(32.3471 31.794) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.794)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 39.6844) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6844)",
        fill: "#00E45D"
    },
    {
        transform: "translate(24.4567 31.794) rotate(-180)",
        fill: "#8AFF76"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.794)",
        fill: "#8AFF76"
    },
    {
        transform: "translate(40.2375 47.5748) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.5748)",
        fill: "#00E45D"
    },
    {
        transform: "translate(16.5664 31.794) rotate(-180)",
        fill: "#8AFF76"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.794)",
        fill: "#8AFF76"
    },
    {
        transform: "translate(8.67601 31.794) rotate(-180)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.794)",
        fill: "#00E45D"
    },
    {
        transform: "translate(40.2375 8.12296) rotate(90)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.12296)",
        fill: "#00E45D"
    },
    {
        transform: "translate(56.0182 31.794) rotate(-180)",
        fill: "#00E45D"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.794)",
        fill: "#00E45D"
    },
    {
        transform: "translate(40.2375 23.9037) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.9037)",
        fill: "#FFF065"
    }
], A3e = [
    {
        transform: "translate(40.2375 0.395386) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.395386)",
        fill: "#FF701E"
    },
    {
        transform: "translate(63.9086 31.9568) rotate(-180)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.9568)",
        fill: "#FF701E"
    },
    {
        transform: "translate(40.2375 16.1761) rotate(90)",
        fill: "#FF9345"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.1761)",
        fill: "#FF9345"
    },
    {
        transform: "translate(32.3471 16.1761) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.1761)",
        fill: "#FF701E"
    },
    {
        transform: "translate(32.3471 31.9568) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.9568)",
        fill: "#FF701E"
    },
    {
        transform: "translate(48.1278 31.9568) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.9568)",
        fill: "#FF701E"
    },
    {
        transform: "translate(48.1278 16.1761) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.1761)",
        fill: "#FF701E"
    },
    {
        transform: "translate(48.1278 31.9568) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.9568)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 31.9568) rotate(90)",
        fill: "#FF9345"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.9568)",
        fill: "#FF9345"
    },
    {
        transform: "translate(32.3471 31.9568) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.9568)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 39.8472) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.8472)",
        fill: "#FF701E"
    },
    {
        transform: "translate(24.4567 31.9568) rotate(-180)",
        fill: "#FF9345"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.9568)",
        fill: "#FF9345"
    },
    {
        transform: "translate(40.2375 47.7375) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.7375)",
        fill: "#FF701E"
    },
    {
        transform: "translate(16.5664 31.9568) rotate(-180)",
        fill: "#FF9345"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.9568)",
        fill: "#FF9345"
    },
    {
        transform: "translate(8.67601 31.9568) rotate(-180)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.9568)",
        fill: "#FF701E"
    },
    {
        transform: "translate(40.2375 8.28577) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.28577)",
        fill: "#FF701E"
    },
    {
        transform: "translate(56.0182 31.9568) rotate(-180)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.9568)",
        fill: "#FF701E"
    },
    {
        transform: "translate(40.2375 24.0665) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.0665)",
        fill: "#FFF065"
    }
], v3e = [
    {
        transform: "translate(40.2375) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(63.9086 31.5615) rotate(-180)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.5615)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(40.2375 15.7807) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.7807)",
        fill: "#FF701E"
    },
    {
        transform: "translate(32.3471 15.7807) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.7807)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(32.3471 31.5615) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.5615)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(48.1278 31.5615) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.5615)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(48.1278 15.7807) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.7807)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(48.1278 31.5615) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.5615)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 31.5615) rotate(90)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.5615)",
        fill: "#FF701E"
    },
    {
        transform: "translate(32.3471 31.5615) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.5615)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 39.4518) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.4518)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(24.4567 31.5615) rotate(-180)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.5615)",
        fill: "#FF701E"
    },
    {
        transform: "translate(40.2375 47.3422) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.3422)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(16.5664 31.5615) rotate(-180)",
        fill: "#FF701E"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.5615)",
        fill: "#FF701E"
    },
    {
        transform: "translate(8.67601 31.5615) rotate(-180)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.5615)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(40.2375 7.89038) rotate(90)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 7.89038)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(56.0182 31.5615) rotate(-180)",
        fill: "#F42F3B"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.5615)",
        fill: "#F42F3B"
    },
    {
        transform: "translate(40.2375 23.6711) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.6711)",
        fill: "#FFF065"
    }
], E3e = [
    {
        transform: "translate(40.2375 0.465149) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.465149)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(63.9086 32.0266) rotate(-180)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.0266)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(40.2375 16.2459) rotate(90)",
        fill: "#7FE8FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.2459)",
        fill: "#7FE8FF"
    },
    {
        transform: "translate(32.3471 16.2459) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.2459)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(32.3471 32.0266) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.0266)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(48.1278 32.0266) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.0266)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(48.1278 16.2459) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.2459)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(48.1278 32.0266) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.0266)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 32.0266) rotate(90)",
        fill: "#7FE8FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.0266)",
        fill: "#7FE8FF"
    },
    {
        transform: "translate(32.3471 32.0266) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.0266)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 39.917) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.917)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(24.4567 32.0266) rotate(-180)",
        fill: "#7FE8FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.0266)",
        fill: "#7FE8FF"
    },
    {
        transform: "translate(40.2375 47.8073) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.8073)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(16.5664 32.0266) rotate(-180)",
        fill: "#7FE8FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.0266)",
        fill: "#7FE8FF"
    },
    {
        transform: "translate(8.67601 32.0266) rotate(-180)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.0266)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(40.2375 8.35553) rotate(90)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.35553)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(56.0182 32.0266) rotate(-180)",
        fill: "#36DBFF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.0266)",
        fill: "#36DBFF"
    },
    {
        transform: "translate(40.2375 24.1363) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.1363)",
        fill: "#FFF065"
    }
], S3e = [
    {
        transform: "translate(40.2375 0.697693) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.697693)",
        fill: "#1657FF"
    },
    {
        transform: "translate(63.9086 32.2592) rotate(-180)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.2592)",
        fill: "#1657FF"
    },
    {
        transform: "translate(40.2375 16.4785) rotate(90)",
        fill: "#3AA0FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4785)",
        fill: "#3AA0FF"
    },
    {
        transform: "translate(32.3471 16.4785) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4785)",
        fill: "#1657FF"
    },
    {
        transform: "translate(32.3471 32.2592) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.2592)",
        fill: "#1657FF"
    },
    {
        transform: "translate(48.1278 32.2592) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.2592)",
        fill: "#1657FF"
    },
    {
        transform: "translate(48.1278 16.4785) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4785)",
        fill: "#1657FF"
    },
    {
        transform: "translate(48.1278 32.2592) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.2592)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 32.2592) rotate(90)",
        fill: "#3AA0FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.2592)",
        fill: "#3AA0FF"
    },
    {
        transform: "translate(32.3471 32.2592) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.2592)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 40.1495) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.1495)",
        fill: "#1657FF"
    },
    {
        transform: "translate(24.4567 32.2592) rotate(-180)",
        fill: "#3AA0FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.2592)",
        fill: "#3AA0FF"
    },
    {
        transform: "translate(40.2375 48.0399) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.0399)",
        fill: "#1657FF"
    },
    {
        transform: "translate(16.5664 32.2592) rotate(-180)",
        fill: "#3AA0FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.2592)",
        fill: "#3AA0FF"
    },
    {
        transform: "translate(8.67601 32.2592) rotate(-180)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.2592)",
        fill: "#1657FF"
    },
    {
        transform: "translate(40.2375 8.58807) rotate(90)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.58807)",
        fill: "#1657FF"
    },
    {
        transform: "translate(56.0182 32.2592) rotate(-180)",
        fill: "#1657FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.2592)",
        fill: "#1657FF"
    },
    {
        transform: "translate(40.2375 24.3688) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.3688)",
        fill: "#FFF065"
    }
], x3e = [
    {
        transform: "translate(40.2375 0.930267) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.930267)",
        fill: "#A528F2"
    },
    {
        transform: "translate(63.9086 32.4917) rotate(-180)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.4917)",
        fill: "#A528F2"
    },
    {
        transform: "translate(40.2375 16.711) rotate(90)",
        fill: "#BF58FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.711)",
        fill: "#BF58FF"
    },
    {
        transform: "translate(32.3471 16.711) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.711)",
        fill: "#A528F2"
    },
    {
        transform: "translate(32.3471 32.4917) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.4917)",
        fill: "#A528F2"
    },
    {
        transform: "translate(48.1278 32.4917) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.4917)",
        fill: "#A528F2"
    },
    {
        transform: "translate(48.1278 16.711) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.711)",
        fill: "#A528F2"
    },
    {
        transform: "translate(48.1278 32.4917) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.4917)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 32.4917) rotate(90)",
        fill: "#BF58FF"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.4917)",
        fill: "#BF58FF"
    },
    {
        transform: "translate(32.3471 32.4917) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.4917)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 40.3821) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.3821)",
        fill: "#A528F2"
    },
    {
        transform: "translate(24.4567 32.4917) rotate(-180)",
        fill: "#BF58FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.4917)",
        fill: "#BF58FF"
    },
    {
        transform: "translate(40.2375 48.2725) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.2725)",
        fill: "#A528F2"
    },
    {
        transform: "translate(16.5664 32.4917) rotate(-180)",
        fill: "#BF58FF"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.4917)",
        fill: "#BF58FF"
    },
    {
        transform: "translate(8.67601 32.4917) rotate(-180)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.4917)",
        fill: "#A528F2"
    },
    {
        transform: "translate(40.2375 8.82065) rotate(90)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.82065)",
        fill: "#A528F2"
    },
    {
        transform: "translate(56.0182 32.4917) rotate(-180)",
        fill: "#A528F2"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.4917)",
        fill: "#A528F2"
    },
    {
        transform: "translate(40.2375 24.6014) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.6014)",
        fill: "#FFF065"
    }
], aF = [
    {
        transform: "translate(40.2375 0.162842) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.162842)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(63.9086 31.7243) rotate(-180)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.7243)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(40.2375 15.9436) rotate(90)",
        fill: "#FF7CD2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.9436)",
        fill: "#FF7CD2"
    },
    {
        transform: "translate(32.3471 15.9436) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.9436)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(32.3471 31.7243) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.7243)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(48.1278 31.7243) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.7243)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(48.1278 15.9436) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.9436)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(48.1278 31.7243) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.7243)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 31.7243) rotate(90)",
        fill: "#FF7CD2"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.7243)",
        fill: "#FF7CD2"
    },
    {
        transform: "translate(32.3471 31.7243) rotate(-180)",
        fill: "#FFDE31"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.7243)",
        fill: "#FFDE31"
    },
    {
        transform: "translate(40.2375 39.6147) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6147)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(24.4567 31.7243) rotate(-180)",
        fill: "#FF7CD2"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.7243)",
        fill: "#FF7CD2"
    },
    {
        transform: "translate(40.2375 47.505) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.505)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(16.5664 31.7243) rotate(-180)",
        fill: "#FF7CD2"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.7243)",
        fill: "#FF7CD2"
    },
    {
        transform: "translate(8.67601 31.7243) rotate(-180)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.7243)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(40.2375 8.05322) rotate(90)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.05322)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(56.0182 31.7243) rotate(-180)",
        fill: "#FB51C1"
    },
    {
        transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.7243)",
        fill: "#FB51C1"
    },
    {
        transform: "translate(40.2375 23.834) rotate(90)",
        fill: "#FFF065"
    },
    {
        transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.834)",
        fill: "#FFF065"
    }
], _3e = {
    pink: aF,
    purple: x3e,
    darkBlue: S3e,
    blue: E3e,
    red: v3e,
    orange: A3e,
    green: w3e,
    yellow: b3e
}, R8e = ({ width: e = 135, height: t, className: r = "", color: n = "green" })=>{
    const i1 = 2.4107142857142856, o = t || e / i1, a = e || t * i1, s = _3e[n] || aF;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("svg", {
        width: a,
        height: o,
        viewBox: "0 0 135 56",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className: r,
        children: s.map((c, l)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: 7.89036,
                height: 7.89036,
                transform: c.transform,
                fill: c.fill
            }, l))
    });
}, k3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        height: e,
        width: e,
        viewBox: "0 0 1536 1535.999932",
        preserveAspectRatio: "xMidYMid meet",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "9771a86253",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            d: "M 0 225 L 0 1311 C 0 1435.265625 100.734375 1536 225 1536 L 1311 1536 C 1435.265625 1536 1536 1435.265625 1536 1311 L 1536 225 C 1536 100.734375 1435.265625 0 1311 0 L 225 0 C 100.734375 0 0 100.734375 0 225 Z M 0 225 "
                        })
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                        width: 1024,
                        xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAIAAADwf7zUAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd3hUZd7G8Xsy6YQWQi+hSJGOoHQUUFEQxQ6K4iqoa1kVrOu69t5W3bX3gr33iooiiiJFREClSu8EQkh7/zC+NsCEzJzfc+b5fi4uL5bXTb7LCzPnnjPnTGS4SgUAAADAD0nWAQAAAACCwwAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8kmwdAACorGiKsrJVtZayaimrVtlPqtZSVrZSMpScWvYjJe2Xn6dt/1ckFW1TUYGKtqlomwp/+cn//8pvf7EwX3lrtWmN8taU/bPsJ2tVXGj9OwIA2DEGAAC4LpqsWo1Vu6lqN1Wtxqqa8+tR/s8/yagWs++VmqHUjMp+kfyNv58Ea7RptdYs1qoFWrVAa5awEADAUmS4Sq0bAACSFE1RThPl5JYd6//8IydX2Q2VFLWOi53SEq39qWwM/Pxj9UKtWqDVixgGABAEBgAA2MjJVZMOatxejdqVHevXbKCIx1dmlZZo3dKySbDkWy2eqUUztWaRSnmaAoCYYgAAQBCyaqlxezXpoMYd1KSDGrVXRlXrpjDI36Ql32jRTC2eqcXfaNFM5a2xbgKAkGMAAEDspWaoYduyw/2fj/tr1LduShTrl5UtgZ8nwZJZ2pZv3QQAocIAAIDYyMlVq15q1VOteqlJJ0W5yUIgiou0aLrmfqa5kzR3klYvtA4CAOcxAABgFyWnqmkXtepV9qNmA+sgSOuWau4kzftMcydp/lQVbbMOAgD3MAAAoAKq11XLnmVH/M27KiXdOgg7VligH7/8dQ9sWGEdBABuYAAAwF+oUlPtB6rTAWrXX3WaW9dgV638UbMmaMbbmvmeNq+zrgEAOwwAANiOpKha7KmOg9RpkFrslVC34UdJsX6Youlvacbb+mGKSoqtgwAgWAwAAPhVdiN1GqSOg9RhX1WpaV2D+Nu8TjPf04y3Nf1trV1iXQMAgWAAAPBdSrp271f2Yn+jdtY1sLPkW814W9Pf0uyPVbjVugYA4oYBAMBTmTXU7RD1OFLtBig1w7oGLtmWr1kfaPKz+vJlbVlvXQMAscYAAOCXKjW15zB1P0Id9lM0xboGbisu1Mz39PmzmvIS1w0DSBwMAABeyMpWt2HqcaTaD+S4HxVWXFh2TmDKS8pbY10DAJXDAACQyKrmlB33txvAR/MiBoqLNOsDff6cpryoTautawBglzAAACSgrFrqfri6H6m2+3Dcj7goLtK3H+rzZ/X585wTABAyDAAAiSOSpA77qv9J6jZMyanWNfBD0TZ9+bImPKCZ76q0xLoGAMqBAQAgEdRuqr3/pr1PUE4T6xT4as1iffiQPnpIqxZYpwDATjEAAIRYSpr2PEz7nKj2AxWJWNcAUmmpZn2gCQ9oyot8mAAARzEAAIRSbmf1P0l9juXzeuGozev06XhNeEALvrZOAYDfYwAACJPMGupzrPqfpKZdrFOA8lnwtSY8oE/H80kCAFzBAAAQDo3aavA56jNSKenWKUDFFW7VJ4/rjf9oySzrFADeYwAAcF3HQRpyjjoOsu4AYmHGO3r9Fs18R6U8/QIwwgAA4KiUdPUZqcHnqFFb6xQg1pZ8qzf/o4mPcaEwAAMMAADOqVFP+52m/f6uqjnWKUA8bVqtd+/Su3dq/XLrFAA+YQAAcEhuJx14tnofw8d4wSNF2zTpSb1xqxZOt04B4AcGAAB7kYi6DNHgc9RugHUKYGfWB3rjVn39OpcHAIgvBgAAS5GI9jxMR1yqxh2sUwA3LJ6p5y7XlBeYAQDihQEAwEYkoj0P1eGXqklH6xTAPcwAAPHDAAAQNA79gXJaNEPPX64pLzIDAMQSAwBAcCIRdRumwy9VbifrFCA8mAEAYosBACAIHPoDlbRwup6/XF++xAwAUFkMAADxFYmo6yE64lLldrZOAcKPGQCg8hgAAOKo4yAdcx2H/kCMLZymJy/S9LesOwCEEwMAQFw0aqfjblbHQdYdQOKa8bYeP1eLv7HuABA2DAAAMVatjo68XAPGKClqnQIkupJiTbhfz/xbG1dapwAIDwYAgJhJSdOBZ2vYP5VRzToF8En+Jr18jd74jwq3WqcACAMGAIDY6Hm0Rlyn2k2tOwBfrV6oJy/UpKesOwA4jwEAoLJa9tBxt6hlT+sOANK8yXpsrOZ9Zt0BwGEMAAC7LidXI65Tr+HWHQB+77On9eSFWrXAugOAkxgAAHZFaoYOu0SDz1FKunUKgO0pLNAbt+jFq1SwxToFgGMYAAAqrOMgnXSX6jSz7gDwV1bO14On8YkBAH6HAQCgAqrX1fG3qtcI6w4AFTHpKT16tjassO4A4AYGAIByiUTUf7SOuV5ValqnAKi4Les1/gJ9cJ9KedoHvMcAAPDXGrXV6HvUuo91B4DKmfOp7j9ZS7617gBgigEAYGdS0nXoxRp6vpJTrVMAxEJxoV65QS9exaeGAf5iAADYofYDddJdqtfSugNArC3/Xg+cqm/et+4AYIEBAGA7quZo5M3qd7x1B4B4mviYHh+njausOwAEiwEA4I/2Olxj7lFWLesOAPGXt0b3n6rPn7PuABAgBgCAX2VU0wm3q98o6w4Awfr4UT18pvI3WncACAQDAECZ3ffWaY8oJ9e6A4CF1Qt15yjN/si6A0D8MQAAKDlVR12lg8YpkmSdAsBOaYlev0XP/EuFBdYpAOKJAQD4rnEHnfG4mnS07gDghsUz9d+RWjTDugNA3PByH+CvSJIOOldXT+HoH8CvGnfQ1VM09DxOCQIJizMAgKdymui0R7X73tYdAFw1+yPdOUqrF1p3AIg11j3go77H6YaZHP0D2Jnd99YNM/g8ECABcQYA8EtGVZ18v3ocZd0BIDwmP6t7T1L+JusOADHCAAA80ri9zn5ODVpbdwAIm2VzdevhWvyNdQeAWOAtQIAv+ozUlZ9z9A9gV9RvpSs/V9/jrDsAxAIDAEh8KWk66S6d/pjSMq1TAIRWWqZOe1Sj71ZKmnUKgMrhLUBAgqvdVGc/q+bdrDsAJIr5X+nWI7RqgXUHgF3FGQAgkXUerGu+4ugfQCw166prp6rLEOsOALuKAQAkpkiSjrpK57+mrGzrFAAJp0pNnfeqjr5aSVHrFAAVx1uAgARUrY7OHK/2A607ACS6WR/o9hHauNK6A0BFcAYASDSteunaqRz9AwhCuwG67mu17m3dAaAiGABAQul/kv79obIbWncA8EbNBrpkgvqPtu4AUG4MACBBRJJ0zA06+X5FU6xTAHgmmqKT79OxNyrCYQUQBlwDACSCtEyd8YS6DbPuAOC3L1/Wf49VwWbrDgA7xVQHQq9mA106kaN/APa6HaLLJvIuRMB1DAAg3Jp20VVfqNke1h0AIIkHJSAMGABAiPFiGwAHcVoScBwDAAirg87V2BeUVsW6AwD+JC1TY5/X0POsOwBsDxcBA+ETTdFJd3LTPQAhMOEBPfB3FRdadwD4DQYAEDJVauqc59RugHUHAJTPrAm69XBtXmfdAeAXvAUICJNajXXFJI7+AYRJu/664jPVamzdAeAXDAAgNOq30mWfqEEb6w4AqKAGrXX5p2rQ2roDgCQGABAWuZ112UTlNLHuAIBdUquxLp2opl2sOwAwAIBQaN1H//5Q1epYdwBAJVSrrUsmqE1f6w7AewwAwHWdD9Q/31FmdesOAKi0zOq66G11HmzdAfiNAQA4refROvdlpWZYdwBAjKRm6NyX1Gu4dQfgMQYA4K6BJ+vM8YqmWHcAQExFU3TGExp4inUH4CsGAOCogy/Q6HsU4e8ogEQUSdLou3XIhdYdgJei7XWZdQOAPxpxnY64zDoCAOKs/b5Ky9TM96w7AM/w6iLglkiSRt+jgy+w7gCAQAw9X2Pu5WwnEKhk6wAAv4pEdMoD2vsE6w4ACNCAMUpO1d1/U2mpdQrgBxY34IpIRCfdzdE/AB/1G6XR9ygSse4A/MAAAFwx6nYNPNk6AgCMDBijE+6wjgD8wAAAnDDyZg06wzoCAEztf7qOu8U6AvAAAwCwN/waDRlrHQEADhh8jkZcZx0BJDpuAwoYO+IyHfov6wgAcEbrPook6dsPrTuAxMUAACwdcpGOutI6AgAc03ZvFRfqu4nWHUCCYgAAZoaM0zHXW0cAgJPaD1TBZs2dZN0BJCKuAQBsDDpDI2+yjgAAhx17ow74h3UEkIgYAICBgSdr1O3WEQDgvFG3aeAp1hFAwmEAAEHrNUIn3c3n3QBAuZx0l3ofYx0BJBYGABCodv3194c5+geA8opEdOpDajfAugNIIAwAIDiN22vsi0pOte4AgFBJTtXYF9S4g3UHkCgYAEBAshvpwjeVWd26AwBCKLO6LnxT2Y2sO4CEwAAAgpBZXRe+wVMXAOy67Ia8jALEBgMAiLvkVI19kZPXAFBZjdtr3Eu8kRKoLAYAEF+RiP7+sNr1t+4AgITQdh/9/RFupQBUCgMAiK8R16vXCOsIAEggvYbrmBusI4AwYwAAcTToDA09zzoCABLOQefyIcHArmMAAPGy56EadZt1BAAkqONv1V6HW0cA4cQAAOKiVS+dOV4R/oYBQHxEknTG42rd27oDCCEOT4DYq9VY415USrp1BwAktJR0jX1RtRpbdwBhwwAAYiwlXWNfULU61h0A4IFqtXnBBagwBgAQY6PvUfNu1hEA4I1mXTXmXusIIFQYAEAsHXiW+h1vHQEAnul7nA482zoCCA8GABAz7frr2JusIwDASyNvUrsB1hFASDAAgNjIydVZzyiabN0BAF5Kiuqsp5WTa90BhAEDAIiB1AyNe1FVc6w7AMBjVXN07ktKy7TuAJzHAABi4OT71bSLdQQAeC+3s06+3zoCcB4DAKisIePU+xjrCACAJKnXCB10rnUE4DYGAFApHfbVMddbRwAAfmPEdeqwn3UE4DAGALDr6jTTP55WUtS6AwDwG0lR/eMp1Wlu3QG4igEA7KJois56RlnZ1h0AgD/JytbZzyiaYt0BOIkBAOyi4dfwib8A4K5mXTXiWusIwEkMAGBXdNxfQ8ZZRwAAdmrwWHUcZB0BuIcBAFRYtTo67VFFItYdAICdikR02iOqXte6A3AMAwCoGJ5OACBEqtfVaY/wkg3wOwwAoGIGj1WnA6wjAADl1nEQb9oEfocBAFRAs64afo11BACggrhtA/BbDACgvNKz9I8nlZxq3QEAqKBois58UulZ1h2AGxgAQHn97X+q19I6AgCwS+rtphPvtI4A3MAAAMqlz7Hqd7x1BACgEvoepz4jrSMABzAAgL9Wt4VOvMs6AgBQaSfeqbotrCMAawwA4C8kRXXGE8qoat0BAKi0jKo6c7ySotYdgCkGAPAXhozVbt2tIwAAMdJiLx10rnUEYIoBAOxM/VY68grrCABATB1xmRq0to4A7DAAgB2KRHTKA0pJt+4AAMRUSrpOfkARDoLgK/7sAzu0/xlq3cc6AgAQB617a9AZ1hGAEQYAsH21m2rEtdYRAIC4GX6N6jSzjgAsMACA7Rtzn9KqWEcAAOImrYrG3GcdAVhgAADb0X+0OuxrHQEAiLP2AzVgjHUEEDgGAPBH2Q018ibrCABAIEbepOyG1hFAsBgAwB+ddLcyq1tHAAACkVFNo++xjgCCxQAAfqfPsdrjIOsIAECAugxRn5HWEUCAGADAr6rV0ajbrCMAAIEbdZuq17WOAILCAAB+Neo2ZdWyjgAABC4rmxeA4BEGAFBm937qNdw6AgBgpOfRaruPdQQQCAYAIElJUZ1wh3UEAMDUCbcrKWodAcQfAwCQpH1PVZOO1hEAAFONO2i/v1tHAPHHAACUVUtHXWkdAQBwwJFXqGqOdQQQZwwAQMOvVpWa1hEAAAdUqamjr7aOAOKMAQDfNe3C58ADAH41YLSa7WEdAcQTAwC+O+EORfh7AAD4RSRJJ9yhSMS6A4gbDnzgtT7HqnVv6wgAgGNa9VLvY60jgLhhAMBf6Vk65gbrCACAk469QelZ1hFAfDAA4K9D/6WaDawjAABOqlFfh11iHQHEBwMAnqrXUoPPsY4AADjswLNVv5V1BBAHDAB46vhblZxqHQEAcFhyqo6/1ToCiAMGAHzUpq+6DLGOAAA4r/Ng7d7POgKINQYAfDT8GusCAEBIHM1TBhIOAwDe6XygWvexjgAAhETr3uo82DoCiCkGAPwSifAZ7wCAihl+NZ8LhoTCAIBfuh+hpl2sIwAAoZLbWd2PtI4AYocBAI8kRXXkFdYRAIAQOvIKJUWtI4AYYQDAI/2OV4M21hEAgBBq0Fr9RllHADHCAIAvklN1+KXWEQCA0Dr8UqWkWUcAscAAgC8GnqKcXOsIAEBo5TTRwFOsI4BYYADAC2mZOvRi6wgAQMgN+6fSqlhHAJXGAIAXDjhL1etaRwAAQq56XR14lnUEUGkMACS+zBoaep51BAAgIQw9T5k1rCOAymEAIPENPkdValpHAAASQmYNDRlrHQFUDgMACS6tigadYR0BAEgg+5/OlQAINwYAElz/k5SVbR0BAEggWdkaMNo6AqgEBgASWTSZE7UAgNgbPFbRZOsIYFcxAJDIeh7Nvf8BALGX00Q9h1tHALuKAYBEdhA3/wEAxAf3l0N4MQCQsDoOUm4n6wgAQIJq0lGdDrCOAHYJAwAJ6+DzrQsAAAnt4AusC4BdwgBAYmreTe0GWEcAABJa233UYk/rCKDiGABITEN5+R8AEH883SCMGABIQHVbqPvh1hEAAA/sdZjq7WYdAVQQAwAJaMg4RfijDQCIv0iSDjrXOgKoII6SkGiq1dE+f7OOAAB4o98oVatjHQFUBAMAiWa/vysl3ToCAOCNlHTtf7p1BFARDAAklKSoBoyxjgAAeKb/SUqKWkcA5cYAQELpMkTZDa0jAACeyW6oPYZaRwDlxgBAQtn3VOsCAICX9j3FugAoNwYAEkdOrjoNso4AAHip4/6q3dQ6AigfBgASx4Ax3P0TAGAjksRFaAgNDpeQIKLJ6n+idQQAwGP7nKhoinUEUA4MACSIrgerRn3rCACAx2rUU9eDrSOAcmAAIEEM5OorAIA1LgVGKDAAkAjqNFeH/awjAADea7+v6rawjgD+CgMAiWDAGEUi1hEAAO9FIhp4snUE8FcYAAi9aAqX/wIAXLH335Scah0B7BQDAKG356GqVsc6AgAASVK12trzUOsIYKcYAAg9TrYCAJzCExMcxwBAuNVsoHb9rSMAAPiNtvsou6F1BLBjDACEW4+j+PRfAIBbIknqcZR1BLBjHDoh3HqPsC4AAOBPevH0BIcxABBidZqrxV7WEQAA/EmLPflAALiLAYAQ6zXcugAAgB3gSQrOYgAgxHhsBQA4qydPUnAVAwBh1aitGnewjgAAYAcat1fj9tYRwPYwABBWXF8FAHAcJwHgJgYAwopHVQCA43irKtzEAEAoNe+mertZRwAAsFN1W6jFntYRwJ8wABBKvP8HABAKPGHBQQwAhE8kop58wiIAIAz4xHo4iD+SCJ82fZXdyDoCAIByyG6oNn2tI4DfYwAgfLofaV0AAEC59eBpC45hACB8ugy2LgAAoNw687QFxzAAEDIN2qhOc+sIAADKrU4zNdzdOgL4DQYAQoaX/wEAocNJADiFAYCQ4TEUABA6XYZYFwC/wQBAmGRU5V4KAIDwadNHGVWtI4BfMAAQJu33VXKqdQQAABUUTVGH/awjgF8wABAmXAAAAAgp3sIKdzAAECadDrQuAABgl3TmKQzOYAAgNHI7K7uhdQQAALukZgM17WIdAUhiACBEeP8PACDUeCKDIxgACA3ePQkACDWeyOAIBgDCIStbLXtYRwAAUAkteyirlnUEwABAWHQcpKSodQQAAJUQSVKnQdYRAAMAYcHtkwEACaDj/tYFAAMAYcEHAAMAEkDrPtYFAAMAoVCjnurtZh0BAECl1W2hGvWtI+A9BgBCgNdLAAAJow1ParDGAEAIMAAAAAmDJzWYYwAgBLgAAACQMHhSgzkGAFyXnqXcTtYRAADESJOOyqhqHQG/MQDgupY9+QQAAEDiSIqqZS/rCPiNAQDXcaoUAJBguA4YthgAcB0XSwEAEgxPbbDFAIDToinarbt1BAAAMbVbd0VTrCPgMQYAnNZsD6VlWkcAABBTqRlq3tU6Ah5jAMBpnCQFACQknuBgiAEAp3EFMAAgIfEEB0MMADitFTdKAwAkIp7gYIgBAHfVbKBqta0jAACIg6o5ym5oHQFfMQDgriYdrQsAAIibJnzOPYwwAOCuXB4ZAQCJK5fXuWCEAQB3MQAAAAmMMwCwkmwdAOwQj4xA5RVu1eb12rJB+RvL/rl1k/I3qWCzCjZrW7625atwqwoLVLRNSUlKTlVymlIzlJqh1EylV1F6ltKylFlNGdWUWb3sn5k1lBS1/t8GhByvc8EKAwCOSklT/VbWEYDDigu1YYU2rNDGVWU/Nv38z9XKW6vN65S3VnlrVbg1Lt89ElFGNVWpqaxsVamprFqqVrvsR9VfflKjnqpkKxKJSwCQAOq3Ukp6vP6SAjvBAICjGrVTlD+e8FtpqTas0JrFWrNYa5do3VKtX6b1y7VumdYvU94alZZatm3ZoC0btGrBzv615FRVr6sa9VWjnmrUV836ym6oWo2V3Ui1GiujWkC1gJuSomrUTvO/su6AfzjCgqM4MQp/FBdq1UKtWqBV87VyvlYtKDviX/uTigut4yqnaFvZgNmujGqq1UjZjVWrseo0U51mqt1UtZupRr1gKwE7uZ0YADDAAICjuAcoElL+Ji2fp2VztXyeVvxQdsS/9ieVlliXWcjfqCXfasm3f/z11IyyJVCnmertpvqtVK+VajflrCASEK92wQSPpnAUVwAj7EqKtfx7LZ2tZXPLjviXzdX65dZZYbAtXz/N1k+zf/eL0RTVaaZ6LVW/leq1VIPWatRO1esaJQIxwqtdMBEZLrv3kAI7dt9qZdWyjgDKraRYK37QkllaMktLvtWSWVo2R4UF1lmJLitbjdr98qMtkwDhs3mdRmdbR8A/nAGAi7IbcvQP121epwXTtHCaFnythdM53LeRt1bfTdR3E3/9laxaatxOTbsot7OadlbDtkpOtesD/kqVmqrVeIfXyQBxwgCAi3j/Dxy0euGvR/wLpmn1QusgbE/eGs3+WLM/LvuPyalq2FbNuii3c9kk4NZDcE2TjgwABI0BABdxURRckLdWP3yh7z/X95/r+y+Ut8Y6CBVXtE0Lp2nhtLL/GImoXkvt1r3sR24nRVNM+wApt5O+ft06Ap5hAMBFDVpbF8BLPx8slh3xf67l31sHIdZKS8uuyZ74mCSlpKlpl7Ix0GIv1W1h3Qcv1ecpD4FjAMBFtZtZF8Ab+Rs1d5Jmf6zvPtYPU1S0zToIASos0LzJmje57D9Wq63WfbR7P7Xpp9xOSoqaxsEbdXjKQ+AYAHARj4aIq42rNOeTsoP+hdNVUmwdBDdsXKUpL2rKi5KUUU2tepWNgRZ7ciUx4oinPASP24DCOcmpejRfkSTrDiSWLev1zfua+Z5mf/THG8wDO5eSrt26q11/ddhPu3XnzABirLREx2dw+hGBYqkcWP0AACAASURBVADAOfV2063zrCOQEIqL9P1kzXhHM9/VD1N4pR8xkFld7Qaow37quD/XDCBmxrbWsrnWEfAJbwGCc7gAAJW0bK5mvqsZ7+jbCcrfZF2DxLJlw69vE6rTTB32V8f91X6AMmtYlyHMajdjACBQDAA4p05z6wKEUHGRvvtYX76sr17RqgXWNfDDyvl6/x69f4+SomrZU10PVrdDVL+VdRZCiMsAEDAGAJzD4yDKL3+jpr2pr17R129oy3rrGviqpFhzPtGcTzT+fDVora6HqNshatmDa5lQXjzxIWAMADiHx0H8pTWL9dUr+vJlffuhiguta4DfWDpHS2/QqzeoWh3tcZC6HqwO+ykt0zoLbuO9rwgYAwDO4XEQO7J2iT57WpOe0o9fWqcAf2XjSn34oD58UKkZ6jxYvUeoyxClpFtnwUm88oWAcRcgOOfeVaqaYx0Bl2xcpc+f06QnNecTlfKIhdDKqKpuw9RrhDrspyivv+E38tZqTC3rCPiEAQC3ZFTVgxutI+CG/I2a8qI+fVKz3ldxkXUNEDtZtdT9CPUeoTZ9uU4AZU6srnye/hAUXoKAW3j/D4qL9PVr+vhRTXtDhQXWNUAc5K0pu31QdkP1PFp7/02N21s3wVqdZlo43ToC3mAAwC28D9Jny7/Xhw/oo4e1frl1ChCItT/p9Vv0+i1q2UP9R6vn0UrPsm6CkdoMAASIAQC31G5qXYDAFW7VFy/og/s0+yPe4g9PzZuseZP16NnqOVwDx6jFXtZBCBxPfwgSAwBuqVbHugABWjRDH9yvTx7X5nXWKYADtuZpwv2acL8ad9CA0ep7nKrUtG5CUKrz9IcAMQDgFu7/44PiIk1+Rm/eph++sE4BnLR4ph45S+MvUI8jNfgcNe1iHYT44+kPQWIAwC08Aia2Lev1/r166w6tXWKdAjivcKsmPqaJj6ntPhoyVl0OUiRi3YS44ekPQWIAwC08AiaqFT/ozf/ow4dUsNk6BQibbz/Utx+qXksNPlv9TuBzhRMTT38IEgMAbqnKJ6EknO8m6vVb9NUrKi2xTgHCbPk8PXi6nrlEA0/RoDNUs4F1EGKKAYAg8UFgcMvdy1W9rnUEYqG0VFNe0MvX6ccvrVOAhBNNUa/hGnaxGrS2TkGMbFylU7gOGEFhAMAhkYge26Yo56XC78uX9Nxl3NMaiK+kqHofo8MuUb2W1imotJJijUzhVsgICB9BDodkVOfoP/SmvqZ/dtXNh3L0D8RdSbEmPqZxu+vuv2nlj9Y1qJykqDJrWEfAGwwAOKQa74AMs2lv6l976cahmj/VOgXwSUmxPnpYY1vr3tFatcC6BpXAZQAIDAMADuGxL6RmvKN/99T1g/XDFOsUwFfFRZrwgM5ppftP0epF1jXYJTwJIjAMADiEx77QWTxTVw3QtYM0b7J1CgCpuFDv36tzWurJC5W/yboGFcSTIALDAIBDeOwLkbw1evB0XdhFsyZYpwD4vaJteuV6jW2ljx/hotIw4X2wCAwDAA7J4kMAwqCkWG//V2e31Lt3qqTYugbADqxfrrtO0CXdOUEXGrwKhsAwAOAQHvvc9837uqCTHj5Tm9dZpwAohx+m6NJeuvN4rVtqnYK/wpMgAsMAgEP4GGCXrfxRNx+qq/fVklnWKQAqorRUEx/T2NZ6+VoVFljXYMeysq0L4A0GABySkm5dgO0pKdYr1+vctvryJesUALtqa56e+qfO76A5n1inYAd4EkRgGABwSEqadQH+5KfZ+ncvPXkhLxwCiWD5PF2+tx4bq2351in4k2SeBBEUBgAckpxqXYDfKCnWqzfqoj30wxfWKQBip7REb9yqCzpp7iTrFPweT4IIDAMADuHFD3csnaPL+mj8+Srcap0CIA6Wz9NlffX4ufwddwinwREYBgAcwosfLigt0es368LO3DoQSHD8ZXcNT4IIDAMADuHFD3Mrf+RFQcAvS+fo0t4af4GKC61TvMdpcASGAQCH8OKHramv6aKuvC0Y8E5piV69QVfsw2cFGONVMASGAQCH8OKHldISPXOJbjpYW9ZbpwAwMneSLtpDsz+y7vAYr4IhMAwAOITHPhN5a3TdgXrxKpWWWqcAMLVhha7eV6/fbN3hK14FQ2AYAHAIZz+D9+OXuqirZrxj3QHADcVFevxc/edI5W+yTvEPr4IhMAwAOIQXPwI24X5d1kerF1p3AHDM58/pX3vpp9nWHZ7hVTAEhgEAh/DiR2CKC3XvaN07hs/3BbB9S7/Tv/bSFy9Yd/iEJ0EEhgEAh/DiRzAKNuuGoZrwgHUHALdtzdN/jtS7d1l3eIPT4AgMAwAO4cWPAOSt1dX7asbb1h0AwqC0RA+epheutO7wA6+CITAMADiEARBva3/S5f341E8AFfPsv/XwP7hRWNxFU6wL4A0GABxSUmJdkNCWzdWlvbVklnUHgBB6+w79bySfFhxnTCwEhQEAh5QUWRckrvlTueEPgEr5dLxuOkQFW6w7EldJsXUBvMEAgEOKeG0pPmZN0JX7aOMq6w4AITftTV2znzavs+5IUDwJIjAMADikMN+6IBHNmqDrD+QzfQDExtxJumqg8jdadySi4m3WBfAGAwAO2cYAiLWF03TzMG72DyCWFnzNA0tc8FuKwCRbBwC/YgDE1sofde0BvFD3R1nZqtlQGVWVXlXRZG3dpPxN2rRaa5dwkxMoJU21myqjujKqKjVD2/KVv0n5G7RqAQdnvzNrgv43Umc9rQgvJMYOT4IIDAMADtmaZ12QQDau1DX7a8MK6w4HZFZXm35qP0DN91SD1qqas/1/rWCLls/VwumaNUHfTtDqRcFWwkhSVM32ULsBatNXDXdX7abbP6ItLdGqBfpptr6bqFkfaP5UrtfU58/poTN04p3WHQmEC6wRGAYAHMIAiJX8TbruQK34wbrDVFqmug1T3+PUYT8lRcv17+d2Vm5n9RslSYtmaOJj+nS81i2NdylstOyhvser59HKyv7rfzmSpDrNVae5ugyRpLy1+uxpTXzU90/VePcuVa+nw/9t3ZEouBAOgYkM566zcMZ5r2qPg6wjwq9om64frG/et+6wUzVHg8/R/qcrs3plv1RJsSY/q5eu0eKZsSiDA5Ki6nGUhl2kxh1i8NUWz9RL12jys16fEBh9twaeYh2REGZ/pCv2sY6AH3jvHhyylTvVVFppif53nL9H/2mZGn6N7lioYf+MwdG/pKSoeg3X9dM19gXVaRaDLwhb3Q7RzbN15vjYHP1LatxBZz6pm2er2yGx+YJh9MBp+uIF64iEULDZugDeYADAIVs2WBeE39P/0uRnrCOMdDtEN83WIRcpLTPGXzkS0Z6H6sZZOvRfiqbE+IsjGLWb6vzXNO4l1WsZ+y9er6XGvaTzX1PtprH/4u4rLdF/j9GCr607wo/3wSIwDAA4hAFQSTPe0SvXWUdYiCRp5E0a95JymsTxu6Rm6Kgr9a/3Va12HL8L4qHDvrp2atnb9+OnyxBdO1Ud9o3vd3FTYYFuO5rPG6ksBgACwwCAQxgAlbF+uf53nI83ssysrvNf05BxAX27Nn111Rdq0jGgb4fKO+AfuvAtVakZxPeqUlMXvqVBZwbxvVyzfJ4eONU6IuS4azMCwwCAQxgAu6y0RP8bqY0rrTsCV6+lrpyszgcG+k1rN9Xln6rbsEC/KXZBNEUn36dRt5XrNlCxkhTVCbdrzL0+vlvs0/Ga8IB1RJhxCgWBYQDAIVvWWxeE1kvX+Hjhb8ueuupzNWhj8K3TszT2BQ0Za/CtUU5pmbr4PfUfbfPdB4zRxe/F/nIU9z3yDy351joitDgDgMAwAOCQvLXWBeH03UQ9d5l1ROBycnXuywG9r2O7IhEde5P2OtwsADsRiei0R7V7P8uG3fvptEcViVg2BK9gi247ik+03UUMAASGAQCHbF5nXRBCeWt0xwjv7kGeVkXnvWJ/MW4kotMeUW5n4wz82eGXObHN9jpch19mHRG4JbP08D+sI8JpM6fBERQGABzCANgFd52gtT9ZRwQrEtEZj7tyGW5aFZ37sqrVse7Ab/Q4SoddYh3xi8MuUY8jrSMCN+F+TXrKOiKEuBAOgWEAwCEMgIqa/IymvmYdEbgjr3TrAtycJhr3opJTrTsgSWq2h059yKE33kQiOvVhNdvDuiNwj5zF4WyFcSEcAsMAgEPy1vp4F8tdti1fT5xnHRG41n106MXWEX/SqpdDLzn7LDlVZz7p3KW3aZk6Y7x3E3HjSh+vTaokJhMCwwCAQ0qKlc/DX7m9cp1WL7KOCFY0WSfdaR2xA0PPV/1W1hHeG3qeo/9faNBaQ/2b6+/8Vz/Nto4IFU6DIzAMALhl42rrgpBYvVCv3mgdEbj9TlPjDtYRO5CcquP/Yx3ht+xGGube2aH/N+xiZTeyjghWcZEeOcs6IlQYAAgMAwBuyVtjXRASj43z7kZ7KWk65ELriJ3qfKBa7GUd4bGDz1dqhnXEjqVm+HgSYOa7+vIl64iQKNisom3WEfAGAwBu2cQZgHKY9YG+eN46InD7nKga9a0j/oqD1yd4onpds8/8Kr8BY3y8YdRj41RYYB0RBrz8jyAxAOCWTZwB+CslxZ6eVT/wbOuCcthjqOo0t47w0sCTnX75/2epGdr3FOuIwK38Ua/dZB0RBnwUJoLEAIBbNq2yLnDeu3dq8TfWEYHbrbujF3f+QSSivsdZR3ip7/HWBeXj5x+Pl6/V2iXWEc7j9S8EiQEAt2xkAOzUtny9cJV1hIV+ITm8k69HeLZa9lS93awjyqdeS7XsaR0RuILNeuka6wjnbeYMAALEAIBbNq60LnDbhAc8/S3aY6h1QbnVbaFGba0jPNM1PH88FLbaWPnwIa1fbh3hNs4AIEgMALiFMwA7UVyo1/y79aekerupVmPriIpoN8C6wDPh+g0PV22sFG7VG7dYR7iNm+AhSAwAuIUBsBOfjvfuk79+1ra/dUEFhS441DKqqnk364iKaN5NGVWtIyy8dzc3utkZzgAgSAwAuMXP97eUk7d30sjtZF1QQaELDrVG7ZUUtY6oiKSoGrWzjrCQv0nv32sd4TDugYEgMQDglg0MgB2Y84mPN//5WYM21gUVVLupUtKsI7zRoLV1QcXVD2FzTLx/j0pLrSNctZGPwUGAGABwS8FmFWy2jnDSe/dYF9gJxQ1AfyspqrotrCO8Ebo/HgrnaImJlfM18x3rCFdxBgBBYgDAOdwp4s/y1ujzZ60j7FSrbV1QcVVD2BxSYfzjEcbmWHn3busCV23iDAACxACAczassC5wz0ePqLDAOsJINFkp6dYRFefnVZ4m0kP4Wx3G5lj5+jWtX2Yd4STugYEgMQDgHAbAn3063rrATkgPlUKaHUZh3FrpWdYFdoqL9NnT1hHu2ZavrXnWEfAJAwDOYQD8wcofNf8r6wg7JUXWBbskpNlhVBzC3+qSYusCU589Y13gHu6Ah4AxAOAcrgH4A8+fLLduDuVtQ/I3WRd4I4yvm3r+x+P7yVqz2DrCMdwBDwFjAMA5vD30Dzw/XV5aEsobQ231+wgvSGH8rQ5jcwyVlmqyx3c12C7OACBgDAA4Zx0D4DdWztfCadYR1tb+ZF1QcWFsDqk1S6wLKo4/HlNesC5wDGcAEDAGAJzDGYDf4p7ZkpbNsS6ooMKtWr3IOsIbofvjoXA2x9b3nyt/o3WES7j4DQFjAMA5DIDfmvGudYEDlobtaGn5PJWWWEd4I3R/PCT99J11gbXiIs36wDrCJQwABIwBAOdsWBHKiz7joaSY50hJ+uEL64IK+j5swaH207chuw54a56WzraOcACvbvzWBu5+gWAxAOCc4iI+Eb3Mj19q8zrrCAfMmhCyTchsC1Jxkb6baB1REd9NDOWtS2OO9zf+Fre/Q8AYAHAR1wH/bPbH1gVuyFujRdOtIyqCARCwcP2Gf/O+dYEbln/PUe+v+K1AwBgAcNE672+R8bMfp1gXOOPz56wLym3OJzyXB+2L50Nzjqi0VF88bx3hDB7i/h8PGggYAwAu4h55P/uBZ8dfTHw8NEd4Hz9qXeCflfM15xPriPL5bqJWLbCOcAZXy/yssEBb1ltHwDMMALiIASBp02oOFH61eqG+/dA6ohwKtvAJRzY+eti6oHw+fti6wCW8xvEz7n2H4DEA4KJ1S60LHMBT4x+8eoN1QTl8cC+v5Nn49IkQPG6s/UmfPGEd4ZIfv7QucAMDAMFjAMBFnAGQtHimdYFjpr+l+V9ZR+xU0Ta9dpN1hK8KC/TqjdYRf+W1m1S0zTrCJXlrOPaVeM0LFhgAcBEXAUtaNs+6wD1PXWxdsFPv3sl2tfTBvU5/APPqRXr/HusI9/BAJwYALDAA4CKOoiQt53nxT2a87e4dVNYv07OXWkf4rWCLHj3bOmLHHjlL2/KtI9yzfK51gQO48zWCxwCAizatVuFW6whry3he3J5Hz1H+JuuI7Xn0HOVvtI7w3pQXNfU164jtmfqavnzJOsJJnAEQZwBggQEAR61ZYl1gamseb43dvjWL9d9jVVpi3fF7b9+hz562joAk6a5RWvGDdcTvrfhBd42yjnAVr3SId73CAgMAjlqz2LrAlOf/83du6qt66p/WEb8x8z09eo51BH6Rt1Y3DnXobEz+Rt04VHlrrTtctcbhyzYC4/kLXjDBAICjPD8C3rjSusBtr1yvTx63jpAkLZ+n245SSbF1B37jp9m6fYQTp4lKS3T7CP0027rDYRt4rJPWMgAQOAYAHOX5AyJPin/p3tH6/nPjhi0bdONQbV5nnIE/m/aGxl9gHSE9cb6mvWEd4bZNq6wLrG1Zr6151hHwDwMAjuIMAHausEA3Hqx5n5kFbFyl6wdr6RyzAOzcazfp+SssA56/Qq/fbBkQCoUF2rLBOsIU7/+BCQYAHMUAwF/auFJX9tfHjxh864XTdfGemjvJ4Fuj/J67VLcdrYItQX/fgi267Wg9x21hy8fzhzvPT3fDCgMAjvJ8AHDJYDkVFuiuE/TEeYG+4fuLF3Rpb61eGNx3xC6b/Iwu7xvoMdbaJbq8ryY/E9x3DDvPH+48f7KDFQYAHOXyJ3oGYJv3H4NQIa/dpBsOCuKNBKWleuFK/ecIFWyO+/dCrMyfqov3DOjdYnMn6Z/dNH9qEN8rYXj+qS+cAYAJBgActWW9QzfyC15RgXVB2Ex7U+N216Qn4/gtFnytS3vp2X+rtDSO3wXxsH65LuurR86K46NK/kY9cpYu76cNK+L1LRJVod8Pd1wDABMMALjL57dYeP6MuGvWL9Mdx+iqAZrzaYy/8upFeuDvunhPzZsc46+MwJQU663bNba13r8nxn+/Cgv0/j0a21pv3c4NYXeF5693cAYAJpKtA4AdWr1IjTtYRxjx/BmxMmZN0Kw+2n1vDT1PnQ5QUrRSX23RDL15myY+puLCGPXB1Prluv9UPX+FhozT3qOUVatSXy1vjT56RK/frHVLY9TnJc9f7+AaAJhgAMBdPp8BKNpmXRBysz/S7I9Uo556H6O9DleLvRStyKPd0jn6+jV9/KgWzYhbIuysW6rHx+mpi9R5sHofo/YDlZVdgf963lp9874+Ha9pb/BXNQY8/z3kDABMMADgLp+vA05OtS5ICOuX6/Vb9PotSs9Sm75qsZcatFb91spuqPSqSsuUpMICFeRp4yotm6ulc7RoumZN4AVdLxRt05cv6cuXFElSbie16atGbVW/teo0V2Z1pWcpKaqSYm3N05YNWvmjls3Rkm/13UQtnO7ExwwnjGiKdYGd/I3K32QdAS8xAOAun88ApGZYFySWrXma9qamvfm7X4wkKSnKe3ug0hIt+FoLvv7jr6ek+f7ulGCkpFkX2PH5aQ62GABw1yqPHxkZAAEoLVExr+Nixzj6D0ZKunWBnVULrAvgK+4CBHetmm9dYCc107oAAALBAACCxwCAuzas8PcDYjgDAMATqQwAIHAMALirtNTfB8cK3ZMEAMIro5p1gR1vn+NgjgEAp6309V1AtZpYFwBAIGrUsy6wwwCAFQYAnObtg2OtxtYFABB/KenKrGEdYcfb5ziYYwDAad5eB5zDGQAAHqhZ37rATv4m5a21joCvGABwmrdvAcpuqAh/OwEkuhoeD4DVC6wL4DEOMeA0b0+PRlNUO9c6AgDiLLuRdYEdb5/g4AIGAJy24gfrAjvNuloXAECcNdzdusAOAwCGGABw2uZ12rLeOsIIAwBAwmvUzrrADgMAhhgAcJ23JwGa7WFdAABx1ri9dYEdBgAMMQDgOm8HQHPOAABIaMmpqtfSOsIOAwCGGABwnbcDIKuWGnewjgCAuGnUTtFk6wg7K360LoDHGABwnc8PkV0GWxcAQNzs3s+6wE7eGn+vcIMLGABw3UpfzwBI6swAAJC4dt/busDO8u+tC+A3BgBc5+1bgCS16qXM6tYRABAHkYjXZwCWz7MugN8YAHDdmiUqLLCOMBJN5iQAgMTUqL2yallH2OEMAGwxAOC60hKt8PiBcp+/WRcAQBx0HWpdYMrn5zW4gAGAEFg217rATvuBysm1jgCAWOtxpHWBKc4AwBYDACGwdI51gZ1IkvY+wToCAGKqbgvldraOMMU1ALDFAEAILPf4DICkfU70+lbZABKP5y//b16nvLXWEfAbAwAh4PNbgCTlNFGfkdYRABA7/UZZF5ji/T8wxwBACHg+ACQN+6eSotYRABALHfZVgzbWEaa4AhjmGAAIgY2rfP/ExHot1fNo6wgAiIX9z7AusLaMCwBgjQGAcPD5OuCfHfZvRVOsIwCgcnJyfb8BqDgDAAcwABAOvAuoQWsNGWsdAQCVc8iFinh/6ME1ADDHvUUQDgwASYddok+e0Nol1h0IobRMVaujrGylV1V6ljKqKi1L6VWUlKxosqLJZT8pLVVJkYqLVFykkiIVbdPWPOVv0tY8bd2k/E3atEqbVqu4yPp/D8KpTnP1P8k6wgHcAxTmGAAIBwaApLQqOv5W/cfv2+dhJ1IzVL+16jRTTq5q56pWE9VqrOp1VLW20jJj9l1KS7V5nTau0oblWr1Iqxdp9UKtXqjl87RqoUpLYvaNkHiOvJy3MipvjTatto6A9xgACAcGwM+6H6FeIzTpSesOOCApqgZt1GwPNe2ihrurQRvl5CoSifv3jUSUla2sbDVo/cf/U+FWLZurpd9p8TeaP1Xzp2r9srj3ICxyO6n3MdYRDvhptnUBwABAWCyfp9LSIA5u3Df6bn0/WSvnW3fAQloVte6jtvuo7d7K7azUDOug30tJV5OOatJRPY4q+5X1y/XDF5o1Qd9+qEXTVVpq2gc7kSSNvod3/0sMALiBAYBwKNisdT8pu5F1hwMyqumM8bq8L+/D9kVaplr1Vtt91K6/mu8Zso+FrlFPXQ9W14MlKW+tvvu4bAwsnskY8Mv+p2u37tYRbmAAwAWheiaB35bNZQCUadlDI2/WI2dZdyCeatTXnoeq++Fq0zdB3jadla1uw9RtmCRtWq2pr+mL5zXzXRUWWJchzmo11tFXW0c4gwEAFzAAEBrL5qrdAOsIZxzwDy3/Xm/fYd2BWMtpoj0PU/fD1apXIr9fomqO9j5Be5+g/I1lS2D6WyrYYp2FOIgm64wnlFHVusMZDAC4gAGAcEhJV9Uc6wjHHH+rVv6or1+37kAsVM1Rn5HqfYxa7GmdEqyMaup9jHofo4ItmvaGPn5U095QSbF1FmLnqKvUpq91hDMKNmvNIusIQIoMF2/DhOs67KcT71S93aw73FOwWdcdqO8mWndgV0WS1HF/9T9JXQ9Wcqp1jRvWL9NHj+jDB7lXeiLoMkTnvcr9G341f6r+2dU6AmAAwHE16um4W9RrhHWHw7bm6frBbIDwqdNM+5yovU/gypYd+m6iJjygz5/lrUFhldtJl36sjGrWHS755An9b6R1BMAAgMv2OVHH3aLM6tYdzivYrOsHa/bH1h0on/YDdeBZ6jIkkd/iH0Ob1+mD+/XOf7WaN06ESk6urvxMNepbdzjmmX/pRa6HhgMYAHBRzQY6+T51HmzdER7b8vW/4/TF89Yd2LHUDPU+VgeepcbtrVNCqKRYU17Um7dpzifWKSiHarV16cdq0Ma6wz23Hq4vXrCOABgAcFDf4zTqNlWpad0RNqWlevJCvXqDdQf+JLuh9j9dA09WVi3rlPCbP1Vv3aZJT6lom3UKdqBGfV38nhq1te5w0rltuQsQnMAAgEOq1dGYe9XtEOuOMJvwgB46Q4VbrTsgSWrZQwecpe5HhOzTu9y3YYXevUvv3a0NK6xT8Hs5TXTx+9yzYfuKizQqU8WF1h0AAwDuaD9Qpz+uGvWsO8Jv4XTddpSWzbXu8Fg0Rd2P0OCz1WIv65SEVrRNk57Sm//Rgq+tUyBJatpF573Cde07tPQ7jdvdOgKQxACAC5KiOuJyDbuIayJjZmueHjxNEx+z7vBPtdoaeLL2O001G1in+OS7iXrzNn35Eh8gYKnHkTr1YaVlWnc47IsXdOvh1hGAJAYAzNVqrDOfVOve1h2JaOa7evB0bqYekKZddMA/1GuEUtKsU3y1ZrHe+Z8+uE95a61TPJOcqiMu18EXcL//v/DcZXr+cusIQBIDALa6HqxTH1JWtnVH4ios0CvX6+VruSogXqLJ6jZMB56l1n2sUyBJ2pavT5/Qm7dr8UzrFD8066q/P8y9rcrllsM05UXrCEASAwBWIkkafo0OvsC6ww8rf9RDZ2jam9YdiaVWY/U/Sf1P4h3Pjpr9sT64V58/z/qNl5Q0HX6php6vpKh1SkicvZtW/GAdAUhiAMBEZnWdOZ7b/Aftixc0/nyefiormqw9hmrAGHUaxFUrIbB5nT55XO/fxwmBGGuxl059iHt9VsDWPJ1YTaUcc8ENDAAErUFrjXtZDVpbd3ippFiTn9Er12vhdOuU2CA+EAAAIABJREFUEKrXUv1P0t4nqHpd6xRU3Pef64P79NnT2ppnnRJyNepr2EXa7zRe+K+YeZ/p372sI4BfMAAQqM4H6swnlVndusN7097UK9dp9sfWHWGQ00Q9jlLPo9W8m3UKKm1bvqa9oc+e1tevq2CLdU3Y1Gyggy/QwJOVkm6dEkLv36P7T7WOAH7BAEBwhp6vEdfyrgmHzPtML1+nqa+ptMQ6xT01G6jHkep5tHbrwb1NElDBZn31qj57WtPfVGGBdY3zshvq4As0YAyH/rvuwdP07l3WEcAvGAAIQjRFpzygvsdZd2B71i3Vp+M18TEtmmGd4oD6rdRliLoNU5u+HPd7IX+jvnpFX72qGe9oy3rrGvc020MDxmjvv3F/28q6rI/mfGodAfyCAYC4S8/SOc+p4yDrDvyVRTP0yeP65AmtW2qdEqz0LLXpp47/1959R1dV5n0b/4ZQpEhRQIVRASsq9l5w1GcYZHREnNcyOrZRxzJjr+NjL4iCBUdFsAsqgjQFRFAR6V16KKGFEEJIQno7Oe8fj44oAXOSc/Lb976vz2Kx/GOGXLNGl+d79r337qbj/qR9D7augZFIhVZO04JxWjJJ6xb6flms5X4680p1vYbne8ZHNKq/t1RxnnUH8BMGABKreRs9MI7D0y6JVmrZZM3/QosmKG2ZdU3CNN5TB5+izmfryHN10MlKrm8dhCApyNayyVr6jVKmasNij8ZAo6Y6/gJ1vUZHd+Me33jKXKs7OllHADtgACCB2nbUQxO07yHWHaip7DT9MEGLJmjxJBXmWNfUTr1ktTtMHU/QIafp0NO1/1F8vkG1FOdr9SytnK7Vs7RugXI3WwfFW1I9dTxeXf6go7vp0NNVv6F1UBjNHa1+Pa0jgB0wAJAoBx6rB8er5b7WHYiHyojWLdCa2Vo9W6lztGmFA9+JNm+r9p3VvrMOPEYdjtMBR6thY+smuG/7Fq2dr3ULtHGJNi1XxkonnyZUv6H2P0qdTtSR56rL/6jZ3tZBYTfiKQ171DoC2AEDAAlx5Dm6Z5QaN7fuQGIU5yt1rlLnatMypadoc4oKss1ikuqpVTu17ag2HdS2o1p3ULvD1L6zmrYyS4I/olFlrdem5dqyWlvXKXPtj78H7X7iPVtrv0PV4Th1PF4djtP+Rym5gXWTT176i2Z/Zh0B7IABgPg7uZf+9THXkf2St1WbU7R5lbLTlL1JOZuUvUnZm1SwTZWRmv+xyfXVuIWatVLTvdS0lZq1UtNWarGPWu6rlvv9/DsfZRA0xfnK3azczcrN+PH3/CwV5qggW4U5P/4qKYjne2HrJavZ3mreRnu2VvM2armv2nZS245q20ltOqrxnnH7QaiBuw5VxirrCGAHDADE2WmX6bbB3FKJH0WjKt6uwlwV56m0UKVFqihTZYWiUdVL/uWv+qrfQA0bq2ETNWry4+98ske4lRWrrFhlRSotUlmRyooVqVBl5Ne//uu//7wk11eDPdSoqRo1UaOmatRUjZvz4NqAKinQ9S0cODYJr/AxDfF05pW65X3urcTPkpLUpKWatLTuAAKpYWM1bCztZd2BRFo7n0//CBxeyoq46XqNbv2AT/8AAPwsda51AbATBgDi48wrdfM7SuJvKAAAdpA6x7oA2Amf1xAHJ1+iW97n0z8AAL/GFQAEEB/ZUFvHX6DbP+bkDwAAv1aUqy1rrCOAnTAAUCtHnac7h/OoFgAAqrBmbjwf9grECwMANdfxBN09Ug0aWXcAABBI3ACAYGIAoIb2PUQPjuPlMgAA7BI3ACCYGACoiZb76aEJat7WugMAgABbwxUABBIDADFrvKceHK+2Ha07AAAIsLxMbdtoHQFUhQGA2NRL1u1DdeAx1h0AAAQbX/8jsBgAiM01r+jY860jAAAIPG4AQGAxABCD8+9Qt9usIwAAcAFXABBYDABU1/EX6G8vWkcAAOAIrgAgsBgAqJZ2h+mfQ5TE3y8AAFRD1gZt32IdAewCH+jw2xo31z2j1Li5dQcAAI5ImWpdAOwaAwC/ISlJ/xysdodbdwAA4A4GAIKMAYDfcMnjOv5C6wgAAJySMs26ANg1BgB255ju6vWIdQQAAE4p2q6NS6wjgF1jAGCX9mqv2z5UUpJ1BwAATlk5XdFK6whg1xgAqFpyfd3+ifZsbd0BAIBruAEAAccAQNUufVqHnWkdAQCAgxgACDgGAKpwTHddeL91BAAADoqU8w5gBB0DAL/WbG/d/C5H/wEAqInUeSorto4AdosBgF+7caBa7msdAQCAmzj/g+BjAOAXul6jk3tZRwAA4CwGAIKPAYCftT5Q1/a3jgAAwGW8AgzBxwDAj5Lq6db31bi5dQcAAM5KT1F+lnUE8FsYAPjRn+5W57OtIwAAcBnnf+AEBgAkaf+jdOnT1hEAADhu+XfWBUA1MACgpHq66S01aGTdAQCA4xZPsi4AqoEBAHW7TQefYh0BAIDj0pYqd7N1BFANDADf7fU7XfaMdQQAAO5bPNG6AKgeBoDvrn9Njfe0jgAAwH2c/4ErGABeO/kSnfBn6wgAANwXKecOYDiDAeCvJi103avWEQAAhMLKGSopsI4AqocB4K+/9lHL/awjAAAIhSWc/4E7GACeOvgUnXuTdQQAAGHBHcBwCAPAR0lJuuYVJSVZdwAAEApF27VmjnUEUG0MAB+deRUP/gcAIG6WfavKiHUEUG0MAO80aqornrOOAAAgRHgAKNzCAPDORQ+pVTvrCAAAQoQbAOAWBoBf2nTQBfdYRwAAECJZG7R5pXUEEAsGgF+ufEEN9rCOAAAgRPj6H85hAHik89k65S/WEQAAhMu8MdYFQIwYAL5IStLVL1lHAAAQLqVFXAGAexgAvjj1UnU4zjoCAIBwWTxRZcXWEUCMGABeqJes//ekdQQAAKEzd5R1ARA7BoAXul6j/Q61jgAAIFwqI5r/hXUEEDsGQPjVb6hLHrOOAAAgdFZOV36WdQQQOwZA+J33D7U+wDoCAIDQmTvaugCoEQZAyDVqoosfto4AACCMuAEAjmIAhFz329ViH+sIAABCJ22ptqyxjgBqhAEQZk1a6ML7rSMAAAgjzv/AXQyAMDv/TjVtZR0BAEAYMQDgLgZAaDVqqu7/so4AACCMctKVOsc6AqgpBkBonXujmu1tHQEAQBjNG6No1DoCqCkGQDglN9Cf7raOAAAgpGaPsC4AaoEBEE5nXqm997eOAAAgjPIytfQb6wigFhgAIZSUxMN/AABIlJnDVBmxjgBqgQEQQif2VPvO1hEAAITU9I+tC4DaYQCE0EUPWhcAABBSWRu0crp1BFA7DICwOfIcHXSydQQAACE14xOe/wPnMQDC5s8PWBcAABBe0zj/A/cxAEKl3WHq0s06AgCAkNq4ROsXWkcAtcYACJU/3KqkJOsIAABC6rt3rQuAeGAAhMcezXT2tdYRAACEVKRC3w+2jgDigQEQHmdepcbNrSMAAAipheOUl2kdAcQDAyA8ut1mXQAAQHh99551ARAnDICQ6Hy29j/KOgIAgJDKz9L8L6wjgDhhAITEH/9pXQAAQEilp+jxMxUpt+4A4oQBEAZ7tdeJPa0jAAAIqe8/UHqKdQQQPwyAMDjvH0qubx0BAEAYRaOaOsQ6AogrBoDzkuvrvJusI+Jh+RRerg4ACJwV3ytrvXUEEFcMAOcd20Mt9rGOqLVoVEPutY4AAGAn339oXQDEGwPAeV2vsS6IhxlDtWaOdQQAAL9UXqJZw6wjgHhjALit2d46/gLriFqrKNPQf1tHAACwk3mfq2i7dQQQbwwAt51xheo3tI6otQmvKnOtdQQAADvh/A9CiQHgthCc/ynarpHPWEcAALCT/Cz98KV1BJAADACH/e4IdTrROqLWxr2kwhzrCAAAdjJjKC//QjgxABzW9VrrglorzNH4l60jAACoCud/EFYMAFfVS9ZZV1lH1NrYftxcBQAIorRlWj3LOgJIDAaAq47uppb7WUfUTsE2fdnfOgIAgKp8/aZ1AZAwDABXheD2389fUHG+dQQAADspK9aUD6wjgIRhADhpj2Y64c/WEbVTmKOvXrOOAACgKjOGqijXOgJIGAaAk47toYaNrSNq56vXVVJgHQEAQFUmDbAuABKJAeCkU/5iXVA75SWc/gcABNT6H7j9FyHHAHBPw8Y6rod1RO1Mfld5mdYRAABUha//EXoMAPcce74aNbWOqIXKiL7oax0BAEBVSgo0bYh1BJBgDAD3nHyJdUHtzBymzFTrCAAAqjLtI55Qh/BjADimQSMdf6F1RO2Me8m6AACAXeDx//ABA8AxXbqp8Z7WEbWwZo7WzLaOAACgKmvmaO186wgg8RgAjnH9+T8TXrUuAABgF3hCHTzBAHBJcgOd6PL7v/IyNfNT6wgAAKqSk64ZQ60jgDrBAHDJUeepSUvriFr4epDKS60jAACoyoRXFSm3jgDqBAPAJSddbF1QC5EKnqwMAAio0kJN4vZfeIMB4JJjz7cuqIV5Y5SdZh0BAEBVvntPhTnWEUBdYQA443dHau/9rSNq4du3rQsAAKhKtFLjX7aOAOoQA8AZx3S3LqiFnHQtmmAdAQBAVeZ9rozV1hFAHWIAOMPp8z9T3ldlxDoCAICqjHvRugCoWwwANzRqqsPPso6ohcnvWhcAAFCVtfO0fIp1BFC3GABuOPJc1W9oHVFTK75XxirrCAAAqjKWr//hHwaAG5w+/zP5HesCAACqsm0jb6iEjxgAbnD3DuCyYs0abh0BAEBVPn9BkQrrCKDOMQAc0O4wte1oHVFT879QSYF1BAAAO8nN0DeDrCMACwwAB7j79b+kGZ9YFwAAUJUv+qq8xDoCsMAAcIC7NwAU52vBOOsIAAB2kp+lSQOsIwAjDICgq99Qh3e1jqipuaP4cgUAEETjXlJpoXUEYIQBEHQHnaSGja0jamo6538AAMFTlKsJ/7GOAOwwAILO3fd/FWRr8UTrCAAAdjK+v4rzrCMAOwyAoHP3/M+ckYqUW0cAAPBLxfka/7J1BGCKARBoSfV02BnWETU1d7R1AQAAO/nqNRXmWEcAphgAgdbhWDVubh1RI2XFWjLJOgIAgF8qLdK4F60jAGsMgEBz9waAxRNVVmwdAQDAL016Q3lbrSMAawyAQHP3BoB5Y6wLAAD4peI8jeptHQEEAAMg0By9AhCNav4X1hEAAPzS2H4q2GYdAQQAAyC42ndW8zbWETWyepa2b7GOAABgB3lbNZbT/4AkBkCQOfr1vzj/AwAInlHPqKTAOgIIBgZAcLl7A8DCcdYFAADsIGuDJg2wjgACgwEQXI5eAcjL1IZF1hEAAOxg+GMqL7WOAAKDARBQLfZR6wOsI2pkydeKRq0jAAD4yabl+v5D6wggSBgAAdXxBOuCmlo80boAAIAdfPq/qoxYRwBBwgAIqE7uDgBeAAwACIw1czR7hHUEEDAMgIDqdKJ1QY2kp2jbRusIAAB+8slD1gVA8DAAAsrRI0BL+PofABAYC8drydfWEUDwMACCqMU+2qu9dUSNcAMAACAgIhUafI91BBBIDIAgcvT8TzSqZd9ZRwAAIEma9IY2LbeOAAKJARBEjt4BnLZURbnWEXUubal1AQBgJwXZGv64dQQQVAyAIHL0CkDKVOsCCx/caV0AANjJZ0+oINs6AggqBkAQOXoHcMo06wILS77WnJHWEQCAHaSv0MTXrSOAAGMABE7LfdWqnXVEjfh5BUDS4Ht4wzwABMiH9yhSYR0BBBgDIHAcPf+Tk66t66wjjGSu1dh+1hEAAEnSoglaOM46Agg2BkDgcP7HRaOeVU66dQQAeC9SoQ/vto4AAo8BEDgHdLEuqBFvz//8n9JCffSAdQQAeG/SAKUts44AAo8BEDjtOlsX1IjnVwAkTRuiVTOsIwDAYwXbePQnUC0MgGBJrq/9DrGOiF1FmTYuto6wFo3qvdsVjVp3AICvPnpABdusIwAXMACCZZ+DldzAOiJ2G5eoosw6IgBS5+qbQdYRAOClldM1+R3rCMARDIBgae/m+Z+186wLAuPjB5W31ToCADwTqdDbt3ANFqguBkCwODoAUhkAPynM0eB7rCMAwDNfvqINi6wjAHcwAIKl/RHWBTWybr51QZB8/6GWTbaOAABvZKdx7y8QGwZAsLh4BSBSwfcuv/b2LdwUAQB15P07VVJgHQE4hQEQIElJane4dUTs0paqvNQ6ImDSV+jzF6wjAMADC8dr9mfWEYBrGAAB0vpANWpiHRE77gCu0qhnlJlqHQEAoVZWrHf/aR0BOIgBECAunv+RtJYbAKrCv5YAINFGPctXLUBNMAACxNEBsHGJdUFQLRyvmcOsIwAgpNJT9Pnz1hGAmxgAAeLoI4A2LbMuCLB3b+O1AAAQf9FKDfw7j1sAaogBECAu3gGcn8UH3N3J26p3brWOAIDQmfAfpUyzjgCcxQAIkH06WRfELo2v/3/LrOGa+al1BACESOZaffJv6wjAZQyAoGjQSC32tY6IHed/quOd25SXaR0BAKEQjWrgDSottO4AXMYACIq9D1BSknVE7LgCUB35WXrrZusIAAiFbwZp6TfWEYDjGABB0eZA64Ia4QpANc0ZqekfW0cAgOO2bdSQ+6wjAPcxAIKidQfrghrhCkD1vftP5WZYRwCAy976h4rzrCMA9zEAgqJNB+uC2BXlKnezdYQ7CrL11j+sIwDAWVPe18Lx1hFAKDAAgsLFI0DpKdYFrpk3RlMHW0cAgINyM/TBXdYRQFgwAILCxSsAvIC9Bt67ncsmABCzt29RYY51BBAWDICgcHEAbGEAxK4wRwNvtI4AAKdM+UBzR1lHACHCAAiE5AZq1c46InZb11oXuGnBWH33nnUEADhi6zq99y/rCCBcGACBsPf+SnLw/wqOANXYB3cpe5N1BAAEXrRSr1/Nk3+AOHPwU2cYuXgHsDgCVAtFuRrEQSAA+C1j+mjF99YRQOgwAALBxRsAIuXKTrOOcNnC8fr2besIAAiwtfM17DHrCCCMGACB4OJbwLI2qDJiHeG4D+/Wto3WEQAQSGXFeu0qRcqtO4AwYgAEwt6/sy6IHTcA1F5xngZcp2ildQcABM+Q+7RpuXUEEFIMgEBo3ta6IHaZPAIoHpZ8rVHPWkcAQMD88KW+es06AggvBkAgtHBwAGxdZ10QFsMf1/Ip1hEAEBj5WRpwnXUEEGoMgEBw8QpATrp1QVhURvTqFcrbat0BAMEw6CblZlhHAKHGAAgEBoDnctL1+tWKRq07AMDaxNc1Z6R1BBB2DAB7ezRToybWEbHL3WxdEC4/fKkxz1lHAICpdQv04d3WEYAHGAD2XPz6X1wBSIBhjyplqnUEABgpztcrl6q81LoD8AADwJ6LdwCXl6og2zoidCIV6n+FCrZZdwCAhUE3KmO1dQTgBwaAvRb7WBfEjvM/CZKdpte4GQCAfyYN0Iyh1hGANxgA9lw8AsT5n8RZOE5f9LWOAIA6tP4HfXCXdQTgEwaAPRePADEAEmrov7VqhnUEANSJH4/+l1h3AD5hANhz8QoAR4ASKlKh/pdzlwUAL7z1D21eaR0BeIYBYM/FewC4ApBoWRv0xrXWEQCQYF8P1PSPrSMA/zAA7Ll4BYDX1taB+Z9r7IvWEQCQMOt/0Pt3WEcAXmIA2HPxHgBOp9SNjx/U6lnWEQCQAIU5erEXR/8BGwwAe3u2ti6IHQOgbkTK1f9yFeVadwBAXEUr1f8KZaZadwC+YgDYa9zcuiB2DIA6s3Wd3riONwMACJWhD2vRBOsIwGMMAGP1ktWwsXVE7AoZAHVo7ih99oR1BADEyazhGv2cdQTgNwaAsT32tC6oEa4A1LERT2rmMOsIAKi1tKUacJ11BOA9BoCxxg4OgPISlRVbR3gmGtWAa7V2vnUHANRCUa76XaySAusOwHsMAGMuDgC+/jdRWqS+Fyk3w7oDAGokWqn/XKWMVdYdABgA5lw8AsQAsJKdpn49eWoeACcNe0wLxlpHAJDEADDHI4AQk9WzNPAG6wgAiNHcURr1jHUEgJ8wAIy5eASIRwDZmjpEo3tbRwBAtW1cotev5nHGQIAwAIy5eASoKM+6wHtDH9bc0dYRAFAN27fo+QtUnG/dAWAHDABjLl4BKC20LvBeNKrXrtLGxdYdALBb5SXq11NZ6607APwSA8CYi1cAyoqsCyCVFOj5C5W31boDAHYhGtUb12rVTOsOADthABhz8QpACVcAgiFrvV7spYoy6w4AqMrwxzRjqHUEgKowAIy5eAWAI0DBkTJVb99iHQEAO5k6RCOeso4AsAsMAGMuXgHgCFCgTH5HY1+0jgCAHaRM08C/W0cA2DUGgDEX3wPAFYCg+eh+LRxvHQEAkqTMVPXrqfJS6w4Au8YAMNaoqXVB7Eq5AhAwlRH1v1ybllt3APBe0XY9f4Hys6w7AOwWA8BYcgPrgthxBSCAivP0woXKy7TuAOCxSLle/gtfRgAOYAAYS65vXRA7rgAE05Y16t1dxbymDYCFaFQDrtfiSdYdAKqBAWDMyQHAFYCgWrdAfS9SeYl1BwD/DLlPUwdbRwCoHgaAsXouDgCuAATYssnqf4UqI9YdAHwy9kWN7WcdAaDaGADGXLwCECm3LsBuzR2lQTdZRwDwxtQhGnKvdQSAWDAAjLl4EzDfLgff5Hf00QPWEQA8sHiiBlynaNS6A0AsGADGXLwCUFlhXYBq+Px5fdHXOgJAqK2dpxd7cVkYcA8DwJiL9wBwBcAVH92v796zjgAQUhmr9VwPlRRYdwCIHQPAmItXACJcAXBENKqBN2jeGOsOAKGzfYt6/5F3jwCuYgAY4x4AJFRlRK9cpuVTrDsAhEhxnvr0UGaqdQeAmmIAGOMKABKtvER9/6z1C607AIRCaaH69NDa+dYdAGqBAWDMxQHAFQDnFG1X7+7assa6A4DjykvU9yKlTLPuAFA7DABjTt4EzBUAB23fome7KXezdQcAZ0XK9dJftORr6w4AtcYAMMY9AKgzmanq3V1FudYdABxUGVH/K7RgrHUHgHhgABjjCBDq0oZFev5ClRVbdwBwSrRSb1yr2Z9ZdwCIEwaAMRcHADcBOy1lql66ROWl1h0A3PHWzZo62DoCQPwwAIw59zmsvFTRSusI1M7C8er7Z5WXWHcAcMEHd+qbQdYRAOKKAWCsJN+6IEbOBaNKi77S8xeotMi6A0CwDX1Y41+xjgAQbwwAY0V51gUxKnYtGLuy5Gv16aHSQusOAEH12ZMa9ax1BIAEYAAYc+7ztHPB2I3l36l3dxVzVQfAToY9quGPWUcASAwGgDHn3s3kXDB2L2Wqev+RXQfgFz55SCOeso4AkDAMAGPrF1oXxGida8H4Tatm6Jk/8H4AAD8afK9GP2cdASCRGADG1i2wLoiRc4sF1bFmtp7+HxVkW3cAsPb+HRrbzzoCQIIxAIw5NwCcC0Y1rZ2np89TwTbrDgBGolG9c6u+7G/dASDxGADGcjNc+ki9/gdlb7KOQMKsX6gnz1HeVusOAHUuGtWgmzTxDesOAHWCAWBv5jDrgmqbNdy6AAm2cbGe+r22b7HuAFCHopUacJ2+fcu6A0BdYQDYc+hT9Sx3tgpqLG2Znvy9cjdbdwCoE5URvX61prxv3QGgDjEA7GWsUupc64hqWLdA6SnWEagT6Sv0xNnKTrPuAJBg5SV66RJNHWLdAaBuMQACYUwf64JqcCIS8ZKxSk+crawN1h0AEqY4T727a+5o6w4AdY4BEAizR2jTcuuI3UpPceleBcRFZqqePJtXvwHhtH2Lnjhby7+z7gBggQEQCNFKjXrWOmK3RvdWtNI6AnVu6zo9errWzrfuABBXmWv1+Jm81wXwFwMgKKZ9pNWzrCN2Yc0cTR1sHQEjeZl66vda8rV1B4A42bhEj52hjNXWHQDsMACCIlqpN69Xeal1x04qyvTm9aqMWHfATnG++vTQjKHWHQBqbeV0PdGVx3wBvmMABEjaMo18yjpiJyOf1sYl1hGwVlGmV/+qCa9adwCohYXj9OwfVJhj3QHAGgMgWMb0CdYtWSu+1+jnrCMQDNFKvXe7hj5s3QGgRqYOUd+LVFpk3QEgABgAwRKpUL+Lg/K4/YxV6tdTkXLrDgTJqGc18AaOhAGOGf2cXv+bIhXWHQCCgQEQOIU56tNDeVuNM/Kz1KeHCrKNMxBA376tfj1VUmDdAaAaIhUaeKM+eUjRqHUKgMBgAARRZqqeO195mWYB+Vl67nyeEYFdmv+Fnuiq7E3WHQB2q2i7+vTQt29ZdwAIGAZAQK2dp0dPt/kInpmqR09X6lyDHw2HrFugR07hOeJAcGWt12NnaPFE6w4AwcMACK4ta/TY6Vozu05/6Jo5euQ0Zayq0x8KR2Vv0uNnacFY6w4AO0mdq0dOVdpS6w4AgcQACLS8rXr8LI18pi7uuayMaHRvPX6m5dEjOKekQH0v0oT/WHcA2MHcUXrybOVmWHcACCoGQNBVlOnT/9Wjp2nT8gT+lPQVevR0ffJvVZQl8KcglCojeu9f+uBORSutUwBI417Si5fwuE8Au8MAcMOaOXroOL1/h3LS4/wn527WB3fpwePq+qwRQmb8K+rLo4EAU5URvXObPrybNQ7gNyRdLh4M5pIGjXTujfrzA9rrd7X9o7LTNOZ5fTNI5SXxKIuHjyqVlGQdEaO/1uPhej/b/yjdM0r7HGTdAfinYJtevlRLv7HuAOACBoCTkurpiLN12mU6qZeat4ntv5ufpdkjNGOolk0O3LdEDIAQaLaXbh+qLv9j3QH4ZP0P6tdTW9dZdwBwBAPAbfWSdcip6niCOp6gTido30NUv+Gv/zMVZcpYpbXztXaeUudq9azgvgySARAO9ZJ15QvqcZd1B+CHGUP15vUc+gcQAwZA2DRqoiYt1bSVJBXmqCjXpX8rMADCpOtqhhDYAAAOTklEQVTVuuFNNdjDugMIr2ilPn5Inz9v3QHANfWtAxBnpUUqLYr/vcJArKZ8oE3LdfdI7dXeOgUIo8Ic9b9CiyZYdwBwEE8BApAoa+bo4RO1crp1BxA6aUv18El8+gdQQwwAAAmUm6Enf68Jr1p3ACEye4QeOVVb1lh3AHAWAwBAYkXK9d7teuVSFedbpwCOi1To4wf18l945waAWmEAAKgLM4fp4RO1cbF1B+Cs7DQ99XuN6cODBwDUFgMAQB3ZvFKPnKop71t3AA5aOE4PHKuUadYdAEKBAQCg7pQW6Y1rNfDGAL1/Ggi4/zv28/wFKthmnQIgLBgAAOrat2/pkdO4hRH4bRz7AZAIDAAABtYv1EPHaepg6w4gwDj2AyBBGAAAbBTn67W/6bWrVJxnnQIETKRCHz3AsR8AicIAAGBp6hA9eJxWzbTuAAIjM1VPdNXnz3PsB0CiMAAAGMtM1RNnaeQzilZapwDWvn1LDxyjVTOsOwCEGgMAgL1IhT79Xz11jrZttE4BjORlqu9FGngjL/kCkHAMAABBsXyKHjhGM4dZdwB1bt4Y3ddF88ZYdwDwAwMAQIAU5uiVS9X/cu59hC9KCjTwBvW9SHmZ1ikAvMEAABA4M4bq3iM1d7R1B5BgKdP0wDH69m3rDgCeYQAACKLtW9Svp16/WkW51ilAAkTK9cm/9URXZaZapwDwDwMAQHB9/6HuO0oLx1t3AHG1epYeOl6je/PkKwA2GAAAAi17k/r00MAbeF8YwqC0UB/cpUdP18Yl1ikAPMYAAOCAb9/mrgA4b9EE3Xukxr/MF/8AjDEAALghO039euqlS5STbp0CxKhgm16/Wr27K2u9dQoAMAAAuGX2CN3TWV+9xneocMa0j3RPZ33/oXUHAPyEAQDAMcV5evefeuwMbVxsnQLsVtYG9fmT/nOl8rZapwDADhgAAJy0aqYeOl6fPKSyYusUYCeRcn3RV/cdqYXjrFMAYCcMAACuilRo9HO67yhuDkawLJqg+7toyH0qKbBOAYCqMAAAuC0zVf16qvcflb7COgXey1yrfj3Vu7vSU6xTAGDXGAAAwmDRV7r/aA2+h9cFwEZpkYY9qnuP4HoUAAcwAACERKRcY1/UXYdq8ruKRq1r4JOZw3RvZ414SuUl1ikAUA0MAASJgx/a+KAZNNu36M3r9cipWj3LOgUeSFuqp8/VK5cqa4N1CgBUGwMAAVJaZF0QI+eC/bFmth49Ta9eocxU6xSEVE66Bt2kB47R0m+tUwAgRgwABIhzp7dL8q0LsGvRqKZ/orsP1/t38BR2xFNRrj55SHcerG8GqTJiXQMAsWMAIECKXfs87dxi8VCkXF/2150HaeTTXLFBbZWX6PMXdHsnjX6OF1AAcBgDAAFSvN26IEZFrgV7qzhfnz6iOw/W128qUmFdAwdVRjT5Hd15iD66X4U51jUAUDsMAATIpuXWBTFyLthzuZv11s26/yjN/JS7txGDuaN1fxe9+Xdlp1mnAEA8MAAQIOsWWhfEaL1rwZCUnqJXLtP9XTRjqKKV1jUItkUT9Ojp6teTtQ8gVBgACJB1C6wLYuTcYsF/pS1V/8t1fxdN/4QZgF+LRjV3tB4+Sb27a9UM6xoAiLeky1189DpCqkkLDdqmesnWHdUTrdSNrTkNHAbtO6vXIzrtMiXxlYj3opWaOUwjn9HGxdYpAJAw/OsOAVK0Xcu/s46otuVT+PQfEpuW69W/6t4jNXUwtwj7K1Kh797TPZ3V/3I+/QMIOQYAgmXmMOuCaps13LoAcZW+Qq/9TXd00tgX3XsiLWqjvFSTBuiuQzTgOm1eaV0DAInHESAES4t99Ea6AycxopW6tb1yM6w7kBhNWui8m9T9Du3V3joFiZSfpW8GacJ/lJNunQIAdYgBgMB5YKyO7WEd8Vt++FLPnW8dgQRLbqAzrtCf7tEBR1unIN7W/6Av+2vaRyovsU4BgDrHAEDgHHaGHp9qHfFbnuiqFd9bR6CuHN1Nf/yXjuvhwLUp7F5lRHNH68tXtHyKdQoA2GEAIIge+VZH/N46YtdWfK8nulpHoM61PlDn3aRz/q4W+1inIHYF2fr2LX31mrI2WKcAgDUGAILoqPP08CTriF17tpsWT7SOgJHkBjrpYv3hlkBvVOxo7Xx9/aamDlZpkXUKAAQDAwABdcdQnXqpdURVZg3Xy//POgIB0O5w/eEWdb1aTVpap6AqeZmaOkTfvacNi6xTACBgGAAIqOZt1HeZ9mxt3fFLBdt0zxHKy7TuQGA02EMnXKizrtYx3ZVc37oGUqRcC8bpu3e1YJwi5dY1ABBIDAAE1+lX6F8fWUf80mtXaeoQ6wgEUvM2Ou1ynfU3HXSSdYqvNizSd+9p6mDlbbVOAYBgYwAg0G4cqHNvtI74ybdva+AN1hEIvHaH66y/6cwr1fpA6xQ/ZK3X7BGaOlhr51unAIAjGAAItOT6un+sju5m3SEtnqQ+5ytSYd0BRyQl6eBTdFIvnXSx9j3YuiaMNq/U7M80e4RS51qnAIBrGAAIusbN9cRU7d/FsiFtqR47Q0XbLRvgrv276OReOrkXLxSLgw2LNPszzfpMaUutUwDAWQwAOKDFPnpgnDoeb/PT1y1Qnx7KzbD56QiTtp10ci+d2FMHn8IdwzGojGjNHM0Zqdmfacsa6xoAcB8DAG7Yo5nuGq6j/1jXP3fxRL10iYrz6/rnItyatNAR5+jobjq6m/Y5yLomqDJWafEkLZmkJd+oKNe6BgBChAEAZyQ30N9f1zl1eBvu5Hf01s08SRCJ1bbTj0vgyHPVpIV1jbW8rVr6jRZP1OJJylpvXQMAIcUAgGNOulg3DFDzton9KXlb9fbNmj0isT8F2FG9ZHU4ToeerkNO06Gnq/UB1kF1JSdda2Zr5XQtnqT1CxXlX0oAkGAMALhnz9a6/nWdmrDX8c4arndu5VHiMLZX+5/HQIfjVL+hdVD8FOcpda5Wz9aa2VozW9mbrIMAwDMMALjqsDPU69E4PyF08UR99qRSpsbzzwRqr0EjtT9CBxytA7po/y464Gi13Ne6KRYF25SeovULf/zQn76Cr/kBwBIDAG475FT1/LeO6a7kBjX/QyIV+uFLjXpWq2bErwxIpOZtflwCvztCbTqqbUe1PqBW/xTES6RcW9YoPUWbU37+PT/LOgsAsAMGAMKg2V46qZdOu0xHnqN6ydX9b1VGtGyyZgzV7BEq2JbIPiDxkupp79+pTUe16aC2HdWmo1rtpz1b//irYeN4/qySAuVmaHuGcjN+/ouczdqyWpmpvC8PAIKOAYBQadRUHY5Vh+PV6QTte4iatlLTVmraUpIKc1WYo8IcZazW2nlaO0/rFqq00LoYqBONmvw8BprtpQZ7qH4j1W+oBo3UoNHPfy2prFjlJSorUflPv/771//93F9aZP2/BwBQCwwAAAAAwCP1rAMAAAAA1B0GAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgkf8PodJLypWGxG4AAAAASUVORK5CYII=",
                        id: "de6bfa1531",
                        height: 1024,
                        preserveAspectRatio: "xMidYMid meet"
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                id: "c61e091855",
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                    clipRule: "nonzero",
                    clipPath: "url(#9771a86253)",
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                        transform: "matrix(1.5,0,0,1.5,0.00003385,-0.00002)",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("image", {
                            width: 1024,
                            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAIAAADwf7zUAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd3hUZd7G8Xsy6YQWQi+hSJGOoHQUUFEQxQ6K4iqoa1kVrOu69t5W3bX3gr33iooiiiJFREClSu8EQkh7/zC+NsCEzJzfc+b5fi4uL5bXTb7LCzPnnjPnTGS4SgUAAADAD0nWAQAAAACCwwAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8wgAAAAAAPMIAAAAAADzCAAAAAAA8kmwdAACorGiKsrJVtZayaimrVtlPqtZSVrZSMpScWvYjJe2Xn6dt/1ckFW1TUYGKtqlomwp/+cn//8pvf7EwX3lrtWmN8taU/bPsJ2tVXGj9OwIA2DEGAAC4LpqsWo1Vu6lqN1Wtxqqa8+tR/s8/yagWs++VmqHUjMp+kfyNv58Ea7RptdYs1qoFWrVAa5awEADAUmS4Sq0bAACSFE1RThPl5JYd6//8IydX2Q2VFLWOi53SEq39qWwM/Pxj9UKtWqDVixgGABAEBgAA2MjJVZMOatxejdqVHevXbKCIx1dmlZZo3dKySbDkWy2eqUUztWaRSnmaAoCYYgAAQBCyaqlxezXpoMYd1KSDGrVXRlXrpjDI36Ql32jRTC2eqcXfaNFM5a2xbgKAkGMAAEDspWaoYduyw/2fj/tr1LduShTrl5UtgZ8nwZJZ2pZv3QQAocIAAIDYyMlVq15q1VOteqlJJ0W5yUIgiou0aLrmfqa5kzR3klYvtA4CAOcxAABgFyWnqmkXtepV9qNmA+sgSOuWau4kzftMcydp/lQVbbMOAgD3MAAAoAKq11XLnmVH/M27KiXdOgg7VligH7/8dQ9sWGEdBABuYAAAwF+oUlPtB6rTAWrXX3WaW9dgV638UbMmaMbbmvmeNq+zrgEAOwwAANiOpKha7KmOg9RpkFrslVC34UdJsX6Youlvacbb+mGKSoqtgwAgWAwAAPhVdiN1GqSOg9RhX1WpaV2D+Nu8TjPf04y3Nf1trV1iXQMAgWAAAPBdSrp271f2Yn+jdtY1sLPkW814W9Pf0uyPVbjVugYA4oYBAMBTmTXU7RD1OFLtBig1w7oGLtmWr1kfaPKz+vJlbVlvXQMAscYAAOCXKjW15zB1P0Id9lM0xboGbisu1Mz39PmzmvIS1w0DSBwMAABeyMpWt2HqcaTaD+S4HxVWXFh2TmDKS8pbY10DAJXDAACQyKrmlB33txvAR/MiBoqLNOsDff6cpryoTautawBglzAAACSgrFrqfri6H6m2+3Dcj7goLtK3H+rzZ/X585wTABAyDAAAiSOSpA77qv9J6jZMyanWNfBD0TZ9+bImPKCZ76q0xLoGAMqBAQAgEdRuqr3/pr1PUE4T6xT4as1iffiQPnpIqxZYpwDATjEAAIRYSpr2PEz7nKj2AxWJWNcAUmmpZn2gCQ9oyot8mAAARzEAAIRSbmf1P0l9juXzeuGozev06XhNeEALvrZOAYDfYwAACJPMGupzrPqfpKZdrFOA8lnwtSY8oE/H80kCAFzBAAAQDo3aavA56jNSKenWKUDFFW7VJ4/rjf9oySzrFADeYwAAcF3HQRpyjjoOsu4AYmHGO3r9Fs18R6U8/QIwwgAA4KiUdPUZqcHnqFFb6xQg1pZ8qzf/o4mPcaEwAAMMAADOqVFP+52m/f6uqjnWKUA8bVqtd+/Su3dq/XLrFAA+YQAAcEhuJx14tnofw8d4wSNF2zTpSb1xqxZOt04B4AcGAAB7kYi6DNHgc9RugHUKYGfWB3rjVn39OpcHAIgvBgAAS5GI9jxMR1yqxh2sUwA3LJ6p5y7XlBeYAQDihQEAwEYkoj0P1eGXqklH6xTAPcwAAPHDAAAQNA79gXJaNEPPX64pLzIDAMQSAwBAcCIRdRumwy9VbifrFCA8mAEAYosBACAIHPoDlbRwup6/XF++xAwAUFkMAADxFYmo6yE64lLldrZOAcKPGQCg8hgAAOKo4yAdcx2H/kCMLZymJy/S9LesOwCEEwMAQFw0aqfjblbHQdYdQOKa8bYeP1eLv7HuABA2DAAAMVatjo68XAPGKClqnQIkupJiTbhfz/xbG1dapwAIDwYAgJhJSdOBZ2vYP5VRzToF8En+Jr18jd74jwq3WqcACAMGAIDY6Hm0Rlyn2k2tOwBfrV6oJy/UpKesOwA4jwEAoLJa9tBxt6hlT+sOANK8yXpsrOZ9Zt0BwGEMAAC7LidXI65Tr+HWHQB+77On9eSFWrXAugOAkxgAAHZFaoYOu0SDz1FKunUKgO0pLNAbt+jFq1SwxToFgGMYAAAqrOMgnXSX6jSz7gDwV1bO14On8YkBAH6HAQCgAqrX1fG3qtcI6w4AFTHpKT16tjassO4A4AYGAIByiUTUf7SOuV5ValqnAKi4Les1/gJ9cJ9KedoHvMcAAPDXGrXV6HvUuo91B4DKmfOp7j9ZS7617gBgigEAYGdS0nXoxRp6vpJTrVMAxEJxoV65QS9exaeGAf5iAADYofYDddJdqtfSugNArC3/Xg+cqm/et+4AYIEBAGA7quZo5M3qd7x1B4B4mviYHh+njausOwAEiwEA4I/2Olxj7lFWLesOAPGXt0b3n6rPn7PuABAgBgCAX2VU0wm3q98o6w4Awfr4UT18pvI3WncACAQDAECZ3ffWaY8oJ9e6A4CF1Qt15yjN/si6A0D8MQAAKDlVR12lg8YpkmSdAsBOaYlev0XP/EuFBdYpAOKJAQD4rnEHnfG4mnS07gDghsUz9d+RWjTDugNA3PByH+CvSJIOOldXT+HoH8CvGnfQ1VM09DxOCQIJizMAgKdymui0R7X73tYdAFw1+yPdOUqrF1p3AIg11j3go77H6YaZHP0D2Jnd99YNM/g8ECABcQYA8EtGVZ18v3ocZd0BIDwmP6t7T1L+JusOADHCAAA80ri9zn5ODVpbdwAIm2VzdevhWvyNdQeAWOAtQIAv+ozUlZ9z9A9gV9RvpSs/V9/jrDsAxAIDAEh8KWk66S6d/pjSMq1TAIRWWqZOe1Sj71ZKmnUKgMrhLUBAgqvdVGc/q+bdrDsAJIr5X+nWI7RqgXUHgF3FGQAgkXUerGu+4ugfQCw166prp6rLEOsOALuKAQAkpkiSjrpK57+mrGzrFAAJp0pNnfeqjr5aSVHrFAAVx1uAgARUrY7OHK/2A607ACS6WR/o9hHauNK6A0BFcAYASDSteunaqRz9AwhCuwG67mu17m3dAaAiGABAQul/kv79obIbWncA8EbNBrpkgvqPtu4AUG4MACBBRJJ0zA06+X5FU6xTAHgmmqKT79OxNyrCYQUQBlwDACSCtEyd8YS6DbPuAOC3L1/Wf49VwWbrDgA7xVQHQq9mA106kaN/APa6HaLLJvIuRMB1DAAg3Jp20VVfqNke1h0AIIkHJSAMGABAiPFiGwAHcVoScBwDAAirg87V2BeUVsW6AwD+JC1TY5/X0POsOwBsDxcBA+ETTdFJd3LTPQAhMOEBPfB3FRdadwD4DQYAEDJVauqc59RugHUHAJTPrAm69XBtXmfdAeAXvAUICJNajXXFJI7+AYRJu/664jPVamzdAeAXDAAgNOq30mWfqEEb6w4AqKAGrXX5p2rQ2roDgCQGABAWuZ112UTlNLHuAIBdUquxLp2opl2sOwAwAIBQaN1H//5Q1epYdwBAJVSrrUsmqE1f6w7AewwAwHWdD9Q/31FmdesOAKi0zOq66G11HmzdAfiNAQA4refROvdlpWZYdwBAjKRm6NyX1Gu4dQfgMQYA4K6BJ+vM8YqmWHcAQExFU3TGExp4inUH4CsGAOCogy/Q6HsU4e8ogEQUSdLou3XIhdYdgJei7XWZdQOAPxpxnY64zDoCAOKs/b5Ky9TM96w7AM/w6iLglkiSRt+jgy+w7gCAQAw9X2Pu5WwnEKhk6wAAv4pEdMoD2vsE6w4ACNCAMUpO1d1/U2mpdQrgBxY34IpIRCfdzdE/AB/1G6XR9ygSse4A/MAAAFwx6nYNPNk6AgCMDBijE+6wjgD8wAAAnDDyZg06wzoCAEztf7qOu8U6AvAAAwCwN/waDRlrHQEADhh8jkZcZx0BJDpuAwoYO+IyHfov6wgAcEbrPook6dsPrTuAxMUAACwdcpGOutI6AgAc03ZvFRfqu4nWHUCCYgAAZoaM0zHXW0cAgJPaD1TBZs2dZN0BJCKuAQBsDDpDI2+yjgAAhx17ow74h3UEkIgYAICBgSdr1O3WEQDgvFG3aeAp1hFAwmEAAEHrNUIn3c3n3QBAuZx0l3ofYx0BJBYGABCodv3194c5+geA8opEdOpDajfAugNIIAwAIDiN22vsi0pOte4AgFBJTtXYF9S4g3UHkCgYAEBAshvpwjeVWd26AwBCKLO6LnxT2Y2sO4CEwAAAgpBZXRe+wVMXAOy67Ia8jALEBgMAiLvkVI19kZPXAFBZjdtr3Eu8kRKoLAYAEF+RiP7+sNr1t+4AgITQdh/9/RFupQBUCgMAiK8R16vXCOsIAEggvYbrmBusI4AwYwAAcTToDA09zzoCABLOQefyIcHArmMAAPGy56EadZt1BAAkqONv1V6HW0cA4cQAAOKiVS+dOV4R/oYBQHxEknTG42rd27oDCCEOT4DYq9VY415USrp1BwAktJR0jX1RtRpbdwBhwwAAYiwlXWNfULU61h0A4IFqtXnBBagwBgAQY6PvUfNu1hEA4I1mXTXmXusIIFQYAEAsHXiW+h1vHQEAnul7nA482zoCCA8GABAz7frr2JusIwDASyNvUrsB1hFASDAAgNjIydVZzyiabN0BAF5Kiuqsp5WTa90BhAEDAIiB1AyNe1FVc6w7AMBjVXN07ktKy7TuAJzHAABi4OT71bSLdQQAeC+3s06+3zoCcB4DAKisIePU+xjrCACAJKnXCB10rnUE4DYGAFApHfbVMddbRwAAfmPEdeqwn3UE4DAGALDr6jTTP55WUtS6AwDwG0lR/eMp1Wlu3QG4igEA7KJois56RlnZ1h0AgD/JytbZzyiaYt0BOIkBAOyi4dfwib8A4K5mXTXiWusIwEkMAGBXdNxfQ8ZZRwAAdmrwWHUcZB0BuIcBAFRYtTo67VFFItYdAICdikR02iOqXte6A3AMAwCoGJ5OACBEqtfVaY/wkg3wOwwAoGIGj1WnA6wjAADl1nEQb9oEfocBAFRAs64afo11BACggrhtA/BbDACgvNKz9I8nlZxq3QEAqKBois58UulZ1h2AGxgAQHn97X+q19I6AgCwS+rtphPvtI4A3MAAAMqlz7Hqd7x1BACgEvoepz4jrSMABzAAgL9Wt4VOvMs6AgBQaSfeqbotrCMAawwA4C8kRXXGE8qoat0BAKi0jKo6c7ySotYdgCkGAPAXhozVbt2tIwAAMdJiLx10rnUEYIoBAOxM/VY68grrCABATB1xmRq0to4A7DAAgB2KRHTKA0pJt+4AAMRUSrpOfkARDoLgK/7sAzu0/xlq3cc6AgAQB617a9AZ1hGAEQYAsH21m2rEtdYRAIC4GX6N6jSzjgAsMACA7Rtzn9KqWEcAAOImrYrG3GcdAVhgAADb0X+0OuxrHQEAiLP2AzVgjHUEEDgGAPBH2Q018ibrCABAIEbepOyG1hFAsBgAwB+ddLcyq1tHAAACkVFNo++xjgCCxQAAfqfPsdrjIOsIAECAugxRn5HWEUCAGADAr6rV0ajbrCMAAIEbdZuq17WOAILCAAB+Neo2ZdWyjgAABC4rmxeA4BEGAFBm937qNdw6AgBgpOfRaruPdQQQCAYAIElJUZ1wh3UEAMDUCbcrKWodAcQfAwCQpH1PVZOO1hEAAFONO2i/v1tHAPHHAACUVUtHXWkdAQBwwJFXqGqOdQQQZwwAQMOvVpWa1hEAAAdUqamjr7aOAOKMAQDfNe3C58ADAH41YLSa7WEdAcQTAwC+O+EORfh7AAD4RSRJJ9yhSMS6A4gbDnzgtT7HqnVv6wgAgGNa9VLvY60jgLhhAMBf6Vk65gbrCACAk469QelZ1hFAfDAA4K9D/6WaDawjAABOqlFfh11iHQHEBwMAnqrXUoPPsY4AADjswLNVv5V1BBAHDAB46vhblZxqHQEAcFhyqo6/1ToCiAMGAHzUpq+6DLGOAAA4r/Ng7d7POgKINQYAfDT8GusCAEBIHM1TBhIOAwDe6XygWvexjgAAhETr3uo82DoCiCkGAPwSifAZ7wCAihl+NZ8LhoTCAIBfuh+hpl2sIwAAoZLbWd2PtI4AYocBAI8kRXXkFdYRAIAQOvIKJUWtI4AYYQDAI/2OV4M21hEAgBBq0Fr9RllHADHCAIAvklN1+KXWEQCA0Dr8UqWkWUcAscAAgC8GnqKcXOsIAEBo5TTRwFOsI4BYYADAC2mZOvRi6wgAQMgN+6fSqlhHAJXGAIAXDjhL1etaRwAAQq56XR14lnUEUGkMACS+zBoaep51BAAgIQw9T5k1rCOAymEAIPENPkdValpHAAASQmYNDRlrHQFUDgMACS6tigadYR0BAEgg+5/OlQAINwYAElz/k5SVbR0BAEggWdkaMNo6AqgEBgASWTSZE7UAgNgbPFbRZOsIYFcxAJDIeh7Nvf8BALGX00Q9h1tHALuKAYBEdhA3/wEAxAf3l0N4MQCQsDoOUm4n6wgAQIJq0lGdDrCOAHYJAwAJ6+DzrQsAAAnt4AusC4BdwgBAYmreTe0GWEcAABJa233UYk/rCKDiGABITEN5+R8AEH883SCMGABIQHVbqPvh1hEAAA/sdZjq7WYdAVQQAwAJaMg4RfijDQCIv0iSDjrXOgKoII6SkGiq1dE+f7OOAAB4o98oVatjHQFUBAMAiWa/vysl3ToCAOCNlHTtf7p1BFARDAAklKSoBoyxjgAAeKb/SUqKWkcA5cYAQELpMkTZDa0jAACeyW6oPYZaRwDlxgBAQtn3VOsCAICX9j3FugAoNwYAEkdOrjoNso4AAHip4/6q3dQ6AigfBgASx4Ax3P0TAGAjksRFaAgNDpeQIKLJ6n+idQQAwGP7nKhoinUEUA4MACSIrgerRn3rCACAx2rUU9eDrSOAcmAAIEEM5OorAIA1LgVGKDAAkAjqNFeH/awjAADea7+v6rawjgD+CgMAiWDAGEUi1hEAAO9FIhp4snUE8FcYAAi9aAqX/wIAXLH335Scah0B7BQDAKG356GqVsc6AgAASVK12trzUOsIYKcYAAg9TrYCAJzCExMcxwBAuNVsoHb9rSMAAPiNtvsou6F1BLBjDACEW4+j+PRfAIBbIknqcZR1BLBjHDoh3HqPsC4AAOBPevH0BIcxABBidZqrxV7WEQAA/EmLPflAALiLAYAQ6zXcugAAgB3gSQrOYgAgxHhsBQA4qydPUnAVAwBh1aitGnewjgAAYAcat1fj9tYRwPYwABBWXF8FAHAcJwHgJgYAwopHVQCA43irKtzEAEAoNe+mertZRwAAsFN1W6jFntYRwJ8wABBKvP8HABAKPGHBQQwAhE8kop58wiIAIAz4xHo4iD+SCJ82fZXdyDoCAIByyG6oNn2tI4DfYwAgfLofaV0AAEC59eBpC45hACB8ugy2LgAAoNw687QFxzAAEDIN2qhOc+sIAADKrU4zNdzdOgL4DQYAQoaX/wEAocNJADiFAYCQ4TEUABA6XYZYFwC/wQBAmGRU5V4KAIDwadNHGVWtI4BfMAAQJu33VXKqdQQAABUUTVGH/awjgF8wABAmXAAAAAgp3sIKdzAAECadDrQuAABgl3TmKQzOYAAgNHI7K7uhdQQAALukZgM17WIdAUhiACBEeP8PACDUeCKDIxgACA3ePQkACDWeyOAIBgDCIStbLXtYRwAAUAkteyirlnUEwABAWHQcpKSodQQAAJUQSVKnQdYRAAMAYcHtkwEACaDj/tYFAAMAYcEHAAMAEkDrPtYFAAMAoVCjnurtZh0BAECl1W2hGvWtI+A9BgBCgNdLAAAJow1ParDGAEAIMAAAAAmDJzWYYwAgBLgAAACQMHhSgzkGAFyXnqXcTtYRAADESJOOyqhqHQG/MQDgupY9+QQAAEDiSIqqZS/rCPiNAQDXcaoUAJBguA4YthgAcB0XSwEAEgxPbbDFAIDToinarbt1BAAAMbVbd0VTrCPgMQYAnNZsD6VlWkcAABBTqRlq3tU6Ah5jAMBpnCQFACQknuBgiAEAp3EFMAAgIfEEB0MMADitFTdKAwAkIp7gYIgBAHfVbKBqta0jAACIg6o5ym5oHQFfMQDgriYdrQsAAIibJnzOPYwwAOCuXB4ZAQCJK5fXuWCEAQB3MQAAAAmMMwCwkmwdAOwQj4xA5RVu1eb12rJB+RvL/rl1k/I3qWCzCjZrW7625atwqwoLVLRNSUlKTlVymlIzlJqh1EylV1F6ltKylFlNGdWUWb3sn5k1lBS1/t8GhByvc8EKAwCOSklT/VbWEYDDigu1YYU2rNDGVWU/Nv38z9XKW6vN65S3VnlrVbg1Lt89ElFGNVWpqaxsVamprFqqVrvsR9VfflKjnqpkKxKJSwCQAOq3Ukp6vP6SAjvBAICjGrVTlD+e8FtpqTas0JrFWrNYa5do3VKtX6b1y7VumdYvU94alZZatm3ZoC0btGrBzv615FRVr6sa9VWjnmrUV836ym6oWo2V3Ui1GiujWkC1gJuSomrUTvO/su6AfzjCgqM4MQp/FBdq1UKtWqBV87VyvlYtKDviX/uTigut4yqnaFvZgNmujGqq1UjZjVWrseo0U51mqt1UtZupRr1gKwE7uZ0YADDAAICjuAcoElL+Ji2fp2VztXyeVvxQdsS/9ieVlliXWcjfqCXfasm3f/z11IyyJVCnmertpvqtVK+VajflrCASEK92wQSPpnAUVwAj7EqKtfx7LZ2tZXPLjviXzdX65dZZYbAtXz/N1k+zf/eL0RTVaaZ6LVW/leq1VIPWatRO1esaJQIxwqtdMBEZLrv3kAI7dt9qZdWyjgDKraRYK37QkllaMktLvtWSWVo2R4UF1lmJLitbjdr98qMtkwDhs3mdRmdbR8A/nAGAi7IbcvQP121epwXTtHCaFnythdM53LeRt1bfTdR3E3/9laxaatxOTbsot7OadlbDtkpOtesD/kqVmqrVeIfXyQBxwgCAi3j/Dxy0euGvR/wLpmn1QusgbE/eGs3+WLM/LvuPyalq2FbNuii3c9kk4NZDcE2TjgwABI0BABdxURRckLdWP3yh7z/X95/r+y+Ut8Y6CBVXtE0Lp2nhtLL/GImoXkvt1r3sR24nRVNM+wApt5O+ft06Ap5hAMBFDVpbF8BLPx8slh3xf67l31sHIdZKS8uuyZ74mCSlpKlpl7Ix0GIv1W1h3Qcv1ecpD4FjAMBFtZtZF8Ab+Rs1d5Jmf6zvPtYPU1S0zToIASos0LzJmje57D9Wq63WfbR7P7Xpp9xOSoqaxsEbdXjKQ+AYAHARj4aIq42rNOeTsoP+hdNVUmwdBDdsXKUpL2rKi5KUUU2tepWNgRZ7ciUx4oinPASP24DCOcmpejRfkSTrDiSWLev1zfua+Z5mf/THG8wDO5eSrt26q11/ddhPu3XnzABirLREx2dw+hGBYqkcWP0AACAASURBVADAOfV2063zrCOQEIqL9P1kzXhHM9/VD1N4pR8xkFld7Qaow37quD/XDCBmxrbWsrnWEfAJbwGCc7gAAJW0bK5mvqsZ7+jbCcrfZF2DxLJlw69vE6rTTB32V8f91X6AMmtYlyHMajdjACBQDAA4p05z6wKEUHGRvvtYX76sr17RqgXWNfDDyvl6/x69f4+SomrZU10PVrdDVL+VdRZCiMsAEDAGAJzD4yDKL3+jpr2pr17R129oy3rrGviqpFhzPtGcTzT+fDVora6HqNshatmDa5lQXjzxIWAMADiHx0H8pTWL9dUr+vJlffuhiguta4DfWDpHS2/QqzeoWh3tcZC6HqwO+ykt0zoLbuO9rwgYAwDO4XEQO7J2iT57WpOe0o9fWqcAf2XjSn34oD58UKkZ6jxYvUeoyxClpFtnwUm88oWAcRcgOOfeVaqaYx0Bl2xcpc+f06QnNecTlfKIhdDKqKpuw9RrhDrspyivv+E38tZqTC3rCPiEAQC3ZFTVgxutI+CG/I2a8qI+fVKz3ldxkXUNEDtZtdT9CPUeoTZ9uU4AZU6srnye/hAUXoKAW3j/D4qL9PVr+vhRTXtDhQXWNUAc5K0pu31QdkP1PFp7/02N21s3wVqdZlo43ToC3mAAwC28D9Jny7/Xhw/oo4e1frl1ChCItT/p9Vv0+i1q2UP9R6vn0UrPsm6CkdoMAASIAQC31G5qXYDAFW7VFy/og/s0+yPe4g9PzZuseZP16NnqOVwDx6jFXtZBCBxPfwgSAwBuqVbHugABWjRDH9yvTx7X5nXWKYADtuZpwv2acL8ad9CA0ep7nKrUtG5CUKrz9IcAMQDgFu7/44PiIk1+Rm/eph++sE4BnLR4ph45S+MvUI8jNfgcNe1iHYT44+kPQWIAwC08Aia2Lev1/r166w6tXWKdAjivcKsmPqaJj6ntPhoyVl0OUiRi3YS44ekPQWIAwC08AiaqFT/ozf/ow4dUsNk6BQibbz/Utx+qXksNPlv9TuBzhRMTT38IEgMAbqnKJ6EknO8m6vVb9NUrKi2xTgHCbPk8PXi6nrlEA0/RoDNUs4F1EGKKAYAg8UFgcMvdy1W9rnUEYqG0VFNe0MvX6ccvrVOAhBNNUa/hGnaxGrS2TkGMbFylU7gOGEFhAMAhkYge26Yo56XC78uX9Nxl3NMaiK+kqHofo8MuUb2W1imotJJijUzhVsgICB9BDodkVOfoP/SmvqZ/dtXNh3L0D8RdSbEmPqZxu+vuv2nlj9Y1qJykqDJrWEfAGwwAOKQa74AMs2lv6l976cahmj/VOgXwSUmxPnpYY1vr3tFatcC6BpXAZQAIDAMADuGxL6RmvKN/99T1g/XDFOsUwFfFRZrwgM5ppftP0epF1jXYJTwJIjAMADiEx77QWTxTVw3QtYM0b7J1CgCpuFDv36tzWurJC5W/yboGFcSTIALDAIBDeOwLkbw1evB0XdhFsyZYpwD4vaJteuV6jW2ljx/hotIw4X2wCAwDAA7J4kMAwqCkWG//V2e31Lt3qqTYugbADqxfrrtO0CXdOUEXGrwKhsAwAOAQHvvc9837uqCTHj5Tm9dZpwAohx+m6NJeuvN4rVtqnYK/wpMgAsMAgEP4GGCXrfxRNx+qq/fVklnWKQAqorRUEx/T2NZ6+VoVFljXYMeysq0L4A0GABySkm5dgO0pKdYr1+vctvryJesUALtqa56e+qfO76A5n1inYAd4EkRgGABwSEqadQH+5KfZ+ncvPXkhLxwCiWD5PF2+tx4bq2351in4k2SeBBEUBgAckpxqXYDfKCnWqzfqoj30wxfWKQBip7REb9yqCzpp7iTrFPweT4IIDAMADuHFD3csnaPL+mj8+Srcap0CIA6Wz9NlffX4ufwddwinwREYBgAcwosfLigt0es368LO3DoQSHD8ZXcNT4IIDAMADuHFD3Mrf+RFQcAvS+fo0t4af4GKC61TvMdpcASGAQCH8OKHramv6aKuvC0Y8E5piV69QVfsw2cFGONVMASGAQCH8OKHldISPXOJbjpYW9ZbpwAwMneSLtpDsz+y7vAYr4IhMAwAOITHPhN5a3TdgXrxKpWWWqcAMLVhha7eV6/fbN3hK14FQ2AYAHAIZz+D9+OXuqirZrxj3QHADcVFevxc/edI5W+yTvEPr4IhMAwAOIQXPwI24X5d1kerF1p3AHDM58/pX3vpp9nWHZ7hVTAEhgEAh/DiR2CKC3XvaN07hs/3BbB9S7/Tv/bSFy9Yd/iEJ0EEhgEAh/DiRzAKNuuGoZrwgHUHALdtzdN/jtS7d1l3eIPT4AgMAwAO4cWPAOSt1dX7asbb1h0AwqC0RA+epheutO7wA6+CITAMADiEARBva3/S5f341E8AFfPsv/XwP7hRWNxFU6wL4A0GABxSUmJdkNCWzdWlvbVklnUHgBB6+w79bySfFhxnTCwEhQEAh5QUWRckrvlTueEPgEr5dLxuOkQFW6w7EldJsXUBvMEAgEOKeG0pPmZN0JX7aOMq6w4AITftTV2znzavs+5IUDwJIjAMADikMN+6IBHNmqDrD+QzfQDExtxJumqg8jdadySi4m3WBfAGAwAO2cYAiLWF03TzMG72DyCWFnzNA0tc8FuKwCRbBwC/YgDE1sofde0BvFD3R1nZqtlQGVWVXlXRZG3dpPxN2rRaa5dwkxMoJU21myqjujKqKjVD2/KVv0n5G7RqAQdnvzNrgv43Umc9rQgvJMYOT4IIDAMADtmaZ12QQDau1DX7a8MK6w4HZFZXm35qP0DN91SD1qqas/1/rWCLls/VwumaNUHfTtDqRcFWwkhSVM32ULsBatNXDXdX7abbP6ItLdGqBfpptr6bqFkfaP5UrtfU58/poTN04p3WHQmEC6wRGAYAHMIAiJX8TbruQK34wbrDVFqmug1T3+PUYT8lRcv17+d2Vm5n9RslSYtmaOJj+nS81i2NdylstOyhvser59HKyv7rfzmSpDrNVae5ugyRpLy1+uxpTXzU90/VePcuVa+nw/9t3ZEouBAOgYkM566zcMZ5r2qPg6wjwq9om64frG/et+6wUzVHg8/R/qcrs3plv1RJsSY/q5eu0eKZsSiDA5Ki6nGUhl2kxh1i8NUWz9RL12jys16fEBh9twaeYh2REGZ/pCv2sY6AH3jvHhyylTvVVFppif53nL9H/2mZGn6N7lioYf+MwdG/pKSoeg3X9dM19gXVaRaDLwhb3Q7RzbN15vjYHP1LatxBZz6pm2er2yGx+YJh9MBp+uIF64iEULDZugDeYADAIVs2WBeE39P/0uRnrCOMdDtEN83WIRcpLTPGXzkS0Z6H6sZZOvRfiqbE+IsjGLWb6vzXNO4l1WsZ+y9er6XGvaTzX1PtprH/4u4rLdF/j9GCr607wo/3wSIwDAA4hAFQSTPe0SvXWUdYiCRp5E0a95JymsTxu6Rm6Kgr9a/3Va12HL8L4qHDvrp2atnb9+OnyxBdO1Ud9o3vd3FTYYFuO5rPG6ksBgACwwCAQxgAlbF+uf53nI83ssysrvNf05BxAX27Nn111Rdq0jGgb4fKO+AfuvAtVakZxPeqUlMXvqVBZwbxvVyzfJ4eONU6IuS4azMCwwCAQxgAu6y0RP8bqY0rrTsCV6+lrpyszgcG+k1rN9Xln6rbsEC/KXZBNEUn36dRt5XrNlCxkhTVCbdrzL0+vlvs0/Ga8IB1RJhxCgWBYQDAIVvWWxeE1kvX+Hjhb8ueuupzNWhj8K3TszT2BQ0Za/CtUU5pmbr4PfUfbfPdB4zRxe/F/nIU9z3yDy351joitDgDgMAwAOCQvLXWBeH03UQ9d5l1ROBycnXuywG9r2O7IhEde5P2OtwsADsRiei0R7V7P8uG3fvptEcViVg2BK9gi247ik+03UUMAASGAQCHbF5nXRBCeWt0xwjv7kGeVkXnvWJ/MW4kotMeUW5n4wz82eGXObHN9jpch19mHRG4JbP08D+sI8JpM6fBERQGABzCANgFd52gtT9ZRwQrEtEZj7tyGW5aFZ37sqrVse7Ab/Q4SoddYh3xi8MuUY8jrSMCN+F+TXrKOiKEuBAOgWEAwCEMgIqa/IymvmYdEbgjr3TrAtycJhr3opJTrTsgSWq2h059yKE33kQiOvVhNdvDuiNwj5zF4WyFcSEcAsMAgEPy1vp4F8tdti1fT5xnHRG41n106MXWEX/SqpdDLzn7LDlVZz7p3KW3aZk6Y7x3E3HjSh+vTaokJhMCwwCAQ0qKlc/DX7m9cp1WL7KOCFY0WSfdaR2xA0PPV/1W1hHeG3qeo/9faNBaQ/2b6+/8Vz/Nto4IFU6DIzAMALhl42rrgpBYvVCv3mgdEbj9TlPjDtYRO5CcquP/Yx3ht+xGGube2aH/N+xiZTeyjghWcZEeOcs6IlQYAAgMAwBuyVtjXRASj43z7kZ7KWk65ELriJ3qfKBa7GUd4bGDz1dqhnXEjqVm+HgSYOa7+vIl64iQKNisom3WEfAGAwBu2cQZgHKY9YG+eN46InD7nKga9a0j/oqD1yd4onpds8/8Kr8BY3y8YdRj41RYYB0RBrz8jyAxAOCWTZwB+CslxZ6eVT/wbOuCcthjqOo0t47w0sCTnX75/2epGdr3FOuIwK38Ua/dZB0RBnwUJoLEAIBbNq2yLnDeu3dq8TfWEYHbrbujF3f+QSSivsdZR3ip7/HWBeXj5x+Pl6/V2iXWEc7j9S8EiQEAt2xkAOzUtny9cJV1hIV+ITm8k69HeLZa9lS93awjyqdeS7XsaR0RuILNeuka6wjnbeYMAALEAIBbNq60LnDbhAc8/S3aY6h1QbnVbaFGba0jPNM1PH88FLbaWPnwIa1fbh3hNs4AIEgMALiFMwA7UVyo1/y79aekerupVmPriIpoN8C6wDPh+g0PV22sFG7VG7dYR7iNm+AhSAwAuIUBsBOfjvfuk79+1ra/dUEFhS441DKqqnk364iKaN5NGVWtIyy8dzc3utkZzgAgSAwAuMXP97eUk7d30sjtZF1QQaELDrVG7ZUUtY6oiKSoGrWzjrCQv0nv32sd4TDugYEgMQDglg0MgB2Y84mPN//5WYM21gUVVLupUtKsI7zRoLV1QcXVD2FzTLx/j0pLrSNctZGPwUGAGABwS8FmFWy2jnDSe/dYF9gJxQ1AfyspqrotrCO8Ebo/HgrnaImJlfM18x3rCFdxBgBBYgDAOdwp4s/y1ujzZ60j7FSrbV1QcVVD2BxSYfzjEcbmWHn3busCV23iDAACxACAczassC5wz0ePqLDAOsJINFkp6dYRFefnVZ4m0kP4Wx3G5lj5+jWtX2Yd4STugYEgMQDgHAbAn3063rrATkgPlUKaHUZh3FrpWdYFdoqL9NnT1hHu2ZavrXnWEfAJAwDOYQD8wcofNf8r6wg7JUXWBbskpNlhVBzC3+qSYusCU589Y13gHu6Ah4AxAOAcrgH4A8+fLLduDuVtQ/I3WRd4I4yvm3r+x+P7yVqz2DrCMdwBDwFjAMA5vD30Dzw/XV5aEsobQ231+wgvSGH8rQ5jcwyVlmqyx3c12C7OACBgDAA4Zx0D4DdWztfCadYR1tb+ZF1QcWFsDqk1S6wLKo4/HlNesC5wDGcAEDAGAJzDGYDf4p7ZkpbNsS6ooMKtWr3IOsIbofvjoXA2x9b3nyt/o3WES7j4DQFjAMA5DIDfmvGudYEDlobtaGn5PJWWWEd4I3R/PCT99J11gbXiIs36wDrCJQwABIwBAOdsWBHKiz7joaSY50hJ+uEL64IK+j5swaH207chuw54a56WzraOcACvbvzWBu5+gWAxAOCc4iI+Eb3Mj19q8zrrCAfMmhCyTchsC1Jxkb6baB1REd9NDOWtS2OO9zf+Fre/Q8AYAHAR1wH/bPbH1gVuyFujRdOtIyqCARCwcP2Gf/O+dYEbln/PUe+v+K1AwBgAcNE672+R8bMfp1gXOOPz56wLym3OJzyXB+2L50Nzjqi0VF88bx3hDB7i/h8PGggYAwAu4h55P/uBZ8dfTHw8NEd4Hz9qXeCflfM15xPriPL5bqJWLbCOcAZXy/yssEBb1ltHwDMMALiIASBp02oOFH61eqG+/dA6ohwKtvAJRzY+eti6oHw+fti6wCW8xvEz7n2H4DEA4KJ1S60LHMBT4x+8eoN1QTl8cC+v5Nn49IkQPG6s/UmfPGEd4ZIfv7QucAMDAMFjAMBFnAGQtHimdYFjpr+l+V9ZR+xU0Ta9dpN1hK8KC/TqjdYRf+W1m1S0zTrCJXlrOPaVeM0LFhgAcBEXAUtaNs+6wD1PXWxdsFPv3sl2tfTBvU5/APPqRXr/HusI9/BAJwYALDAA4CKOoiQt53nxT2a87e4dVNYv07OXWkf4rWCLHj3bOmLHHjlL2/KtI9yzfK51gQO48zWCxwCAizatVuFW6whry3he3J5Hz1H+JuuI7Xn0HOVvtI7w3pQXNfU164jtmfqavnzJOsJJnAEQZwBggQEAR61ZYl1gamseb43dvjWL9d9jVVpi3fF7b9+hz562joAk6a5RWvGDdcTvrfhBd42yjnAVr3SId73CAgMAjlqz2LrAlOf/83du6qt66p/WEb8x8z09eo51BH6Rt1Y3DnXobEz+Rt04VHlrrTtctcbhyzYC4/kLXjDBAICjPD8C3rjSusBtr1yvTx63jpAkLZ+n245SSbF1B37jp9m6fYQTp4lKS3T7CP0027rDYRt4rJPWMgAQOAYAHOX5AyJPin/p3tH6/nPjhi0bdONQbV5nnIE/m/aGxl9gHSE9cb6mvWEd4bZNq6wLrG1Zr6151hHwDwMAjuIMAHausEA3Hqx5n5kFbFyl6wdr6RyzAOzcazfp+SssA56/Qq/fbBkQCoUF2rLBOsIU7/+BCQYAHMUAwF/auFJX9tfHjxh864XTdfGemjvJ4Fuj/J67VLcdrYItQX/fgi267Wg9x21hy8fzhzvPT3fDCgMAjvJ8AHDJYDkVFuiuE/TEeYG+4fuLF3Rpb61eGNx3xC6b/Iwu7xvoMdbaJbq8ryY/E9x3DDvPH+48f7KDFQYAHOXyJ3oGYJv3H4NQIa/dpBsOCuKNBKWleuFK/ecIFWyO+/dCrMyfqov3DOjdYnMn6Z/dNH9qEN8rYXj+qS+cAYAJBgActWW9QzfyC15RgXVB2Ex7U+N216Qn4/gtFnytS3vp2X+rtDSO3wXxsH65LuurR86K46NK/kY9cpYu76cNK+L1LRJVod8Pd1wDABMMALjL57dYeP6MuGvWL9Mdx+iqAZrzaYy/8upFeuDvunhPzZsc46+MwJQU663bNba13r8nxn+/Cgv0/j0a21pv3c4NYXeF5693cAYAJpKtA4AdWr1IjTtYRxjx/BmxMmZN0Kw+2n1vDT1PnQ5QUrRSX23RDL15myY+puLCGPXB1Prluv9UPX+FhozT3qOUVatSXy1vjT56RK/frHVLY9TnJc9f7+AaAJhgAMBdPp8BKNpmXRBysz/S7I9Uo556H6O9DleLvRStyKPd0jn6+jV9/KgWzYhbIuysW6rHx+mpi9R5sHofo/YDlZVdgf963lp9874+Ha9pb/BXNQY8/z3kDABMMADgLp+vA05OtS5ICOuX6/Vb9PotSs9Sm75qsZcatFb91spuqPSqSsuUpMICFeRp4yotm6ulc7RoumZN4AVdLxRt05cv6cuXFElSbie16atGbVW/teo0V2Z1pWcpKaqSYm3N05YNWvmjls3Rkm/13UQtnO7ExwwnjGiKdYGd/I3K32QdAS8xAOAun88ApGZYFySWrXma9qamvfm7X4wkKSnKe3ug0hIt+FoLvv7jr6ek+f7ulGCkpFkX2PH5aQ62GABw1yqPHxkZAAEoLVExr+Nixzj6D0ZKunWBnVULrAvgK+4CBHetmm9dYCc107oAAALBAACCxwCAuzas8PcDYjgDAMATqQwAIHAMALirtNTfB8cK3ZMEAMIro5p1gR1vn+NgjgEAp6309V1AtZpYFwBAIGrUsy6wwwCAFQYAnObtg2OtxtYFABB/KenKrGEdYcfb5ziYYwDAad5eB5zDGQAAHqhZ37rATv4m5a21joCvGABwmrdvAcpuqAh/OwEkuhoeD4DVC6wL4DEOMeA0b0+PRlNUO9c6AgDiLLuRdYEdb5/g4AIGAJy24gfrAjvNuloXAECcNdzdusAOAwCGGABw2uZ12rLeOsIIAwBAwmvUzrrADgMAhhgAcJ23JwGa7WFdAABx1ri9dYEdBgAMMQDgOm8HQHPOAABIaMmpqtfSOsIOAwCGGABwnbcDIKuWGnewjgCAuGnUTtFk6wg7K360LoDHGABwnc8PkV0GWxcAQNzs3s+6wE7eGn+vcIMLGABw3UpfzwBI6swAAJC4dt/busDO8u+tC+A3BgBc5+1bgCS16qXM6tYRABAHkYjXZwCWz7MugN8YAHDdmiUqLLCOMBJN5iQAgMTUqL2yallH2OEMAGwxAOC60hKt8PiBcp+/WRcAQBx0HWpdYMrn5zW4gAGAEFg217rATvuBysm1jgCAWOtxpHWBKc4AwBYDACGwdI51gZ1IkvY+wToCAGKqbgvldraOMMU1ALDFAEAILPf4DICkfU70+lbZABKP5y//b16nvLXWEfAbAwAh4PNbgCTlNFGfkdYRABA7/UZZF5ji/T8wxwBACHg+ACQN+6eSotYRABALHfZVgzbWEaa4AhjmGAAIgY2rfP/ExHot1fNo6wgAiIX9z7AusLaMCwBgjQGAcPD5OuCfHfZvRVOsIwCgcnJyfb8BqDgDAAcwABAOvAuoQWsNGWsdAQCVc8iFinh/6ME1ADDHvUUQDgwASYddok+e0Nol1h0IobRMVaujrGylV1V6ljKqKi1L6VWUlKxosqLJZT8pLVVJkYqLVFykkiIVbdPWPOVv0tY8bd2k/E3atEqbVqu4yPp/D8KpTnP1P8k6wgHcAxTmGAAIBwaApLQqOv5W/cfv2+dhJ1IzVL+16jRTTq5q56pWE9VqrOp1VLW20jJj9l1KS7V5nTau0oblWr1Iqxdp9UKtXqjl87RqoUpLYvaNkHiOvJy3MipvjTatto6A9xgACAcGwM+6H6FeIzTpSesOOCApqgZt1GwPNe2ihrurQRvl5CoSifv3jUSUla2sbDVo/cf/U+FWLZurpd9p8TeaP1Xzp2r9srj3ICxyO6n3MdYRDvhptnUBwABAWCyfp9LSIA5u3Df6bn0/WSvnW3fAQloVte6jtvuo7d7K7azUDOug30tJV5OOatJRPY4q+5X1y/XDF5o1Qd9+qEXTVVpq2gc7kSSNvod3/0sMALiBAYBwKNisdT8pu5F1hwMyqumM8bq8L+/D9kVaplr1Vtt91K6/mu8Zso+FrlFPXQ9W14MlKW+tvvu4bAwsnskY8Mv+p2u37tYRbmAAwAWheiaB35bNZQCUadlDI2/WI2dZdyCeatTXnoeq++Fq0zdB3jadla1uw9RtmCRtWq2pr+mL5zXzXRUWWJchzmo11tFXW0c4gwEAFzAAEBrL5qrdAOsIZxzwDy3/Xm/fYd2BWMtpoj0PU/fD1apXIr9fomqO9j5Be5+g/I1lS2D6WyrYYp2FOIgm64wnlFHVusMZDAC4gAGAcEhJV9Uc6wjHHH+rVv6or1+37kAsVM1Rn5HqfYxa7GmdEqyMaup9jHofo4ItmvaGPn5U095QSbF1FmLnqKvUpq91hDMKNmvNIusIQIoMF2/DhOs67KcT71S93aw73FOwWdcdqO8mWndgV0WS1HF/9T9JXQ9Wcqp1jRvWL9NHj+jDB7lXeiLoMkTnvcr9G341f6r+2dU6AmAAwHE16um4W9RrhHWHw7bm6frBbIDwqdNM+5yovU/gypYd+m6iJjygz5/lrUFhldtJl36sjGrWHS755An9b6R1BMAAgMv2OVHH3aLM6tYdzivYrOsHa/bH1h0on/YDdeBZ6jIkkd/iH0Ob1+mD+/XOf7WaN06ESk6urvxMNepbdzjmmX/pRa6HhgMYAHBRzQY6+T51HmzdER7b8vW/4/TF89Yd2LHUDPU+VgeepcbtrVNCqKRYU17Um7dpzifWKSiHarV16cdq0Ma6wz23Hq4vXrCOABgAcFDf4zTqNlWpad0RNqWlevJCvXqDdQf+JLuh9j9dA09WVi3rlPCbP1Vv3aZJT6lom3UKdqBGfV38nhq1te5w0rltuQsQnMAAgEOq1dGYe9XtEOuOMJvwgB46Q4VbrTsgSWrZQwecpe5HhOzTu9y3YYXevUvv3a0NK6xT8Hs5TXTx+9yzYfuKizQqU8WF1h0AAwDuaD9Qpz+uGvWsO8Jv4XTddpSWzbXu8Fg0Rd2P0OCz1WIv65SEVrRNk57Sm//Rgq+tUyBJatpF573Cde07tPQ7jdvdOgKQxACAC5KiOuJyDbuIayJjZmueHjxNEx+z7vBPtdoaeLL2O001G1in+OS7iXrzNn35Eh8gYKnHkTr1YaVlWnc47IsXdOvh1hGAJAYAzNVqrDOfVOve1h2JaOa7evB0bqYekKZddMA/1GuEUtKsU3y1ZrHe+Z8+uE95a61TPJOcqiMu18EXcL//v/DcZXr+cusIQBIDALa6HqxTH1JWtnVH4ios0CvX6+VruSogXqLJ6jZMB56l1n2sUyBJ2pavT5/Qm7dr8UzrFD8066q/P8y9rcrllsM05UXrCEASAwBWIkkafo0OvsC6ww8rf9RDZ2jam9YdiaVWY/U/Sf1P4h3Pjpr9sT64V58/z/qNl5Q0HX6php6vpKh1SkicvZtW/GAdAUhiAMBEZnWdOZ7b/Aftixc0/nyefiormqw9hmrAGHUaxFUrIbB5nT55XO/fxwmBGGuxl059iHt9VsDWPJ1YTaUcc8ENDAAErUFrjXtZDVpbd3ippFiTn9Er12vhdOuU2CA+EAAAIABJREFUEKrXUv1P0t4nqHpd6xRU3Pef64P79NnT2ppnnRJyNepr2EXa7zRe+K+YeZ/p372sI4BfMAAQqM4H6swnlVndusN7097UK9dp9sfWHWGQ00Q9jlLPo9W8m3UKKm1bvqa9oc+e1tevq2CLdU3Y1Gyggy/QwJOVkm6dEkLv36P7T7WOAH7BAEBwhp6vEdfyrgmHzPtML1+nqa+ptMQ6xT01G6jHkep5tHbrwb1NElDBZn31qj57WtPfVGGBdY3zshvq4As0YAyH/rvuwdP07l3WEcAvGAAIQjRFpzygvsdZd2B71i3Vp+M18TEtmmGd4oD6rdRliLoNU5u+HPd7IX+jvnpFX72qGe9oy3rrGvc020MDxmjvv3F/28q6rI/mfGodAfyCAYC4S8/SOc+p4yDrDvyVRTP0yeP65AmtW2qdEqz0LLXpp47/1959R1dV5n0b/4ZQpEhRQIVRASsq9l5w1GcYZHREnNcyOrZRxzJjr+NjL4iCBUdFsAsqgjQFRFAR6V16KKGFEEJIQno7Oe8fj44oAXOSc/Lb976vz2Kx/GOGXLNGl+d79r337qbj/qR9D7augZFIhVZO04JxWjJJ6xb6flms5X4680p1vYbne8ZHNKq/t1RxnnUH8BMGABKreRs9MI7D0y6JVmrZZM3/QosmKG2ZdU3CNN5TB5+izmfryHN10MlKrm8dhCApyNayyVr6jVKmasNij8ZAo6Y6/gJ1vUZHd+Me33jKXKs7OllHADtgACCB2nbUQxO07yHWHaip7DT9MEGLJmjxJBXmWNfUTr1ktTtMHU/QIafp0NO1/1F8vkG1FOdr9SytnK7Vs7RugXI3WwfFW1I9dTxeXf6go7vp0NNVv6F1UBjNHa1+Pa0jgB0wAJAoBx6rB8er5b7WHYiHyojWLdCa2Vo9W6lztGmFA9+JNm+r9p3VvrMOPEYdjtMBR6thY+smuG/7Fq2dr3ULtHGJNi1XxkonnyZUv6H2P0qdTtSR56rL/6jZ3tZBYTfiKQ171DoC2AEDAAlx5Dm6Z5QaN7fuQGIU5yt1rlLnatMypadoc4oKss1ikuqpVTu17ag2HdS2o1p3ULvD1L6zmrYyS4I/olFlrdem5dqyWlvXKXPtj78H7X7iPVtrv0PV4Th1PF4djtP+Rym5gXWTT176i2Z/Zh0B7IABgPg7uZf+9THXkf2St1WbU7R5lbLTlL1JOZuUvUnZm1SwTZWRmv+xyfXVuIWatVLTvdS0lZq1UtNWarGPWu6rlvv9/DsfZRA0xfnK3azczcrN+PH3/CwV5qggW4U5P/4qKYjne2HrJavZ3mreRnu2VvM2armv2nZS245q20ltOqrxnnH7QaiBuw5VxirrCGAHDADE2WmX6bbB3FKJH0WjKt6uwlwV56m0UKVFqihTZYWiUdVL/uWv+qrfQA0bq2ETNWry4+98ske4lRWrrFhlRSotUlmRyooVqVBl5Ne//uu//7wk11eDPdSoqRo1UaOmatRUjZvz4NqAKinQ9S0cODYJr/AxDfF05pW65X3urcTPkpLUpKWatLTuAAKpYWM1bCztZd2BRFo7n0//CBxeyoq46XqNbv2AT/8AAPwsda51AbATBgDi48wrdfM7SuJvKAAAdpA6x7oA2Amf1xAHJ1+iW97n0z8AAL/GFQAEEB/ZUFvHX6DbP+bkDwAAv1aUqy1rrCOAnTAAUCtHnac7h/OoFgAAqrBmbjwf9grECwMANdfxBN09Ug0aWXcAABBI3ACAYGIAoIb2PUQPjuPlMgAA7BI3ACCYGACoiZb76aEJat7WugMAgABbwxUABBIDADFrvKceHK+2Ha07AAAIsLxMbdtoHQFUhQGA2NRL1u1DdeAx1h0AAAQbX/8jsBgAiM01r+jY860jAAAIPG4AQGAxABCD8+9Qt9usIwAAcAFXABBYDABU1/EX6G8vWkcAAOAIrgAgsBgAqJZ2h+mfQ5TE3y8AAFRD1gZt32IdAewCH+jw2xo31z2j1Li5dQcAAI5ImWpdAOwaAwC/ISlJ/xysdodbdwAA4A4GAIKMAYDfcMnjOv5C6wgAAJySMs26ANg1BgB255ju6vWIdQQAAE4p2q6NS6wjgF1jAGCX9mqv2z5UUpJ1BwAATlk5XdFK6whg1xgAqFpyfd3+ifZsbd0BAIBruAEAAccAQNUufVqHnWkdAQCAgxgACDgGAKpwTHddeL91BAAADoqU8w5gBB0DAL/WbG/d/C5H/wEAqInUeSorto4AdosBgF+7caBa7msdAQCAmzj/g+BjAOAXul6jk3tZRwAA4CwGAIKPAYCftT5Q1/a3jgAAwGW8AgzBxwDAj5Lq6db31bi5dQcAAM5KT1F+lnUE8FsYAPjRn+5W57OtIwAAcBnnf+AEBgAkaf+jdOnT1hEAADhu+XfWBUA1MACgpHq66S01aGTdAQCA4xZPsi4AqoEBAHW7TQefYh0BAIDj0pYqd7N1BFANDADf7fU7XfaMdQQAAO5bPNG6AKgeBoDvrn9Njfe0jgAAwH2c/4ErGABeO/kSnfBn6wgAANwXKecOYDiDAeCvJi103avWEQAAhMLKGSopsI4AqocB4K+/9lHL/awjAAAIhSWc/4E7GACeOvgUnXuTdQQAAGHBHcBwCAPAR0lJuuYVJSVZdwAAEApF27VmjnUEUG0MAB+deRUP/gcAIG6WfavKiHUEUG0MAO80aqornrOOAAAgRHgAKNzCAPDORQ+pVTvrCAAAQoQbAOAWBoBf2nTQBfdYRwAAECJZG7R5pXUEEAsGgF+ufEEN9rCOAAAgRPj6H85hAHik89k65S/WEQAAhMu8MdYFQIwYAL5IStLVL1lHAAAQLqVFXAGAexgAvjj1UnU4zjoCAIBwWTxRZcXWEUCMGABeqJes//ekdQQAAKEzd5R1ARA7BoAXul6j/Q61jgAAIFwqI5r/hXUEEDsGQPjVb6hLHrOOAAAgdFZOV36WdQQQOwZA+J33D7U+wDoCAIDQmTvaugCoEQZAyDVqoosfto4AACCMuAEAjmIAhFz329ViH+sIAABCJ22ptqyxjgBqhAEQZk1a6ML7rSMAAAgjzv/AXQyAMDv/TjVtZR0BAEAYMQDgLgZAaDVqqu7/so4AACCMctKVOsc6AqgpBkBonXujmu1tHQEAQBjNG6No1DoCqCkGQDglN9Cf7raOAAAgpGaPsC4AaoEBEE5nXqm997eOAAAgjPIytfQb6wigFhgAIZSUxMN/AABIlJnDVBmxjgBqgQEQQif2VPvO1hEAAITU9I+tC4DaYQCE0EUPWhcAABBSWRu0crp1BFA7DICwOfIcHXSydQQAACE14xOe/wPnMQDC5s8PWBcAABBe0zj/A/cxAEKl3WHq0s06AgCAkNq4ROsXWkcAtcYACJU/3KqkJOsIAABC6rt3rQuAeGAAhMcezXT2tdYRAACEVKRC3w+2jgDigQEQHmdepcbNrSMAAAipheOUl2kdAcQDAyA8ut1mXQAAQHh99551ARAnDICQ6Hy29j/KOgIAgJDKz9L8L6wjgDhhAITEH/9pXQAAQEilp+jxMxUpt+4A4oQBEAZ7tdeJPa0jAAAIqe8/UHqKdQQQPwyAMDjvH0qubx0BAEAYRaOaOsQ6AogrBoDzkuvrvJusI+Jh+RRerg4ACJwV3ytrvXUEEFcMAOcd20Mt9rGOqLVoVEPutY4AAGAn339oXQDEGwPAeV2vsS6IhxlDtWaOdQQAAL9UXqJZw6wjgHhjALit2d46/gLriFqrKNPQf1tHAACwk3mfq2i7dQQQbwwAt51xheo3tI6otQmvKnOtdQQAADvh/A9CiQHgthCc/ynarpHPWEcAALCT/Cz98KV1BJAADACH/e4IdTrROqLWxr2kwhzrCAAAdjJjKC//QjgxABzW9VrrglorzNH4l60jAACoCud/EFYMAFfVS9ZZV1lH1NrYftxcBQAIorRlWj3LOgJIDAaAq47uppb7WUfUTsE2fdnfOgIAgKp8/aZ1AZAwDABXheD2389fUHG+dQQAADspK9aUD6wjgIRhADhpj2Y64c/WEbVTmKOvXrOOAACgKjOGqijXOgJIGAaAk47toYaNrSNq56vXVVJgHQEAQFUmDbAuABKJAeCkU/5iXVA75SWc/gcABNT6H7j9FyHHAHBPw8Y6rod1RO1Mfld5mdYRAABUha//EXoMAPcce74aNbWOqIXKiL7oax0BAEBVSgo0bYh1BJBgDAD3nHyJdUHtzBymzFTrCAAAqjLtI55Qh/BjADimQSMdf6F1RO2Me8m6AACAXeDx//ABA8AxXbqp8Z7WEbWwZo7WzLaOAACgKmvmaO186wgg8RgAjnH9+T8TXrUuAABgF3hCHTzBAHBJcgOd6PL7v/IyNfNT6wgAAKqSk64ZQ60jgDrBAHDJUeepSUvriFr4epDKS60jAACoyoRXFSm3jgDqBAPAJSddbF1QC5EKnqwMAAio0kJN4vZfeIMB4JJjz7cuqIV5Y5SdZh0BAEBVvntPhTnWEUBdYQA443dHau/9rSNq4du3rQsAAKhKtFLjX7aOAOoQA8AZx3S3LqiFnHQtmmAdAQBAVeZ9rozV1hFAHWIAOMPp8z9T3ldlxDoCAICqjHvRugCoWwwANzRqqsPPso6ohcnvWhcAAFCVtfO0fIp1BFC3GABuOPJc1W9oHVFTK75XxirrCAAAqjKWr//hHwaAG5w+/zP5HesCAACqsm0jb6iEjxgAbnD3DuCyYs0abh0BAEBVPn9BkQrrCKDOMQAc0O4wte1oHVFT879QSYF1BAAAO8nN0DeDrCMACwwAB7j79b+kGZ9YFwAAUJUv+qq8xDoCsMAAcIC7NwAU52vBOOsIAAB2kp+lSQOsIwAjDICgq99Qh3e1jqipuaP4cgUAEETjXlJpoXUEYIQBEHQHnaSGja0jamo6538AAMFTlKsJ/7GOAOwwAILO3fd/FWRr8UTrCAAAdjK+v4rzrCMAOwyAoHP3/M+ckYqUW0cAAPBLxfka/7J1BGCKARBoSfV02BnWETU1d7R1AQAAO/nqNRXmWEcAphgAgdbhWDVubh1RI2XFWjLJOgIAgF8qLdK4F60jAGsMgEBz9waAxRNVVmwdAQDAL016Q3lbrSMAawyAQHP3BoB5Y6wLAAD4peI8jeptHQEEAAMg0By9AhCNav4X1hEAAPzS2H4q2GYdAQQAAyC42ndW8zbWETWyepa2b7GOAABgB3lbNZbT/4AkBkCQOfr1vzj/AwAInlHPqKTAOgIIBgZAcLl7A8DCcdYFAADsIGuDJg2wjgACgwEQXI5eAcjL1IZF1hEAAOxg+GMqL7WOAAKDARBQLfZR6wOsI2pkydeKRq0jAAD4yabl+v5D6wggSBgAAdXxBOuCmlo80boAAIAdfPq/qoxYRwBBwgAIqE7uDgBeAAwACIw1czR7hHUEEDAMgIDqdKJ1QY2kp2jbRusIAAB+8slD1gVA8DAAAsrRI0BL+PofABAYC8drydfWEUDwMACCqMU+2qu9dUSNcAMAACAgIhUafI91BBBIDIAgcvT8TzSqZd9ZRwAAIEma9IY2LbeOAAKJARBEjt4BnLZURbnWEXUubal1AQBgJwXZGv64dQQQVAyAIHL0CkDKVOsCCx/caV0AANjJZ0+oINs6AggqBkAQOXoHcMo06wILS77WnJHWEQCAHaSv0MTXrSOAAGMABE7LfdWqnXVEjfh5BUDS4Ht4wzwABMiH9yhSYR0BBBgDIHAcPf+Tk66t66wjjGSu1dh+1hEAAEnSoglaOM46Agg2BkDgcP7HRaOeVU66dQQAeC9SoQ/vto4AAo8BEDgHdLEuqBFvz//8n9JCffSAdQQAeG/SAKUts44AAo8BEDjtOlsX1IjnVwAkTRuiVTOsIwDAYwXbePQnUC0MgGBJrq/9DrGOiF1FmTYuto6wFo3qvdsVjVp3AICvPnpABdusIwAXMACCZZ+DldzAOiJ2G5eoosw6IgBS5+qbQdYRAOClldM1+R3rCMARDIBgae/m+Z+186wLAuPjB5W31ToCADwTqdDbt3ANFqguBkCwODoAUhkAPynM0eB7rCMAwDNfvqINi6wjAHcwAIKl/RHWBTWybr51QZB8/6GWTbaOAABvZKdx7y8QGwZAsLh4BSBSwfcuv/b2LdwUAQB15P07VVJgHQE4hQEQIElJane4dUTs0paqvNQ6ImDSV+jzF6wjAMADC8dr9mfWEYBrGAAB0vpANWpiHRE77gCu0qhnlJlqHQEAoVZWrHf/aR0BOIgBECAunv+RtJYbAKrCv5YAINFGPctXLUBNMAACxNEBsHGJdUFQLRyvmcOsIwAgpNJT9Pnz1hGAmxgAAeLoI4A2LbMuCLB3b+O1AAAQf9FKDfw7j1sAaogBECAu3gGcn8UH3N3J26p3brWOAIDQmfAfpUyzjgCcxQAIkH06WRfELo2v/3/LrOGa+al1BACESOZaffJv6wjAZQyAoGjQSC32tY6IHed/quOd25SXaR0BAKEQjWrgDSottO4AXMYACIq9D1BSknVE7LgCUB35WXrrZusIAAiFbwZp6TfWEYDjGABB0eZA64Ia4QpANc0ZqekfW0cAgOO2bdSQ+6wjAPcxAIKidQfrghrhCkD1vftP5WZYRwCAy976h4rzrCMA9zEAgqJNB+uC2BXlKnezdYQ7CrL11j+sIwDAWVPe18Lx1hFAKDAAgsLFI0DpKdYFrpk3RlMHW0cAgINyM/TBXdYRQFgwAILCxSsAvIC9Bt67ncsmABCzt29RYY51BBAWDICgcHEAbGEAxK4wRwNvtI4AAKdM+UBzR1lHACHCAAiE5AZq1c46InZb11oXuGnBWH33nnUEADhi6zq99y/rCCBcGACBsPf+SnLw/wqOANXYB3cpe5N1BAAEXrRSr1/Nk3+AOHPwU2cYuXgHsDgCVAtFuRrEQSAA+C1j+mjF99YRQOgwAALBxRsAIuXKTrOOcNnC8fr2besIAAiwtfM17DHrCCCMGACB4OJbwLI2qDJiHeG4D+/Wto3WEQAQSGXFeu0qRcqtO4AwYgAEwt6/sy6IHTcA1F5xngZcp2ildQcABM+Q+7RpuXUEEFIMgEBo3ta6IHaZPAIoHpZ8rVHPWkcAQMD88KW+es06AggvBkAgtHBwAGxdZ10QFsMf1/Ip1hEAEBj5WRpwnXUEEGoMgEBw8QpATrp1QVhURvTqFcrbat0BAMEw6CblZlhHAKHGAAgEBoDnctL1+tWKRq07AMDaxNc1Z6R1BBB2DAB7ezRToybWEbHL3WxdEC4/fKkxz1lHAICpdQv04d3WEYAHGAD2XPz6X1wBSIBhjyplqnUEABgpztcrl6q81LoD8AADwJ6LdwCXl6og2zoidCIV6n+FCrZZdwCAhUE3KmO1dQTgBwaAvRb7WBfEjvM/CZKdpte4GQCAfyYN0Iyh1hGANxgA9lw8AsT5n8RZOE5f9LWOAIA6tP4HfXCXdQTgEwaAPRePADEAEmrov7VqhnUEANSJH4/+l1h3AD5hANhz8QoAR4ASKlKh/pdzlwUAL7z1D21eaR0BeIYBYM/FewC4ApBoWRv0xrXWEQCQYF8P1PSPrSMA/zAA7Ll4BYDX1taB+Z9r7IvWEQCQMOt/0Pt3WEcAXmIA2HPxHgBOp9SNjx/U6lnWEQCQAIU5erEXR/8BGwwAe3u2ti6IHQOgbkTK1f9yFeVadwBAXEUr1f8KZaZadwC+YgDYa9zcuiB2DIA6s3Wd3riONwMACJWhD2vRBOsIwGMMAGP1ktWwsXVE7AoZAHVo7ih99oR1BADEyazhGv2cdQTgNwaAsT32tC6oEa4A1LERT2rmMOsIAKi1tKUacJ11BOA9BoCxxg4OgPISlRVbR3gmGtWAa7V2vnUHANRCUa76XaySAusOwHsMAGMuDgC+/jdRWqS+Fyk3w7oDAGokWqn/XKWMVdYdABgA5lw8AsQAsJKdpn49eWoeACcNe0wLxlpHAJDEADDHI4AQk9WzNPAG6wgAiNHcURr1jHUEgJ8wAIy5eASIRwDZmjpEo3tbRwBAtW1cotev5nHGQIAwAIy5eASoKM+6wHtDH9bc0dYRAFAN27fo+QtUnG/dAWAHDABjLl4BKC20LvBeNKrXrtLGxdYdALBb5SXq11NZ6607APwSA8CYi1cAyoqsCyCVFOj5C5W31boDAHYhGtUb12rVTOsOADthABhz8QpACVcAgiFrvV7spYoy6w4AqMrwxzRjqHUEgKowAIy5eAWAI0DBkTJVb99iHQEAO5k6RCOeso4AsAsMAGMuXgHgCFCgTH5HY1+0jgCAHaRM08C/W0cA2DUGgDEX3wPAFYCg+eh+LRxvHQEAkqTMVPXrqfJS6w4Au8YAMNaoqXVB7Eq5AhAwlRH1v1ybllt3APBe0XY9f4Hys6w7AOwWA8BYcgPrgthxBSCAivP0woXKy7TuAOCxSLle/gtfRgAOYAAYS65vXRA7rgAE05Y16t1dxbymDYCFaFQDrtfiSdYdAKqBAWDMyQHAFYCgWrdAfS9SeYl1BwD/DLlPUwdbRwCoHgaAsXouDgCuAATYssnqf4UqI9YdAHwy9kWN7WcdAaDaGADGXLwCECm3LsBuzR2lQTdZRwDwxtQhGnKvdQSAWDAAjLl4EzDfLgff5Hf00QPWEQA8sHiiBlynaNS6A0AsGADGXLwCUFlhXYBq+Px5fdHXOgJAqK2dpxd7cVkYcA8DwJiL9wBwBcAVH92v796zjgAQUhmr9VwPlRRYdwCIHQPAmItXACJcAXBENKqBN2jeGOsOAKGzfYt6/5F3jwCuYgAY4x4AJFRlRK9cpuVTrDsAhEhxnvr0UGaqdQeAmmIAGOMKABKtvER9/6z1C607AIRCaaH69NDa+dYdAGqBAWDMxQHAFQDnFG1X7+7assa6A4DjykvU9yKlTLPuAFA7DABjTt4EzBUAB23fome7KXezdQcAZ0XK9dJftORr6w4AtcYAMMY9AKgzmanq3V1FudYdABxUGVH/K7RgrHUHgHhgABjjCBDq0oZFev5ClRVbdwBwSrRSb1yr2Z9ZdwCIEwaAMRcHADcBOy1lql66ROWl1h0A3PHWzZo62DoCQPwwAIw59zmsvFTRSusI1M7C8er7Z5WXWHcAcMEHd+qbQdYRAOKKAWCsJN+6IEbOBaNKi77S8xeotMi6A0CwDX1Y41+xjgAQbwwAY0V51gUxKnYtGLuy5Gv16aHSQusOAEH12ZMa9ax1BIAEYAAYc+7ztHPB2I3l36l3dxVzVQfAToY9quGPWUcASAwGgDHn3s3kXDB2L2Wqev+RXQfgFz55SCOeso4AkDAMAGPrF1oXxGida8H4Tatm6Jk/8H4AAD8afK9GP2cdASCRGADG1i2wLoiRc4sF1bFmtp7+HxVkW3cAsPb+HRrbzzoCQIIxAIw5NwCcC0Y1rZ2np89TwTbrDgBGolG9c6u+7G/dASDxGADGcjNc+ki9/gdlb7KOQMKsX6gnz1HeVusOAHUuGtWgmzTxDesOAHWCAWBv5jDrgmqbNdy6AAm2cbGe+r22b7HuAFCHopUacJ2+fcu6A0BdYQDYc+hT9Sx3tgpqLG2Znvy9cjdbdwCoE5URvX61prxv3QGgDjEA7GWsUupc64hqWLdA6SnWEagT6Sv0xNnKTrPuAJBg5SV66RJNHWLdAaBuMQACYUwf64JqcCIS8ZKxSk+crawN1h0AEqY4T727a+5o6w4AdY4BEAizR2jTcuuI3UpPceleBcRFZqqePJtXvwHhtH2Lnjhby7+z7gBggQEQCNFKjXrWOmK3RvdWtNI6AnVu6zo9errWzrfuABBXmWv1+Jm81wXwFwMgKKZ9pNWzrCN2Yc0cTR1sHQEjeZl66vda8rV1B4A42bhEj52hjNXWHQDsMACCIlqpN69Xeal1x04qyvTm9aqMWHfATnG++vTQjKHWHQBqbeV0PdGVx3wBvmMABEjaMo18yjpiJyOf1sYl1hGwVlGmV/+qCa9adwCohYXj9OwfVJhj3QHAGgMgWMb0CdYtWSu+1+jnrCMQDNFKvXe7hj5s3QGgRqYOUd+LVFpk3QEgABgAwRKpUL+Lg/K4/YxV6tdTkXLrDgTJqGc18AaOhAGOGf2cXv+bIhXWHQCCgQEQOIU56tNDeVuNM/Kz1KeHCrKNMxBA376tfj1VUmDdAaAaIhUaeKM+eUjRqHUKgMBgAARRZqqeO195mWYB+Vl67nyeEYFdmv+Fnuiq7E3WHQB2q2i7+vTQt29ZdwAIGAZAQK2dp0dPt/kInpmqR09X6lyDHw2HrFugR07hOeJAcGWt12NnaPFE6w4AwcMACK4ta/TY6Vozu05/6Jo5euQ0Zayq0x8KR2Vv0uNnacFY6w4AO0mdq0dOVdpS6w4AgcQACLS8rXr8LI18pi7uuayMaHRvPX6m5dEjOKekQH0v0oT/WHcA2MHcUXrybOVmWHcACCoGQNBVlOnT/9Wjp2nT8gT+lPQVevR0ffJvVZQl8KcglCojeu9f+uBORSutUwBI417Si5fwuE8Au8MAcMOaOXroOL1/h3LS4/wn527WB3fpwePq+qwRQmb8K+rLo4EAU5URvXObPrybNQ7gNyRdLh4M5pIGjXTujfrzA9rrd7X9o7LTNOZ5fTNI5SXxKIuHjyqVlGQdEaO/1uPhej/b/yjdM0r7HGTdAfinYJtevlRLv7HuAOACBoCTkurpiLN12mU6qZeat4ntv5ufpdkjNGOolk0O3LdEDIAQaLaXbh+qLv9j3QH4ZP0P6tdTW9dZdwBwBAPAbfWSdcip6niCOp6gTido30NUv+Gv/zMVZcpYpbXztXaeUudq9azgvgySARAO9ZJ15QvqcZd1B+CHGUP15vUc+gcQAwZA2DRqoiYt1bSVJBXmqCjXpX8rMADCpOtqhhDYAAAOTklEQVTVuuFNNdjDugMIr2ilPn5Inz9v3QHANfWtAxBnpUUqLYr/vcJArKZ8oE3LdfdI7dXeOgUIo8Ic9b9CiyZYdwBwEE8BApAoa+bo4RO1crp1BxA6aUv18El8+gdQQwwAAAmUm6Enf68Jr1p3ACEye4QeOVVb1lh3AHAWAwBAYkXK9d7teuVSFedbpwCOi1To4wf18l945waAWmEAAKgLM4fp4RO1cbF1B+Cs7DQ99XuN6cODBwDUFgMAQB3ZvFKPnKop71t3AA5aOE4PHKuUadYdAEKBAQCg7pQW6Y1rNfDGAL1/Ggi4/zv28/wFKthmnQIgLBgAAOrat2/pkdO4hRH4bRz7AZAIDAAABtYv1EPHaepg6w4gwDj2AyBBGAAAbBTn67W/6bWrVJxnnQIETKRCHz3AsR8AicIAAGBp6hA9eJxWzbTuAAIjM1VPdNXnz3PsB0CiMAAAGMtM1RNnaeQzilZapwDWvn1LDxyjVTOsOwCEGgMAgL1IhT79Xz11jrZttE4BjORlqu9FGngjL/kCkHAMAABBsXyKHjhGM4dZdwB1bt4Y3ddF88ZYdwDwAwMAQIAU5uiVS9X/cu59hC9KCjTwBvW9SHmZ1ikAvMEAABA4M4bq3iM1d7R1B5BgKdP0wDH69m3rDgCeYQAACKLtW9Svp16/WkW51ilAAkTK9cm/9URXZaZapwDwDwMAQHB9/6HuO0oLx1t3AHG1epYeOl6je/PkKwA2GAAAAi17k/r00MAbeF8YwqC0UB/cpUdP18Yl1ikAPMYAAOCAb9/mrgA4b9EE3Xukxr/MF/8AjDEAALghO039euqlS5STbp0CxKhgm16/Wr27K2u9dQoAMAAAuGX2CN3TWV+9xneocMa0j3RPZ33/oXUHAPyEAQDAMcV5evefeuwMbVxsnQLsVtYG9fmT/nOl8rZapwDADhgAAJy0aqYeOl6fPKSyYusUYCeRcn3RV/cdqYXjrFMAYCcMAACuilRo9HO67yhuDkawLJqg+7toyH0qKbBOAYCqMAAAuC0zVf16qvcflb7COgXey1yrfj3Vu7vSU6xTAGDXGAAAwmDRV7r/aA2+h9cFwEZpkYY9qnuP4HoUAAcwAACERKRcY1/UXYdq8ruKRq1r4JOZw3RvZ414SuUl1ikAUA0MAASJgx/a+KAZNNu36M3r9cipWj3LOgUeSFuqp8/VK5cqa4N1CgBUGwMAAVJaZF0QI+eC/bFmth49Ta9eocxU6xSEVE66Bt2kB47R0m+tUwAgRgwABIhzp7dL8q0LsGvRqKZ/orsP1/t38BR2xFNRrj55SHcerG8GqTJiXQMAsWMAIECKXfs87dxi8VCkXF/2150HaeTTXLFBbZWX6PMXdHsnjX6OF1AAcBgDAAFSvN26IEZFrgV7qzhfnz6iOw/W128qUmFdAwdVRjT5Hd15iD66X4U51jUAUDsMAATIpuXWBTFyLthzuZv11s26/yjN/JS7txGDuaN1fxe9+Xdlp1mnAEA8MAAQIOsWWhfEaL1rwZCUnqJXLtP9XTRjqKKV1jUItkUT9Ojp6teTtQ8gVBgACJB1C6wLYuTcYsF/pS1V/8t1fxdN/4QZgF+LRjV3tB4+Sb27a9UM6xoAiLeky1189DpCqkkLDdqmesnWHdUTrdSNrTkNHAbtO6vXIzrtMiXxlYj3opWaOUwjn9HGxdYpAJAw/OsOAVK0Xcu/s46otuVT+PQfEpuW69W/6t4jNXUwtwj7K1Kh797TPZ3V/3I+/QMIOQYAgmXmMOuCaps13LoAcZW+Qq/9TXd00tgX3XsiLWqjvFSTBuiuQzTgOm1eaV0DAInHESAES4t99Ea6AycxopW6tb1yM6w7kBhNWui8m9T9Du3V3joFiZSfpW8GacJ/lJNunQIAdYgBgMB5YKyO7WEd8Vt++FLPnW8dgQRLbqAzrtCf7tEBR1unIN7W/6Av+2vaRyovsU4BgDrHAEDgHHaGHp9qHfFbnuiqFd9bR6CuHN1Nf/yXjuvhwLUp7F5lRHNH68tXtHyKdQoA2GEAIIge+VZH/N46YtdWfK8nulpHoM61PlDn3aRz/q4W+1inIHYF2fr2LX31mrI2WKcAgDUGAILoqPP08CTriF17tpsWT7SOgJHkBjrpYv3hlkBvVOxo7Xx9/aamDlZpkXUKAAQDAwABdcdQnXqpdURVZg3Xy//POgIB0O5w/eEWdb1aTVpap6AqeZmaOkTfvacNi6xTACBgGAAIqOZt1HeZ9mxt3fFLBdt0zxHKy7TuQGA02EMnXKizrtYx3ZVc37oGUqRcC8bpu3e1YJwi5dY1ABBIDAAE1+lX6F8fWUf80mtXaeoQ6wgEUvM2Ou1ynfU3HXSSdYqvNizSd+9p6mDlbbVOAYBgYwAg0G4cqHNvtI74ybdva+AN1hEIvHaH66y/6cwr1fpA6xQ/ZK3X7BGaOlhr51unAIAjGAAItOT6un+sju5m3SEtnqQ+5ytSYd0BRyQl6eBTdFIvnXSx9j3YuiaMNq/U7M80e4RS51qnAIBrGAAIusbN9cRU7d/FsiFtqR47Q0XbLRvgrv276OReOrkXLxSLgw2LNPszzfpMaUutUwDAWQwAOKDFPnpgnDoeb/PT1y1Qnx7KzbD56QiTtp10ci+d2FMHn8IdwzGojGjNHM0Zqdmfacsa6xoAcB8DAG7Yo5nuGq6j/1jXP3fxRL10iYrz6/rnItyatNAR5+jobjq6m/Y5yLomqDJWafEkLZmkJd+oKNe6BgBChAEAZyQ30N9f1zl1eBvu5Hf01s08SRCJ1bbTj0vgyHPVpIV1jbW8rVr6jRZP1OJJylpvXQMAIcUAgGNOulg3DFDzton9KXlb9fbNmj0isT8F2FG9ZHU4ToeerkNO06Gnq/UB1kF1JSdda2Zr5XQtnqT1CxXlX0oAkGAMALhnz9a6/nWdmrDX8c4arndu5VHiMLZX+5/HQIfjVL+hdVD8FOcpda5Wz9aa2VozW9mbrIMAwDMMALjqsDPU69E4PyF08UR99qRSpsbzzwRqr0EjtT9CBxytA7po/y464Gi13Ne6KRYF25SeovULf/zQn76Cr/kBwBIDAG475FT1/LeO6a7kBjX/QyIV+uFLjXpWq2bErwxIpOZtflwCvztCbTqqbUe1PqBW/xTES6RcW9YoPUWbU37+PT/LOgsAsAMGAMKg2V46qZdOu0xHnqN6ydX9b1VGtGyyZgzV7BEq2JbIPiDxkupp79+pTUe16aC2HdWmo1rtpz1b//irYeN4/qySAuVmaHuGcjN+/ouczdqyWpmpvC8PAIKOAYBQadRUHY5Vh+PV6QTte4iatlLTVmraUpIKc1WYo8IcZazW2nlaO0/rFqq00LoYqBONmvw8BprtpQZ7qH4j1W+oBo3UoNHPfy2prFjlJSorUflPv/771//93F9aZP2/BwBQCwwAAAAAwCP1rAMAAAAA1B0GAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgEQYAAAAA4BEGAAAAAOARBgAAAADgkf8PodJLypWGxG4AAAAASUVORK5CYII=",
                            height: 1024,
                            preserveAspectRatio: "xMidYMid meet"
                        })
                    })
                })
            })
        ]
    }), O3e = ({ size: e = 42, variant: t = "first", className: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        id: "Ebene_2",
        "data-name": "Ebene 2",
        viewBox: "0 0 314.29 111.66",
        width: e,
        height: e,
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("defs", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("style", {
                    children: ".cls-1{fill:#fff;stroke-width:0}"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                id: "Ebene_1-2",
                "data-name": "Ebene 1",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "M118.13 0c-8.69-.1-16.81 2.21-23.8 6.26-2.57 1.49-3.29 4.91-1.55 7.33 3.44 4.8 6.15 10.15 7.97 15.9 1.01 3.2 4.82 4.23 7.65 2.43 3.55-2.25 7.97-3.25 12.67-2.33 6.53 1.27 11.95 6.44 13.44 12.93 2.61 11.39-5.97 21.5-16.91 21.5-3.41 0-6.58-.99-9.24-2.7-2.82-1.8-6.61-.66-7.63 2.53-4.48 14.04-14.26 25.71-27.02 32.66-1.67.91-2.75 2.6-2.75 4.5v5.58c0 2.8 2.27 5.07 5.07 5.07h19.13c2.8 0 5.07-2.27 5.07-5.07v-9.76c0-3.35 3.16-5.67 6.42-4.87 3.52.86 7.18 1.32 10.96 1.32 26.19 0 47.34-21.59 46.62-47.95C163.55 20.67 142.8.28 118.13 0Z",
                        style: {
                            fill: "#ff7900",
                            strokeWidth: 0
                        }
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "M46.64 0C20.88 0 0 20.88 0 46.64s20.88 46.64 46.64 46.64S93.28 72.4 93.28 46.64 72.4 0 46.64 0Zm0 64.03c-9.6 0-17.38-7.78-17.38-17.39s7.78-17.39 17.38-17.39 17.39 7.78 17.39 17.39-7.78 17.39-17.39 17.39ZM188.46 41.7l20.14 33.14h11.26V18.5h-13.02v34.05L185.9 18.5h-10.38v56.34h12.94V41.7zM265.74 63.57h-24.29V51.9h15.46V40.8h-15.46V29.77h24.29V18.5h-37.88v56.34h37.88V63.57zM286.16 74.84h14.06V29.77h14.07V18.5H272.1v11.27h14.06v45.07z",
                        className: "cls-1"
                    })
                ]
            })
        ]
    }), I3e = ({ size: e = 42, className: t, ...r })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        viewBox: "0 0 200 200",
        fill: "none",
        className: t,
        ...r,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.14
                    },
                    fill: "#090a0b",
                    d: "M 81.5,9.5 C 82.2423,11.4258 83.2423,13.2591 84.5,15C 82.7184,15.1218 81.0518,14.6218 79.5,13.5C 79.2291,11.6203 79.8958,10.287 81.5,9.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#4f585a",
                    d: "M 125.5,38.5 C 112.548,31.863 99.8817,25.0297 87.5,18C 100.667,29.0023 113.667,40.1689 126.5,51.5C 127.634,54.3704 128.3,57.3704 128.5,60.5C 126.668,59.7515 125.001,58.7515 123.5,57.5C 110.167,46.8333 96.8333,36.1667 83.5,25.5C 80.3626,22.7015 78.0293,19.3681 76.5,15.5C 76.9731,14.0937 77.9731,13.427 79.5,13.5C 81.0518,14.6218 82.7184,15.1218 84.5,15C 83.2423,13.2591 82.2423,11.4258 81.5,9.5C 83.4346,8.29099 85.4346,8.45766 87.5,10C 100.414,19.2774 113.08,28.7774 125.5,38.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.161
                    },
                    fill: "#08090a",
                    d: "M 76.5,15.5 C 78.0293,19.3681 80.3626,22.7015 83.5,25.5C 80.5498,24.6916 77.8831,23.3582 75.5,21.5C 73.9378,19.0993 74.2712,17.0993 76.5,15.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.999
                    },
                    fill: "#778085",
                    d: "M 75.5,21.5 C 77.8831,23.3582 80.5498,24.6916 83.5,25.5C 96.8333,36.1667 110.167,46.8333 123.5,57.5C 118.285,55.5594 113.285,53.0594 108.5,50C 99.2121,47.5708 90.0454,44.7374 81,41.5C 80.2352,41.5699 79.7352,41.9033 79.5,42.5C 75.0157,41.6841 72.6824,39.0174 72.5,34.5C 72.8417,33.6618 73.5084,33.3284 74.5,33.5C 77.4258,34.868 80.4258,35.7013 83.5,36C 80.3333,32.8333 77.1667,29.6667 74,26.5C 73.51,25.2068 73.3433,23.8734 73.5,22.5C 73.8417,21.6618 74.5084,21.3284 75.5,21.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.165
                    },
                    fill: "#070809",
                    d: "M 73.5,22.5 C 73.3433,23.8734 73.51,25.2068 74,26.5C 77.1667,29.6667 80.3333,32.8333 83.5,36C 80.4258,35.7013 77.4258,34.868 74.5,33.5C 73.2222,31.2009 71.8889,28.8676 70.5,26.5C 71.0351,24.739 72.0351,23.4057 73.5,22.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#8d9999",
                    d: "M 125.5,38.5 C 126.125,42.3258 126.791,46.1592 127.5,50C 127.43,50.7648 127.097,51.2648 126.5,51.5C 113.667,40.1689 100.667,29.0023 87.5,18C 99.8817,25.0297 112.548,31.863 125.5,38.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#8e9a9a",
                    d: "M 123.5,57.5 C 125.001,58.7515 126.668,59.7515 128.5,60.5C 128.5,61.8333 128.5,63.1667 128.5,64.5C 128.5,65.8333 128.5,67.1667 128.5,68.5C 112.879,61.0229 97.5452,53.0229 82.5,44.5C 81.2905,44.0679 80.2905,43.4013 79.5,42.5C 79.7352,41.9033 80.2352,41.5699 81,41.5C 90.0454,44.7374 99.2121,47.5708 108.5,50C 113.285,53.0594 118.285,55.5594 123.5,57.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#777f85",
                    d: "M 125.5,38.5 C 129.5,41.5 133.5,44.5 137.5,47.5C 136.428,51.7555 134.261,55.4222 131,58.5C 130.155,60.6115 129.322,62.6115 128.5,64.5C 128.5,63.1667 128.5,61.8333 128.5,60.5C 128.3,57.3704 127.634,54.3704 126.5,51.5C 127.097,51.2648 127.43,50.7648 127.5,50C 126.791,46.1592 126.125,42.3258 125.5,38.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.997
                    },
                    fill: "#888889",
                    d: "M 58.5,63.5 C 48.5374,62.2002 38.7041,60.2002 29,57.5C 27.9302,57.528 27.0968,57.8614 26.5,58.5C 24.2459,57.5849 22.2459,56.2516 20.5,54.5C 18.4985,51.6662 15.9985,49.3329 13,47.5C 12.51,46.2068 12.3433,44.8734 12.5,43.5C 13.2506,42.4265 14.2506,42.2599 15.5,43C 29.1035,51.4694 43.4368,58.3027 58.5,63.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.17
                    },
                    fill: "#0e0f0f",
                    d: "M 12.5,43.5 C 12.3433,44.8734 12.51,46.2068 13,47.5C 15.9985,49.3329 18.4985,51.6662 20.5,54.5C 20.44,55.0431 20.1067,55.3764 19.5,55.5C 16.3707,53.6001 13.0373,52.2667 9.5,51.5C 10.7279,49.9902 10.7279,48.4902 9.5,47C 10.1634,45.4815 11.1634,44.3149 12.5,43.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#7b848a",
                    d: "M 82.5,44.5 C 97.5452,53.0229 112.879,61.0229 128.5,68.5C 128.72,71.4005 128.054,74.0671 126.5,76.5C 113.14,69.1544 99.8062,61.8211 86.5,54.5C 83.5279,52.6778 80.5279,50.8445 77.5,49C 76.6198,47.6439 76.2865,46.1439 76.5,44.5C 78.7411,44.9539 80.7411,44.9539 82.5,44.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.153
                    },
                    fill: "#050506",
                    d: "M 72.5,34.5 C 72.6824,39.0174 75.0157,41.6841 79.5,42.5C 80.2905,43.4013 81.2905,44.0679 82.5,44.5C 80.7411,44.9539 78.7411,44.9539 76.5,44.5C 76.2865,46.1439 76.6198,47.6439 77.5,49C 80.5279,50.8445 83.5279,52.6778 86.5,54.5C 86.2774,59.2804 87.944,63.2804 91.5,66.5C 91.1496,69.4534 92.1496,71.7867 94.5,73.5C 92.4471,73.5979 90.7804,72.9313 89.5,71.5C 89.6495,70.448 89.4828,69.448 89,68.5C 85.7393,65.9786 84.0726,62.6453 84,58.5C 80.5991,56.6387 77.5991,54.3053 75,51.5C 74.2419,49.2305 74.4086,47.0639 75.5,45C 70.4866,42.378 69.4866,38.878 72.5,34.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.016
                    },
                    fill: "#0f1010",
                    d: "M 138.5,48.5 C 140.539,49.911 141.539,51.911 141.5,54.5C 139.992,52.8185 138.992,50.8185 138.5,48.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.999
                    },
                    fill: "#343f49",
                    d: "M 9.5,51.5 C 13.0373,52.2667 16.3707,53.6001 19.5,55.5C 20.1067,55.3764 20.44,55.0431 20.5,54.5C 22.2459,56.2516 24.2459,57.5849 26.5,58.5C 35.1667,62.8333 43.8333,67.1667 52.5,71.5C 56.6478,75.4041 60.9811,79.0708 65.5,82.5C 65.5,82.8333 65.5,83.1667 65.5,83.5C 50.001,77.6719 34.6676,71.6719 19.5,65.5C 16.9116,63.4392 14.0783,60.7726 11,57.5C 9.87201,55.6547 9.37201,53.6547 9.5,51.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.191
                    },
                    fill: "#070809",
                    d: "M 9.5,51.5 C 9.37201,53.6547 9.87201,55.6547 11,57.5C 14.0783,60.7726 16.9116,63.4392 19.5,65.5C 16.2854,65.0951 13.2854,64.0951 10.5,62.5C 8.3912,60.8783 7.3912,58.7116 7.5,56C 7.30684,53.9919 7.9735,52.4919 9.5,51.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.05
                    },
                    fill: "#060707",
                    d: "M 141.5,54.5 C 142.633,56.0552 143.299,57.8886 143.5,60C 142.418,65.9944 141.418,71.9944 140.5,78C 140.899,79.7275 141.566,81.2275 142.5,82.5C 142.167,83.5 141.5,84.1667 140.5,84.5C 140.046,81.1349 139.38,77.8015 138.5,74.5C 139.874,67.8812 140.874,61.2146 141.5,54.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#c9cbcb",
                    d: "M 26.5,58.5 C 27.0968,57.8614 27.9302,57.528 29,57.5C 38.7041,60.2002 48.5374,62.2002 58.5,63.5C 61.221,63.9628 63.8877,64.6295 66.5,65.5C 72.5358,70.1912 78.8691,74.5245 85.5,78.5C 74.6653,76.7183 63.6653,74.385 52.5,71.5C 43.8333,67.1667 35.1667,62.8333 26.5,58.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#929294",
                    d: "M 10.5,62.5 C 13.2854,64.0951 16.2854,65.0951 19.5,65.5C 34.6676,71.6719 50.001,77.6719 65.5,83.5C 63.9504,84.7199 62.2837,84.7199 60.5,83.5C 47.2117,81.5939 34.2117,78.5939 21.5,74.5C 15.1127,73.7734 10.7793,70.4401 8.5,64.5C 8.83333,63.5 9.5,62.8333 10.5,62.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#494f51",
                    d: "M 137.5,47.5 C 138.167,47.5 138.5,47.8333 138.5,48.5C 138.992,50.8185 139.992,52.8185 141.5,54.5C 140.874,61.2146 139.874,67.8812 138.5,74.5C 139.38,77.8015 140.046,81.1349 140.5,84.5C 138.83,87.0016 136.664,89.0016 134,90.5C 132.478,88.2591 131.145,85.9258 130,83.5C 128.544,86.0324 127.377,88.6991 126.5,91.5C 115.094,82.7537 103.427,74.4203 91.5,66.5C 87.944,63.2804 86.2774,59.2804 86.5,54.5C 99.8062,61.8211 113.14,69.1544 126.5,76.5C 128.054,74.0671 128.72,71.4005 128.5,68.5C 128.5,67.1667 128.5,65.8333 128.5,64.5C 129.322,62.6115 130.155,60.6115 131,58.5C 134.261,55.4222 136.428,51.7555 137.5,47.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.183
                    },
                    fill: "#060606",
                    d: "M 8.5,64.5 C 10.7793,70.4401 15.1127,73.7734 21.5,74.5C 19.3021,75.1653 16.9688,75.8319 14.5,76.5C 16.3737,81.6139 20.0404,84.6139 25.5,85.5C 26.5,85.5 27.5,85.5 28.5,85.5C 28.2627,86.791 28.596,87.791 29.5,88.5C 29.5106,90.0174 30.1772,91.1841 31.5,92C 34.7365,93.7862 38.0698,95.2862 41.5,96.5C 41.5,97.1667 41.8333,97.5 42.5,97.5C 42.5494,100.099 43.5494,102.266 45.5,104C 48.8168,104.498 52.1501,104.665 55.5,104.5C 55.2627,105.791 55.596,106.791 56.5,107.5C 56.9528,108.458 57.6195,109.292 58.5,110C 61.3771,111.127 64.3771,111.794 67.5,112C 68.9852,114.237 70.9852,115.737 73.5,116.5C 76.9386,117.019 80.272,118.019 83.5,119.5C 87.2508,121.079 91.2508,122.079 95.5,122.5C 95.5,122.833 95.5,123.167 95.5,123.5C 92.5715,130.285 90.2382,137.285 88.5,144.5C 88.1667,145.167 87.8333,145.833 87.5,146.5C 87.1667,146.5 86.8333,146.5 86.5,146.5C 87.7936,139.786 89.7936,133.286 92.5,127C 87.5169,126.897 83.1836,125.23 79.5,122C 74.2686,122.485 69.9353,120.819 66.5,117C 60.8614,116.865 56.528,114.531 53.5,110C 50.1853,109.059 46.852,108.226 43.5,107.5C 41.5592,105.166 39.8925,102.666 38.5,100C 32.4206,98.8085 28.0872,95.4752 25.5,90C 17.189,88.6898 12.689,83.8564 12,75.5C 9.28221,73.2292 7.44888,70.3958 6.5,67C 7.06594,66.0053 7.73261,65.172 8.5,64.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#b8b6ac",
                    d: "M 52.5,71.5 C 63.6653,74.385 74.6653,76.7183 85.5,78.5C 89.228,81.5589 93.228,84.2256 97.5,86.5C 91.3341,87.3789 85.0007,87.3789 78.5,86.5C 75.3915,86.7359 72.3915,86.4025 69.5,85.5C 68.205,84.5116 66.8717,83.5116 65.5,82.5C 60.9811,79.0708 56.6478,75.4041 52.5,71.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#343f48",
                    d: "M 21.5,74.5 C 34.2117,78.5939 47.2117,81.5939 60.5,83.5C 48.8333,84.1667 37.1667,84.8333 25.5,85.5C 20.0404,84.6139 16.3737,81.6139 14.5,76.5C 16.9688,75.8319 19.3021,75.1653 21.5,74.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#565a5e",
                    d: "M 66.5,65.5 C 74.1667,67.5 81.8333,69.5 89.5,71.5C 90.7804,72.9313 92.4471,73.5979 94.5,73.5C 104.436,81.5934 114.269,89.9267 124,98.5C 124.333,100.5 124.667,102.5 125,104.5C 127.25,100.332 129.75,96.3318 132.5,92.5C 130.604,91.5344 128.604,91.2011 126.5,91.5C 127.377,88.6991 128.544,86.0324 130,83.5C 131.145,85.9258 132.478,88.2591 134,90.5C 136.664,89.0016 138.83,87.0016 140.5,84.5C 141.5,84.1667 142.167,83.5 142.5,82.5C 146.184,80.4717 149.85,78.4717 153.5,76.5C 153.5,76.8333 153.5,77.1667 153.5,77.5C 150.542,81.6911 148.542,86.3578 147.5,91.5C 151.5,90.5 155.5,89.5 159.5,88.5C 160.492,88.3284 161.158,88.6618 161.5,89.5C 160.26,90.6588 158.926,91.6588 157.5,92.5C 154.615,92.1936 151.948,92.5269 149.5,93.5C 148.391,93.4431 147.391,93.1098 146.5,92.5C 142.6,91.5701 138.6,91.2367 134.5,91.5C 134.46,94.8806 134.793,98.2139 135.5,101.5C 135.5,102.833 135.5,104.167 135.5,105.5C 131.563,105.207 127.73,105.54 124,106.5C 115.993,99.572 107.493,93.2387 98.5,87.5C 98.5,86.8333 98.1667,86.5 97.5,86.5C 93.228,84.2256 89.228,81.5589 85.5,78.5C 78.8691,74.5245 72.5358,70.1912 66.5,65.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#c0bbb1",
                    d: "M 153.5,76.5 C 156.5,76.5 159.5,76.5 162.5,76.5C 164.526,80.5813 165.526,84.9146 165.5,89.5C 164.167,89.5 162.833,89.5 161.5,89.5C 161.158,88.6618 160.492,88.3284 159.5,88.5C 157.5,84.8333 155.5,81.1667 153.5,77.5C 153.5,77.1667 153.5,76.8333 153.5,76.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#7c858b",
                    d: "M 153.5,77.5 C 155.5,81.1667 157.5,84.8333 159.5,88.5C 155.5,89.5 151.5,90.5 147.5,91.5C 148.542,86.3578 150.542,81.6911 153.5,77.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.996
                    },
                    fill: "#898a89",
                    d: "M 162.5,76.5 C 167.023,78.0073 171.523,79.674 176,81.5C 177.03,81.8361 177.53,82.5028 177.5,83.5C 177.992,85.8185 178.992,87.8185 180.5,89.5C 181.338,89.8417 181.672,90.5084 181.5,91.5C 178.012,91.7054 174.679,92.5387 171.5,94C 176.66,95.6954 181.66,97.5287 186.5,99.5C 181.93,100.441 177.263,100.774 172.5,100.5C 171.793,98.2186 170.793,96.0519 169.5,94C 165.534,93.1721 161.534,92.6721 157.5,92.5C 158.926,91.6588 160.26,90.6588 161.5,89.5C 162.184,91.1852 163.517,92.1852 165.5,92.5C 168.012,91.2162 168.012,90.2162 165.5,89.5C 165.526,84.9146 164.526,80.5813 162.5,76.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#5c676f",
                    d: "M 65.5,82.5 C 66.8717,83.5116 68.205,84.5116 69.5,85.5C 66.8333,87.5 64.1667,89.5 61.5,91.5C 51.2474,90.3957 41.0808,88.729 31,86.5C 29.9701,86.8361 29.4701,87.5028 29.5,88.5C 28.596,87.791 28.2627,86.791 28.5,85.5C 27.5,85.5 26.5,85.5 25.5,85.5C 37.1667,84.8333 48.8333,84.1667 60.5,83.5C 62.2837,84.7199 63.9504,84.7199 65.5,83.5C 65.5,83.1667 65.5,82.8333 65.5,82.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.018
                    },
                    fill: "#191919",
                    d: "M 177.5,83.5 C 179.539,84.911 180.539,86.911 180.5,89.5C 178.992,87.8185 177.992,85.8185 177.5,83.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#cdcfd0",
                    d: "M 61.5,91.5 C 64.3522,93.0765 67.3522,94.5765 70.5,96C 60.8391,96.4998 51.1724,96.6665 41.5,96.5C 38.0698,95.2862 34.7365,93.7862 31.5,92C 30.1772,91.1841 29.5106,90.0174 29.5,88.5C 29.4701,87.5028 29.9701,86.8361 31,86.5C 41.0808,88.729 51.2474,90.3957 61.5,91.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#7c858b",
                    d: "M 78.5,86.5 C 85.0007,87.3789 91.3341,87.3789 97.5,86.5C 98.1667,86.5 98.5,86.8333 98.5,87.5C 95.9058,93.1859 92.9058,98.6859 89.5,104C 89.7284,104.399 90.0618,104.565 90.5,104.5C 94.7789,107.029 99.1122,109.363 103.5,111.5C 97.296,115.128 90.6293,117.795 83.5,119.5C 80.272,118.019 76.9386,117.019 73.5,116.5C 76.1873,116.664 78.854,116.497 81.5,116C 83.5871,112.492 85.9204,109.158 88.5,106C 88.2716,105.601 87.9382,105.435 87.5,105.5C 87.5,104.833 87.5,104.167 87.5,103.5C 87.9382,103.565 88.2716,103.399 88.5,103C 84.7673,97.6938 81.434,92.1938 78.5,86.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#3c413e",
                    d: "M 91.5,66.5 C 103.427,74.4203 115.094,82.7537 126.5,91.5C 128.604,91.2011 130.604,91.5344 132.5,92.5C 129.75,96.3318 127.25,100.332 125,104.5C 124.667,102.5 124.333,100.5 124,98.5C 114.269,89.9267 104.436,81.5934 94.5,73.5C 92.1496,71.7867 91.1496,69.4534 91.5,66.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#e2730e",
                    d: "M 161.5,89.5 C 162.833,89.5 164.167,89.5 165.5,89.5C 168.012,90.2162 168.012,91.2162 165.5,92.5C 163.517,92.1852 162.184,91.1852 161.5,89.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#b7b5ac",
                    d: "M 146.5,92.5 C 147.265,95.0961 147.599,97.7628 147.5,100.5C 147.5,100.833 147.5,101.167 147.5,101.5C 143.569,102.132 140.235,103.799 137.5,106.5C 137.167,106.5 136.833,106.5 136.5,106.5C 136.784,104.585 136.451,102.919 135.5,101.5C 134.793,98.2139 134.46,94.8806 134.5,91.5C 138.6,91.2367 142.6,91.5701 146.5,92.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.998
                    },
                    fill: "#babbba",
                    d: "M 181.5,91.5 C 184.81,93.4821 187.81,95.8154 190.5,98.5C 189.432,99.4345 188.099,99.7678 186.5,99.5C 181.66,97.5287 176.66,95.6954 171.5,94C 174.679,92.5387 178.012,91.7054 181.5,91.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#353f49",
                    d: "M 146.5,92.5 C 147.391,93.1098 148.391,93.4431 149.5,93.5C 153.167,94.1667 156.833,94.8333 160.5,95.5C 156.624,98.1293 152.29,99.796 147.5,100.5C 147.599,97.7628 147.265,95.0961 146.5,92.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#d0c9c0",
                    d: "M 149.5,93.5 C 151.948,92.5269 154.615,92.1936 157.5,92.5C 161.534,92.6721 165.534,93.1721 169.5,94C 170.793,96.0519 171.793,98.2186 172.5,100.5C 168.52,98.8702 164.52,97.2035 160.5,95.5C 156.833,94.8333 153.167,94.1667 149.5,93.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#7e8182",
                    d: "M 160.5,95.5 C 164.52,97.2035 168.52,98.8702 172.5,100.5C 172.5,101.167 172.167,101.5 171.5,101.5C 163.981,101.175 156.648,101.508 149.5,102.5C 148.833,102.167 148.167,101.833 147.5,101.5C 147.5,101.167 147.5,100.833 147.5,100.5C 152.29,99.796 156.624,98.1293 160.5,95.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#5c666f",
                    d: "M 42.5,97.5 C 52.1724,97.3335 61.8391,97.5002 71.5,98C 66.7133,99.8932 62.0466,102.06 57.5,104.5C 56.6143,105.325 56.281,106.325 56.5,107.5C 55.596,106.791 55.2627,105.791 55.5,104.5C 52.1501,104.665 48.8168,104.498 45.5,104C 43.5494,102.266 42.5494,100.099 42.5,97.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#5d6871",
                    d: "M 87.5,103.5 C 87.5,104.167 87.5,104.833 87.5,105.5C 81.5738,106.774 75.7404,108.441 70,110.5C 69.5,110.167 69,109.833 68.5,109.5C 69.9376,105.167 71.9376,101.167 74.5,97.5C 78.9793,99.2405 83.3126,101.24 87.5,103.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.165
                    },
                    fill: "#070707",
                    d: "M 190.5,98.5 C 192.676,99.7133 193.009,101.38 191.5,103.5C 185.274,105.018 178.94,105.852 172.5,106C 168.352,109.314 164.352,112.814 160.5,116.5C 157.833,124.323 154.667,131.99 151,139.5C 147.796,142.369 144.963,145.535 142.5,149C 139.761,150.026 137.428,151.526 135.5,153.5C 134.609,152.89 133.609,152.557 132.5,152.5C 131.833,152.5 131.167,152.5 130.5,152.5C 130.5,151.833 130.5,151.167 130.5,150.5C 131.167,150.5 131.5,150.167 131.5,149.5C 139.372,146.766 145.372,141.766 149.5,134.5C 150.167,134.5 150.5,134.167 150.5,133.5C 153.099,127.704 155.099,121.704 156.5,115.5C 157.167,115.5 157.5,115.167 157.5,114.5C 157.833,113.5 158.5,112.833 159.5,112.5C 163.5,108.833 167.5,105.167 171.5,101.5C 172.167,101.5 172.5,101.167 172.5,100.5C 177.263,100.774 181.93,100.441 186.5,99.5C 188.099,99.7678 189.432,99.4345 190.5,98.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#cdcfcf",
                    d: "M 147.5,101.5 C 148.167,101.833 148.833,102.167 149.5,102.5C 153.14,105.473 156.473,108.806 159.5,112.5C 158.5,112.833 157.833,113.5 157.5,114.5C 150.833,111.833 144.167,109.167 137.5,106.5C 140.235,103.799 143.569,102.132 147.5,101.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#343e48",
                    d: "M 171.5,101.5 C 167.5,105.167 163.5,108.833 159.5,112.5C 156.473,108.806 153.14,105.473 149.5,102.5C 156.648,101.508 163.981,101.175 171.5,101.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#969798",
                    d: "M 69.5,85.5 C 72.3915,86.4025 75.3915,86.7359 78.5,86.5C 81.434,92.1938 84.7673,97.6938 88.5,103C 88.2716,103.399 87.9382,103.565 87.5,103.5C 83.3126,101.24 78.9793,99.2405 74.5,97.5C 71.9376,101.167 69.9376,105.167 68.5,109.5C 69,109.833 69.5,110.167 70,110.5C 75.7404,108.441 81.5738,106.774 87.5,105.5C 87.9382,105.435 88.2716,105.601 88.5,106C 85.9204,109.158 83.5871,112.492 81.5,116C 78.854,116.497 76.1873,116.664 73.5,116.5C 70.9852,115.737 68.9852,114.237 67.5,112C 64.3771,111.794 61.3771,111.127 58.5,110C 57.6195,109.292 56.9528,108.458 56.5,107.5C 56.281,106.325 56.6143,105.325 57.5,104.5C 62.0466,102.06 66.7133,99.8932 71.5,98C 61.8391,97.5002 52.1724,97.3335 42.5,97.5C 41.8333,97.5 41.5,97.1667 41.5,96.5C 51.1724,96.6665 60.8391,96.4998 70.5,96C 67.3522,94.5765 64.3522,93.0765 61.5,91.5C 64.1667,89.5 66.8333,87.5 69.5,85.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#bfc2c4",
                    d: "M 90.5,104.5 C 100.989,105.041 111.322,105.707 121.5,106.5C 115.431,107.914 109.431,109.581 103.5,111.5C 99.1122,109.363 94.7789,107.029 90.5,104.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#5d6870",
                    d: "M 98.5,87.5 C 107.493,93.2387 115.993,99.572 124,106.5C 127.73,105.54 131.563,105.207 135.5,105.5C 135.5,104.167 135.5,102.833 135.5,101.5C 136.451,102.919 136.784,104.585 136.5,106.5C 135.724,113.137 135.391,119.804 135.5,126.5C 129.121,126.038 122.788,125.538 116.5,125C 118.606,128.039 120.106,131.205 121,134.5C 116.332,132.082 111.499,130.082 106.5,128.5C 106.5,128.167 106.5,127.833 106.5,127.5C 106.5,126.833 106.833,126.5 107.5,126.5C 110.315,126.796 112.982,125.796 115.5,123.5C 114.639,121.089 113.306,119.089 111.5,117.5C 115.841,114.189 119.174,110.522 121.5,106.5C 111.322,105.707 100.989,105.041 90.5,104.5C 90.0618,104.565 89.7284,104.399 89.5,104C 92.9058,98.6859 95.9058,93.1859 98.5,87.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#959697",
                    d: "M 136.5,106.5 C 136.833,106.5 137.167,106.5 137.5,106.5C 144.167,109.167 150.833,111.833 157.5,114.5C 157.5,115.167 157.167,115.5 156.5,115.5C 150.409,118.408 144.409,121.574 138.5,125C 137.619,125.708 136.953,126.542 136.5,127.5C 131.952,129.107 127.619,131.274 123.5,134C 127.152,134.499 130.818,134.665 134.5,134.5C 131.038,135.482 127.371,135.815 123.5,135.5C 121.308,139.098 120.308,143.098 120.5,147.5C 119.869,149.934 118.869,152.268 117.5,154.5C 116.833,155.5 116.167,156.5 115.5,157.5C 114.18,156.058 112.514,155.392 110.5,155.5C 108.704,154.207 107.037,152.707 105.5,151C 108.833,150.667 112.167,150.333 115.5,150C 107.624,149.113 99.7911,147.946 92,146.5C 90.6244,146.316 89.7911,145.649 89.5,144.5C 95.1404,139.195 100.807,133.861 106.5,128.5C 111.499,130.082 116.332,132.082 121,134.5C 120.106,131.205 118.606,128.039 116.5,125C 122.788,125.538 129.121,126.038 135.5,126.5C 135.391,119.804 135.724,113.137 136.5,106.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#56595b",
                    d: "M 121.5,106.5 C 119.174,110.522 115.841,114.189 111.5,117.5C 106.167,119.167 100.833,120.833 95.5,122.5C 91.2508,122.079 87.2508,121.079 83.5,119.5C 90.6293,117.795 97.296,115.128 103.5,111.5C 109.431,109.581 115.431,107.914 121.5,106.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#56585a",
                    d: "M 156.5,115.5 C 155.099,121.704 153.099,127.704 150.5,133.5C 145.597,132.048 140.93,130.048 136.5,127.5C 136.953,126.542 137.619,125.708 138.5,125C 144.409,121.574 150.409,118.408 156.5,115.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#858689",
                    d: "M 111.5,117.5 C 110.16,120.529 108.827,123.529 107.5,126.5C 106.833,126.5 106.5,126.833 106.5,127.5C 102.721,126.442 99.0541,125.109 95.5,123.5C 95.5,123.167 95.5,122.833 95.5,122.5C 100.833,120.833 106.167,119.167 111.5,117.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#37414b",
                    d: "M 111.5,117.5 C 113.306,119.089 114.639,121.089 115.5,123.5C 112.982,125.796 110.315,126.796 107.5,126.5C 108.827,123.529 110.16,120.529 111.5,117.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#343e48",
                    d: "M 95.5,123.5 C 99.0541,125.109 102.721,126.442 106.5,127.5C 106.5,127.833 106.5,128.167 106.5,128.5C 100.807,133.861 95.1404,139.195 89.5,144.5C 89.1667,144.5 88.8333,144.5 88.5,144.5C 90.2382,137.285 92.5715,130.285 95.5,123.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#ced0d0",
                    d: "M 136.5,127.5 C 140.93,130.048 145.597,132.048 150.5,133.5C 150.5,134.167 150.167,134.5 149.5,134.5C 144.5,134.5 139.5,134.5 134.5,134.5C 130.818,134.665 127.152,134.499 123.5,134C 127.619,131.274 131.952,129.107 136.5,127.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#7b8389",
                    d: "M 134.5,134.5 C 139.5,134.5 144.5,134.5 149.5,134.5C 145.372,141.766 139.372,146.766 131.5,149.5C 128.406,145.074 125.739,140.407 123.5,135.5C 127.371,135.815 131.038,135.482 134.5,134.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#36414b",
                    d: "M 123.5,135.5 C 125.739,140.407 128.406,145.074 131.5,149.5C 131.5,150.167 131.167,150.5 130.5,150.5C 126.881,150.119 123.548,149.119 120.5,147.5C 120.308,143.098 121.308,139.098 123.5,135.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#5d676f",
                    d: "M 88.5,144.5 C 88.8333,144.5 89.1667,144.5 89.5,144.5C 89.7911,145.649 90.6244,146.316 92,146.5C 99.7911,147.946 107.624,149.113 115.5,150C 112.167,150.333 108.833,150.667 105.5,151C 107.037,152.707 108.704,154.207 110.5,155.5C 107.085,162 103.418,168.333 99.5,174.5C 101.095,168.717 103.095,163.051 105.5,157.5C 103.5,156.833 101.5,156.167 99.5,155.5C 101.316,154.185 102.983,152.685 104.5,151C 99.8333,150.333 95.1667,150.333 90.5,151C 91.4118,153.205 92.7451,155.038 94.5,156.5C 94.5,157.167 94.1667,157.5 93.5,157.5C 83.3942,165.095 73.3942,172.928 63.5,181C 62.8333,181.667 62.1667,181.667 61.5,181C 69.3025,172.197 77.4691,163.697 86,155.5C 87.1821,153.656 88.3488,151.823 89.5,150C 89.1918,148.541 88.5251,147.374 87.5,146.5C 87.8333,145.833 88.1667,145.167 88.5,144.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.999
                    },
                    fill: "#5e686e",
                    d: "M 120.5,147.5 C 123.548,149.119 126.881,150.119 130.5,150.5C 130.5,151.167 130.5,151.833 130.5,152.5C 129.039,151.314 127.705,151.314 126.5,152.5C 123.402,152.756 120.402,153.422 117.5,154.5C 118.869,152.268 119.869,149.934 120.5,147.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.961
                    },
                    fill: "#b3afa3",
                    d: "M 130.5,152.5 C 131.167,152.5 131.833,152.5 132.5,152.5C 133.306,153.728 134.306,154.728 135.5,155.5C 132.145,155.31 129.145,154.31 126.5,152.5C 127.705,151.314 129.039,151.314 130.5,152.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.988
                    },
                    fill: "#686b65",
                    d: "M 132.5,152.5 C 133.609,152.557 134.609,152.89 135.5,153.5C 137.292,153.366 138.958,153.699 140.5,154.5C 139.789,156.03 138.789,157.363 137.5,158.5C 134.932,158.594 133.432,159.928 133,162.5C 131.794,159.162 132.96,157.329 136.5,157C 135.944,156.617 135.611,156.117 135.5,155.5C 134.306,154.728 133.306,153.728 132.5,152.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.176
                    },
                    fill: "#030404",
                    d: "M 110.5,155.5 C 112.514,155.392 114.18,156.058 115.5,157.5C 117.986,159.155 119.986,161.322 121.5,164C 119.419,166.818 119.085,169.818 120.5,173C 121.167,173.667 121.833,173.667 122.5,173C 120.775,166.133 122.608,164.966 128,169.5C 129.505,171.298 129.672,173.132 128.5,175C 132.204,174.516 132.538,172.849 129.5,170C 132.657,170.176 134.157,172.009 134,175.5C 135.689,173.68 135.855,171.68 134.5,169.5C 137.686,172.399 138.02,175.566 135.5,179C 132.207,179.826 128.874,180.326 125.5,180.5C 127.089,177.036 126.589,174.036 124,171.5C 125.225,174.331 124.559,176.664 122,178.5C 119.086,177.252 117.253,175.086 116.5,172C 117.791,169.95 118.291,167.783 118,165.5C 116.316,163.649 114.483,161.982 112.5,160.5C 111.522,160.977 110.689,161.643 110,162.5C 105.922,170.991 101.588,179.324 97,187.5C 95.786,189.049 94.286,190.215 92.5,191C 77.4054,197.181 62.9054,196.014 49,187.5C 48.1742,184.788 48.6742,182.455 50.5,180.5C 50.238,181.978 50.5713,183.311 51.5,184.5C 56.3296,185.951 60.9962,187.617 65.5,189.5C 70.2981,190.744 74.9648,190.744 79.5,189.5C 82.9419,190.172 85.6086,189.172 87.5,186.5C 90.1569,186.838 92.4902,186.171 94.5,184.5C 96.705,181.423 98.3716,178.09 99.5,174.5C 103.418,168.333 107.085,162 110.5,155.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#555759",
                    d: "M 94.5,156.5 C 96.0481,156.821 96.7148,157.821 96.5,159.5C 89.8331,168.856 83.4997,178.523 77.5,188.5C 77.9569,189.298 78.6236,189.631 79.5,189.5C 74.9648,190.744 70.2981,190.744 65.5,189.5C 68.4045,187.101 71.2379,184.435 74,181.5C 80.2688,173.286 86.7688,165.286 93.5,157.5C 94.1667,157.5 94.5,157.167 94.5,156.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.99
                    },
                    fill: "#2d363e",
                    d: "M 140.5,154.5 C 143.802,155.294 147.135,155.96 150.5,156.5C 149.645,158.787 149.478,161.12 150,163.5C 148.334,164.34 148.167,163.84 149.5,162C 148.25,159.375 146.25,158.375 143.5,159C 146.47,162.145 145.97,164.645 142,166.5C 141.667,164.953 142.167,163.62 143.5,162.5C 142.833,159.167 140.833,157.833 137.5,158.5C 138.789,157.363 139.789,156.03 140.5,154.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#898f8c",
                    d: "M 99.5,174.5 C 98.3716,178.09 96.705,181.423 94.5,184.5C 92.4902,186.171 90.1569,186.838 87.5,186.5C 90.2985,177.438 93.2985,168.438 96.5,159.5C 96.7148,157.821 96.0481,156.821 94.5,156.5C 92.7451,155.038 91.4118,153.205 90.5,151C 95.1667,150.333 99.8333,150.333 104.5,151C 102.983,152.685 101.316,154.185 99.5,155.5C 101.5,156.167 103.5,156.833 105.5,157.5C 103.095,163.051 101.095,168.717 99.5,174.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 0.132
                    },
                    fill: "#040505",
                    d: "M 126.5,152.5 C 129.145,154.31 132.145,155.31 135.5,155.5C 135.611,156.117 135.944,156.617 136.5,157C 132.96,157.329 131.794,159.162 133,162.5C 133.432,159.928 134.932,158.594 137.5,158.5C 140.833,157.833 142.833,159.167 143.5,162.5C 142.167,163.62 141.667,164.953 142,166.5C 145.97,164.645 146.47,162.145 143.5,159C 146.25,158.375 148.25,159.375 149.5,162C 148.167,163.84 148.334,164.34 150,163.5C 149.478,161.12 149.645,158.787 150.5,156.5C 153.859,160.675 153.525,164.842 149.5,169C 146.36,168.418 143.36,168.751 140.5,170C 139.351,168.396 139.351,166.73 140.5,165C 140.387,163.72 139.72,162.887 138.5,162.5C 136.599,164.006 134.932,165.673 133.5,167.5C 132.29,167.068 131.29,166.401 130.5,165.5C 130.784,163.123 130.784,160.956 130.5,159C 128.722,158.296 126.888,157.796 125,157.5C 123.301,157.387 122.134,158.053 121.5,159.5C 119.413,158.415 118.08,156.749 117.5,154.5C 120.402,153.422 123.402,152.756 126.5,152.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#828688",
                    d: "M 86.5,146.5 C 86.8333,146.5 87.1667,146.5 87.5,146.5C 88.5251,147.374 89.1918,148.541 89.5,150C 88.3488,151.823 87.1821,153.656 86,155.5C 77.4691,163.697 69.3025,172.197 61.5,181C 62.1667,181.667 62.8333,181.667 63.5,181C 73.3942,172.928 83.3942,165.095 93.5,157.5C 86.7688,165.286 80.2688,173.286 74,181.5C 71.2379,184.435 68.4045,187.101 65.5,189.5C 60.9962,187.617 56.3296,185.951 51.5,184.5C 50.5713,183.311 50.238,181.978 50.5,180.5C 62.1716,168.829 74.1716,157.495 86.5,146.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#5c666f",
                    d: "M 96.5,159.5 C 93.2985,168.438 90.2985,177.438 87.5,186.5C 85.6086,189.172 82.9419,190.172 79.5,189.5C 78.6236,189.631 77.9569,189.298 77.5,188.5C 83.4997,178.523 89.8331,168.856 96.5,159.5 Z"
                })
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("g", {
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                    style: {
                        opacity: 1
                    },
                    fill: "#3b4346",
                    d: "M 117.5,154.5 C 118.08,156.749 119.413,158.415 121.5,159.5C 124.328,161.748 127.328,163.748 130.5,165.5C 131.29,166.401 132.29,167.068 133.5,167.5C 133.833,168.167 134.167,168.833 134.5,169.5C 135.855,171.68 135.689,173.68 134,175.5C 134.157,172.009 132.657,170.176 129.5,170C 132.538,172.849 132.204,174.516 128.5,175C 129.672,173.132 129.505,171.298 128,169.5C 122.608,164.966 120.775,166.133 122.5,173C 121.833,173.667 121.167,173.667 120.5,173C 119.085,169.818 119.419,166.818 121.5,164C 119.986,161.322 117.986,159.155 115.5,157.5C 116.167,156.5 116.833,155.5 117.5,154.5 Z"
                })
            })
        ]
    }), B3e = ({ size: e = 42, className: t, variant: r, ...n })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: e,
        height: e,
        fill: "none",
        className: t,
        viewBox: "0 0 38.687 38.002",
        ...n,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                clipPath: "url(#a)",
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#b)",
                        d: "M29.895 0H8.791C3.937 0 0 3.867 0 8.637v20.728c0 4.77 3.937 8.637 8.792 8.637h21.102c4.856 0 8.793-3.867 8.793-8.637V8.637C38.687 3.867 34.75 0 29.895 0Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#c)",
                        d: "M29.895 0H8.791C3.937 0 0 3.867 0 8.637v20.728c0 4.77 3.937 8.637 8.792 8.637h21.102c4.856 0 8.793-3.867 8.793-8.637V8.637C38.687 3.867 34.75 0 29.895 0Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#d)",
                        d: "M29.895 0H8.791C3.937 0 0 3.867 0 8.637v20.728c0 4.77 3.937 8.637 8.792 8.637h21.102c4.856 0 8.793-3.867 8.793-8.637V8.637C38.687 3.867 34.75 0 29.895 0Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "url(#e)",
                        d: "M29.895 0H8.791C3.937 0 0 3.867 0 8.637v20.728c0 4.77 3.937 8.637 8.792 8.637h21.102c4.856 0 8.793-3.867 8.793-8.637V8.637C38.687 3.867 34.75 0 29.895 0Z"
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        fill: "#F5F5F5",
                        d: "M15.892 29.19v-8.814l8.719 8.815h4.85v-.23l-10.029-10.04 9.258-9.524v-.112h-4.883L15.892 17.7V9.285H11.96V29.19h3.931Z"
                    })
                ]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("defs", {
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("radialGradient", {
                        id: "c",
                        cx: 0,
                        cy: 0,
                        r: 1,
                        gradientTransform: "matrix(43.7508 -43.21048 43.85415 44.40253 1.848 36.562)",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                stopColor: "#232DE3"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: 1,
                                stopColor: "#232DE3",
                                stopOpacity: 0
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("radialGradient", {
                        id: "d",
                        cx: 0,
                        cy: 0,
                        r: 1,
                        gradientTransform: "matrix(-29.03064 -25.27423 38.4475 -44.16182 36.603 37.785)",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                stopColor: "#8B4DFF"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: 1,
                                stopColor: "#8B4DFF",
                                stopOpacity: 0
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("radialGradient", {
                        id: "e",
                        cx: 0,
                        cy: 0,
                        r: 1,
                        gradientTransform: "matrix(0 29.9615 -74.0047 0 19.021 .282)",
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                stopColor: "#24D5FF"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: 1,
                                stopColor: "#1BB8FF",
                                stopOpacity: 0
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("linearGradient", {
                        id: "b",
                        x1: 19.343,
                        x2: 19.343,
                        y1: 0,
                        y2: 38.002,
                        gradientUnits: "userSpaceOnUse",
                        children: [
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                stopColor: "#1FD1FF"
                            }),
                            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("stop", {
                                offset: 1,
                                stopColor: "#1BB8FF"
                            })
                        ]
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("clipPath", {
                        id: "a",
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                            fill: "#fff",
                            d: "M0 0h38.687v38.002H0z"
                        })
                    })
                ]
            })
        ]
    }), U8e = ({ size: e, className: t, variant: r, walletName: n })=>n === jl ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(d3e, {
        size: e,
        className: t,
        variant: r
    }) : n === zd ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(p3e, {
        size: e,
        className: t,
        variant: r
    }) : n === jd ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(l3e, {
        size: e,
        className: t,
        variant: r
    }) : n === _u ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(y3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Fd ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(g3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Ll ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(I3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Fl ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(f3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Dl ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(h3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Ul ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(BB, {
        size: e,
        className: t,
        variant: r
    }) : n === Mc ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(m3e, {
        size: e,
        className: t,
        variant: r
    }) : n === zl ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(O3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Ld ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(k3e, {
        size: e,
        className: t,
        variant: r
    }) : n === Hl ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(B3e, {
        size: e,
        className: t,
        variant: r
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(BB, {
        size: e,
        className: t,
        variant: r
    });
function D8e(e) {
    const { client: t } = iu(({ client: s })=>({
            client: s
        })), r = e == null ? void 0 : e.queryOptions, n = async ({ pageParam: s = (t == null ? void 0 : t.$network.get()) === "mainnet" ? 16 : 0 })=>{
        if (!t) throw new Error("Client not found");
        return await t.modules.alkanes.getAlkanes({
            limit: (e == null ? void 0 : e.batchSize) ?? 10,
            offset: s
        });
    }, { data: i1, ...o } = u3e({
        ...r,
        queryKey: [
            "fetch-alkanes",
            t == null ? void 0 : t.$network.get(),
            e == null ? void 0 : e.batchSize
        ],
        initialPageParam: (r == null ? void 0 : r.initialPageParam) ?? (t == null ? void 0 : t.$network.get()) === "mainnet" ? 16 : 0,
        getNextPageParam: (s, c)=>{
            if (!(s.length === 0 && c.flat().length)) return s.reduce((l, u)=>Math.max(l, Number(u.id.tx)), (t == null ? void 0 : t.$network.get()) === "mainnet" ? 15 : 0) + 1;
        },
        queryFn: n,
        refetchInterval: 1e3 * 60 * 10
    });
    return {
        data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])(()=>i1 == null ? void 0 : i1.pages.flat(), [
            i1
        ]),
        ...o
    };
}
function j8e(e) {
    const { id: t, queryOptions: r } = e.block ? {
        id: e
    } : e, { client: n, network: i1 } = iu(({ client: s, network: c })=>({
            client: s,
            network: c
        })), o = async ()=>await (n == null ? void 0 : n.modules.alkanes.getAlkaneById(t)) ?? null;
    return Zb({
        refetchInterval: 1e3 * 60 * 10,
        ...r,
        queryKey: [
            "use-alkane-token",
            i1,
            t
        ],
        queryFn: o
    });
}
function F8e() {
    const { address: e, paymentAddress: t, accounts: r, publicKey: n } = iu(({ address: i1, paymentAddress: o, accounts: a, publicKey: s })=>({
            address: i1,
            paymentAddress: o,
            accounts: a,
            publicKey: s
        }));
    return e ? {
        addresses: r,
        payment: t,
        ordinals: e,
        publicKey: n
    } : void 0;
}
function z8e(e, t) {
    const r = iu((n)=>{
        var i1;
        return (i1 = n.client) == null ? void 0 : i1.$store;
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (!r) return;
        let n;
        const i1 = r.subscribe((o, a, s)=>{
            s === "accounts" && (Wj(o.accounts, a == null ? void 0 : a.accounts) || (n == null || n(), n = e()));
        });
        return ()=>{
            i1(), n == null || n();
        };
    }, [
        r,
        e,
        ...t
    ]);
}
function L8e(e, t) {
    if (typeof e == "string" && t === void 0) throw Error("Invalid argument received, 'address' cannot be undefined");
    const { client: r, network: n } = iu(({ client: l, network: u })=>({
            client: l,
            network: u
        })), { address: i1, queryOptions: o, protocol: a } = typeof e == "string" ? {
        address: t,
        protocol: e
    } : e, s = async ()=>{
        if (!r) throw new Error("Client not found");
        return a === G8 ? await r.dataSourceManager.getAlkanesByAddress(i1) : {};
    };
    return Zb({
        refetchInterval: 1e3 * 60 * 10,
        // 10 minutes
        ...o,
        queryKey: [
            "address-tokens",
            n,
            a,
            i1
        ],
        queryFn: s
    });
}
function H8e(e) {
    const { client: t, address: r, network: n } = iu(({ client: l, address: u, network: f })=>({
            client: l,
            address: u,
            network: f
        }));
    if (typeof e == "string" && e !== Md) throw Error(`Invalid parameters. Expected \`${Md}\`, got: \`${e}\``);
    const { protocol: i1, tokenId: o, queryOptions: a } = e === Md ? {
        protocol: Md
    } : e, s = async ()=>{
        if (r) {
            if (i1 === "btc") {
                const l = await (t == null ? void 0 : t.getBalance());
                if (!l) throw new Error("Balance not found");
                return BigInt(l);
            } else if (!o) throw new Error("Token ID is required");
        }
        return BigInt(0);
    };
    return Zb({
        staleTime: 1e3 * 60 * 5,
        // 5 minutes
        refetchInterval: 1e3 * 60 * 10,
        // 1 minute
        ...a,
        queryKey: [
            "user-balance",
            n,
            r,
            i1,
            o
        ],
        queryFn: s
    });
}
function K8e(e) {
    const { client: t, network: r } = iu(({ client: s, network: c })=>({
            client: s,
            network: c
        })), n = async ()=>await (t == null ? void 0 : t.dataSourceManager.getRecommendedFees()) ?? {
            minFee: 0,
            fastFee: 1
        }, { data: i1, isPending: o, error: a } = Zb({
        staleTime: 1e3 * 60 * 5,
        // 5 minutes
        refetchInterval: 1e3 * 60 * 1,
        // 1 minute
        ...e == null ? void 0 : e.queryOptions,
        queryKey: [
            "mempool-fees",
            r
        ],
        queryFn: n
    });
    return {
        data: i1,
        isPending: o,
        error: a
    };
}
function q8e() {
    return iu((e)=>e.client);
}
function V8e() {
    return iu((e)=>e.connect);
}
function W8e() {
    const { client: e, provider: t } = iu(({ client: r, provider: n })=>({
            client: r,
            provider: n
        }));
    if (t) return e == null ? void 0 : e.$providerMap[t];
}
;
}),
]);

//# sourceMappingURL=node_modules_%40omnisat_lasereyes-react_dist_index_7163e96d.js.map